#!/bin/bash --noprofile

# This script bootstraps Specware4.
# That is,
#  - it saves the old generated Specware4.lisp and Specware4.dxl (ie world)
#  - it starts Specware4 
#      - it first tries to run a lisp session with an existing dxl image
#      - if that fails it tries to load Specware from previously generated lisp
#  - applies Specware to itself (sw "/Applications/Specware/Specware4")
#     to generate a new Specware4.lisp,
#  - starts a fresh lisp session
#  - loads the new Specware (under Handwritten/Lisp, (load "Specware4.lisp"))
#    (this compiles everything)
#  - starts a fresh lisp session again
#  - loads the new Specware (under Handwritten/Lisp, (load "Specware4.lisp"))
#  - dumps a world into the bin directory

# Perhaps there should be a different script for bootstrapping from lisp
# (bootstrap-from-lisp?).

# The --noprofile inhibits loading of ~/.bash_profile and ~/.profile
# files. See "man bash" for details. The 'set -v' turns on echoing of
# lines read. This will be removed later.

act='bootstrap'

PATH=/bin:/usr/bin:/etc:/sbin:/usr/sbin

# set -v

# Test whether SPECWARE4 has been set
if [ -z "$SPECWARE4" ]; then
    echo "Failed to $act, SPECWARE4 environment variable not set" 2>&1
    exit 1
fi

# Test whether SPECWARE4 is a directory
if [ ! -d "$SPECWARE4" ]; then
   echo "Failed to $act, $SPECWARE4 is not a directory" 2>&1
   exit 1
fi

# Ensure SPECWARE4 is set to full pathname:
case "$SPECWARE4" in
    /*) : ok;;
    *)  SPECWARE="`pwd`/$SPECWARE4";;
esac

if [ ! -d "$SPECWARE4"/Applications/Specware ]; then
   echo "Failed to $act: could not find directory $SPECWARE4/Applications/Specware" 2>&1
   exit 1
fi

echo cd "$SPECWARE4"/Applications/Specware
cd "$SPECWARE4"/Applications/Specware

# Try to find lisp executable:

if [ -z "$LISP" ]; then
   for L in /usr/local/acl/acl62/alisp /usr/local/acl/acl61/alisp /usr/local/acl/acl501/lisp; do
      if [ -x "$L" ]; then
         export LISP="$L"; break
      fi
   done
fi

if [ -z "$LISP" ]; then
   echo "Failed to $act, no LISP executable found" 2>&1
   exit 1
fi

if [ ! -x "$LISP" ]; then
   echo "Failed to $act, $LISP is not executable" 2>&1
   exit 1
fi

echo " "
if [ -f lisp/Specware4.lisp ]; then
  echo "Saving previous specware lisp file ..."
  echo "cp -p -f lisp/Specware4.lisp lisp/Specware4-save.lisp"
  cp -p -f lisp/Specware4.lisp lisp/Specware4-save.lisp
else
  echo "Note: No previous specware lisp file."
fi
echo " "
if [ -f bin/linux/Specware4.dxl ]; then
  echo "Saving previous specware image ..."
  echo "cp -p -f bin/linux/Specware4.dxl bin/linux/Specware4-save.dxl"
  cp -p -f bin/linux/Specware4.dxl bin/linux/Specware4-save.dxl
else
  echo "Note: No previous specware image."
fi
echo " "

# Note the use of the <<-XXXX in the following. The - means that preceeding
# tabs are removed.  Thus the tabs that follow are significant. If you
# change them to spaces, the end of the "here-document" is not recognized
# (the XXXX).

# Is there a way to inhibit all the warnings (eg unused variable)
# when Lisp loads?

export SWPATH="$SPECWARE4":.
EXIT_ON_ERRORS="$SPECWARE4"/Applications/Specware/bin/linux/exit-on-errors

echo "\$SWPATH=$SWPATH"

# All the toplevel routines that activate Specware return a boolean value.
# They return true if the call to Specware succeeded without activating
# Specware's toplevel handler. They return false (lisp nil) when the
# handler is invoked. If, when bootrapping, the toplevel handler is
# called, then we abort the bootstrap.

if [ -f lisp ]; then
   echo "Failed to $act, $SPECWARE4/Applications/Specware/lisp is not a directory" 2>&1
   exit 1
fi


if [   -f bin/linux/Specware4.dxl \
     -a \(   \( ! -f Specware4-base.lisp \) \
         -o bin/linux/Specware4.dxl -nt Specware4-base.lisp \) ]; then
	echo "Bootstrapping from existing Specware image: bin/linux/Specware4.dxl"
        echo " "
	bin/linux/Specware4-text -batch <<-XXXX
                :swpath
		(load "$EXIT_ON_ERRORS") ; bin/linux/exit-on-errors
		(enlarge-stack)
		(exiting-on-errors 
		  (if (sw "/Applications/Specware/Specware4")
		    (exit 0)
		    (exit 11)))
	XXXX
        RC=$?
else
        if [   -f lisp/Specware4.lisp \
	     -a \(    \( ! -f Specware4-base.lisp \) \
                 -o lisp/Specware4.lisp -nt Specware4-base.lisp \) ]; then
		if [ -f bin/linux/Specware4.dxl ]; then
  		    echo "Cvs saved lisp, Specware4-base.lisp, is newer than bin/linux/Specware4.dxl."
		fi
		echo "Bootstrapping from previously generated lisp: lisp/Specware4.lisp"
                echo " "
		cd Handwritten/Lisp
		$LISP -batch <<-XXXX
			(load "$EXIT_ON_ERRORS")
			(enlarge-stack)
			(exiting-on-errors 
			  (load "Specware4.lisp")
			  (if (sw "/Applications/Specware/Specware4")
			    (exit 0)
			    (exit 22)))
		XXXX
                RC=$?
	else
                if [ -f Specware4-base.lisp ]; then
			if [ -f bin/linux/Specware4.dxl ]; then
			    echo "Cvs saved lisp, Specware4-base.lisp, is newer than bin/linux/Specware4.dxl."
			fi
			if [ -f lisp/Specware4.lisp ]; then
			    echo "Cvs saved lisp, Specware4-base.lisp, is newer than both lisp/Specware4.lisp."
			fi
                        echo "Bootstrapping from cvs saved lisp: Specware4-base.lisp"
			if [ ! -d lisp ]; then
			    echo "mkdir lisp"
			    mkdir lisp
			fi

			echo "cp -p -f Specware4-base.lisp lisp/Specware4.lisp"
			cp -p -f Specware4-base.lisp lisp/Specware4.lisp
			echo " "
			cd Handwritten/Lisp
			$LISP -batch <<-XXXX
			    (load "$EXIT_ON_ERRORS")
			    (enlarge-stack)
			    (exiting-on-errors 
			      (load "Specware4.lisp")
			      (if (sw "/Applications/Specware/Specware4")
				(exit 0)
			        (exit 33)))
			XXXX
			RC=$?
		else
		    # You should never end up here.
		    # If you do then cvs checkout/update did not correctly
		    # provide you with a Specware4-base.lisp.
		    echo " "
		    echo "Bootstrap failed"
		    echo "Could not find bin/linux/Specware4.dxl or lisp/Specware4.lisp or Specware4-base.lisp"
		    echo "under $SPECWARE4/Applications/Specware"
		    exit 1
		fi
	fi
fi

# If the bootstrap failed (non-zero exit status) then we abort.
if [ $RC -ne 0 ]; then
  echo ""
  echo "Bootstrap failed with code $RC, exiting ..."
  exit $RC
fi

echo " "
echo cd "$SPECWARE4"/Applications/Specware/Handwritten/Lisp
cd "$SPECWARE4"/Applications/Specware/Handwritten/Lisp

# We load the new Specware4.lisp twice, each in a fresh lisp session. The
# first time compiles everything.  As we have just generated a new
# lisp file for Specware, we are certain something needs to be compiled.
# We could do the load and compile up above in the lisp that generated it,
# but that seems weird to me ...

echo " "
echo "Loading Specware ... (to compile)"
echo " "
$LISP -batch <<-XXXX
	(load "$EXIT_ON_ERRORS")
	(exiting-on-errors 
	  (load "Specware4.lisp"))
XXXX
RC=$?

# If the load failed (non-zero exit status) then we abort.
if [ $RC -ne 0 ]; then
  echo ""
  echo "First load failed with code $RC, exiting ..."
  exit $RC
fi

# The second time is just to do the dumplisp. If we do it in one
# go, the generated dxl file is almost 4 times larger.
#
# I once added a (gc) between the load and the dumplisp, and the dxl
# file became 10k bigger. Go figure.

# People who want to avoid lots of line breaks can set *DEFAULT-RIGHT-MARGIN* 
# in their lisp init.

# Rebuild each time.  A bit redundant, but ensures compatibility...
# big-alisp.dxl will have a larger lisp heap than the default alisp image.
$LISP -batch <<-XXXX
	(build-lisp-image "big-alisp.dxl" :lisp-heap-start #x48000000 :oldspace #x2000000)
XXXX


echo " "
echo "Loading Specware ... (for dumplisp)"
echo " "
$LISP -I big-alisp.dxl -batch <<-XXXX
	(load "$EXIT_ON_ERRORS")
	(set-gc-parameters t)
	(exiting-on-errors 
	  (load "Specware4.lisp"))
	(compact-memory t)
	(let (#+ALLEGRO (EXCL::*DEFAULT-RIGHT-MARGIN* 1000))
	  (excl::dumplisp :name "$SPECWARE4/Applications/Specware/bin/linux/Specware4.dxl"))
XXXX
RC=$?

# If the load failed (non-zero exit status) then we abort.
if [ $RC -ne 0 ]; then
  echo ""
  echo "Second load failed with code $RC, exiting ..."
  exit $RC
fi

cd "$SPECWARE4"/Applications/Specware/lisp
if cmp -s Specware4.lisp Specware4-save.lisp; then
  echo " "
  echo "The bootstrap reached a fixed point"
fi
