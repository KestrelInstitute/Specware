(defpackage :Script)
(defpackage :SWShell)
(in-package :SWShell)

(defvar *transform-help-strings* '(("at" . "[op] Focuses on definition of op")
				   ("simplify" . "[rules] Applies rewriting simplifier with supplied rules.")
				   ("fold" . "[op] folds first occurrence of definition of op")
				   ("unfold" . "[op] unfolds first occurrence of op")
				   ("lr" . "[thm] Applies theorem as a rewrite in left-to-right direction")
				   ("rl" . "[thm] Applies theorem as a rewrite in right-to-left direction")
				   ("simp-standard" . "Applies standard simplifier")
				   ("ss" . "Applies standard simplifier")
				   ("partial-eval" . "Evaluate closed sub-expressions")
				   ("pe" . "Evaluate closed sub-expressions")
				   ("abstract-cse" . "Abstract Common Sub-Expressions")
				   ("cse" . "Abstract Common Sub-Expressions")
				   ("pc"   . "Print current expression")
				   ("proc" . "[unit-term} Restart transformation on processed spec")
				   ("p" . "[unit-term} Restart transformation on processed spec")
				   ("trace-rewrites" . "Print trace for individual rewrites")
				   ("trr" . "Print trace for individual rewrites")
				   ("untrace-rewrites" . "Turn off printing trace for individual rewrites")
				   ("untrr" . "Turn off printing trace for individual rewrites")
				   ("undo" . "[n] Undo n levels (1 with no argument)")
				   ("done" . "Print script and return to normal shell")
				   ))


(defvar *transform-spec*)
(defvar *transform-term*)
(defvar *transform-commands*)
(defvar *undo-stack*)

(defun initialize-transform-session (spc)
  (setq *transform-spec* spc)
  (setq *transform-term* nil)
  (setq *transform-commands* nil)
  (setq *undo-stack* nil)
  (setq *prompt* "** ")
  (emacs::eval-in-emacs "(setq *sw-slime-prompt* \"** \")"))

(defun push-state ()
  (push (list *transform-term* *transform-commands*) *undo-stack*))

(defvar *print-undone-commands* t)

(defun pop-state ()
  (let ((last-state (pop *undo-stack*)))
    (setq *transform-term* (first last-state))
    (setq *transform-commands* (second last-state))))

(defun print-current-term ()
  (if (null *transform-term*)
      (princ "No term chosen")
      (princ (AnnSpecPrinter::printTerm *transform-term*)))
  (values))

(defun previous-multi-command (acts)
  (when (null *transform-commands*)
    (error "Multi-step processing command not found!"))
  (let ((prev (pop *transform-commands*)))
    (if (functionp prev)
	(funcall prev acts)
	(previous-multi-command (cons prev acts)))))

(defun finish-previous-multi-command ()
  (when (and (not (null *transform-commands*))
	     (loop for x in *transform-commands* thereis (functionp x)))
    (let ((prev-result (previous-multi-command nil)))
      (when prev-result
	(push prev-result *transform-commands*)))))

(defun parse-qid (qid-str)
  (let* ((syms (String-Spec::splitStringAt-2 (String-Spec::removeWhitesPace qid-str) "."))
	 (len (length syms)))
    (if (= len 1)
	(MetaSlang::mkUnQualifiedId (first syms))
	(if (= len 2)
	    (MetaSlang::mkQualifiedId-2 (first syms) (second syms))
	    nil))))

(defun interpret-command (command)
  (if (null *transform-term*)
      (princ "No term chosen! (Use \"at\" command)")
      (let ((new-term (Script::interpretTerm-3 *transform-spec* command *transform-term*)))
	(if (MetaSlang::equalTerm?-2 *transform-term* new-term)
	    (format t "No effect!")
	    (progn 
	      (push-state)
	      (setq *transform-term* new-term)
	      (push command *transform-commands*)
	      (print-current-term)))
	))
  (values))

(defun find-op-def (qid)
  (let ((result (Script::getOpDef-2 *transform-spec* qid)))
    (cdr result)))

(defun at-command (qid)
  (finish-previous-multi-command)
  (let ((new-term (find-op-def qid)))
    (if (null new-term)
	()
	(progn
	  (push-state)
	  (setq *transform-term* new-term)
	  (push #'(lambda (future-steps)
		    (if (null future-steps)
			nil
			(Script::mkAt-2 qid future-steps)))
		*transform-commands*)
	  (print-current-term)))
    (values)))

(defun apply-command (qid constr-fn)
  (interpret-command (Script::mkApply (list (funcall constr-fn (parse-qid qid))))))

(defun simplify-command (argstr)
  (let* ((words (and argstr
		     (String-Spec::removeEmpty (String-Spec::splitStringAt-2 argstr " "))))
	 (rules (loop for tl on words by #'cddr
		      collect (funcall (Script::ruleConstructor (first tl))
				       (if (null (cdr tl))
					   nil
					   (parse-qid (second tl)))))))
    (interpret-command (Script::mkSimplify rules))))

(defun finish-transform-session ()
  (finish-previous-multi-command)
  (if (null *transform-commands*)
      (format t "No transformations")
      (Script::printScript (Script::mkSteps *transform-commands*)))
  (setq *current-command-processor* 'process-sw-shell-command)
  (setq *prompt* "* ")
  (emacs::eval-in-emacs "(setq *sw-slime-prompt* \"* \")")
  (values))

(defun process-transform-shell-command (command argstr)
  (cond ((and (consp command) (null argstr))
	 (lisp-value (multiple-value-list (eval command))))
	((symbolp command)
	 (case command
	   (help      (let ((cl-user::*sw-help-strings*
			     *transform-help-strings*))
			(cl-user::sw-help argstr) ; refers to *transform-help-strings*
			))
	   (at                 (at-command (parse-qid argstr)))
	   ((simplify simp s)  (simplify-command argstr)    )
	   ;((apply a)       (cl-user::ls     (or argstr "")))
	   ((fold f)           (apply-command argstr 'Script::mkFold))
	   ((unfold uf)        (apply-command argstr 'Script::mkUnfold))
	   ((left-to-right lr) (apply-command argstr 'Script::mkLeftToRight))
	   ((right-to-left rl) (apply-command argstr 'Script::mkRightToLeft))
	   ((simp-standard ss) (interpret-command (Script::mkSimpStandard-0)))
	   ((abstract-cse cse acse) (interpret-command (Script::mkAbstractCommonExpressions-0)))
	   ((partial-eval pe)  (interpret-command (Script::mkPartialEval-0)))

	   (pc                 (print-current-term))
	   ((undo back)        (if (null *undo-stack*)
				   (format t "Nothing to undo!")
				   (progn (setq argstr (and argstr (String-Spec::removeWhitesPace argstr)))
					  (if (or (null argstr) (equal argstr ""))
					      (pop-state)
					      (if (equal argstr "all")
						  (progn (finish-previous-multi-command)
							 (unless (null *transform-commands*)
							   (Script::printScript (Script::mkSteps *transform-commands*)))
							 (loop while (not (null *undo-stack*))
							    do (pop-state)))
						  (let ((num (read-from-string argstr)))
						    (if (and (integerp num) (> num 0))
							(loop while (and (> num 0) (not (null *undo-stack*)))
							  do (pop-state)
							     (incf num -1))
							(format t "Illegal undo argument")))))
					  (unless (null *transform-term*)
					    (print-current-term))))
	                       (values))
	   ((trace-rewrites trr) (setq MetaSlangRewriter::traceRewriting 2)
	                         (format t "Rewrite tracing turned on.")
	                         (values))
	   ((untrace-rewrites untrr) (setq MetaSlangRewriter::traceRewriting 0)
	                             (format t "Rewrite tracing turned off.")
	                             (values))
	   ((done)             (finish-transform-session))

	   ((proc p) (when (cl-user::sw argstr)
		       (let ((val (cdr (Specware::evaluateUnitId cl-user::*last-unit-Id-_loaded*))))
			 (if (or (null val) (not (eq (car val) ':|Spec|)))
			     (format t "Not a spec!")
			     (let ((spc (cdr val)))
			       (process-transform-shell-command 'undo "all")
			       (setq *transform-spec* spc)
			       (format t "Restarting Transformation Shell.")))))
		      (values))
	   ;; Possibly useful commands from the standard shell
	   (show      (cl-user::show   argstr) (values))
	   (showx     (cl-user::showx  argstr) (values))
	   (lgen-lisp (cl-user::swll   argstr) (values))
	   ((eval e)  (let ((cl-user::*swe-use-interpreter?* t)
			    (argstr (or argstr *last-eval-expr*))
			    (cl-user::*expr-begin-offset* (if (eq command 'e) -12 -9)))
			(if (null argstr)
			    (warn "No previous eval command.")
			    (progn (setq *last-eval-expr* argstr)
				   (cl-user::swe argstr)
				   (values)))))
	   ((eval-lisp el) 
	    (let ((cl-user::*swe-use-interpreter?* nil)
		  (argstr (or argstr *last-eval-expr*))
		  (cl-user::*expr-begin-offset* (if (eq command 'el) -11 -4)))
	      (if (null argstr)
		  (warn "No previous eval command.")
		  (progn (setq *last-eval-expr* argstr)
			 (cl-user::swe argstr)
			 (values)))))
	   ;; Non-user commands
	   (set-base          (cl-user::set-base argstr))
	   (show-base-unit-id (cl-user::show-base-unit-id))

	   ((lisp l)  (with-break-possibility (lisp-value (multiple-value-list (eval (read-from-string argstr))))))
	   (cl        (with-break-possibility (cl-user::cl argstr)))
	   (ld        (with-break-possibility (cl-user::ld argstr)))
	   (cf        (cl-user::cf argstr))
	   (tr        (cl-user::tr argstr))
	   (untr      (cl-user::untr))
	   (f-b       (when (fboundp 'cl-user::f-b)
			(funcall 'cl-user::f-b argstr)))
	   (f-unb     (when (fboundp 'cl-user::f-unb)
			(funcall 'cl-user::f-unb (or argstr ""))))
	   (pa        (cl-user::pa argstr))
	   (dev       (princ (if argstr
				 (setq *developer?* (not (member argstr '("nil" "NIL" "off") :test 'string=)))
				 *developer?*))
		      (values))
	   (wiz       (if argstr (cl-user::wiz   argstr) (cl-user::wiz)))
	   (swdbg     (if argstr (cl-user::swdbg argstr) (cl-user::swdbg)))
	   (com       (let ((cl:*package* (find-package "CL-USER")))
			(multiple-value-bind (command pos)
			    (read-from-string argstr)
			  (if (fboundp command)
			      (let ((com-argstr (subseq argstr pos)))
				(if (string= com-argstr "")
				    (funcall command)
				    (funcall command com-argstr)))
			      (format t "Unknown command: ~a." command)))))
;;      (bash      (cl-user::bash argstr))
	   ;;
	   (t 
	    (format t "Unknown command `~a'. Type `help' to see available commands."
		    (string-downcase command))
	    (values))))
	((and (constantp command) (null argstr))
	 (values command))
	(t
	 (format t "Unknown command `~S'. Type `help' to see available commands."
		 command))))
