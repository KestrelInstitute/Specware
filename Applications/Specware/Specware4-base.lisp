
;;; Lisp spec

(defpackage "ANNSPECPRINTER")
(defpackage "ANNTERMPRINTER")
(defpackage "ARITYNORMALIZE")
(defpackage "BOOLEAN-SPEC")
(defpackage "CGEN")
(defpackage "CAT")
(defpackage "CHAR-SPEC")
(defpackage "COMPARE")
(defpackage "EDGE")
(defpackage "FUNCTIONS")
(defpackage "FUNCTOR")
(defpackage "HASHTABLE-SPEC")
(defpackage "IO-SPEC")
(defpackage "INFIX")
(defpackage "INTEGER-SPEC")
(defpackage "INTEGERSET")
(defpackage "JGEN")
(defpackage "JAVA")
(defpackage "LISP-SPEC")
(defpackage "LISP-SPEC")
(defpackage "LIST-SPEC")
(defpackage "LISTADT")
(defpackage "LISTPAIR")
(defpackage "LISTUTILITIES")
(defpackage "MFSET")
(defpackage "MERGESORT")
(defpackage "METASLANG")
(defpackage "NAT-SPEC")
(defpackage "NATMAP")
(defpackage "NATTRANS")
(defpackage "OPTION")
(defpackage "PARSER4")
(defpackage "PATTERNMATCH")
(defpackage "POLYMAP")
(defpackage "POLYSET")
(defpackage "POSSPEC")
(defpackage "POSSPECTOSPEC")
(defpackage "POSITION-SPEC")
(defpackage "PRETTYPRINT")
(defpackage "SNARK")
(defpackage "SKETCH")
(defpackage "SPECCALC")
(defpackage "SPECENVIRONMENT")
(defpackage "SPECTOLISP")
(defpackage "SPECTOPOSSPEC")
(defpackage "SPECUNION")
(defpackage "SPECWARE")
(defpackage "SPLAYMAP")
(defpackage "SPLAYSET")
(defpackage "SPLAYTREE")
(defpackage "STANDARDSPEC")
(defpackage "STATE")
(defpackage "STRING-SPEC")
(defpackage "STRINGMAP")
(defpackage "STRINGSET")
(defpackage "STRINGUTILITIES")
(defpackage "SYSTEM-SPEC")
(defpackage "TOPSORT")
(defpackage "TYPECHECKER")
(defpackage "TYPEOBLIGATIONS")
(defpackage "UTILITIES")
(defpackage "VERTEX")
(defpackage "WADLERLINDIG")
(defpackage "ANNSPEC")
(in-package "ANNSPEC")

;;; Definitions

(defun LIST-SPEC::|!cons| (a l) (cons a l))

(defun setProperties (spc new_properties) 
  (vector (svref spc 0) (svref spc 1) new_properties (svref spc 3)))

(defun addProperty (new_property spc) 
  (setProperties spc (LIST-SPEC::|!cons| new_property (svref spc 2))))

(defun addAxiom (pV1 pV2) 
  (block 
   nil 
   (return 
    (addProperty 
     (vector '(:|Axiom|) (svref pV1 0) (svref pV1 1) (svref pV1 2)) 
     pV2)) 
   (error "Nonexhaustive match failure in addAxiom")))

(defun addAxiom-1 (x) (addAxiom (car x) (cdr x)))

(defun addConjecture (pV1 pV2) 
  (block 
   nil 
   (return 
    (addProperty 
     (vector '(:|Conjecture|) (svref pV1 0) (svref pV1 1) (svref pV1 2)) 
     pV2)) 
   (error "Nonexhaustive match failure in addConjecture")))

(defun addConjecture-1 (x) (addConjecture (car x) (cdr x)))

(defun LIST-SPEC::foldr-1-1-1 (f base s) 
  (block 
   nil 
   (if (null s) 
       (return base) 
       (if (consp s) 
           (return 
            (funcall f (cons (car s) (LIST-SPEC::foldr-1-1-1 f base (cdr s))))))) 
   (error "Nonexhaustive match failure in foldr")))

(defun addConjectures (conjectures spc) 
  (LIST-SPEC::foldr-1-1-1 #'addConjecture-1 spc conjectures))

(defun addConjectures-1 (x) (addConjectures (car x) (cdr x)))

(defun LIST-SPEC::concat (s1 s2) 
  (block 
   nil 
   (if (null s1) 
       (return s2) 
       (if (consp s1) (return (cons (car s1) (LIST-SPEC::concat (cdr s1) s2))))) 
   (error "Nonexhaustive match failure in concat")))

(defun LIST-SPEC::|!++| (s1 s2) (LIST-SPEC::concat s1 s2))

(defun setImports (pV2 pV3) 
  (block 
   nil 
   (let ((pV4 (svref pV2 0))) 
     (return 
      (vector 
       (vector (svref pV4 0) pV3 (svref pV4 2) (svref pV4 3)) 
       (svref pV2 1) 
       (svref pV2 2) 
       (svref pV2 3)))) 
   (error "Nonexhaustive match failure in setImports")))

(defun addImport (pV1 pV2) 
  (block 
   nil 
   (return 
    (setImports 
     pV2 
     (LIST-SPEC::|!cons| (cons (car pV1) (cdr pV1)) (svref (svref pV2 0) 1)))) 
   (error "Nonexhaustive match failure in addImport")))

(defun SPLAYMAP::foldriAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV2 (cdr sp))) 
               (let ((pV5 (svref pV2 2))) 
                 (return 
                  (SPLAYMAP::foldriAp-1-1 
                   abf 
                   (cons 
                    (svref pV2 0) 
                    (funcall abf 
                             (vector 
                              (car pV5) 
                              (cdr pV5) 
                              (SPLAYMAP::foldriAp-1-1 abf (cons (svref pV2 1) b))))))))))) 
     (error "Nonexhaustive match failure in foldriAp"))))

(defun SPLAYMAP::foldri-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldriAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldri")))

(defun SPLAYMAP::foldriDouble-1-1-1 (f ob omap) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (let ((key1 (svref x 0))) 
        (SPLAYMAP::foldri-1-1-1 
         #'(lambda (x1) 
            (funcall f (vector key1 (svref x1 0) (svref x1 1) (svref x1 2)))) 
         (svref x 2) 
         (svref x 1)))) 
   ob 
   omap))

(defun STRINGMAP::foldriDouble-1-1-1 (x0 x1 x2) 
  (SPLAYMAP::foldriDouble-1-1-1 x0 x1 x2))

(defun foldriAQualifierMap-1-1-1 (x0 x1 x2) 
  (STRINGMAP::foldriDouble-1-1-1 x0 x1 x2))

(defun SPLAYMAP::empty (x) (cons :|EMPTY| x))

(defun STRING-SPEC::compare (n m) 
  (if (STRING-SPEC::lt n m) 
      '(:|Less|) 
      (if (string=  n m) '(:|Equal|) '(:|Greater|))))

(defun STRING-SPEC::compare-1 (x) (STRING-SPEC::compare (car x) (cdr x)))

(defparameter STRINGMAP::empty (SPLAYMAP::empty #'STRING-SPEC::compare-1))

(defun SPLAYTREE::mkSplayObj (x1 x0 x) (cons :|SplayObj| (vector x1 x0 x)))

(defun SPLAYTREE::adj-1-1 (compf sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return (vector '(:|No|) '(:|SplayNil|) '(:|SplayNil|))) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV42 (cdr sp))) 
             (let ((pV43 (svref pV42 0))
                   (pV44 (svref pV42 1))
                   (pV45 (svref pV42 2))) 
               (return 
                (let ((pV40 (funcall compf pV45))) 
                  (block 
                   nil 
                   (if (eq (car pV40) :|Equal|) 
                       (return (vector (cons :|Eq| pV45) pV43 pV44)) 
                       (if (eq (car pV40) :|Greater|) 
                           (return 
                            (block 
                             nil 
                             (if (eq (car pV43) :|SplayNil|) 
                                 (return 
                                  (vector (cons :|Gt| pV45) '(:|SplayNil|) pV44)) 
                                 (if (eq (car pV43) :|SplayObj|) 
                                     (let ((pV16 (cdr pV43))) 
                                       (let ((pV17 (svref pV16 0))
                                             (pV18 (svref pV16 1))
                                             (pV19 (svref pV16 2))) 
                                         (return 
                                          (let ((pV14 (funcall compf pV19))) 
                                            (block 
                                             nil 
                                             (if (eq (car pV14) :|Equal|) 
                                                 (return 
                                                  (vector 
                                                   (cons :|Eq| pV19) 
                                                   pV17 
                                                   (cons 
                                                    :|SplayObj| 
                                                    (vector pV18 pV44 pV45)))) 
                                                 (if (eq (car pV14) :|Greater|) 
                                                     (return 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV17) 
                                                            :|SplayNil|) 
                                                           (return 
                                                            (vector 
                                                             (cons :|Gt| pV19) 
                                                             pV17 
                                                             (cons 
                                                              :|SplayObj| 
                                                              (vector 
                                                               pV18 
                                                               pV44 
                                                               pV45))))) 
                                                       (return 
                                                        (let ((pV2 
                                                               (SPLAYTREE::adj-1-1 
                                                                compf 
                                                                pV17))) 
                                                          (block 
                                                           nil 
                                                           (return 
                                                            (let ((rchild 
                                                                   (SPLAYTREE::mkSplayObj 
                                                                    pV18 
                                                                    pV44 
                                                                    pV45))) 
                                                              (vector 
                                                               (svref pV2 0) 
                                                               (svref pV2 1) 
                                                               (cons 
                                                                :|SplayObj| 
                                                                (vector 
                                                                 (svref pV2 2) 
                                                                 rchild 
                                                                 pV19))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in adj")))))))) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV18) :|SplayNil|) 
                                                   (return 
                                                    (vector 
                                                     (cons :|Lt| pV19) 
                                                     pV17 
                                                     (cons 
                                                      :|SplayObj| 
                                                      (vector pV18 pV44 pV45))))) 
                                               (return 
                                                (let ((pV9 
                                                       (SPLAYTREE::adj-1-1 
                                                        compf 
                                                        pV18))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (let ((rchild 
                                                           (SPLAYTREE::mkSplayObj 
                                                            (svref pV9 2) 
                                                            pV44 
                                                            pV45))) 
                                                      (let ((lchild 
                                                             (SPLAYTREE::mkSplayObj 
                                                              pV17 
                                                              (svref pV9 1) 
                                                              pV19))) 
                                                        (vector 
                                                         (svref pV9 0) 
                                                         lchild 
                                                         rchild)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in adj"))))))))))))) 
                             (error "Nonexhaustive match failure in adj"))))) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car pV44) :|SplayNil|) 
                         (return (vector (cons :|Lt| pV45) pV43 '(:|SplayNil|))) 
                         (if (eq (car pV44) :|SplayObj|) 
                             (let ((pV36 (cdr pV44))) 
                               (let ((pV37 (svref pV36 0))
                                     (pV38 (svref pV36 1))
                                     (pV39 (svref pV36 2))) 
                                 (return 
                                  (let ((pV34 (funcall compf pV39))) 
                                    (block 
                                     nil 
                                     (if (eq (car pV34) :|Equal|) 
                                         (return 
                                          (vector 
                                           (cons :|Eq| pV39) 
                                           (cons 
                                            :|SplayObj| 
                                            (vector pV43 pV37 pV45)) 
                                           pV38)) 
                                         (if (eq (car pV34) :|Less|) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV38) :|SplayNil|) 
                                                   (return 
                                                    (vector 
                                                     (cons :|Lt| pV39) 
                                                     (cons 
                                                      :|SplayObj| 
                                                      (vector pV43 pV37 pV45)) 
                                                     pV38))) 
                                               (return 
                                                (let ((pV22 
                                                       (SPLAYTREE::adj-1-1 
                                                        compf 
                                                        pV38))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (let ((lchild 
                                                           (SPLAYTREE::mkSplayObj 
                                                            pV43 
                                                            pV37 
                                                            pV45))) 
                                                      (vector 
                                                       (svref pV22 0) 
                                                       (cons 
                                                        :|SplayObj| 
                                                        (vector 
                                                         lchild 
                                                         (svref pV22 1) 
                                                         pV39)) 
                                                       (svref pV22 2)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in adj")))))))) 
                                     (return 
                                      (block 
                                       nil 
                                       (if (eq (car pV37) :|SplayNil|) 
                                           (return 
                                            (vector 
                                             (cons :|Gt| pV39) 
                                             (cons 
                                              :|SplayObj| 
                                              (vector pV43 pV37 pV45)) 
                                             pV38))) 
                                       (return 
                                        (let ((pV29 
                                               (SPLAYTREE::adj-1-1 compf pV37))) 
                                          (block 
                                           nil 
                                           (return 
                                            (let ((rchild 
                                                   (SPLAYTREE::mkSplayObj 
                                                    (svref pV29 2) 
                                                    pV38 
                                                    pV39))) 
                                              (let ((lchild 
                                                     (SPLAYTREE::mkSplayObj 
                                                      pV43 
                                                      (svref pV29 1) 
                                                      pV45))) 
                                                (vector 
                                                 (svref pV29 0) 
                                                 lchild 
                                                 rchild)))) 
                                           (error 
                                            "Nonexhaustive match failure in adj"))))))))))))) 
                     (error "Nonexhaustive match failure in adj")))))))))) 
   (error "Nonexhaustive match failure in adj")))

(defun SPLAYTREE::splay (compf root) 
  (let ((x (SPLAYTREE::adj-1-1 compf root))) 
    (let ((pV5 (svref x 2))
          (pV4 (svref x 1))
          (pV3 (svref x 0))) 
      (block 
       nil 
       (if (eq (car pV3) :|No|) 
           (return (cons '(:|Greater|) '(:|SplayNil|))) 
           (if (eq (car pV3) :|Eq|) 
               (return 
                (cons '(:|Equal|) (cons :|SplayObj| (vector pV4 pV5 (cdr pV3))))) 
               (if (eq (car pV3) :|Lt|) 
                   (return 
                    (cons 
                     '(:|Less|) 
                     (cons :|SplayObj| (vector pV4 pV5 (cdr pV3))))) 
                   (if (eq (car pV3) :|Gt|) 
                       (return 
                        (cons 
                         '(:|Greater|) 
                         (cons :|SplayObj| (vector pV4 pV5 (cdr pV3))))))))) 
       (error "Nonexhaustive match failure in splay")))))

(defun SPLAYMAP::insert (|!map| key v) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return 
        (cons 
         :|MAP| 
         (vector 
          (cdr |!map|) 
          1 
          (cons 
           :|Ref| 
           (cons :|SplayObj| (vector '(:|SplayNil|) '(:|SplayNil|) (cons key v))))))) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV18 (cdr |!map|))) 
             (let ((pV21 (svref pV18 1))
                   (pV20 (svref pV18 0))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        #'(lambda (x) (funcall pV20 (cons (car x) key))) 
                        (STATE::|!!| (svref pV18 2))))) 
                  (let ((pV3 (cdr x))
                        (pV2 (car x))) 
                    (block 
                     nil 
                     (if (eq (car pV2) :|Equal|) 
                         (if (eq (car pV3) :|SplayObj|) 
                             (let ((pV12 (cdr pV3))) 
                               (return 
                                (cons 
                                 :|MAP| 
                                 (vector 
                                  pV20 
                                  pV21 
                                  (cons 
                                   :|Ref| 
                                   (cons 
                                    :|SplayObj| 
                                    (vector 
                                     (svref pV12 0) 
                                     (svref pV12 1) 
                                     (cons key v))))))))) 
                         (if (eq (car pV2) :|Less|) 
                             (if (eq (car pV3) :|SplayObj|) 
                                 (let ((pV8 (cdr pV3))) 
                                   (return 
                                    (cons 
                                     :|MAP| 
                                     (vector 
                                      pV20 
                                      (INTEGER-SPEC::|!+| pV21 1) 
                                      (cons 
                                       :|Ref| 
                                       (cons 
                                        :|SplayObj| 
                                        (vector 
                                         (cons 
                                          :|SplayObj| 
                                          (vector 
                                           (svref pV8 0) 
                                           '(:|SplayNil|) 
                                           (svref pV8 2))) 
                                         (svref pV8 1) 
                                         (cons key v))))))))) 
                             (if (eq (car pV2) :|Greater|) 
                                 (if (eq (car pV3) :|SplayObj|) 
                                     (let ((pV4 (cdr pV3))) 
                                       (return 
                                        (cons 
                                         :|MAP| 
                                         (vector 
                                          pV20 
                                          (INTEGER-SPEC::|!+| pV21 1) 
                                          (cons 
                                           :|Ref| 
                                           (cons 
                                            :|SplayObj| 
                                            (vector 
                                             (svref pV4 0) 
                                             (cons 
                                              :|SplayObj| 
                                              (vector 
                                               '(:|SplayNil|) 
                                               (svref pV4 1) 
                                               (svref pV4 2))) 
                                             (cons key v)))))))))))) 
                     (if (eq (car pV3) :|SplayNil|) 
                         (return (SYSTEM-SPEC::fail "SplayMap.insert SplayNil"))) 
                     (error "Nonexhaustive match failure in insert"))))))))) 
   (error "Nonexhaustive match failure in insert")))

(defun STRINGMAP::insert (x1 x0 x) (SPLAYMAP::insert x1 x0 x))

(defun SPLAYMAP::findR (sTree key comp) 
  (block 
   nil 
   (if (eq (car sTree) :|SplayNil|) 
       (return '(:|None|)) 
       (if (eq (car sTree) :|SplayObj|) 
           (let ((pV4 (cdr sTree))) 
             (let ((pV7 (svref pV4 2))) 
               (return 
                (let ((pV2 (funcall comp (cons key (car pV7))))) 
                  (block 
                   nil 
                   (if (eq (car pV2) :|Equal|) 
                       (return (cons :|Some| (cdr pV7))) 
                       (if (eq (car pV2) :|Less|) 
                           (return (SPLAYMAP::findR (svref pV4 0) key comp)))) 
                   (return (SPLAYMAP::findR (svref pV4 1) key comp))))))))) 
   (error "Nonexhaustive match failure in findR")))

(defun SPLAYMAP::|!find| (|!map| key) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return '(:|None|)) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV3 (cdr |!map|))) 
             (return 
              (SPLAYMAP::findR (STATE::|!!| (svref pV3 2)) key (svref pV3 0)))))) 
   (error "Nonexhaustive match failure in find")))

(defun STRINGMAP::|!find| (x0 x) (SPLAYMAP::|!find| x0 x))

(defun STRINGMAP::insert2 (m x y v) 
  (STRINGMAP::insert 
   m 
   x 
   (STRINGMAP::insert 
    (let ((pV2 (STRINGMAP::|!find| m x))) 
      (block 
       nil 
       (if (eq (car pV2) :|Some|) (return (cdr pV2))) 
       (return STRINGMAP::empty))) 
    y 
    v)))

(defun insertAQualifierMap (x2 x1 x0 x) (STRINGMAP::insert2 x2 x1 x0 x))

(defun setOps (spc new_ops) 
  (vector (svref spc 0) new_ops (svref spc 2) (svref spc 3)))

(defun setSorts (spc new_sorts) 
  (vector (svref spc 0) (svref spc 1) (svref spc 2) new_sorts))

(defun addDisjointImport (spc imported_spec) 
  (labels 
    ((mergeOpStep 
      (imported_qualifier imported_id imported_op_info combined_pops) 
      (insertAQualifierMap 
       combined_pops 
       imported_qualifier 
       imported_id 
       imported_op_info))
     (mergeSortStep 
      (imported_qualifier imported_id imported_sort_info combined_psorts) 
      (insertAQualifierMap 
       combined_psorts 
       imported_qualifier 
       imported_id 
       imported_sort_info))) 
    (let ((spc (addImport (cons "" imported_spec) spc))) 
      (let ((newSorts 
             (foldriAQualifierMap-1-1-1 
              #'(lambda (x) 
                 (mergeSortStep (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
              (svref spc 3) 
              (svref imported_spec 3)))) 
        (let ((spc (setSorts spc newSorts))) 
          (let ((newOps 
                 (foldriAQualifierMap-1-1-1 
                  #'(lambda (x) 
                     (mergeOpStep 
                      (svref x 0) 
                      (svref x 1) 
                      (svref x 2) 
                      (svref x 3))) 
                  (svref spc 1) 
                  (svref imported_spec 1)))) 
            (let ((spc (setOps spc newOps))) 
              (setProperties 
               spc 
               (LIST-SPEC::|!++| (svref spc 2) (svref imported_spec 2))))))))))

(defun addDisjointImport-1 (x) (addDisjointImport (car x) (cdr x)))

(defun addImport-1 (x) (addImport (car x) (cdr x)))

(defun addToNames (name nameSet) (LIST-SPEC::|!cons| name nameSet))

(defun LIST-SPEC::|!member| (a l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (return 
            (if (slang-built-in::slang-term-equals a (car l)) 
                t 
                (LIST-SPEC::|!member| a (cdr l)))))) 
   (error "Nonexhaustive match failure in member")))

(defun memberNames (n nms) (LIST-SPEC::|!member| n nms))

(defun addLocalOpName (pV1 pV2) 
  (block 
   nil 
   (let ((pV3 (svref pV1 0))) 
     (let ((pV9 (svref pV3 2))) 
       (return 
        (if (memberNames pV2 pV9) 
            pV1 
            (vector 
             (vector 
              (svref pV3 0) 
              (svref pV3 1) 
              (addToNames pV2 pV9) 
              (svref pV3 3)) 
             (svref pV1 1) 
             (svref pV1 2) 
             (svref pV1 3)))))) 
   (error "Nonexhaustive match failure in addLocalOpName")))

(defun addLocalOpName-1 (x) (addLocalOpName (car x) (cdr x)))

(defun addLocalSortName (pV1 pV2) 
  (block 
   nil 
   (let ((pV3 (svref pV1 0))) 
     (let ((pV10 (svref pV3 3))) 
       (return 
        (if (memberNames pV2 pV10) 
            pV1 
            (vector 
             (vector 
              (svref pV3 0) 
              (svref pV3 1) 
              (svref pV3 2) 
              (addToNames pV2 pV10)) 
             (svref pV1 1) 
             (svref pV1 2) 
             (svref pV1 3)))))) 
   (error "Nonexhaustive match failure in addLocalSortName")))

(defun addLocalSortName-1 (x) (addLocalSortName (car x) (cdr x)))

(defun addProperty-1 (x) (addProperty (car x) (cdr x)))

(defun addTheorem (pV1 pV2) 
  (block 
   nil 
   (return 
    (addProperty 
     (vector '(:|Theorem|) (svref pV1 0) (svref pV1 1) (svref pV1 2)) 
     pV2)) 
   (error "Nonexhaustive match failure in addTheorem")))

(defun addTheorem-1 (x) (addTheorem (car x) (cdr x)))

(defun addTheoremLast (pV1 pV2) 
  (block 
   nil 
   (return 
    (setProperties 
     pV2 
     (LIST-SPEC::|!++| 
      (svref pV2 2) 
      (cons (vector '(:|Theorem|) (svref pV1 0) (svref pV1 1) (svref pV1 2)) nil)))) 
   (error "Nonexhaustive match failure in addTheoremLast")))

(defun addTheoremLast-1 (x) (addTheoremLast (car x) (cdr x)))

(defun addTheorems (theorems spc) 
  (LIST-SPEC::foldr-1-1-1 #'addTheorem-1 spc theorems))

(defun addTheorems-1 (x) (addTheorems (car x) (cdr x)))

(defun addToNames-1 (x) (addToNames (car x) (cdr x)))

(defun SPLAYMAP::|!apply|-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV3 (cdr sp))) 
             (return 
              (progn (SPLAYMAP::|!apply|-1-1 af (svref pV3 0)) 
                     (funcall af (cdr (svref pV3 2))) 
                     (SPLAYMAP::|!apply|-1-1 af (svref pV3 1))))))) 
   (error "Nonexhaustive match failure in apply")))

(defun SPLAYMAP::app-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::|!apply|-1-1 af (STATE::|!!| (svref (cdr |!map|) 2)))))) 
   (error "Nonexhaustive match failure in app")))

(defun STRINGMAP::app-1-1 (x0 x1) (SPLAYMAP::app-1-1 x0 x1))

(defun STRINGMAP::appDouble-1-1 (f m) 
  (STRINGMAP::app-1-1 #'(lambda (sm) (STRINGMAP::app-1-1 f sm)) m))

(defun STRINGMAP::appDouble (x1) 
  #'(lambda (x2) (STRINGMAP::appDouble-1-1 x1 x2)))

(defun appAQualifierMap (x) (STRINGMAP::appDouble x))

(defun appAQualifierMap-1-1 (x0 x1) (STRINGMAP::appDouble-1-1 x0 x1))

(defun LIST-SPEC::app-1-1 (f s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return (progn (funcall f (car s)) (LIST-SPEC::app-1-1 f (cdr s)))))) 
   (error "Nonexhaustive match failure in app")))

(defun METASLANG::appSortOpt-1-1 (tsp_apps opt_sort) 
  (block 
   nil 
   (if (eq (car opt_sort) :|None|) 
       (return nil) 
       (if (eq (car opt_sort) :|Some|) 
           (return (METASLANG::appSort-1-1 tsp_apps (cdr opt_sort))))) 
   (error "Nonexhaustive match failure in appSortOpt")))

(defun METASLANG::appPattern-1-1 (tsp_apps pat) 
  (let ((pattern_app (svref tsp_apps 2))) 
    (labels 
      ((appRec (pat) (progn (appP tsp_apps pat) (funcall pattern_app pat)))
       (appP (tsp_apps1 pat) 
        (block 
         nil 
         (if (eq (car pat) :|AliasPat|) 
             (let ((pV19 (cdr pat))) 
               (return (progn (appRec (svref pV19 0)) (appRec (svref pV19 1))))) 
             (if (eq (car pat) :|EmbedPat|) 
                 (let ((pV18 (cdr pat))) 
                   (let ((pV35 (svref pV18 1))
                         (pV36 (svref pV18 2))) 
                     (if (eq (car pV35) :|Some|) 
                         (return 
                          (progn (appRec (cdr pV35)) 
                                 (METASLANG::appSort-1-1 tsp_apps1 pV36))) 
                         (if (eq (car pV35) :|None|) 
                             (return (METASLANG::appSort-1-1 tsp_apps1 pV36)))))) 
                 (if (eq (car pat) :|RelaxPat|) 
                     (let ((pV17 (cdr pat))) 
                       (return 
                        (progn (appRec (svref pV17 0)) 
                               (METASLANG::appTerm-1-1 tsp_apps1 (svref pV17 1))))) 
                     (if (eq (car pat) :|QuotientPat|) 
                         (let ((pV16 (cdr pat))) 
                           (return 
                            (progn (appRec (svref pV16 0)) 
                                   (METASLANG::appTerm-1-1 
                                    tsp_apps1 
                                    (svref pV16 1))))) 
                         (if (eq (car pat) :|VarPat|) 
                             (return 
                              (METASLANG::appSort-1-1 
                               tsp_apps1 
                               (cdr (car (cdr pat))))) 
                             (if (eq (car pat) :|WildPat|) 
                                 (return 
                                  (METASLANG::appSort-1-1 
                                   tsp_apps1 
                                   (car (cdr pat)))) 
                                 (if (eq (car pat) :|RecordPat|) 
                                     (return 
                                      (LIST-SPEC::app-1-1 
                                       #'(lambda (x1) (appRec (cdr x1))) 
                                       (car (cdr pat))))))))))) 
         (return nil)))) (appRec pat))))

(defun METASLANG::appTerm-1-1 (tsp_apps term) 
  (let ((term_app (svref tsp_apps 0))) 
    (labels 
      ((appRec (term) (progn (appT tsp_apps term) (funcall term_app term)))
       (appT (tsp_apps1 term) 
        (block 
         nil 
         (if (eq (car term) :|Fun|) 
             (return (METASLANG::appSort-1-1 tsp_apps1 (svref (cdr term) 1))) 
             (if (eq (car term) :|Var|) 
                 (return 
                  (METASLANG::appSort-1-1 tsp_apps1 (cdr (car (cdr term))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV26 (cdr term))) 
                       (return 
                        (progn (LIST-SPEC::app-1-1 
                                #'(lambda (x1) 
                                   (progn (METASLANG::appPattern-1-1 
                                           tsp_apps1 
                                           (car x1)) 
                                          (appRec (cdr x1)))) 
                                (svref pV26 0)) 
                               (appRec (svref pV26 1))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV25 (cdr term))) 
                           (return 
                            (progn (LIST-SPEC::app-1-1 
                                    #'(lambda (x1) (appRec (cdr x1))) 
                                    (svref pV25 0)) 
                                   (appRec (svref pV25 1))))) 
                         (if (eq (car term) :|Record|) 
                             (return 
                              (LIST-SPEC::app-1-1 
                               #'(lambda (x1) (appRec (cdr x1))) 
                               (car (cdr term)))) 
                             (if (eq (car term) :|IfThenElse|) 
                                 (let ((pV23 (cdr term))) 
                                   (return 
                                    (progn (appRec (svref pV23 0)) 
                                           (appRec (svref pV23 1)) 
                                           (appRec (svref pV23 2))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (return 
                                      (LIST-SPEC::app-1-1 
                                       #'(lambda (x1) 
                                          (progn (METASLANG::appPattern-1-1 
                                                  tsp_apps1 
                                                  (svref x1 0)) 
                                                 (appRec (svref x1 1)) 
                                                 (appRec (svref x1 2)))) 
                                       (car (cdr term)))) 
                                     (if (eq (car term) :|Bind|) 
                                         (let ((pV21 (cdr term))) 
                                           (return 
                                            (progn (LIST-SPEC::app-1-1 
                                                    #'(lambda (x1) 
                                                       (METASLANG::appSort-1-1 
                                                        tsp_apps1 
                                                        (cdr x1))) 
                                                    (svref pV21 1)) 
                                                   (appRec (svref pV21 2))))) 
                                         (if (eq (car term) :|Apply|) 
                                             (let ((pV20 (cdr term))) 
                                               (return 
                                                (progn (appRec (svref pV20 0)) 
                                                       (appRec (svref pV20 1))))) 
                                             (if (eq (car term) :|Seq|) 
                                                 (return 
                                                  (LIST-SPEC::app-1-1 
                                                   #'appRec 
                                                   (car (cdr term)))) 
                                                 (if (eq (car term) :|ApplyN|) 
                                                     (return 
                                                      (LIST-SPEC::app-1-1 
                                                       #'appRec 
                                                       (car (cdr term)))) 
                                                     (if (eq 
                                                          (car term) 
                                                          :|SortedTerm|) 
                                                         (let ((pV17 (cdr term))) 
                                                           (return 
                                                            (progn (appRec 
                                                                    (svref 
                                                                     pV17 
                                                                     0)) 
                                                                   (METASLANG::appSort-1-1 
                                                                    tsp_apps1 
                                                                    (svref 
                                                                     pV17 
                                                                     1))))))))))))))))) 
         (error "Nonexhaustive match failure in appTerm")))) (appRec term))))

(defun METASLANG::appSort-1-1 (tsp_apps srt) 
  (let ((srt_app (svref tsp_apps 1))) 
    (labels 
      ((appRec (srt) (progn (appS tsp_apps srt) (funcall srt_app srt)))
       (appS (tsp_apps1 srt) 
        (block 
         nil 
         (if (eq (car srt) :|CoProduct|) 
             (return 
              (LIST-SPEC::app-1-1 
               #'(lambda (x1) (METASLANG::appSortOpt-1-1 tsp_apps1 (cdr x1))) 
               (car (cdr srt)))) 
             (if (eq (car srt) :|Product|) 
                 (return 
                  (LIST-SPEC::app-1-1 
                   #'(lambda (x1) (appRec (cdr x1))) 
                   (car (cdr srt)))) 
                 (if (eq (car srt) :|Arrow|) 
                     (let ((pV15 (cdr srt))) 
                       (return 
                        (progn (appRec (svref pV15 0)) (appRec (svref pV15 1))))) 
                     (if (eq (car srt) :|Quotient|) 
                         (let ((pV14 (cdr srt))) 
                           (return 
                            (progn (appRec (svref pV14 0)) 
                                   (METASLANG::appTerm-1-1 
                                    tsp_apps1 
                                    (svref pV14 1))))) 
                         (if (eq (car srt) :|Subsort|) 
                             (let ((pV13 (cdr srt))) 
                               (return 
                                (progn (appRec (svref pV13 0)) 
                                       (METASLANG::appTerm-1-1 
                                        tsp_apps1 
                                        (svref pV13 1))))) 
                             (if (eq (car srt) :|Base|) 
                                 (let ((pV19 (svref (cdr srt) 1))) 
                                   (progn (return 
                                           (LIST-SPEC::app-1-1 #'appRec pV19)) 
                                          (return 
                                           (LIST-SPEC::app-1-1 #'appRec pV19)))))))))) 
         (return nil)))) (appRec srt))))

(defun METASLANG::appSort-1 (x1) 
  #'(lambda (x2) (METASLANG::appSort-1-1 x1 x2)))

(defun METASLANG::appSortSchemes-1-1 (tsp_apps sort_schemes) 
  (LIST-SPEC::app-1-1 
   #'(lambda (x) (METASLANG::appSort-1-1 tsp_apps (cdr x))) 
   sort_schemes))

(defun METASLANG::appSortSchemes-1 (x1) 
  #'(lambda (x2) (METASLANG::appSortSchemes-1-1 x1 x2)))

(defun METASLANG::appTerm-1 (x1) 
  #'(lambda (x2) (METASLANG::appTerm-1-1 x1 x2)))

(defun METASLANG::appTermSchemes-1-1 (tsp_apps term_schemes) 
  (LIST-SPEC::app-1-1 
   #'(lambda (x) (METASLANG::appTerm-1-1 tsp_apps (cdr x))) 
   term_schemes))

(defun METASLANG::appTermSchemes-1 (x1) 
  #'(lambda (x2) (METASLANG::appTermSchemes-1-1 x1 x2)))

(defun appSpec-1-1 (tsp spc) 
  (let ((|!appt| (METASLANG::appTerm-1 tsp))) 
    (let ((appts (METASLANG::appTermSchemes-1 tsp))) 
      (let ((|!apps| (METASLANG::appSort-1 tsp))) 
        (let ((appss (METASLANG::appSortSchemes-1 tsp))) 
          (progn (appAQualifierMap-1-1 
                  #'(lambda (x) 
                     (block 
                      nil 
                      (return 
                       (progn (funcall |!apps| (cdr (svref x 2))) 
                              (funcall appts (svref x 3)))) 
                      (error "Nonexhaustive match failure in appSpec"))) 
                  (svref spc 1)) 
                 (appAQualifierMap-1-1 
                  #'(lambda (x) (funcall appss (svref x 2))) 
                  (svref spc 3)) 
                 (LIST-SPEC::app-1-1 
                  #'(lambda (x) (funcall |!appt| (svref x 3))) 
                  (svref spc 2))))))))

(defun appSpec-1 (x1) #'(lambda (x2) (appSpec-1-1 x1 x2)))

(defun appSpec (x0 x1 x2) (appSpec-1 (vector x0 x1 x2)))

(defparameter emptyAQualifierMap STRINGMAP::empty)

(defparameter emptyAOpMap emptyAQualifierMap)

(defparameter emptyAProperties nil)

(defparameter emptyASortMap emptyAQualifierMap)

(defparameter emptyImports nil)

(defparameter emptyOpNames nil)

(defparameter emptySortNames nil)

(defparameter emptyImportInfo 
  (vector '(:|None|) emptyImports emptyOpNames emptySortNames))

(defparameter emptySpec 
  (vector emptyImportInfo emptyAOpMap emptyAProperties emptyASortMap))

(defun LIST-SPEC::all-1-1 (p s) 
  (block 
   nil 
   (if (null s) 
       (return t) 
       (if (consp s) 
           (return (if (funcall p (car s)) (LIST-SPEC::all-1-1 p (cdr s)) nil)))) 
   (error "Nonexhaustive match failure in all")))

(defun LIST-SPEC::|!exists|-1-1 (p s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return 
            (if (funcall p (car s)) t (LIST-SPEC::|!exists|-1-1 p (cdr s)))))) 
   (error "Nonexhaustive match failure in exists")))

(defun LIST-SPEC::|!length| (s) 
  (block 
   nil 
   (if (null s) 
       (return 0) 
       (if (consp s) 
           (return (INTEGER-SPEC::|!+| 1 (LIST-SPEC::|!length| (cdr s)))))) 
   (error "Nonexhaustive match failure in length")))

(defun METASLANG::equalList? (x y eqFn) 
  (cl:and 
   ( =  (LIST-SPEC::|!length| x) (LIST-SPEC::|!length| y)) 
   (block 
    nil 
    (if (null x) 
        (if (null y) (return t)) 
        (if (consp x) 
            (if (consp y) 
                (return 
                 (cl:and 
                  (funcall eqFn (cons (car x) (car y))) 
                  (METASLANG::equalList? (cdr x) (cdr y) eqFn)))))) 
    (return nil))))

(defun METASLANG::equalOpt? (x y eqFn) 
  (block 
   nil 
   (if (eq (car x) :|None|) 
       (if (eq (car y) :|None|) (return t)) 
       (if (eq (car x) :|Some|) 
           (if (eq (car y) :|Some|) 
               (return (funcall eqFn (cons (cdr x) (cdr y))))))) 
   (return nil)))

(defun METASLANG::equalSort?-1 (x) (METASLANG::equalSort? (car x) (cdr x)))

(defun METASLANG::equalFun? (f1 f2) 
  (block 
   nil 
   (if (eq (car f1) :|PQuotient|) 
       (if (eq (car f2) :|PQuotient|) 
           (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
       (if (eq (car f1) :|PChoose|) 
           (if (eq (car f2) :|PChoose|) 
               (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
           (if (eq (car f1) :|PRestrict|) 
               (if (eq (car f2) :|PRestrict|) 
                   (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
               (if (eq (car f1) :|PRelax|) 
                   (if (eq (car f2) :|PRelax|) 
                       (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
                   (if (eq (car f1) :|Equals|) 
                       (if (eq (car f2) :|Equals|) (return t)) 
                       (if (eq (car f1) :|Quotient|) 
                           (if (eq (car f2) :|Quotient|) (return t)) 
                           (if (eq (car f1) :|Choose|) 
                               (if (eq (car f2) :|Choose|) (return t)) 
                               (if (eq (car f1) :|Restrict|) 
                                   (if (eq (car f2) :|Restrict|) (return t)) 
                                   (if (eq (car f1) :|Relax|) 
                                       (if (eq (car f2) :|Relax|) (return t)) 
                                       (if (eq (car f1) :|Op|) 
                                           (if (eq (car f2) :|Op|) 
                                               (return 
                                                (slang-built-in::slang-term-equals 
                                                 (cdr f1) 
                                                 (cdr f2)))) 
                                           (if (eq (car f1) :|Project|) 
                                               (if (eq (car f2) :|Project|) 
                                                   (return 
                                                    (string=  (cdr f1) (cdr f2)))) 
                                               (if (eq (car f1) :|Embed|) 
                                                   (if (eq (car f2) :|Embed|) 
                                                       (return 
                                                        (slang-built-in::slang-term-equals 
                                                         (cdr f1) 
                                                         (cdr f2)))) 
                                                   (if (eq (car f1) :|Embedded|) 
                                                       (if (eq 
                                                            (car f2) 
                                                            :|Embedded|) 
                                                           (return 
                                                            (string=  
                                                             (cdr f1) 
                                                             (cdr f2)))) 
                                                       (if (eq (car f1) :|Nat|) 
                                                           (if (eq 
                                                                (car f2) 
                                                                :|Nat|) 
                                                               (return 
                                                                ( =  
                                                                 (cdr f1) 
                                                                 (cdr f2)))) 
                                                           (if (eq 
                                                                (car f1) 
                                                                :|Char|) 
                                                               (if (eq 
                                                                    (car f2) 
                                                                    :|Char|) 
                                                                   (return 
                                                                    (eq 
                                                                     (cdr f1) 
                                                                     (cdr f2)))) 
                                                               (if (eq 
                                                                    (car f1) 
                                                                    :|String|) 
                                                                   (if (eq 
                                                                        (car f2) 
                                                                        :|String|) 
                                                                       (return 
                                                                        (string=  
                                                                         (cdr f1) 
                                                                         (cdr f2)))) 
                                                                   (if (eq 
                                                                        (car f1) 
                                                                        :|Bool|) 
                                                                       (if (eq 
                                                                            (car 
                                                                             f2) 
                                                                            :|Bool|) 
                                                                           (return 
                                                                            (eq 
                                                                             (cdr 
                                                                              f1) 
                                                                             (cdr 
                                                                              f2)))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             f1) 
                                                                            :|OneName|) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 f2) 
                                                                                :|OneName|) 
                                                                               (return 
                                                                                (slang-built-in::slang-term-equals 
                                                                                 (cdr 
                                                                                  f1) 
                                                                                 (cdr 
                                                                                  f2)))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 f1) 
                                                                                :|TwoNames|) 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     f2) 
                                                                                    :|TwoNames|) 
                                                                                   (return 
                                                                                    (slang-built-in::slang-term-equals 
                                                                                     (cdr 
                                                                                      f1) 
                                                                                     (cdr 
                                                                                      f2))))))))))))))))))))))) 
   (return nil)))

(defun METASLANG::equalPattern?-1 (x) 
  (METASLANG::equalPattern? (car x) (cdr x)))

(defun METASLANG::equalVar? (pV1 pV2) 
  (block 
   nil 
   (return 
    (cl:and 
     (string=  (car pV1) (car pV2)) 
     (METASLANG::equalSort? (cdr pV1) (cdr pV2)))) 
   (error "Nonexhaustive match failure in equalVar?")))

(defun METASLANG::equalPattern? (p1 p2) 
  (block 
   nil 
   (if (eq (car p1) :|AliasPat|) 
       (let ((pV45 (cdr p1))) 
         (if (eq (car p2) :|AliasPat|) 
             (let ((pV114 (cdr p2))) 
               (return 
                (cl:and 
                 (METASLANG::equalPattern? (svref pV45 0) (svref pV114 0)) 
                 (METASLANG::equalPattern? (svref pV45 1) (svref pV114 1))))))) 
       (if (eq (car p1) :|VarPat|) 
           (if (eq (car p2) :|VarPat|) 
               (return (METASLANG::equalVar? (car (cdr p1)) (car (cdr p2))))) 
           (if (eq (car p1) :|EmbedPat|) 
               (let ((pV43 (cdr p1))) 
                 (if (eq (car p2) :|EmbedPat|) 
                     (let ((pV101 (cdr p2))) 
                       (return 
                        (cl:and 
                         (string=  (svref pV43 0) (svref pV101 0)) 
                         (cl:and 
                          (METASLANG::equalSort? (svref pV43 2) (svref pV101 2)) 
                          (METASLANG::equalOpt? 
                           (svref pV43 1) 
                           (svref pV101 1) 
                           #'METASLANG::equalPattern?-1))))))) 
               (if (eq (car p1) :|RecordPat|) 
                   (if (eq (car p2) :|RecordPat|) 
                       (return 
                        (METASLANG::equalList? 
                         (car (cdr p1)) 
                         (car (cdr p2)) 
                         #'(lambda (x) 
                            (let ((pV10 (cdr x))
                                  (pV9 (car x))) 
                              (block 
                               nil 
                               (return 
                                (cl:and 
                                 (string=  (car pV9) (car pV10)) 
                                 (METASLANG::equalPattern? (cdr pV9) (cdr pV10)))) 
                               (error 
                                "Nonexhaustive match failure in equalPattern?"))))))) 
                   (if (eq (car p1) :|WildPat|) 
                       (if (eq (car p2) :|WildPat|) 
                           (return 
                            (METASLANG::equalSort? (car (cdr p1)) (car (cdr p2))))) 
                       (if (eq (car p1) :|StringPat|) 
                           (if (eq (car p2) :|StringPat|) 
                               (return (string=  (car (cdr p1)) (car (cdr p2))))) 
                           (if (eq (car p1) :|BoolPat|) 
                               (if (eq (car p2) :|BoolPat|) 
                                   (return (eq (car (cdr p1)) (car (cdr p2))))) 
                               (if (eq (car p1) :|CharPat|) 
                                   (if (eq (car p2) :|CharPat|) 
                                       (return 
                                        (eq (car (cdr p1)) (car (cdr p2))))) 
                                   (if (eq (car p1) :|NatPat|) 
                                       (if (eq (car p2) :|NatPat|) 
                                           (return 
                                            ( =  (car (cdr p1)) (car (cdr p2))))) 
                                       (if (eq (car p1) :|RelaxPat|) 
                                           (let ((pV36 (cdr p1))) 
                                             (if (eq (car p2) :|RelaxPat|) 
                                                 (let ((pV63 (cdr p2))) 
                                                   (return 
                                                    (cl:and 
                                                     (METASLANG::equalPattern? 
                                                      (svref pV36 0) 
                                                      (svref pV63 0)) 
                                                     (METASLANG::equalTerm? 
                                                      (svref pV36 1) 
                                                      (svref pV63 1))))))) 
                                           (if (eq (car p1) :|QuotientPat|) 
                                               (let ((pV35 (cdr p1))) 
                                                 (if (eq (car p2) :|QuotientPat|) 
                                                     (let ((pV56 (cdr p2))) 
                                                       (return 
                                                        (cl:and 
                                                         (METASLANG::equalPattern? 
                                                          (svref pV35 0) 
                                                          (svref pV56 0)) 
                                                         (METASLANG::equalTerm? 
                                                          (svref pV35 1) 
                                                          (svref pV56 1))))))) 
                                               (if (eq (car p1) :|SortedPat|) 
                                                   (let ((pV34 (cdr p1))) 
                                                     (if (eq 
                                                          (car p2) 
                                                          :|SortedPat|) 
                                                         (let ((pV49 (cdr p2))) 
                                                           (return 
                                                            (cl:and 
                                                             (METASLANG::equalPattern? 
                                                              (svref pV34 0) 
                                                              (svref pV49 0)) 
                                                             (METASLANG::equalSort? 
                                                              (svref pV34 1) 
                                                              (svref pV49 1))))))))))))))))))) 
   (return nil)))

(defun METASLANG::equalTerm?-1 (x) (METASLANG::equalTerm? (car x) (cdr x)))

(defun METASLANG::equalVar?-1 (x) (METASLANG::equalVar? (car x) (cdr x)))

(defun METASLANG::equalTerm? (t1 t2) 
  (block 
   nil 
   (if (eq (car t1) :|Apply|) 
       (let ((pV65 (cdr t1))) 
         (if (eq (car t2) :|Apply|) 
             (let ((pV140 (cdr t2))) 
               (return 
                (cl:and 
                 (METASLANG::equalTerm? (svref pV65 0) (svref pV140 0)) 
                 (METASLANG::equalTerm? (svref pV65 1) (svref pV140 1))))))) 
       (if (eq (car t1) :|ApplyN|) 
           (if (eq (car t2) :|ApplyN|) 
               (return 
                (METASLANG::equalList? 
                 (car (cdr t1)) 
                 (car (cdr t2)) 
                 #'METASLANG::equalTerm?-1))) 
           (if (eq (car t1) :|Record|) 
               (if (eq (car t2) :|Record|) 
                   (return 
                    (METASLANG::equalList? 
                     (car (cdr t1)) 
                     (car (cdr t2)) 
                     #'(lambda (x) 
                        (let ((pV8 (cdr x))
                              (pV7 (car x))) 
                          (block 
                           nil 
                           (return 
                            (cl:and 
                             (string=  (car pV7) (car pV8)) 
                             (METASLANG::equalTerm? (cdr pV7) (cdr pV8)))) 
                           (error "Nonexhaustive match failure in equalTerm?"))))))) 
               (if (eq (car t1) :|Bind|) 
                   (let ((pV62 (cdr t1))) 
                     (if (eq (car t2) :|Bind|) 
                         (let ((pV122 (cdr t2))) 
                           (return 
                            (cl:and 
                             (slang-built-in::slang-term-equals 
                              (svref pV62 0) 
                              (svref pV122 0)) 
                             (cl:and 
                              (METASLANG::equalList? 
                               (svref pV62 1) 
                               (svref pV122 1) 
                               #'METASLANG::equalVar?-1) 
                              (METASLANG::equalTerm? 
                               (svref pV62 2) 
                               (svref pV122 2)))))))) 
                   (if (eq (car t1) :|Let|) 
                       (let ((pV61 (cdr t1))) 
                         (if (eq (car t2) :|Let|) 
                             (let ((pV114 (cdr t2))) 
                               (return 
                                (cl:and 
                                 (METASLANG::equalTerm? 
                                  (svref pV61 1) 
                                  (svref pV114 1)) 
                                 (METASLANG::equalList? 
                                  (svref pV61 0) 
                                  (svref pV114 0) 
                                  #'(lambda (x) 
                                     (let ((pV18 (cdr x))
                                           (pV17 (car x))) 
                                       (block 
                                        nil 
                                        (return 
                                         (cl:and 
                                          (METASLANG::equalPattern? 
                                           (car pV17) 
                                           (car pV18)) 
                                          (METASLANG::equalTerm? 
                                           (cdr pV17) 
                                           (cdr pV18)))) 
                                        (error 
                                         "Nonexhaustive match failure in equalTerm?")))))))))) 
                       (if (eq (car t1) :|LetRec|) 
                           (let ((pV60 (cdr t1))) 
                             (if (eq (car t2) :|LetRec|) 
                                 (let ((pV107 (cdr t2))) 
                                   (return 
                                    (cl:and 
                                     (METASLANG::equalTerm? 
                                      (svref pV60 1) 
                                      (svref pV107 1)) 
                                     (METASLANG::equalList? 
                                      (svref pV60 0) 
                                      (svref pV107 0) 
                                      #'(lambda (x) 
                                         (let ((pV26 (cdr x))
                                               (pV25 (car x))) 
                                           (block 
                                            nil 
                                            (return 
                                             (cl:and 
                                              (METASLANG::equalVar? 
                                               (car pV25) 
                                               (car pV26)) 
                                              (METASLANG::equalTerm? 
                                               (cdr pV25) 
                                               (cdr pV26)))) 
                                            (error 
                                             "Nonexhaustive match failure in equalTerm?")))))))))) 
                           (if (eq (car t1) :|Var|) 
                               (if (eq (car t2) :|Var|) 
                                   (return 
                                    (METASLANG::equalVar? 
                                     (car (cdr t1)) 
                                     (car (cdr t2))))) 
                               (if (eq (car t1) :|Fun|) 
                                   (let ((pV58 (cdr t1))) 
                                     (if (eq (car t2) :|Fun|) 
                                         (let ((pV95 (cdr t2))) 
                                           (return 
                                            (cl:and 
                                             (METASLANG::equalFun? 
                                              (svref pV58 0) 
                                              (svref pV95 0)) 
                                             (METASLANG::equalSort? 
                                              (svref pV58 1) 
                                              (svref pV95 1))))))) 
                                   (if (eq (car t1) :|Lambda|) 
                                       (if (eq (car t2) :|Lambda|) 
                                           (return 
                                            (METASLANG::equalList? 
                                             (car (cdr t1)) 
                                             (car (cdr t2)) 
                                             #'(lambda (x) 
                                                (let ((pV38 (cdr x))
                                                      (pV37 (car x))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (cl:and 
                                                     (METASLANG::equalPattern? 
                                                      (svref pV37 0) 
                                                      (svref pV38 0)) 
                                                     (cl:and 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV37 1) 
                                                       (svref pV38 1)) 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV37 2) 
                                                       (svref pV38 2))))) 
                                                   (error 
                                                    "Nonexhaustive match failure in equalTerm?"))))))) 
                                       (if (eq (car t1) :|IfThenElse|) 
                                           (let ((pV56 (cdr t1))) 
                                             (if (eq (car t2) :|IfThenElse|) 
                                                 (let ((pV82 (cdr t2))) 
                                                   (return 
                                                    (cl:and 
                                                     (METASLANG::equalTerm? 
                                                      (svref pV56 0) 
                                                      (svref pV82 0)) 
                                                     (cl:and 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV56 1) 
                                                       (svref pV82 1)) 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV56 2) 
                                                       (svref pV82 2)))))))) 
                                           (if (eq (car t1) :|Seq|) 
                                               (if (eq (car t2) :|Seq|) 
                                                   (return 
                                                    (METASLANG::equalList? 
                                                     (car (cdr t1)) 
                                                     (car (cdr t2)) 
                                                     #'METASLANG::equalTerm?-1))) 
                                               (if (eq (car t1) :|SortedTerm|) 
                                                   (let ((pV54 (cdr t1))) 
                                                     (if (eq 
                                                          (car t2) 
                                                          :|SortedTerm|) 
                                                         (let ((pV69 (cdr t2))) 
                                                           (return 
                                                            (cl:and 
                                                             (METASLANG::equalTerm? 
                                                              (svref pV54 0) 
                                                              (svref pV69 0)) 
                                                             (METASLANG::equalSort? 
                                                              (svref pV54 1) 
                                                              (svref pV69 1))))))))))))))))))) 
   (return nil)))

(defun METASLANG::equalSort? (s1 s2) 
  (block 
   nil 
   (if (eq (car s1) :|Arrow|) 
       (let ((pV76 (cdr s1))) 
         (if (eq (car s2) :|Arrow|) 
             (let ((pV121 (cdr s2))) 
               (return 
                (cl:and 
                 (METASLANG::equalSort? (svref pV76 0) (svref pV121 0)) 
                 (METASLANG::equalSort? (svref pV76 1) (svref pV121 1))))))) 
       (if (eq (car s1) :|Product|) 
           (if (eq (car s2) :|Product|) 
               (return 
                (METASLANG::equalList? 
                 (car (cdr s1)) 
                 (car (cdr s2)) 
                 #'(lambda (x) 
                    (let ((pV6 (cdr x))
                          (pV5 (car x))) 
                      (block 
                       nil 
                       (return 
                        (cl:and 
                         (string=  (car pV5) (car pV6)) 
                         (METASLANG::equalSort? (cdr pV5) (cdr pV6)))) 
                       (error "Nonexhaustive match failure in equalSort?"))))))) 
           (if (eq (car s1) :|CoProduct|) 
               (if (eq (car s2) :|CoProduct|) 
                   (return 
                    (METASLANG::equalList? 
                     (car (cdr s1)) 
                     (car (cdr s2)) 
                     #'(lambda (x) 
                        (let ((pV14 (cdr x))
                              (pV13 (car x))) 
                          (block 
                           nil 
                           (return 
                            (cl:and 
                             (string=  (car pV13) (car pV14)) 
                             (METASLANG::equalOpt? 
                              (cdr pV13) 
                              (cdr pV14) 
                              #'METASLANG::equalSort?-1))) 
                           (error "Nonexhaustive match failure in equalSort?"))))))) 
               (if (eq (car s1) :|Quotient|) 
                   (let ((pV73 (cdr s1))) 
                     (if (eq (car s2) :|Quotient|) 
                         (let ((pV104 (cdr s2))) 
                           (return 
                            (cl:and 
                             (METASLANG::equalSort? 
                              (svref pV73 0) 
                              (svref pV104 0)) 
                             (METASLANG::equalTerm? 
                              (svref pV73 1) 
                              (svref pV104 1))))))) 
                   (if (eq (car s1) :|Subsort|) 
                       (let ((pV72 (cdr s1))) 
                         (if (eq (car s2) :|Subsort|) 
                             (let ((pV97 (cdr s2))) 
                               (return 
                                (cl:and 
                                 (METASLANG::equalSort? 
                                  (svref pV72 0) 
                                  (svref pV97 0)) 
                                 (METASLANG::equalTerm? 
                                  (svref pV72 1) 
                                  (svref pV97 1))))))) 
                       (if (eq (car s1) :|Base|) 
                           (let ((pV71 (cdr s1))) 
                             (if (eq (car s2) :|Base|) 
                                 (let ((pV90 (cdr s2))) 
                                   (return 
                                    (cl:and 
                                     (slang-built-in::slang-term-equals 
                                      (svref pV71 0) 
                                      (svref pV90 0)) 
                                     (METASLANG::equalList? 
                                      (svref pV71 1) 
                                      (svref pV90 1) 
                                      #'METASLANG::equalSort?-1)))))) 
                           (if (eq (car s1) :|TyVar|) 
                               (if (eq (car s2) :|TyVar|) 
                                   (return 
                                    (string=  (car (cdr s1)) (car (cdr s2))))) 
                               (if (eq (car s1) :|MetaTyVar|) 
                                   (let ((pV77 (car (cdr s1)))) 
                                     (progn (if (eq (car s2) :|MetaTyVar|) 
                                                (return 
                                                 (let ((pV41 (STATE::|!!| pV77))) 
                                                   (block 
                                                    nil 
                                                    (let ((pV42 (svref pV41 0))) 
                                                      (return 
                                                       (let ((pV37 
                                                              (STATE::|!!| 
                                                               (car (cdr s2))))) 
                                                         (block 
                                                          nil 
                                                          (let ((pV38 
                                                                 (svref pV37 0))) 
                                                            (return 
                                                             (cl:or 
                                                              ( =  
                                                               (svref pV41 2) 
                                                               (svref pV37 2)) 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car pV42) 
                                                                    :|Some|) 
                                                                   (let ((pV35 
                                                                          (cdr 
                                                                           pV42))) 
                                                                     (progn (if (eq 
                                                                                 (car 
                                                                                  pV38) 
                                                                                 :|Some|) 
                                                                                (return 
                                                                                 (METASLANG::equalSort? 
                                                                                  pV35 
                                                                                  (cdr 
                                                                                   pV38)))) 
                                                                            (return 
                                                                             (METASLANG::equalSort? 
                                                                              pV35 
                                                                              s2))))) 
                                                               (if (eq 
                                                                    (car pV38) 
                                                                    :|Some|) 
                                                                   (return 
                                                                    (METASLANG::equalSort? 
                                                                     s1 
                                                                     (cdr pV38)))) 
                                                               (return nil))))) 
                                                          (error 
                                                           "Nonexhaustive match failure in equalSort?"))))) 
                                                    (error 
                                                     "Nonexhaustive match failure in equalSort?"))))) 
                                            (return 
                                             (let ((pV50 (STATE::|!!| pV77))) 
                                               (block 
                                                nil 
                                                (let ((pV51 (svref pV50 0))) 
                                                  (return 
                                                   (block 
                                                    nil 
                                                    (if (eq (car pV51) :|Some|) 
                                                        (return 
                                                         (METASLANG::equalSort? 
                                                          (cdr pV51) 
                                                          s2))) 
                                                    (return nil)))) 
                                                (error 
                                                 "Nonexhaustive match failure in equalSort?")))))))))))))) 
   (if (eq (car s2) :|MetaTyVar|) 
       (return 
        (let ((pV59 (STATE::|!!| (car (cdr s2))))) 
          (block 
           nil 
           (let ((pV60 (svref pV59 0))) 
             (return 
              (block 
               nil 
               (if (eq (car pV60) :|Some|) 
                   (return (METASLANG::equalSort? s1 (cdr pV60)))) 
               (return nil)))) 
           (error "Nonexhaustive match failure in equalSort?"))))) 
   (return nil)))

(defun equalSortScheme? (pV1 pV2) 
  (block 
   nil 
   (return 
    (cl:and 
     (slang-built-in::slang-term-equals (car pV1) (car pV2)) 
     (METASLANG::equalSort? (cdr pV1) (cdr pV2)))) 
   (error "Nonexhaustive match failure in equalSortScheme?")))

(defun equalTermScheme? (pV1 pV2) 
  (block 
   nil 
   (return 
    (cl:and 
     (slang-built-in::slang-term-equals (car pV1) (car pV2)) 
     (METASLANG::equalTerm? (cdr pV1) (cdr pV2)))) 
   (error "Nonexhaustive match failure in equalTermScheme?")))

(defun equalOpInfo? (pV1 pV2) 
  (block 
   nil 
   (let ((pV10 (svref pV2 3))) 
     (return 
      (cl:and 
       (slang-built-in::slang-term-equals (svref pV1 0) (svref pV2 0)) 
       (cl:and 
        (slang-built-in::slang-term-equals (svref pV1 1) (svref pV2 1)) 
        (cl:and 
         (equalSortScheme? (svref pV1 2) (svref pV2 2)) 
         (LIST-SPEC::all-1-1 
          #'(lambda (def1) 
             (LIST-SPEC::|!exists|-1-1 
              #'(lambda (def2) (equalTermScheme? def1 def2)) 
              pV10)) 
          (svref pV1 3))))))) 
   (error "Nonexhaustive match failure in equalOpInfo?")))

(defun equalOpInfo?-1 (x) (equalOpInfo? (car x) (cdr x)))

(defun equalSortInfo? (pV1 pV2) 
  (block 
   nil 
   (let ((pV8 (svref pV2 2))) 
     (return 
      (cl:and 
       (slang-built-in::slang-term-equals (svref pV1 0) (svref pV2 0)) 
       (cl:and 
        (slang-built-in::slang-term-equals (svref pV1 1) (svref pV2 1)) 
        (LIST-SPEC::all-1-1 
         #'(lambda (def1) 
            (LIST-SPEC::|!exists|-1-1 
             #'(lambda (def2) (equalSortScheme? def1 def2)) 
             pV8)) 
         (svref pV1 2)))))) 
   (error "Nonexhaustive match failure in equalSortInfo?")))

(defun equalSortInfo?-1 (x) (equalSortInfo? (car x) (cdr x)))

(defun equalSortScheme?-1 (x) (equalSortScheme? (car x) (cdr x)))

(defun equalTermScheme?-1 (x) (equalTermScheme? (car x) (cdr x)))

(defun STRINGMAP::find2 (m x y) 
  (let ((pV1 (STRINGMAP::|!find| m x))) 
    (block 
     nil 
     (if (eq (car pV1) :|None|) 
         (return '(:|None|)) 
         (if (eq (car pV1) :|Some|) (return (STRINGMAP::|!find| (cdr pV1) y)))) 
     (error "Nonexhaustive match failure in find2"))))

(defun findAQualifierMap (x1 x0 x) (STRINGMAP::find2 x1 x0 x))

(defun findAQualifierMap-1 (x) 
  (findAQualifierMap (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYMAP::foldriDouble (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldriDouble-1-1-1 x1 x2 x3))))

(defun STRINGMAP::foldriDouble (x) (SPLAYMAP::foldriDouble x))

(defun foldriAQualifierMap (x) (STRINGMAP::foldriDouble x))

(defun insertAQualifierMap-1 (x) 
  (insertAQualifierMap (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun memberQualifiedId (qualifier id qids) 
  (LIST-SPEC::|!exists|-1-1 
   #'(lambda (pV1) 
      (block 
       nil 
       (if (eq (car pV1) :|Qualified|) 
           (let ((pV2 (cdr pV1))) 
             (return 
              (cl:and (string=  (car pV2) qualifier) (string=  (cdr pV2) id))))) 
       (error "Nonexhaustive match failure in memberQualifiedId"))) 
   qids))

(defun localOp? (pV1 pV2) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV3 (cdr pV1))) 
         (return (memberQualifiedId (car pV3) (cdr pV3) (svref (svref pV2 0) 2))))) 
   (error "Nonexhaustive match failure in localOp?")))

(defun localOp?-1 (x) (localOp? (car x) (cdr x)))

(defun localSort? (pV1 pV2) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV3 (cdr pV1))) 
         (return (memberQualifiedId (car pV3) (cdr pV3) (svref (svref pV2 0) 3))))) 
   (error "Nonexhaustive match failure in localSort?")))

(defun localSort?-1 (x) (localSort? (car x) (cdr x)))

(defun SPLAYMAP::ap-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|SplayNil|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (let ((pV5 (svref pV2 2))) 
               (return 
                (let ((left (SPLAYMAP::ap-1-1 af (svref pV2 0)))) 
                  (let ((value (cons (car pV5) (funcall af (cdr pV5))))) 
                    (cons 
                     :|SplayObj| 
                     (vector left (SPLAYMAP::ap-1-1 af (svref pV2 1)) value))))))))) 
   (error "Nonexhaustive match failure in ap")))

(defun SPLAYMAP::|!map|-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return (cons :|EMPTY| (cdr |!map|))) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV2 (cdr |!map|))) 
             (return 
              (cons 
               :|MAP| 
               (vector 
                (svref pV2 0) 
                (svref pV2 1) 
                (cons :|Ref| (SPLAYMAP::ap-1-1 af (STATE::|!!| (svref pV2 2)))))))))) 
   (error "Nonexhaustive match failure in map")))

(defun STRINGMAP::|!map|-1-1 (x0 x1) (SPLAYMAP::|!map|-1-1 x0 x1))

(defun STRINGMAP::mapDouble-1-1 (f m) 
  (STRINGMAP::|!map|-1-1 #'(lambda (sm) (STRINGMAP::|!map|-1-1 f sm)) m))

(defun STRINGMAP::mapDouble (x1) 
  #'(lambda (x2) (STRINGMAP::mapDouble-1-1 x1 x2)))

(defun mapAQualifierMap (x) (STRINGMAP::mapDouble x))

(defun mapAQualifierMap-1-1 (x0 x1) (STRINGMAP::mapDouble-1-1 x0 x1))

(defun mapDiff-1-1 (xMap yMap) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((qual (svref x 0))
            (id (svref x 1))
            (newMap (svref x 3))) 
        (let ((pV2 (findAQualifierMap yMap qual id))) 
          (block 
           nil 
           (if (eq (car pV2) :|None|) 
               (return (insertAQualifierMap newMap qual id (svref x 2))) 
               (if (eq (car pV2) :|Some|) (return newMap))) 
           (error "Nonexhaustive match failure in mapDiff"))))) 
   emptyAQualifierMap 
   xMap))

(defun mapDiff (x1) #'(lambda (x2) (mapDiff-1-1 x1 x2)))

(defun LIST-SPEC::|!map|-1-1 (f s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return (cons (funcall f (car s)) (LIST-SPEC::|!map|-1-1 f (cdr s)))))) 
   (error "Nonexhaustive match failure in map")))

(defun METASLANG::mapPattern-1-1 (tsp_maps pattern) 
  (let ((pattern_map (svref tsp_maps 2))) 
    (labels 
      ((mapRec (pattern) (funcall pattern_map (mapP tsp_maps pattern)))
       (mapP (tsp_maps1 pattern) 
        (block 
         nil 
         (if (eq (car pattern) :|AliasPat|) 
             (let ((pV12 (cdr pattern))) 
               (let ((pV35 (svref pV12 0))
                     (pV36 (svref pV12 1))) 
                 (return 
                  (let ((newP1 (mapRec pV35))) 
                    (let ((newP2 (mapRec pV36))) 
                      (if (cl:and 
                           (slang-built-in::slang-term-equals newP1 pV35) 
                           (slang-built-in::slang-term-equals newP2 pV36)) 
                          pattern 
                          (cons :|AliasPat| (vector newP1 newP2 (svref pV12 2))))))))) 
             (if (eq (car pattern) :|EmbedPat|) 
                 (let ((pV11 (cdr pattern))) 
                   (let ((pV30 (svref pV11 0))
                         (pV31 (svref pV11 1))
                         (pV32 (svref pV11 2))
                         (pV33 (svref pV11 3))) 
                     (if (eq (car pV31) :|Some|) 
                         (let ((pV34 (cdr pV31))) 
                           (return 
                            (let ((newPat (mapRec pV34))) 
                              (let ((newSrt 
                                     (METASLANG::mapSort-1-1 tsp_maps1 pV32))) 
                                (if (cl:and 
                                     (slang-built-in::slang-term-equals 
                                      newPat 
                                      pV34) 
                                     (slang-built-in::slang-term-equals 
                                      newSrt 
                                      pV32)) 
                                    pattern 
                                    (cons 
                                     :|EmbedPat| 
                                     (vector 
                                      pV30 
                                      (cons :|Some| newPat) 
                                      newSrt 
                                      pV33))))))) 
                         (if (eq (car pV31) :|None|) 
                             (return 
                              (let ((newSrt 
                                     (METASLANG::mapSort-1-1 tsp_maps1 pV32))) 
                                (if (slang-built-in::slang-term-equals 
                                     newSrt 
                                     pV32) 
                                    pattern 
                                    (cons 
                                     :|EmbedPat| 
                                     (vector pV30 '(:|None|) newSrt pV33))))))))) 
                 (if (eq (car pattern) :|RelaxPat|) 
                     (let ((pV10 (cdr pattern))) 
                       (let ((pV27 (svref pV10 0))
                             (pV28 (svref pV10 1))) 
                         (return 
                          (let ((newPat (mapRec pV27))) 
                            (let ((newTrm 
                                   (METASLANG::mapTerm-1-1 tsp_maps1 pV28))) 
                              (if (cl:and 
                                   (slang-built-in::slang-term-equals 
                                    newPat 
                                    pV27) 
                                   (slang-built-in::slang-term-equals 
                                    newTrm 
                                    pV28)) 
                                  pattern 
                                  (cons 
                                   :|RelaxPat| 
                                   (vector newPat newTrm (svref pV10 2))))))))) 
                     (if (eq (car pattern) :|QuotientPat|) 
                         (let ((pV9 (cdr pattern))) 
                           (let ((pV24 (svref pV9 0))
                                 (pV25 (svref pV9 1))) 
                             (return 
                              (let ((newPat (mapRec pV24))) 
                                (let ((newTrm 
                                       (METASLANG::mapTerm-1-1 tsp_maps1 pV25))) 
                                  (if (cl:and 
                                       (slang-built-in::slang-term-equals 
                                        newPat 
                                        pV24) 
                                       (slang-built-in::slang-term-equals 
                                        newTrm 
                                        pV25)) 
                                      pattern 
                                      (cons 
                                       :|QuotientPat| 
                                       (vector newPat newTrm (svref pV9 2))))))))) 
                         (if (eq (car pattern) :|VarPat|) 
                             (let ((pV8 (cdr pattern))) 
                               (let ((pV20 (car pV8))) 
                                 (let ((pV23 (cdr pV20))) 
                                   (return 
                                    (let ((newSrt 
                                           (METASLANG::mapSort-1-1 
                                            tsp_maps1 
                                            pV23))) 
                                      (if (slang-built-in::slang-term-equals 
                                           newSrt 
                                           pV23) 
                                          pattern 
                                          (cons 
                                           :|VarPat| 
                                           (cons 
                                            (cons (car pV20) newSrt) 
                                            (cdr pV8))))))))) 
                             (if (eq (car pattern) :|WildPat|) 
                                 (let ((pV7 (cdr pattern))) 
                                   (let ((pV18 (car pV7))) 
                                     (return 
                                      (let ((newSrt 
                                             (METASLANG::mapSort-1-1 
                                              tsp_maps1 
                                              pV18))) 
                                        (if (slang-built-in::slang-term-equals 
                                             newSrt 
                                             pV18) 
                                            pattern 
                                            (cons 
                                             :|WildPat| 
                                             (cons newSrt (cdr pV7)))))))) 
                                 (if (eq (car pattern) :|RecordPat|) 
                                     (let ((pV6 (cdr pattern))) 
                                       (let ((pV16 (car pV6))) 
                                         (return 
                                          (let ((newFields 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'(lambda (x1) 
                                                     (cons 
                                                      (car x1) 
                                                      (mapRec (cdr x1)))) 
                                                  pV16))) 
                                            (if (slang-built-in::slang-term-equals 
                                                 newFields 
                                                 pV16) 
                                                pattern 
                                                (cons 
                                                 :|RecordPat| 
                                                 (cons newFields (cdr pV6)))))))) 
                                     (if (eq (car pattern) :|SortedPat|) 
                                         (let ((pV5 (cdr pattern))) 
                                           (let ((pV13 (svref pV5 0))
                                                 (pV14 (svref pV5 1))) 
                                             (return 
                                              (let ((newPat (mapRec pV13))) 
                                                (let ((newSrt 
                                                       (METASLANG::mapSort-1-1 
                                                        tsp_maps1 
                                                        pV14))) 
                                                  (if (cl:and 
                                                       (slang-built-in::slang-term-equals 
                                                        newPat 
                                                        pV13) 
                                                       (slang-built-in::slang-term-equals 
                                                        newSrt 
                                                        pV14)) 
                                                      pattern 
                                                      (cons 
                                                       :|SortedPat| 
                                                       (vector 
                                                        newPat 
                                                        newSrt 
                                                        (svref pV5 2))))))))))))))))) 
         (return pattern)))) (mapRec pattern))))

(defun METASLANG::mapTerm-1-1 (tsp_maps term) 
  (let ((term_map (svref tsp_maps 0))) 
    (labels 
      ((mapRec (term) (funcall term_map (mapT tsp_maps term)))
       (mapT (tsp_maps1 term) 
        (block 
         nil 
         (if (eq (car term) :|Fun|) 
             (let ((pV19 (cdr term))) 
               (let ((pV53 (svref pV19 1))) 
                 (return 
                  (let ((newSrt (METASLANG::mapSort-1-1 tsp_maps1 pV53))) 
                    (if (slang-built-in::slang-term-equals pV53 newSrt) 
                        term 
                        (cons 
                         :|Fun| 
                         (vector (svref pV19 0) newSrt (svref pV19 2)))))))) 
             (if (eq (car term) :|Var|) 
                 (let ((pV18 (cdr term))) 
                   (let ((pV48 (car pV18))) 
                     (let ((pV51 (cdr pV48))) 
                       (return 
                        (let ((newSrt (METASLANG::mapSort-1-1 tsp_maps1 pV51))) 
                          (if (slang-built-in::slang-term-equals pV51 newSrt) 
                              term 
                              (cons 
                               :|Var| 
                               (cons (cons (car pV48) newSrt) (cdr pV18))))))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV17 (cdr term))) 
                       (let ((pV45 (svref pV17 0))
                             (pV46 (svref pV17 1))) 
                         (return 
                          (let ((newDecls 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x1) 
                                     (cons 
                                      (METASLANG::mapPattern-1-1 
                                       tsp_maps1 
                                       (car x1)) 
                                      (mapRec (cdr x1)))) 
                                  pV45))) 
                            (let ((newBdy (mapRec pV46))) 
                              (if (cl:and 
                                   (slang-built-in::slang-term-equals 
                                    pV45 
                                    newDecls) 
                                   (slang-built-in::slang-term-equals 
                                    pV46 
                                    newBdy)) 
                                  term 
                                  (cons 
                                   :|Let| 
                                   (vector newDecls newBdy (svref pV17 2))))))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV16 (cdr term))) 
                           (let ((pV42 (svref pV16 0))
                                 (pV43 (svref pV16 1))) 
                             (return 
                              (let ((newDecls 
                                     (LIST-SPEC::|!map|-1-1 
                                      #'(lambda (x1) 
                                         (let ((pV3 (car x1))) 
                                           (block 
                                            nil 
                                            (return 
                                             (cons 
                                              (cons 
                                               (car pV3) 
                                               (METASLANG::mapSort-1-1 
                                                tsp_maps1 
                                                (cdr pV3))) 
                                              (mapRec (cdr x1)))) 
                                            (error 
                                             "Nonexhaustive match failure in mapTerm")))) 
                                      pV42))) 
                                (let ((newBdy (mapRec pV43))) 
                                  (if (cl:and 
                                       (slang-built-in::slang-term-equals 
                                        pV42 
                                        newDecls) 
                                       (slang-built-in::slang-term-equals 
                                        pV43 
                                        newBdy)) 
                                      term 
                                      (cons 
                                       :|LetRec| 
                                       (vector newDecls newBdy (svref pV16 2))))))))) 
                         (if (eq (car term) :|Record|) 
                             (let ((pV15 (cdr term))) 
                               (let ((pV40 (car pV15))) 
                                 (return 
                                  (let ((newRow 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x1) 
                                             (cons (car x1) (mapRec (cdr x1)))) 
                                          pV40))) 
                                    (if (slang-built-in::slang-term-equals 
                                         pV40 
                                         newRow) 
                                        term 
                                        (cons :|Record| (cons newRow (cdr pV15)))))))) 
                             (if (eq (car term) :|IfThenElse|) 
                                 (let ((pV14 (cdr term))) 
                                   (let ((pV36 (svref pV14 0))
                                         (pV37 (svref pV14 1))
                                         (pV38 (svref pV14 2))) 
                                     (return 
                                      (let ((newT1 (mapRec pV36))) 
                                        (let ((newT2 (mapRec pV37))) 
                                          (let ((newT3 (mapRec pV38))) 
                                            (if (cl:and 
                                                 (slang-built-in::slang-term-equals 
                                                  newT1 
                                                  pV36) 
                                                 (cl:and 
                                                  (slang-built-in::slang-term-equals 
                                                   newT2 
                                                   pV37) 
                                                  (slang-built-in::slang-term-equals 
                                                   newT3 
                                                   pV38))) 
                                                term 
                                                (cons 
                                                 :|IfThenElse| 
                                                 (vector 
                                                  newT1 
                                                  newT2 
                                                  newT3 
                                                  (svref pV14 3)))))))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (let ((pV13 (cdr term))) 
                                       (let ((pV34 (car pV13))) 
                                         (return 
                                          (let ((|!newMatch| 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'(lambda (x1) 
                                                     (vector 
                                                      (METASLANG::mapPattern-1-1 
                                                       tsp_maps1 
                                                       (svref x1 0)) 
                                                      (mapRec (svref x1 1)) 
                                                      (mapRec (svref x1 2)))) 
                                                  pV34))) 
                                            (if (slang-built-in::slang-term-equals 
                                                 pV34 
                                                 |!newMatch|) 
                                                term 
                                                (cons 
                                                 :|Lambda| 
                                                 (cons |!newMatch| (cdr pV13)))))))) 
                                     (if (eq (car term) :|Bind|) 
                                         (let ((pV12 (cdr term))) 
                                           (let ((pV31 (svref pV12 1))
                                                 (pV32 (svref pV12 2))) 
                                             (return 
                                              (let ((newVars 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x1) 
                                                         (cons 
                                                          (car x1) 
                                                          (METASLANG::mapSort-1-1 
                                                           tsp_maps1 
                                                           (cdr x1)))) 
                                                      pV31))) 
                                                (let ((newTrm (mapRec pV32))) 
                                                  (if (cl:and 
                                                       (slang-built-in::slang-term-equals 
                                                        pV31 
                                                        newVars) 
                                                       (slang-built-in::slang-term-equals 
                                                        pV32 
                                                        newTrm)) 
                                                      term 
                                                      (cons 
                                                       :|Bind| 
                                                       (vector 
                                                        (svref pV12 0) 
                                                        newVars 
                                                        newTrm 
                                                        (svref pV12 3))))))))) 
                                         (if (eq (car term) :|Apply|) 
                                             (let ((pV11 (cdr term))) 
                                               (let ((pV27 (svref pV11 0))
                                                     (pV28 (svref pV11 1))) 
                                                 (return 
                                                  (let ((newT1 (mapRec pV27))) 
                                                    (let ((newT2 (mapRec pV28))) 
                                                      (if (cl:and 
                                                           (slang-built-in::slang-term-equals 
                                                            newT1 
                                                            pV27) 
                                                           (slang-built-in::slang-term-equals 
                                                            newT2 
                                                            pV28)) 
                                                          term 
                                                          (cons 
                                                           :|Apply| 
                                                           (vector 
                                                            (mapRec newT1) 
                                                            (mapRec newT2) 
                                                            (svref pV11 2))))))))) 
                                             (if (eq (car term) :|Seq|) 
                                                 (let ((pV10 (cdr term))) 
                                                   (let ((pV25 (car pV10))) 
                                                     (return 
                                                      (let ((newTerms 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'mapRec 
                                                              pV25))) 
                                                        (if (slang-built-in::slang-term-equals 
                                                             newTerms 
                                                             pV25) 
                                                            term 
                                                            (cons 
                                                             :|Seq| 
                                                             (cons 
                                                              newTerms 
                                                              (cdr pV10)))))))) 
                                                 (if (eq (car term) :|ApplyN|) 
                                                     (let ((pV9 (cdr term))) 
                                                       (let ((pV23 (car pV9))) 
                                                         (return 
                                                          (let ((newTerms 
                                                                 (LIST-SPEC::|!map|-1-1 
                                                                  #'mapRec 
                                                                  pV23))) 
                                                            (if (slang-built-in::slang-term-equals 
                                                                 newTerms 
                                                                 pV23) 
                                                                term 
                                                                (cons 
                                                                 :|ApplyN| 
                                                                 (cons 
                                                                  newTerms 
                                                                  (cdr pV9)))))))) 
                                                     (if (eq 
                                                          (car term) 
                                                          :|SortedTerm|) 
                                                         (let ((pV8 (cdr term))) 
                                                           (let ((pV20 
                                                                  (svref pV8 0))
                                                                 (pV21 
                                                                  (svref pV8 1))) 
                                                             (return 
                                                              (let ((newTrm 
                                                                     (mapRec 
                                                                      pV20))) 
                                                                (let ((newSrt 
                                                                       (METASLANG::mapSort-1-1 
                                                                        tsp_maps1 
                                                                        pV21))) 
                                                                  (if (cl:and 
                                                                       (slang-built-in::slang-term-equals 
                                                                        newTrm 
                                                                        pV20) 
                                                                       (slang-built-in::slang-term-equals 
                                                                        pV21 
                                                                        newSrt)) 
                                                                      term 
                                                                      (cons 
                                                                       :|SortedTerm| 
                                                                       (vector 
                                                                        newTrm 
                                                                        newSrt 
                                                                        (svref 
                                                                         pV8 
                                                                         2))))))))))))))))))))) 
         (error "Nonexhaustive match failure in mapTerm")))) (mapRec term))))

(defun METASLANG::mapSort-1-1 (tsp_maps srt) 
  (let ((sort_map (svref tsp_maps 1))) 
    (labels 
      ((mapRec (tsp_maps1 sort_map srt) 
        (funcall sort_map (mapS tsp_maps1 sort_map srt)))
       (mapRecOpt (tsp_maps1 sort_map opt_sort) 
        (block 
         nil 
         (if (eq (car opt_sort) :|None|) 
             (return '(:|None|)) 
             (if (eq (car opt_sort) :|Some|) 
                 (return 
                  (cons :|Some| (mapRec tsp_maps1 sort_map (cdr opt_sort)))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapSRow (tsp_maps1 sort_map row) 
        (block 
         nil 
         (if (null row) 
             (return nil) 
             (if (consp row) 
                 (let ((pV48 (car row))) 
                   (return 
                    (LIST-SPEC::|!cons| 
                     (cons (car pV48) (mapRec tsp_maps1 sort_map (cdr pV48))) 
                     (mapSRow tsp_maps1 sort_map (cdr row))))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapSRowOpt (tsp_maps1 sort_map row) 
        (block 
         nil 
         (if (null row) 
             (return nil) 
             (if (consp row) 
                 (let ((pV42 (car row))) 
                   (return 
                    (LIST-SPEC::|!cons| 
                     (cons (car pV42) (mapRecOpt tsp_maps1 sort_map (cdr pV42))) 
                     (mapSRowOpt tsp_maps1 sort_map (cdr row))))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapSLst (tsp_maps1 sort_map srts) 
        (block 
         nil 
         (if (null srts) 
             (return nil) 
             (if (consp srts) 
                 (return 
                  (LIST-SPEC::|!cons| 
                   (mapRec tsp_maps1 sort_map (car srts)) 
                   (mapSLst tsp_maps1 sort_map (cdr srts)))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapS (tsp_maps1 sort_map srt) 
        (block 
         nil 
         (if (eq (car srt) :|CoProduct|) 
             (let ((pV17 (cdr srt))) 
               (let ((pV34 (car pV17))) 
                 (return 
                  (let ((newRow (mapSRowOpt tsp_maps1 sort_map pV34))) 
                    (if (slang-built-in::slang-term-equals newRow pV34) 
                        srt 
                        (cons :|CoProduct| (cons newRow (cdr pV17)))))))) 
             (if (eq (car srt) :|Product|) 
                 (let ((pV16 (cdr srt))) 
                   (let ((pV32 (car pV16))) 
                     (return 
                      (let ((newRow (mapSRow tsp_maps1 sort_map pV32))) 
                        (if (slang-built-in::slang-term-equals newRow pV32) 
                            srt 
                            (cons :|Product| (cons newRow (cdr pV16)))))))) 
                 (if (eq (car srt) :|Arrow|) 
                     (let ((pV15 (cdr srt))) 
                       (let ((pV29 (svref pV15 0))
                             (pV30 (svref pV15 1))) 
                         (return 
                          (let ((newS1 (mapRec tsp_maps1 sort_map pV29))) 
                            (let ((newS2 (mapRec tsp_maps1 sort_map pV30))) 
                              (if (cl:and 
                                   (slang-built-in::slang-term-equals newS1 pV29) 
                                   (slang-built-in::slang-term-equals newS2 pV30)) 
                                  srt 
                                  (cons 
                                   :|Arrow| 
                                   (vector newS1 newS2 (svref pV15 2))))))))) 
                     (if (eq (car srt) :|Quotient|) 
                         (let ((pV14 (cdr srt))) 
                           (let ((pV26 (svref pV14 0))
                                 (pV27 (svref pV14 1))) 
                             (return 
                              (let ((newSsrt (mapRec tsp_maps1 sort_map pV26))) 
                                (let ((newTrm 
                                       (METASLANG::mapTerm-1-1 tsp_maps1 pV27))) 
                                  (if (cl:and 
                                       (slang-built-in::slang-term-equals 
                                        newSsrt 
                                        pV26) 
                                       (slang-built-in::slang-term-equals 
                                        newTrm 
                                        pV27)) 
                                      srt 
                                      (cons 
                                       :|Quotient| 
                                       (vector newSsrt newTrm (svref pV14 2))))))))) 
                         (if (eq (car srt) :|Subsort|) 
                             (let ((pV13 (cdr srt))) 
                               (let ((pV23 (svref pV13 0))
                                     (pV24 (svref pV13 1))) 
                                 (return 
                                  (let ((newSsrt 
                                         (mapRec tsp_maps1 sort_map pV23))) 
                                    (let ((newTrm 
                                           (METASLANG::mapTerm-1-1 
                                            tsp_maps1 
                                            pV24))) 
                                      (if (cl:and 
                                           (slang-built-in::slang-term-equals 
                                            newSsrt 
                                            pV23) 
                                           (slang-built-in::slang-term-equals 
                                            newTrm 
                                            pV24)) 
                                          srt 
                                          (cons 
                                           :|Subsort| 
                                           (vector newSsrt newTrm (svref pV13 2))))))))) 
                             (if (eq (car srt) :|Base|) 
                                 (let ((pV12 (cdr srt))) 
                                   (let ((pV21 (svref pV12 1))) 
                                     (return 
                                      (let ((newSrts 
                                             (mapSLst tsp_maps1 sort_map pV21))) 
                                        (if (slang-built-in::slang-term-equals 
                                             newSrts 
                                             pV21) 
                                            srt 
                                            (cons 
                                             :|Base| 
                                             (vector 
                                              (svref pV12 0) 
                                              newSrts 
                                              (svref pV12 2)))))))) 
                                 (if (eq (car srt) :|MetaTyVar|) 
                                     (let ((pV11 (cdr srt))) 
                                       (return 
                                        (let ((pV5 (STATE::|!!| (car pV11)))) 
                                          (block 
                                           nil 
                                           (let ((pV6 (svref pV5 0))) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV6) :|None|) 
                                                   (return srt) 
                                                   (if (eq (car pV6) :|Some|) 
                                                       (let ((pV4 (cdr pV6))) 
                                                         (return 
                                                          (let ((|!newssrt| 
                                                                 (mapRec 
                                                                  tsp_maps1 
                                                                  sort_map 
                                                                  pV4))) 
                                                            (if (slang-built-in::slang-term-equals 
                                                                 |!newssrt| 
                                                                 pV4) 
                                                                srt 
                                                                (cons 
                                                                 :|MetaTyVar| 
                                                                 (cons 
                                                                  (cons 
                                                                   :|Ref| 
                                                                   (vector 
                                                                    (cons 
                                                                     :|Some| 
                                                                     |!newssrt|) 
                                                                    (svref pV5 1) 
                                                                    (svref pV5 2))) 
                                                                  (cdr pV11))))))))) 
                                               (error 
                                                "Nonexhaustive match failure in mapSort")))) 
                                           (error 
                                            "Nonexhaustive match failure in mapSort")))))))))))) 
         (return srt)))) (mapRec tsp_maps sort_map srt))))

(defun mapSortSchemes-1-1 (tsp_maps sort_schemes) 
  (LIST-SPEC::|!map|-1-1 
   #'(lambda (x) (cons (car x) (METASLANG::mapSort-1-1 tsp_maps (cdr x)))) 
   sort_schemes))

(defun mapSortSchemes-1 (x1) #'(lambda (x2) (mapSortSchemes-1-1 x1 x2)))

(defun mapSortSchemes (x0 x1 x2) (mapSortSchemes-1 (vector x0 x1 x2)))

(defun mapTermSchemes-1-1 (tsp_maps term_schemes) 
  (LIST-SPEC::|!map|-1-1 
   #'(lambda (x) (cons (car x) (METASLANG::mapTerm-1-1 tsp_maps (cdr x)))) 
   term_schemes))

(defun mapSpec-1-1 (tsp_maps x) 
  (vector 
   (svref x 0) 
   (mapAQualifierMap-1-1 
    #'(lambda (x1) 
       (let ((pV3 (svref x1 2))) 
         (block 
          nil 
          (return 
           (vector 
            (svref x1 0) 
            (svref x1 1) 
            (cons (car pV3) (METASLANG::mapSort-1-1 tsp_maps (cdr pV3))) 
            (mapTermSchemes-1-1 tsp_maps (svref x1 3)))) 
          (error "Nonexhaustive match failure in mapSpec")))) 
    (svref x 1)) 
   (LIST-SPEC::|!map|-1-1 
    #'(lambda (x1) 
       (vector 
        (svref x1 0) 
        (svref x1 1) 
        (svref x1 2) 
        (METASLANG::mapTerm-1-1 tsp_maps (svref x1 3)))) 
    (svref x 2)) 
   (mapAQualifierMap-1-1 
    #'(lambda (x1) 
       (vector 
        (svref x1 0) 
        (svref x1 1) 
        (mapSortSchemes-1-1 tsp_maps (svref x1 2)))) 
    (svref x 3))))

(defun mapSpec-1 (x1) #'(lambda (x2) (mapSpec-1-1 x1 x2)))

(defun mapSpec (x0 x1 x2) (mapSpec-1 (vector x0 x1 x2)))

(defun mapTermSchemes-1 (x1) #'(lambda (x2) (mapTermSchemes-1-1 x1 x2)))

(defun mapTermSchemes (x0 x1 x2) (mapTermSchemes-1 (vector x0 x1 x2)))

(defun SPLAYMAP::api-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|SplayNil|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV3 (cdr sp))) 
             (let ((pV6 (svref pV3 2))) 
               (return 
                (let ((left (SPLAYMAP::api-1-1 af (svref pV3 0)))) 
                  (let ((value (cons (car pV6) (funcall af pV6)))) 
                    (cons 
                     :|SplayObj| 
                     (vector left (SPLAYMAP::api-1-1 af (svref pV3 1)) value))))))))) 
   (error "Nonexhaustive match failure in api")))

(defun SPLAYMAP::mapi-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return (cons :|EMPTY| (cdr |!map|))) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV2 (cdr |!map|))) 
             (return 
              (cons 
               :|MAP| 
               (vector 
                (svref pV2 0) 
                (svref pV2 1) 
                (cons :|Ref| (SPLAYMAP::api-1-1 af (STATE::|!!| (svref pV2 2)))))))))) 
   (error "Nonexhaustive match failure in mapi")))

(defun STRINGMAP::mapi-1-1 (x0 x1) (SPLAYMAP::mapi-1-1 x0 x1))

(defun STRINGMAP::mapiDouble-1-1 (f m) 
  (STRINGMAP::mapi-1-1 
   #'(lambda (x) 
      (let ((x1 (car x))) 
        (STRINGMAP::mapi-1-1 
         #'(lambda (x01) (funcall f (vector x1 (car x01) (cdr x01)))) 
         (cdr x)))) 
   m))

(defun STRINGMAP::mapiDouble (x1) 
  #'(lambda (x2) (STRINGMAP::mapiDouble-1-1 x1 x2)))

(defun mapiAQualifierMap (x) (STRINGMAP::mapiDouble x))

(defun mapiAQualifierMap-1-1 (x0 x1) (STRINGMAP::mapiDouble-1-1 x0 x1))

(defun memberNames-1 (x) (memberNames (car x) (cdr x)))

(defun memberQualifiedId-1 (x) 
  (memberQualifiedId (svref x 0) (svref x 1) (svref x 2)))

(defun opInfosAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((new_list (svref x 3))
            (this_op_info (svref x 2))) 
        (if (LIST-SPEC::|!exists|-1-1 
             #'(lambda (old_info) (equalOpInfo? old_info this_op_info)) 
             new_list) 
            new_list 
            (LIST-SPEC::|!cons| this_op_info new_list)))) 
   nil 
   (svref spc 1)))

(defun opInfosAsList (x0 x1 x2 x3) (opInfosAsList-1 (vector x0 x1 x2 x3)))

(defun opNames-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) (LIST-SPEC::concat (svref x 3) (cons (svref x 1) nil))) 
   nil 
   (svref spc 1)))

(defun opNames (x0 x1 x2 x3) (opNames-1 (vector x0 x1 x2 x3)))

(defun opsAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (LIST-SPEC::|!cons| 
       (vector (svref x 0) (svref x 1) (svref x 2)) 
       (svref x 3))) 
   nil 
   (svref spc 1)))

(defun opsAsList (x0 x1 x2 x3) (opsAsList-1 (vector x0 x1 x2 x3)))

(defun STRINGMAP::foldri-1-1-1 (x0 x1 x2) (SPLAYMAP::foldri-1-1-1 x0 x1 x2))

(defun qualifiers (m) 
  (STRINGMAP::foldri-1-1-1 
   #'(lambda (x) (LIST-SPEC::|!cons| (svref x 0) (svref x 2))) 
   nil 
   m))

(defun setImportInfo (pV2 pV3) 
  (block 
   nil 
   (return (vector pV3 (svref pV2 1) (svref pV2 2) (svref pV2 3))) 
   (error "Nonexhaustive match failure in setImportInfo")))

(defun setImportInfo-1 (x) (setImportInfo (car x) (cdr x)))

(defun setImportedSpec (pV2 pV3) 
  (block 
   nil 
   (let ((pV4 (svref pV2 0))) 
     (return 
      (vector 
       (vector 
        (cons 
         :|Some| 
         (vector (svref pV3 0) (svref pV3 1) (svref pV3 2) (svref pV3 3))) 
        (svref pV4 1) 
        (svref pV4 2) 
        (svref pV4 3)) 
       (svref pV2 1) 
       (svref pV2 2) 
       (svref pV2 3)))) 
   (error "Nonexhaustive match failure in setImportedSpec")))

(defun setImportedSpec-1 (x) (setImportedSpec (car x) (cdr x)))

(defun setImports-1 (x) (setImports (car x) (cdr x)))

(defun setLocalOps (pV2 pV3) 
  (block 
   nil 
   (let ((pV4 (svref pV2 0))) 
     (return 
      (vector 
       (vector (svref pV4 0) (svref pV4 1) pV3 (svref pV4 3)) 
       (svref pV2 1) 
       (svref pV2 2) 
       (svref pV2 3)))) 
   (error "Nonexhaustive match failure in setLocalOps")))

(defun setLocalOps-1 (x) (setLocalOps (car x) (cdr x)))

(defun setLocalSorts (pV2 pV3) 
  (block 
   nil 
   (let ((pV4 (svref pV2 0))) 
     (return 
      (vector 
       (vector (svref pV4 0) (svref pV4 1) (svref pV4 2) pV3) 
       (svref pV2 1) 
       (svref pV2 2) 
       (svref pV2 3)))) 
   (error "Nonexhaustive match failure in setLocalSorts")))

(defun setLocalSorts-1 (x) (setLocalSorts (car x) (cdr x)))

(defun setOps-1 (x) (setOps (car x) (cdr x)))

(defun setProperties-1 (x) (setProperties (car x) (cdr x)))

(defun setSorts-1 (x) (setSorts (car x) (cdr x)))

(defun sortInfosAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((new_list (svref x 3))
            (this_sort_info (svref x 2))) 
        (if (LIST-SPEC::|!exists|-1-1 
             #'(lambda (old_info) (equalSortInfo? old_info this_sort_info)) 
             new_list) 
            new_list 
            (LIST-SPEC::|!cons| this_sort_info new_list)))) 
   nil 
   (svref spc 3)))

(defun sortInfosAsList (x0 x1 x2 x3) (sortInfosAsList-1 (vector x0 x1 x2 x3)))

(defun sortNames-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) (LIST-SPEC::concat (svref x 3) (cons (svref x 1) nil))) 
   nil 
   (svref spc 3)))

(defun sortNames (x0 x1 x2 x3) (sortNames-1 (vector x0 x1 x2 x3)))

(defun sortsAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (LIST-SPEC::|!cons| 
       (vector (svref x 0) (svref x 1) (svref x 2)) 
       (svref x 3))) 
   nil 
   (svref spc 3)))

(defun sortsAsList (x0 x1 x2 x3) (sortsAsList-1 (vector x0 x1 x2 x3)))

(defun specOps-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (let ((pV7 (svref (svref x 2) 2))) 
         (return 
          (LIST-SPEC::|!cons| 
           (vector (svref x 0) (svref x 1) (car pV7) (cdr pV7)) 
           (svref x 3)))) 
       (error "Nonexhaustive match failure in specOps"))) 
   nil 
   (svref spc 1)))

(defun specOps (x0 x1 x2 x3) (specOps-1 (vector x0 x1 x2 x3)))

(defun specSorts-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (return 
        (LIST-SPEC::|!cons| 
         (vector (svref x 0) (svref x 1) (svref (svref x 2) 1)) 
         (svref x 3))) 
       (error "Nonexhaustive match failure in specSorts"))) 
   nil 
   (svref spc 3)))

(defun specSorts (x0 x1 x2 x3) (specSorts-1 (vector x0 x1 x2 x3)))

(defun LIST-SPEC::foldl-1-1-1 (f base s) 
  (block 
   nil 
   (if (null s) 
       (return base) 
       (if (consp s) 
           (return 
            (LIST-SPEC::foldl-1-1-1 f (funcall f (cons (car s) base)) (cdr s))))) 
   (error "Nonexhaustive match failure in foldl")))

(defun subtractSpec-1-1 (x y) 
  (vector 
   (svref x 0) 
   (mapDiff-1-1 (svref x 1) (svref y 1)) 
   (LIST-SPEC::foldl-1-1-1 
    #'(lambda (x0) 
       (let ((x (car x0))
             (l (cdr x0))) 
         (if (LIST-SPEC::|!member| x (svref y 2)) l (cons x l)))) 
    nil 
    (svref x 2)) 
   (mapDiff-1-1 (svref x 3) (svref y 3))))

(defun subtractSpec-1 (x1) #'(lambda (x2) (subtractSpec-1-1 x1 x2)))

(defun subtractSpec (x0 x1 x2 x3) (subtractSpec-1 (vector x0 x1 x2 x3)))

(defun INTEGER-SPEC::compare (n m) 
  (if (INTEGER-SPEC::|!<| n m) 
      '(:|Less|) 
      (if ( =  n m) '(:|Equal|) '(:|Greater|))))

(defun INTEGER-SPEC::compare-1 (x) (INTEGER-SPEC::compare (car x) (cdr x)))

(defun SPLAYSET::empty (comp) (cons :|EMPTY| comp))

(defparameter INTEGERSET::empty (SPLAYSET::empty #'INTEGER-SPEC::compare-1))

(defparameter NATMAP::empty (SPLAYMAP::empty #'INTEGER-SPEC::compare-1))

(defun ANNSPECPRINTER::initialize (pp printSort?) 
  (vector 
   INTEGERSET::empty 
   (cons :|Ref| 0) 
   nil 
   (cons :|Ref| NATMAP::empty) 
   pp 
   printSort? 
   INTEGERSET::empty))

(defun ANNSPECPRINTER::isShortTuple (i row) 
  (block 
   nil 
   (if (null row) 
       (return t) 
       (if (consp row) 
           (return 
            (cl:and 
             (string=  (car (car row)) (NAT-SPEC::toString i)) 
             (ANNSPECPRINTER::isShortTuple (INTEGER-SPEC::|!+| i 1) (cdr row)))))) 
   (error "Nonexhaustive match failure in isShortTuple")))

(defun ANNSPECPRINTER::markSubterm?-1 (c) (svref c 2))

(defun ANNSPECPRINTER::isFiniteList (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV83 (svref (cdr term) 0))) 
         (if (eq (car pV83) :|Embed|) 
             (let ((pV86 (cdr pV83))) 
               (if (string=  "Nil" (car pV86)) 
                   (if (eq nil (cdr pV86)) (return (cons :|Some| nil))))))) 
       (if (eq (car term) :|Apply|) 
           (let ((pV24 (cdr term))) 
             (let ((pV61 (svref pV24 1))
                   (pV60 (svref pV24 0))) 
               (if (eq (car pV60) :|Fun|) 
                   (let ((pV64 (svref (cdr pV60) 0))) 
                     (if (eq (car pV64) :|Embed|) 
                         (let ((pV67 (cdr pV64))) 
                           (if (string=  "Cons" (car pV67)) 
                               (if (eq t (cdr pV67)) 
                                   (if (eq (car pV61) :|Record|) 
                                       (let ((pV71 (car (cdr pV61)))) 
                                         (if (consp pV71) 
                                             (let ((pV75 (cdr pV71))) 
                                               (if (consp pV75) 
                                                   (if (null (cdr pV75)) 
                                                       (return 
                                                        (let ((pV9 
                                                               (ANNSPECPRINTER::isFiniteList 
                                                                (cdr (car pV75))))) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car pV9) 
                                                                :|Some|) 
                                                               (return 
                                                                (cons 
                                                                 :|Some| 
                                                                 (LIST-SPEC::|!cons| 
                                                                  (cdr 
                                                                   (car pV71)) 
                                                                  (cdr pV9)))) 
                                                               (if (eq 
                                                                    (car pV9) 
                                                                    :|None|) 
                                                                   (return 
                                                                    '(:|None|)))) 
                                                           (error 
                                                            "Nonexhaustive match failure in isFiniteList")))))))))))))))))) 
           (if (eq (car term) :|ApplyN|) 
               (let ((pV26 (car (cdr term)))) 
                 (if (consp pV26) 
                     (let ((pV30 (cdr pV26))
                           (pV29 (car pV26))) 
                       (if (eq (car pV29) :|Fun|) 
                           (let ((pV32 (svref (cdr pV29) 0))) 
                             (if (eq (car pV32) :|Embed|) 
                                 (let ((pV35 (cdr pV32))) 
                                   (if (string=  "Cons" (car pV35)) 
                                       (if (eq t (cdr pV35)) 
                                           (if (consp pV30) 
                                               (let ((pV40 (cdr pV30))) 
                                                 (if (consp pV40) 
                                                     (let ((pV43 (cdr pV40))
                                                           (pV42 (car pV40))) 
                                                       (if (eq 
                                                            (car pV42) 
                                                            :|Record|) 
                                                           (let ((pV45 
                                                                  (car 
                                                                   (cdr pV42)))) 
                                                             (if (consp pV45) 
                                                                 (let ((pV49 
                                                                        (cdr 
                                                                         pV45))) 
                                                                   (if (consp 
                                                                        pV49) 
                                                                       (if (null 
                                                                            (cdr 
                                                                             pV49)) 
                                                                           (if (consp 
                                                                                pV43) 
                                                                               (if (null 
                                                                                    (cdr 
                                                                                     pV43)) 
                                                                                   (return 
                                                                                    (let ((pV19 
                                                                                           (ANNSPECPRINTER::isFiniteList 
                                                                                            (cdr 
                                                                                             (car 
                                                                                              pV49))))) 
                                                                                      (block 
                                                                                       nil 
                                                                                       (if (eq 
                                                                                            (car 
                                                                                             pV19) 
                                                                                            :|Some|) 
                                                                                           (return 
                                                                                            (cons 
                                                                                             :|Some| 
                                                                                             (LIST-SPEC::|!cons| 
                                                                                              (cdr 
                                                                                               (car 
                                                                                                pV45)) 
                                                                                              (cdr 
                                                                                               pV19)))) 
                                                                                           (if (eq 
                                                                                                (car 
                                                                                                 pV19) 
                                                                                                :|None|) 
                                                                                               (return 
                                                                                                '(:|None|)))) 
                                                                                       (error 
                                                                                        "Nonexhaustive match failure in isFiniteList")))))))))))))))))))))))))))) 
   (return '(:|None|))))

(defun LISTUTILITIES::mapWithIndexRec (f ls i) 
  (block 
   nil 
   (if (null ls) 
       (return nil) 
       (if (consp ls) 
           (return 
            (LIST-SPEC::|!cons| 
             (funcall f (cons i (car ls))) 
             (LISTUTILITIES::mapWithIndexRec f (cdr ls) (INTEGER-SPEC::|!+| i 1)))))) 
   (error "Nonexhaustive match failure in mapWithIndexRec")))

(defun LISTUTILITIES::mapWithIndex-1-1 (f l) 
  (LISTUTILITIES::mapWithIndexRec f l 0))

(defun PRETTYPRINT::blankLines (n text) 
  (if (INTEGER-SPEC::|!<=| n 0) 
      text 
      (cons (cons 0 nil) (PRETTYPRINT::blankLines (INTEGER-SPEC::|!-| n 1) text))))


(defun PRETTYPRINT::addBreak (indent |!newlines| text) 
  (cons (cons indent nil) (PRETTYPRINT::blankLines |!newlines| text)))

(defun PRETTYPRINT::lengthStrings (strings) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (return (INTEGER-SPEC::|!+| (cdr x) (car (car x)))) 
       (error "Nonexhaustive match failure in lengthStrings"))) 
   0 
   strings))

(defun PRETTYPRINT::lengthLast (|!t|) 
  (block 
   nil 
   (if (null |!t|) 
       (return 0) 
       (if (consp |!t|) 
           (let ((pV4 (car |!t|))) 
             (return 
              (INTEGER-SPEC::|!+| 
               (car pV4) 
               (PRETTYPRINT::lengthStrings (cdr pV4))))))) 
   (error "Nonexhaustive match failure in lengthLast")))

(defun PRETTYPRINT::fits? (columns width text) 
  (INTEGER-SPEC::|!<=| 
   (INTEGER-SPEC::|!+| (PRETTYPRINT::lengthLast text) width) 
   columns))

(defun PRETTYPRINT::formatPretty (columns p text) 
  (funcall (cdr p) (cons columns text)))

(defun PRETTYPRINT::formatLines (columns lines text |!break|) 
  (labels 
    ((formatRestLines (lines text) 
      (block 
       nil 
       (if (null lines) 
           (return text) 
           (if (consp lines) 
               (let ((pV3 (car lines))) 
                 (return 
                  (formatRestLines 
                   (cdr lines) 
                   (funcall |!break| (vector (car pV3) (cdr pV3) text))))))) 
       (error "Nonexhaustive match failure in formatLines")))) 
    (block 
     nil 
     (if (null lines) 
         (return text) 
         (if (consp lines) 
             (return 
              (formatRestLines 
               (cdr lines) 
               (PRETTYPRINT::formatPretty columns (cdr (car lines)) text))))) 
     (error "Nonexhaustive match failure in formatLines"))))

(defun PRETTYPRINT::pretty (width |!format|) (cons width |!format|))

(defun PRETTYPRINT::widthPretty-1 (p) (car p))

(defun PRETTYPRINT::widthLine (indent pretty) 
  (INTEGER-SPEC::|!+| indent (PRETTYPRINT::widthPretty-1 pretty)))

(defun PRETTYPRINT::widthLine-1 (x) (PRETTYPRINT::widthLine (car x) (cdr x)))

(defun PRETTYPRINT::widthLines (lines) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (INTEGER-SPEC::|!+| (PRETTYPRINT::widthLine-1 (car x)) (cdr x))) 
   0 
   lines))

(defun PRETTYPRINT::blockFill (|!newlines| lines) 
  (PRETTYPRINT::pretty 
   (PRETTYPRINT::widthLines lines) 
   #'(lambda (x) 
      (let ((text (cdr x))
            (columns (car x))) 
        (let ((start (PRETTYPRINT::lengthLast text))) 
          (PRETTYPRINT::formatLines 
           columns 
           lines 
           text 
           #'(lambda (x1) 
              (let ((text (svref x1 2))
                    (pretty (svref x1 1))) 
                (PRETTYPRINT::formatPretty 
                 columns 
                 pretty 
                 (if (PRETTYPRINT::fits? 
                      columns 
                      (PRETTYPRINT::widthPretty-1 pretty) 
                      text) 
                     text 
                     (PRETTYPRINT::addBreak 
                      (INTEGER-SPEC::|!+| start (svref x1 0)) 
                      |!newlines| 
                      text)))))))))))

(defun PRETTYPRINT::blockAll (|!newlines| lines) 
  (PRETTYPRINT::pretty 
   (PRETTYPRINT::widthLines lines) 
   #'(lambda (x) 
      (let ((text (cdr x))
            (columns (car x))) 
        (let ((start (PRETTYPRINT::lengthLast text))) 
          (PRETTYPRINT::formatLines 
           columns 
           lines 
           text 
           #'(lambda (x1) 
              (PRETTYPRINT::formatPretty 
               columns 
               (svref x1 1) 
               (PRETTYPRINT::addBreak 
                (INTEGER-SPEC::|!+| start (svref x1 0)) 
                |!newlines| 
                (svref x1 2))))))))))

(defun PRETTYPRINT::blockAll-1 (x) (PRETTYPRINT::blockAll (car x) (cdr x)))

(defun PRETTYPRINT::prettysBlock-1-1 (|!block| ps) 
  (funcall |!block| 
           (cons 0 (LIST-SPEC::|!map|-1-1 #'(lambda (p) (cons 0 p)) ps))))

(defun PRETTYPRINT::prettysAll (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockAll-1 ps))

(defun PRETTYPRINT::blockNone (pV1 lines) 
  (declare (ignore pV1)) 
  (PRETTYPRINT::pretty 
   (PRETTYPRINT::widthLines lines) 
   #'(lambda (x) 
      (let ((columns (car x))) 
        (PRETTYPRINT::formatLines 
         columns 
         lines 
         (cdr x) 
         #'(lambda (x1) 
            (PRETTYPRINT::formatPretty columns (svref x1 1) (svref x1 2))))))))

(defun PRETTYPRINT::blockNone-1 (x) (PRETTYPRINT::blockNone (car x) (cdr x)))

(defun PRETTYPRINT::prettysNone (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockNone-1 ps))

(defun PRETTYPRINT::extend (|!length| |!string| text) 
  (block 
   nil 
   (if (null text) 
       (return (cons (cons 0 (cons (cons |!length| |!string|) nil)) nil)) 
       (if (consp text) 
           (let ((pV3 (car text))) 
             (return 
              (cons 
               (cons (car pV3) (cons (cons |!length| |!string|) (cdr pV3))) 
               (cdr text)))))) 
   (error "Nonexhaustive match failure in extend")))

(defun PRETTYPRINT::lengthString (l s) 
  (PRETTYPRINT::pretty l #'(lambda (x) (PRETTYPRINT::extend l s (cdr x)))))

(defun PRETTYPRINT::|!string| (s) 
  (PRETTYPRINT::lengthString (STRING-SPEC::|!length| s) s))

(defun ANNSPECPRINTER::printLambda (context path marker match) 
  (let ((pp (svref context 4))) 
    (labels 
      ((prRule (marker) 
        #'(lambda (x) 
           (let ((pV11 (cdr x))
                 (pV10 (car x))) 
             (block 
              nil 
              (let ((pV14 (svref pV11 2))
                    (pV13 (svref pV11 1))
                    (pV12 (svref pV11 0))) 
                (return 
                 (block 
                  nil 
                  (if (eq (car pV13) :|Fun|) 
                      (let ((pV6 (svref (cdr pV13) 0))) 
                        (if (eq (car pV6) :|Bool|) 
                            (if (eq t (cdr pV6)) 
                                (return 
                                 (PRETTYPRINT::blockFill 
                                  0 
                                  (cons 
                                   (cons 
                                    0 
                                    (PRETTYPRINT::prettysNone 
                                     (cons 
                                      marker 
                                      (cons 
                                       (ANNSPECPRINTER::ppPattern-1-1-1 
                                        context 
                                        (cons 
                                         (LIST-SPEC::|!++| 
                                          (cons 0 (cons pV10 nil)) 
                                          path) 
                                         t) 
                                        pV12) 
                                       (cons (svref pp 1) nil))))) 
                                   (cons 
                                    (cons 
                                     3 
                                     (ANNSPECPRINTER::ppTerm-1-1-1 
                                      context 
                                      (cons 
                                       (LIST-SPEC::|!++| 
                                        (cons 2 (cons pV10 nil)) 
                                        path) 
                                       '(:|Top|)) 
                                      pV14)) 
                                    nil)))))))) 
                  (return 
                   (PRETTYPRINT::blockFill 
                    0 
                    (cons 
                     (cons 
                      0 
                      (PRETTYPRINT::prettysNone 
                       (cons 
                        marker 
                        (cons 
                         (ANNSPECPRINTER::ppPattern-1-1-1 
                          context 
                          (cons 
                           (LIST-SPEC::|!++| (cons 0 (cons pV10 nil)) path) 
                           t) 
                          pV12) 
                         (cons 
                          (PRETTYPRINT::|!string| " ") 
                          (cons 
                           (svref pp 37) 
                           (cons 
                            (PRETTYPRINT::|!string| " ") 
                            (cons 
                             (ANNSPECPRINTER::ppTerm-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 (cons pV10 nil)) path) 
                               '(:|Top|)) 
                              pV13) 
                             (cons (svref pp 1) nil))))))))) 
                     (cons 
                      (cons 
                       3 
                       (ANNSPECPRINTER::ppTerm-1-1-1 
                        context 
                        (cons 
                         (LIST-SPEC::|!++| (cons 3 (cons pV10 nil)) path) 
                         '(:|Top|)) 
                        pV14)) 
                      nil))))))) 
              (error "Nonexhaustive match failure in printLambda")))))) 
      (PRETTYPRINT::prettysAll 
       (block 
        nil 
        (if (null match) 
            (return nil) 
            (if (consp match) 
                (return 
                 (LIST-SPEC::|!++| 
                  (cons (funcall (prRule marker) (cons 0 (car match))) nil) 
                  (LISTUTILITIES::mapWithIndex-1-1 
                   #'(lambda (x) 
                      (funcall (prRule (svref pp 3)) 
                               (cons (INTEGER-SPEC::|!+| (car x) 1) (cdr x)))) 
                   (cdr match)))))) 
        (error "Nonexhaustive match failure in printLambda"))))))

(defparameter METASLANG::UnQualified "<unqualified>")

(defun METASLANG::mkABase (qid srts a) (cons :|Base| (vector qid srts a)))

(defun METASLANG::boolSort (a) 
  (METASLANG::mkABase (cons :|Qualified| (cons "Boolean" "Boolean")) nil a))

(defun METASLANG::mkTrueA (a) 
  (cons :|Fun| (vector (cons :|Bool| t) (METASLANG::boolSort a) a)))

(defun PRETTYPRINT::blockFill-1 (x) (PRETTYPRINT::blockFill (car x) (cdr x)))

(defun PRETTYPRINT::prettysFill (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockFill-1 ps))

(defun ANNSPECPRINTER::printOp (context pp termOp srt a) 
  (block 
   nil 
   (if (eq (car termOp) :|Op|) 
       (return (funcall (svref pp 42) (car (cdr termOp)))) 
       (if (eq (car termOp) :|Bool|) 
           (return (funcall (svref pp 38) (BOOLEAN-SPEC::toString (cdr termOp)))) 
           (if (eq (car termOp) :|Nat|) 
               (return (funcall (svref pp 38) (NAT-SPEC::toString (cdr termOp)))) 
               (if (eq (car termOp) :|String|) 
                   (return 
                    (funcall (svref pp 38) 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ "\"" (cdr termOp)) 
                              "\""))) 
                   (if (eq (car termOp) :|Char|) 
                       (return 
                        (funcall (svref pp 38) 
                                 (STRING-SPEC::^ 
                                  "#" 
                                  (CHAR-SPEC::toString (cdr termOp))))) 
                       (if (eq (car termOp) :|Embed|) 
                           (return (funcall (svref pp 38) (car (cdr termOp)))) 
                           (if (eq (car termOp) :|Project|) 
                               (return 
                                (funcall (svref pp 38) 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ 
                                           "project(" 
                                           (cdr termOp)) 
                                          ")"))) 
                               (if (eq (car termOp) :|Embedded|) 
                                   (return 
                                    (funcall (svref pp 38) 
                                             (STRING-SPEC::^ 
                                              (STRING-SPEC::^ 
                                               "embed?(" 
                                               (cdr termOp)) 
                                              ")"))) 
                                   (if (eq (car termOp) :|Quotient|) 
                                       (return 
                                        (funcall (svref pp 38) "quotient")) 
                                       (if (eq (car termOp) :|Choose|) 
                                           (return 
                                            (funcall (svref pp 38) "choose")) 
                                           (if (eq (car termOp) :|PQuotient|) 
                                               (return 
                                                (funcall (svref pp 38) 
                                                         "quotient")) 
                                               (if (eq (car termOp) :|PChoose|) 
                                                   (return 
                                                    (funcall (svref pp 38) 
                                                             "choose")) 
                                                   (if (eq 
                                                        (car termOp) 
                                                        :|Equals|) 
                                                       (return (svref pp 13)) 
                                                       (if (eq 
                                                            (car termOp) 
                                                            :|OneName|) 
                                                           (return 
                                                            (funcall (svref 
                                                                      pp 
                                                                      38) 
                                                                     (car 
                                                                      (cdr 
                                                                       termOp)))) 
                                                           (if (eq 
                                                                (car termOp) 
                                                                :|TwoNames|) 
                                                               (let ((pV39 
                                                                      (cdr 
                                                                       termOp))) 
                                                                 (let ((pV52 
                                                                        (svref 
                                                                         pV39 
                                                                         1))
                                                                       (pV51 
                                                                        (svref 
                                                                         pV39 
                                                                         0))) 
                                                                   (return 
                                                                    (funcall (svref 
                                                                              pp 
                                                                              38) 
                                                                             (if (string=  
                                                                                  pV51 
                                                                                  METASLANG::UnQualified) 
                                                                                 pV52 
                                                                                 (STRING-SPEC::^ 
                                                                                  (STRING-SPEC::^ 
                                                                                   pV51 
                                                                                   ".") 
                                                                                  pV52)))))) 
                                                               (if (eq 
                                                                    (car termOp) 
                                                                    :|Relax|) 
                                                                   (return 
                                                                    (let ((p 
                                                                           (block 
                                                                            nil 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  srt) 
                                                                                 :|Arrow|) 
                                                                                (let ((pV14 
                                                                                       (svref 
                                                                                        (cdr 
                                                                                         srt) 
                                                                                        0))) 
                                                                                  (if (eq 
                                                                                       (car 
                                                                                        pV14) 
                                                                                       :|Subsort|) 
                                                                                      (return 
                                                                                       (svref 
                                                                                        (cdr 
                                                                                         pV14) 
                                                                                        1))))) 
                                                                            (return 
                                                                             (METASLANG::mkTrueA 
                                                                              a))))) 
                                                                      (PRETTYPRINT::prettysFill 
                                                                       (cons 
                                                                        (funcall (svref 
                                                                                  pp 
                                                                                  38) 
                                                                                 "relax") 
                                                                        (cons 
                                                                         (PRETTYPRINT::|!string| 
                                                                          "(") 
                                                                         (cons 
                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                           context 
                                                                           (cons 
                                                                            nil 
                                                                            '(:|Top|)) 
                                                                           p) 
                                                                          (cons 
                                                                           (PRETTYPRINT::|!string| 
                                                                            ")") 
                                                                           nil))))))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         termOp) 
                                                                        :|Restrict|) 
                                                                       (return 
                                                                        (let ((p 
                                                                               (block 
                                                                                nil 
                                                                                (if (eq 
                                                                                     (car 
                                                                                      srt) 
                                                                                     :|Arrow|) 
                                                                                    (let ((pV29 
                                                                                           (svref 
                                                                                            (cdr 
                                                                                             srt) 
                                                                                            1))) 
                                                                                      (if (eq 
                                                                                           (car 
                                                                                            pV29) 
                                                                                           :|Subsort|) 
                                                                                          (return 
                                                                                           (svref 
                                                                                            (cdr 
                                                                                             pV29) 
                                                                                            1))))) 
                                                                                (return 
                                                                                 (METASLANG::mkTrueA 
                                                                                  a))))) 
                                                                          (PRETTYPRINT::prettysFill 
                                                                           (cons 
                                                                            (funcall (svref 
                                                                                      pp 
                                                                                      38) 
                                                                                     "restrict") 
                                                                            (cons 
                                                                             (PRETTYPRINT::|!string| 
                                                                              "(") 
                                                                             (cons 
                                                                              (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                               context 
                                                                               (cons 
                                                                                nil 
                                                                                '(:|Top|)) 
                                                                               p) 
                                                                              (cons 
                                                                               (PRETTYPRINT::|!string| 
                                                                                ")") 
                                                                               nil))))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             termOp) 
                                                                            :|PRelax|) 
                                                                           (return 
                                                                            (PRETTYPRINT::prettysFill 
                                                                             (cons 
                                                                              (funcall (svref 
                                                                                        pp 
                                                                                        38) 
                                                                                       "relax") 
                                                                              (cons 
                                                                               (PRETTYPRINT::|!string| 
                                                                                "(") 
                                                                               (cons 
                                                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                 context 
                                                                                 (cons 
                                                                                  nil 
                                                                                  '(:|Top|)) 
                                                                                 (cdr 
                                                                                  termOp)) 
                                                                                (cons 
                                                                                 (PRETTYPRINT::|!string| 
                                                                                  ")") 
                                                                                 nil)))))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 termOp) 
                                                                                :|PRestrict|) 
                                                                               (return 
                                                                                (PRETTYPRINT::prettysFill 
                                                                                 (cons 
                                                                                  (funcall (svref 
                                                                                            pp 
                                                                                            38) 
                                                                                           "restrict") 
                                                                                  (cons 
                                                                                   (PRETTYPRINT::|!string| 
                                                                                    "(") 
                                                                                   (cons 
                                                                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                     context 
                                                                                     (cons 
                                                                                      nil 
                                                                                      '(:|Top|)) 
                                                                                     (cdr 
                                                                                      termOp)) 
                                                                                    (cons 
                                                                                     (PRETTYPRINT::|!string| 
                                                                                      ")") 
                                                                                     nil)))))) 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     termOp) 
                                                                                    :|Select|) 
                                                                                   (return 
                                                                                    (funcall (svref 
                                                                                              pp 
                                                                                              38) 
                                                                                             (STRING-SPEC::^ 
                                                                                              (STRING-SPEC::^ 
                                                                                               "select(" 
                                                                                               (cdr 
                                                                                                termOp)) 
                                                                                              ")"))))))))))))))))))))))) 
   (error "Nonexhaustive match failure in printOp")))

(defun ANNSPECPRINTER::printSort?-1 (c) (svref c 5))

(defun ANNSPECPRINTER::termFixity (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV11 (svref (cdr term) 0))) 
         (return 
          (block 
           nil 
           (if (eq (car pV11) :|Op|) 
               (return (cdr (cdr pV11))) 
               (if (eq (car pV11) :|Equals|) (return (cons '(:|Left|) 20)))) 
           (return nil))))) 
   (return nil)))

(defun PRETTYPRINT::addSeparator-1-1 (sep ps) 
  (block 
   nil 
   (if (null ps) 
       (return nil) 
       (if (consp ps) 
           (let ((pV3 (car ps))
                 (pV4 (cdr ps))) 
             (progn (if (null pV4) (return (cons pV3 nil))) 
                    (return 
                     (LIST-SPEC::|!cons| 
                      (PRETTYPRINT::prettysNone (cons pV3 (cons sep nil))) 
                      (PRETTYPRINT::addSeparator-1-1 sep pV4))))))) 
   (error "Nonexhaustive match failure in addSeparator")))

(defun PRETTYPRINT::blockLinear (|!newlines| lines) 
  (let ((width (PRETTYPRINT::widthLines lines))) 
    (PRETTYPRINT::pretty 
     width 
     #'(lambda (x) 
        (let ((text (cdr x))
              (columns (car x))) 
          (if (PRETTYPRINT::fits? columns width text) 
              (PRETTYPRINT::formatPretty 
               columns 
               (PRETTYPRINT::blockNone |!newlines| lines) 
               text) 
              (PRETTYPRINT::formatPretty 
               columns 
               (PRETTYPRINT::blockAll |!newlines| lines) 
               text)))))))

(defun PRETTYPRINT::blockLinear-1 (x) 
  (PRETTYPRINT::blockLinear (car x) (cdr x)))

(defun PRETTYPRINT::prettysLinear (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockLinear-1 ps))

(defun ANNTERMPRINTER::ppListPath-1-1-1-1 (path f x ps) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (svref x 0) 
    (cons 
     (PRETTYPRINT::prettysLinear 
      (PRETTYPRINT::addSeparator-1-1 
       (svref x 1) 
       (LISTUTILITIES::mapWithIndex-1-1 
        #'(lambda (x1) 
           (funcall f (cons (LIST-SPEC::|!cons| (car x1) path) (cdr x1)))) 
        ps))) 
     (cons (svref x 2) nil)))))

(defun PRETTYPRINT::prettys (ps) (PRETTYPRINT::prettysNone ps))

(defun ANNSPECPRINTER::ppTerm1-1-1-1 (context x term) 
  (let ((path (car x))
        (parentTerm (cdr x))) 
    (let ((pp (svref context 4))) 
      (labels 
        ((prApply (t1 t2) 
          (block 
           nil 
           (if (eq (car t1) :|Lambda|) 
               (let ((pV29 (car (cdr t1)))) 
                 (if (consp pV29) 
                     (return 
                      (PRETTYPRINT::blockAll 
                       0 
                       (cons 
                        (cons 
                         0 
                         (PRETTYPRINT::prettysNone 
                          (cons 
                           (svref pp 22) 
                           (cons 
                            (svref pp 4) 
                            (cons 
                             (ANNSPECPRINTER::ppTerm-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 nil) path) 
                               '(:|Top|)) 
                              t2) 
                             nil))))) 
                        (cons 
                         (cons 
                          3 
                          (PRETTYPRINT::prettysNone 
                           (cons 
                            (ANNSPECPRINTER::printLambda 
                             context 
                             (LIST-SPEC::|!++| (cons 0 nil) path) 
                             (svref pp 26) 
                             pV29) 
                            (cons (svref pp 31) nil)))) 
                         nil)))))) 
               (if (eq (car t1) :|Fun|) 
                   (let ((pV18 (cdr t1))) 
                     (let ((pV20 (svref pV18 0))) 
                       (if (eq (car pV20) :|Project|) 
                           (let ((pV23 (cdr pV20))) 
                             (if (eq (car t2) :|Var|) 
                                 (let ((pV25 (car (cdr t2)))) 
                                   (let ((pV27 (car pV25))) 
                                     (return 
                                      (if (ANNSPECPRINTER::printSort?-1 context) 
                                          (PRETTYPRINT::prettysNone 
                                           (cons 
                                            (funcall (svref pp 38) pV27) 
                                            (cons 
                                             (PRETTYPRINT::|!string| ":") 
                                             (cons 
                                              (ANNSPECPRINTER::ppSort-1-1-1 
                                               context 
                                               (cons 
                                                (LIST-SPEC::|!++| 
                                                 (cons 0 (cons 1 nil)) 
                                                 path) 
                                                '(:|Top|)) 
                                               (cdr pV25)) 
                                              (cons 
                                               (PRETTYPRINT::|!string| ".") 
                                               (cons 
                                                (PRETTYPRINT::|!string| pV23) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| ":") 
                                                 (cons 
                                                  (ANNSPECPRINTER::ppSort-1-1-1 
                                                   context 
                                                   (cons 
                                                    (LIST-SPEC::|!++| 
                                                     (cons 0 (cons 0 nil)) 
                                                     path) 
                                                    '(:|Top|)) 
                                                   (svref pV18 1)) 
                                                  nil)))))))) 
                                          (PRETTYPRINT::prettysNone 
                                           (cons 
                                            (funcall (svref pp 38) pV27) 
                                            (cons 
                                             (PRETTYPRINT::|!string| ".") 
                                             (cons 
                                              (funcall (svref pp 38) pV23) 
                                              nil))))))))))))))) 
           (return 
            (PRETTYPRINT::blockFill 
             0 
             (cons 
              (cons 
               0 
               (ANNSPECPRINTER::ppTerm-1-1-1 
                context 
                (cons (LIST-SPEC::|!++| (cons 0 nil) path) '(:|Top|)) 
                t1)) 
              (cons 
               (cons 
                1 
                (PRETTYPRINT::blockNone 
                 0 
                 (block 
                  nil 
                  (if (eq (car t2) :|Record|) 
                      (return 
                       (if (ANNSPECPRINTER::isShortTuple 1 (car (cdr t2))) 
                           (cons 
                            (cons 
                             0 
                             (ANNSPECPRINTER::ppTerm1-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 nil) path) 
                               '(:|Top|)) 
                              t2)) 
                            nil) 
                           (cons 
                            (cons 
                             0 
                             (ANNSPECPRINTER::ppTerm-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 nil) path) 
                               '(:|Top|)) 
                              t2)) 
                            nil))) 
                      (if (eq (car t2) :|Var|) 
                          (return 
                           (cons 
                            (cons 0 (PRETTYPRINT::|!string| " ")) 
                            (cons 
                             (cons 
                              0 
                              (ANNSPECPRINTER::ppTerm-1-1-1 
                               context 
                               (cons 
                                (LIST-SPEC::|!++| (cons 1 nil) path) 
                                '(:|Top|)) 
                               t2)) 
                             nil))))) 
                  (return 
                   (cons 
                    (cons 0 (svref pp 22)) 
                    (cons 
                     (cons 
                      0 
                      (ANNSPECPRINTER::ppTerm-1-1-1 
                       context 
                       (cons (LIST-SPEC::|!++| (cons 1 nil) path) '(:|Top|)) 
                       t2)) 
                     (cons (cons 0 (svref pp 31)) nil))))))) 
               nil))))))) 
        (let ((pV233 (ANNSPECPRINTER::isFiniteList term))) 
          (block 
           nil 
           (if (eq (car pV233) :|Some|) 
               (return 
                (ANNTERMPRINTER::ppListPath-1-1-1-1 
                 path 
                 #'(lambda (x1) 
                    (ANNSPECPRINTER::ppTerm-1-1-1 
                     context 
                     (cons (car x1) '(:|Top|)) 
                     (cdr x1))) 
                 (vector (svref pp 20) (svref pp 5) (svref pp 29)) 
                 (cdr pV233))) 
               (if (eq (car pV233) :|None|) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car term) :|Fun|) 
                         (let ((pV165 (cdr term))) 
                           (let ((pV230 (svref pV165 0))
                                 (pV231 (svref pV165 1))
                                 (pV232 (svref pV165 2))) 
                             (return 
                              (if (ANNSPECPRINTER::printSort?-1 context) 
                                  (PRETTYPRINT::blockFill 
                                   0 
                                   (cons 
                                    (cons 
                                     0 
                                     (ANNSPECPRINTER::printOp 
                                      context 
                                      pp 
                                      pV230 
                                      pV231 
                                      pV232)) 
                                    (cons 
                                     (cons 0 (PRETTYPRINT::|!string| " : ")) 
                                     (cons 
                                      (cons 
                                       0 
                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                        context 
                                        (cons 
                                         (LIST-SPEC::|!++| (cons 0 nil) path) 
                                         '(:|Top|)) 
                                        pV231)) 
                                      nil)))) 
                                  (ANNSPECPRINTER::printOp 
                                   context 
                                   pp 
                                   pV230 
                                   pV231 
                                   pV232))))) 
                         (if (eq (car term) :|Var|) 
                             (let ((pV226 (car (cdr term)))) 
                               (let ((pV228 (car pV226))) 
                                 (return 
                                  (if (ANNSPECPRINTER::printSort?-1 context) 
                                      (PRETTYPRINT::blockFill 
                                       0 
                                       (cons 
                                        (cons 0 (funcall (svref pp 38) pV228)) 
                                        (cons 
                                         (cons 0 (PRETTYPRINT::|!string| " : ")) 
                                         (cons 
                                          (cons 
                                           0 
                                           (ANNSPECPRINTER::ppSort-1-1-1 
                                            context 
                                            (cons 
                                             (LIST-SPEC::|!++| (cons 0 nil) path) 
                                             '(:|Top|)) 
                                            (cdr pV226))) 
                                          nil)))) 
                                      (funcall (svref pp 38) pV228))))) 
                             (if (eq (car term) :|Let|) 
                                 (let ((pV163 (cdr term))) 
                                   (let ((pV223 (svref pV163 0))
                                         (pV224 (svref pV163 1))) 
                                     (return 
                                      (labels 
                                        ((ppD 
                                          (index 
                                           separatorLength 
                                           separator 
                                           pat 
                                           trm) 
                                          (block 
                                           nil 
                                           (if (eq (car pat) :|VarPat|) 
                                               (if (eq (car trm) :|Lambda|) 
                                                   (let ((pV45 (car (cdr trm)))) 
                                                     (if (consp pV45) 
                                                         (let ((pV48 (car pV45))) 
                                                           (let ((pV51 
                                                                  (svref pV48 1))) 
                                                             (if (eq 
                                                                  (car pV51) 
                                                                  :|Fun|) 
                                                                 (let ((pV54 
                                                                        (svref 
                                                                         (cdr 
                                                                          pV51) 
                                                                         0))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV54) 
                                                                        :|Bool|) 
                                                                       (if (eq 
                                                                            t 
                                                                            (cdr 
                                                                             pV54)) 
                                                                           (if (null 
                                                                                (cdr 
                                                                                 pV45)) 
                                                                               (return 
                                                                                (cons 
                                                                                 0 
                                                                                 (PRETTYPRINT::blockLinear 
                                                                                  0 
                                                                                  (cons 
                                                                                   (cons 
                                                                                    0 
                                                                                    (PRETTYPRINT::prettysNone 
                                                                                     (cons 
                                                                                      separator 
                                                                                      (cons 
                                                                                       (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                        context 
                                                                                        (cons 
                                                                                         (LIST-SPEC::|!++| 
                                                                                          (cons 
                                                                                           0 
                                                                                           (cons 
                                                                                            index 
                                                                                            nil)) 
                                                                                          path) 
                                                                                         nil) 
                                                                                        pat) 
                                                                                       (cons 
                                                                                        (PRETTYPRINT::|!string| 
                                                                                         " ") 
                                                                                        (cons 
                                                                                         (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                          context 
                                                                                          (cons 
                                                                                           (LIST-SPEC::|!++| 
                                                                                            (cons 
                                                                                             0 
                                                                                             (cons 
                                                                                              1 
                                                                                              (cons 
                                                                                               index 
                                                                                               nil))) 
                                                                                            path) 
                                                                                           nil) 
                                                                                          (svref 
                                                                                           pV48 
                                                                                           0)) 
                                                                                         (cons 
                                                                                          (PRETTYPRINT::|!string| 
                                                                                           " ") 
                                                                                          (cons 
                                                                                           (svref 
                                                                                            pp 
                                                                                            13) 
                                                                                           (cons 
                                                                                            (PRETTYPRINT::|!string| 
                                                                                             " ") 
                                                                                            nil))))))))) 
                                                                                   (cons 
                                                                                    (cons 
                                                                                     separatorLength 
                                                                                     (PRETTYPRINT::prettysNone 
                                                                                      (cons 
                                                                                       (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                        context 
                                                                                        (cons 
                                                                                         (LIST-SPEC::|!++| 
                                                                                          (cons 
                                                                                           2 
                                                                                           (cons 
                                                                                            1 
                                                                                            (cons 
                                                                                             index 
                                                                                             nil))) 
                                                                                          path) 
                                                                                         '(:|Top|)) 
                                                                                        (svref 
                                                                                         pV48 
                                                                                         2)) 
                                                                                       (cons 
                                                                                        (PRETTYPRINT::|!string| 
                                                                                         " ") 
                                                                                        nil)))) 
                                                                                    nil)))))))))))))))) 
                                           (return 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::blockLinear 
                                              0 
                                              (cons 
                                               (cons 
                                                0 
                                                (PRETTYPRINT::prettysNone 
                                                 (cons 
                                                  separator 
                                                  (cons 
                                                   (ANNSPECPRINTER::ppPattern-1-1-1 
                                                    context 
                                                    (cons 
                                                     (LIST-SPEC::|!++| 
                                                      (cons 0 (cons index nil)) 
                                                      path) 
                                                     t) 
                                                    pat) 
                                                   (cons 
                                                    (PRETTYPRINT::|!string| " ") 
                                                    (cons 
                                                     (svref pp 13) 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       " ") 
                                                      nil))))))) 
                                               (cons 
                                                (cons 
                                                 separatorLength 
                                                 (PRETTYPRINT::prettysNone 
                                                  (cons 
                                                   (ANNSPECPRINTER::ppTerm-1-1-1 
                                                    context 
                                                    (cons 
                                                     (LIST-SPEC::|!++| 
                                                      (cons 1 (cons index nil)) 
                                                      path) 
                                                     '(:|Top|)) 
                                                    trm) 
                                                   (cons 
                                                    (PRETTYPRINT::|!string| " ") 
                                                    nil)))) 
                                                nil)))))))) 
                                        (labels 
                                          ((ppDs (index l separator decls) 
                                            (block 
                                             nil 
                                             (if (null decls) 
                                                 (return nil) 
                                                 (if (consp decls) 
                                                     (let ((pV60 (car decls))) 
                                                       (return 
                                                        (LIST-SPEC::|!cons| 
                                                         (ppD 
                                                          index 
                                                          l 
                                                          separator 
                                                          (car pV60) 
                                                          (cdr pV60)) 
                                                         (ppDs 
                                                          (INTEGER-SPEC::|!+| 
                                                           index 
                                                           1) 
                                                          5 
                                                          (svref pp 0) 
                                                          (cdr decls))))))) 
                                             (error 
                                              "Nonexhaustive match failure in ppTerm1")))) 
                                          (PRETTYPRINT::blockAll 
                                           0 
                                           (cons 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::blockFill 
                                              0 
                                              (cons 
                                               (cons 
                                                0 
                                                (PRETTYPRINT::blockLinear 
                                                 0 
                                                 (ppDs 0 4 (svref pp 24) pV223))) 
                                               (cons (cons 0 (svref pp 18)) nil)))) 
                                            (cons 
                                             (cons 
                                              0 
                                              (ANNSPECPRINTER::ppTerm-1-1-1 
                                               context 
                                               (cons 
                                                (LIST-SPEC::|!++| 
                                                 (cons 
                                                  (LIST-SPEC::|!length| pV223) 
                                                  nil) 
                                                 path) 
                                                parentTerm) 
                                               pV224)) 
                                             nil)))))))) 
                                 (if (eq (car term) :|LetRec|) 
                                     (let ((pV162 (cdr term))) 
                                       (let ((pV220 (svref pV162 0))
                                             (pV221 (svref pV162 1))) 
                                         (return 
                                          (labels 
                                            ((ppD (pV85 pV86) 
                                              (block 
                                               nil 
                                               (let ((pV88 (cdr pV86))) 
                                                 (let ((pV89 (car (car pV86)))) 
                                                   (return 
                                                    (block 
                                                     nil 
                                                     (if (eq 
                                                          (car pV88) 
                                                          :|Lambda|) 
                                                         (let ((pV72 
                                                                (car (cdr pV88)))) 
                                                           (if (consp pV72) 
                                                               (let ((pV75 
                                                                      (car pV72))) 
                                                                 (let ((pV78 
                                                                        (svref 
                                                                         pV75 
                                                                         1))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV78) 
                                                                        :|Fun|) 
                                                                       (let ((pV81 
                                                                              (svref 
                                                                               (cdr 
                                                                                pV78) 
                                                                               0))) 
                                                                         (if (eq 
                                                                              (car 
                                                                               pV81) 
                                                                              :|Bool|) 
                                                                             (if (eq 
                                                                                  t 
                                                                                  (cdr 
                                                                                   pV81)) 
                                                                                 (if (null 
                                                                                      (cdr 
                                                                                       pV72)) 
                                                                                     (return 
                                                                                      (PRETTYPRINT::blockLinear 
                                                                                       0 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         0 
                                                                                         (PRETTYPRINT::prettysNone 
                                                                                          (cons 
                                                                                           (svref 
                                                                                            pp 
                                                                                            7) 
                                                                                           (cons 
                                                                                            (funcall (svref 
                                                                                                      pp 
                                                                                                      38) 
                                                                                                     pV89) 
                                                                                            (cons 
                                                                                             (PRETTYPRINT::|!string| 
                                                                                              " ") 
                                                                                             (cons 
                                                                                              (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                               context 
                                                                                               (cons 
                                                                                                (LIST-SPEC::|!++| 
                                                                                                 (cons 
                                                                                                  1 
                                                                                                  (cons 
                                                                                                   0 
                                                                                                   nil)) 
                                                                                                 pV85) 
                                                                                                nil) 
                                                                                               (svref 
                                                                                                pV75 
                                                                                                0)) 
                                                                                              (cons 
                                                                                               (svref 
                                                                                                pp 
                                                                                                13) 
                                                                                               nil))))))) 
                                                                                        (cons 
                                                                                         (cons 
                                                                                          4 
                                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                           context 
                                                                                           (cons 
                                                                                            (LIST-SPEC::|!++| 
                                                                                             (cons 
                                                                                              2 
                                                                                              (cons 
                                                                                               0 
                                                                                               nil)) 
                                                                                             pV85) 
                                                                                            '(:|Top|)) 
                                                                                           (svref 
                                                                                            pV75 
                                                                                            2))) 
                                                                                         nil)))))))))))))) 
                                                     (return 
                                                      (PRETTYPRINT::blockLinear 
                                                       0 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (PRETTYPRINT::prettysNone 
                                                          (cons 
                                                           (svref pp 7) 
                                                           (cons 
                                                            (funcall (svref 
                                                                      pp 
                                                                      38) 
                                                                     pV89) 
                                                            (cons 
                                                             (svref pp 13) 
                                                             nil))))) 
                                                        (cons 
                                                         (cons 
                                                          4 
                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                           context 
                                                           (cons pV85 '(:|Top|)) 
                                                           pV88)) 
                                                         nil)))))))) 
                                               (error 
                                                "Nonexhaustive match failure in ppTerm1")))) 
                                            (PRETTYPRINT::blockAll 
                                             0 
                                             (cons 
                                              (cons 
                                               0 
                                               (PRETTYPRINT::blockNone 
                                                0 
                                                (cons 
                                                 (cons 0 (svref pp 24)) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                    path 
                                                    #'(lambda (x1) 
                                                       (ppD (car x1) (cdr x1))) 
                                                    (vector 
                                                     (svref pp 10) 
                                                     (svref pp 10) 
                                                     (svref pp 18)) 
                                                    pV220)) 
                                                  nil)))) 
                                              (cons 
                                               (cons 
                                                0 
                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                 context 
                                                 (cons 
                                                  (LIST-SPEC::|!++| 
                                                   (cons 
                                                    (LIST-SPEC::|!length| pV220) 
                                                    nil) 
                                                   path) 
                                                  parentTerm) 
                                                 pV221)) 
                                               nil))))))) 
                                     (if (eq (car term) :|Record|) 
                                         (let ((pV218 (car (cdr term)))) 
                                           (return 
                                            (if (ANNSPECPRINTER::isShortTuple 
                                                 1 
                                                 pV218) 
                                                (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                 path 
                                                 #'(lambda (x1) 
                                                    (block 
                                                     nil 
                                                     (return 
                                                      (ANNSPECPRINTER::ppTerm-1-1-1 
                                                       context 
                                                       (cons (car x1) '(:|Top|)) 
                                                       (cdr (cdr x1)))) 
                                                     (error 
                                                      "Nonexhaustive match failure in ppTerm1"))) 
                                                 (vector 
                                                  (svref pp 22) 
                                                  (svref pp 5) 
                                                  (svref pp 31)) 
                                                 pV218) 
                                                (labels 
                                                  ((ppEntry (pV97 pV98) 
                                                    (block 
                                                     nil 
                                                     (return 
                                                      (PRETTYPRINT::blockLinear 
                                                       0 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (funcall (svref pp 38) 
                                                                  (car pV98))) 
                                                        (cons 
                                                         (cons 
                                                          0 
                                                          (PRETTYPRINT::|!string| 
                                                           " = ")) 
                                                         (cons 
                                                          (cons 
                                                           0 
                                                           (ANNSPECPRINTER::ppTerm-1-1-1 
                                                            context 
                                                            (cons pV97 '(:|Top|)) 
                                                            (cdr pV98))) 
                                                          nil))))) 
                                                     (error 
                                                      "Nonexhaustive match failure in ppTerm1")))) 
                                                  (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                   path 
                                                   #'(lambda (x1) 
                                                      (ppEntry (car x1) (cdr x1))) 
                                                   (vector 
                                                    (svref pp 21) 
                                                    (PRETTYPRINT::|!string| ", ") 
                                                    (svref pp 30)) 
                                                   pV218))))) 
                                         (if (eq (car term) :|IfThenElse|) 
                                             (let ((pV160 (cdr term))) 
                                               (return 
                                                (PRETTYPRINT::blockLinear 
                                                 0 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (PRETTYPRINT::prettys 
                                                    (cons 
                                                     (svref pp 16) 
                                                     (cons 
                                                      (ANNSPECPRINTER::ppTerm-1-1-1 
                                                       context 
                                                       (cons 
                                                        (LIST-SPEC::|!++| 
                                                         (cons 0 nil) 
                                                         path) 
                                                        '(:|Top|)) 
                                                       (svref pV160 0)) 
                                                      nil)))) 
                                                  (cons 
                                                   (cons 
                                                    3 
                                                    (PRETTYPRINT::blockLinear 
                                                     0 
                                                     (cons 
                                                      (cons 0 (svref pp 34)) 
                                                      (cons 
                                                       (cons 
                                                        0 
                                                        (ANNSPECPRINTER::ppTerm-1-1-1 
                                                         context 
                                                         (cons 
                                                          (LIST-SPEC::|!++| 
                                                           (cons 1 nil) 
                                                           path) 
                                                          '(:|Top|)) 
                                                         (svref pV160 1))) 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (PRETTYPRINT::|!string| 
                                                          " ")) 
                                                        nil))))) 
                                                   (cons 
                                                    (cons 
                                                     0 
                                                     (PRETTYPRINT::blockFill 
                                                      0 
                                                      (cons 
                                                       (cons 0 (svref pp 9)) 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (ANNSPECPRINTER::ppTerm-1-1-1 
                                                          context 
                                                          (cons 
                                                           (LIST-SPEC::|!++| 
                                                            (cons 2 nil) 
                                                            path) 
                                                           '(:|Top|)) 
                                                          (svref pV160 2))) 
                                                        nil)))) 
                                                    nil)))))) 
                                             (if (eq (car term) :|Lambda|) 
                                                 (return 
                                                  (PRETTYPRINT::prettysNone 
                                                   (cons 
                                                    (svref pp 22) 
                                                    (cons 
                                                     (ANNSPECPRINTER::printLambda 
                                                      context 
                                                      path 
                                                      (svref pp 23) 
                                                      (car (cdr term))) 
                                                     (cons (svref pp 31) nil))))) 
                                                 (if (eq (car term) :|Bind|) 
                                                     (let ((pV158 (cdr term))) 
                                                       (let ((pV208 
                                                              (svref pV158 0))
                                                             (pV209 
                                                              (svref pV158 1))
                                                             (pV210 
                                                              (svref pV158 2))) 
                                                         (return 
                                                          (let ((b 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV208) 
                                                                       :|Forall|) 
                                                                      (return 
                                                                       (svref 
                                                                        pp 
                                                                        15)) 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV208) 
                                                                           :|Exists|) 
                                                                          (return 
                                                                           (svref 
                                                                            pp 
                                                                            14)))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in ppTerm1")))) 
                                                            (labels 
                                                              ((ppBound 
                                                                (pV105 pV106) 
                                                                (block 
                                                                 nil 
                                                                 (return 
                                                                  (PRETTYPRINT::prettys 
                                                                   (cons 
                                                                    (funcall (svref 
                                                                              pp 
                                                                              38) 
                                                                             (car 
                                                                              pV106)) 
                                                                    (cons 
                                                                     (PRETTYPRINT::|!string| 
                                                                      " : ") 
                                                                     (cons 
                                                                      (ANNSPECPRINTER::ppSort-1-1-1 
                                                                       context 
                                                                       (cons 
                                                                        (LIST-SPEC::|!++| 
                                                                         (cons 
                                                                          pV105 
                                                                          nil) 
                                                                         path) 
                                                                        '(:|Top|)) 
                                                                       (cdr 
                                                                        pV106)) 
                                                                      nil))))) 
                                                                 (error 
                                                                  "Nonexhaustive match failure in ppTerm1")))) 
                                                              (PRETTYPRINT::blockFill 
                                                               0 
                                                               (cons 
                                                                (cons 
                                                                 0 
                                                                 (PRETTYPRINT::prettysNone 
                                                                  (cons 
                                                                   b 
                                                                   (cons 
                                                                    (svref pp 22) 
                                                                    (cons 
                                                                     (PRETTYPRINT::prettysFill 
                                                                      (PRETTYPRINT::addSeparator-1-1 
                                                                       (PRETTYPRINT::|!string| 
                                                                        ", ") 
                                                                       (LISTUTILITIES::mapWithIndex-1-1 
                                                                        #'(lambda (x1) 
                                                                           (ppBound 
                                                                            (car 
                                                                             x1) 
                                                                            (cdr 
                                                                             x1))) 
                                                                        pV209))) 
                                                                     (cons 
                                                                      (svref 
                                                                       pp 
                                                                       31) 
                                                                      (cons 
                                                                       (PRETTYPRINT::|!string| 
                                                                        " ") 
                                                                       nil))))))) 
                                                                (cons 
                                                                 (cons 
                                                                  1 
                                                                  (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                   context 
                                                                   (cons 
                                                                    (LIST-SPEC::|!++| 
                                                                     (cons 
                                                                      (LIST-SPEC::|!length| 
                                                                       pV209) 
                                                                      nil) 
                                                                     path) 
                                                                    parentTerm) 
                                                                   pV210)) 
                                                                 nil)))))))) 
                                                     (if (eq (car term) :|Seq|) 
                                                         (return 
                                                          (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                           path 
                                                           #'(lambda (x1) 
                                                              (ANNSPECPRINTER::ppTerm-1-1-1 
                                                               context 
                                                               (cons 
                                                                (car x1) 
                                                                '(:|Top|)) 
                                                               (cdr x1))) 
                                                           (vector 
                                                            (svref pp 22) 
                                                            (PRETTYPRINT::|!string| 
                                                             ";") 
                                                            (svref pp 31)) 
                                                           (car (cdr term)))) 
                                                         (if (eq 
                                                              (car term) 
                                                              :|Apply|) 
                                                             (let ((pV156 
                                                                    (cdr term))) 
                                                               (let ((pV190 
                                                                      (svref 
                                                                       pV156 
                                                                       0))
                                                                     (pV191 
                                                                      (svref 
                                                                       pV156 
                                                                       1))) 
                                                                 (progn (if (eq 
                                                                             (car 
                                                                              pV191) 
                                                                             :|Record|) 
                                                                            (let ((pV194 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV191)))) 
                                                                              (if (consp 
                                                                                   pV194) 
                                                                                  (let ((pV198 
                                                                                         (cdr 
                                                                                          pV194))) 
                                                                                    (let ((pV200 
                                                                                           (cdr 
                                                                                            (car 
                                                                                             pV194)))) 
                                                                                      (if (consp 
                                                                                           pV198) 
                                                                                          (let ((pV205 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV198)))) 
                                                                                            (if (null 
                                                                                                 (cdr 
                                                                                                  pV198)) 
                                                                                                (return 
                                                                                                 (labels 
                                                                                                   ((prInfix 
                                                                                                     (f1 
                                                                                                      f2 
                                                                                                      l 
                                                                                                      t1 
                                                                                                      oper 
                                                                                                      t2 
                                                                                                      r) 
                                                                                                     (PRETTYPRINT::prettysFill 
                                                                                                      (cons 
                                                                                                       l 
                                                                                                       (cons 
                                                                                                        (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                         context 
                                                                                                         (cons 
                                                                                                          (LIST-SPEC::|!++| 
                                                                                                           (cons 
                                                                                                            0 
                                                                                                            (cons 
                                                                                                             1 
                                                                                                             nil)) 
                                                                                                           path) 
                                                                                                          f1) 
                                                                                                         t1) 
                                                                                                        (cons 
                                                                                                         (PRETTYPRINT::|!string| 
                                                                                                          " ") 
                                                                                                         (cons 
                                                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                           context 
                                                                                                           (cons 
                                                                                                            (LIST-SPEC::|!++| 
                                                                                                             (cons 
                                                                                                              0 
                                                                                                              nil) 
                                                                                                             path) 
                                                                                                            '(:|Top|)) 
                                                                                                           oper) 
                                                                                                          (cons 
                                                                                                           (PRETTYPRINT::|!string| 
                                                                                                            " ") 
                                                                                                           (cons 
                                                                                                            (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                             context 
                                                                                                             (cons 
                                                                                                              (LIST-SPEC::|!++| 
                                                                                                               (cons 
                                                                                                                1 
                                                                                                                (cons 
                                                                                                                 1 
                                                                                                                 nil)) 
                                                                                                               path) 
                                                                                                              f2) 
                                                                                                             t2) 
                                                                                                            (cons 
                                                                                                             r 
                                                                                                             nil)))))))))) 
                                                                                                   (let ((pV116 
                                                                                                          (ANNSPECPRINTER::termFixity 
                                                                                                           pV190))) 
                                                                                                     (block 
                                                                                                      nil 
                                                                                                      (if (null 
                                                                                                           pV116) 
                                                                                                          (return 
                                                                                                           (prApply 
                                                                                                            pV190 
                                                                                                            pV191))) 
                                                                                                      (if (eq 
                                                                                                           (car 
                                                                                                            parentTerm) 
                                                                                                           :|Nonfix|) 
                                                                                                          (if (consp 
                                                                                                               pV116) 
                                                                                                              (return 
                                                                                                               (prInfix 
                                                                                                                '(:|Nonfix|) 
                                                                                                                '(:|Nonfix|) 
                                                                                                                (svref 
                                                                                                                 pp 
                                                                                                                 22) 
                                                                                                                pV200 
                                                                                                                pV190 
                                                                                                                pV205 
                                                                                                                (svref 
                                                                                                                 pp 
                                                                                                                 31)))) 
                                                                                                          (if (eq 
                                                                                                               (car 
                                                                                                                parentTerm) 
                                                                                                               :|Top|) 
                                                                                                              (if (consp 
                                                                                                                   pV116) 
                                                                                                                  (return 
                                                                                                                   (prInfix 
                                                                                                                    '(:|Nonfix|) 
                                                                                                                    '(:|Nonfix|) 
                                                                                                                    (svref 
                                                                                                                     pp 
                                                                                                                     10) 
                                                                                                                    pV200 
                                                                                                                    pV190 
                                                                                                                    pV205 
                                                                                                                    (svref 
                                                                                                                     pp 
                                                                                                                     10)))) 
                                                                                                              (if (eq 
                                                                                                                   (car 
                                                                                                                    parentTerm) 
                                                                                                                   :|Infix|) 
                                                                                                                  (if (consp 
                                                                                                                       pV116) 
                                                                                                                      (return 
                                                                                                                       (prInfix 
                                                                                                                        '(:|Nonfix|) 
                                                                                                                        '(:|Nonfix|) 
                                                                                                                        (svref 
                                                                                                                         pp 
                                                                                                                         22) 
                                                                                                                        pV200 
                                                                                                                        pV190 
                                                                                                                        pV205 
                                                                                                                        (svref 
                                                                                                                         pp 
                                                                                                                         31))))))) 
                                                                                                      (error 
                                                                                                       "Nonexhaustive match failure in ppTerm1"))))))))))))) 
                                                                        (return 
                                                                         (prApply 
                                                                          pV190 
                                                                          pV191))))) 
                                                             (if (eq 
                                                                  (car term) 
                                                                  :|ApplyN|) 
                                                                 (let ((pV155 
                                                                        (cdr 
                                                                         term))) 
                                                                   (let ((pV169 
                                                                          (car 
                                                                           pV155))
                                                                         (pV170 
                                                                          (cdr 
                                                                           pV155))) 
                                                                     (if (consp 
                                                                          pV169) 
                                                                         (let ((pV172 
                                                                                (car 
                                                                                 pV169))
                                                                               (pV173 
                                                                                (cdr 
                                                                                 pV169))) 
                                                                           (if (null 
                                                                                pV173) 
                                                                               (return 
                                                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                 context 
                                                                                 (cons 
                                                                                  path 
                                                                                  parentTerm) 
                                                                                 pV172)) 
                                                                               (if (consp 
                                                                                    pV173) 
                                                                                   (let ((pV175 
                                                                                          (car 
                                                                                           pV173))
                                                                                         (pV176 
                                                                                          (cdr 
                                                                                           pV173))) 
                                                                                     (progn (if (eq 
                                                                                                 (car 
                                                                                                  pV175) 
                                                                                                 :|Record|) 
                                                                                                (let ((pV178 
                                                                                                       (car 
                                                                                                        (cdr 
                                                                                                         pV175)))) 
                                                                                                  (if (consp 
                                                                                                       pV178) 
                                                                                                      (let ((pV182 
                                                                                                             (cdr 
                                                                                                              pV178))) 
                                                                                                        (let ((pV184 
                                                                                                               (cdr 
                                                                                                                (car 
                                                                                                                 pV178)))) 
                                                                                                          (if (consp 
                                                                                                               pV182) 
                                                                                                              (let ((pV189 
                                                                                                                     (cdr 
                                                                                                                      (car 
                                                                                                                       pV182)))) 
                                                                                                                (if (null 
                                                                                                                     (cdr 
                                                                                                                      pV182)) 
                                                                                                                    (if (null 
                                                                                                                         pV176) 
                                                                                                                        (return 
                                                                                                                         (labels 
                                                                                                                           ((prInfix 
                                                                                                                             (f1 
                                                                                                                              f2 
                                                                                                                              l 
                                                                                                                              t1 
                                                                                                                              oper 
                                                                                                                              t2 
                                                                                                                              r) 
                                                                                                                             (PRETTYPRINT::prettysFill 
                                                                                                                              (cons 
                                                                                                                               l 
                                                                                                                               (cons 
                                                                                                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                                                 context 
                                                                                                                                 (cons 
                                                                                                                                  (LIST-SPEC::|!++| 
                                                                                                                                   (cons 
                                                                                                                                    0 
                                                                                                                                    (cons 
                                                                                                                                     1 
                                                                                                                                     nil)) 
                                                                                                                                   path) 
                                                                                                                                  f1) 
                                                                                                                                 t1) 
                                                                                                                                (cons 
                                                                                                                                 (PRETTYPRINT::|!string| 
                                                                                                                                  " ") 
                                                                                                                                 (cons 
                                                                                                                                  (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                                                   context 
                                                                                                                                   (cons 
                                                                                                                                    (LIST-SPEC::|!++| 
                                                                                                                                     (cons 
                                                                                                                                      0 
                                                                                                                                      nil) 
                                                                                                                                     path) 
                                                                                                                                    '(:|Top|)) 
                                                                                                                                   oper) 
                                                                                                                                  (cons 
                                                                                                                                   (PRETTYPRINT::|!string| 
                                                                                                                                    " ") 
                                                                                                                                   (cons 
                                                                                                                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                                                     context 
                                                                                                                                     (cons 
                                                                                                                                      (LIST-SPEC::|!++| 
                                                                                                                                       (cons 
                                                                                                                                        1 
                                                                                                                                        (cons 
                                                                                                                                         1 
                                                                                                                                         nil)) 
                                                                                                                                       path) 
                                                                                                                                      f2) 
                                                                                                                                     t2) 
                                                                                                                                    (cons 
                                                                                                                                     r 
                                                                                                                                     nil)))))))))) 
                                                                                                                           (let ((pV137 
                                                                                                                                  (ANNSPECPRINTER::termFixity 
                                                                                                                                   pV172))) 
                                                                                                                             (block 
                                                                                                                              nil 
                                                                                                                              (if (null 
                                                                                                                                   pV137) 
                                                                                                                                  (return 
                                                                                                                                   (prApply 
                                                                                                                                    pV172 
                                                                                                                                    pV175))) 
                                                                                                                              (if (eq 
                                                                                                                                   (car 
                                                                                                                                    parentTerm) 
                                                                                                                                   :|Nonfix|) 
                                                                                                                                  (if (consp 
                                                                                                                                       pV137) 
                                                                                                                                      (return 
                                                                                                                                       (prInfix 
                                                                                                                                        '(:|Nonfix|) 
                                                                                                                                        '(:|Nonfix|) 
                                                                                                                                        (svref 
                                                                                                                                         pp 
                                                                                                                                         22) 
                                                                                                                                        pV184 
                                                                                                                                        pV172 
                                                                                                                                        pV189 
                                                                                                                                        (svref 
                                                                                                                                         pp 
                                                                                                                                         31)))) 
                                                                                                                                  (if (eq 
                                                                                                                                       (car 
                                                                                                                                        parentTerm) 
                                                                                                                                       :|Top|) 
                                                                                                                                      (if (consp 
                                                                                                                                           pV137) 
                                                                                                                                          (return 
                                                                                                                                           (prInfix 
                                                                                                                                            '(:|Nonfix|) 
                                                                                                                                            '(:|Nonfix|) 
                                                                                                                                            (svref 
                                                                                                                                             pp 
                                                                                                                                             10) 
                                                                                                                                            pV184 
                                                                                                                                            pV172 
                                                                                                                                            pV189 
                                                                                                                                            (svref 
                                                                                                                                             pp 
                                                                                                                                             10)))) 
                                                                                                                                      (if (eq 
                                                                                                                                           (car 
                                                                                                                                            parentTerm) 
                                                                                                                                           :|Infix|) 
                                                                                                                                          (if (consp 
                                                                                                                                               pV137) 
                                                                                                                                              (return 
                                                                                                                                               (prInfix 
                                                                                                                                                '(:|Nonfix|) 
                                                                                                                                                '(:|Nonfix|) 
                                                                                                                                                (svref 
                                                                                                                                                 pp 
                                                                                                                                                 22) 
                                                                                                                                                pV184 
                                                                                                                                                pV172 
                                                                                                                                                pV189 
                                                                                                                                                (svref 
                                                                                                                                                 pp 
                                                                                                                                                 31))))))) 
                                                                                                                              (error 
                                                                                                                               "Nonexhaustive match failure in ppTerm1")))))))))))))) 
                                                                                            (if (null 
                                                                                                 pV176) 
                                                                                                (return 
                                                                                                 (prApply 
                                                                                                  pV172 
                                                                                                  pV175))) 
                                                                                            (return 
                                                                                             (prApply 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 pV172 
                                                                                                 (cons 
                                                                                                  pV175 
                                                                                                  nil)) 
                                                                                                pV170)) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                pV176 
                                                                                                pV170)))))))))))) 
                                                                 (if (eq 
                                                                      (car term) 
                                                                      :|SortedTerm|) 
                                                                     (let ((pV154 
                                                                            (cdr 
                                                                             term))) 
                                                                       (return 
                                                                        (PRETTYPRINT::prettysNone 
                                                                         (cons 
                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                           context 
                                                                           (cons 
                                                                            (LIST-SPEC::|!++| 
                                                                             (cons 
                                                                              0 
                                                                              nil) 
                                                                             path) 
                                                                            '(:|Top|)) 
                                                                           (svref 
                                                                            pV154 
                                                                            0)) 
                                                                          (cons 
                                                                           (PRETTYPRINT::|!string| 
                                                                            ":") 
                                                                           (cons 
                                                                            (PRETTYPRINT::|!string| 
                                                                             " ") 
                                                                            (cons 
                                                                             (ANNSPECPRINTER::ppSort-1-1-1 
                                                                              context 
                                                                              (cons 
                                                                               (LIST-SPEC::|!++| 
                                                                                (cons 
                                                                                 1 
                                                                                 nil) 
                                                                                path) 
                                                                               '(:|Top|)) 
                                                                              (svref 
                                                                               pV154 
                                                                               1)) 
                                                                             nil))))))))))))))))))) 
                     (return (SYSTEM-SPEC::fail "Uncovered case for term")))))) 
           (error "Nonexhaustive match failure in ppTerm1")))))))

(defun NATMAP::insert (x1 x0 x) (SPLAYMAP::insert x1 x0 x))

(defun PRETTYPRINT::markPretty (uniqueId p) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::lengthString 0 "%(") 
    (cons 
     (PRETTYPRINT::lengthString 0 (NAT-SPEC::toString uniqueId)) 
     (cons p (cons (PRETTYPRINT::lengthString 0 "%)") nil))))))

(defun ANNSPECPRINTER::ppTerm-1-1-1 (context x term) 
  (let ((path (car x))) 
    (let ((pretty 
           (ANNSPECPRINTER::ppTerm1-1-1-1 context (cons path (cdr x)) term))) 
      (if (ANNSPECPRINTER::markSubterm?-1 context) 
          (let ((num (STATE::|!!| (svref context 1)))) 
            (let ((table (STATE::|!!| (svref context 3)))) 
              (progn (STATE::|:=| 
                      (svref context 3) 
                      (NATMAP::insert table num path)) 
                     (STATE::|:=| (svref context 1) (INTEGER-SPEC::|!+| num 1)) 
                     (PRETTYPRINT::markPretty num pretty)))) 
          pretty))))

(defun ANNSPECPRINTER::singletonPattern (pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (return nil) 
       (if (eq (car pat) :|RelaxPat|) 
           (return nil) 
           (if (eq (car pat) :|QuotientPat|) (return nil)))) 
   (return t)))

(defun ANNSPECPRINTER::|!enclose| (enclosed pretty) 
  (if enclosed 
      pretty 
      (PRETTYPRINT::prettysFill 
       (cons 
        (PRETTYPRINT::|!string| "(") 
        (cons pretty (cons (PRETTYPRINT::|!string| ")") nil))))))

(defun METASLANG::patternSort (pat) 
  (block 
   nil 
   (if (eq (car pat) :|WildPat|) 
       (return (car (cdr pat))) 
       (if (eq (car pat) :|AliasPat|) 
           (return (METASLANG::patternSort (svref (cdr pat) 0))) 
           (if (eq (car pat) :|VarPat|) 
               (return (cdr (car (cdr pat)))) 
               (if (eq (car pat) :|EmbedPat|) 
                   (return (svref (cdr pat) 2)) 
                   (if (eq (car pat) :|RecordPat|) 
                       (let ((pV22 (cdr pat))) 
                         (return 
                          (cons 
                           :|Product| 
                           (cons 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons (car x) (METASLANG::patternSort (cdr x)))) 
                             (car pV22)) 
                            (cdr pV22))))) 
                       (if (eq (car pat) :|StringPat|) 
                           (return 
                            (METASLANG::mkABase 
                             (cons :|Qualified| (cons "String" "String")) 
                             nil 
                             (cdr (cdr pat)))) 
                           (if (eq (car pat) :|NatPat|) 
                               (return 
                                (METASLANG::mkABase 
                                 (cons :|Qualified| (cons "Nat" "Nat")) 
                                 nil 
                                 (cdr (cdr pat)))) 
                               (if (eq (car pat) :|BoolPat|) 
                                   (return 
                                    (METASLANG::mkABase 
                                     (cons 
                                      :|Qualified| 
                                      (cons "Boolean" "Boolean")) 
                                     nil 
                                     (cdr (cdr pat)))) 
                                   (if (eq (car pat) :|CharPat|) 
                                       (return 
                                        (METASLANG::mkABase 
                                         (cons :|Qualified| (cons "Char" "Char")) 
                                         nil 
                                         (cdr (cdr pat)))) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (let ((pV17 (cdr pat))) 
                                             (return 
                                              (cons 
                                               :|Subsort| 
                                               (vector 
                                                (METASLANG::patternSort 
                                                 (svref pV17 0)) 
                                                (svref pV17 1) 
                                                (svref pV17 2))))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (let ((pV16 (cdr pat))) 
                                                 (return 
                                                  (cons 
                                                   :|Quotient| 
                                                   (vector 
                                                    (METASLANG::patternSort 
                                                     (svref pV16 0)) 
                                                    (svref pV16 1) 
                                                    (svref pV16 2))))) 
                                               (if (eq (car pat) :|SortedPat|) 
                                                   (return (svref (cdr pat) 1)))))))))))))) 
   (error "Nonexhaustive match failure in patternSort")))

(defun ANNSPECPRINTER::ppPattern-1-1-1 (context x pattern) 
  (let ((path (car x))
        (enclosed (cdr x))) 
    (let ((pp (svref context 4))) 
      (block 
       nil 
       (if (eq (car pattern) :|WildPat|) 
           (return (svref pp 36)) 
           (if (eq (car pattern) :|BoolPat|) 
               (return 
                (PRETTYPRINT::|!string| 
                 (BOOLEAN-SPEC::toString (car (cdr pattern))))) 
               (if (eq (car pattern) :|NatPat|) 
                   (return 
                    (PRETTYPRINT::|!string| 
                     (NAT-SPEC::toString (car (cdr pattern))))) 
                   (if (eq (car pattern) :|StringPat|) 
                       (return 
                        (funcall (svref pp 38) 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ "\"" (car (cdr pattern))) 
                                  "\""))) 
                       (if (eq (car pattern) :|CharPat|) 
                           (return 
                            (funcall (svref pp 38) 
                                     (STRING-SPEC::^ 
                                      "#" 
                                      (CHAR-SPEC::toString (car (cdr pattern)))))) 
                           (if (eq (car pattern) :|VarPat|) 
                               (let ((pV104 (car (cdr pattern)))) 
                                 (let ((pV106 (car pV104))) 
                                   (return 
                                    (if (ANNSPECPRINTER::printSort?-1 context) 
                                        (PRETTYPRINT::blockFill 
                                         0 
                                         (cons 
                                          (cons 0 (funcall (svref pp 38) pV106)) 
                                          (cons 
                                           (cons 
                                            0 
                                            (PRETTYPRINT::|!string| " : ")) 
                                           (cons 
                                            (cons 
                                             0 
                                             (ANNSPECPRINTER::ppSort-1-1-1 
                                              context 
                                              (cons 
                                               (LIST-SPEC::|!++| 
                                                (cons 0 nil) 
                                                path) 
                                               '(:|Top|)) 
                                              (cdr pV104))) 
                                            nil)))) 
                                        (funcall (svref pp 38) pV106))))) 
                               (if (eq (car pattern) :|RecordPat|) 
                                   (let ((pV102 (car (cdr pattern)))) 
                                     (return 
                                      (if (ANNSPECPRINTER::isShortTuple 1 pV102) 
                                          (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                           path 
                                           #'(lambda (x1) 
                                              (block 
                                               nil 
                                               (return 
                                                (ANNSPECPRINTER::ppPattern-1-1-1 
                                                 context 
                                                 (cons (car x1) t) 
                                                 (cdr (cdr x1)))) 
                                               (error 
                                                "Nonexhaustive match failure in ppPattern"))) 
                                           (vector 
                                            (svref pp 22) 
                                            (svref pp 5) 
                                            (svref pp 31)) 
                                           pV102) 
                                          (labels 
                                            ((ppEntry (pV21 pV22) 
                                              (block 
                                               nil 
                                               (let ((pV23 (car pV22))) 
                                                 (return 
                                                  (PRETTYPRINT::blockFill 
                                                   0 
                                                   (cons 
                                                    (cons 
                                                     0 
                                                     (PRETTYPRINT::prettysNone 
                                                      (cons 
                                                       (funcall (svref pp 38) 
                                                                pV23) 
                                                       (cons (svref pp 13) nil)))) 
                                                    (cons 
                                                     (cons 
                                                      (INTEGER-SPEC::|!+| 
                                                       2 
                                                       (STRING-SPEC::|!length| 
                                                        pV23)) 
                                                      (PRETTYPRINT::prettysFill 
                                                       (cons 
                                                        (ANNSPECPRINTER::ppPattern-1-1-1 
                                                         context 
                                                         (cons pV21 t) 
                                                         (cdr pV22)) 
                                                        nil))) 
                                                     nil))))) 
                                               (error 
                                                "Nonexhaustive match failure in ppPattern")))) 
                                            (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                             path 
                                             #'(lambda (x1) 
                                                (ppEntry (car x1) (cdr x1))) 
                                             (vector 
                                              (svref pp 21) 
                                              (svref pp 5) 
                                              (svref pp 30)) 
                                             pV102))))) 
                                   (if (eq (car pattern) :|EmbedPat|) 
                                       (let ((pV43 (cdr pattern))) 
                                         (let ((pV63 (svref pV43 0))
                                               (pV64 (svref pV43 1))
                                               (pV65 (svref pV43 2))) 
                                           (progn (if (string=  "Nil" pV63) 
                                                      (if (eq (car pV64) :|None|) 
                                                          (if (eq 
                                                               (car pV65) 
                                                               :|Base|) 
                                                              (let ((pV89 
                                                                     (cdr pV65))) 
                                                                (let ((pV90 
                                                                       (svref 
                                                                        pV89 
                                                                        0))
                                                                      (pV91 
                                                                       (svref 
                                                                        pV89 
                                                                        1))) 
                                                                  (if (eq 
                                                                       (car pV90) 
                                                                       :|Qualified|) 
                                                                      (let ((pV93 
                                                                             (cdr 
                                                                              pV90))) 
                                                                        (let ((pV95 
                                                                               (cdr 
                                                                                pV93))) 
                                                                          (progn (if (string=  
                                                                                      "List" 
                                                                                      (car 
                                                                                       pV93)) 
                                                                                     (if (string=  
                                                                                          "List" 
                                                                                          pV95) 
                                                                                         (if (consp 
                                                                                              pV91) 
                                                                                             (if (null 
                                                                                                  (cdr 
                                                                                                   pV91)) 
                                                                                                 (return 
                                                                                                  (PRETTYPRINT::|!string| 
                                                                                                   "[]")))))) 
                                                                                 (if (string=  
                                                                                      "List" 
                                                                                      pV95) 
                                                                                     (if (consp 
                                                                                          pV91) 
                                                                                         (if (null 
                                                                                              (cdr 
                                                                                               pV91)) 
                                                                                             (return 
                                                                                              (PRETTYPRINT::|!string| 
                                                                                               "[]")))))))))))))) 
                                                  (if (eq (car pV64) :|None|) 
                                                      (return 
                                                       (funcall (svref pp 38) 
                                                                pV63))) 
                                                  (if (string=  "Cons" pV63) 
                                                      (if (eq (car pV64) :|Some|) 
                                                          (let ((pV68 (cdr pV64))) 
                                                            (if (eq 
                                                                 (car pV68) 
                                                                 :|RecordPat|) 
                                                                (let ((pV70 
                                                                       (car 
                                                                        (cdr 
                                                                         pV68)))) 
                                                                  (if (consp 
                                                                       pV70) 
                                                                      (let ((pV73 
                                                                             (car 
                                                                              pV70))
                                                                            (pV74 
                                                                             (cdr 
                                                                              pV70))) 
                                                                        (if (string=  
                                                                             "1" 
                                                                             (car 
                                                                              pV73)) 
                                                                            (if (consp 
                                                                                 pV74) 
                                                                                (let ((pV78 
                                                                                       (car 
                                                                                        pV74))) 
                                                                                  (if (string=  
                                                                                       "2" 
                                                                                       (car 
                                                                                        pV78)) 
                                                                                      (if (null 
                                                                                           (cdr 
                                                                                            pV74)) 
                                                                                          (if (eq 
                                                                                               (car 
                                                                                                pV65) 
                                                                                               :|Base|) 
                                                                                              (let ((pV84 
                                                                                                     (svref 
                                                                                                      (cdr 
                                                                                                       pV65) 
                                                                                                      1))) 
                                                                                                (if (consp 
                                                                                                     pV84) 
                                                                                                    (if (null 
                                                                                                         (cdr 
                                                                                                          pV84)) 
                                                                                                        (return 
                                                                                                         (ANNSPECPRINTER::|!enclose| 
                                                                                                          enclosed 
                                                                                                          (PRETTYPRINT::prettysFill 
                                                                                                           (cons 
                                                                                                            (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                                             context 
                                                                                                             (cons 
                                                                                                              (LIST-SPEC::|!++| 
                                                                                                               (cons 
                                                                                                                0 
                                                                                                                nil) 
                                                                                                               path) 
                                                                                                              nil) 
                                                                                                             (cdr 
                                                                                                              pV73)) 
                                                                                                            (cons 
                                                                                                             (PRETTYPRINT::|!string| 
                                                                                                              " :: ") 
                                                                                                             (cons 
                                                                                                              (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                                               context 
                                                                                                               (cons 
                                                                                                                (LIST-SPEC::|!++| 
                                                                                                                 (cons 
                                                                                                                  1 
                                                                                                                  nil) 
                                                                                                                 path) 
                                                                                                                nil) 
                                                                                                               (cdr 
                                                                                                                pV78)) 
                                                                                                              nil)))))))))))))))))))))) 
                                                  (if (eq (car pV64) :|Some|) 
                                                      (let ((pV67 (cdr pV64))) 
                                                        (return 
                                                         (ANNSPECPRINTER::|!enclose| 
                                                          enclosed 
                                                          (PRETTYPRINT::prettysFill 
                                                           (LIST-SPEC::|!cons| 
                                                            (funcall (svref 
                                                                      pp 
                                                                      38) 
                                                                     pV63) 
                                                            (if (ANNSPECPRINTER::singletonPattern 
                                                                 pV67) 
                                                                (cons 
                                                                 (PRETTYPRINT::|!string| 
                                                                  " ") 
                                                                 (cons 
                                                                  (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                   context 
                                                                   (cons 
                                                                    (LIST-SPEC::|!++| 
                                                                     (cons 0 nil) 
                                                                     path) 
                                                                    nil) 
                                                                   pV67) 
                                                                  nil)) 
                                                                (cons 
                                                                 (svref pp 22) 
                                                                 (cons 
                                                                  (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                   context 
                                                                   (cons 
                                                                    (LIST-SPEC::|!++| 
                                                                     (cons 0 nil) 
                                                                     path) 
                                                                    t) 
                                                                   pV67) 
                                                                  (cons 
                                                                   (svref pp 31) 
                                                                   nil))))))))))))) 
                                       (if (eq (car pattern) :|SortedPat|) 
                                           (let ((pV42 (cdr pattern))) 
                                             (return 
                                              (ANNSPECPRINTER::|!enclose| 
                                               enclosed 
                                               (PRETTYPRINT::blockFill 
                                                0 
                                                (cons 
                                                 (cons 
                                                  0 
                                                  (ANNSPECPRINTER::ppPattern-1-1-1 
                                                   context 
                                                   (cons 
                                                    (LIST-SPEC::|!++| 
                                                     (cons 0 nil) 
                                                     path) 
                                                    nil) 
                                                   (svref pV42 0))) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (PRETTYPRINT::|!string| " : ")) 
                                                  (cons 
                                                   (cons 
                                                    0 
                                                    (ANNSPECPRINTER::ppSort-1-1-1 
                                                     context 
                                                     (cons 
                                                      (LIST-SPEC::|!++| 
                                                       (cons 1 nil) 
                                                       path) 
                                                      '(:|Top|)) 
                                                     (svref pV42 1))) 
                                                   nil))))))) 
                                           (if (eq (car pattern) :|AliasPat|) 
                                               (let ((pV41 (cdr pattern))) 
                                                 (return 
                                                  (ANNSPECPRINTER::|!enclose| 
                                                   enclosed 
                                                   (PRETTYPRINT::blockFill 
                                                    0 
                                                    (cons 
                                                     (cons 
                                                      0 
                                                      (ANNSPECPRINTER::ppPattern-1-1-1 
                                                       context 
                                                       (cons 
                                                        (LIST-SPEC::|!++| 
                                                         (cons 0 nil) 
                                                         path) 
                                                        nil) 
                                                       (svref pV41 0))) 
                                                     (cons 
                                                      (cons 
                                                       0 
                                                       (PRETTYPRINT::|!string| 
                                                        " as ")) 
                                                      (cons 
                                                       (cons 
                                                        0 
                                                        (ANNSPECPRINTER::ppPattern-1-1-1 
                                                         context 
                                                         (cons 
                                                          (LIST-SPEC::|!++| 
                                                           (cons 1 nil) 
                                                           path) 
                                                          nil) 
                                                         (svref pV41 1))) 
                                                       nil))))))) 
                                               (if (eq (car pattern) :|RelaxPat|) 
                                                   (let ((pV40 (cdr pattern))) 
                                                     (let ((pV54 (svref pV40 0))) 
                                                       (return 
                                                        (progn (METASLANG::patternSort 
                                                                pV54) 
                                                               (ANNSPECPRINTER::|!enclose| 
                                                                enclosed 
                                                                (PRETTYPRINT::blockFill 
                                                                 0 
                                                                 (cons 
                                                                  (cons 
                                                                   0 
                                                                   (PRETTYPRINT::|!string| 
                                                                    "relax (")) 
                                                                  (cons 
                                                                   (cons 
                                                                    0 
                                                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                     context 
                                                                     (cons 
                                                                      (LIST-SPEC::|!++| 
                                                                       (cons 
                                                                        1 
                                                                        nil) 
                                                                       path) 
                                                                      '(:|Top|)) 
                                                                     (svref 
                                                                      pV40 
                                                                      1))) 
                                                                   (cons 
                                                                    (cons 
                                                                     0 
                                                                     (svref 
                                                                      pp 
                                                                      31)) 
                                                                    (cons 
                                                                     (cons 
                                                                      0 
                                                                      (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                       context 
                                                                       (cons 
                                                                        (LIST-SPEC::|!++| 
                                                                         (cons 
                                                                          0 
                                                                          nil) 
                                                                         path) 
                                                                        nil) 
                                                                       pV54)) 
                                                                     nil)))))))))) 
                                                   (if (eq 
                                                        (car pattern) 
                                                        :|QuotientPat|) 
                                                       (let ((pV39 (cdr pattern))) 
                                                         (return 
                                                          (ANNSPECPRINTER::|!enclose| 
                                                           enclosed 
                                                           (PRETTYPRINT::blockFill 
                                                            0 
                                                            (cons 
                                                             (cons 
                                                              0 
                                                              (PRETTYPRINT::|!string| 
                                                               "quotient(")) 
                                                             (cons 
                                                              (cons 
                                                               0 
                                                               (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                context 
                                                                (cons 
                                                                 (LIST-SPEC::|!++| 
                                                                  (cons 1 nil) 
                                                                  path) 
                                                                 '(:|Top|)) 
                                                                (svref pV39 1))) 
                                                              (cons 
                                                               (cons 
                                                                0 
                                                                (PRETTYPRINT::|!string| 
                                                                 " ?)")) 
                                                               (cons 
                                                                (cons 
                                                                 0 
                                                                 (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                  context 
                                                                  (cons 
                                                                   (LIST-SPEC::|!++| 
                                                                    (cons 0 nil) 
                                                                    path) 
                                                                   nil) 
                                                                  (svref pV39 0))) 
                                                                nil)))))))))))))))))))) 
       (return (SYSTEM-SPEC::fail "Uncovered case for pattern"))))))

(defun ANNSPECPRINTER::ppSort-1-1-1 (context x srt) 
  (let ((path (car x))
        (parent (cdr x))) 
    (let ((pp (svref context 4))) 
      (block 
       nil 
       (if (eq (car srt) :|CoProduct|) 
           (let ((pV86 (car (cdr srt)))) 
             (return 
              (labels 
                ((ppEntry (pV4 pV5) 
                  (block 
                   nil 
                   (let ((pV6 (car pV5))
                         (pV7 (cdr pV5))) 
                     (return 
                      (block 
                       nil 
                       (if (eq (car pV7) :|Some|) 
                           (return 
                            (PRETTYPRINT::prettysNone 
                             (cons 
                              (svref pp 3) 
                              (cons 
                               (funcall (svref pp 38) pV6) 
                               (cons 
                                (PRETTYPRINT::|!string| " ") 
                                (cons 
                                 (ANNSPECPRINTER::ppSort-1-1-1 
                                  context 
                                  (cons pV4 '(:|CoProduct|)) 
                                  (cdr pV7)) 
                                 nil)))))) 
                           (if (eq (car pV7) :|None|) 
                               (return 
                                (PRETTYPRINT::prettysNone 
                                 (cons 
                                  (svref pp 3) 
                                  (cons (funcall (svref pp 38) pV6) nil)))))) 
                       (error "Nonexhaustive match failure in ppSort")))) 
                   (error "Nonexhaustive match failure in ppSort")))) 
                (progn (block 
                        nil 
                        (if (eq (car parent) :|Product|) 
                            (return (cons (svref pp 22) (svref pp 31))) 
                            (if (eq (car parent) :|CoProduct|) 
                                (return (cons (svref pp 22) (svref pp 31))))) 
                        (return (cons (svref pp 10) (svref pp 10)))) 
                       (block 
                        nil 
                        (return 
                         (ANNTERMPRINTER::ppListPath-1-1-1-1 
                          path 
                          #'(lambda (x1) (ppEntry (car x1) (cdr x1))) 
                          (vector (svref pp 10) (svref pp 10) (svref pp 10)) 
                          pV86)) 
                        (error "Nonexhaustive match failure in ppSort")))))) 
           (if (eq (car srt) :|Product|) 
               (let ((pV84 (car (cdr srt)))) 
                 (progn (if (null pV84) (return (PRETTYPRINT::|!string| "()"))) 
                        (return 
                         (if (ANNSPECPRINTER::isShortTuple 1 pV84) 
                             (let ((pV21 
                                    (block 
                                     nil 
                                     (if (eq (car parent) :|Product|) 
                                         (return 
                                          (cons (svref pp 22) (svref pp 31)))) 
                                     (return (cons (svref pp 10) (svref pp 10)))))) 
                               (block 
                                nil 
                                (return 
                                 (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                  path 
                                  #'(lambda (x1) 
                                     (block 
                                      nil 
                                      (return 
                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                        context 
                                        (cons (car x1) '(:|Product|)) 
                                        (cdr (cdr x1)))) 
                                      (error 
                                       "Nonexhaustive match failure in ppSort"))) 
                                  (vector (car pV21) (svref pp 28) (cdr pV21)) 
                                  pV84)) 
                                (error "Nonexhaustive match failure in ppSort"))) 
                             (labels 
                               ((ppEntry (pV24 pV25) 
                                 (block 
                                  nil 
                                  (return 
                                   (PRETTYPRINT::blockFill 
                                    0 
                                    (cons 
                                     (cons 0 (funcall (svref pp 38) (car pV25))) 
                                     (cons 
                                      (cons 0 (PRETTYPRINT::|!string| ":")) 
                                      (cons 
                                       (cons 
                                        0 
                                        (ANNSPECPRINTER::ppSort-1-1-1 
                                         context 
                                         (cons pV24 '(:|Top|)) 
                                         (cdr pV25))) 
                                       nil))))) 
                                  (error "Nonexhaustive match failure in ppSort")))) 
                               (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                path 
                                #'(lambda (x1) (ppEntry (car x1) (cdr x1))) 
                                (vector 
                                 (svref pp 21) 
                                 (PRETTYPRINT::|!string| ", ") 
                                 (svref pp 30)) 
                                pV84)))))) 
               (if (eq (car srt) :|Arrow|) 
                   (let ((pV51 (cdr srt))) 
                     (return 
                      (let ((pV31 
                             (block 
                              nil 
                              (if (eq (car parent) :|Product|) 
                                  (return (cons (svref pp 22) (svref pp 31))) 
                                  (if (eq (car parent) :|ArrowLeft|) 
                                      (return (cons (svref pp 22) (svref pp 31))))) 
                              (return (cons (svref pp 10) (svref pp 10)))))) 
                        (block 
                         nil 
                         (return 
                          (PRETTYPRINT::blockFill 
                           0 
                           (cons 
                            (cons 
                             0 
                             (PRETTYPRINT::prettysNone 
                              (cons 
                               (car pV31) 
                               (cons 
                                (ANNSPECPRINTER::ppSort-1-1-1 
                                 context 
                                 (cons 
                                  (LIST-SPEC::|!++| (cons 0 nil) path) 
                                  '(:|ArrowLeft|)) 
                                 (svref pV51 0)) 
                                (cons (svref pp 1) nil))))) 
                            (cons 
                             (cons 
                              3 
                              (PRETTYPRINT::prettysNone 
                               (cons 
                                (ANNSPECPRINTER::ppSort-1-1-1 
                                 context 
                                 (cons 
                                  (LIST-SPEC::|!++| (cons 1 nil) path) 
                                  '(:|ArrowRight|)) 
                                 (svref pV51 1)) 
                                (cons (cdr pV31) nil)))) 
                             nil)))) 
                         (error "Nonexhaustive match failure in ppSort"))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV50 (cdr srt))) 
                         (let ((pV64 (svref pV50 0))
                               (pV65 (svref pV50 1))) 
                           (progn (if (eq (car pV65) :|Lambda|) 
                                      (let ((pV68 (car (cdr pV65)))) 
                                        (if (consp pV68) 
                                            (let ((pV71 (car pV68))) 
                                              (let ((pV74 (svref pV71 1))) 
                                                (if (eq (car pV74) :|Fun|) 
                                                    (let ((pV77 
                                                           (svref (cdr pV74) 0))) 
                                                      (if (eq (car pV77) :|Bool|) 
                                                          (if (eq t (cdr pV77)) 
                                                              (if (null 
                                                                   (cdr pV68)) 
                                                                  (return 
                                                                   (PRETTYPRINT::blockFill 
                                                                    0 
                                                                    (cons 
                                                                     (cons 
                                                                      0 
                                                                      (svref 
                                                                       pp 
                                                                       21)) 
                                                                     (cons 
                                                                      (cons 
                                                                       0 
                                                                       (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                        context 
                                                                        (cons 
                                                                         (LIST-SPEC::|!++| 
                                                                          (cons 
                                                                           0 
                                                                           (cons 
                                                                            0 
                                                                            (cons 
                                                                             1 
                                                                             nil))) 
                                                                          path) 
                                                                         t) 
                                                                        (svref 
                                                                         pV71 
                                                                         0))) 
                                                                      (cons 
                                                                       (cons 
                                                                        0 
                                                                        (PRETTYPRINT::|!string| 
                                                                         " : ")) 
                                                                       (cons 
                                                                        (cons 
                                                                         0 
                                                                         (ANNSPECPRINTER::ppSort-1-1-1 
                                                                          context 
                                                                          (cons 
                                                                           (LIST-SPEC::|!++| 
                                                                            (cons 
                                                                             0 
                                                                             nil) 
                                                                            path) 
                                                                           '(:|Top|)) 
                                                                          pV64)) 
                                                                        (cons 
                                                                         (cons 
                                                                          0 
                                                                          (svref 
                                                                           pp 
                                                                           3)) 
                                                                         (cons 
                                                                          (cons 
                                                                           0 
                                                                           (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                            context 
                                                                            (cons 
                                                                             (LIST-SPEC::|!++| 
                                                                              (cons 
                                                                               2 
                                                                               (cons 
                                                                                0 
                                                                                (cons 
                                                                                 1 
                                                                                 nil))) 
                                                                              path) 
                                                                             '(:|Top|)) 
                                                                            (svref 
                                                                             pV71 
                                                                             2))) 
                                                                          (cons 
                                                                           (cons 
                                                                            0 
                                                                            (svref 
                                                                             pp 
                                                                             30)) 
                                                                           nil))))))))))))))))))) 
                                  (return 
                                   (PRETTYPRINT::blockFill 
                                    0 
                                    (cons 
                                     (cons 0 (svref pp 22)) 
                                     (cons 
                                      (cons 
                                       0 
                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                        context 
                                        (cons 
                                         (LIST-SPEC::|!++| (cons 0 nil) path) 
                                         '(:|Top|)) 
                                        pV64)) 
                                      (cons 
                                       (cons 0 (svref pp 3)) 
                                       (cons 
                                        (cons 
                                         0 
                                         (ANNSPECPRINTER::ppTerm-1-1-1 
                                          context 
                                          (cons 
                                           (LIST-SPEC::|!++| (cons 1 nil) path) 
                                           '(:|Top|)) 
                                          pV65)) 
                                        (cons (cons 0 (svref pp 31)) nil)))))))))) 
                       (if (eq (car srt) :|Quotient|) 
                           (let ((pV49 (cdr srt))) 
                             (return 
                              (PRETTYPRINT::blockFill 
                               0 
                               (cons 
                                (cons 0 (svref pp 22)) 
                                (cons 
                                 (cons 
                                  0 
                                  (ANNSPECPRINTER::ppSort-1-1-1 
                                   context 
                                   (cons 
                                    (LIST-SPEC::|!++| (cons 0 nil) path) 
                                    '(:|Top|)) 
                                   (svref pV49 0))) 
                                 (cons 
                                  (cons 0 (PRETTYPRINT::|!string| " / ")) 
                                  (cons 
                                   (cons 
                                    0 
                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                     context 
                                     (cons 
                                      (LIST-SPEC::|!++| (cons 1 nil) path) 
                                      '(:|Top|)) 
                                     (svref pV49 1))) 
                                   (cons (cons 0 (svref pp 31)) nil)))))))) 
                           (if (eq (car srt) :|Base|) 
                               (let ((pV48 (cdr srt))) 
                                 (let ((pV58 (svref pV48 0))
                                       (pV59 (svref pV48 1))) 
                                   (progn (if (null pV59) 
                                              (return 
                                               (funcall (svref pp 46) pV58))) 
                                          (return 
                                           (PRETTYPRINT::blockFill 
                                            0 
                                            (cons 
                                             (cons 
                                              0 
                                              (funcall (svref pp 46) pV58)) 
                                             (cons 
                                              (cons 
                                               0 
                                               (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                path 
                                                #'(lambda (x1) 
                                                   (ANNSPECPRINTER::ppSort-1-1-1 
                                                    context 
                                                    (cons (car x1) '(:|Top|)) 
                                                    (cdr x1))) 
                                                (vector 
                                                 (svref pp 22) 
                                                 (svref pp 5) 
                                                 (svref pp 31)) 
                                                pV59)) 
                                              nil))))))) 
                               (if (eq (car srt) :|TyVar|) 
                                   (return 
                                    (PRETTYPRINT::|!string| (car (cdr srt)))) 
                                   (if (eq (car srt) :|MetaTyVar|) 
                                       (return 
                                        (PRETTYPRINT::|!string| 
                                         (ANNSPECPRINTER::TyVarString 
                                          (car (cdr srt))))))))))))) 
       (return (PRETTYPRINT::|!string| "ignoring bad case for sort"))))))

(defun ANNTERMPRINTER::ppAsciiId (pV1) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV2 (cdr pV1))) 
         (let ((pV4 (cdr pV2))
               (pV3 (car pV2))) 
           (return 
            (PRETTYPRINT::|!string| 
             (if (cl:or 
                  (string=  pV3 METASLANG::UnQualified) 
                  (cl:or 
                   (string=  pV3 "Nat") 
                   (cl:or 
                    (string=  pV3 "Boolean") 
                    (cl:or 
                     (string=  pV3 "String") 
                     (cl:or 
                      (string=  pV3 "Integer") 
                      (cl:or 
                       (string=  pV3 "General") 
                       (cl:or (string=  pV3 "Char") (string=  pV3 "List")))))))) 
                 pV4 
                 (STRING-SPEC::^ (STRING-SPEC::^ pV3 ".") pV4))))))) 
   (error "Nonexhaustive match failure in ppAsciiId")))

(defparameter ANNTERMPRINTER::asciiPrinter 
  (vector 
   (PRETTYPRINT::|!string| " and ") 
   (PRETTYPRINT::|!string| " -> ") 
   (PRETTYPRINT::|!string| "axiom") 
   (PRETTYPRINT::|!string| " | ") 
   (PRETTYPRINT::|!string| "case ") 
   (PRETTYPRINT::|!string| ", ") 
   (PRETTYPRINT::|!string| "conjecture") 
   (PRETTYPRINT::|!string| "def ") 
   (PRETTYPRINT::|!string| "=") 
   (PRETTYPRINT::|!string| "else ") 
   (PRETTYPRINT::|!string| "") 
   (PRETTYPRINT::|!string| "end-module") 
   (PRETTYPRINT::|!string| "endspec") 
   (PRETTYPRINT::|!string| "=") 
   (PRETTYPRINT::|!string| "ex") 
   (PRETTYPRINT::|!string| "fa") 
   (PRETTYPRINT::|!string| "if ") 
   (PRETTYPRINT::|!string| "import ") 
   (PRETTYPRINT::|!string| "in ") 
   (PRETTYPRINT::|!string| "is") 
   (PRETTYPRINT::|!string| "[") 
   (PRETTYPRINT::|!string| "{") 
   (PRETTYPRINT::|!string| "(") 
   (PRETTYPRINT::|!string| "fn ") 
   (PRETTYPRINT::|!string| "let ") 
   (PRETTYPRINT::|!string| "module ") 
   (PRETTYPRINT::|!string| "of ") 
   (PRETTYPRINT::|!string| "op") 
   (PRETTYPRINT::|!string| " * ") 
   (PRETTYPRINT::|!string| "]") 
   (PRETTYPRINT::|!string| "}") 
   (PRETTYPRINT::|!string| ")") 
   (PRETTYPRINT::|!string| "sort") 
   (PRETTYPRINT::|!string| "spec ") 
   (PRETTYPRINT::|!string| " then ") 
   (PRETTYPRINT::|!string| "theorem") 
   (PRETTYPRINT::|!string| "_") 
   (PRETTYPRINT::|!string| "where") 
   #'PRETTYPRINT::|!string| 
   #'PRETTYPRINT::|!string| 
   #'PRETTYPRINT::|!string| 
   #'PRETTYPRINT::|!string| 
   #'ANNTERMPRINTER::ppAsciiId 
   #'ANNTERMPRINTER::ppAsciiId 
   #'ANNTERMPRINTER::ppAsciiId 
   #'PRETTYPRINT::|!string| 
   #'ANNTERMPRINTER::ppAsciiId))

(defun PRETTYPRINT::newlineString () (CHAR-SPEC::toString (CHAR-SPEC::chr 10)))

(defun PRETTYPRINT::newlineAndBlanks (n) 
  (STRING-SPEC::^ (PRETTYPRINT::newlineString) (PRETTYPRINT::blanks n)))

(defun PRETTYPRINT::streamWriter (|!stream| |!string|) 
  (IO-SPEC::format1 |!stream| "~A" |!string|))

(defun LIST-SPEC::rev2 (l r) 
  (block 
   nil 
   (if (null l) 
       (return r) 
       (if (consp l) (return (LIST-SPEC::rev2 (cdr l) (cons (car l) r))))) 
   (error "Nonexhaustive match failure in rev2")))

(defun LIST-SPEC::rev (s) (LIST-SPEC::rev2 s nil))

(defun PRETTYPRINT::toStreamT (text cont base newlineAndBlanks) 
  (let ((pV14 (LIST-SPEC::rev text))) 
    (block 
     nil 
     (if (null pV14) 
         (return base) 
         (if (consp pV14) 
             (return 
              (progn (LIST-SPEC::foldr-1-1-1 cont nil (cdr (car pV14))) 
                     (progn (LIST-SPEC::app-1-1 
                             #'(lambda (textel) 
                                (let ((pV8 (cdr textel))) 
                                  (block 
                                   nil 
                                   (if (consp pV8) 
                                       (if ( =  0 (car (car pV8))) 
                                           (if (null (cdr pV8)) 
                                               (return 
                                                (funcall newlineAndBlanks 
                                                         (cons 0 nil)))))) 
                                   (return 
                                    (progn (funcall newlineAndBlanks 
                                                    (cons (car textel) nil)) 
                                           (LIST-SPEC::foldr-1-1-1 cont nil pV8))) 
                                   (error 
                                    "Nonexhaustive match failure in toStreamT")))) 
                             (cdr pV14)) 
                            (funcall cont 
                                     (cons (cons 0 (PRETTYPRINT::blanks 0)) base))))))) 
     (error "Nonexhaustive match failure in toStreamT"))))

(defun PRETTYPRINT::toString (text) 
  (IO-SPEC::withOutputToString 
   #'(lambda (|!stream|) 
      (PRETTYPRINT::toStreamT 
       text 
       #'(lambda (x) 
          (block 
           nil 
           (return (PRETTYPRINT::streamWriter |!stream| (cdr (car x)))) 
           (error "Nonexhaustive match failure in toString"))) 
       nil 
       #'(lambda (x) 
          (block 
           nil 
           (return 
            (PRETTYPRINT::streamWriter 
             |!stream| 
             (PRETTYPRINT::newlineAndBlanks (car x)))) 
           (error "Nonexhaustive match failure in toString")))))))

(defun PRETTYPRINT::emptyText () nil)

(defun PRETTYPRINT::|!format| (columns p) 
  (PRETTYPRINT::formatPretty columns p (PRETTYPRINT::emptyText)))

(defun ANNSPECPRINTER::printSort (srt) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSort-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     srt))))

(defun ANNSPECPRINTER::TyVarString (mtv) 
  (let ((pV3 (STATE::|!!| mtv))) 
    (block 
     nil 
     (let ((pV4 (svref pV3 0))) 
       (return 
        (block 
         nil 
         (if (eq (car pV4) :|None|) 
             (return (STRING-SPEC::^ "mtv%" (NAT-SPEC::toString (svref pV3 2)))) 
             (if (eq (car pV4) :|Some|) 
                 (return (ANNSPECPRINTER::printSort (cdr pV4))))) 
         (error "Nonexhaustive match failure in TyVarString")))) 
     (error "Nonexhaustive match failure in TyVarString"))))

(defun ANNSPECPRINTER::boolToNat (b) (if b 1 0))

(defparameter ANNSPECPRINTER::defIndex 2)

(defun ANNSPECPRINTER::|!enclose|-1 (x) 
  (ANNSPECPRINTER::|!enclose| (car x) (cdr x)))

(defun ANNSPECPRINTER::isBuiltIn? (spec_ref pV1) 
  (declare (ignore pV1)) 
  (cl:or 
   (string=  spec_ref "String") 
   (cl:or 
    (string=  spec_ref "Nat") 
    (cl:or 
     (string=  spec_ref "Boolean") 
     (cl:or 
      (string=  spec_ref "Char") 
      (cl:or 
       (string=  spec_ref "Integer") 
       (cl:or (string=  spec_ref "List") (string=  spec_ref "General"))))))))

(defun ANNSPECPRINTER::isBuiltIn?-1 (x) 
  (ANNSPECPRINTER::isBuiltIn? (car x) (cdr x)))

(defparameter ANNSPECPRINTER::opIndex 1)

(defun ANNTERMPRINTER::ppList-1-1-1 (f x ps) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (svref x 0) 
    (cons 
     (PRETTYPRINT::prettysLinear 
      (PRETTYPRINT::addSeparator-1-1 (svref x 1) (LIST-SPEC::|!map|-1-1 f ps))) 
     (cons (svref x 2) nil)))))

(defun ANNSPECPRINTER::ppForallTyVars-1-1 (pp |!tyVars|) 
  (block 
   nil 
   (if (null |!tyVars|) (return (PRETTYPRINT::|!string| ""))) 
   (return 
    (ANNTERMPRINTER::ppList-1-1-1 
     #'PRETTYPRINT::|!string| 
     (vector 
      (PRETTYPRINT::prettysNone 
       (cons 
        (PRETTYPRINT::|!string| " ") 
        (cons (svref pp 15) (cons (svref pp 22) nil)))) 
      (svref pp 5) 
      (svref pp 31)) 
     |!tyVars|))))

(defun BOOLEAN-SPEC::~ (x) (if x nil t))

(defun SPLAYSET::compf-1-1 (!x1 k_) (funcall (car !x1) (cons k_ (cdr !x1))))

(defun SPLAYSET::compf-1 (x1) #'(lambda (x2) (SPLAYSET::compf-1-1 x1 x2)))

(defun SPLAYSET::compf (x0 x1) (SPLAYSET::compf-1 (cons x0 x1)))

(defun SPLAYSET::|!member| (|!set| key) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV6 (cdr |!set|))) 
             (let ((pV10 (svref pV6 2))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        (SPLAYSET::compf (svref pV6 0) key) 
                        (STATE::|!!| pV10)))) 
                  (let ((pV4 (cdr x))) 
                    (block 
                     nil 
                     (if (eq (car (car x)) :|Equal|) 
                         (return (progn (STATE::|:=| pV10 pV4) t))) 
                     (return (progn (STATE::|:=| pV10 pV4) nil)) 
                     (error "Nonexhaustive match failure in member"))))))))) 
   (error "Nonexhaustive match failure in member")))

(defun INTEGERSET::|!member| (x0 x) (SPLAYSET::|!member| x0 x))

(defun LIST-SPEC::|!null| (l) (block nil (if (null l) (return t)) (return nil)))

(defun PRETTYPRINT::printInt (i) (INTEGER-SPEC::toString i))

(defun PRETTYPRINT::buttonPretty (enabled |!number| p sos?) 
  (let ((|!string| 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ (BOOLEAN-SPEC::toString enabled) ":") 
            (PRETTYPRINT::printInt |!number|)) 
           ":") 
          (BOOLEAN-SPEC::toString sos?)))) 
    (PRETTYPRINT::prettysNone 
     (cons 
      (PRETTYPRINT::lengthString 0 "%[") 
      (cons (PRETTYPRINT::lengthString 0 |!string|) (cons p nil))))))

(defun LIST-SPEC::@ (s1 s2) (LIST-SPEC::concat s1 s2))

(defun PRETTYPRINT::markLines (uniqueId p) 
  (LIST-SPEC::@ 
   (LIST-SPEC::@ 
    (cons 
     (cons 0 (PRETTYPRINT::lengthString 0 "%(")) 
     (cons 
      (cons 0 (PRETTYPRINT::lengthString 0 (NAT-SPEC::toString uniqueId))) 
      nil)) 
    p) 
   (cons (cons 0 (PRETTYPRINT::lengthString 0 "%)")) nil)))

(defun PRETTYPRINT::prettysBlockDelim-1-1-1 (prettysBlock x ps) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::|!string| (svref x 0)) 
    (cons 
     (funcall prettysBlock 
              (PRETTYPRINT::addSeparator-1-1 
               (PRETTYPRINT::|!string| (svref x 1)) 
               ps)) 
     (cons (PRETTYPRINT::|!string| (svref x 2)) nil)))))

(defun PRETTYPRINT::prettysLinearDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysLinear delims ps))

(defun PRETTYPRINT::ppList-1-1-1 (f x ts) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector (svref x 0) (svref x 1) (svref x 2)) 
   (LIST-SPEC::|!map|-1-1 f ts)))

(defun ANNSPECPRINTER::ppOpDecl-1-1 (context x) 
  (let ((pV40 (svref x 2))
        (pV41 (svref x 3))) 
    (block 
     nil 
     (let ((pV42 (svref pV40 0))
           (pV43 (svref pV40 1))
           (pV44 (svref pV40 2))
           (pV45 (svref pV40 3))) 
       (if (consp pV42) 
           (let ((pV47 (car pV42))) 
             (if (eq (car pV47) :|Qualified|) 
                 (let ((pV49 (cdr pV47))) 
                   (let ((pV52 (car pV44))
                         (pV53 (cdr pV44))) 
                     (let ((pV54 (car pV41))
                           (pV55 (cdr pV41))) 
                       (return 
                        (if (BOOLEAN-SPEC::~ 
                             (cl:and 
                              (string=  (svref x 0) (car pV49)) 
                              (string=  (svref x 1) (cdr pV49)))) 
                            (cons pV54 pV55) 
                            (let ((pp (svref context 4))) 
                              (labels 
                                ((ppOpName (qid) 
                                  (block 
                                   nil 
                                   (if (eq (car qid) :|Qualified|) 
                                       (let ((pV3 (cdr qid))) 
                                         (return 
                                          (if (string=  
                                               (car pV3) 
                                               METASLANG::UnQualified) 
                                              (funcall (svref pp 41) (cdr pV3)) 
                                              (funcall (svref pp 42) qid))))) 
                                   (error 
                                    "Nonexhaustive match failure in ppOpDecl")))) 
                                (labels 
                                  ((ppOpNames () 
                                    (block 
                                     nil 
                                     (if (consp pV42) 
                                         (if (null (cdr pV42)) 
                                             (return (ppOpName (car pV42))))) 
                                     (return 
                                      (PRETTYPRINT::ppList-1-1-1 
                                       #'ppOpName 
                                       (vector "{" "," "}") 
                                       pV42))))) 
                                  (let ((index1 
                                         (INTEGER-SPEC::~ 
                                          (INTEGER-SPEC::|!+| pV54 1)))) 
                                    (let ((button1 
                                           (if (cl:and 
                                                (ANNSPECPRINTER::markSubterm?-1 
                                                 context) 
                                                (BOOLEAN-SPEC::~ 
                                                 (LIST-SPEC::|!null| pV45))) 
                                               (PRETTYPRINT::buttonPretty 
                                                (BOOLEAN-SPEC::~ 
                                                 (INTEGERSET::|!member| 
                                                  (svref context 0) 
                                                  index1)) 
                                                index1 
                                                (PRETTYPRINT::|!string| " ") 
                                                nil) 
                                               (PRETTYPRINT::|!string| "")))) 
                                      (let ((button2 
                                             (if (cl:and 
                                                  (ANNSPECPRINTER::markSubterm?-1 
                                                   context) 
                                                  (BOOLEAN-SPEC::~ 
                                                   (LIST-SPEC::|!null| pV45))) 
                                                 (PRETTYPRINT::buttonPretty 
                                                  (INTEGERSET::|!member| 
                                                   (svref context 6) 
                                                   index1) 
                                                  index1 
                                                  (PRETTYPRINT::|!string| " ") 
                                                  t) 
                                                 (PRETTYPRINT::|!string| "")))) 
                                        (cons 
                                         (INTEGER-SPEC::|!+| pV54 1) 
                                         (LIST-SPEC::|!cons| 
                                          (cons 
                                           1 
                                           (PRETTYPRINT::blockFill 
                                            0 
                                            (cons 
                                             (cons 0 (svref pp 27)) 
                                             (cons 
                                              (cons 
                                               0 
                                               (PRETTYPRINT::|!string| " ")) 
                                              (cons 
                                               (cons 0 (ppOpNames)) 
                                               (cons 
                                                (cons 
                                                 0 
                                                 (block 
                                                  nil 
                                                  (if (null pV43) 
                                                      (return 
                                                       (PRETTYPRINT::|!string| 
                                                        "")) 
                                                      (if (consp pV43) 
                                                          (let ((pV13 (car pV43))
                                                                (pV14 (cdr pV43))) 
                                                            (if (eq 
                                                                 (car pV13) 
                                                                 :|Left|) 
                                                                (return 
                                                                 (PRETTYPRINT::|!string| 
                                                                  (STRING-SPEC::^ 
                                                                   " infixl " 
                                                                   (NAT-SPEC::toString 
                                                                    pV14)))) 
                                                                (if (eq 
                                                                     (car pV13) 
                                                                     :|Right|) 
                                                                    (return 
                                                                     (PRETTYPRINT::|!string| 
                                                                      (STRING-SPEC::^ 
                                                                       " infixr " 
                                                                       (NAT-SPEC::toString 
                                                                        pV14))))))))) 
                                                  (error 
                                                   "Nonexhaustive match failure in ppOpDecl"))) 
                                                (cons 
                                                 (cons 
                                                  0 
                                                  (PRETTYPRINT::|!string| " :")) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (ANNSPECPRINTER::ppForallTyVars-1-1 
                                                    pp 
                                                    pV52)) 
                                                  (cons 
                                                   (cons 
                                                    0 
                                                    (PRETTYPRINT::|!string| " ")) 
                                                   (cons 
                                                    (cons 
                                                     3 
                                                     (ANNSPECPRINTER::ppSort-1-1-1 
                                                      context 
                                                      (cons 
                                                       (cons 
                                                        pV54 
                                                        (cons 
                                                         ANNSPECPRINTER::opIndex 
                                                         nil)) 
                                                       '(:|Top|)) 
                                                      pV53)) 
                                                    nil)))))))))) 
                                          (LIST-SPEC::foldl-1-1-1 
                                           #'(lambda (x1) 
                                              (let ((pV34 (car x1))
                                                    (pV35 (cdr x1))) 
                                                (block 
                                                 nil 
                                                 (let ((pV36 (car pV34))
                                                       (pV37 (cdr pV34))) 
                                                   (return 
                                                    (labels 
                                                      ((ppDefn (path term) 
                                                        (block 
                                                         nil 
                                                         (if (eq 
                                                              (car term) 
                                                              :|Lambda|) 
                                                             (let ((pV21 
                                                                    (car 
                                                                     (cdr term)))) 
                                                               (if (consp pV21) 
                                                                   (let ((pV24 
                                                                          (car 
                                                                           pV21))) 
                                                                     (let ((pV27 
                                                                            (svref 
                                                                             pV24 
                                                                             1))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV27) 
                                                                            :|Fun|) 
                                                                           (let ((pV30 
                                                                                  (svref 
                                                                                   (cdr 
                                                                                    pV27) 
                                                                                   0))) 
                                                                             (if (eq 
                                                                                  (car 
                                                                                   pV30) 
                                                                                  :|Bool|) 
                                                                                 (if (eq 
                                                                                      t 
                                                                                      (cdr 
                                                                                       pV30)) 
                                                                                     (if (null 
                                                                                          (cdr 
                                                                                           pV21)) 
                                                                                         (return 
                                                                                          (let ((pat 
                                                                                                 (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                                  context 
                                                                                                  (cons 
                                                                                                   (LIST-SPEC::|!++| 
                                                                                                    (cons 
                                                                                                     0 
                                                                                                     (cons 
                                                                                                      0 
                                                                                                      nil)) 
                                                                                                    path) 
                                                                                                   nil) 
                                                                                                  (svref 
                                                                                                   pV24 
                                                                                                   0)))) 
                                                                                            (let ((body 
                                                                                                   (ppDefn 
                                                                                                    (LIST-SPEC::|!++| 
                                                                                                     (cons 
                                                                                                      2 
                                                                                                      (cons 
                                                                                                       0 
                                                                                                       nil)) 
                                                                                                     path) 
                                                                                                    (svref 
                                                                                                     pV24 
                                                                                                     2)))) 
                                                                                              (let ((prettys 
                                                                                                     (LIST-SPEC::|!++| 
                                                                                                      (cons 
                                                                                                       (cons 
                                                                                                        0 
                                                                                                        pat) 
                                                                                                       (cons 
                                                                                                        (cons 
                                                                                                         0 
                                                                                                         (PRETTYPRINT::|!string| 
                                                                                                          " ")) 
                                                                                                        nil)) 
                                                                                                      body))) 
                                                                                                (if (ANNSPECPRINTER::markSubterm?-1 
                                                                                                     context) 
                                                                                                    (let ((num 
                                                                                                           (STATE::|!!| 
                                                                                                            (svref 
                                                                                                             context 
                                                                                                             1)))) 
                                                                                                      (let ((table 
                                                                                                             (STATE::|!!| 
                                                                                                              (svref 
                                                                                                               context 
                                                                                                               3)))) 
                                                                                                        (progn (STATE::|:=| 
                                                                                                                (svref 
                                                                                                                 context 
                                                                                                                 3) 
                                                                                                                (NATMAP::insert 
                                                                                                                 table 
                                                                                                                 num 
                                                                                                                 path)) 
                                                                                                               (STATE::|:=| 
                                                                                                                (svref 
                                                                                                                 context 
                                                                                                                 1) 
                                                                                                                (INTEGER-SPEC::|!+| 
                                                                                                                 num 
                                                                                                                 1)) 
                                                                                                               (PRETTYPRINT::markLines 
                                                                                                                num 
                                                                                                                prettys)))) 
                                                                                                    prettys))))))))))))))) 
                                                         (return 
                                                          (let ((pretty 
                                                                 (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                  context 
                                                                  (cons 
                                                                   path 
                                                                   '(:|Top|)) 
                                                                  term))) 
                                                            (let ((prettys 
                                                                   (cons 
                                                                    (cons 
                                                                     0 
                                                                     (svref pp 8)) 
                                                                    (cons 
                                                                     (cons 
                                                                      0 
                                                                      (PRETTYPRINT::|!string| 
                                                                       " ")) 
                                                                     (cons 
                                                                      (cons 
                                                                       4 
                                                                       pretty) 
                                                                      nil))))) 
                                                              prettys)))))) 
                                                      (let ((prettys 
                                                             (ppDefn 
                                                              (cons 
                                                               pV54 
                                                               (cons 
                                                                ANNSPECPRINTER::defIndex 
                                                                nil)) 
                                                              pV37))) 
                                                        (LIST-SPEC::|!cons| 
                                                         (cons 
                                                          1 
                                                          (PRETTYPRINT::blockFill 
                                                           0 
                                                           (LIST-SPEC::|!++| 
                                                            (cons 
                                                             (cons 
                                                              0 
                                                              (PRETTYPRINT::blockFill 
                                                               0 
                                                               (cons 
                                                                (cons 0 button1) 
                                                                (cons 
                                                                 (cons 0 button2) 
                                                                 (cons 
                                                                  (cons 
                                                                   0 
                                                                   (svref pp 7)) 
                                                                  (cons 
                                                                   (if (ANNSPECPRINTER::printSort?-1 
                                                                        context) 
                                                                       (cons 
                                                                        0 
                                                                        (ANNSPECPRINTER::ppForallTyVars-1-1 
                                                                         pp 
                                                                         pV36)) 
                                                                       (cons 
                                                                        0 
                                                                        (PRETTYPRINT::|!string| 
                                                                         ""))) 
                                                                   (cons 
                                                                    (cons 
                                                                     0 
                                                                     (ppOpName 
                                                                      pV47)) 
                                                                    (cons 
                                                                     (cons 
                                                                      0 
                                                                      (PRETTYPRINT::|!string| 
                                                                       " ")) 
                                                                     nil)))))))) 
                                                             nil) 
                                                            prettys))) 
                                                         pV35))))) 
                                                 (error 
                                                  "Nonexhaustive match failure in ppOpDecl")))) 
                                           pV55 
                                           pV45)))))))))))))))))) 
     (error "Nonexhaustive match failure in ppOpDecl"))))

(defun ANNSPECPRINTER::ppOpDecl-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppOpDecl-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppOpDecls-1-1 (context ops) 
  (let ((pV1 
         (STRINGMAP::foldriDouble-1-1-1 
          (ANNSPECPRINTER::ppOpDecl-1 context) 
          (cons 0 nil) 
          ops))) 
    (block 
     nil 
     (return (cdr pV1)) 
     (error "Nonexhaustive match failure in ppOpDecls"))))

(defparameter ANNSPECPRINTER::propertyIndex 3)

(defun ANNSPECPRINTER::ppProperty-1-1 (context x) 
  (let ((pV2 (car x))
        (pV3 (cdr x))) 
    (block 
     nil 
     (let ((pV4 (svref pV3 0))
           (pV6 (svref pV3 2))) 
       (return 
        (let ((pp (svref context 4))) 
          (let ((button1 
                 (if (ANNSPECPRINTER::markSubterm?-1 context) 
                     (PRETTYPRINT::buttonPretty 
                      (BOOLEAN-SPEC::~ 
                       (INTEGERSET::|!member| (svref context 0) pV2)) 
                      pV2 
                      (PRETTYPRINT::|!string| " ") 
                      nil) 
                     (PRETTYPRINT::|!string| "")))) 
            (let ((button2 
                   (if (ANNSPECPRINTER::markSubterm?-1 context) 
                       (PRETTYPRINT::buttonPretty 
                        (INTEGERSET::|!member| (svref context 6) pV2) 
                        pV2 
                        (PRETTYPRINT::|!string| " ") 
                        t) 
                       (PRETTYPRINT::|!string| "")))) 
              (cons 
               1 
               (PRETTYPRINT::blockFill 
                0 
                (cons 
                 (cons 0 button1) 
                 (cons 
                  (cons 0 button2) 
                  (cons 
                   (cons 
                    0 
                    (block 
                     nil 
                     (if (eq (car pV4) :|Theorem|) 
                         (return (svref pp 35)) 
                         (if (eq (car pV4) :|Axiom|) 
                             (return (svref pp 2)) 
                             (if (eq (car pV4) :|Conjecture|) 
                                 (return (svref pp 6))))) 
                     (error "Nonexhaustive match failure in ppProperty"))) 
                   (cons 
                    (cons 
                     0 
                     (funcall (svref pp 40) (STRING-SPEC::^ " " (svref pV3 1)))) 
                    (cons 
                     (cons 0 (PRETTYPRINT::|!string| " ")) 
                     (cons 
                      (cons 0 (svref pp 19)) 
                      (cons 
                       (cons 
                        0 
                        (if (LIST-SPEC::|!null| pV6) 
                            (PRETTYPRINT::|!string| "") 
                            (PRETTYPRINT::|!string| " sort"))) 
                       (cons 
                        (cons 0 (ANNSPECPRINTER::ppForallTyVars-1-1 pp pV6)) 
                        (cons 
                         (cons 0 (PRETTYPRINT::|!string| " ")) 
                         (cons 
                          (cons 
                           3 
                           (ANNSPECPRINTER::ppTerm-1-1-1 
                            context 
                            (cons 
                             (cons pV2 (cons ANNSPECPRINTER::propertyIndex nil)) 
                             '(:|Top|)) 
                            (svref pV3 3))) 
                          nil))))))))))))))))) 
     (error "Nonexhaustive match failure in ppProperty"))))

(defun ANNSPECPRINTER::ppProperty-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppProperty-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppTyVars-1-1 (pp |!tyVars|) 
  (block 
   nil 
   (if (null |!tyVars|) (return (PRETTYPRINT::|!string| ""))) 
   (return 
    (ANNTERMPRINTER::ppList-1-1-1 
     #'PRETTYPRINT::|!string| 
     (vector (svref pp 22) (svref pp 5) (svref pp 31)) 
     |!tyVars|))))

(defparameter ANNSPECPRINTER::sortIndex 0)

(defun ANNSPECPRINTER::ppSortDecl-1-1 (context x) 
  (let ((pV19 (svref x 2))
        (pV20 (svref x 3))) 
    (block 
     nil 
     (let ((pV21 (svref pV19 0))
           (pV22 (svref pV19 1))
           (pV23 (svref pV19 2))) 
       (if (consp pV21) 
           (let ((pV25 (car pV21))) 
             (if (eq (car pV25) :|Qualified|) 
                 (let ((pV27 (cdr pV25))) 
                   (let ((pV30 (car pV20))
                         (pV31 (cdr pV20))) 
                     (return 
                      (if (BOOLEAN-SPEC::~ 
                           (cl:and 
                            (string=  (svref x 0) (car pV27)) 
                            (string=  (svref x 1) (cdr pV27)))) 
                          (cons pV30 pV31) 
                          (let ((pp (svref context 4))) 
                            (labels 
                              ((ppSortName (qid) 
                                (block 
                                 nil 
                                 (if (eq (car qid) :|Qualified|) 
                                     (let ((pV3 (cdr qid))) 
                                       (return 
                                        (if (string=  
                                             (car pV3) 
                                             METASLANG::UnQualified) 
                                            (funcall (svref pp 45) (cdr pV3)) 
                                            (funcall (svref pp 46) qid))))) 
                                 (error 
                                  "Nonexhaustive match failure in ppSortDecl")))) 
                              (labels 
                                ((ppSortNames () 
                                  (block 
                                   nil 
                                   (if (consp pV21) 
                                       (if (null (cdr pV21)) 
                                           (return (ppSortName (car pV21))))) 
                                   (return 
                                    (PRETTYPRINT::ppList-1-1-1 
                                     #'ppSortName 
                                     (vector "{" "," "}") 
                                     pV21))))) 
                                (cons 
                                 (INTEGER-SPEC::|!+| pV30 1) 
                                 (block 
                                  nil 
                                  (if (null pV23) 
                                      (return 
                                       (LIST-SPEC::|!cons| 
                                        (cons 
                                         1 
                                         (PRETTYPRINT::blockFill 
                                          0 
                                          (cons 
                                           (cons 0 (svref pp 32)) 
                                           (cons 
                                            (cons 0 (PRETTYPRINT::|!string| " ")) 
                                            (cons 
                                             (cons 0 (ppSortNames)) 
                                             (cons 
                                              (cons 
                                               0 
                                               (ANNSPECPRINTER::ppTyVars-1-1 
                                                pp 
                                                pV22)) 
                                              nil)))))) 
                                        pV31))) 
                                  (return 
                                   (LIST-SPEC::foldl-1-1-1 
                                    #'(lambda (x1) 
                                       (let ((pV12 (car x1))) 
                                         (block 
                                          nil 
                                          (return 
                                           (LIST-SPEC::|!cons| 
                                            (cons 
                                             1 
                                             (PRETTYPRINT::blockFill 
                                              0 
                                              (cons 
                                               (cons 0 (svref pp 32)) 
                                               (cons 
                                                (cons 
                                                 0 
                                                 (PRETTYPRINT::|!string| " ")) 
                                                (cons 
                                                 (cons 0 (ppSortNames)) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (ANNSPECPRINTER::ppTyVars-1-1 
                                                    pp 
                                                    (car pV12))) 
                                                  (cons 
                                                   (cons 
                                                    0 
                                                    (PRETTYPRINT::|!string| " ")) 
                                                   (cons 
                                                    (cons 0 (svref pp 8)) 
                                                    (cons 
                                                     (cons 
                                                      0 
                                                      (PRETTYPRINT::|!string| 
                                                       " ")) 
                                                     (cons 
                                                      (cons 
                                                       3 
                                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                                        context 
                                                        (cons 
                                                         (cons 
                                                          pV30 
                                                          (cons 
                                                           ANNSPECPRINTER::sortIndex 
                                                           nil)) 
                                                         '(:|Top|)) 
                                                        (cdr pV12))) 
                                                      nil)))))))))) 
                                            (cdr x1))) 
                                          (error 
                                           "Nonexhaustive match failure in ppSortDecl")))) 
                                    pV31 
                                    pV23))))))))))))))) 
     (error "Nonexhaustive match failure in ppSortDecl"))))

(defun ANNSPECPRINTER::ppSortDecl-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSortDecl-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppSortDecls-1-1 (context sorts) 
  (let ((pV1 
         (STRINGMAP::foldriDouble-1-1-1 
          (ANNSPECPRINTER::ppSortDecl-1 context) 
          (cons 0 nil) 
          sorts))) 
    (block 
     nil 
     (return (cdr pV1)) 
     (error "Nonexhaustive match failure in ppSortDecls"))))

(defun LIST-SPEC::filter-1-1 (f l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV3 (car l))
                 (pV4 (cdr l))) 
             (return 
              (if (funcall f pV3) 
                  (cons pV3 (LIST-SPEC::filter-1-1 f pV4)) 
                  (LIST-SPEC::filter-1-1 f pV4)))))) 
   (error "Nonexhaustive match failure in filter")))

(defun ANNSPECPRINTER::ppSpec-1-1 (context x) 
  (block 
   nil 
   (return 
    (let ((pp (svref context 4))) 
      (let ((imports 
             (LIST-SPEC::filter-1-1 
              #'(lambda (imp) 
                 (BOOLEAN-SPEC::~ (ANNSPECPRINTER::isBuiltIn?-1 imp))) 
              (svref (svref x 0) 1)))) 
        (PRETTYPRINT::blockAll 
         0 
         (LIST-SPEC::|!++| 
          (LIST-SPEC::|!++| 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (cons 
               (cons 
                0 
                (PRETTYPRINT::blockFill 
                 0 
                 (cons 
                  (cons 0 (svref pp 33)) 
                  (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
               nil) 
              (LIST-SPEC::|!map|-1-1 
               #'(lambda (x1) 
                  (cons 
                   1 
                   (PRETTYPRINT::prettysFill 
                    (cons 
                     (svref pp 17) 
                     (cons (PRETTYPRINT::|!string| (car x1)) nil))))) 
               imports)) 
             (ANNSPECPRINTER::ppSortDecls-1-1 context (svref x 3))) 
            (ANNSPECPRINTER::ppOpDecls-1-1 context (svref x 1))) 
           (LISTUTILITIES::mapWithIndex-1-1 
            (ANNSPECPRINTER::ppProperty-1 context) 
            (svref x 2))) 
          (cons 
           (cons 0 (svref pp 12)) 
           (cons (cons 0 (PRETTYPRINT::|!string| "")) nil))))))) 
   (error "Nonexhaustive match failure in ppSpec")))

(defun ANNTERMPRINTER::htmlPrinter () 
  (let ((nameMap (cons :|Ref| STRINGMAP::empty))) 
    (let ((counter (cons :|Ref| 0))) 
      (labels 
        ((nameNumber (s) 
          (let ((pV1 (STRINGMAP::|!find| (STATE::|!!| nameMap) s))) 
            (block 
             nil 
             (if (eq (car pV1) :|None|) 
                 (return 
                  (let ((n (STATE::|!!| counter))) 
                    (let ((ns (NAT-SPEC::toString n))) 
                      (progn (STATE::|:=| 
                              nameMap 
                              (STRINGMAP::insert (STATE::|!!| nameMap) s ns)) 
                             (STATE::|:=| counter (INTEGER-SPEC::|!+| n 1)) 
                             ns)))) 
                 (if (eq (car pV1) :|Some|) (return (cdr pV1)))) 
             (error "Nonexhaustive match failure in htmlPrinter"))))) 
        (labels 
          ((ppQid (pV5) 
            (block 
             nil 
             (if (eq (car pV5) :|Qualified|) 
                 (let ((pV6 (cdr pV5))) 
                   (let ((pV8 (cdr pV6))
                         (pV7 (car pV6))) 
                     (return 
                      (if (string=  pV7 METASLANG::UnQualified) 
                          (PRETTYPRINT::lengthString 
                           (STRING-SPEC::|!length| pV8) 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ "<a href = #" (nameNumber pV8)) 
                              ">") 
                             pV8) 
                            "</a>")) 
                          (block 
                           nil 
                           (if (string=  "Nat" pV7) 
                               (return (PRETTYPRINT::|!string| pV8)) 
                               (if (string=  "Boolean" pV7) 
                                   (return (PRETTYPRINT::|!string| pV8)))) 
                           (return 
                            (PRETTYPRINT::prettysNone 
                             (cons 
                              (PRETTYPRINT::lengthString 
                               (STRING-SPEC::|!length| pV7) 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ "<a href = " pV7) 
                                  ".html>") 
                                 pV7) 
                                "</a>")) 
                              (cons 
                               (PRETTYPRINT::|!string| ".") 
                               (cons (PRETTYPRINT::|!string| pV8) nil))))))))))) 
             (error "Nonexhaustive match failure in htmlPrinter")))) 
          (labels 
            ((ppOp (s) 
              (PRETTYPRINT::lengthString 
               (STRING-SPEC::|!length| s) 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ "<a name = " (nameNumber s)) 
                  ">") 
                 s) 
                "</a>")))) 
            (vector 
             (PRETTYPRINT::lengthString 3 "<b> and </b>") 
             (PRETTYPRINT::lengthString 4 " -> ") 
             (PRETTYPRINT::lengthString 6 "<b>axiom </b>") 
             (PRETTYPRINT::lengthString 3 "<b> | </b>") 
             (PRETTYPRINT::lengthString 6 "<b>case </b>") 
             (PRETTYPRINT::|!string| ", ") 
             (PRETTYPRINT::lengthString 11 "<b>conjecture </b>") 
             (PRETTYPRINT::lengthString 3 "<b>def </b>") 
             (PRETTYPRINT::lengthString 2 "<b>=</b>") 
             (PRETTYPRINT::lengthString 5 "<b>else </b>") 
             (PRETTYPRINT::|!string| "") 
             (PRETTYPRINT::lengthString 9 "<b>end-module </b>") 
             (PRETTYPRINT::lengthString 7 "<b>endspec</b>") 
             (PRETTYPRINT::lengthString 2 "<b>=</b>") 
             (PRETTYPRINT::lengthString 2 "<b>ex</b>") 
             (PRETTYPRINT::lengthString 2 "<b>fa</b>") 
             (PRETTYPRINT::lengthString 3 "<b>if </b>") 
             (PRETTYPRINT::lengthString 7 "<b>import </b>") 
             (PRETTYPRINT::lengthString 2 "<b> in</b>") 
             (PRETTYPRINT::lengthString 11 "<b>is </b>") 
             (PRETTYPRINT::|!string| "[") 
             (PRETTYPRINT::lengthString 1 "<b>{</b>") 
             (PRETTYPRINT::|!string| "(") 
             (PRETTYPRINT::lengthString 3 "<b>fn</b> ") 
             (PRETTYPRINT::lengthString 3 "<b>let </b>") 
             (PRETTYPRINT::lengthString 7 "<b>module </b>") 
             (PRETTYPRINT::lengthString 2 "<b>of </b>") 
             (PRETTYPRINT::lengthString 2 "<b>op</b>") 
             (PRETTYPRINT::lengthString 3 "<b> * </b>") 
             (PRETTYPRINT::|!string| "]") 
             (PRETTYPRINT::lengthString 1 "<b>}</b>") 
             (PRETTYPRINT::|!string| ")") 
             (PRETTYPRINT::lengthString 4 "<b>sort</b>") 
             (PRETTYPRINT::lengthString 5 "<b>spec </b>") 
             (PRETTYPRINT::lengthString 6 "<b> then </b>") 
             (PRETTYPRINT::lengthString 8 "<b>theorem </b>") 
             (PRETTYPRINT::lengthString 1 "<b>_</b>") 
             (PRETTYPRINT::lengthString 4 "<b>where</b>") 
             #'PRETTYPRINT::|!string| 
             #'PRETTYPRINT::|!string| 
             #'PRETTYPRINT::|!string| 
             #'ppOp 
             #'ppQid 
             #'ppQid 
             #'ppQid 
             #'ppOp 
             #'ppQid)))))))

(defun ANNSPECPRINTER::htmlSpecToPretty-1 (spc) 
  (let ((pSpec 
         (ANNSPECPRINTER::ppSpec-1-1 
          (ANNSPECPRINTER::initialize (ANNTERMPRINTER::htmlPrinter) nil) 
          spc))) 
    (PRETTYPRINT::prettysAll 
     (cons 
      (PRETTYPRINT::|!string| "<html><body BGCOLOR = \"#EEFFFA\"><pre>") 
      (cons pSpec (cons (PRETTYPRINT::|!string| "</pre></body></html>") nil))))))


(defun PRETTYPRINT::toFileWithNewline (|!fileName| text newlineAndBlanks) 
  (IO-SPEC::withOpenFileForWrite 
   |!fileName| 
   #'(lambda (|!stream|) 
      (PRETTYPRINT::toStreamT 
       text 
       #'(lambda (x) 
          (block 
           nil 
           (return (PRETTYPRINT::streamWriter |!stream| (cdr (car x)))) 
           (error "Nonexhaustive match failure in toFileWithNewline"))) 
       nil 
       #'(lambda (x) 
          (block 
           nil 
           (return 
            (PRETTYPRINT::streamWriter 
             |!stream| 
             (funcall newlineAndBlanks (car x)))) 
           (error "Nonexhaustive match failure in toFileWithNewline")))))))

(defun PRETTYPRINT::toFile (|!fileName| text) 
  (PRETTYPRINT::toFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::newlineAndBlanks))

(defun ANNSPECPRINTER::htmlSpecToFile (|!fileName| spc) 
  (PRETTYPRINT::toFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::htmlSpecToPretty-1 spc))))

(defun ANNSPECPRINTER::htmlSpecToFile-1 (x) 
  (ANNSPECPRINTER::htmlSpecToFile (car x) (cdr x)))

(defun ANNSPECPRINTER::htmlSpecToPretty (x0 x1 x2 x3) 
  (ANNSPECPRINTER::htmlSpecToPretty-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::initialize-1 (x) 
  (ANNSPECPRINTER::initialize (car x) (cdr x)))

(defun ANNSPECPRINTER::initializeMark (pp indicesToDisable sosIndicesToEnable) 
  (vector 
   indicesToDisable 
   (cons :|Ref| 0) 
   t 
   (cons :|Ref| NATMAP::empty) 
   pp 
   nil 
   sosIndicesToEnable))

(defun ANNSPECPRINTER::initializeMark-1 (x) 
  (ANNSPECPRINTER::initializeMark (svref x 0) (svref x 1) (svref x 2)))

(defun ANNSPECPRINTER::isShortTuple-1 (x) 
  (ANNSPECPRINTER::isShortTuple (car x) (cdr x)))

(defun ANNSPECPRINTER::makeSpecListing-1 (pSpec) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::|!string| "\\specListing{")) 
    (cons (cons 0 pSpec) (cons (cons 0 (PRETTYPRINT::|!string| "}")) nil)))))

(defun ANNTERMPRINTER::latexString (s) 
  (if (CHAR-SPEC::isAlphaNum (STRING-SPEC::sub s 0)) 
      (PRETTYPRINT::|!string| s) 
      (let ((s 
             (STRING-SPEC::translate-1-1 
              #'(lambda (pV1) 
                 (block 
                  nil 
                  (if (eq #\^ pV1) 
                      (return "++") 
                      (if (eq #\# pV1) 
                          (return "\\#") 
                          (if (eq #\_ pV1) 
                              (return "\\_") 
                              (if (eq #\& pV1) (return "\\&"))))) 
                  (return (CHAR-SPEC::toString pV1)))) 
              s))) 
        (PRETTYPRINT::lengthString 
         (STRING-SPEC::|!length| s) 
         (STRING-SPEC::^ (STRING-SPEC::^ "\\mbox{{\\tt " s) "}}")))))

(defun ANNTERMPRINTER::latexBoolean (s) 
  (block 
   nil 
   (if (string=  "&" s) 
       (return (PRETTYPRINT::lengthString 1 "$\\&$")) 
       (if (string=  " =>" s) 
           (return (PRETTYPRINT::lengthString 1 "$\\Rightarrow$")) 
           (if (string=  "or" s) 
               (return (PRETTYPRINT::lengthString 2 "\\SWor\\ ")) 
               (if (string=  "<=>" s) 
                   (return (PRETTYPRINT::lengthString 2 "$\\Leftrightarrow$")) 
                   (if (string=  "~" s) 
                       (return (PRETTYPRINT::lengthString 1 "$\\neg$"))))))) 
   (return (PRETTYPRINT::|!string| s))))

(defun ANNTERMPRINTER::latexNat (s) 
  (block 
   nil 
   (if (string=  "*" s) 
       (return (PRETTYPRINT::lengthString 1 "$\\cdot$")) 
       (if (string=  ">" s) 
           (return (PRETTYPRINT::lengthString 1 "$>$")) 
           (if (string=  "<" s) 
               (return (PRETTYPRINT::lengthString 1 "$<$")) 
               (if (string=  ">= " s) 
                   (return (PRETTYPRINT::lengthString 1 "$\\geq$")) 
                   (if (string=  "<= " s) 
                       (return (PRETTYPRINT::lengthString 1 "$\\leq$"))))))) 
   (return (PRETTYPRINT::|!string| s))))

(defun ANNTERMPRINTER::latexInt (s) (ANNTERMPRINTER::latexNat s))

(defun ANNTERMPRINTER::ppLatexId (pV3) 
  (block 
   nil 
   (if (eq (car pV3) :|Qualified|) 
       (let ((pV4 (cdr pV3))) 
         (let ((pV6 (cdr pV4))
               (pV5 (car pV4))) 
           (return 
            (if (string=  pV5 METASLANG::UnQualified) 
                (ANNTERMPRINTER::latexString pV6) 
                (block 
                 nil 
                 (if (string=  "Nat" pV5) 
                     (return (ANNTERMPRINTER::latexNat pV6)) 
                     (if (string=  "Integer" pV5) 
                         (return (ANNTERMPRINTER::latexInt pV6)) 
                         (if (string=  "Boolean" pV5) 
                             (return (ANNTERMPRINTER::latexBoolean pV6))))) 
                 (return 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (PRETTYPRINT::|!string| (STRING-SPEC::^ pV5 ".")) 
                    (cons (ANNTERMPRINTER::latexString pV6) nil)))))))))) 
   (error "Nonexhaustive match failure in ppLatexId")))

(defparameter ANNTERMPRINTER::latexPrinter 
  (vector 
   (PRETTYPRINT::lengthString 3 "\\ \\SWand\\ ") 
   (PRETTYPRINT::lengthString 3 " $\\rightarrow$ ") 
   (PRETTYPRINT::lengthString 6 "\\SWaxiom\\ ") 
   (PRETTYPRINT::lengthString 3 " {\\tt |} ") 
   (PRETTYPRINT::lengthString 6 "\\SWcase ") 
   (PRETTYPRINT::|!string| ", ") 
   (PRETTYPRINT::lengthString 8 "{\\bf conjecture}\\ ") 
   (PRETTYPRINT::lengthString 4 "\\SWdef ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 5 "\\SWelse ") 
   (PRETTYPRINT::|!string| "") 
   (PRETTYPRINT::lengthString 9 "{\\bf end-module}\\ ") 
   (PRETTYPRINT::lengthString 8 "\\SWendspec ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 1 "\\SWex ") 
   (PRETTYPRINT::lengthString 1 "\\SWfa ") 
   (PRETTYPRINT::lengthString 3 "\\SWif ") 
   (PRETTYPRINT::lengthString 7 "\\SWimport ") 
   (PRETTYPRINT::lengthString 3 "\\ {\\bf in}") 
   (PRETTYPRINT::lengthString 2 "{\\bf is}\\ ") 
   (PRETTYPRINT::|!string| "[") 
   (PRETTYPRINT::lengthString 1 "$\\{$") 
   (PRETTYPRINT::|!string| "(") 
   (PRETTYPRINT::lengthString 3 "$\\lambda$ ") 
   (PRETTYPRINT::lengthString 4 "\\SWlet\\ ") 
   (PRETTYPRINT::lengthString 7 "{\\bf module}\\ ") 
   (PRETTYPRINT::lengthString 3 "\\SWof ") 
   (PRETTYPRINT::lengthString 2 "\\SWop ") 
   (PRETTYPRINT::lengthString 3 " $\\times$ ") 
   (PRETTYPRINT::|!string| "]") 
   (PRETTYPRINT::lengthString 1 "$\\}$") 
   (PRETTYPRINT::|!string| ")") 
   (PRETTYPRINT::lengthString 4 "\\SWsort ") 
   (PRETTYPRINT::lengthString 5 "\\SWspec\\ ") 
   (PRETTYPRINT::lengthString 6 " \\SWthen ") 
   (PRETTYPRINT::lengthString 8 "\\SWtheorem\\ ") 
   (PRETTYPRINT::lengthString 1 "{\\tt \\_}") 
   (PRETTYPRINT::lengthString 4 "{\\bf where} ") 
   #'ANNTERMPRINTER::latexString 
   #'PRETTYPRINT::|!string| 
   #'(lambda (s) 
      (PRETTYPRINT::lengthString 
       (STRING-SPEC::|!length| s) 
       (STRING-SPEC::^ (STRING-SPEC::^ "{\\tt " s) "}"))) 
   #'ANNTERMPRINTER::latexString 
   #'ANNTERMPRINTER::ppLatexId 
   #'ANNTERMPRINTER::ppLatexId 
   #'ANNTERMPRINTER::ppLatexId 
   #'ANNTERMPRINTER::latexString 
   #'ANNTERMPRINTER::ppLatexId))

(defun ANNSPECPRINTER::latexSpecToPretty-1 (spc) 
  (let ((pSpec 
         (ANNSPECPRINTER::ppSpec-1-1 
          (ANNSPECPRINTER::initialize ANNTERMPRINTER::latexPrinter nil) 
          spc))) (ANNSPECPRINTER::makeSpecListing-1 pSpec)))

(defun PRETTYPRINT::latexBlanks (n) 
  (if ( =  n 0) 
      "" 
      (STRING-SPEC::^ 
       (STRING-SPEC::^ 
        "\\SWspace{" 
        (NAT-SPEC::toString (INTEGER-SPEC::|!*| 6 n))) 
       "}")))

(defun PRETTYPRINT::latexNewlineAndBlanks (n) 
  (STRING-SPEC::^ 
   (STRING-SPEC::^ "\\\\[0.3em]" (PRETTYPRINT::newlineString)) 
   (PRETTYPRINT::latexBlanks n)))

(defun PRETTYPRINT::toLatexString (text) 
  (IO-SPEC::withOutputToString 
   #'(lambda (|!stream|) 
      (PRETTYPRINT::toStreamT 
       text 
       #'(lambda (x) 
          (block 
           nil 
           (return (PRETTYPRINT::streamWriter |!stream| (cdr (car x)))) 
           (error "Nonexhaustive match failure in toLatexString"))) 
       nil 
       #'(lambda (x) 
          (block 
           nil 
           (return 
            (PRETTYPRINT::streamWriter 
             |!stream| 
             (PRETTYPRINT::latexNewlineAndBlanks (car x)))) 
           (error "Nonexhaustive match failure in toLatexString")))))))

(defun ANNSPECPRINTER::latexSpec-1 (spc) 
  (PRETTYPRINT::toLatexString 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::latexSpecToPretty-1 spc))))

(defun ANNSPECPRINTER::latexSpec (x0 x1 x2 x3) 
  (ANNSPECPRINTER::latexSpec-1 (vector x0 x1 x2 x3)))

(defun PRETTYPRINT::toLatexFile (|!fileName| text) 
  (PRETTYPRINT::toFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::latexNewlineAndBlanks))

(defun ANNSPECPRINTER::latexSpecToFile (|!fileName| spc) 
  (PRETTYPRINT::toLatexFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::latexSpecToPretty-1 spc))))

(defun ANNSPECPRINTER::latexSpecToFile-1 (x) 
  (ANNSPECPRINTER::latexSpecToFile (car x) (cdr x)))

(defun ANNSPECPRINTER::latexSpecToPretty (x0 x1 x2 x3) 
  (ANNSPECPRINTER::latexSpecToPretty-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::makeSpecListing (x0 x1) 
  (ANNSPECPRINTER::makeSpecListing-1 (cons x0 x1)))

(defun ANNSPECPRINTER::markSubterm? (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::markSubterm?-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun INTEGER-SPEC::|!>| (x y) (INTEGER-SPEC::|!<| y x))

(defun ANNSPECPRINTER::positive? (n) (if (INTEGER-SPEC::|!>| n 0) 1 0))

(defun ANNSPECPRINTER::pdfMenu-1 (spc) 
  (let ((sorts 
         (STRINGMAP::foldriDouble-1-1-1 
          #'(lambda (x) 
             (let ((id (svref x 1))
                   (qualifier (svref x 0))) 
               (LIST-SPEC::|!cons| 
                (PRETTYPRINT::prettysNone 
                 (cons 
                  (PRETTYPRINT::|!string| 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ "  \\pdfoutline goto name {" "???") 
                       ":Sort:") 
                      (if (string=  qualifier METASLANG::UnQualified) 
                          "" 
                          (STRING-SPEC::^ qualifier "."))) 
                     id) 
                    "} {")) 
                  (cons 
                   (PRETTYPRINT::|!string| 
                    (if (string=  qualifier METASLANG::UnQualified) 
                        "" 
                        (STRING-SPEC::^ qualifier "."))) 
                   (cons 
                    (PRETTYPRINT::|!string| id) 
                    (cons (PRETTYPRINT::|!string| "}") nil))))) 
                (svref x 3)))) 
          nil 
          (svref spc 3)))) 
    (let ((ops 
           (STRINGMAP::foldriDouble-1-1-1 
            #'(lambda (x) 
               (let ((id (svref x 1))
                     (qualifier (svref x 0))) 
                 (LIST-SPEC::|!cons| 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (PRETTYPRINT::|!string| 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ "  \\pdfoutline goto name {" "???") 
                         ":Op:") 
                        (if (string=  qualifier METASLANG::UnQualified) 
                            "" 
                            (STRING-SPEC::^ qualifier "."))) 
                       id) 
                      "} {")) 
                    (cons 
                     (PRETTYPRINT::|!string| 
                      (if (string=  qualifier METASLANG::UnQualified) 
                          "" 
                          (STRING-SPEC::^ qualifier "."))) 
                     (cons 
                      (PRETTYPRINT::|!string| id) 
                      (cons (PRETTYPRINT::|!string| "}") nil))))) 
                  (svref x 3)))) 
            nil 
            (svref spc 1)))) 
      (let ((pV12 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x) 
                 (let ((pV5 (cdr x))) 
                   (block 
                    nil 
                    (let ((pV10 (car pV5))) 
                      (return 
                       (cons 
                        (INTEGER-SPEC::|!+| pV10 1) 
                        (LIST-SPEC::|!cons| 
                         (PRETTYPRINT::|!string| 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              "  \\pdfoutline goto num " 
                              (NAT-SPEC::toString pV10)) 
                             "  {") 
                            (svref (car x) 1)) 
                           "}")) 
                         (cdr pV5))))) 
                    (error "Nonexhaustive match failure in pdfMenu")))) 
              (cons 1 nil) 
              (svref spc 2)))) 
        (block 
         nil 
         (return 
          (let ((properties (LIST-SPEC::rev (cdr pV12)))) 
            (let ((sortCount (LIST-SPEC::|!length| sorts))) 
              (let ((opCount (LIST-SPEC::|!length| ops))) 
                (let ((pCount (LIST-SPEC::|!length| properties))) 
                  (let ((menuCount 
                         (INTEGER-SPEC::|!+| 
                          (INTEGER-SPEC::|!+| 
                           (ANNSPECPRINTER::positive? sortCount) 
                           (ANNSPECPRINTER::positive? opCount)) 
                          (ANNSPECPRINTER::positive? pCount)))) 
                    (PRETTYPRINT::prettysAll 
                     (LIST-SPEC::|!++| 
                      (LIST-SPEC::|!++| 
                       (LIST-SPEC::|!++| 
                        (LIST-SPEC::|!++| 
                         (LIST-SPEC::|!++| 
                          (LIST-SPEC::|!++| 
                           (cons 
                            (PRETTYPRINT::|!string| 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   "\\pdfoutline goto name {Spec:" 
                                   "???") 
                                  "} count -") 
                                 (NAT-SPEC::toString menuCount)) 
                                "  {") 
                               "???") 
                              "}")) 
                            nil) 
                           (if (INTEGER-SPEC::|!>| sortCount 0) 
                               (cons 
                                (PRETTYPRINT::|!string| 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     "\\pdfoutline goto name {Spec:" 
                                     "???") 
                                    "} count -") 
                                   (NAT-SPEC::toString sortCount)) 
                                  " {Sorts}")) 
                                nil) 
                               nil)) 
                          sorts) 
                         (if (INTEGER-SPEC::|!>| opCount 0) 
                             (cons 
                              (PRETTYPRINT::|!string| 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   "\\pdfoutline goto name {Spec:" 
                                   "???") 
                                  "} count -") 
                                 (NAT-SPEC::toString opCount)) 
                                " {Ops}")) 
                              nil) 
                             nil)) 
                        ops) 
                       (if (INTEGER-SPEC::|!>| pCount 0) 
                           (cons 
                            (PRETTYPRINT::|!string| 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 "\\pdfoutline goto name {Spec:" 
                                 "???") 
                                "} count-") 
                               (NAT-SPEC::toString pCount)) 
                              " {Properties}")) 
                            nil) 
                           nil)) 
                      properties)))))))) 
         (error "Nonexhaustive match failure in pdfMenu"))))))

(defun ANNSPECPRINTER::pdfMenu (x0 x1 x2 x3) 
  (ANNSPECPRINTER::pdfMenu-1 (vector x0 x1 x2 x3)))

(defun ANNTERMPRINTER::pdfId-1-1 (!x1 pV3) 
  (let ((nameSpace (cdr !x1))) 
    (block 
     nil 
     (if (eq (car pV3) :|Qualified|) 
         (let ((pV4 (cdr pV3))) 
           (let ((pV5 (car pV4))
                 (pV6 (cdr pV4))) 
             (return 
              (if (string=  pV5 METASLANG::UnQualified) 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (PRETTYPRINT::lengthString 
                     0 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            "\\pdfannotlink goto name {" 
                            (car !x1)) 
                           ":") 
                          nameSpace) 
                         ":") 
                        pV6) 
                       "}") 
                      (PRETTYPRINT::newlineString))) 
                    (cons 
                     (ANNTERMPRINTER::latexString pV6) 
                     (cons (PRETTYPRINT::lengthString 0 "\\pdfendlink\\ ") nil)))) 
                  (block 
                   nil 
                   (if (string=  "Nat" pV5) 
                       (return (ANNTERMPRINTER::latexNat pV6)) 
                       (if (string=  "Integer" pV5) 
                           (return (ANNTERMPRINTER::latexInt pV6)) 
                           (if (string=  "Boolean" pV5) 
                               (return (ANNTERMPRINTER::latexBoolean pV6))))) 
                   (return 
                    (PRETTYPRINT::prettysNone 
                     (cons 
                      (PRETTYPRINT::lengthString 
                       0 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ "\\pdfannotlink goto name {" pV5) 
                             ":") 
                            nameSpace) 
                           ":") 
                          pV6) 
                         "}") 
                        (PRETTYPRINT::newlineString))) 
                      (cons 
                       (PRETTYPRINT::|!string| (STRING-SPEC::^ pV5 ".")) 
                       (cons 
                        (ANNTERMPRINTER::latexString pV6) 
                        (cons 
                         (PRETTYPRINT::lengthString 0 "\\pdfendlink\\ ") 
                         nil)))))))))))) 
     (error "Nonexhaustive match failure in pdfId"))))

(defun ANNTERMPRINTER::pdfId-1 (x1) 
  #'(lambda (x2) (ANNTERMPRINTER::pdfId-1-1 x1 x2)))

(defun ANNTERMPRINTER::pdfId (x0 x1) (ANNTERMPRINTER::pdfId-1 (cons x0 x1)))

(defun ANNTERMPRINTER::pdfIdDecl-1-1 (!x1 s) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::lengthString 
     0 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       (STRING-SPEC::^ 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ (STRING-SPEC::^ "\\pdfdest name {" (car !x1)) ":") 
          (cdr !x1)) 
         ":") 
        s) 
       "} fitbh%") 
      (PRETTYPRINT::newlineString))) 
    (cons (ANNTERMPRINTER::latexString s) nil))))

(defun ANNTERMPRINTER::pdfIdDecl-1 (x1) 
  #'(lambda (x2) (ANNTERMPRINTER::pdfIdDecl-1-1 x1 x2)))

(defun ANNTERMPRINTER::pdfIdDecl (x0 x1) 
  (ANNTERMPRINTER::pdfIdDecl-1 (cons x0 x1)))

(defun ANNTERMPRINTER::pdfPrinter (counter spc) 
  (vector 
   (PRETTYPRINT::lengthString 3 "\\ \\SWand\\ ") 
   (PRETTYPRINT::lengthString 3 " $\\rightarrow$ ") 
   (PRETTYPRINT::lengthString 6 "\\SWaxiom\\ ") 
   (PRETTYPRINT::lengthString 3 " {\\tt |} ") 
   (PRETTYPRINT::lengthString 6 "\\SWcase ") 
   (PRETTYPRINT::|!string| ", ") 
   (PRETTYPRINT::lengthString 11 "{\\bf conjecture}\\ ") 
   (PRETTYPRINT::lengthString 4 "\\SWdef ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 5 "\\SWelse ") 
   (PRETTYPRINT::|!string| "") 
   (PRETTYPRINT::lengthString 9 "{\\bf end-module}\\ ") 
   (PRETTYPRINT::lengthString 8 "\\SWendspec ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 1 "\\SWex ") 
   (PRETTYPRINT::lengthString 1 "\\SWfa ") 
   (PRETTYPRINT::lengthString 3 "\\SWif ") 
   (PRETTYPRINT::lengthString 7 "\\SWimport ") 
   (PRETTYPRINT::lengthString 3 "\\ {\\bf in}") 
   (PRETTYPRINT::lengthString 2 "{\\bf is}\\ ") 
   (PRETTYPRINT::|!string| "[") 
   (PRETTYPRINT::lengthString 1 "$\\{$") 
   (PRETTYPRINT::|!string| "(") 
   (PRETTYPRINT::lengthString 3 "$\\lambda$ ") 
   (PRETTYPRINT::lengthString 4 "\\SWlet\\ ") 
   (PRETTYPRINT::lengthString 7 "{\\bf module}\\ ") 
   (PRETTYPRINT::lengthString 3 "\\SWof ") 
   (PRETTYPRINT::lengthString 2 "\\SWop ") 
   (PRETTYPRINT::lengthString 3 " $\\times$ ") 
   (PRETTYPRINT::|!string| "]") 
   (PRETTYPRINT::lengthString 1 "$\\}$") 
   (PRETTYPRINT::|!string| ")") 
   (PRETTYPRINT::lengthString 4 "\\SWsort ") 
   (PRETTYPRINT::lengthString 5 "\\SWspec\\ ") 
   (PRETTYPRINT::lengthString 6 " \\SWthen ") 
   (PRETTYPRINT::lengthString 8 "\\SWtheorem\\ ") 
   (PRETTYPRINT::lengthString 1 "{\\tt \\_}") 
   (PRETTYPRINT::lengthString 4 "{\\bf where} ") 
   #'ANNTERMPRINTER::latexString 
   #'PRETTYPRINT::|!string| 
   #'(lambda (s) 
      (progn (STATE::|:=| counter (INTEGER-SPEC::|!+| (STATE::|!!| counter) 1)) 
             (PRETTYPRINT::prettysNone 
              (cons 
               (PRETTYPRINT::lengthString 
                0 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   "\\pdfdest num " 
                   (NAT-SPEC::toString (STATE::|!!| counter))) 
                  " fitbh%") 
                 (PRETTYPRINT::newlineString))) 
               (cons 
                (PRETTYPRINT::lengthString 
                 (STRING-SPEC::|!length| s) 
                 (STRING-SPEC::^ (STRING-SPEC::^ "{\\tt " s) "}")) 
                nil))))) 
   (ANNTERMPRINTER::pdfIdDecl spc "Op") 
   (ANNTERMPRINTER::pdfId spc "Op") 
   (ANNTERMPRINTER::pdfId spc "Op") 
   (ANNTERMPRINTER::pdfId spc "Sort") 
   (ANNTERMPRINTER::pdfIdDecl spc "Sort") 
   (ANNTERMPRINTER::pdfId spc "Sort")))

(defun PRETTYPRINT::appendFileWithNewline (|!fileName| text newlineAndBlanks) 
  (labels 
    ((writeFun (|!stream|) 
      (PRETTYPRINT::toStreamT 
       text 
       #'(lambda (x) 
          (block 
           nil 
           (return (PRETTYPRINT::streamWriter |!stream| (cdr (car x)))) 
           (error "Nonexhaustive match failure in appendFileWithNewline"))) 
       nil 
       #'(lambda (x) 
          (block 
           nil 
           (return 
            (PRETTYPRINT::streamWriter 
             |!stream| 
             (funcall newlineAndBlanks (car x)))) 
           (error "Nonexhaustive match failure in appendFileWithNewline")))))) 
    (progn (IO-SPEC::withOpenFileForAppend |!fileName| #'writeFun) nil)))

(defun PRETTYPRINT::appendFile (|!fileName| text) 
  (PRETTYPRINT::appendFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::newlineAndBlanks))

(defun PRETTYPRINT::appendLatexFile (|!fileName| text) 
  (PRETTYPRINT::appendFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::latexNewlineAndBlanks))

(defun ANNSPECPRINTER::pdfOneSpecToFile (counter |!fileName| spc) 
  (let ((spc1 
         (ANNSPECPRINTER::ppSpec-1-1 
          (ANNSPECPRINTER::initialize 
           (ANNTERMPRINTER::pdfPrinter counter "???") 
           nil) 
          spc))) 
    (let ((menu (ANNSPECPRINTER::pdfMenu-1 spc))) 
      (progn (PRETTYPRINT::appendFile 
              |!fileName| 
              (PRETTYPRINT::|!format| 90 (PRETTYPRINT::|!string| "\\newpage"))) 
             (PRETTYPRINT::appendLatexFile 
              |!fileName| 
              (PRETTYPRINT::|!format| 
               90 
               (ANNSPECPRINTER::makeSpecListing-1 spc1))) 
             menu))))

(defun ANNSPECPRINTER::pdfOneSpecToFile-1 (x) 
  (ANNSPECPRINTER::pdfOneSpecToFile (svref x 0) (svref x 1) (svref x 2)))

(defun ANNSPECPRINTER::pdfPostLudeToFile (|!fileName| menues) 
  (PRETTYPRINT::appendFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 
    90 
    (PRETTYPRINT::prettysAll 
     (LIST-SPEC::|!++| 
      (LIST-SPEC::|!++| 
       (cons (PRETTYPRINT::|!string| "\\pdfendthread") nil) 
       menues) 
      (cons 
       (PRETTYPRINT::|!string| "\\pdfcatalog{ /PageMode /UseOutlines }") 
       (cons (PRETTYPRINT::|!string| "\\end{document}") nil)))))))

(defun ANNSPECPRINTER::pdfPostLudeToFile-1 (x) 
  (ANNSPECPRINTER::pdfPostLudeToFile (car x) (cdr x)))

(defun ANNSPECPRINTER::pdfPreludeToFile (|!fileName|) 
  (let ((sw2000 
         (let ((pV1 (SYSTEM-SPEC::getEnv "SPECWARE2000"))) 
           (block 
            nil 
            (if (eq (car pV1) :|None|) 
                (return "??SPECWARE2000??") 
                (if (eq (car pV1) :|Some|) (return (cdr pV1)))) 
            (error "Nonexhaustive match failure in pdfPreludeToFile"))))) 
    (PRETTYPRINT::toFile 
     |!fileName| 
     (PRETTYPRINT::|!format| 
      90 
      (PRETTYPRINT::prettysAll 
       (cons 
        (PRETTYPRINT::|!string| "\\documentclass{article}") 
        (cons 
         (PRETTYPRINT::|!string| 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ "\\input{" sw2000) 
           "/doc/pdf-sources/megamacros}")) 
         (cons 
          (PRETTYPRINT::|!string| "\\begin{document}") 
          (cons (PRETTYPRINT::|!string| "\\pdfthread num 1") nil)))))))))

(defun ANNSPECPRINTER::pdfSpecsToPretty (specs0) 
  (let ((counter (cons :|Ref| 0))) 
    (let ((specs 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (sp) 
               (ANNSPECPRINTER::ppSpec-1-1 
                (ANNSPECPRINTER::initialize 
                 (ANNTERMPRINTER::pdfPrinter counter "???") 
                 nil) 
                sp)) 
            specs0))) 
      (let ((menues (LIST-SPEC::|!map|-1-1 #'ANNSPECPRINTER::pdfMenu-1 specs0))) 
        (let ((sw2000 
               (let ((pV1 (SYSTEM-SPEC::getEnv "SPECWARE2000"))) 
                 (block 
                  nil 
                  (if (eq (car pV1) :|None|) 
                      (return "??SPECWARE2000??") 
                      (if (eq (car pV1) :|Some|) (return (cdr pV1)))) 
                  (error "Nonexhaustive match failure in pdfSpecsToPretty"))))) 
          (PRETTYPRINT::prettysAll 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (LIST-SPEC::|!++| 
               (cons 
                (PRETTYPRINT::|!string| "\\documentclass{article}") 
                (cons 
                 (PRETTYPRINT::|!string| 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ "\\input{" sw2000) 
                   "/doc/pdf-sources/megamacros}")) 
                 (cons 
                  (PRETTYPRINT::|!string| "\\begin{document}") 
                  (cons (PRETTYPRINT::|!string| "\\pdfthread num 1") nil)))) 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (s) 
                   (PRETTYPRINT::|!string| 
                    (PRETTYPRINT::toLatexString 
                     (PRETTYPRINT::|!format| 
                      90 
                      (ANNSPECPRINTER::makeSpecListing-1 s))))) 
                specs)) 
              (cons (PRETTYPRINT::|!string| "\\pdfendthread") nil)) 
             menues) 
            (cons 
             (PRETTYPRINT::|!string| "\\pdfcatalog{ /PageMode /UseOutlines }") 
             (cons (PRETTYPRINT::|!string| "\\end{document}") nil)))))))))

(defun ANNSPECPRINTER::pdfSpecsToFile (|!fileName| spcs) 
  (PRETTYPRINT::toFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::pdfSpecsToPretty spcs))))

(defun ANNSPECPRINTER::pdfSpecsToFile-1 (x) 
  (ANNSPECPRINTER::pdfSpecsToFile (car x) (cdr x)))

(defun ANNSPECPRINTER::ppForallTyVars-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppForallTyVars-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppForallTyVars
 (x0 
  x1 
  x2 
  x3 
  x4 
  x5 
  x6 
  x7 
  x8 
  x9 
  x10 
  x11 
  x12 
  x13 
  x14 
  x15 
  x16 
  x17 
  x18 
  x19 
  x20 
  x21 
  x22 
  x23 
  x24 
  x25 
  x26 
  x27 
  x28 
  x29 
  x30 
  x31 
  x32 
  x33 
  x34 
  x35 
  x36 
  x37 
  x38 
  x39 
  x40 
  x41 
  x42 
  x43 
  x44 
  x45 
  x46) 
  (ANNSPECPRINTER::ppForallTyVars-1 
   (vector 
    x0 
    x1 
    x2 
    x3 
    x4 
    x5 
    x6 
    x7 
    x8 
    x9 
    x10 
    x11 
    x12 
    x13 
    x14 
    x15 
    x16 
    x17 
    x18 
    x19 
    x20 
    x21 
    x22 
    x23 
    x24 
    x25 
    x26 
    x27 
    x28 
    x29 
    x30 
    x31 
    x32 
    x33 
    x34 
    x35 
    x36 
    x37 
    x38 
    x39 
    x40 
    x41 
    x42 
    x43 
    x44 
    x45 
    x46)))

(defun ANNSPECPRINTER::ppOpDecl (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppOpDecl-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppOpDecls-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppOpDecls-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppOpDecls (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppOpDecls-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppPattern-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppPattern-1-1-1 x1 x2 x3))))

(defun ANNSPECPRINTER::ppPattern (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppPattern-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppProperty (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppProperty-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSort-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppSort-1-1-1 x1 x2 x3))))

(defun ANNSPECPRINTER::ppSort (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSort-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSortDecl (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSortDecl-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSortDecls-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSortDecls-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppSortDecls (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSortDecls-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSortScheme-1-1-1 (context parent x) 
  (let ((pp2 (ANNSPECPRINTER::ppSort-1-1-1 context parent (cdr x)))) 
    (let ((pp1 (ANNSPECPRINTER::ppForallTyVars-1-1 (svref context 4) (car x)))) 
      (PRETTYPRINT::prettysNone (cons pp1 (cons pp2 nil))))))

(defun ANNSPECPRINTER::ppSortScheme-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (ANNSPECPRINTER::ppSortScheme-1-1-1 x1 x2 x3))))

(defun ANNSPECPRINTER::ppSortScheme (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSortScheme-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSpec-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSpec-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppSpec (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpec-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSpecAll-1-1 (context x) 
  (block 
   nil 
   (return 
    (let ((pp (svref context 4))) 
      (let ((imports 
             (LIST-SPEC::filter-1-1 
              #'(lambda (imp) 
                 (BOOLEAN-SPEC::~ (ANNSPECPRINTER::isBuiltIn?-1 imp))) 
              (svref (svref x 0) 1)))) 
        (let ((ppImports 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (x1) 
                   (cons 
                    2 
                    (PRETTYPRINT::blockFill 
                     0 
                     (cons 
                      (cons 0 (PRETTYPRINT::|!string| "import ")) 
                      (cons 
                       (cons 0 (PRETTYPRINT::|!string| (car x1))) 
                       (cons 
                        (cons 0 (PRETTYPRINT::|!string| " |-> ")) 
                        (cons 
                         (cons 
                          0 
                          (ANNSPECPRINTER::ppSpecAll-1-1 context (cdr x1))) 
                         nil))))))) 
                imports))) 
          (PRETTYPRINT::blockAll 
           0 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (LIST-SPEC::|!++| 
               (LIST-SPEC::|!++| 
                (cons 
                 (cons 
                  0 
                  (PRETTYPRINT::blockFill 
                   0 
                   (cons 
                    (cons 0 (svref pp 33)) 
                    (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
                 nil) 
                ppImports) 
               (ANNSPECPRINTER::ppSortDecls-1-1 context (svref x 3))) 
              (ANNSPECPRINTER::ppOpDecls-1-1 context (svref x 1))) 
             (LISTUTILITIES::mapWithIndex-1-1 
              (ANNSPECPRINTER::ppProperty-1 context) 
              (svref x 2))) 
            (cons 
             (cons 0 (svref pp 12)) 
             (cons (cons 0 (PRETTYPRINT::|!string| "")) nil)))))))) 
   (error "Nonexhaustive match failure in ppSpecAll")))

(defun ANNSPECPRINTER::ppSpecAll-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSpecAll-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppSpecAll (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpecAll-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSpecHidingImportedStuff-1-1-1 (context base_spec x) 
  (let ((pV45 (svref x 1))
        (pV46 (svref x 2))
        (pV47 (svref x 3))) 
    (block 
     nil 
     (let ((pV49 (svref (svref x 0) 1))) 
       (return 
        (let ((pp (svref context 4))) 
          (let ((imported_sorts 
                 (cons 
                  (svref base_spec 3) 
                  (LIST-SPEC::|!map|-1-1 
                   #'(lambda (x1) (svref (cdr x1) 3)) 
                   pV49)))) 
            (let ((imported_ops 
                   (cons 
                    (svref base_spec 1) 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x1) (svref (cdr x1) 1)) 
                     pV49)))) 
              (let ((imported_props 
                     (cons 
                      (svref base_spec 2) 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (x1) (svref (cdr x1) 2)) 
                       pV49)))) 
                (labels 
                  ((imported_sort? (qualifier id) 
                    (LIST-SPEC::|!exists|-1-1 
                     #'(lambda (sorts) 
                        (let ((pV6 (findAQualifierMap sorts qualifier id))) 
                          (block 
                           nil 
                           (if (eq (car pV6) :|Some|) (return t)) 
                           (return nil)))) 
                     imported_sorts))) 
                  (labels 
                    ((imported_op? (qualifier id) 
                      (LIST-SPEC::|!exists|-1-1 
                       #'(lambda (ops) 
                          (let ((pV10 (findAQualifierMap ops qualifier id))) 
                            (block 
                             nil 
                             (if (eq (car pV10) :|Some|) (return t)) 
                             (return nil)))) 
                       imported_ops))) 
                    (labels 
                      ((imported_prop? (|!type| name pV12 pV13) 
                        (declare (ignore pV12 pV13)) 
                        (declare (ignore pV12 pV13)) 
                        (LIST-SPEC::|!exists|-1-1 
                         #'(lambda (imp_props) 
                            (LIST-SPEC::|!exists|-1-1 
                             #'(lambda (x1) 
                                (cl:and 
                                 (slang-built-in::slang-term-equals 
                                  |!type| 
                                  (svref x1 0)) 
                                 (string=  name (svref x1 1)))) 
                             imp_props)) 
                         imported_props))) 
                      (PRETTYPRINT::blockAll 
                       0 
                       (LIST-SPEC::|!++| 
                        (LIST-SPEC::|!++| 
                         (LIST-SPEC::|!++| 
                          (LIST-SPEC::|!++| 
                           (LIST-SPEC::|!++| 
                            (cons 
                             (cons 
                              0 
                              (PRETTYPRINT::blockFill 
                               0 
                               (cons 
                                (cons 0 (svref pp 33)) 
                                (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
                             nil) 
                            (block 
                             nil 
                             (let ((pV35 (svref (svref base_spec 0) 1))) 
                               (return 
                                (let ((non_base_imports 
                                       (LIST-SPEC::filter-1-1 
                                        #'(lambda (x1) 
                                           (let ((imp_spec (cdr x1))) 
                                             (if (slang-built-in::slang-term-equals 
                                                  imp_spec 
                                                  base_spec) 
                                                 nil 
                                                 (LIST-SPEC::foldl-1-1-1 
                                                  #'(lambda (x11) 
                                                     (block 
                                                      nil 
                                                      (return 
                                                       (if (slang-built-in::slang-term-equals 
                                                            imp_spec 
                                                            (cdr (car x11))) 
                                                           nil 
                                                           (cdr x11))) 
                                                      (error 
                                                       "Nonexhaustive match failure in ppSpecHidingImportedStuff"))) 
                                                  t 
                                                  pV35)))) 
                                        pV49))) 
                                  (let ((pps 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x1) 
                                             (cons 
                                              1 
                                              (PRETTYPRINT::prettysFill 
                                               (cons 
                                                (svref pp 17) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| 
                                                  (car x1)) 
                                                 nil))))) 
                                          non_base_imports))) pps)))) 
                             (error 
                              "Nonexhaustive match failure in ppSpecHidingImportedStuff"))) 
                           (let ((pV38 
                                  (STRINGMAP::foldriDouble-1-1-1 
                                   #'(lambda (x1) 
                                      (let ((qualifier (svref x1 0))
                                            (id (svref x1 1))
                                            (index_and_pps (svref x1 3))) 
                                        (if (imported_sort? qualifier id) 
                                            index_and_pps 
                                            (ANNSPECPRINTER::ppSortDecl-1-1 
                                             context 
                                             (vector 
                                              qualifier 
                                              id 
                                              (svref x1 2) 
                                              index_and_pps))))) 
                                   (cons 0 nil) 
                                   pV47))) 
                             (block 
                              nil 
                              (return (cdr pV38)) 
                              (error 
                               "Nonexhaustive match failure in ppSpecHidingImportedStuff")))) 
                          (let ((pV41 
                                 (STRINGMAP::foldriDouble-1-1-1 
                                  #'(lambda (x1) 
                                     (let ((qualifier (svref x1 0))
                                           (id (svref x1 1))
                                           (index_and_pps (svref x1 3))) 
                                       (if (imported_op? qualifier id) 
                                           index_and_pps 
                                           (ANNSPECPRINTER::ppOpDecl-1-1 
                                            context 
                                            (vector 
                                             qualifier 
                                             id 
                                             (svref x1 2) 
                                             index_and_pps))))) 
                                  (cons 0 nil) 
                                  pV45))) 
                            (block 
                             nil 
                             (return (cdr pV41)) 
                             (error 
                              "Nonexhaustive match failure in ppSpecHidingImportedStuff")))) 
                         (let ((pps 
                                (LIST-SPEC::foldl-1-1-1 
                                 #'(lambda (x1) 
                                    (let ((prop (car x1))
                                          (pps (cdr x1))) 
                                      (if (imported_prop? 
                                           (svref prop 0) 
                                           (svref prop 1) 
                                           (svref prop 2) 
                                           (svref prop 3)) 
                                          pps 
                                          (cons 
                                           (ANNSPECPRINTER::ppProperty-1-1 
                                            context 
                                            (cons 0 prop)) 
                                           pps)))) 
                                 nil 
                                 pV46))) pps)) 
                        (cons 
                         (cons 0 (svref pp 12)) 
                         (cons (cons 0 (PRETTYPRINT::|!string| "")) nil))))))))))))) 
     (error "Nonexhaustive match failure in ppSpecHidingImportedStuff"))))

(defun ANNSPECPRINTER::ppSpecHidingImportedStuff-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (ANNSPECPRINTER::ppSpecHidingImportedStuff-1-1-1 x1 x2 x3))))


(defun ANNSPECPRINTER::ppSpecHidingImportedStuff (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpecHidingImportedStuff-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppSpecR-1-1 (context x) 
  (block 
   nil 
   (return 
    (let ((pp (svref context 4))) 
      (let ((imports 
             (LIST-SPEC::filter-1-1 
              #'(lambda (imp) 
                 (BOOLEAN-SPEC::~ (ANNSPECPRINTER::isBuiltIn?-1 imp))) 
              (svref (svref x 0) 1)))) 
        (PRETTYPRINT::blockAll 
         0 
         (LIST-SPEC::|!++| 
          (LIST-SPEC::|!++| 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (cons 
               (cons 
                0 
                (PRETTYPRINT::blockFill 
                 0 
                 (cons 
                  (cons 0 (svref pp 33)) 
                  (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
               nil) 
              (LIST-SPEC::|!map|-1-1 
               #'(lambda (x1) 
                  (cons 
                   1 
                   (PRETTYPRINT::prettysFill 
                    (cons 
                     (svref pp 17) 
                     (cons (PRETTYPRINT::|!string| (car x1)) nil))))) 
               imports)) 
             (ANNSPECPRINTER::ppSortDecls-1-1 context (svref x 3))) 
            (ANNSPECPRINTER::ppOpDecls-1-1 context (svref x 1))) 
           (LISTUTILITIES::mapWithIndex-1-1 
            (ANNSPECPRINTER::ppProperty-1 context) 
            (svref x 2))) 
          (cons 
           (cons 0 (svref pp 12)) 
           (cons (cons 0 (PRETTYPRINT::|!string| "")) nil))))))) 
   (error "Nonexhaustive match failure in ppSpecR")))

(defun ANNSPECPRINTER::ppSpecR-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSpecR-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppSpecR (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpecR-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppTerm-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppTerm-1-1-1 x1 x2 x3))))

(defun ANNSPECPRINTER::ppTerm (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppTerm-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppTerm1-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppTerm1-1-1-1 x1 x2 x3))))

(defun ANNSPECPRINTER::ppTerm1 (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppTerm1-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppTermScheme-1-1-1 (context parent x) 
  (let ((pp1 (ANNSPECPRINTER::ppForallTyVars-1-1 (svref context 4) (car x)))) 
    (let ((pp2 (ANNSPECPRINTER::ppTerm-1-1-1 context parent (cdr x)))) 
      (PRETTYPRINT::prettysNone (cons pp1 (cons pp2 nil))))))

(defun ANNSPECPRINTER::ppTermScheme-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (ANNSPECPRINTER::ppTermScheme-1-1-1 x1 x2 x3))))

(defun ANNSPECPRINTER::ppTermScheme (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppTermScheme-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::ppTyVars-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppTyVars-1-1 x1 x2)))

(defun ANNSPECPRINTER::ppTyVars
 (x0 
  x1 
  x2 
  x3 
  x4 
  x5 
  x6 
  x7 
  x8 
  x9 
  x10 
  x11 
  x12 
  x13 
  x14 
  x15 
  x16 
  x17 
  x18 
  x19 
  x20 
  x21 
  x22 
  x23 
  x24 
  x25 
  x26 
  x27 
  x28 
  x29 
  x30 
  x31 
  x32 
  x33 
  x34 
  x35 
  x36 
  x37 
  x38 
  x39 
  x40 
  x41 
  x42 
  x43 
  x44 
  x45 
  x46) 
  (ANNSPECPRINTER::ppTyVars-1 
   (vector 
    x0 
    x1 
    x2 
    x3 
    x4 
    x5 
    x6 
    x7 
    x8 
    x9 
    x10 
    x11 
    x12 
    x13 
    x14 
    x15 
    x16 
    x17 
    x18 
    x19 
    x20 
    x21 
    x22 
    x23 
    x24 
    x25 
    x26 
    x27 
    x28 
    x29 
    x30 
    x31 
    x32 
    x33 
    x34 
    x35 
    x36 
    x37 
    x38 
    x39 
    x40 
    x41 
    x42 
    x43 
    x44 
    x45 
    x46)))

(defun ANNSPECPRINTER::printLambda-1 (x) 
  (ANNSPECPRINTER::printLambda (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun PRETTYPRINT::shift (id pos1 stack) 
  (LIST-SPEC::|!cons| (vector id pos1 0 nil nil) stack))

(defun PRETTYPRINT::toStream (text cont base newlineAndBlanks) 
  (labels 
    ((|!loop| (text indent) 
      (block 
       nil 
       (if (null text) 
           (return 
            (funcall cont (cons (cons indent (PRETTYPRINT::blanks indent)) base))) 
           (if (consp text) 
               (let ((pV6 (cdr text))
                     (pV5 (car text))) 
                 (let ((pV8 (cdr pV5))) 
                   (progn (if (consp pV8) 
                              (if ( =  0 (car (car pV8))) 
                                  (if (null (cdr pV8)) 
                                      (return 
                                       (let ((head (|!loop| pV6 0))) 
                                         (let ((head 
                                                (funcall newlineAndBlanks 
                                                         (cons indent head)))) 
                                           head)))))) 
                          (return 
                           (let ((head (|!loop| pV6 (car pV5)))) 
                             (let ((head (LIST-SPEC::foldr-1-1-1 cont head pV8))) 
                               (let ((head 
                                      (funcall newlineAndBlanks 
                                               (cons indent head)))) head))))))))) 
       (error "Nonexhaustive match failure in toStream")))) 
    (block 
     nil 
     (if (null text) 
         (return base) 
         (if (consp text) 
             (let ((pV16 (car text))) 
               (return 
                (let ((head (|!loop| (cdr text) (car pV16)))) 
                  (let ((head (LIST-SPEC::foldr-1-1-1 cont head (cdr pV16)))) 
                    head)))))) 
     (error "Nonexhaustive match failure in toStream"))))

(defun PRETTYPRINT::insertElem (pV1 pV2) 
  (block 
   nil 
   (return 
    (vector 
     (svref pV2 0) 
     (svref pV2 1) 
     (svref pV2 2) 
     (svref pV2 3) 
     (LIST-SPEC::|!cons| pV1 (svref pV2 4)))) 
   (error "Nonexhaustive match failure in insertElem")))

(defun PRETTYPRINT::|!reduce| (pos2 stack) 
  (block 
   nil 
   (if (consp stack) 
       (let ((pV19 (cdr stack))
             (pV18 (car stack))) 
         (let ((pV24 (svref pV18 4))
               (pV21 (svref pV18 1))
               (pV20 (svref pV18 0))) 
           (if (consp pV19) 
               (let ((pV27 (cdr pV19))
                     (pV26 (car pV19))) 
                 (return 
                  (let ((elem (vector pV20 pV21 pos2 t pV24))) 
                    (block 
                     nil 
                     (return 
                      (if (BOOLEAN-SPEC::~ (svref pV26 3)) 
                          (LIST-SPEC::|!cons| 
                           (PRETTYPRINT::insertElem elem pV26) 
                           pV27) 
                          (LIST-SPEC::|!cons| 
                           elem 
                           (LIST-SPEC::|!cons| pV26 pV27)))) 
                     (error "Nonexhaustive match failure in reduce"))))) 
               (if (null pV19) 
                   (return (cons (vector pV20 pV21 pos2 t pV24) nil))))))) 
   (return stack)))

(defun PRETTYPRINT::toFileWithPathIndexing (|!fileName| text) 
  (labels 
    ((appendString (pV3 pV4 pV5 pV6) 
      (block 
       nil 
       (let ((pV10 (svref pV6 3))
             (pV8 (svref pV6 1))) 
         (return 
          (if (svref pV6 2) 
              (if (svref pV6 0) 
                  (vector nil pV8 nil pV10) 
                  (vector nil 0 nil (PRETTYPRINT::shift pV5 pV8 pV10))) 
              (block 
               nil 
               (if (string=  "%(" pV5) 
                   (return (vector nil pV8 t pV10)) 
                   (if (string=  "%)" pV5) 
                       (return 
                        (vector nil 0 nil (PRETTYPRINT::|!reduce| pV8 pV10))) 
                       (if (string=  "%[" pV5) (return (vector t pV8 t pV10))))) 
               (return 
                (progn (PRETTYPRINT::streamWriter pV3 pV5) 
                       (vector nil (INTEGER-SPEC::|!+| pV8 pV4) nil pV10))))))) 
       (error "Nonexhaustive match failure in toFileWithPathIndexing")))) 
    (labels 
      ((writeFun (|!stream|) 
        (PRETTYPRINT::toStream 
         text 
         #'(lambda (x) 
            (let ((pV11 (car x))) 
              (block 
               nil 
               (return (appendString |!stream| (car pV11) (cdr pV11) (cdr x))) 
               (error "Nonexhaustive match failure in toFileWithPathIndexing")))) 
         (vector nil 0 nil nil) 
         #'(lambda (x) 
            (let ((pV16 (cdr x))
                  (pV15 (car x))) 
              (block 
               nil 
               (return 
                (progn (PRETTYPRINT::streamWriter 
                        |!stream| 
                        (PRETTYPRINT::newlineAndBlanks pV15)) 
                       (vector 
                        (svref pV16 0) 
                        (INTEGER-SPEC::|!+| 
                         (INTEGER-SPEC::|!+| (svref pV16 1) pV15) 
                         1) 
                        (svref pV16 2) 
                        (svref pV16 3)))) 
               (error "Nonexhaustive match failure in toFileWithPathIndexing"))))))) 
      (let ((pV21 (IO-SPEC::withOpenFileForWrite |!fileName| #'writeFun))) 
        (block 
         nil 
         (return (svref pV21 3)) 
         (error "Nonexhaustive match failure in toFileWithPathIndexing"))))))

(defun PRETTYPRINT::treeToString (id startPos endPos pV1 subtrees) 
  (declare (ignore pV1)) 
  (STRING-SPEC::^ 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       (STRING-SPEC::^ 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ (STRING-SPEC::^ "(" id) " ") 
         (NAT-SPEC::toString startPos)) 
        (PRETTYPRINT::treesToString subtrees)) 
       " ") 
      id) 
     " ") 
    (NAT-SPEC::toString endPos)) 
   ")"))

(defun PRETTYPRINT::treeToString-1 (x) 
  (PRETTYPRINT::treeToString 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun PRETTYPRINT::treesToString (trees) 
  (block 
   nil 
   (if (null trees) 
       (return "") 
       (if (consp trees) 
           (return 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ (PRETTYPRINT::treesToString (cdr trees)) " ") 
             (PRETTYPRINT::treeToString-1 (car trees)))))) 
   (error "Nonexhaustive match failure in treesToString")))

(defun PRETTYPRINT::toPathFiles (|!fileName| pathFileName text) 
  (let ((trees (PRETTYPRINT::toFileWithPathIndexing |!fileName| text))) 
    (labels 
      ((writeFun (|!stream|) 
        (PRETTYPRINT::streamWriter 
         |!stream| 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           "(mspe-add-extents '(" 
           (PRETTYPRINT::treesToString trees)) 
          "))")))) 
      (progn (IO-SPEC::withOpenFileForWrite pathFileName #'writeFun) nil))))

(defun ANNSPECPRINTER::printMarkedSpecToFile
 (|!fileName| pathFileName indicesToDisable sosIndicesToEnable spc) 
  (let ((context 
         (ANNSPECPRINTER::initializeMark 
          ANNTERMPRINTER::asciiPrinter 
          indicesToDisable 
          sosIndicesToEnable))) 
    (let ((specToPretty (ANNSPECPRINTER::ppSpec-1 context))) 
      (progn (PRETTYPRINT::toPathFiles 
              |!fileName| 
              pathFileName 
              (PRETTYPRINT::|!format| 90 (funcall specToPretty spc))) 
             (STATE::|!!| (svref context 3))))))

(defun ANNSPECPRINTER::printMarkedSpecToFile-1 (x) 
  (ANNSPECPRINTER::printMarkedSpecToFile 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun STRINGUTILITIES::tokens-1-1 (p |!string|) 
  (let ((chars (STRING-SPEC::explode |!string|))) 
    (labels 
      ((consChars (chars strings) 
        (if (LIST-SPEC::|!null| chars) 
            strings 
            (LIST-SPEC::|!cons| 
             (STRING-SPEC::implode (LIST-SPEC::rev chars)) 
             strings)))) 
      (labels 
        ((|!loop| (chars chars_ strings) 
          (block 
           nil 
           (if (null chars) 
               (return (LIST-SPEC::rev (consChars chars_ strings))) 
               (if (consp chars) 
                   (let ((pV3 (car chars))
                         (pV4 (cdr chars))) 
                     (return 
                      (if (funcall p pV3) 
                          (|!loop| pV4 nil (consChars chars_ strings)) 
                          (|!loop| pV4 (LIST-SPEC::|!cons| pV3 chars_) strings)))))) 
           (error "Nonexhaustive match failure in tokens")))) 
        (|!loop| chars nil nil)))))

(defun PRETTYPRINT::toStringWithPathIndexing (text) 
  (labels 
    ((appendString (pV20 pV21 pV22) 
      (block 
       nil 
       (let ((pV27 (svref pV22 4))
             (pV26 (svref pV22 3))
             (pV24 (svref pV22 1))) 
         (return 
          (if (svref pV22 2) 
              (if (svref pV22 0) 
                  (let ((pV7 
                         (STRINGUTILITIES::tokens-1-1 
                          #'(lambda (pV2) 
                             (block 
                              nil 
                              (if (eq #\: pV2) (return t)) 
                              (return nil))) 
                          pV21))) 
                    (block 
                     nil 
                     (if (consp pV7) 
                         (let ((pV10 (cdr pV7))) 
                           (if (consp pV10) 
                               (let ((pV13 (cdr pV10))) 
                                 (if (consp pV13) 
                                     (if (null (cdr pV13)) 
                                         (return 
                                          (let ((enabled 
                                                 (block 
                                                  nil 
                                                  (if (string=  "true" (car pV7)) 
                                                      (return "t")) 
                                                  (return "nil")))) 
                                            (let ((sos? 
                                                   (block 
                                                    nil 
                                                    (if (string=  
                                                         "true" 
                                                         (car pV13)) 
                                                        (return "t")) 
                                                    (return "nil")))) 
                                              (vector 
                                               nil 
                                               pV24 
                                               nil 
                                               pV26 
                                               (STRING-SPEC::^ 
                                                (STRING-SPEC::^ 
                                                 (STRING-SPEC::^ 
                                                  (STRING-SPEC::^ 
                                                   (STRING-SPEC::^ 
                                                    (STRING-SPEC::^ 
                                                     (STRING-SPEC::^ 
                                                      (STRING-SPEC::^ 
                                                       pV27 
                                                       "\\\") (theorem-widget ") 
                                                      (car pV10)) 
                                                     " ") 
                                                    enabled) 
                                                   " ") 
                                                  sos?) 
                                                 ")") 
                                                "(widget-insert \\\""))))))))))) 
                     (error 
                      "Nonexhaustive match failure in toStringWithPathIndexing"))) 
                  (vector nil 0 nil (PRETTYPRINT::shift pV21 pV24 pV26) pV27)) 
              (block 
               nil 
               (if (string=  "%(" pV21) 
                   (return (vector nil pV24 t pV26 pV27)) 
                   (if (string=  "%)" pV21) 
                       (return 
                        (vector 
                         nil 
                         0 
                         nil 
                         (PRETTYPRINT::|!reduce| pV24 pV26) 
                         pV27)) 
                       (if (string=  "%[" pV21) 
                           (return 
                            (vector t (INTEGER-SPEC::|!+| pV24 1) t pV26 pV27))))) 
               (return 
                (vector 
                 nil 
                 (INTEGER-SPEC::|!+| pV24 pV20) 
                 nil 
                 pV26 
                 (STRING-SPEC::^ 
                  pV27 
                  (STRING-SPEC::translate-1-1 
                   #'(lambda (pV18) 
                      (block 
                       nil 
                       (if (eq #\" pV18) (return "\\\\\\\"")) 
                       (return (CHAR-SPEC::toString pV18)))) 
                   pV21)))))))) 
       (error "Nonexhaustive match failure in toStringWithPathIndexing")))) 
    (let ((pV39 
           (PRETTYPRINT::toStream 
            text 
            #'(lambda (x) 
               (let ((pV28 (car x))) 
                 (block 
                  nil 
                  (return (appendString (car pV28) (cdr pV28) (cdr x))) 
                  (error 
                   "Nonexhaustive match failure in toStringWithPathIndexing")))) 
            (vector nil 0 nil nil "") 
            #'(lambda (x) 
               (let ((pV33 (cdr x))
                     (pV32 (car x))) 
                 (block 
                  nil 
                  (return 
                   (vector 
                    (svref pV33 0) 
                    (INTEGER-SPEC::|!+| 
                     (INTEGER-SPEC::|!+| (svref pV33 1) pV32) 
                     1) 
                    (svref pV33 2) 
                    (svref pV33 3) 
                    (STRING-SPEC::^ 
                     (svref pV33 4) 
                     (PRETTYPRINT::newlineAndBlanks pV32)))) 
                  (error 
                   "Nonexhaustive match failure in toStringWithPathIndexing"))))))) 
      (block 
       nil 
       (return 
        (let ((tree 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 "(mspe-add-extents '(" 
                 (PRETTYPRINT::treesToString (svref pV39 3))) 
                "))"))) 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              "(insert-mouse-sensitive-spec \"(progn (let ((pt (point))) (widget-insert \\\"" 
              (svref pV39 4)) 
             " \\\") (goto-char pt)) ") 
            tree) 
           ")\")"))) 
       (error "Nonexhaustive match failure in toStringWithPathIndexing")))))

(defun ANNSPECPRINTER::printMarkedSpecToString
 (indicesToDisable sosIndicesToEnable spc) 
  (let ((context 
         (ANNSPECPRINTER::initializeMark 
          ANNTERMPRINTER::asciiPrinter 
          indicesToDisable 
          sosIndicesToEnable))) 
    (let ((specToPretty (ANNSPECPRINTER::ppSpec-1 context))) 
      (let ((spcAndMarking 
             (PRETTYPRINT::toStringWithPathIndexing 
              (PRETTYPRINT::|!format| 90 (funcall specToPretty spc))))) 
        (cons spcAndMarking (STATE::|!!| (svref context 3)))))))

(defun ANNSPECPRINTER::printMarkedSpecToString-1 (x) 
  (ANNSPECPRINTER::printMarkedSpecToString (svref x 0) (svref x 1) (svref x 2)))

(defun ANNSPECPRINTER::printOp-1 (x) 
  (ANNSPECPRINTER::printOp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun ANNSPECPRINTER::printPattern (pat) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppPattern-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil t) 
     pat))))

(defun ANNSPECPRINTER::printSort? (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::printSort?-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun ANNSPECPRINTER::printSortScheme-1 (scheme) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSortScheme-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     scheme))))

(defun ANNSPECPRINTER::printSortScheme (x0 x1) 
  (ANNSPECPRINTER::printSortScheme-1 (cons x0 x1)))

(defun PRETTYPRINT::toTerminal (text) 
  (PRETTYPRINT::toStreamT 
   text 
   #'(lambda (x) 
      (block 
       nil 
       (return (STRING-SPEC::toScreen (cdr (car x)))) 
       (error "Nonexhaustive match failure in toTerminal"))) 
   nil 
   #'(lambda (x) 
      (block 
       nil 
       (return (STRING-SPEC::toScreen (PRETTYPRINT::newlineAndBlanks (car x)))) 
       (error "Nonexhaustive match failure in toTerminal")))))

(defun ANNSPECPRINTER::printSortToTerminal (srt) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSort-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     srt))))

(defun ANNSPECPRINTER::specToPretty-1 (spc) 
  (ANNSPECPRINTER::ppSpecR-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   spc))

(defun ANNSPECPRINTER::printSpec-1 (spc) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 80 (ANNSPECPRINTER::specToPretty-1 spc))))

(defun ANNSPECPRINTER::printSpec (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpec-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::printSpecToFile (|!fileName| spc) 
  (PRETTYPRINT::toFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::specToPretty-1 spc))))

(defun ANNSPECPRINTER::printSpecToFile-1 (x) 
  (ANNSPECPRINTER::printSpecToFile (car x) (cdr x)))

(defun ANNSPECPRINTER::printSpecToTerminal-1 (spc) 
  (progn (PRETTYPRINT::toTerminal 
          (PRETTYPRINT::|!format| 80 (ANNSPECPRINTER::specToPretty-1 spc))) 
         (STRING-SPEC::writeLine "")))

(defun ANNSPECPRINTER::printSpecToTerminal (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpecToTerminal-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::specToPrettyVerbose-1 (spc) 
  (ANNSPECPRINTER::ppSpecAll-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   spc))

(defun ANNSPECPRINTER::printSpecVerbose-1 (spc) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 80 (ANNSPECPRINTER::specToPrettyVerbose-1 spc))))

(defun ANNSPECPRINTER::printSpecVerbose (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpecVerbose-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::printSpecWithSortsToTerminal-1 (spc) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSpec-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter t) 
     spc))))

(defun ANNSPECPRINTER::printSpecWithSortsToTerminal (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpecWithSortsToTerminal-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::printTerm (term) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppTerm-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     term))))

(defun ANNSPECPRINTER::printTermScheme-1 (scheme) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppTermScheme-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     scheme))))

(defun ANNSPECPRINTER::printTermScheme (x0 x1) 
  (ANNSPECPRINTER::printTermScheme-1 (cons x0 x1)))

(defun ANNSPECPRINTER::printTermToTerminal (term) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppTerm-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     term))))

(defun ANNSPECPRINTER::printTermWithSorts (term) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppTerm-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter t) 
     (cons nil '(:|Top|)) 
     term))))

(defun ANNSPECPRINTER::specToPretty (x0 x1 x2 x3) 
  (ANNSPECPRINTER::specToPretty-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::specToPrettyR-1 (spc) 
  (ANNSPECPRINTER::ppSpecR-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   spc))

(defun ANNSPECPRINTER::specToPrettyR (x0 x1 x2 x3) 
  (ANNSPECPRINTER::specToPrettyR-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::specToPrettyVerbose (x0 x1 x2 x3) 
  (ANNSPECPRINTER::specToPrettyVerbose-1 (vector x0 x1 x2 x3)))

(defun ANNSPECPRINTER::termToPretty (term) 
  (ANNSPECPRINTER::ppTerm-1-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   (cons nil '(:|Top|)) 
   term))

(defun ANNSPECPRINTER::toString (x) (PRETTYPRINT::toString x))

(defun ANNTERMPRINTER::htmlPrinter-1 (ignore) 
  (declare (ignore ignore)) 
  (ANNTERMPRINTER::htmlPrinter))

(defun ANNTERMPRINTER::pdfPrinter-1 (x) 
  (ANNTERMPRINTER::pdfPrinter (car x) (cdr x)))

(defun ANNTERMPRINTER::ppList (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNTERMPRINTER::ppList-1-1-1 x1 x2 x3))))

(defun ANNTERMPRINTER::ppListPath (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) (ANNTERMPRINTER::ppListPath-1-1-1-1 x1 x2 x3 x4)))))

(defun SPLAYSET::insert-1-1 (comp x) 
  (let ((pV16 (car x))
        (pV17 (cdr x))) 
    (block 
     nil 
     (let ((pV18 (car pV17))) 
       (return 
        (let ((x1 (SPLAYTREE::splay (SPLAYSET::compf comp pV16) (cdr pV17)))) 
          (let ((pV2 (car x1))
                (pV3 (cdr x1))) 
            (block 
             nil 
             (if (eq (car pV2) :|Equal|) 
                 (if (eq (car pV3) :|SplayObj|) 
                     (let ((pV12 (cdr pV3))) 
                       (return 
                        (cons 
                         pV18 
                         (cons 
                          :|SplayObj| 
                          (vector (svref pV12 0) (svref pV12 1) pV16)))))) 
                 (if (eq (car pV2) :|Less|) 
                     (if (eq (car pV3) :|SplayObj|) 
                         (let ((pV8 (cdr pV3))) 
                           (return 
                            (cons 
                             (INTEGER-SPEC::|!+| pV18 1) 
                             (cons 
                              :|SplayObj| 
                              (vector 
                               (cons 
                                :|SplayObj| 
                                (vector 
                                 (svref pV8 0) 
                                 '(:|SplayNil|) 
                                 (svref pV8 2))) 
                               (svref pV8 1) 
                               pV16)))))) 
                     (if (eq (car pV2) :|Greater|) 
                         (if (eq (car pV3) :|SplayObj|) 
                             (let ((pV4 (cdr pV3))) 
                               (return 
                                (cons 
                                 (INTEGER-SPEC::|!+| pV18 1) 
                                 (cons 
                                  :|SplayObj| 
                                  (vector 
                                   (svref pV4 0) 
                                   (cons 
                                    :|SplayObj| 
                                    (vector 
                                     '(:|SplayNil|) 
                                     (svref pV4 1) 
                                     (svref pV4 2))) 
                                   pV16))))))))) 
             (if (eq (car pV3) :|SplayNil|) 
                 (return 
                  (cons 
                   1 
                   (cons :|SplayObj| (vector '(:|SplayNil|) '(:|SplayNil|) pV16))))) 
             (error "Nonexhaustive match failure in insert")))))) 
     (error "Nonexhaustive match failure in insert"))))

(defun SPLAYSET::singleton (comp v) 
  (cons 
   :|SET| 
   (vector 
    comp 
    1 
    (cons :|Ref| (cons :|SplayObj| (vector '(:|SplayNil|) '(:|SplayNil|) v))))))

(defun SPLAYSET::add (|!set| v) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return (SPLAYSET::singleton (cdr |!set|) v)) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV5 (cdr |!set|))) 
             (let ((pV7 (svref pV5 0))) 
               (return 
                (let ((pV1 
                       (SPLAYSET::insert-1-1 
                        pV7 
                        (cons v (cons (svref pV5 1) (STATE::|!!| (svref pV5 2))))))) 
                  (block 
                   nil 
                   (return 
                    (cons :|SET| (vector pV7 (car pV1) (cons :|Ref| (cdr pV1))))) 
                   (error "Nonexhaustive match failure in add")))))))) 
   (error "Nonexhaustive match failure in add")))

(defun STRINGSET::add (x0 x) (SPLAYSET::add x0 x))

(defun STRINGSET::|!member| (x0 x) (SPLAYSET::|!member| x0 x))

(defun STRINGUTILITIES::freshName (name0 names) 
  (labels 
    ((|!loop| (counter name) 
      (if (STRINGSET::|!member| names name) 
          (|!loop| 
           (INTEGER-SPEC::|!+| counter 1) 
           (STRING-SPEC::^ name0 (NAT-SPEC::toString counter))) 
          name))) (|!loop| 0 name0)))

(defun ARITYNORMALIZE::freshName (name0 names) 
  (let ((name1 (STRINGUTILITIES::freshName name0 names))) 
    (cons name1 (STRINGSET::add names name1))))

(defun ARITYNORMALIZE::freshNames (name0 xs names) 
  (let ((pV9 
         (LIST-SPEC::foldr-1-1-1 
          #'(lambda (x) 
             (let ((pV6 (cdr x))) 
               (block 
                nil 
                (return 
                 (let ((pV2 (ARITYNORMALIZE::freshName name0 (cdr pV6)))) 
                   (block 
                    nil 
                    (return 
                     (cons (LIST-SPEC::|!cons| (car pV2) (car pV6)) (cdr pV2))) 
                    (error "Nonexhaustive match failure in freshNames")))) 
                (error "Nonexhaustive match failure in freshNames")))) 
          (cons nil names) 
          xs))) 
    (block 
     nil 
     (return (cons (car pV9) (cdr pV9))) 
     (error "Nonexhaustive match failure in freshNames"))))

(defun LISTPAIR::|!map|-1-1 (f x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (cons 
               (funcall f (cons (car l) (car r))) 
               (LISTPAIR::|!map|-1-1 f (cons (cdr l) (cdr r))))))) 
     (return nil))))

(defparameter POSITION-SPEC::noPos (cons :|Internal| "no position"))

(defun LISTPAIR::zip (l r) 
  (block 
   nil 
   (if (consp l) 
       (if (consp r) 
           (return (cons (cons (car l) (car r)) (LISTPAIR::zip (cdr l) (cdr r)))))) 
   (return nil)))

(defun SPECENVIRONMENT::substSort (|!S| srt) 
  (labels 
    ((|!find| (name |!S| a) 
      (block 
       nil 
       (if (null |!S|) 
           (return (cons :|TyVar| (cons name a))) 
           (if (consp |!S|) 
               (let ((pV3 (car |!S|))) 
                 (return 
                  (if (string=  name (car pV3)) 
                      (cdr pV3) 
                      (|!find| name (cdr |!S|) a)))))) 
       (error "Nonexhaustive match failure in substSort")))) 
    (labels 
      ((substRec (srt) 
        (block 
         nil 
         (if (eq (car srt) :|Base|) 
             (let ((pV16 (cdr srt))) 
               (return 
                (cons 
                 :|Base| 
                 (vector 
                  (svref pV16 0) 
                  (LIST-SPEC::|!map|-1-1 #'substRec (svref pV16 1)) 
                  (svref pV16 2))))) 
             (if (eq (car srt) :|Arrow|) 
                 (let ((pV15 (cdr srt))) 
                   (return 
                    (cons 
                     :|Arrow| 
                     (vector 
                      (substRec (svref pV15 0)) 
                      (substRec (svref pV15 1)) 
                      (svref pV15 2))))) 
                 (if (eq (car srt) :|Product|) 
                     (let ((pV14 (cdr srt))) 
                       (return 
                        (cons 
                         :|Product| 
                         (cons 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x) (cons (car x) (substRec (cdr x)))) 
                           (car pV14)) 
                          (cdr pV14))))) 
                     (if (eq (car srt) :|CoProduct|) 
                         (let ((pV13 (cdr srt))) 
                           (return 
                            (cons 
                             :|CoProduct| 
                             (cons 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x) 
                                  (let ((sopt (cdr x))) 
                                    (cons 
                                     (car x) 
                                     (block 
                                      nil 
                                      (if (eq (car sopt) :|None|) 
                                          (return '(:|None|)) 
                                          (if (eq (car sopt) :|Some|) 
                                              (return 
                                               (cons 
                                                :|Some| 
                                                (substRec (cdr sopt)))))) 
                                      (error 
                                       "Nonexhaustive match failure in substSort"))))) 
                               (car pV13)) 
                              (cdr pV13))))) 
                         (if (eq (car srt) :|Quotient|) 
                             (let ((pV12 (cdr srt))) 
                               (return 
                                (cons 
                                 :|Quotient| 
                                 (vector 
                                  (substRec (svref pV12 0)) 
                                  (svref pV12 1) 
                                  (svref pV12 2))))) 
                             (if (eq (car srt) :|Subsort|) 
                                 (let ((pV11 (cdr srt))) 
                                   (return 
                                    (cons 
                                     :|Subsort| 
                                     (vector 
                                      (substRec (svref pV11 0)) 
                                      (svref pV11 1) 
                                      (svref pV11 2))))) 
                                 (if (eq (car srt) :|TyVar|) 
                                     (let ((pV10 (cdr srt))) 
                                       (return 
                                        (|!find| (car pV10) |!S| (cdr pV10))))))))))) 
         (error "Nonexhaustive match failure in substSort")))) (substRec srt))))

(defun STANDARDSPEC::findTheSort (pV1 pV2) 
  (block 
   nil 
   (if (eq (car pV2) :|Qualified|) 
       (let ((pV3 (cdr pV2))) 
         (return (findAQualifierMap (svref pV1 3) (car pV3) (cdr pV3))))) 
   (error "Nonexhaustive match failure in findTheSort")))

(defun SPECENVIRONMENT::unfoldBaseV (sp srt verbose) 
  (block 
   nil 
   (if (eq (car srt) :|Base|) 
       (let ((pV18 (cdr srt))) 
         (return 
          (let ((pV6 (STANDARDSPEC::findTheSort sp (svref pV18 0)))) 
            (block 
             nil 
             (if (eq (car pV6) :|None|) 
                 (return srt) 
                 (if (eq (car pV6) :|Some|) 
                     (let ((pV10 (svref (cdr pV6) 2))) 
                       (if (null pV10) 
                           (return srt) 
                           (if (consp pV10) 
                               (let ((pV12 (car pV10))) 
                                 (return 
                                  (let ((ssrt 
                                         (SPECENVIRONMENT::substSort 
                                          (LISTPAIR::zip 
                                           (car pV12) 
                                           (svref pV18 1)) 
                                          (cdr pV12)))) 
                                    (SPECENVIRONMENT::unfoldBaseV 
                                     sp 
                                     ssrt 
                                     verbose))))))))) 
             (error "Nonexhaustive match failure in unfoldBaseV")))))) 
   (return srt)))

(defun SPECENVIRONMENT::unfoldBase (sp srt) 
  (SPECENVIRONMENT::unfoldBaseV sp srt t))

(defun SPECENVIRONMENT::stripSubsorts (sp srt) 
  (let ((pV3 (SPECENVIRONMENT::unfoldBase sp srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|Subsort|) 
         (return (SPECENVIRONMENT::stripSubsorts sp (svref (cdr pV3) 0)))) 
     (return pV3))))

(defun SPECENVIRONMENT::arrowOpt (sp srt) 
  (let ((pV3 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|Arrow|) 
         (let ((pV4 (cdr pV3))) 
           (return (cons :|Some| (cons (svref pV4 0) (svref pV4 1)))))) 
     (return '(:|None|)))))

(defun SPECENVIRONMENT::productOpt (sp srt) 
  (let ((pV3 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|Product|) (return (cons :|Some| (car (cdr pV3))))) 
     (return '(:|None|)))))

(defun STANDARDSPEC::mkBase (qid srts) 
  (cons :|Base| (vector qid srts POSITION-SPEC::noPos)))

(defparameter STANDARDSPEC::boolSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Boolean" "Boolean")) nil))

(defun STANDARDSPEC::mkFun (constant srt) 
  (cons :|Fun| (vector constant srt POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkTrue () 
  (STANDARDSPEC::mkFun (cons :|Bool| t) STANDARDSPEC::boolSort))

(defun ARITYNORMALIZE::etaExpand (sp usedNames srt term) 
  (let ((pV30 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV30) :|None|) 
         (return term) 
         (if (eq (car pV30) :|Some|) 
             (let ((pV32 (car (cdr pV30)))) 
               (return 
                (let ((pV28 (SPECENVIRONMENT::productOpt sp pV32))) 
                  (block 
                   nil 
                   (if (eq (car pV28) :|None|) 
                       (return 
                        (block 
                         nil 
                         (if (eq (car term) :|Lambda|) (return term)) 
                         (return 
                          (let ((pV4 (ARITYNORMALIZE::freshName "x" usedNames))) 
                            (block 
                             nil 
                             (return 
                              (let ((x (cons (car pV4) pV32))) 
                                (cons 
                                 :|Lambda| 
                                 (cons 
                                  (cons 
                                   (vector 
                                    (cons 
                                     :|VarPat| 
                                     (cons x POSITION-SPEC::noPos)) 
                                    (STANDARDSPEC::mkTrue) 
                                    (cons 
                                     :|Apply| 
                                     (vector 
                                      term 
                                      (cons :|Var| (cons x POSITION-SPEC::noPos)) 
                                      POSITION-SPEC::noPos))) 
                                   nil) 
                                  POSITION-SPEC::noPos)))) 
                             (error "Nonexhaustive match failure in etaExpand")))))) 
                       (if (eq (car pV28) :|Some|) 
                           (let ((pV29 (cdr pV28))) 
                             (return 
                              (block 
                               nil 
                               (if (eq (car term) :|Lambda|) 
                                   (let ((pV23 (car (cdr term)))) 
                                     (if (consp pV23) 
                                         (if (null (cdr pV23)) (return term))))) 
                               (return 
                                (let ((pV18 
                                       (ARITYNORMALIZE::freshNames 
                                        "x" 
                                        pV29 
                                        usedNames))) 
                                  (block 
                                   nil 
                                   (return 
                                    (let ((vars 
                                           (LISTPAIR::|!map|-1-1 
                                            #'(lambda (x) 
                                               (let ((pV15 (cdr x))) 
                                                 (block 
                                                  nil 
                                                  (return 
                                                   (cons 
                                                    (car pV15) 
                                                    (cons (car x) (cdr pV15)))) 
                                                  (error 
                                                   "Nonexhaustive match failure in etaExpand")))) 
                                            (cons (car pV18) pV29)))) 
                                      (let ((trm 
                                             (cons 
                                              :|Lambda| 
                                              (cons 
                                               (cons 
                                                (vector 
                                                 (cons 
                                                  :|RecordPat| 
                                                  (cons 
                                                   (LIST-SPEC::|!map|-1-1 
                                                    #'(lambda (x) 
                                                       (cons 
                                                        (car x) 
                                                        (cons 
                                                         :|VarPat| 
                                                         (cons 
                                                          (cdr x) 
                                                          POSITION-SPEC::noPos)))) 
                                                    vars) 
                                                   POSITION-SPEC::noPos)) 
                                                 (STANDARDSPEC::mkTrue) 
                                                 (cons 
                                                  :|Apply| 
                                                  (vector 
                                                   term 
                                                   (cons 
                                                    :|Record| 
                                                    (cons 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (cons 
                                                          (car x) 
                                                          (cons 
                                                           :|Var| 
                                                           (cons 
                                                            (cdr x) 
                                                            POSITION-SPEC::noPos)))) 
                                                      vars) 
                                                     POSITION-SPEC::noPos)) 
                                                   POSITION-SPEC::noPos))) 
                                                nil) 
                                               POSITION-SPEC::noPos)))) trm))) 
                                   (error 
                                    "Nonexhaustive match failure in etaExpand"))))))))) 
                   (error "Nonexhaustive match failure in etaExpand"))))))) 
     (error "Nonexhaustive match failure in etaExpand"))))

(defun ARITYNORMALIZE::insertPattern (pV17 pV18) 
  (block 
   nil 
   (return 
    (block 
     nil 
     (if (eq (car pV17) :|VarPat|) 
         (let ((pV15 (car (car (cdr pV17))))) 
           (return 
            (cons 
             (STRINGSET::add (car pV18) pV15) 
             (LIST-SPEC::|!cons| (cons pV15 '(:|None|)) (cdr pV18))))) 
         (if (eq (car pV17) :|RecordPat|) 
             (return 
              (LIST-SPEC::foldr-1-1-1 
               #'(lambda (x) 
                  (block 
                   nil 
                   (return (ARITYNORMALIZE::insertPattern (cdr (car x)) (cdr x))) 
                   (error "Nonexhaustive match failure in insertPattern"))) 
               pV18 
               (car (cdr pV17)))))) 
     (error "Nonexhaustive match failure in insertPattern"))) 
   (error "Nonexhaustive match failure in insertPattern")))

(defun STANDARDSPEC::mkApply (t1 t2) 
  (cons :|Apply| (vector t1 t2 POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkArrow (s1 s2) 
  (cons :|Arrow| (vector s1 s2 POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkLet (decls term) 
  (cons :|Let| (vector decls term POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkRecord (fields) 
  (cons :|Record| (cons fields POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkSubsort (srt pred) 
  (cons :|Subsort| (vector srt pred POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkRelax (srt pred) 
  (STANDARDSPEC::mkFun 
   '(:|Relax|) 
   (STANDARDSPEC::mkArrow (STANDARDSPEC::mkSubsort srt pred) srt)))

(defun METASLANG::termSort (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (return 
        (let ((pV4 (METASLANG::termSort (svref (cdr term) 0)))) 
          (block 
           nil 
           (if (eq (car pV4) :|Arrow|) (return (svref (cdr pV4) 1))) 
           (return 
            (SYSTEM-SPEC::fail 
             (STRING-SPEC::^ 
              "Cannot extract sort of application " 
              (SYSTEM-SPEC::toString term))))))) 
       (if (eq (car term) :|ApplyN|) 
           (let ((pV86 (car (cdr term)))) 
             (if (consp pV86) 
                 (let ((pV90 (cdr pV86))) 
                   (if (consp pV90) 
                       (if (null (cdr pV90)) 
                           (return 
                            (let ((pV12 (METASLANG::termSort (car pV86)))) 
                              (block 
                               nil 
                               (if (eq (car pV12) :|Arrow|) 
                                   (return (svref (cdr pV12) 1))) 
                               (return 
                                (SYSTEM-SPEC::fail 
                                 (STRING-SPEC::^ 
                                  "Cannot extract sort of application " 
                                  (SYSTEM-SPEC::toString term)))))))))))) 
           (if (eq (car term) :|Bind|) 
               (return 
                (METASLANG::mkABase 
                 (cons :|Qualified| (cons "Boolean" "Boolean")) 
                 nil 
                 (svref (cdr term) 3))) 
               (if (eq (car term) :|Record|) 
                   (let ((pV46 (cdr term))) 
                     (return 
                      (cons 
                       :|Product| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons (car x) (METASLANG::termSort (cdr x)))) 
                         (car pV46)) 
                        (cdr pV46))))) 
                   (if (eq (car term) :|Let|) 
                       (return (METASLANG::termSort (svref (cdr term) 1))) 
                       (if (eq (car term) :|LetRec|) 
                           (return (METASLANG::termSort (svref (cdr term) 1))) 
                           (if (eq (car term) :|Var|) 
                               (return (cdr (car (cdr term)))) 
                               (if (eq (car term) :|Fun|) 
                                   (return (svref (cdr term) 1)) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (return 
                                        (METASLANG::termSort 
                                         (svref (cdr term) 1))) 
                                       (if (eq (car term) :|Seq|) 
                                           (return 
                                            (cons 
                                             :|Product| 
                                             (cons nil (cdr (cdr term))))) 
                                           (if (eq (car term) :|SortedTerm|) 
                                               (return (svref (cdr term) 1)) 
                                               (if (eq (car term) :|Lambda|) 
                                                   (let ((pV38 (cdr term))) 
                                                     (let ((pV50 (car pV38))) 
                                                       (if (consp pV50) 
                                                           (let ((pV53 
                                                                  (car pV50))) 
                                                             (return 
                                                              (cons 
                                                               :|Arrow| 
                                                               (vector 
                                                                (METASLANG::patternSort 
                                                                 (svref pV53 0)) 
                                                                (METASLANG::termSort 
                                                                 (svref pV53 2)) 
                                                                (cdr pV38))))) 
                                                           (if (null pV50) 
                                                               (return 
                                                                (SYSTEM-SPEC::fail 
                                                                 "Ill formed lambda abstraction")))))))))))))))))) 
   (return (SYSTEM-SPEC::fail "Non-exhaustive match in termSort"))))

(defun STANDARDSPEC::mkRestrict (srt pred) 
  (STANDARDSPEC::mkFun 
   '(:|Restrict|) 
   (STANDARDSPEC::mkArrow srt (STANDARDSPEC::mkSubsort srt pred))))

(defun STANDARDSPEC::mkRestriction (pred term) 
  (let ((srt (METASLANG::termSort term))) 
    (STANDARDSPEC::mkApply (STANDARDSPEC::mkRestrict srt pred) term)))

(defun STANDARDSPEC::mkVar-1 (v) (cons :|Var| (cons v POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkVar (x0 x1) (STANDARDSPEC::mkVar-1 (cons x0 x1)))

(defun STANDARDSPEC::mkVarPat-1 (v) 
  (cons :|VarPat| (cons v POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkVarPat (x0 x1) (STANDARDSPEC::mkVarPat-1 (cons x0 x1)))

(defun ARITYNORMALIZE::mkArityApply (sp dom t1 t2 usedNames) 
  (labels 
    ((unfoldArgument (dom t2) 
      (let ((pV22 (SPECENVIRONMENT::unfoldBase sp dom))) 
        (block 
         nil 
         (if (eq (car pV22) :|Subsort|) 
             (let ((pV24 (cdr pV22))) 
               (let ((pV28 (svref pV24 1))
                     (pV27 (svref pV24 0))) 
                 (return 
                  (let ((relaxOp (STANDARDSPEC::mkRelax pV27 pV28))) 
                    (let ((t2 (STANDARDSPEC::mkApply relaxOp t2))) 
                      (let ((pV2 (unfoldArgument pV27 t2))) 
                        (block 
                         nil 
                         (return 
                          (let ((t2 (STANDARDSPEC::mkRestriction pV28 (car pV2)))) 
                            (cons t2 (cdr pV2)))) 
                         (error "Nonexhaustive match failure in mkArityApply")))))))) 
             (if (eq (car pV22) :|Product|) 
                 (return 
                  (let ((pV18 
                         (LIST-SPEC::foldr-1-1-1 
                          #'(lambda (x) 
                             (let ((pV10 (cdr x))
                                   (pV9 (car x))) 
                               (block 
                                nil 
                                (let ((pV11 (car pV9))) 
                                  (return 
                                   (let ((pV6 
                                          (ARITYNORMALIZE::freshName 
                                           (STRING-SPEC::^ "v" pV11) 
                                           (cdr pV10)))) 
                                     (block 
                                      nil 
                                      (return 
                                       (cons 
                                        (LIST-SPEC::|!cons| 
                                         (vector (car pV6) pV11 (cdr pV9)) 
                                         (car pV10)) 
                                        (cdr pV6))) 
                                      (error 
                                       "Nonexhaustive match failure in mkArityApply"))))) 
                                (error 
                                 "Nonexhaustive match failure in mkArityApply")))) 
                          (cons nil usedNames) 
                          (car (cdr pV22))))) 
                    (block 
                     nil 
                     (return 
                      (let ((pV15 (ARITYNORMALIZE::freshName "x" (cdr pV18)))) 
                        (block 
                         nil 
                         (let ((pV16 (car pV15))) 
                           (return 
                            (let ((decl 
                                   (cons (STANDARDSPEC::mkVarPat pV16 dom) t2))) 
                              (let ((v (STANDARDSPEC::mkVar pV16 dom))) 
                                (let ((fields 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'(lambda (x0) 
                                           (let ((label (svref x0 1))) 
                                             (let ((trm 
                                                    (STANDARDSPEC::mkApply 
                                                     (cons 
                                                      :|Fun| 
                                                      (vector 
                                                       (cons :|Project| label) 
                                                       (STANDARDSPEC::mkArrow 
                                                        dom 
                                                        (svref x0 2)) 
                                                       POSITION-SPEC::noPos)) 
                                                     v))) (cons label trm)))) 
                                        (car pV18)))) 
                                  (cons 
                                   (STANDARDSPEC::mkRecord fields) 
                                   (cons decl nil))))))) 
                         (error "Nonexhaustive match failure in mkArityApply")))) 
                     (error "Nonexhaustive match failure in mkArityApply")))))) 
         (return 
          (progn (STRING-SPEC::toScreen 
                  "Unexpected non-record argument to function ") 
                 (STRING-SPEC::toScreen 
                  (STRING-SPEC::^ (ANNSPECPRINTER::printTerm t2) " :  ")) 
                 (STRING-SPEC::writeLine (ANNSPECPRINTER::printSort dom)) 
                 (cons t2 nil))))))) 
    (let ((pV30 (unfoldArgument dom t2))) 
      (block 
       nil 
       (return 
        (STANDARDSPEC::mkLet (cdr pV30) (STANDARDSPEC::mkApply t1 (car pV30)))) 
       (error "Nonexhaustive match failure in mkArityApply")))))

(defun ARITYNORMALIZE::matchArity (match) 
  (labels 
    ((mA (match num) 
      (block 
       nil 
       (if (null match) 
           (return num) 
           (if (consp match) 
               (let ((pV12 (cdr match))) 
                 (let ((pV13 (svref (car match) 0))) 
                   (if (eq (car pV13) :|RecordPat|) 
                       (return 
                        (if ( =  num (LIST-SPEC::|!length| (car (cdr pV13)))) 
                            (mA pV12 num) 
                            1)) 
                       (if (eq (car pV13) :|WildPat|) (return (mA pV12 num)))))))) 
       (return 1)))) 
    (block 
     nil 
     (if (null match) 
         (return 0) 
         (if (consp match) 
             (let ((pV30 (svref (car match) 0))) 
               (if (eq (car pV30) :|RecordPat|) 
                   (return 
                    (mA (cdr match) (LIST-SPEC::|!length| (car (cdr pV30))))))))) 
     (return 1))))

(defun ARITYNORMALIZE::sortArity (sp srt) 
  (labels 
    ((productLength (srt) 
      (let ((pV1 (SPECENVIRONMENT::productOpt sp srt))) 
        (block 
         nil 
         (if (eq (car pV1) :|Some|) 
             (return (LIST-SPEC::|!length| (cdr pV1))) 
             (if (eq (car pV1) :|None|) (return 1))) 
         (error "Nonexhaustive match failure in sortArity"))))) 
    (let ((pV4 (SPECENVIRONMENT::arrowOpt sp srt))) 
      (block 
       nil 
       (if (eq (car pV4) :|Some|) 
           (let ((pV6 (car (cdr pV4)))) 
             (return 
              (let ((len (productLength pV6))) 
                (if (BOOLEAN-SPEC::~ ( =  len 1)) 
                    (cons :|Some| (cons pV6 len)) 
                    '(:|None|)))))) 
       (return '(:|None|))))))

(defun LIST-SPEC::|!find|-1-1 (p l) 
  (block 
   nil 
   (if (null l) 
       (return '(:|None|)) 
       (if (consp l) 
           (let ((pV3 (car l))) 
             (return 
              (if (funcall p pV3) 
                  (cons :|Some| pV3) 
                  (LIST-SPEC::|!find|-1-1 p (cdr l))))))) 
   (error "Nonexhaustive match failure in find")))

(defun ARITYNORMALIZE::termArity (sp gamma term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (return '(:|None|)) 
       (if (eq (car term) :|Var|) 
           (let ((pV51 (car (car (cdr term))))) 
             (return 
              (let ((pV4 
                     (LIST-SPEC::|!find|-1-1 
                      #'(lambda (x) (string=  pV51 (car x))) 
                      gamma))) 
                (block 
                 nil 
                 (if (eq (car pV4) :|Some|) 
                     (return (cdr (cdr pV4))) 
                     (if (eq (car pV4) :|None|) (return '(:|None|)))) 
                 (error "Nonexhaustive match failure in termArity"))))) 
           (if (eq (car term) :|Fun|) 
               (let ((pV38 (cdr term))) 
                 (progn (let ((pV44 (svref pV38 1))
                              (pV43 (svref pV38 0))) 
                          (if (eq (car pV43) :|Equals|) 
                              (return (ARITYNORMALIZE::sortArity sp pV44)) 
                              (if (eq (car pV43) :|Embed|) 
                                  (if (eq t (cdr (cdr pV43))) 
                                      (return 
                                       (ARITYNORMALIZE::sortArity sp pV44)))))) 
                        (return '(:|None|)))) 
               (if (eq (car term) :|Let|) 
                   (return '(:|None|)) 
                   (if (eq (car term) :|LetRec|) 
                       (return '(:|None|)) 
                       (if (eq (car term) :|Bind|) 
                           (return '(:|None|)) 
                           (if (eq (car term) :|Lambda|) 
                               (let ((pV41 (car (cdr term)))) 
                                 (return 
                                  (let ((mArity 
                                         (ARITYNORMALIZE::matchArity pV41))) 
                                    (if ( =  mArity 1) 
                                        '(:|None|) 
                                        (cons 
                                         :|Some| 
                                         (cons 
                                          (block 
                                           nil 
                                           (if (consp pV41) 
                                               (return 
                                                (METASLANG::patternSort 
                                                 (svref (car pV41) 0)))) 
                                           (return 
                                            (SYSTEM-SPEC::fail 
                                             "Unexpected empty match"))) 
                                          mArity)))))) 
                               (if (eq (car term) :|IfThenElse|) 
                                   (return '(:|None|)) 
                                   (if (eq (car term) :|Record|) 
                                       (return '(:|None|)) 
                                       (if (eq (car term) :|Seq|) 
                                           (return '(:|None|)))))))))))) 
   (return (SYSTEM-SPEC::fail "Unmatched term"))))

(defun ARITYNORMALIZE::convertToArity1 (sp gamma usedNames term) 
  (let ((pV4 (ARITYNORMALIZE::termArity sp gamma term))) 
    (block 
     nil 
     (if (eq (car pV4) :|None|) 
         (return term) 
         (if (eq (car pV4) :|Some|) 
             (let ((pV6 (car (cdr pV4)))) 
               (return 
                (let ((pV1 (ARITYNORMALIZE::freshName "x" usedNames))) 
                  (block 
                   nil 
                   (return 
                    (let ((x (cons (car pV1) pV6))) 
                      (cons 
                       :|Lambda| 
                       (cons 
                        (cons 
                         (vector 
                          (cons :|VarPat| (cons x POSITION-SPEC::noPos)) 
                          (STANDARDSPEC::mkTrue) 
                          (ARITYNORMALIZE::mkArityApply 
                           sp 
                           pV6 
                           term 
                           (STANDARDSPEC::mkVar-1 x) 
                           (cdr pV1))) 
                         nil) 
                        POSITION-SPEC::noPos)))) 
                   (error "Nonexhaustive match failure in convertToArity1"))))))) 
     (error "Nonexhaustive match failure in convertToArity1"))))

(defun ARITYNORMALIZE::insertVars (pV7 pV8) 
  (block 
   nil 
   (return 
    (LIST-SPEC::foldr-1-1-1 
     #'(lambda (x) 
        (let ((pV2 (cdr x))) 
          (block 
           nil 
           (let ((pV3 (car (car x)))) 
             (return 
              (cons 
               (STRINGSET::add (car pV2) pV3) 
               (LIST-SPEC::|!cons| (cons pV3 '(:|None|)) (cdr pV2))))) 
           (error "Nonexhaustive match failure in insertVars")))) 
     (cons (car pV8) (cdr pV8)) 
     pV7)) 
   (error "Nonexhaustive match failure in insertVars")))

(defun SPECENVIRONMENT::rangeOpt (sp srt) 
  (let ((pV2 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV2) :|None|) 
         (return '(:|None|)) 
         (if (eq (car pV2) :|Some|) (return (cons :|Some| (cdr (cdr pV2)))))) 
     (error "Nonexhaustive match failure in rangeOpt"))))

(defun SPECENVIRONMENT::inferType (sp tm) 
  (block 
   nil 
   (if (eq (car tm) :|Apply|) 
       (return 
        (let ((pV2 
               (SPECENVIRONMENT::rangeOpt 
                sp 
                (SPECENVIRONMENT::inferType sp (svref (cdr tm) 0))))) 
          (block 
           nil 
           (if (eq (car pV2) :|Some|) 
               (return (cdr pV2)) 
               (if (eq (car pV2) :|None|) 
                   (return 
                    (SYSTEM-SPEC::fail 
                     (STRING-SPEC::^ 
                      "Could not extract type for " 
                      (ANNSPECPRINTER::printTermWithSorts tm)))))) 
           (error "Nonexhaustive match failure in inferType")))) 
       (if (eq (car tm) :|Bind|) 
           (return STANDARDSPEC::boolSort) 
           (if (eq (car tm) :|Record|) 
               (let ((pV31 (cdr tm))) 
                 (return 
                  (cons 
                   :|Product| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (cons (car x) (SPECENVIRONMENT::inferType sp (cdr x)))) 
                     (car pV31)) 
                    (cdr pV31))))) 
               (if (eq (car tm) :|Let|) 
                   (return (SPECENVIRONMENT::inferType sp (svref (cdr tm) 1))) 
                   (if (eq (car tm) :|LetRec|) 
                       (return 
                        (SPECENVIRONMENT::inferType sp (svref (cdr tm) 1))) 
                       (if (eq (car tm) :|Var|) 
                           (return (cdr (car (cdr tm)))) 
                           (if (eq (car tm) :|Fun|) 
                               (return (svref (cdr tm) 1)) 
                               (if (eq (car tm) :|Lambda|) 
                                   (let ((pV43 (car (cdr tm)))) 
                                     (if (consp pV43) 
                                         (let ((pV46 (car pV43))) 
                                           (return 
                                            (STANDARDSPEC::mkArrow 
                                             (METASLANG::patternSort 
                                              (svref pV46 0)) 
                                             (SPECENVIRONMENT::inferType 
                                              sp 
                                              (svref pV46 2))))) 
                                         (if (null pV43) 
                                             (return 
                                              (SYSTEM-SPEC::fail 
                                               "inferType: Ill formed lambda abstraction"))))) 
                                   (if (eq (car tm) :|IfThenElse|) 
                                       (return 
                                        (SPECENVIRONMENT::inferType 
                                         sp 
                                         (svref (cdr tm) 1))) 
                                       (if (eq (car tm) :|Seq|) 
                                           (let ((pV34 (car (cdr tm)))) 
                                             (if (null pV34) 
                                                 (return 
                                                  (cons 
                                                   :|Product| 
                                                   (cons 
                                                    nil 
                                                    POSITION-SPEC::noPos))) 
                                                 (if (consp pV34) 
                                                     (let ((pV38 (cdr pV34))) 
                                                       (progn (if (null pV38) 
                                                                  (return 
                                                                   (SPECENVIRONMENT::inferType 
                                                                    sp 
                                                                    (car pV34)))) 
                                                              (return 
                                                               (SPECENVIRONMENT::inferType 
                                                                sp 
                                                                (cons 
                                                                 :|Seq| 
                                                                 (cons 
                                                                  pV38 
                                                                  POSITION-SPEC::noPos))))))))))))))))))) 
   (return (SYSTEM-SPEC::fail "inferType: Non-exhaustive match"))))

(defun STANDARDSPEC::mkOp (qid srt) 
  (STANDARDSPEC::mkFun (cons :|Op| (cons qid nil)) srt))

(defun ARITYNORMALIZE::mkArityTuple (sp term) 
  (let ((srt (SPECENVIRONMENT::inferType sp term))) 
    (STANDARDSPEC::mkApply 
     (STANDARDSPEC::mkOp 
      (cons :|Qualified| (cons "TranslationBuiltIn" "mkTuple")) 
      (STANDARDSPEC::mkArrow srt srt)) 
     term)))

(defun ARITYNORMALIZE::polymorphicDomain? (sp srt) 
  (let ((pV4 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV4) :|Some|) 
         (if (eq (car (car (cdr pV4))) :|TyVar|) (return t))) 
     (return nil))))

(defun STANDARDSPEC::findTheOp (pV1 pV2) 
  (block 
   nil 
   (if (eq (car pV2) :|Qualified|) 
       (let ((pV3 (cdr pV2))) 
         (return (findAQualifierMap (svref pV1 1) (car pV3) (cdr pV3))))) 
   (error "Nonexhaustive match failure in findTheOp")))

(defun ARITYNORMALIZE::polymorphicDomainOp? (spc idf) 
  (let ((pV5 (STANDARDSPEC::findTheOp spc idf))) 
    (block 
     nil 
     (if (eq (car pV5) :|Some|) 
         (return 
          (ARITYNORMALIZE::polymorphicDomain? spc (cdr (svref (cdr pV5) 2)))) 
         (if (eq (car pV5) :|None|) (return nil))) 
     (error "Nonexhaustive match failure in polymorphicDomainOp?"))))

(defun STANDARDSPEC::mkBind (b vars term) 
  (cons :|Bind| (vector b vars term POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkLetRec (decls term) 
  (cons :|LetRec| (vector decls term POSITION-SPEC::noPos)))

(defun ARITYNORMALIZE::normalizeArity (sp gamma usedNames term) 
  (labels 
    ((nonPolymorphicFun? (t1) 
      (block 
       nil 
       (if (eq (car t1) :|Fun|) 
           (let ((pV26 (svref (cdr t1) 0))) 
             (if (eq (car pV26) :|Op|) 
                 (return 
                  (BOOLEAN-SPEC::~ 
                   (ARITYNORMALIZE::polymorphicDomainOp? sp (car (cdr pV26)))))))) 
       (return nil)))
     (normalizeRecordArguments (|!t|) 
      (block 
       nil 
       (if (eq (car |!t|) :|Record|) 
           (return 
            (let ((fields 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (x) 
                       (cons 
                        (car x) 
                        (ARITYNORMALIZE::normalizeArity 
                         sp 
                         gamma 
                         usedNames 
                         (cdr x)))) 
                    (car (cdr |!t|))))) 
              (cons (STANDARDSPEC::mkRecord fields) t))) 
           (if (eq (car |!t|) :|Apply|) 
               (let ((pV9 (cdr |!t|))) 
                 (let ((pV11 (svref pV9 0))) 
                   (if (eq (car pV11) :|Fun|) 
                       (if (eq (car (svref (cdr pV11) 0)) :|Restrict|) 
                           (return 
                            (let ((pV4 (normalizeRecordArguments (svref pV9 1)))) 
                              (block 
                               nil 
                               (return 
                                (cons 
                                 (cons 
                                  :|Apply| 
                                  (vector pV11 (car pV4) (svref pV9 2))) 
                                 (cdr pV4))) 
                               (error 
                                "Nonexhaustive match failure in normalizeArity")))))))))) 
       (return 
        (let ((|!t|1 (ARITYNORMALIZE::normalizeArity sp gamma usedNames |!t|))) 
          (cons |!t|1 nil)))))) 
    (block 
     nil 
     (if (eq (car term) :|Apply|) 
         (let ((pV97 (cdr term))) 
           (let ((pV117 (svref pV97 1))
                 (pV116 (svref pV97 0))) 
             (return 
              (if (nonPolymorphicFun? pV116) 
                  (let ((pV34 (normalizeRecordArguments pV117))) 
                    (block 
                     nil 
                     (return (STANDARDSPEC::mkApply pV116 (car pV34))) 
                     (error "Nonexhaustive match failure in normalizeArity"))) 
                  (let ((pV46 (ARITYNORMALIZE::termArity sp gamma pV116))) 
                    (block 
                     nil 
                     (if (eq (car pV46) :|None|) 
                         (return 
                          (STANDARDSPEC::mkApply 
                           (ARITYNORMALIZE::normalizeArity 
                            sp 
                            gamma 
                            usedNames 
                            pV116) 
                           (ARITYNORMALIZE::normalizeArity 
                            sp 
                            gamma 
                            usedNames 
                            pV117))) 
                         (if (eq (car pV46) :|Some|) 
                             (return 
                              (let ((pV43 (normalizeRecordArguments pV117))) 
                                (block 
                                 nil 
                                 (let ((pV44 (car pV43))) 
                                   (return 
                                    (let ((t1 
                                           (block 
                                            nil 
                                            (if (eq (car pV116) :|Var|) 
                                                (return pV116) 
                                                (if (eq (car pV116) :|Fun|) 
                                                    (return pV116))) 
                                            (return 
                                             (ARITYNORMALIZE::normalizeArityTopLevel 
                                              sp 
                                              gamma 
                                              usedNames 
                                              pV116))))) 
                                      (if (cdr pV43) 
                                          (STANDARDSPEC::mkApply t1 pV44) 
                                          (ARITYNORMALIZE::mkArityApply 
                                           sp 
                                           (car (cdr pV46)) 
                                           t1 
                                           pV44 
                                           usedNames))))) 
                                 (error 
                                  "Nonexhaustive match failure in normalizeArity")))))) 
                     (error "Nonexhaustive match failure in normalizeArity"))))))) 
         (if (eq (car term) :|Record|) 
             (return 
              (let ((fields 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x) 
                         (cons 
                          (car x) 
                          (ARITYNORMALIZE::normalizeArity 
                           sp 
                           gamma 
                           usedNames 
                           (cdr x)))) 
                      (car (cdr term))))) 
                (ARITYNORMALIZE::mkArityTuple sp (STANDARDSPEC::mkRecord fields)))) 
             (if (eq (car term) :|Bind|) 
                 (let ((pV95 (cdr term))) 
                   (let ((pV111 (svref pV95 1))) 
                     (return 
                      (let ((pV52 
                             (ARITYNORMALIZE::insertVars 
                              pV111 
                              (cons usedNames gamma)))) 
                        (block 
                         nil 
                         (return 
                          (STANDARDSPEC::mkBind 
                           (svref pV95 0) 
                           pV111 
                           (ARITYNORMALIZE::normalizeArity 
                            sp 
                            (cdr pV52) 
                            (car pV52) 
                            (svref pV95 2)))) 
                         (error "Nonexhaustive match failure in normalizeArity")))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV94 (cdr term))) 
                       (return 
                        (let ((pV66 
                               (LIST-SPEC::foldr-1-1-1 
                                #'(lambda (x) 
                                   (let ((pV60 (cdr x))
                                         (pV59 (car x))) 
                                     (block 
                                      nil 
                                      (let ((pV61 (car pV59))) 
                                        (let ((pV65 (svref pV60 2))
                                              (pV64 (svref pV60 1))) 
                                          (return 
                                           (let ((t2 
                                                  (ARITYNORMALIZE::normalizeArity 
                                                   sp 
                                                   pV65 
                                                   pV64 
                                                   (cdr pV59)))) 
                                             (let ((pV56 
                                                    (ARITYNORMALIZE::insertPattern 
                                                     pV61 
                                                     (cons pV64 pV65)))) 
                                               (block 
                                                nil 
                                                (return 
                                                 (vector 
                                                  (LIST-SPEC::|!cons| 
                                                   (cons pV61 t2) 
                                                   (svref pV60 0)) 
                                                  (car pV56) 
                                                  (cdr pV56))) 
                                                (error 
                                                 "Nonexhaustive match failure in normalizeArity"))))))) 
                                      (error 
                                       "Nonexhaustive match failure in normalizeArity")))) 
                                (vector nil usedNames gamma) 
                                (svref pV94 0)))) 
                          (block 
                           nil 
                           (return 
                            (let ((term1 
                                   (ARITYNORMALIZE::normalizeArity 
                                    sp 
                                    (svref pV66 2) 
                                    (svref pV66 1) 
                                    (svref pV94 1)))) 
                              (STANDARDSPEC::mkLet (svref pV66 0) term1))) 
                           (error 
                            "Nonexhaustive match failure in normalizeArity"))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV93 (cdr term))) 
                           (let ((pV104 (svref pV93 0))) 
                             (return 
                              (let ((pV81 
                                     (LIST-SPEC::foldr-1-1-1 
                                      #'(lambda (x) 
                                         (let ((pV76 (cdr x))
                                               (pV75 (car x))) 
                                           (block 
                                            nil 
                                            (let ((pV80 (cdr pV76))) 
                                              (return 
                                               (block 
                                                nil 
                                                (let ((pV73 (car (car pV75)))) 
                                                  (return 
                                                   (let ((usedNames 
                                                          (STRINGSET::add 
                                                           (car pV76) 
                                                           pV73))) 
                                                     (let ((gamma 
                                                            (LIST-SPEC::|!cons| 
                                                             (cons 
                                                              pV73 
                                                              (ARITYNORMALIZE::termArity 
                                                               sp 
                                                               pV80 
                                                               (cdr pV75))) 
                                                             pV80))) 
                                                       (cons usedNames gamma))))) 
                                                (error 
                                                 "Nonexhaustive match failure in normalizeArity")))) 
                                            (error 
                                             "Nonexhaustive match failure in normalizeArity")))) 
                                      (cons usedNames gamma) 
                                      pV104))) 
                                (block 
                                 nil 
                                 (let ((pV83 (cdr pV81))
                                       (pV82 (car pV81))) 
                                   (return 
                                    (let ((decls 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) 
                                               (cons 
                                                (car x) 
                                                (ARITYNORMALIZE::normalizeArityTopLevel 
                                                 sp 
                                                 pV83 
                                                 pV82 
                                                 (cdr x)))) 
                                            pV104))) 
                                      (let ((term1 
                                             (ARITYNORMALIZE::normalizeArity 
                                              sp 
                                              pV83 
                                              pV82 
                                              (svref pV93 1)))) 
                                        (STANDARDSPEC::mkLetRec decls term1))))) 
                                 (error 
                                  "Nonexhaustive match failure in normalizeArity")))))) 
                         (if (eq (car term) :|IfThenElse|) 
                             (let ((pV92 (cdr term))) 
                               (return 
                                (cons 
                                 :|IfThenElse| 
                                 (vector 
                                  (ARITYNORMALIZE::normalizeArity 
                                   sp 
                                   gamma 
                                   usedNames 
                                   (svref pV92 0)) 
                                  (ARITYNORMALIZE::normalizeArity 
                                   sp 
                                   gamma 
                                   usedNames 
                                   (svref pV92 1)) 
                                  (ARITYNORMALIZE::normalizeArity 
                                   sp 
                                   gamma 
                                   usedNames 
                                   (svref pV92 2)) 
                                  (svref pV92 3))))) 
                             (if (eq (car term) :|Seq|) 
                                 (let ((pV91 (cdr term))) 
                                   (return 
                                    (cons 
                                     :|Seq| 
                                     (cons 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (trm) 
                                          (ARITYNORMALIZE::normalizeArity 
                                           sp 
                                           gamma 
                                           usedNames 
                                           trm)) 
                                       (car pV91)) 
                                      (cdr pV91))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (return 
                                      (let ((term1 
                                             (ARITYNORMALIZE::normalizeArityTopLevel 
                                              sp 
                                              gamma 
                                              usedNames 
                                              term))) 
                                        (ARITYNORMALIZE::convertToArity1 
                                         sp 
                                         gamma 
                                         usedNames 
                                         term1))) 
                                     (if (eq (car term) :|Var|) 
                                         (return 
                                          (ARITYNORMALIZE::convertToArity1 
                                           sp 
                                           gamma 
                                           usedNames 
                                           term)) 
                                         (if (eq (car term) :|Fun|) 
                                             (return 
                                              (ARITYNORMALIZE::convertToArity1 
                                               sp 
                                               gamma 
                                               usedNames 
                                               term)))))))))))) 
     (error "Nonexhaustive match failure in normalizeArity"))))

(defun ARITYNORMALIZE::normalizeArityTopLevel (sp gamma usedNames term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (let ((pV6 (cdr term))) 
         (return 
          (cons 
           :|Lambda| 
           (cons 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (x) 
                (let ((pat (svref x 0))) 
                  (let ((pV1 
                         (ARITYNORMALIZE::insertPattern 
                          pat 
                          (cons usedNames gamma)))) 
                    (block 
                     nil 
                     (let ((pV3 (cdr pV1))
                           (pV2 (car pV1))) 
                       (return 
                        (vector 
                         pat 
                         (ARITYNORMALIZE::normalizeArity sp pV3 pV2 (svref x 1)) 
                         (ARITYNORMALIZE::normalizeArity sp pV3 pV2 (svref x 2))))) 
                     (error 
                      "Nonexhaustive match failure in normalizeArityTopLevel"))))) 
             (car pV6)) 
            (cdr pV6)))))) 
   (return (ARITYNORMALIZE::normalizeArity sp gamma usedNames term))))

(defun SPLAYMAP::listItemsf (f sp l) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return l) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (SPLAYMAP::listItemsf 
               f 
               (svref pV2 0) 
               (LIST-SPEC::|!cons| 
                (funcall f (svref pV2 2)) 
                (SPLAYMAP::listItemsf f (svref pV2 1) l))))))) 
   (error "Nonexhaustive match failure in listItemsf")))

(defun SPLAYMAP::listDomain (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::listItemsf 
             #'(lambda (x) (car x)) 
             (STATE::|!!| (svref (cdr |!map|) 2)) 
             nil)))) 
   (error "Nonexhaustive match failure in listDomain")))

(defun STRINGMAP::listDomain (x) (SPLAYMAP::listDomain x))

(defun SPLAYSET::insert (x1) #'(lambda (x2) (SPLAYSET::insert-1-1 x1 x2)))

(defun SPLAYSET::addList (|!set| l) 
  (block 
   nil 
   (if (null l) (return |!set|)) 
   (return 
    (let ((pV11 
           (block 
            nil 
            (if (eq (car |!set|) :|SET|) 
                (let ((pV4 (cdr |!set|))) 
                  (return 
                   (vector 
                    (svref pV4 1) 
                    (STATE::|!!| (svref pV4 2)) 
                    (svref pV4 0)))) 
                (if (eq (car |!set|) :|EMPTY|) 
                    (return (vector 0 '(:|SplayNil|) (cdr |!set|))))) 
            (error "Nonexhaustive match failure in addList")))) 
      (block 
       nil 
       (let ((pV14 (svref pV11 2))) 
         (return 
          (let ((pV8 
                 (LIST-SPEC::foldr-1-1-1 
                  (SPLAYSET::insert pV14) 
                  (cons (svref pV11 0) (svref pV11 1)) 
                  l))) 
            (block 
             nil 
             (return 
              (cons :|SET| (vector pV14 (car pV8) (cons :|Ref| (cdr pV8))))) 
             (error "Nonexhaustive match failure in addList"))))) 
       (error "Nonexhaustive match failure in addList"))))))

(defparameter STRINGSET::empty (SPLAYSET::empty #'STRING-SPEC::compare-1))

(defun STRINGSET::fromList (ls) (SPLAYSET::addList STRINGSET::empty ls))

(defun ARITYNORMALIZE::arityNormalize-1 (spc) 
  (let ((usedNames (STRINGSET::fromList (STRINGMAP::listDomain (svref spc 1))))) 
    (setOps 
     spc 
     (mapAQualifierMap-1-1 
      #'(lambda (x) 
         (let ((pV3 (svref x 2))) 
           (block 
            nil 
            (let ((pV6 (cdr pV3))) 
              (return 
               (let ((new_defs 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (x1) 
                          (cons 
                           (car x1) 
                           (ARITYNORMALIZE::normalizeArityTopLevel 
                            spc 
                            nil 
                            usedNames 
                            (ARITYNORMALIZE::etaExpand 
                             spc 
                             usedNames 
                             pV6 
                             (cdr x1))))) 
                       (svref x 3)))) 
                 (vector (svref x 0) (svref x 1) (cons (car pV3) pV6) new_defs)))) 
            (error "Nonexhaustive match failure in arityNormalize")))) 
      (svref spc 1)))))

(defun ARITYNORMALIZE::arityNormalize (x0 x1 x2 x3) 
  (ARITYNORMALIZE::arityNormalize-1 (vector x0 x1 x2 x3)))

(defun ARITYNORMALIZE::convertToArity1-1 (x) 
  (ARITYNORMALIZE::convertToArity1 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun ARITYNORMALIZE::etaExpand-1 (x) 
  (ARITYNORMALIZE::etaExpand (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun ARITYNORMALIZE::freshName-1 (x) 
  (ARITYNORMALIZE::freshName (car x) (cdr x)))

(defun ARITYNORMALIZE::freshNames-1 (x) 
  (ARITYNORMALIZE::freshNames (svref x 0) (svref x 1) (svref x 2)))

(defun ARITYNORMALIZE::insertPattern-1 (x) 
  (ARITYNORMALIZE::insertPattern (car x) (cdr x)))

(defun ARITYNORMALIZE::insertVars-1 (x) 
  (ARITYNORMALIZE::insertVars (car x) (cdr x)))

(defun ARITYNORMALIZE::mkArityApply-1 (x) 
  (ARITYNORMALIZE::mkArityApply 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun ARITYNORMALIZE::mkArityTuple-1 (x) 
  (ARITYNORMALIZE::mkArityTuple (car x) (cdr x)))

(defun ARITYNORMALIZE::normalizeArity-1 (x) 
  (ARITYNORMALIZE::normalizeArity 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun ARITYNORMALIZE::normalizeArityTopLevel-1 (x) 
  (ARITYNORMALIZE::normalizeArityTopLevel 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun ARITYNORMALIZE::polymorphicDomain?-1 (x) 
  (ARITYNORMALIZE::polymorphicDomain? (car x) (cdr x)))

(defun ARITYNORMALIZE::polymorphicDomainOp?-1 (x) 
  (ARITYNORMALIZE::polymorphicDomainOp? (car x) (cdr x)))

(defun ARITYNORMALIZE::sortArity-1 (x) 
  (ARITYNORMALIZE::sortArity (car x) (cdr x)))

(defun ARITYNORMALIZE::termArity-1 (x) 
  (ARITYNORMALIZE::termArity (svref x 0) (svref x 1) (svref x 2)))

(defun BOOLEAN-SPEC::& (x y) (if x y nil))

(defun BOOLEAN-SPEC::&-1 (x) (BOOLEAN-SPEC::& (car x) (cdr x)))

(defun BOOLEAN-SPEC::<=> (x y) (if x y (BOOLEAN-SPEC::~ y)))

(defun BOOLEAN-SPEC::<=>-1 (x) (BOOLEAN-SPEC::<=> (car x) (cdr x)))

(defun BOOLEAN-SPEC::=> (x y) (if x y t))

(defun BOOLEAN-SPEC::=>-1 (x) (BOOLEAN-SPEC::=> (car x) (cdr x)))

(defun BOOLEAN-SPEC::|!or| (x y) (if x t y))

(defun BOOLEAN-SPEC::|!or|-1 (x) (BOOLEAN-SPEC::|!or| (car x) (cdr x)))

(defun BOOLEAN-SPEC::show (b) (BOOLEAN-SPEC::toString b))

(defun CGEN::addFuncDefn-1-1-1-1-1 (cSpec name params |!type| stmt) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (cons (vector name params |!type| stmt) (svref cSpec 4)) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (svref cSpec 7) 
   (svref cSpec 8) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (svref cSpec 11)))

(defun CGEN::addFuncDefn-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) 
           #'(lambda (x5) (CGEN::addFuncDefn-1-1-1-1-1 x1 x2 x3 x4 x5))))))

(defun CGEN::addFuncDefn (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addFuncDefn-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::addStruct-1-1-1 (cSpec name fields) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (svref cSpec 4) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (cons (cons name fields) (svref cSpec 7)) 
   (cons (cons name (cons :|Struct| name)) (svref cSpec 8)) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (svref cSpec 11)))

(defun CGEN::addStruct-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CGEN::addStruct-1-1-1 x1 x2 x3))))

(defun CGEN::addStruct (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addStruct-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::addTypeDefn-1-1-1 (cSpec name |!type|) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (svref cSpec 4) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (svref cSpec 7) 
   (cons (cons name |!type|) (svref cSpec 8)) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (svref cSpec 11)))

(defun CGEN::addTypeDefn-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CGEN::addTypeDefn-1-1-1 x1 x2 x3))))

(defun CGEN::addTypeDefn (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addTypeDefn-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::addVarDecl-1-1-1 (cSpec name |!type|) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (svref cSpec 4) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (svref cSpec 7) 
   (svref cSpec 8) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (cons (cons name |!type|) (svref cSpec 11))))

(defun CGEN::addVarDecl-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CGEN::addVarDecl-1-1-1 x1 x2 x3))))

(defun CGEN::addVarDecl (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addVarDecl-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::showQualifiedId (pV1) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV2 (cdr pV1))) 
         (let ((pV4 (cdr pV2))
               (pV3 (car pV2))) 
           (return 
            (if (string=  pV3 METASLANG::UnQualified) 
                pV4 
                (STRING-SPEC::^ (STRING-SPEC::^ pV3 "_") pV4)))))) 
   (error "Nonexhaustive match failure in showQualifiedId")))

(defun CGEN::baseSortToCType (pV4) 
  (block 
   nil 
   (if (eq (car pV4) :|Qualified|) 
       (let ((pV5 (cdr pV4))) 
         (let ((pV7 (cdr pV5))
               (pV6 (car pV5))) 
           (return 
            (if (string=  pV6 METASLANG::UnQualified) 
                (cons :|Base| pV7) 
                (block 
                 nil 
                 (if (string=  "Boolean" pV6) 
                     (if (string=  "Boolean" pV7) (return (cons :|Base| "bool"))) 
                     (if (string=  "Integer" pV6) 
                         (if (string=  "Integer" pV7) (return '(:|Int|))) 
                         (if (string=  "Nat" pV6) 
                             (if (string=  "Nat" pV7) (return '(:|UnsignedInt|))) 
                             (if (string=  "String" pV6) 
                                 (if (string=  "String" pV7) 
                                     (return (cons :|Ptr| '(:|Char|)))) 
                                 (if (string=  "Char" pV6) 
                                     (if (string=  "Char" pV7) 
                                         (return '(:|Char|))) 
                                     (if (string=  "Double" pV6) 
                                         (if (string=  "Double" pV7) 
                                             (return '(:|Double|))))))))) 
                 (return 
                  (cons 
                   :|Base| 
                   (CGEN::showQualifiedId (cons :|Qualified| (cons pV6 pV7))))))))))) 
   (error "Nonexhaustive match failure in baseSortToCType")))

(defun CGEN::fail (msg) (progn (STRING-SPEC::writeLine msg) msg))

(defun CGEN::binaryToString (b) 
  (block 
   nil 
   (if (eq (car b) :|Set|) 
       (return " = ") 
       (if (eq (car b) :|Add|) 
           (return " + ") 
           (if (eq (car b) :|Sub|) 
               (return " - ") 
               (if (eq (car b) :|Mul|) 
                   (return " * ") 
                   (if (eq (car b) :|Div|) 
                       (return " / ") 
                       (if (eq (car b) :|Mod|) 
                           (return " % ") 
                           (if (eq (car b) :|BitAnd|) 
                               (return " & ") 
                               (if (eq (car b) :|BitOr|) 
                                   (return " | ") 
                                   (if (eq (car b) :|BitXor|) 
                                       (return " ^ ") 
                                       (if (eq (car b) :|ShiftLeft|) 
                                           (return " << ") 
                                           (if (eq (car b) :|ShiftRight|) 
                                               (return " >> ") 
                                               (if (eq (car b) :|SetAdd|) 
                                                   (return " += ") 
                                                   (if (eq (car b) :|SetSub|) 
                                                       (return " -= ") 
                                                       (if (eq (car b) :|SetMul|) 
                                                           (return " *= ") 
                                                           (if (eq 
                                                                (car b) 
                                                                :|SetDiv|) 
                                                               (return " /= ") 
                                                               (if (eq 
                                                                    (car b) 
                                                                    :|SetMod|) 
                                                                   (return 
                                                                    " %= ") 
                                                                   (if (eq 
                                                                        (car b) 
                                                                        :|SetBitAnd|) 
                                                                       (return 
                                                                        " &= ") 
                                                                       (if (eq 
                                                                            (car 
                                                                             b) 
                                                                            :|SetBitOr|) 
                                                                           (return 
                                                                            " |= ") 
                                                                           (if (eq 
                                                                                (car 
                                                                                 b) 
                                                                                :|SetBitXor|) 
                                                                               (return 
                                                                                " ^= ") 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     b) 
                                                                                    :|SetShiftLeft|) 
                                                                                   (return 
                                                                                    " <<= ") 
                                                                                   (if (eq 
                                                                                        (car 
                                                                                         b) 
                                                                                        :|SetShiftRight|) 
                                                                                       (return 
                                                                                        " >>= ") 
                                                                                       (if (eq 
                                                                                            (car 
                                                                                             b) 
                                                                                            :|LogAnd|) 
                                                                                           (return 
                                                                                            " && ") 
                                                                                           (if (eq 
                                                                                                (car 
                                                                                                 b) 
                                                                                                :|LogOr|) 
                                                                                               (return 
                                                                                                " || ") 
                                                                                               (if (eq 
                                                                                                    (car 
                                                                                                     b) 
                                                                                                    :|Eq|) 
                                                                                                   (return 
                                                                                                    " == ") 
                                                                                                   (if (eq 
                                                                                                        (car 
                                                                                                         b) 
                                                                                                        :|NotEq|) 
                                                                                                       (return 
                                                                                                        " != ") 
                                                                                                       (if (eq 
                                                                                                            (car 
                                                                                                             b) 
                                                                                                            :|Lt|) 
                                                                                                           (return 
                                                                                                            " < ") 
                                                                                                           (if (eq 
                                                                                                                (car 
                                                                                                                 b) 
                                                                                                                :|Gt|) 
                                                                                                               (return 
                                                                                                                " > ") 
                                                                                                               (if (eq 
                                                                                                                    (car 
                                                                                                                     b) 
                                                                                                                    :|Le|) 
                                                                                                                   (return 
                                                                                                                    " <= ") 
                                                                                                                   (if (eq 
                                                                                                                        (car 
                                                                                                                         b) 
                                                                                                                        :|Ge|) 
                                                                                                                       (return 
                                                                                                                        " >= ")))))))))))))))))))))))))))))) 
   (return (CGEN::fail "Unexpected binary"))))

(defun CGEN::derefSort-1-1 (spc srt) 
  (block 
   nil 
   (if (eq (car srt) :|Base|) 
       (return 
        (let ((pV4 (STANDARDSPEC::findTheSort spc (svref (cdr srt) 0)))) 
          (block 
           nil 
           (if (eq (car pV4) :|None|) 
               (return srt) 
               (if (eq (car pV4) :|Some|) 
                   (let ((pV8 (svref (cdr pV4) 2))) 
                     (if (null pV8) 
                         (return srt) 
                         (if (consp pV8) 
                             (return (CGEN::derefSort-1-1 spc (cdr (car pV8))))))))) 
           (error "Nonexhaustive match failure in derefSort"))))) 
   (return srt)))

(defun CGEN::codSort-1-1 (spc srt) 
  (let ((pV3 (CGEN::derefSort-1-1 spc srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|Arrow|) (return (svref (cdr pV3) 1))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        (STRING-SPEC::^ "codSort: '" (ANNSPECPRINTER::printSort srt)) 
        "' is not a function type"))))))

(defun CGEN::codSort-1 (x1) #'(lambda (x2) (CGEN::codSort-1-1 x1 x2)))

(defun CGEN::codSort (x0 x1 x2 x3) (CGEN::codSort-1 (vector x0 x1 x2 x3)))

(defun CGEN::derefSort-1 (x1) #'(lambda (x2) (CGEN::derefSort-1-1 x1 x2)))

(defun CGEN::derefSort (x0 x1 x2 x3) (CGEN::derefSort-1 (vector x0 x1 x2 x3)))

(defparameter CGEN::emptyCSpec 
  (vector nil nil nil nil nil nil nil nil nil nil nil nil))

(defun CGEN::findTypeDefn (x defns) 
  (LIST-SPEC::|!find|-1-1 #'(lambda (x0) (string=  x (car x0))) defns))

(defun LIST-SPEC::flatten (l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (return (LIST-SPEC::concat (car l) (LIST-SPEC::flatten (cdr l)))))) 
   (error "Nonexhaustive match failure in flatten")))

(defun CGEN::namesInTypes (ts) 
  (LIST-SPEC::flatten (LIST-SPEC::|!map|-1-1 #'CGEN::namesInType ts)))

(defun CGEN::namesInType (|!t|) 
  (block 
   nil 
   (if (eq (car |!t|) :|Base|) 
       (return (cons (cdr |!t|) nil)) 
       (if (eq (car |!t|) :|Ptr|) 
           (return (CGEN::namesInType (cdr |!t|))) 
           (if (eq (car |!t|) :|Struct|) 
               (return nil) 
               (if (eq (car |!t|) :|Union|) 
                   (return nil) 
                   (if (eq (car |!t|) :|Fn|) 
                       (let ((pV5 (cdr |!t|))) 
                         (return 
                          (LIST-SPEC::|!++| 
                           (CGEN::namesInType (cdr pV5)) 
                           (CGEN::namesInTypes (car pV5))))) 
                       (if (eq (car |!t|) :|Array|) 
                           (return (CGEN::namesInType (cdr |!t|))) 
                           (if (eq (car |!t|) :|Void|) 
                               (return nil) 
                               (if (eq (car |!t|) :|Char|) 
                                   (return nil) 
                                   (if (eq (car |!t|) :|Short|) 
                                       (return nil) 
                                       (if (eq (car |!t|) :|Int|) 
                                           (return nil) 
                                           (if (eq (car |!t|) :|Long|) 
                                               (return nil) 
                                               (if (eq 
                                                    (car |!t|) 
                                                    :|UnsignedChar|) 
                                                   (return nil) 
                                                   (if (eq 
                                                        (car |!t|) 
                                                        :|UnsignedShort|) 
                                                       (return nil) 
                                                       (if (eq 
                                                            (car |!t|) 
                                                            :|UnsignedInt|) 
                                                           (return nil) 
                                                           (if (eq 
                                                                (car |!t|) 
                                                                :|UnsignedLong|) 
                                                               (return nil) 
                                                               (if (eq 
                                                                    (car |!t|) 
                                                                    :|Float|) 
                                                                   (return nil) 
                                                                   (if (eq 
                                                                        (car 
                                                                         |!t|) 
                                                                        :|Double|) 
                                                                       (return 
                                                                        nil) 
                                                                       (if (eq 
                                                                            (car 
                                                                             |!t|) 
                                                                            :|LongDouble|) 
                                                                           (return 
                                                                            nil))))))))))))))))))) 
   (error "Nonexhaustive match failure in namesInType")))

(defun CGEN::expand (name defns) 
  (let ((pV2 (CGEN::findTypeDefn name defns))) 
    (block 
     nil 
     (if (eq (car pV2) :|None|) 
         (return nil) 
         (if (eq (car pV2) :|Some|) (return (CGEN::namesInType (cdr (cdr pV2)))))) 
     (error "Nonexhaustive match failure in expand"))))

(defun CGEN::expand-1 (x) (CGEN::expand (car x) (cdr x)))

(defun CGEN::failPretty (msg) 
  (progn (STRING-SPEC::writeLine msg) (PRETTYPRINT::|!string| msg)))

(defun CGEN::findTypeDefn-1 (x) (CGEN::findTypeDefn (car x) (cdr x)))

(defun CGEN::findTypeDefns (names defns) 
  (block 
   nil 
   (if (null names) 
       (return nil) 
       (if (consp names) 
           (let ((pV6 (cdr names))) 
             (return 
              (let ((pV1 (CGEN::findTypeDefn (car names) defns))) 
                (block 
                 nil 
                 (if (eq (car pV1) :|None|) 
                     (return (CGEN::findTypeDefns pV6 defns)) 
                     (if (eq (car pV1) :|Some|) 
                         (return 
                          (LIST-SPEC::|!cons| 
                           (cdr pV1) 
                           (CGEN::findTypeDefns pV6 defns))))) 
                 (error "Nonexhaustive match failure in findTypeDefns"))))))) 
   (error "Nonexhaustive match failure in findTypeDefns")))

(defun CGEN::findTypeDefns-1 (x) (CGEN::findTypeDefns (car x) (cdr x)))

(defun CGEN::removePrime (qid) 
  (block 
   nil 
   (if (eq (car qid) :|Qualified|) 
       (let ((pV7 (cdr qid))) 
         (return 
          (let ((pV2 (LIST-SPEC::rev (STRING-SPEC::explode (cdr pV7))))) 
            (block 
             nil 
             (if (consp pV2) 
                 (if (eq #\' (car pV2)) 
                     (return 
                      (cons 
                       :|Qualified| 
                       (cons 
                        (car pV7) 
                        (STRING-SPEC::implode (LIST-SPEC::rev (cdr pV2)))))))) 
             (return qid)))))) 
   (error "Nonexhaustive match failure in removePrime")))

(defun CGEN::sortToCType (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Subsort|) 
       (return (CGEN::sortToCType (svref (cdr srt) 0))) 
       (if (eq (car srt) :|Base|) 
           (let ((pV25 (cdr srt))) 
             (let ((pV31 (svref pV25 1))
                   (pV30 (svref pV25 0))) 
               (progn (if (eq (car pV30) :|Qualified|) 
                          (let ((pV33 (cdr pV30))) 
                            (let ((pV35 (cdr pV33))
                                  (pV34 (car pV33))) 
                              (if (string=  "Array" pV34) 
                                  (if (string=  "Array" pV35) 
                                      (if (consp pV31) 
                                          (if (null (cdr pV31)) 
                                              (return 
                                               (cons 
                                                :|Array| 
                                                (CGEN::sortToCType (car pV31))))))) 
                                  (if (string=  "Store" pV34) 
                                      (if (string=  "Ptr" pV35) 
                                          (if (consp pV31) 
                                              (if (null (cdr pV31)) 
                                                  (return 
                                                   (cons 
                                                    :|Ptr| 
                                                    (CGEN::sortToCType 
                                                     (car pV31)))))))))))) 
                      (if (null pV31) (return (CGEN::baseSortToCType pV30))) 
                      (return 
                       (progn (STRING-SPEC::writeLine 
                               (STRING-SPEC::^ 
                                "sortToCType: found instantiated base type: " 
                                (ANNSPECPRINTER::printSort srt))) 
                              '(:|Void|)))))) 
           (if (eq (car srt) :|Arrow|) 
               (let ((pV24 (cdr srt))) 
                 (let ((pV27 (svref pV24 0))) 
                   (return 
                    (let ((domTypes 
                           (block 
                            nil 
                            (if (eq (car pV27) :|Product|) 
                                (let ((pV14 (car (cdr pV27)))) 
                                  (if (consp pV14) 
                                      (if (string=  "1" (car (car pV14))) 
                                          (return 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) 
                                               (CGEN::sortToCType (cdr x))) 
                                            pV14)))))) 
                            (return (cons (CGEN::sortToCType pV27) nil))))) 
                      (cons 
                       :|Fn| 
                       (cons domTypes (CGEN::sortToCType (svref pV24 1))))))))))) 
   (return 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             "sortToCType: unsupported type: " 
             (ANNSPECPRINTER::printSort srt))) 
           '(:|Void|)))))

(defun CGEN::funToCExp-1-1 (fun srt) 
  (block 
   nil 
   (if (eq (car fun) :|Equals|) 
       (return (cons :|Binary| '(:|Eq|))) 
       (if (eq (car fun) :|Nat|) 
           (return (cons :|Const| (cons :|Int| (cons t (cdr fun))))) 
           (if (eq (car fun) :|Char|) 
               (return (cons :|Const| (cons :|Char| (cdr fun)))) 
               (if (eq (car fun) :|Bool|) 
                   (return 
                    (cons :|Const| (cons :|Int| (cons t (if (cdr fun) 1 0))))) 
                   (if (eq (car fun) :|String|) 
                       (return (cons :|Const| (cons :|String| (cdr fun)))) 
                       (if (eq (car fun) :|Op|) 
                           (let ((pV46 (car (cdr fun)))) 
                             (progn (if (eq (car pV46) :|Qualified|) 
                                        (let ((pV48 (cdr pV46))) 
                                          (let ((pV49 (car pV48))
                                                (pV50 (cdr pV48))) 
                                            (if (string=  "Store" pV49) 
                                                (if (string=  "nilPtr" pV50) 
                                                    (return 
                                                     (cons 
                                                      :|Var| 
                                                      (cons "NULL" '(:|Void|))))) 
                                                (if (string=  "Nat" pV49) 
                                                    (if (string=  "+" pV50) 
                                                        (return 
                                                         (cons 
                                                          :|Binary| 
                                                          '(:|Add|))) 
                                                        (if (string=  "*" pV50) 
                                                            (return 
                                                             (cons 
                                                              :|Binary| 
                                                              '(:|Mul|))) 
                                                            (if (string=  
                                                                 "-" 
                                                                 pV50) 
                                                                (return 
                                                                 (cons 
                                                                  :|Binary| 
                                                                  '(:|Sub|))) 
                                                                (if (string=  
                                                                     "<" 
                                                                     pV50) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Binary| 
                                                                      '(:|Lt|))) 
                                                                    (if (string=  
                                                                         "<=" 
                                                                         pV50) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|Le|))) 
                                                                        (if (string=  
                                                                             ">" 
                                                                             pV50) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|Gt|))) 
                                                                            (if (string=  
                                                                                 ">=" 
                                                                                 pV50) 
                                                                                (return 
                                                                                 (cons 
                                                                                  :|Binary| 
                                                                                  '(:|Ge|))) 
                                                                                (if (string=  
                                                                                     "div" 
                                                                                     pV50) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Binary| 
                                                                                      '(:|Div|))) 
                                                                                    (if (string=  
                                                                                         "mod" 
                                                                                         pV50) 
                                                                                        (return 
                                                                                         (cons 
                                                                                          :|Binary| 
                                                                                          '(:|Mod|)))))))))))) 
                                                    (if (string=  "Integer" pV49) 
                                                        (if (string=  "+" pV50) 
                                                            (return 
                                                             (cons 
                                                              :|Binary| 
                                                              '(:|Add|))) 
                                                            (if (string=  
                                                                 "*" 
                                                                 pV50) 
                                                                (return 
                                                                 (cons 
                                                                  :|Binary| 
                                                                  '(:|Mul|))) 
                                                                (if (string=  
                                                                     "-" 
                                                                     pV50) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Binary| 
                                                                      '(:|Sub|))) 
                                                                    (if (string=  
                                                                         "div" 
                                                                         pV50) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|Div|))) 
                                                                        (if (string=  
                                                                             "mod" 
                                                                             pV50) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|Mod|))) 
                                                                            (if (string=  
                                                                                 "~" 
                                                                                 pV50) 
                                                                                (return 
                                                                                 (cons 
                                                                                  :|Unary| 
                                                                                  '(:|Negate|))) 
                                                                                (if (string=  
                                                                                     "<" 
                                                                                     pV50) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Binary| 
                                                                                      '(:|Lt|))) 
                                                                                    (if (string=  
                                                                                         "<=" 
                                                                                         pV50) 
                                                                                        (return 
                                                                                         (cons 
                                                                                          :|Binary| 
                                                                                          '(:|Le|))) 
                                                                                        (if (string=  
                                                                                             ">" 
                                                                                             pV50) 
                                                                                            (return 
                                                                                             (cons 
                                                                                              :|Binary| 
                                                                                              '(:|Gt|))) 
                                                                                            (if (string=  
                                                                                                 ">=" 
                                                                                                 pV50) 
                                                                                                (return 
                                                                                                 (cons 
                                                                                                  :|Binary| 
                                                                                                  '(:|Ge|))))))))))))) 
                                                        (if (string=  
                                                             "Double" 
                                                             pV49) 
                                                            (if (string=  
                                                                 "+" 
                                                                 pV50) 
                                                                (return 
                                                                 (cons 
                                                                  :|Binary| 
                                                                  '(:|Add|))) 
                                                                (if (string=  
                                                                     "*" 
                                                                     pV50) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Binary| 
                                                                      '(:|Mul|))) 
                                                                    (if (string=  
                                                                         "-" 
                                                                         pV50) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|Sub|))) 
                                                                        (if (string=  
                                                                             "//" 
                                                                             pV50) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|Div|))) 
                                                                            (if (string=  
                                                                                 "~" 
                                                                                 pV50) 
                                                                                (return 
                                                                                 (cons 
                                                                                  :|Unary| 
                                                                                  '(:|Negate|))) 
                                                                                (if (string=  
                                                                                     "<" 
                                                                                     pV50) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Binary| 
                                                                                      '(:|Lt|))) 
                                                                                    (if (string=  
                                                                                         "<=" 
                                                                                         pV50) 
                                                                                        (return 
                                                                                         (cons 
                                                                                          :|Binary| 
                                                                                          '(:|Le|))) 
                                                                                        (if (string=  
                                                                                             ">" 
                                                                                             pV50) 
                                                                                            (return 
                                                                                             (cons 
                                                                                              :|Binary| 
                                                                                              '(:|Gt|))) 
                                                                                            (if (string=  
                                                                                                 ">=" 
                                                                                                 pV50) 
                                                                                                (return 
                                                                                                 (cons 
                                                                                                  :|Binary| 
                                                                                                  '(:|Ge|))) 
                                                                                                (if (string=  
                                                                                                     "pi" 
                                                                                                     pV50) 
                                                                                                    (return 
                                                                                                     (cons 
                                                                                                      :|Var| 
                                                                                                      (cons 
                                                                                                       "M_PI" 
                                                                                                       '(:|Double|)))))))))))))) 
                                                            (if (string=  
                                                                 "Boolean" 
                                                                 pV49) 
                                                                (if (string=  
                                                                     "~" 
                                                                     pV50) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Unary| 
                                                                      '(:|LogNot|))) 
                                                                    (if (string=  
                                                                         "&" 
                                                                         pV50) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|LogAnd|))) 
                                                                        (if (string=  
                                                                             "or" 
                                                                             pV50) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|LogOr|)))))))))))))) 
                                    (return 
                                     (cons 
                                      :|Var| 
                                      (cons 
                                       (CGEN::showQualifiedId 
                                        (CGEN::removePrime pV46)) 
                                       (CGEN::sortToCType srt)))))) 
                           (if (eq (car fun) :|Embed|) 
                               (return 
                                (progn (STRING-SPEC::writeLine 
                                        (STRING-SPEC::^ 
                                         "funToCExp: Ignoring constructor " 
                                         (car (cdr fun)))) 
                                       '(:|Nop|)))))))))) 
   (error "Nonexhaustive match failure in funToCExp")))

(defun CGEN::funToCExp (x1) #'(lambda (x2) (CGEN::funToCExp-1-1 x1 x2)))

(defun CGEN::termToCExp (term) 
  (labels 
    ((applyArgsToCExps (args) 
      (block 
       nil 
       (if (eq (car args) :|Record|) 
           (return (recordFieldsToCExps (car (cdr args))))) 
       (return (cons (CGEN::termToCExp args) nil))))
     (recordFieldsToCExps (fields) 
      (block 
       nil 
       (if (null fields) 
           (return nil) 
           (if (consp fields) 
               (return 
                (cons 
                 (CGEN::termToCExp (cdr (car fields))) 
                 (recordFieldsToCExps (cdr fields)))))) 
       (error "Nonexhaustive match failure in termToCExp")))) 
    (block 
     nil 
     (if (eq (car term) :|Fun|) 
         (let ((pV45 (cdr term))) 
           (return (CGEN::funToCExp-1-1 (svref pV45 0) (svref pV45 1)))) 
         (if (eq (car term) :|Var|) 
             (let ((pV85 (car (cdr term)))) 
               (return 
                (cons :|Var| (cons (car pV85) (CGEN::sortToCType (cdr pV85)))))) 
             (if (eq (car term) :|IfThenElse|) 
                 (let ((pV43 (cdr term))) 
                   (return 
                    (cons 
                     :|IfExp| 
                     (vector 
                      (CGEN::termToCExp (svref pV43 0)) 
                      (CGEN::termToCExp (svref pV43 1)) 
                      (CGEN::termToCExp (svref pV43 2)))))) 
                 (if (eq (car term) :|Apply|) 
                     (let ((pV42 (cdr term))) 
                       (let ((pV47 (svref pV42 1))
                             (pV46 (svref pV42 0))) 
                         (progn (if (eq (car pV46) :|Apply|) 
                                    (let ((pV50 (cdr pV46))) 
                                      (let ((pV62 (svref pV50 1))
                                            (pV61 (svref pV50 0))) 
                                        (if (eq (car pV61) :|Fun|) 
                                            (let ((pV65 (svref (cdr pV61) 0))) 
                                              (if (eq (car pV65) :|Op|) 
                                                  (let ((pV69 (car (cdr pV65)))) 
                                                    (if (eq 
                                                         (car pV69) 
                                                         :|Qualified|) 
                                                        (let ((pV71 (cdr pV69))) 
                                                          (let ((pV73 (cdr pV71))
                                                                (pV72 (car pV71))) 
                                                            (if (string=  
                                                                 "Array" 
                                                                 pV72) 
                                                                (if (string=  
                                                                     "index" 
                                                                     pV73) 
                                                                    (return 
                                                                     (let ((cArray 
                                                                            (CGEN::termToCExp 
                                                                             pV62))) 
                                                                       (let ((cIndex 
                                                                              (CGEN::termToCExp 
                                                                               pV47))) 
                                                                         (cons 
                                                                          :|ArrayRef| 
                                                                          (cons 
                                                                           cArray 
                                                                           cIndex)))))) 
                                                                (if (string=  
                                                                     "Struct" 
                                                                     pV72) 
                                                                    (if (string=  
                                                                         "proj" 
                                                                         pV73) 
                                                                        (progn (if (eq 
                                                                                    (car 
                                                                                     pV62) 
                                                                                    :|Fun|) 
                                                                                   (let ((pV75 
                                                                                          (svref 
                                                                                           (cdr 
                                                                                            pV62) 
                                                                                           0))) 
                                                                                     (if (eq 
                                                                                          (car 
                                                                                           pV75) 
                                                                                          :|Op|) 
                                                                                         (return 
                                                                                          (let ((cStruct 
                                                                                                 (CGEN::termToCExp 
                                                                                                  pV47))) 
                                                                                            (cons 
                                                                                             :|StructRef| 
                                                                                             (cons 
                                                                                              cStruct 
                                                                                              (CGEN::showQualifiedId 
                                                                                               (CGEN::removePrime 
                                                                                                (car 
                                                                                                 (cdr 
                                                                                                  pV75))))))))))) 
                                                                               (return 
                                                                                (let ((cProjFunc 
                                                                                       (CGEN::termToCExp 
                                                                                        pV62))) 
                                                                                  (let ((cStruct 
                                                                                         (CGEN::termToCExp 
                                                                                          pV47))) 
                                                                                    (cons 
                                                                                     :|Apply| 
                                                                                     (cons 
                                                                                      (cons 
                                                                                       :|Apply| 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         :|Unary| 
                                                                                         '(:|Contents|)) 
                                                                                        (cons 
                                                                                         cProjFunc 
                                                                                         nil))) 
                                                                                      (cons 
                                                                                       cStruct 
                                                                                       nil))))))))))))))))))) 
                                    (if (eq (car pV46) :|Fun|) 
                                        (let ((pV49 (cdr pV46))) 
                                          (let ((pV51 (svref pV49 0))) 
                                            (progn (if (eq (car pV51) :|Project|) 
                                                       (return 
                                                        (let ((cStruct 
                                                               (CGEN::termToCExp 
                                                                pV47))) 
                                                          (cons 
                                                           :|StructRef| 
                                                           (cons 
                                                            cStruct 
                                                            (cdr pV51))))) 
                                                       (if (eq (car pV51) :|Op|) 
                                                           (let ((pV56 
                                                                  (car 
                                                                   (cdr pV51)))) 
                                                             (if (eq 
                                                                  (car pV56) 
                                                                  :|Qualified|) 
                                                                 (let ((pV58 
                                                                        (cdr 
                                                                         pV56))) 
                                                                   (let ((pV60 
                                                                          (cdr 
                                                                           pV58))
                                                                         (pV59 
                                                                          (car 
                                                                           pV58))) 
                                                                     (if (string=  
                                                                          "Store" 
                                                                          pV59) 
                                                                         (if (string=  
                                                                              "deref" 
                                                                              pV60) 
                                                                             (return 
                                                                              (cons 
                                                                               :|Apply| 
                                                                               (cons 
                                                                                (cons 
                                                                                 :|Unary| 
                                                                                 '(:|Contents|)) 
                                                                                (cons 
                                                                                 (CGEN::termToCExp 
                                                                                  pV47) 
                                                                                 nil))))) 
                                                                         (if (string=  
                                                                              "Double" 
                                                                              pV59) 
                                                                             (if (string=  
                                                                                  "fromNat" 
                                                                                  pV60) 
                                                                                 (return 
                                                                                  (CGEN::termToCExp 
                                                                                   pV47)) 
                                                                                 (if (string=  
                                                                                      "sqrt" 
                                                                                      pV60) 
                                                                                     (return 
                                                                                      (cons 
                                                                                       :|Apply| 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         :|Var| 
                                                                                         (cons 
                                                                                          "sqrt" 
                                                                                          (cons 
                                                                                           :|Fn| 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             '(:|Double|) 
                                                                                             nil) 
                                                                                            '(:|Double|))))) 
                                                                                        (cons 
                                                                                         (CGEN::termToCExp 
                                                                                          pV47) 
                                                                                         nil)))) 
                                                                                     (if (string=  
                                                                                          "exp" 
                                                                                          pV60) 
                                                                                         (return 
                                                                                          (cons 
                                                                                           :|Apply| 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             :|Var| 
                                                                                             (cons 
                                                                                              "exp" 
                                                                                              (cons 
                                                                                               :|Fn| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 '(:|Double|) 
                                                                                                 nil) 
                                                                                                '(:|Double|))))) 
                                                                                            (cons 
                                                                                             (CGEN::termToCExp 
                                                                                              pV47) 
                                                                                             nil)))) 
                                                                                         (if (string=  
                                                                                              "abs" 
                                                                                              pV60) 
                                                                                             (return 
                                                                                              (cons 
                                                                                               :|Apply| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 :|Var| 
                                                                                                 (cons 
                                                                                                  "fabs" 
                                                                                                  (cons 
                                                                                                   :|Fn| 
                                                                                                   (cons 
                                                                                                    (cons 
                                                                                                     '(:|Double|) 
                                                                                                     nil) 
                                                                                                    '(:|Double|))))) 
                                                                                                (cons 
                                                                                                 (CGEN::termToCExp 
                                                                                                  pV47) 
                                                                                                 nil)))))))) 
                                                                             (if (string=  
                                                                                  "Functions" 
                                                                                  pV59) 
                                                                                 (if (string=  
                                                                                      "id" 
                                                                                      pV60) 
                                                                                     (return 
                                                                                      (CGEN::termToCExp 
                                                                                       pV47)))))))))))) 
                                                   (return 
                                                    (let ((cFun 
                                                           (CGEN::funToCExp-1-1 
                                                            pV51 
                                                            (svref pV49 1)))) 
                                                      (let ((cArgs 
                                                             (applyArgsToCExps 
                                                              pV47))) 
                                                        (block 
                                                         nil 
                                                         (if (eq 
                                                              (car cFun) 
                                                              :|Binary|) 
                                                             (return 
                                                              (if (BOOLEAN-SPEC::~ 
                                                                   ( =  
                                                                    (LIST-SPEC::|!length| 
                                                                     cArgs) 
                                                                    2)) 
                                                                  (SYSTEM-SPEC::fail 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     "trying to apply a binary operator to " 
                                                                     (NAT-SPEC::natToString 
                                                                      (LIST-SPEC::|!length| 
                                                                       cArgs))) 
                                                                    " arguments.")) 
                                                                  (cons 
                                                                   :|Apply| 
                                                                   (cons 
                                                                    cFun 
                                                                    cArgs)))) 
                                                             (if (eq 
                                                                  (car cFun) 
                                                                  :|Unary|) 
                                                                 (return 
                                                                  (if (BOOLEAN-SPEC::~ 
                                                                       ( =  
                                                                        (LIST-SPEC::|!length| 
                                                                         cArgs) 
                                                                        1)) 
                                                                      (SYSTEM-SPEC::fail 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         "trying to apply a unary operator to " 
                                                                         (NAT-SPEC::natToString 
                                                                          (LIST-SPEC::|!length| 
                                                                           cArgs))) 
                                                                        " arguments.")) 
                                                                      (cons 
                                                                       :|Apply| 
                                                                       (cons 
                                                                        cFun 
                                                                        cArgs)))))) 
                                                         (return 
                                                          (cons 
                                                           :|Apply| 
                                                           (cons cFun cArgs)))))))))))) 
                                (return 
                                 (let ((cFun (CGEN::termToCExp pV46))) 
                                   (let ((cArgs (applyArgsToCExps pV47))) 
                                     (cons :|Apply| (cons cFun cArgs)))))))))))) 
     (return 
      (progn (STRING-SPEC::writeLine 
              (STRING-SPEC::^ 
               "termToCExp: term is neither a constant nor an application: " 
               (ANNSPECPRINTER::printTerm term))) 
             '(:|Nop|))))))

(defun CGEN::generateCFunctions-1-1 (cSpec spc) 
  (labels 
    ((doOp (pV42 pV43 pV44 pV45) 
      (block 
       nil 
       (let ((pV49 (svref pV44 3))) 
         (return 
          (block 
           nil 
           (if (null pV49) 
               (return pV45) 
               (if (consp pV49) 
                   (return 
                    (funcall (funcall (funcall (toCFunc pV45) 
                                               (CGEN::showQualifiedId 
                                                (cons 
                                                 :|Qualified| 
                                                 (cons pV42 pV43)))) 
                                      (cdr (car pV49))) 
                             (cdr (svref pV44 2)))))) 
           (error "Nonexhaustive match failure in generateCFunctions")))) 
       (error "Nonexhaustive match failure in generateCFunctions")))
     (toCFunc (cSpec) 
      #'(lambda (name) 
         #'(lambda (trm) 
            #'(lambda (srt) 
               (block 
                nil 
                (if (eq (car trm) :|Lambda|) 
                    (let ((pV29 (car (cdr trm)))) 
                      (if (consp pV29) 
                          (let ((pV32 (car pV29))) 
                            (if (null (cdr pV29)) 
                                (return 
                                 (let ((pV16 (svref pV32 0))
                                       (pV18 (svref pV32 2))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV16) :|VarPat|) 
                                        (let ((pV23 (car (cdr pV16)))) 
                                          (return 
                                           (CGEN::addFuncDefn-1-1-1-1-1 
                                            cSpec 
                                            name 
                                            (cons 
                                             (cons 
                                              (car pV23) 
                                              (CGEN::sortToCType (cdr pV23))) 
                                             nil) 
                                            (CGEN::sortToCType 
                                             (CGEN::codSort-1-1 spc srt)) 
                                            (cons 
                                             :|Return| 
                                             (CGEN::termToCExp pV18))))) 
                                        (if (eq (car pV16) :|RecordPat|) 
                                            (let ((pV21 (car (cdr pV16)))) 
                                              (return 
                                               (labels 
                                                 ((fieldToVarDecl (pV6 pat) 
                                                   (declare (ignore pV6)) 
                                                   (declare (ignore pV6)) 
                                                   (block 
                                                    nil 
                                                    (if (eq (car pat) :|VarPat|) 
                                                        (let ((pV11 
                                                               (car (cdr pat)))) 
                                                          (return 
                                                           (cons 
                                                            (car pV11) 
                                                            (CGEN::sortToCType 
                                                             (cdr pV11)))))) 
                                                    (return 
                                                     (SYSTEM-SPEC::fail 
                                                      "generateCFunctions: record field not a var pat"))))) 
                                                 (CGEN::addFuncDefn-1-1-1-1-1 
                                                  cSpec 
                                                  name 
                                                  (LIST-SPEC::|!map|-1-1 
                                                   #'(lambda (x1) 
                                                      (fieldToVarDecl 
                                                       (car x1) 
                                                       (cdr x1))) 
                                                   pV21) 
                                                  (CGEN::sortToCType 
                                                   (CGEN::codSort-1-1 spc srt)) 
                                                  (cons 
                                                   :|Return| 
                                                   (CGEN::termToCExp pV18)))))))) 
                                    (return 
                                     (SYSTEM-SPEC::fail 
                                      (STRING-SPEC::^ 
                                       (STRING-SPEC::^ 
                                        (STRING-SPEC::^ 
                                         (STRING-SPEC::^ 
                                          "generateCFunctions: operator " 
                                          name) 
                                         " is not a function: '") 
                                        (ANNSPECPRINTER::printTerm trm)) 
                                       "'"))))))))))) 
                (return 
                 (CGEN::addFuncDefn-1-1-1-1-1 
                  cSpec 
                  name 
                  nil 
                  (CGEN::sortToCType srt) 
                  (cons :|Return| (CGEN::termToCExp trm)))))))))) 
    (foldriAQualifierMap-1-1-1 
     #'(lambda (x) (doOp (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
     cSpec 
     (svref spc 1))))

(defun CGEN::generateCFunctions-1 (x1) 
  #'(lambda (x2) (CGEN::generateCFunctions-1-1 x1 x2)))

(defun CGEN::generateCFunctions (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::generateCFunctions-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::generateCTypes-1-1 (cSpec spc) 
  (labels 
    ((doSort (pV42 pV43 pV44 pV45) 
      (block 
       nil 
       (let ((pV48 (svref pV44 2))) 
         (return 
          (block 
           nil 
           (if (null pV48) 
               (return pV45) 
               (if (consp pV48) 
                   (return 
                    (funcall (funcall (makeCType pV45) 
                                      (CGEN::showQualifiedId 
                                       (cons :|Qualified| (cons pV42 pV43)))) 
                             (cdr (car pV48)))))) 
           (error "Nonexhaustive match failure in generateCTypes")))) 
       (error "Nonexhaustive match failure in generateCTypes")))
     (makeCType (cSpec) 
      #'(lambda (name) 
         #'(lambda (srt) 
            (block 
             nil 
             (if (eq (car srt) :|Arrow|) 
                 (return 
                  (CGEN::addTypeDefn-1-1-1 cSpec name (CGEN::sortToCType srt))) 
                 (if (eq (car srt) :|Subsort|) 
                     (return 
                      (funcall (funcall (makeCType cSpec) name) 
                               (svref (cdr srt) 0))) 
                     (if (eq (car srt) :|Product|) 
                         (return 
                          (CGEN::addStruct-1-1-1 
                           cSpec 
                           name 
                           (LIST-SPEC::|!map|-1-1 
                            #'(lambda (x) 
                               (cons (car x) (CGEN::sortToCType (cdr x)))) 
                            (car (cdr srt))))) 
                         (if (eq (car srt) :|Base|) 
                             (let ((pV10 (cdr srt))) 
                               (let ((pV14 (svref pV10 0))
                                     (pV15 (svref pV10 1))) 
                                 (progn (if (null pV15) 
                                            (return 
                                             (CGEN::addTypeDefn-1-1-1 
                                              cSpec 
                                              name 
                                              (CGEN::baseSortToCType pV14)))) 
                                        (if (eq (car pV14) :|Qualified|) 
                                            (let ((pV17 (cdr pV14))) 
                                              (let ((pV18 (car pV17))
                                                    (pV19 (cdr pV17))) 
                                                (if (string=  "Array" pV18) 
                                                    (if (string=  "Array" pV19) 
                                                        (if (consp pV15) 
                                                            (if (null (cdr pV15)) 
                                                                (return 
                                                                 (CGEN::addTypeDefn-1-1-1 
                                                                  cSpec 
                                                                  name 
                                                                  (cons 
                                                                   :|Array| 
                                                                   (CGEN::sortToCType 
                                                                    (car pV15)))))))) 
                                                    (if (string=  "Store" pV18) 
                                                        (if (string=  "Ptr" pV19) 
                                                            (if (consp pV15) 
                                                                (if (null 
                                                                     (cdr pV15)) 
                                                                    (return 
                                                                     (CGEN::addTypeDefn-1-1-1 
                                                                      cSpec 
                                                                      name 
                                                                      (cons 
                                                                       :|Ptr| 
                                                                       (CGEN::sortToCType 
                                                                        (car 
                                                                         pV15)))))))))))))))))))) 
             (return 
              (progn (STRING-SPEC::writeLine 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        "generateCTypes: unsupported sort: " 
                        (ANNSPECPRINTER::printSort srt)) 
                       "
")) 
                     cSpec))))))) 
    (CGEN::addTypeDefn-1-1-1 
     (foldriAQualifierMap-1-1-1 
      #'(lambda (x) (doSort (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
      cSpec 
      (svref spc 3)) 
     "bool" 
     '(:|Int|))))

(defun CGEN::generateCTypes-1 (x1) 
  #'(lambda (x2) (CGEN::generateCTypes-1-1 x1 x2)))

(defun CGEN::generateCTypes (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::generateCTypes-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::generateCVars-1-1 (cSpec spc) 
  (labels 
    ((doOp (pV3 pV4 pV5 pV6) 
      (block 
       nil 
       (return 
        (block 
         nil 
         (if (null (svref pV5 3)) 
             (return 
              (CGEN::addVarDecl-1-1-1 
               pV6 
               (CGEN::showQualifiedId (cons :|Qualified| (cons pV3 pV4))) 
               (CGEN::sortToCType (cdr (svref pV5 2)))))) 
         (return pV6))) 
       (error "Nonexhaustive match failure in generateCVars")))) 
    (foldriAQualifierMap-1-1-1 
     #'(lambda (x) (doOp (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
     cSpec 
     (svref spc 1))))

(defun CGEN::generateCVars-1 (x1) 
  #'(lambda (x2) (CGEN::generateCVars-1-1 x1 x2)))

(defun CGEN::generateCVars (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::generateCVars-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::parens-1 (p) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::|!string| "(") 
    (cons p (cons (PRETTYPRINT::|!string| ")") nil)))))

(defun CGEN::parens (x0 x1) (CGEN::parens-1 (cons x0 x1)))

(defun CGEN::ppBaseType (s p) 
  (PRETTYPRINT::prettysNone (cons (PRETTYPRINT::|!string| s) (cons p nil))))

(defun PRETTYPRINT::emptyPretty () (PRETTYPRINT::|!string| ""))

(defun CGEN::ppPlainType (|!t|) (CGEN::ppType |!t| (PRETTYPRINT::emptyPretty)))

(defun CGEN::ppPlainTypes (ts) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'CGEN::ppPlainType ts)))

(defun CGEN::ppType (|!t| p) 
  (block 
   nil 
   (if (eq (car |!t|) :|Void|) 
       (return (CGEN::ppBaseType "void" p)) 
       (if (eq (car |!t|) :|Char|) 
           (return (CGEN::ppBaseType "char" p)) 
           (if (eq (car |!t|) :|ConstField|) 
               (return (CGEN::ppBaseType "ConstField" p)) 
               (if (eq (car |!t|) :|Short|) 
                   (return (CGEN::ppBaseType "short" p)) 
                   (if (eq (car |!t|) :|Int|) 
                       (return (CGEN::ppBaseType "int" p)) 
                       (if (eq (car |!t|) :|Long|) 
                           (return (CGEN::ppBaseType "long" p)) 
                           (if (eq (car |!t|) :|UnsignedChar|) 
                               (return (CGEN::ppBaseType "unsigned char" p)) 
                               (if (eq (car |!t|) :|UnsignedShort|) 
                                   (return (CGEN::ppBaseType "unsigned short" p)) 
                                   (if (eq (car |!t|) :|UnsignedInt|) 
                                       (return 
                                        (CGEN::ppBaseType "unsigned int" p)) 
                                       (if (eq (car |!t|) :|UnsignedLong|) 
                                           (return 
                                            (CGEN::ppBaseType "unsigned long" p)) 
                                           (if (eq (car |!t|) :|Float|) 
                                               (return 
                                                (CGEN::ppBaseType "float" p)) 
                                               (if (eq (car |!t|) :|Double|) 
                                                   (return 
                                                    (CGEN::ppBaseType "double" p)) 
                                                   (if (eq 
                                                        (car |!t|) 
                                                        :|LongDouble|) 
                                                       (return 
                                                        (CGEN::ppBaseType 
                                                         "long double" 
                                                         p)) 
                                                       (if (eq 
                                                            (car |!t|) 
                                                            :|Base|) 
                                                           (return 
                                                            (CGEN::ppBaseType 
                                                             (cdr |!t|) 
                                                             p)) 
                                                           (if (eq 
                                                                (car |!t|) 
                                                                :|Struct|) 
                                                               (return 
                                                                (PRETTYPRINT::prettysNone 
                                                                 (cons 
                                                                  (PRETTYPRINT::|!string| 
                                                                   "struct ") 
                                                                  (cons 
                                                                   (PRETTYPRINT::|!string| 
                                                                    (cdr |!t|)) 
                                                                   (cons p nil))))) 
                                                               (if (eq 
                                                                    (car |!t|) 
                                                                    :|Union|) 
                                                                   (return 
                                                                    (PRETTYPRINT::prettysNone 
                                                                     (cons 
                                                                      (PRETTYPRINT::|!string| 
                                                                       "union ") 
                                                                      (cons 
                                                                       (PRETTYPRINT::|!string| 
                                                                        (cdr 
                                                                         |!t|)) 
                                                                       (cons 
                                                                        p 
                                                                        nil))))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         |!t|) 
                                                                        :|Ptr|) 
                                                                       (return 
                                                                        (CGEN::ppType 
                                                                         (cdr 
                                                                          |!t|) 
                                                                         (PRETTYPRINT::prettysNone 
                                                                          (cons 
                                                                           (PRETTYPRINT::|!string| 
                                                                            "*") 
                                                                           (cons 
                                                                            p 
                                                                            (cons 
                                                                             (PRETTYPRINT::|!string| 
                                                                              "") 
                                                                             nil)))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             |!t|) 
                                                                            :|Array|) 
                                                                           (return 
                                                                            (CGEN::ppType 
                                                                             (cdr 
                                                                              |!t|) 
                                                                             (PRETTYPRINT::prettysNone 
                                                                              (cons 
                                                                               (PRETTYPRINT::|!string| 
                                                                                "(") 
                                                                               (cons 
                                                                                p 
                                                                                (cons 
                                                                                 (PRETTYPRINT::|!string| 
                                                                                  "[])") 
                                                                                 nil)))))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 |!t|) 
                                                                                :|Fn|) 
                                                                               (let ((pV3 
                                                                                      (cdr 
                                                                                       |!t|))) 
                                                                                 (return 
                                                                                  (CGEN::ppType 
                                                                                   (cdr 
                                                                                    pV3) 
                                                                                   (PRETTYPRINT::prettysNone 
                                                                                    (cons 
                                                                                     p 
                                                                                     (cons 
                                                                                      (CGEN::ppPlainTypes 
                                                                                       (car 
                                                                                        pV3)) 
                                                                                      nil))))))))))))))))))))))))) 
   (return (CGEN::failPretty "Unexpected type to print "))))

(defun PRETTYPRINT::strings (ss) 
  (PRETTYPRINT::prettysNone (LIST-SPEC::|!map|-1-1 #'PRETTYPRINT::|!string| ss)))


(defun CGEN::ppArg (s |!t|) 
  (CGEN::ppType |!t| (PRETTYPRINT::strings (cons " " (cons s nil)))))

(defun CGEN::ppArg-1 (x) (CGEN::ppArg (car x) (cdr x)))

(defun CGEN::ppArgs (vds) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'CGEN::ppArg-1 vds)))

(defun CGEN::ppBinary (b) (PRETTYPRINT::|!string| (CGEN::binaryToString b)))

(defun CGEN::ppQuoteString (s) 
  (labels 
    ((ppQuoteCharList (clist) 
      (block 
       nil 
       (if (null clist) 
           (return nil) 
           (if (consp clist) 
               (let ((pV4 (cdr clist))
                     (pV3 (car clist))) 
                 (progn (if (eq #\" pV3) 
                            (return 
                             (LIST-SPEC::concat 
                              (cons #\\ (cons #\" nil)) 
                              (ppQuoteCharList pV4)))) 
                        (return (LIST-SPEC::|!cons| pV3 (ppQuoteCharList pV4))))))) 
       (error "Nonexhaustive match failure in ppQuoteString")))) 
    (STRING-SPEC::implode (ppQuoteCharList (STRING-SPEC::explode s)))))

(defun CGEN::ppConst (v) 
  (block 
   nil 
   (if (eq (car v) :|Char|) 
       (return 
        (PRETTYPRINT::strings 
         (cons "'" (cons (CHAR-SPEC::toString (cdr v)) (cons "'" nil))))) 
       (if (eq (car v) :|Int|) 
           (let ((pV5 (cdr v))) 
             (return 
              (PRETTYPRINT::strings 
               (cons 
                (if (car pV5) "" "-") 
                (cons (NAT-SPEC::toString (cdr pV5)) nil))))) 
           (if (eq (car v) :|Float|) 
               (let ((pV4 (cdr v))) 
                 (return 
                  (PRETTYPRINT::strings 
                   (cons 
                    (if (svref pV4 0) "" "-") 
                    (cons 
                     (NAT-SPEC::toString (svref pV4 1)) 
                     (cons "." (cons (NAT-SPEC::toString (svref pV4 2)) nil))))))) 
               (if (eq (car v) :|String|) 
                   (return 
                    (PRETTYPRINT::strings 
                     (cons "" (cons (CGEN::ppQuoteString (cdr v)) (cons "" nil))))))))) 
   (return (CGEN::failPretty "Unexpected const to print"))))

(defun CGEN::ppExpRec (e inOneLine) 
  (block 
   nil 
   (if (eq (car e) :|Const|) 
       (return (CGEN::ppExp_internal e inOneLine)) 
       (if (eq (car e) :|Var|) 
           (return (CGEN::ppExp_internal e inOneLine)) 
           (if (eq (car e) :|Fn|) (return (CGEN::ppExp_internal e inOneLine))))) 
   (return (CGEN::parens-1 (CGEN::ppExp_internal e inOneLine)))))

(defun PRETTYPRINT::prettysNoneDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysNone delims ps))

(defun CGEN::ppExpsInOneline (es) 
  (PRETTYPRINT::prettysNoneDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'(lambda (e) (CGEN::ppExp_internal e t)) es)))

(defun CGEN::ppUnary (u) 
  (PRETTYPRINT::|!string| 
   (block 
    nil 
    (if (eq (car u) :|Contents|) 
        (return "*") 
        (if (eq (car u) :|Address|) 
            (return "&") 
            (if (eq (car u) :|Negate|) 
                (return "-") 
                (if (eq (car u) :|BitNot|) 
                    (return "~") 
                    (if (eq (car u) :|LogNot|) 
                        (return "!") 
                        (if (eq (car u) :|PreInc|) 
                            (return "++") 
                            (if (eq (car u) :|PreDec|) 
                                (return "--") 
                                (if (eq (car u) :|PostInc|) 
                                    (return "++") 
                                    (if (eq (car u) :|PostDec|) (return "--")))))))))) 
    (return (CGEN::fail "Unexpected unary")))))

(defun CGEN::unaryPrefix? (u) 
  (block 
   nil 
   (if (eq (car u) :|PostInc|) 
       (return nil) 
       (if (eq (car u) :|PostDec|) (return nil))) 
   (return t)))

(defun CGEN::ppExp_internal (e inOneLine) 
  (let ((prettysFill_ 
         (if inOneLine #'PRETTYPRINT::prettysNone #'PRETTYPRINT::prettysFill))) 
    (let ((prettysLinear 
           (if inOneLine #'PRETTYPRINT::prettysNone #'PRETTYPRINT::prettysLinear))) 
      (block 
       nil 
       (if (eq (car e) :|Const|) 
           (return (CGEN::ppConst (cdr e))) 
           (if (eq (car e) :|Fn|) 
               (return (PRETTYPRINT::|!string| (svref (cdr e) 0))) 
               (if (eq (car e) :|Var|) 
                   (return (PRETTYPRINT::|!string| (car (cdr e)))) 
                   (if (eq (car e) :|Apply|) 
                       (let ((pV11 (cdr e))) 
                         (let ((pV39 (cdr pV11))
                               (pV38 (car pV11))) 
                           (progn (if (eq (car pV38) :|Unary|) 
                                      (let ((pV41 (cdr pV38))) 
                                        (if (consp pV39) 
                                            (let ((pV55 (car pV39))) 
                                              (if (null (cdr pV39)) 
                                                  (return 
                                                   (PRETTYPRINT::prettysNone 
                                                    (if (CGEN::unaryPrefix? pV41) 
                                                        (cons 
                                                         (CGEN::ppUnary pV41) 
                                                         (cons 
                                                          (CGEN::ppExpRec 
                                                           pV55 
                                                           inOneLine) 
                                                          nil)) 
                                                        (cons 
                                                         (CGEN::ppExpRec 
                                                          pV55 
                                                          inOneLine) 
                                                         (cons 
                                                          (CGEN::ppUnary pV41) 
                                                          nil))))))))) 
                                      (if (eq (car pV38) :|Binary|) 
                                          (let ((pV40 (cdr pV38))) 
                                            (progn (if (eq (car pV40) :|Set|) 
                                                       (if (consp pV39) 
                                                           (let ((pV50 
                                                                  (cdr pV39))) 
                                                             (if (consp pV50) 
                                                                 (if (null 
                                                                      (cdr pV50)) 
                                                                     (return 
                                                                      (funcall prettysFill_ 
                                                                               (cons 
                                                                                (CGEN::ppExp_internal 
                                                                                 (car 
                                                                                  pV39) 
                                                                                 inOneLine) 
                                                                                (cons 
                                                                                 (CGEN::ppBinary 
                                                                                  '(:|Set|)) 
                                                                                 (cons 
                                                                                  (CGEN::ppExp_internal 
                                                                                   (car 
                                                                                    pV50) 
                                                                                   inOneLine) 
                                                                                  nil)))))))))) 
                                                   (if (consp pV39) 
                                                       (let ((pV44 (cdr pV39))) 
                                                         (if (consp pV44) 
                                                             (if (null 
                                                                  (cdr pV44)) 
                                                                 (return 
                                                                  (funcall prettysFill_ 
                                                                           (cons 
                                                                            (CGEN::ppExpRec 
                                                                             (car 
                                                                              pV39) 
                                                                             inOneLine) 
                                                                            (cons 
                                                                             (CGEN::ppBinary 
                                                                              pV40) 
                                                                             (cons 
                                                                              (CGEN::ppExpRec 
                                                                               (car 
                                                                                pV44) 
                                                                               inOneLine) 
                                                                              nil))))))))))))) 
                                  (return 
                                   (funcall prettysFill_ 
                                            (cons 
                                             (CGEN::ppExp_internal 
                                              pV38 
                                              inOneLine) 
                                             (cons 
                                              (PRETTYPRINT::prettysNone 
                                               (cons 
                                                (PRETTYPRINT::|!string| " ") 
                                                (cons 
                                                 (CGEN::ppExpsInOneline pV39) 
                                                 nil))) 
                                              nil))))))) 
                       (if (eq (car e) :|Cast|) 
                           (let ((pV10 (cdr e))) 
                             (return 
                              (CGEN::parens-1 
                               (PRETTYPRINT::prettysNone 
                                (cons 
                                 (CGEN::parens-1 (CGEN::ppPlainType (car pV10))) 
                                 (cons 
                                  (PRETTYPRINT::|!string| " ") 
                                  (cons 
                                   (CGEN::ppExp_internal (cdr pV10) inOneLine) 
                                   nil))))))) 
                           (if (eq (car e) :|StructRef|) 
                               (let ((pV9 (cdr e))) 
                                 (let ((pV25 (cdr pV9))
                                       (pV24 (car pV9))) 
                                   (progn (if (eq (car pV24) :|Apply|) 
                                              (let ((pV27 (cdr pV24))) 
                                                (let ((pV31 (cdr pV27))
                                                      (pV30 (car pV27))) 
                                                  (if (eq (car pV30) :|Unary|) 
                                                      (if (eq 
                                                           (car (cdr pV30)) 
                                                           :|Contents|) 
                                                          (if (consp pV31) 
                                                              (if (null 
                                                                   (cdr pV31)) 
                                                                  (return 
                                                                   (PRETTYPRINT::prettysNone 
                                                                    (cons 
                                                                     (CGEN::ppExpRec 
                                                                      (car pV31) 
                                                                      inOneLine) 
                                                                     (cons 
                                                                      (PRETTYPRINT::strings 
                                                                       (cons 
                                                                        " -> " 
                                                                        (cons 
                                                                         pV25 
                                                                         nil))) 
                                                                      nil)))))))))) 
                                              (if (eq (car pV24) :|Var|) 
                                                  (return 
                                                   (PRETTYPRINT::prettysNone 
                                                    (cons 
                                                     (PRETTYPRINT::strings 
                                                      (cons 
                                                       (car (cdr pV24)) 
                                                       (cons "." (cons pV25 nil)))) 
                                                     nil))))) 
                                          (return 
                                           (PRETTYPRINT::prettysNone 
                                            (cons 
                                             (CGEN::parens-1 
                                              (CGEN::ppExp_internal 
                                               pV24 
                                               inOneLine)) 
                                             (cons 
                                              (PRETTYPRINT::strings 
                                               (cons "." (cons pV25 nil))) 
                                              nil))))))) 
                               (if (eq (car e) :|UnionRef|) 
                                   (let ((pV8 (cdr e))) 
                                     (return 
                                      (PRETTYPRINT::prettysNone 
                                       (cons 
                                        (CGEN::ppExp_internal 
                                         (car pV8) 
                                         inOneLine) 
                                        (cons 
                                         (PRETTYPRINT::strings 
                                          (cons "." (cons (cdr pV8) nil))) 
                                         nil))))) 
                                   (if (eq (car e) :|ArrayRef|) 
                                       (let ((pV7 (cdr e))) 
                                         (return 
                                          (PRETTYPRINT::prettysNone 
                                           (cons 
                                            (CGEN::ppExpRec (car pV7) inOneLine) 
                                            (cons 
                                             (PRETTYPRINT::|!string| "[") 
                                             (cons 
                                              (CGEN::ppExp_internal 
                                               (cdr pV7) 
                                               inOneLine) 
                                              (cons 
                                               (PRETTYPRINT::|!string| "]") 
                                               nil))))))) 
                                       (if (eq (car e) :|IfExp|) 
                                           (let ((pV6 (cdr e))) 
                                             (return 
                                              (funcall prettysLinear 
                                                       (cons 
                                                        (PRETTYPRINT::prettysNone 
                                                         (cons 
                                                          (CGEN::ppExpRec 
                                                           (svref pV6 0) 
                                                           inOneLine) 
                                                          (cons 
                                                           (PRETTYPRINT::|!string| 
                                                            " ? ") 
                                                           nil))) 
                                                        (cons 
                                                         (PRETTYPRINT::prettysNone 
                                                          (cons 
                                                           (CGEN::ppExpRec 
                                                            (svref pV6 1) 
                                                            inOneLine) 
                                                           (cons 
                                                            (PRETTYPRINT::|!string| 
                                                             " : ") 
                                                            nil))) 
                                                         (cons 
                                                          (CGEN::ppExpRec 
                                                           (svref pV6 2) 
                                                           inOneLine) 
                                                          nil)))))) 
                                           (if (eq (car e) :|Comma|) 
                                               (let ((pV5 (cdr e))) 
                                                 (return 
                                                  (CGEN::parens-1 
                                                   (funcall prettysFill_ 
                                                            (cons 
                                                             (CGEN::ppExp_internal 
                                                              (car pV5) 
                                                              inOneLine) 
                                                             (cons 
                                                              (PRETTYPRINT::|!string| 
                                                               ", ") 
                                                              (cons 
                                                               (CGEN::ppExp_internal 
                                                                (cdr pV5) 
                                                                inOneLine) 
                                                               nil))))))) 
                                               (if (eq (car e) :|SizeOfType|) 
                                                   (return 
                                                    (PRETTYPRINT::prettysNone 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       "sizeof (") 
                                                      (cons 
                                                       (CGEN::ppPlainType 
                                                        (cdr e)) 
                                                       (cons 
                                                        (PRETTYPRINT::|!string| 
                                                         ")") 
                                                        nil))))) 
                                                   (if (eq (car e) :|SizeOfExp|) 
                                                       (return 
                                                        (PRETTYPRINT::prettysNone 
                                                         (cons 
                                                          (PRETTYPRINT::|!string| 
                                                           "sizeof (") 
                                                          (cons 
                                                           (CGEN::ppExp_internal 
                                                            (cdr e) 
                                                            inOneLine) 
                                                           (cons 
                                                            (PRETTYPRINT::|!string| 
                                                             ")") 
                                                            nil))))) 
                                                       (if (eq (car e) :|Nop|) 
                                                           (return 
                                                            (PRETTYPRINT::prettysNone 
                                                             nil))))))))))))))) 
       (return (CGEN::failPretty "Unexpected expression"))))))

(defun CGEN::ppExp (e) (CGEN::ppExp_internal e nil))

(defun CGEN::ppAxiom (e) 
  (PRETTYPRINT::prettysAll 
   (cons 
    (CGEN::ppExp e) 
    (cons (PRETTYPRINT::emptyPretty) (cons (PRETTYPRINT::emptyPretty) nil)))))

(defun CGEN::ppBaseType-1 (x) (CGEN::ppBaseType (car x) (cdr x)))

(defun CGEN::ppBlock-1 (x) (CGEN::ppBlock (car x) (cdr x)))

(defun CGEN::ppInBlock (s) 
  (block 
   nil 
   (if (eq (car s) :|Block|) 
       (let ((pV3 (cdr s))) (return (CGEN::ppPlainBlock (car pV3) (cdr pV3))))) 
   (return (CGEN::ppStmt s))))

(defun CGEN::ppStmt (s) 
  (block 
   nil 
   (if (eq (car s) :|Exp|) 
       (return 
        (PRETTYPRINT::prettysNone 
         (cons (CGEN::ppExp (cdr s)) (cons (PRETTYPRINT::|!string| ";") nil)))) 
       (if (eq (car s) :|Block|) 
           (return (CGEN::ppBlock-1 (cdr s))) 
           (if (eq (car s) :|IfThen|) 
               (let ((pV10 (cdr s))) 
                 (return 
                  (PRETTYPRINT::blockAll 
                   0 
                   (cons 
                    (cons 
                     0 
                     (PRETTYPRINT::prettysNone 
                      (cons 
                       (PRETTYPRINT::|!string| "if (") 
                       (cons 
                        (CGEN::ppExp (car pV10)) 
                        (cons (PRETTYPRINT::|!string| ") {") nil))))) 
                    (cons 
                     (cons 2 (CGEN::ppInBlock (cdr pV10))) 
                     (cons (cons 0 (PRETTYPRINT::|!string| "}")) nil)))))) 
               (if (eq (car s) :|If|) 
                   (let ((pV9 (cdr s))) 
                     (return 
                      (PRETTYPRINT::blockAll 
                       0 
                       (cons 
                        (cons 
                         0 
                         (PRETTYPRINT::prettysNone 
                          (cons 
                           (PRETTYPRINT::|!string| "if (") 
                           (cons 
                            (CGEN::ppExp (svref pV9 0)) 
                            (cons (PRETTYPRINT::|!string| ") {") nil))))) 
                        (cons 
                         (cons 2 (CGEN::ppInBlock (svref pV9 1))) 
                         (cons 
                          (cons 0 (PRETTYPRINT::|!string| "} else {")) 
                          (cons 
                           (cons 2 (CGEN::ppInBlock (svref pV9 2))) 
                           (cons (cons 0 (PRETTYPRINT::|!string| "}")) nil)))))))) 
                   (if (eq (car s) :|Return|) 
                       (return 
                        (PRETTYPRINT::prettysNone 
                         (cons 
                          (PRETTYPRINT::|!string| "return ") 
                          (cons 
                           (CGEN::ppExp (cdr s)) 
                           (cons (PRETTYPRINT::|!string| ";") nil))))) 
                       (if (eq (car s) :|VoidReturn|) 
                           (return 
                            (PRETTYPRINT::prettysNone 
                             (cons 
                              (PRETTYPRINT::|!string| "return ") 
                              (cons (PRETTYPRINT::|!string| ";") nil)))) 
                           (if (eq (car s) :|Break|) 
                               (return (PRETTYPRINT::|!string| "break;")) 
                               (if (eq (car s) :|Nop|) 
                                   (return (PRETTYPRINT::|!string| ";")) 
                                   (if (eq (car s) :|While|) 
                                       (let ((pV7 (cdr s))) 
                                         (return 
                                          (PRETTYPRINT::blockAll 
                                           0 
                                           (cons 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::prettysNone 
                                              (cons 
                                               (PRETTYPRINT::|!string| "while (") 
                                               (cons 
                                                (CGEN::ppExp (car pV7)) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| ") {") 
                                                 nil))))) 
                                            (cons 
                                             (cons 2 (CGEN::ppInBlock (cdr pV7))) 
                                             (cons 
                                              (cons 
                                               0 
                                               (PRETTYPRINT::|!string| "}")) 
                                              nil)))))) 
                                       (if (eq (car s) :|Label|) 
                                           (return 
                                            (PRETTYPRINT::strings 
                                             (cons (cdr s) (cons ":" nil)))) 
                                           (if (eq (car s) :|Goto|) 
                                               (return 
                                                (PRETTYPRINT::strings 
                                                 (cons 
                                                  "goto " 
                                                  (cons (cdr s) (cons ";" nil))))) 
                                               (if (eq (car s) :|Switch|) 
                                                   (let ((pV4 (cdr s))) 
                                                     (return 
                                                      (PRETTYPRINT::blockAll 
                                                       0 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (PRETTYPRINT::prettysNone 
                                                          (cons 
                                                           (PRETTYPRINT::|!string| 
                                                            "switch (") 
                                                           (cons 
                                                            (CGEN::ppExp 
                                                             (car pV4)) 
                                                            (cons 
                                                             (PRETTYPRINT::|!string| 
                                                              ") {") 
                                                             nil))))) 
                                                        (cons 
                                                         (cons 
                                                          2 
                                                          (CGEN::ppStmts 
                                                           (cdr pV4))) 
                                                         (cons 
                                                          (cons 
                                                           0 
                                                           (PRETTYPRINT::|!string| 
                                                            "}")) 
                                                          nil)))))) 
                                                   (if (eq (car s) :|Case|) 
                                                       (return 
                                                        (PRETTYPRINT::prettysNone 
                                                         (cons 
                                                          (PRETTYPRINT::|!string| 
                                                           "case ") 
                                                          (cons 
                                                           (CGEN::ppConst 
                                                            (cdr s)) 
                                                           (cons 
                                                            (PRETTYPRINT::|!string| 
                                                             ":") 
                                                            nil)))))))))))))))))) 
   (return (CGEN::failPretty "Unexpected statement"))))

(defun CGEN::ppStmts (ss) 
  (PRETTYPRINT::prettysAll (LIST-SPEC::|!map|-1-1 #'CGEN::ppStmt ss)))

(defun CGEN::ppVarDecl (s |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons (CGEN::ppArg s |!t|) (cons (PRETTYPRINT::|!string| ";") nil))))

(defun CGEN::ppVarDecl-1 (x) (CGEN::ppVarDecl (car x) (cdr x)))

(defun CGEN::ppVarDecls (vds) 
  (PRETTYPRINT::prettysAll (LIST-SPEC::|!map|-1-1 #'CGEN::ppVarDecl-1 vds)))

(defun CGEN::ppPlainBlock (vds ss) 
  (if (LIST-SPEC::|!null| vds) 
      (CGEN::ppStmts ss) 
      (PRETTYPRINT::prettysAll 
       (cons (CGEN::ppVarDecls vds) (cons (CGEN::ppStmts ss) nil)))))

(defun CGEN::ppBlock (vds ss) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::|!string| "{")) 
    (cons 
     (cons 2 (CGEN::ppPlainBlock vds ss)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "}")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))

(defun CGEN::ppDefine (s) (PRETTYPRINT::strings (cons "#define " (cons s nil))))

(defun CGEN::ppExtVar (s |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons (PRETTYPRINT::|!string| "extern ") (cons (CGEN::ppVarDecl s |!t|) nil))))


(defun CGEN::ppExtVar-1 (x) (CGEN::ppExtVar (car x) (cdr x)))

(defun CGEN::ppFn (s ts |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (CGEN::ppType 
     |!t| 
     (PRETTYPRINT::prettysFill 
      (cons 
       (PRETTYPRINT::strings (cons " " (cons s (cons " " nil)))) 
       (cons (CGEN::ppPlainTypes ts) nil)))) 
    (cons (PRETTYPRINT::|!string| ";") nil))))

(defun CGEN::ppFn-1 (x) (CGEN::ppFn (svref x 0) (svref x 1) (svref x 2)))

(defun CGEN::ppFnDefn (s vds |!t| b) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 
     0 
     (PRETTYPRINT::prettysNone 
      (cons 
       (CGEN::ppType 
        |!t| 
        (PRETTYPRINT::prettysFill 
         (cons 
          (PRETTYPRINT::strings (cons " " (cons s (cons " " nil)))) 
          (cons (CGEN::ppArgs vds) nil)))) 
       (cons (PRETTYPRINT::|!string| " {") nil)))) 
    (cons 
     (cons 2 (CGEN::ppInBlock b)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "}")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))

(defun CGEN::ppFnDefn-1 (x) 
  (CGEN::ppFnDefn (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun CGEN::ppInclude (s) 
  (PRETTYPRINT::prettysAll 
   (cons 
    (PRETTYPRINT::strings (cons "#include \"" (cons s (cons "\"" nil)))) 
    (cons (PRETTYPRINT::emptyPretty) nil))))

(defun CGEN::ppStructDefn (s vds) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::strings (cons "struct " (cons s (cons " {" nil))))) 
    (cons 
     (cons 2 (CGEN::ppVarDecls vds)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "};")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))

(defun CGEN::ppStructDefn-1 (x) (CGEN::ppStructDefn (car x) (cdr x)))

(defun CGEN::ppTypeDefn (s |!t|) 
  (let ((pp 
         (PRETTYPRINT::prettysNone 
          (cons 
           (PRETTYPRINT::|!string| "typedef ") 
           (cons (CGEN::ppVarDecl s |!t|) nil))))) 
    (block 
     nil 
     (if (eq (car |!t|) :|Base|) 
         (if (string=  "Any" (cdr |!t|)) 
             (return 
              (PRETTYPRINT::blockAll 
               0 
               (cons 
                (cons 
                 0 
                 (PRETTYPRINT::strings 
                  (cons 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ "#ifndef " s) 
                    "_is_externally_defined") 
                   nil))) 
                (cons 
                 (cons 0 pp) 
                 (cons (cons 0 (PRETTYPRINT::|!string| "#endif")) nil))))))) 
     (return pp))))

(defun CGEN::ppTypeDefn-1 (x) (CGEN::ppTypeDefn (car x) (cdr x)))

(defun CGEN::ppUnionDefn (s vds) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::strings (cons "union " (cons s (cons " {" nil))))) 
    (cons 
     (cons 2 (CGEN::ppVarDecls vds)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "};")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))

(defun CGEN::ppUnionDefn-1 (x) (CGEN::ppUnionDefn (car x) (cdr x)))

(defun CGEN::ppVar (s |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons (PRETTYPRINT::|!string| "static ") (cons (CGEN::ppVarDecl s |!t|) nil))))


(defun CGEN::ppVar-1 (x) (CGEN::ppVar (car x) (cdr x)))

(defun CGEN::ppVarDefn (s |!t| e) 
  (if (slang-built-in::slang-term-equals e '(:|Nop|)) 
      (CGEN::ppVarDecl s |!t|) 
      (PRETTYPRINT::blockFill 
       0 
       (cons 
        (cons 
         0 
         (PRETTYPRINT::prettysNone 
          (cons 
           (PRETTYPRINT::|!string| "static ") 
           (cons 
            (CGEN::ppType |!t| (PRETTYPRINT::strings (cons " " (cons s nil)))) 
            (cons (PRETTYPRINT::|!string| " = ") nil))))) 
        (cons 
         (cons 
          2 
          (PRETTYPRINT::prettysNone 
           (cons (CGEN::ppExp e) (cons (PRETTYPRINT::|!string| ";") nil)))) 
         nil)))))

(defun CGEN::ppVarDefn-1 (x) 
  (CGEN::ppVarDefn (svref x 0) (svref x 1) (svref x 2)))

(defun CGEN::ppExpInOneLine (e) (CGEN::ppExp_internal e t))

(defun PRETTYPRINT::newline () 
  (PRETTYPRINT::prettysAll 
   (cons (PRETTYPRINT::emptyPretty) (cons (PRETTYPRINT::emptyPretty) nil))))

(defun CGEN::ppVarDefnAsDefine (s pV1 e) 
  (declare (ignore pV1)) 
  (PRETTYPRINT::blockNone 
   0 
   (cons 
    (cons 
     0 
     (PRETTYPRINT::prettysNone 
      (cons 
       (PRETTYPRINT::|!string| "#define ") 
       (cons (PRETTYPRINT::|!string| s) (cons (PRETTYPRINT::|!string| " ") nil))))) 
    (cons 
     (cons 2 (PRETTYPRINT::prettysNone (cons (CGEN::ppExpInOneLine e) nil))) 
     (cons (cons 0 (PRETTYPRINT::newline)) nil)))))

(defun CGEN::ppVarDefnAsDefine-1 (x) 
  (CGEN::ppVarDefnAsDefine (svref x 0) (svref x 1) (svref x 2)))

(defun CGEN::section (title ps) 
  (if (LIST-SPEC::|!null| ps) 
      nil 
      (cons 
       (PRETTYPRINT::emptyPretty) 
       (cons (PRETTYPRINT::|!string| title) (cons (PRETTYPRINT::emptyPretty) ps)))))


(defparameter TOPSORT::mkLeaf '(:|Leaf|))

(defun TOPSORT::dfs (test g vs) 
  (let ((|!t| (HASHTABLE-SPEC::initialize test (LIST-SPEC::|!length| vs)))) 
    (labels 
      ((dfsLoop (vs) 
        (block 
         nil 
         (if (null vs) 
             (return TOPSORT::mkLeaf) 
             (if (consp vs) 
                 (let ((pV8 (cdr vs))
                       (pV7 (car vs))) 
                   (return 
                    (if (marked pV7) 
                        (dfsLoop pV8) 
                        (progn (mark pV7) 
                               (let ((ps (dfsLoop (funcall g pV7)))) 
                                 (let ((qs (dfsLoop pV8))) 
                                   (cons :|Node| (vector pV7 ps qs)))))))))) 
         (error "Nonexhaustive match failure in dfs")))
       (marked (v) 
        (let ((pV2 (HASHTABLE-SPEC::lookup v |!t|))) 
          (block 
           nil 
           (if (eq (car pV2) :|Some|) 
               (return t) 
               (if (eq (car pV2) :|None|) (return nil))) 
           (error "Nonexhaustive match failure in dfs"))))
       (mark (v) (HASHTABLE-SPEC::insert v nil |!t|))) (dfsLoop vs))))

(defun TOPSORT::inorderL (|!t| ls) 
  (block 
   nil 
   (if (eq (car |!t|) :|Leaf|) 
       (return ls) 
       (if (eq (car |!t|) :|Node|) 
           (let ((pV2 (cdr |!t|))) 
             (return 
              (TOPSORT::inorderL 
               (svref pV2 1) 
               (LIST-SPEC::|!cons| 
                (svref pV2 0) 
                (TOPSORT::inorderL (svref pV2 2) ls))))))) 
   (error "Nonexhaustive match failure in inorderL")))

(defun TOPSORT::inorder (|!t|) (TOPSORT::inorderL |!t| nil))

(defun TOPSORT::topSort (test g vs) (TOPSORT::inorder (TOPSORT::dfs test g vs)))

(defun CGEN::topSortTypeDefns (defns) 
  (let ((names (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) defns))) 
    (let ((sortedNames 
           (TOPSORT::topSort 
            '(:|EQUAL|) 
            #'(lambda (name) (CGEN::expand name defns)) 
            names))) (CGEN::findTypeDefns sortedNames defns))))

(defun CGEN::ppCSpec-1 (s) 
  (let ((typeDefns (CGEN::topSortTypeDefns (svref s 8)))) 
    (let ((includes (LIST-SPEC::|!map|-1-1 #'CGEN::ppInclude (svref s 6)))) 
      (let ((defines (LIST-SPEC::|!map|-1-1 #'CGEN::ppDefine (svref s 2)))) 
        (let ((constDefns 
               (LIST-SPEC::|!map|-1-1 #'CGEN::ppVarDefnAsDefine-1 (svref s 1)))) 
          (let ((typeDefns 
                 (LIST-SPEC::|!map|-1-1 #'CGEN::ppTypeDefn-1 typeDefns))) 
            (let ((structDefns 
                   (LIST-SPEC::|!map|-1-1 #'CGEN::ppStructDefn-1 (svref s 7)))) 
              (let ((unionDefns 
                     (LIST-SPEC::|!map|-1-1 #'CGEN::ppUnionDefn-1 (svref s 9)))) 
                (let ((vars (LIST-SPEC::|!map|-1-1 #'CGEN::ppVar-1 (svref s 11)))) 
                  (let ((extVars 
                         (LIST-SPEC::|!map|-1-1 #'CGEN::ppExtVar-1 (svref s 3)))) 
                    (let ((fns 
                           (LIST-SPEC::|!map|-1-1 #'CGEN::ppFn-1 (svref s 5)))) 
                      (let ((varDefns 
                             (LIST-SPEC::|!map|-1-1 
                              #'CGEN::ppVarDefn-1 
                              (svref s 10)))) 
                        (let ((fnDefns 
                               (LIST-SPEC::|!map|-1-1 
                                #'CGEN::ppFnDefn-1 
                                (svref s 4)))) 
                          (let ((axioms 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'CGEN::ppAxiom 
                                  (svref s 0)))) 
                            (PRETTYPRINT::prettysAll 
                             (LIST-SPEC::|!++| 
                              (LIST-SPEC::|!++| 
                               (LIST-SPEC::|!++| 
                                (LIST-SPEC::|!++| 
                                 (LIST-SPEC::|!++| 
                                  (LIST-SPEC::|!++| 
                                   (LIST-SPEC::|!++| 
                                    (LIST-SPEC::|!++| 
                                     (LIST-SPEC::|!++| 
                                      (LIST-SPEC::|!++| 
                                       (LIST-SPEC::|!++| 
                                        (LIST-SPEC::|!++| 
                                         (LIST-SPEC::|!++| 
                                          (CGEN::section "/* C spec */" nil) 
                                          (CGEN::section 
                                           "/* Include files */" 
                                           includes)) 
                                         (CGEN::section 
                                          "/* Definitions */" 
                                          defines)) 
                                        (CGEN::section 
                                         "/* Constant Definitions */" 
                                         constDefns)) 
                                       (CGEN::section "/* Types */" typeDefns)) 
                                      (CGEN::section "/* Unions */" unionDefns)) 
                                     (CGEN::section "/* Structs */" structDefns)) 
                                    (CGEN::section "/* Variables */" vars)) 
                                   (CGEN::section 
                                    "/* External Variables */" 
                                    extVars)) 
                                  (CGEN::section "/* Functions */" fns)) 
                                 (CGEN::section 
                                  "/* Variable definitions */" 
                                  varDefns)) 
                                (CGEN::section 
                                 "/* Function definitions */" 
                                 fnDefns)) 
                               (CGEN::section "/* Axioms */" axioms)) 
                              (cons (PRETTYPRINT::emptyPretty) nil)))))))))))))))))


(defun CGEN::ppCSpec (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::ppCSpec-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))

(defun CGEN::ppCSpecAsHeader (name s) 
  (let ((defname 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           "__METASLANG_" 
           (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase name)) 
          "_H"))) 
    (PRETTYPRINT::prettysAll 
     (LIST-SPEC::|!++| 
      (LIST-SPEC::|!++| 
       (LIST-SPEC::|!++| 
        (LIST-SPEC::|!++| 
         (LIST-SPEC::|!++| 
          (cons (PRETTYPRINT::emptyPretty) nil) 
          (cons (PRETTYPRINT::strings (cons "#ifndef " (cons defname nil))) nil)) 
         (cons (PRETTYPRINT::strings (cons "#define " (cons defname nil))) nil)) 
        (cons (CGEN::ppCSpec-1 s) nil)) 
       (cons (PRETTYPRINT::|!string| "#endif") nil)) 
      (cons (PRETTYPRINT::emptyPretty) nil)))))

(defun CGEN::ppCSpecAsHeader-1 (x) (CGEN::ppCSpecAsHeader (car x) (cdr x)))

(defun CGEN::ppDeclsWithoutDefns (decls) 
  (block 
   nil 
   (if (null decls) (return (PRETTYPRINT::emptyPretty))) 
   (return 
    (PRETTYPRINT::prettysAll 
     (LIST-SPEC::|!++| 
      (LIST-SPEC::|!++| 
       (LIST-SPEC::|!++| 
        (LIST-SPEC::|!++| 
         (cons (PRETTYPRINT::emptyPretty) nil) 
         (cons 
          (PRETTYPRINT::|!string| 
           "/* no code has been generated for the following functions: ") 
          nil)) 
        (LIST-SPEC::|!map|-1-1 #'CGEN::ppFn-1 decls)) 
       (cons (PRETTYPRINT::emptyPretty) nil)) 
      (cons (PRETTYPRINT::|!string| "*/") nil))))))

(defun CGEN::ppExpRec-1 (x) (CGEN::ppExpRec (car x) (cdr x)))

(defun CGEN::ppExp_internal-1 (x) (CGEN::ppExp_internal (car x) (cdr x)))

(defun CGEN::ppExps (es) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'CGEN::ppExp es)))

(defun CGEN::ppFnDefnAppendFile (fndefn filename) 
  (let ((fnPretty (CGEN::ppFnDefn-1 fndefn))) 
    (PRETTYPRINT::appendFile filename (PRETTYPRINT::|!format| 80 fnPretty))))

(defun CGEN::ppFnDefnAppendFile-1 (x) 
  (CGEN::ppFnDefnAppendFile (car x) (cdr x)))

(defun CGEN::ppPlainBlock-1 (x) (CGEN::ppPlainBlock (car x) (cdr x)))

(defun CGEN::ppType-1 (x) (CGEN::ppType (car x) (cdr x)))

(defun CGEN::section-1 (x) (CGEN::section (car x) (cdr x)))

(defun CGEN::termToCStmt (trm) 
  (block 
   nil 
   (if (eq (car trm) :|Apply|) 
       (let ((pV6 (cdr trm))) 
         (let ((pV8 (svref pV6 1))
               (pV7 (svref pV6 0))) 
           (if (eq (car pV7) :|Fun|) 
               (if (eq (car (svref (cdr pV7) 0)) :|Equals|) 
                   (if (eq (car pV8) :|Record|) 
                       (let ((pV15 (car (cdr pV8)))) 
                         (if (consp pV15) 
                             (let ((pV19 (cdr pV15))
                                   (pV18 (car pV15))) 
                               (if (string=  "1" (car pV18)) 
                                   (if (consp pV19) 
                                       (let ((pV23 (car pV19))) 
                                         (if (string=  "2" (car pV23)) 
                                             (if (null (cdr pV19)) 
                                                 (return 
                                                  (cons 
                                                   :|Exp| 
                                                   (cons 
                                                    :|Apply| 
                                                    (cons 
                                                     (cons :|Binary| '(:|Set|)) 
                                                     (cons 
                                                      (CGEN::termToCExp 
                                                       (cdr pV18)) 
                                                      (cons 
                                                       (CGEN::termToCExp 
                                                        (cdr pV23)) 
                                                       nil)))))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "termToCStmt: term '" (ANNSPECPRINTER::printTerm trm)) 
      "' is not an equality")))))

(defun CGEN::specToC-1 (spc) 
  (let ((cSpec (CGEN::generateCTypes-1-1 CGEN::emptyCSpec spc))) 
    (let ((cSpec (CGEN::generateCVars-1-1 cSpec spc))) 
      (let ((cSpec (CGEN::generateCFunctions-1-1 cSpec spc))) 
        (let ((stmt 
               (cons 
                :|Block| 
                (cons 
                 nil 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) (CGEN::termToCStmt (svref x 3))) 
                  (svref spc 2)))))) 
          (let ((cSpec 
                 (CGEN::addFuncDefn-1-1-1-1-1 cSpec "main" nil '(:|Int|) stmt))) 
            (progn (STRING-SPEC::writeLine 
                    (PRETTYPRINT::toString 
                     (PRETTYPRINT::|!format| 80 (CGEN::ppCSpec-1 cSpec)))) 
                   cSpec)))))))

(defun CGEN::specToC (x0 x1 x2 x3) (CGEN::specToC-1 (vector x0 x1 x2 x3)))

(defun CAT::functor-1 (dgm) (car dgm))

(defun CAT::shape-1 (dgm) (cdr dgm))

(defun FUNCTOR::cod-1 (functor) (svref functor 0))

(defun FUNCTOR::dom-1 (functor) (svref functor 1))

(defun FUNCTOR::edgeMap-1 (functor) (svref functor 2))

(defun FUNCTOR::vertexMap-1 (functor) (svref functor 3))

(defun POLYSET::member?-1-1 (l x) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (return 
            (cl:or 
             (slang-built-in::slang-term-equals (car l) x) 
             (POLYSET::member?-1-1 (cdr l) x))))) 
   (error "Nonexhaustive match failure in member?")))

(defun POLYSET::insert-1-1 (l a) (if (POLYSET::member?-1-1 l a) l (cons a l)))

(defun EDGE::insert-1-1 (x0 x1) (POLYSET::insert-1-1 x0 x1))

(defun SKETCH::edges-1 (graph) (svref graph 0))

(defun SKETCH::src-1 (graph) (svref graph 1))

(defun SKETCH::target-1 (graph) (svref graph 2))

(defun POLYMAP::update-1-1-1 (|!map| x y) 
  (block 
   nil 
   (if (null |!map|) 
       (return (cons (cons x y) nil)) 
       (if (consp |!map|) 
           (let ((pV3 (car |!map|))
                 (pV4 (cdr |!map|))) 
             (let ((pV5 (car pV3))) 
               (return 
                (if (slang-built-in::slang-term-equals x pV5) 
                    (cons (cons x y) pV4) 
                    (cons (cons pV5 (cdr pV3)) (POLYMAP::update-1-1-1 pV4 x y)))))))) 
   (error "Nonexhaustive match failure in update")))

(defun SKETCH::update-1-1-1 (x0 x1 x2) (POLYMAP::update-1-1-1 x0 x1 x2))

(defun SKETCH::vertices-1 (graph) (svref graph 3))

(defun VERTEX::insert-1-1 (x0 x1) (POLYSET::insert-1-1 x0 x1))

(defun SKETCH::insertEdge-1-1-1-1 (graph edge dom cod) 
  (vector 
   (EDGE::insert-1-1 (SKETCH::edges-1 graph) edge) 
   (SKETCH::update-1-1-1 (SKETCH::src-1 graph) edge dom) 
   (SKETCH::update-1-1-1 (SKETCH::target-1 graph) edge cod) 
   (VERTEX::insert-1-1 (VERTEX::insert-1-1 (SKETCH::vertices-1 graph) dom) cod)))


(defun CAT::addEdge-1-1-1-1 (dgm edge src target) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (SKETCH::insertEdge-1-1-1-1 
     (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
     edge 
     src 
     target) 
    (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm))) 
   (SKETCH::insertEdge-1-1-1-1 (CAT::shape-1 dgm) edge src target)))

(defun CAT::addEdge-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) #'(lambda (x4) (CAT::addEdge-1-1-1-1 x1 x2 x3 x4)))))

(defun CAT::addEdge (x0 x1) (CAT::addEdge-1 (cons x0 x1)))

(defun SKETCH::insertVertex-1-1 (graph vertex) 
  (vector 
   (SKETCH::edges-1 graph) 
   (SKETCH::src-1 graph) 
   (SKETCH::target-1 graph) 
   (VERTEX::insert-1-1 (SKETCH::vertices-1 graph) vertex)))

(defun CAT::addVertex-1-1 (dgm vertex) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (SKETCH::insertVertex-1-1 (FUNCTOR::dom-1 (CAT::functor-1 dgm)) vertex) 
    (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm))) 
   (SKETCH::insertVertex-1-1 (CAT::shape-1 dgm) vertex)))

(defun CAT::addVertex-1 (x1) #'(lambda (x2) (CAT::addVertex-1-1 x1 x2)))

(defun CAT::addVertex (x0 x1) (CAT::addVertex-1 (cons x0 x1)))

(defun CAT::apex-1 (cocone) (svref cocone 0))

(defun CAT::apex (x0 x1 x2) (CAT::apex-1 (vector x0 x1 x2)))

(defun CAT::cocone-1 (initCocone) (car initCocone))

(defun CAT::cocone (x0 x1) (CAT::cocone-1 (cons x0 x1)))

(defun CAT::cod-1 (cat) (svref cat 0))

(defun CAT::cod (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::cod-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::cod-1-1 (x1 x2) (funcall (CAT::cod-1 x1) x2))

(defun CAT::colimit-1 (cat) (svref cat 1))

(defun CAT::colimit (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::colimit-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::colimit-1-1 (x1 x2) (funcall (CAT::colimit-1 x1) x2))

(defun CAT::compose-1 (cat) (svref cat 2))

(defun CAT::compose (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::compose-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::compose-1-1-1 (x1 x2 x3) 
  (funcall (funcall (CAT::compose-1 x1) x2) x3))

(defun CAT::diagram-1 (cocone) (svref cocone 1))

(defun CAT::diagram (x0 x1 x2) (CAT::diagram-1 (vector x0 x1 x2)))

(defun CAT::dom-1 (cat) (svref cat 3))

(defun CAT::dom (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::dom-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::dom-1-1 (x1 x2) (funcall (CAT::dom-1 x1) x2))

(defun EDGE::member?-1-1 (x0 x1) (POLYSET::member?-1-1 x0 x1))

(defun CAT::edgeInDiagram?-1-1 (dgm edge) 
  (EDGE::member?-1-1 (SKETCH::edges-1 (CAT::shape-1 dgm)) edge))

(defun CAT::edgeInDiagram?-1 (x1) 
  #'(lambda (x2) (CAT::edgeInDiagram?-1-1 x1 x2)))

(defun CAT::edgeInDiagram? (x0 x1) (CAT::edgeInDiagram?-1 (cons x0 x1)))

(defun POLYMAP::|!eval|-1-1 (|!map| x) 
  (block 
   nil 
   (if (null |!map|) 
       (return (SYSTEM-SPEC::fail "inside eval")) 
       (if (consp |!map|) 
           (let ((pV3 (car |!map|))) 
             (return 
              (if (slang-built-in::slang-term-equals x (car pV3)) 
                  (cdr pV3) 
                  (POLYMAP::|!eval|-1-1 (cdr |!map|) x)))))) 
   (error "Nonexhaustive match failure in eval")))

(defun CAT::edgeLabel-1-1 (dgm edge) 
  (POLYMAP::|!eval|-1-1 (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) edge))

(defun CAT::edgeLabel-1 (x1) #'(lambda (x2) (CAT::edgeLabel-1-1 x1 x2)))

(defun CAT::edgeLabel (x0 x1) (CAT::edgeLabel-1 (cons x0 x1)))

(defparameter POLYMAP::emptyMap nil)

(defparameter POLYSET::empty nil)

(defparameter EDGE::empty POLYSET::empty)

(defparameter SKETCH::emptyMap POLYMAP::emptyMap)

(defparameter VERTEX::empty POLYSET::empty)

(defparameter SKETCH::emptySketch 
  (vector EDGE::empty SKETCH::emptyMap SKETCH::emptyMap VERTEX::empty))

(defun CAT::emptyDiagram-1 (targetCat) 
  (cons 
   (vector targetCat SKETCH::emptySketch POLYMAP::emptyMap POLYMAP::emptyMap) 
   SKETCH::emptySketch))

(defun CAT::initialObject-1 (cat) (svref cat 5))

(defun FUNCTOR::makeFunctor-1-1-1-1 (sketch cat vertexMap edgeMap) 
  (vector cat sketch edgeMap vertexMap))

(defun FUNCTOR::emptyFunctor-1 (targetCat) 
  (FUNCTOR::makeFunctor-1-1-1-1 
   SKETCH::emptySketch 
   targetCat 
   POLYMAP::emptyMap 
   POLYMAP::emptyMap))

(defun NATTRANS::emptyNatTrans-1 (targetCat) 
  (vector 
   (FUNCTOR::emptyFunctor-1 targetCat) 
   POLYMAP::emptyMap 
   (FUNCTOR::emptyFunctor-1 targetCat)))

(defun CAT::emptyCocone-1 (targetCat) 
  (vector 
   (CAT::initialObject-1 targetCat) 
   (CAT::emptyDiagram-1 targetCat) 
   (NATTRANS::emptyNatTrans-1 targetCat)))

(defun CAT::emptyCocone (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::emptyCocone-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::emptyDiagram (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::emptyDiagram-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::ident-1 (cat) (svref cat 4))

(defun CAT::ident-1-1 (x1 x2) (funcall (CAT::ident-1 x1) x2))

(defun CAT::emptyInitialCocone-1 (targetCat) 
  (cons 
   (CAT::emptyCocone-1 targetCat) 
   #'(lambda (pV1) 
      (declare (ignore pV1)) 
      (CAT::ident-1-1 targetCat (CAT::initialObject-1 targetCat)))))

(defun CAT::emptyInitialCocone (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::emptyInitialCocone-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun POLYSET::fold-1-1-1 (f e l) 
  (block 
   nil 
   (if (null l) 
       (return e) 
       (if (consp l) 
           (return 
            (POLYSET::fold-1-1-1 f (funcall (funcall f e) (car l)) (cdr l))))) 
   (error "Nonexhaustive match failure in fold")))

(defun EDGE::fold-1-1-1 (x0 x1 x2) (POLYSET::fold-1-1-1 x0 x1 x2))

(defun CAT::foldOverEdges-1-1-1 (f acc dgm) 
  (EDGE::fold-1-1-1 f acc (SKETCH::edges-1 (CAT::shape-1 dgm))))

(defun CAT::foldOverEdges (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::foldOverEdges-1-1-1 x1 x2 x3))))

(defun VERTEX::fold-1-1-1 (x0 x1 x2) (POLYSET::fold-1-1-1 x0 x1 x2))

(defun CAT::foldOverVertices-1-1-1 (f acc dgm) 
  (VERTEX::fold-1-1-1 f acc (SKETCH::vertices-1 (CAT::shape-1 dgm))))

(defun CAT::foldOverVertices (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::foldOverVertices-1-1-1 x1 x2 x3))))

(defun CAT::functor (x0 x1) (CAT::functor-1 (cons x0 x1)))

(defun CAT::ident (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::ident-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::initialObject (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::initialObject-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::labelEdge-1-1-1 (dgm edge label) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
    (POLYMAP::update-1-1-1 (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) edge label) 
    (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm))) 
   (CAT::shape-1 dgm)))

(defun CAT::labelEdge-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::labelEdge-1-1-1 x1 x2 x3))))

(defun CAT::labelEdge (x0 x1) (CAT::labelEdge-1 (cons x0 x1)))

(defun CAT::labelVertex-1-1-1 (dgm vertex label) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) 
    (POLYMAP::update-1-1-1 
     (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm)) 
     vertex 
     label)) 
   (CAT::shape-1 dgm)))

(defun CAT::labelVertex-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::labelVertex-1-1-1 x1 x2 x3))))

(defun CAT::labelVertex (x0 x1) (CAT::labelVertex-1 (cons x0 x1)))

(defun POLYMAP::mapMap-1-1 (f |!map|) 
  (block 
   nil 
   (if (null |!map|) 
       (return nil) 
       (if (consp |!map|) 
           (let ((pV3 (car |!map|))) 
             (return 
              (cons 
               (cons (car pV3) (funcall f (cdr pV3))) 
               (POLYMAP::mapMap-1-1 f (cdr |!map|))))))) 
   (error "Nonexhaustive match failure in mapMap")))

(defun CAT::mapDiagram-1-1-1 (dgm objMap arrMap) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
    (POLYMAP::mapMap-1-1 arrMap (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm))) 
    (POLYMAP::mapMap-1-1 objMap (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm)))) 
   (CAT::shape-1 dgm)))

(defun CAT::mapDiagram-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::mapDiagram-1-1-1 x1 x2 x3))))

(defun CAT::mapDiagram (x0 x1) (CAT::mapDiagram-1 (cons x0 x1)))

(defun CAT::natTrans-1 (cocone) (svref cocone 2))

(defun CAT::natTrans (x0 x1 x2) (CAT::natTrans-1 (vector x0 x1 x2)))

(defun CAT::ppArr-1 (cat) (svref cat 6))

(defun CAT::ppArr (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::ppArr-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::ppArr-1-1 (x1 x2) (funcall (CAT::ppArr-1 x1) x2))

(defun CAT::ppObj-1 (cat) (svref cat 7))

(defun WADLERLINDIG::ppString (s) (cons :|DocText| s))

(defun EDGE::ppElem (x) (WADLERLINDIG::ppString x))

(defun POLYMAP::foldMap-1-1-1 (f z |!map|) 
  (block 
   nil 
   (if (null |!map|) 
       (return z) 
       (if (consp |!map|) 
           (let ((pV3 (car |!map|))) 
             (return 
              (POLYMAP::foldMap-1-1-1 
               f 
               (funcall (funcall (funcall f z) (car pV3)) (cdr pV3)) 
               (cdr |!map|)))))) 
   (error "Nonexhaustive match failure in foldMap")))

(defun WADLERLINDIG::ppCons-1-1 (x y) 
  (block 
   nil 
   (if (eq (car x) :|DocNil|) 
       (progn (if (eq (car y) :|DocNil|) (return '(:|DocNil|))) (return y))) 
   (if (eq (car y) :|DocNil|) (return x)) 
   (return (cons :|DocCons| (cons x y)))))

(defparameter WADLERLINDIG::ppNil '(:|DocNil|))

(defun WADLERLINDIG::ppConcat (l) 
  (block 
   nil 
   (if (null l) 
       (return WADLERLINDIG::ppNil) 
       (if (consp l) 
           (return 
            (WADLERLINDIG::ppCons-1-1 (car l) (WADLERLINDIG::ppConcat (cdr l)))))) 
   (error "Nonexhaustive match failure in ppConcat")))

(defparameter WADLERLINDIG::ppBreak (cons :|DocBreak| " "))

(defparameter WADLERLINDIG::ppNewline WADLERLINDIG::ppBreak)

(defun WADLERLINDIG::ppSep-1-1 (sep l) 
  (block 
   nil 
   (if (null l) 
       (return WADLERLINDIG::ppNil) 
       (if (consp l) 
           (let ((pV3 (car l))
                 (pV4 (cdr l))) 
             (progn (if (null pV4) (return pV3)) 
                    (if (eq (car pV3) :|DocNil|) 
                        (return (WADLERLINDIG::ppSep-1-1 sep pV4))) 
                    (return 
                     (WADLERLINDIG::ppCons-1-1 
                      pV3 
                      (WADLERLINDIG::ppCons-1-1 
                       sep 
                       (WADLERLINDIG::ppSep-1-1 sep pV4)))))))) 
   (error "Nonexhaustive match failure in ppSep")))

(defun POLYMAP::ppMap-1-1-1 (ppKey ppValue |!map|) 
  (WADLERLINDIG::ppSep-1-1 
   WADLERLINDIG::ppNewline 
   (POLYMAP::foldMap-1-1-1 
    #'(lambda (l) 
       #'(lambda (dom) 
          #'(lambda (cod) 
             (cons 
              (WADLERLINDIG::ppConcat 
               (cons 
                (funcall ppKey dom) 
                (cons 
                 (WADLERLINDIG::ppString " +-> ") 
                 (cons (funcall ppValue cod) nil)))) 
              l)))) 
    nil 
    |!map|)))

(defun VERTEX::ppElem (x) (WADLERLINDIG::ppString x))

(defun WADLERLINDIG::ppNest-1-1 (i x) (cons :|DocNest| (cons i x)))

(defun WADLERLINDIG::ppIndent (p) (WADLERLINDIG::ppNest-1-1 2 p))

(defun FUNCTOR::ppFunctor-1 (functor) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "Vertex Map =") 
    (cons 
     WADLERLINDIG::ppNewline 
     (cons 
      (WADLERLINDIG::ppString "  ") 
      (cons 
       (WADLERLINDIG::ppIndent 
        (POLYMAP::ppMap-1-1-1 
         #'VERTEX::ppElem 
         (CAT::ppObj-1 (FUNCTOR::cod-1 functor)) 
         (FUNCTOR::vertexMap-1 functor))) 
       (cons 
        WADLERLINDIG::ppNewline 
        (cons 
         (WADLERLINDIG::ppString "Edge Map =") 
         (cons 
          WADLERLINDIG::ppNewline 
          (cons 
           (WADLERLINDIG::ppString "  ") 
           (cons 
            (WADLERLINDIG::ppIndent 
             (POLYMAP::ppMap-1-1-1 
              #'EDGE::ppElem 
              (CAT::ppArr-1 (FUNCTOR::cod-1 functor)) 
              (FUNCTOR::edgeMap-1 functor))) 
            nil)))))))))))

(defun EDGE::ppSet (|!set|) 
  (WADLERLINDIG::ppSep-1-1 
   (WADLERLINDIG::ppString ",") 
   (EDGE::fold-1-1-1 
    #'(lambda (l) #'(lambda (elem) (cons (EDGE::ppElem elem) l))) 
    nil 
    |!set|)))

(defun POLYMAP::mapToList (l) l)

(defun SKETCH::mapToList (x) (POLYMAP::mapToList x))

(defun VERTEX::ppSet (|!set|) 
  (WADLERLINDIG::ppSep-1-1 
   (WADLERLINDIG::ppString ",") 
   (VERTEX::fold-1-1-1 
    #'(lambda (l) #'(lambda (elem) (cons (VERTEX::ppElem elem) l))) 
    nil 
    |!set|)))

(defun SKETCH::ppSketch-1 (graph) 
  (labels 
    ((ppPair (x y) 
      (WADLERLINDIG::ppConcat 
       (cons 
        (EDGE::ppElem x) 
        (cons (WADLERLINDIG::ppString "|->") (cons (VERTEX::ppElem y) nil)))))) 
    (WADLERLINDIG::ppConcat 
     (cons 
      (WADLERLINDIG::ppString "Vertices = {") 
      (cons 
       (VERTEX::ppSet (SKETCH::vertices-1 graph)) 
       (cons 
        (WADLERLINDIG::ppString "}") 
        (cons 
         WADLERLINDIG::ppNewline 
         (cons 
          (WADLERLINDIG::ppString "Edges = {") 
          (cons 
           (EDGE::ppSet (SKETCH::edges-1 graph)) 
           (cons 
            (WADLERLINDIG::ppString "}") 
            (cons 
             WADLERLINDIG::ppNewline 
             (cons 
              (WADLERLINDIG::ppString "Source map = {") 
              (cons 
               (WADLERLINDIG::ppSep-1-1 
                (WADLERLINDIG::ppString ",") 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) (ppPair (car x) (cdr x))) 
                 (SKETCH::mapToList (SKETCH::src-1 graph)))) 
               (cons 
                (WADLERLINDIG::ppString "}") 
                (cons 
                 WADLERLINDIG::ppNewline 
                 (cons 
                  (WADLERLINDIG::ppString "Target map = {") 
                  (cons 
                   (WADLERLINDIG::ppSep-1-1 
                    (WADLERLINDIG::ppString ",") 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) (ppPair (car x) (cdr x))) 
                     (SKETCH::mapToList (SKETCH::target-1 graph)))) 
                   (cons (WADLERLINDIG::ppString "}") nil))))))))))))))))))

(defun CAT::ppDiagram-1 (dgm) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "Shape=") 
    (cons 
     WADLERLINDIG::ppNewline 
     (cons 
      (WADLERLINDIG::ppString "  ") 
      (cons 
       (WADLERLINDIG::ppIndent (SKETCH::ppSketch-1 (CAT::shape-1 dgm))) 
       (cons 
        WADLERLINDIG::ppNewline 
        (cons 
         (WADLERLINDIG::ppString "  ") 
         (cons 
          (WADLERLINDIG::ppString "Functor=") 
          (cons 
           (WADLERLINDIG::ppIndent (FUNCTOR::ppFunctor-1 (CAT::functor-1 dgm))) 
           nil))))))))))

(defun CAT::ppDiagram (x0 x1) (CAT::ppDiagram-1 (cons x0 x1)))

(defun CAT::ppObj (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::ppObj-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun CAT::ppObj-1-1 (x1 x2) (funcall (CAT::ppObj-1 x1) x2))

(defun CAT::shape (x0 x1) (CAT::shape-1 (cons x0 x1)))

(defun CAT::universal-1 (initCocone) (cdr initCocone))

(defun CAT::universal (x0 x1) (CAT::universal-1 (cons x0 x1)))

(defun CAT::universal-1-1 (x1 x2) (funcall (CAT::universal-1 x1) x2))

(defun VERTEX::member?-1-1 (x0 x1) (POLYSET::member?-1-1 x0 x1))

(defun CAT::vertexInDiagram?-1-1 (dgm vertex) 
  (VERTEX::member?-1-1 (SKETCH::vertices-1 (CAT::shape-1 dgm)) vertex))

(defun CAT::vertexInDiagram?-1 (x1) 
  #'(lambda (x2) (CAT::vertexInDiagram?-1-1 x1 x2)))

(defun CAT::vertexInDiagram? (x0 x1) (CAT::vertexInDiagram?-1 (cons x0 x1)))

(defun CAT::vertexLabel-1-1 (dgm vertex) 
  (POLYMAP::|!eval|-1-1 (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm)) vertex))

(defun CAT::vertexLabel-1 (x1) #'(lambda (x2) (CAT::vertexLabel-1-1 x1 x2)))

(defun CAT::vertexLabel (x0 x1) (CAT::vertexLabel-1 (cons x0 x1)))

(defun CHAR-SPEC::show (c) (CHAR-SPEC::toString c))

(defun COMPARE::show (cmp) 
  (block 
   nil 
   (if (eq (car cmp) :|Greater|) 
       (return "Greater") 
       (if (eq (car cmp) :|Equal|) 
           (return "Equal") 
           (if (eq (car cmp) :|Less|) (return "Less")))) 
   (error "Nonexhaustive match failure in show")))

(defun POLYSET::|!delete|-1-1 (l x) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV3 (car l))
                 (pV4 (cdr l))) 
             (return 
              (if (slang-built-in::slang-term-equals pV3 x) 
                  pV4 
                  (cons pV3 (POLYSET::|!delete|-1-1 pV4 x))))))) 
   (error "Nonexhaustive match failure in delete")))

(defun POLYSET::|!delete| (x1) 
  #'(lambda (x2) (POLYSET::|!delete|-1-1 x1 x2)))

(defun EDGE::|!delete| (x) (POLYSET::|!delete| x))

(defun EDGE::|!delete|-1-1 (x0 x1) (POLYSET::|!delete|-1-1 x0 x1))

(defun POLYSET::empty? (s) (slang-built-in::slang-term-equals nil s))

(defun EDGE::empty? (x) (POLYSET::empty? x))

(defun POLYSET::fold (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYSET::fold-1-1-1 x1 x2 x3))))

(defun EDGE::fold (x) (POLYSET::fold x))

(defun POLYSET::insert (x1) #'(lambda (x2) (POLYSET::insert-1-1 x1 x2)))

(defun EDGE::insert (x) (POLYSET::insert x))

(defun POLYSET::|!map|-1-1 (f s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return (cons (funcall f (car s)) (POLYSET::|!map|-1-1 f (cdr s)))))) 
   (error "Nonexhaustive match failure in map")))

(defun POLYSET::|!map| (x1) #'(lambda (x2) (POLYSET::|!map|-1-1 x1 x2)))

(defun EDGE::|!map| (x) (POLYSET::|!map| x))

(defun EDGE::|!map|-1-1 (x0 x1) (POLYSET::|!map|-1-1 x0 x1))

(defun POLYSET::member? (x1) #'(lambda (x2) (POLYSET::member?-1-1 x1 x2)))

(defun EDGE::member? (x) (POLYSET::member? x))

(defun POLYSET::singleton (x) (cons x nil))

(defun EDGE::singleton (x) (POLYSET::singleton x))

(defun POLYSET::toList (l) l)

(defun EDGE::toList (x) (POLYSET::toList x))

(defun EDGE::|!union| (x) (POLYSET::|!union| x))

(defun EDGE::|!union|-1-1 (x0 x1) (POLYSET::|!union|-1-1 x0 x1))

(defun FUNCTIONS::id (x) x)

(defun FUNCTIONS::o-1-1 (!x1 x) (funcall (car !x1) (funcall (cdr !x1) x)))

(defun FUNCTIONS::o-1 (x1) #'(lambda (x2) (FUNCTIONS::o-1-1 x1 x2)))

(defun FUNCTIONS::o (x0 x1) (FUNCTIONS::o-1 (cons x0 x1)))

(defun FUNCTOR::cod (x0 x1 x2 x3) (FUNCTOR::cod-1 (vector x0 x1 x2 x3)))

(defun FUNCTOR::dom (x0 x1 x2 x3) (FUNCTOR::dom-1 (vector x0 x1 x2 x3)))

(defun FUNCTOR::edgeMap (x0 x1 x2 x3) (FUNCTOR::edgeMap-1 (vector x0 x1 x2 x3)))

(defun FUNCTOR::emptyFunctor (x0 x1 x2 x3 x4 x5 x6 x7) 
  (FUNCTOR::emptyFunctor-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun FUNCTOR::makeFunctor-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) (FUNCTOR::makeFunctor-1-1-1-1 x1 x2 x3 x4)))))

(defun FUNCTOR::makeFunctor (x0 x1 x2 x3) 
  (FUNCTOR::makeFunctor-1 (vector x0 x1 x2 x3)))

(defun FUNCTOR::ppFunctor (x0 x1 x2 x3) 
  (FUNCTOR::ppFunctor-1 (vector x0 x1 x2 x3)))

(defun FUNCTOR::vertexMap (x0 x1 x2 x3) 
  (FUNCTOR::vertexMap-1 (vector x0 x1 x2 x3)))

(defun POSITION-SPEC::printAll (|!position|) 
  (block 
   nil 
   (if (eq (car |!position|) :|Internal|) 
       (return (cdr |!position|)) 
       (if (eq (car |!position|) :|String|) 
           (let ((pV3 (cdr |!position|))) 
             (return 
              (let ((printPos 
                     #'(lambda (x) 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ (NAT-SPEC::toString (svref x 0)) ".") 
                         (NAT-SPEC::toString (svref x 1)))))) 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ (funcall printPos (svref pV3 1)) "-") 
                    (funcall printPos (svref pV3 2))) 
                   " in [") 
                  (svref pV3 0)) 
                 "]")))) 
           (if (eq (car |!position|) :|File|) 
               (let ((pV2 (cdr |!position|))) 
                 (return 
                  (let ((printPos 
                         #'(lambda (x) 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              (NAT-SPEC::toString (svref x 0)) 
                              ".") 
                             (NAT-SPEC::toString (svref x 1)))))) 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ (STRING-SPEC::^ "in " (svref pV2 0)) "
") 
                       (funcall printPos (svref pV2 1))) 
                      "-") 
                     (funcall printPos (svref pV2 2))))))))) 
   (error "Nonexhaustive match failure in printAll")))

(defun STANDARDSPEC::tagTuple (|!labels|) 
  (labels 
    ((|!loop| (i |!labels|) 
      (block 
       nil 
       (if (null |!labels|) 
           (return nil) 
           (if (consp |!labels|) 
               (return 
                (LIST-SPEC::|!cons| 
                 (cons (NAT-SPEC::toString i) (car |!labels|)) 
                 (|!loop| (INTEGER-SPEC::|!+| i 1) (cdr |!labels|)))))) 
       (error "Nonexhaustive match failure in tagTuple")))) 
    (|!loop| 1 |!labels|)))

(defun STANDARDSPEC::mkTuple (terms) 
  (block 
   nil 
   (if (consp terms) (if (null (cdr terms)) (return (car terms)))) 
   (return (STANDARDSPEC::mkRecord (STANDARDSPEC::tagTuple terms)))))

(defun INFIX::resolveInfixes (tagTermWithInfixInfo pos terms) 
  (labels 
    ((applyInfix (t1 infOp t2) 
      (cons 
       :|ApplyN| 
       (cons 
        (cons infOp (cons (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil))) nil)) 
        pos)))) 
    (labels 
      ((applyPrefixes (terms) 
        (block 
         nil 
         (if (null terms) 
             (return nil) 
             (if (consp terms) 
                 (let ((pV4 (cdr terms))
                       (pV3 (car terms))) 
                   (progn (if (null pV4) (return (cons pV3 nil))) 
                          (if (eq (car pV3) :|Nonfix|) 
                              (if (consp pV4) 
                                  (let ((pV7 (car pV4))) 
                                    (if (eq (car pV7) :|Nonfix|) 
                                        (return 
                                         (applyPrefixes 
                                          (LIST-SPEC::|!cons| 
                                           (cons 
                                            :|Nonfix| 
                                            (cons 
                                             :|ApplyN| 
                                             (cons 
                                              (cons 
                                               (cdr pV3) 
                                               (cons (cdr pV7) nil)) 
                                              pos))) 
                                           (cdr pV4)))))))) 
                          (return (LIST-SPEC::|!cons| pV3 (applyPrefixes pV4))))))) 
         (error "Nonexhaustive match failure in resolveInfixes")))) 
      (let ((tagged (LIST-SPEC::|!map|-1-1 tagTermWithInfixInfo terms))) 
        (let ((tagged (applyPrefixes tagged))) 
          (labels 
            ((scan (delta0 terms) 
              (block 
               nil 
               (if (null terms) 
                   (return 
                    (SYSTEM-SPEC::fail 
                     (STRING-SPEC::^ 
                      (POSITION-SPEC::printAll pos) 
                      " : No terms to apply"))) 
                   (if (consp terms) 
                       (let ((pV41 (cdr terms))
                             (pV40 (car terms))) 
                         (if (eq (car pV40) :|Infix|) 
                             (let ((pV53 (car (cdr pV40)))) 
                               (progn (if (null pV41) 
                                          (return 
                                           (cons (cons :|Nonfix| pV53) nil))) 
                                      (return 
                                       (SYSTEM-SPEC::fail 
                                        (STRING-SPEC::^ 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ 
                                           (POSITION-SPEC::printAll pos) 
                                           " : Infix ") 
                                          (ANNSPECPRINTER::printTerm pV53)) 
                                         " given without left argument"))))) 
                             (if (eq (car pV40) :|Nonfix|) 
                                 (let ((pV42 (cdr pV40))) 
                                   (if (null pV41) 
                                       (return (cons (cons :|Nonfix| pV42) nil)) 
                                       (if (consp pV41) 
                                           (let ((pV45 (car pV41))) 
                                             (if (eq (car pV45) :|Infix|) 
                                                 (let ((pV48 (cdr pV45))) 
                                                   (let ((pV50 (cdr pV48))
                                                         (pV49 (car pV48))) 
                                                     (let ((pV52 (cdr pV50))
                                                           (pV51 (car pV50))) 
                                                       (return 
                                                        (let ((|!rest| 
                                                               (scan 
                                                                pV52 
                                                                (cdr pV41)))) 
                                                          (if (cl:or 
                                                               (INTEGER-SPEC::|!>| 
                                                                delta0 
                                                                pV52) 
                                                               (cl:and 
                                                                ( =  delta0 pV52) 
                                                                (slang-built-in::slang-term-equals 
                                                                 pV51 
                                                                 '(:|Left|)))) 
                                                              (LIST-SPEC::|!cons| 
                                                               (cons 
                                                                :|Nonfix| 
                                                                pV42) 
                                                               (LIST-SPEC::|!cons| 
                                                                (cons 
                                                                 :|Infix| 
                                                                 (cons 
                                                                  pV49 
                                                                  (cons 
                                                                   pV51 
                                                                   pV52))) 
                                                                |!rest|)) 
                                                              (block 
                                                               nil 
                                                               (if (consp 
                                                                    |!rest|) 
                                                                   (let ((pV21 
                                                                          (cdr 
                                                                           |!rest|))
                                                                         (pV20 
                                                                          (car 
                                                                           |!rest|))) 
                                                                     (if (eq 
                                                                          (car 
                                                                           pV20) 
                                                                          :|Nonfix|) 
                                                                         (let ((pV22 
                                                                                (cdr 
                                                                                 pV20))) 
                                                                           (if (consp 
                                                                                pV21) 
                                                                               (let ((pV25 
                                                                                      (cdr 
                                                                                       pV21))
                                                                                     (pV24 
                                                                                      (car 
                                                                                       pV21))) 
                                                                                 (if (eq 
                                                                                      (car 
                                                                                       pV24) 
                                                                                      :|Infix|) 
                                                                                     (let ((pV26 
                                                                                            (cdr 
                                                                                             pV24))) 
                                                                                       (let ((pV28 
                                                                                              (cdr 
                                                                                               pV26))
                                                                                             (pV27 
                                                                                              (car 
                                                                                               pV26))) 
                                                                                         (let ((pV30 
                                                                                                (cdr 
                                                                                                 pV28))) 
                                                                                           (if (consp 
                                                                                                pV25) 
                                                                                               (let ((pV33 
                                                                                                      (cdr 
                                                                                                       pV25))
                                                                                                     (pV32 
                                                                                                      (car 
                                                                                                       pV25))) 
                                                                                                 (if (eq 
                                                                                                      (car 
                                                                                                       pV32) 
                                                                                                      :|Nonfix|) 
                                                                                                     (let ((pV34 
                                                                                                            (cdr 
                                                                                                             pV32))) 
                                                                                                       (return 
                                                                                                        (if (cl:or 
                                                                                                             (INTEGER-SPEC::|!>| 
                                                                                                              pV52 
                                                                                                              pV30) 
                                                                                                             (cl:and 
                                                                                                              ( =  
                                                                                                               pV52 
                                                                                                               pV30) 
                                                                                                              (slang-built-in::slang-term-equals 
                                                                                                               pV51 
                                                                                                               '(:|Left|)))) 
                                                                                                            (LIST-SPEC::|!++| 
                                                                                                             (cons 
                                                                                                              (cons 
                                                                                                               :|Nonfix| 
                                                                                                               (applyInfix 
                                                                                                                pV42 
                                                                                                                pV49 
                                                                                                                pV22)) 
                                                                                                              (cons 
                                                                                                               (cons 
                                                                                                                :|Infix| 
                                                                                                                (cons 
                                                                                                                 pV27 
                                                                                                                 (cons 
                                                                                                                  (car 
                                                                                                                   pV28) 
                                                                                                                  pV30))) 
                                                                                                               (cons 
                                                                                                                (cons 
                                                                                                                 :|Nonfix| 
                                                                                                                 pV34) 
                                                                                                                nil))) 
                                                                                                             pV33) 
                                                                                                            (let ((pV12 
                                                                                                                   (scan 
                                                                                                                    pV30 
                                                                                                                    (LIST-SPEC::|!++| 
                                                                                                                     (cons 
                                                                                                                      (cons 
                                                                                                                       :|Nonfix| 
                                                                                                                       pV34) 
                                                                                                                      nil) 
                                                                                                                     pV33)))) 
                                                                                                              (block 
                                                                                                               nil 
                                                                                                               (if (consp 
                                                                                                                    pV12) 
                                                                                                                   (let ((pV14 
                                                                                                                          (car 
                                                                                                                           pV12))) 
                                                                                                                     (if (eq 
                                                                                                                          (car 
                                                                                                                           pV14) 
                                                                                                                          :|Nonfix|) 
                                                                                                                         (return 
                                                                                                                          (scan 
                                                                                                                           delta0 
                                                                                                                           (LIST-SPEC::|!++| 
                                                                                                                            (cons 
                                                                                                                             (cons 
                                                                                                                              :|Nonfix| 
                                                                                                                              pV42) 
                                                                                                                             (cons 
                                                                                                                              (cons 
                                                                                                                               :|Infix| 
                                                                                                                               (cons 
                                                                                                                                pV49 
                                                                                                                                (cons 
                                                                                                                                 pV51 
                                                                                                                                 pV52))) 
                                                                                                                              (cons 
                                                                                                                               (cons 
                                                                                                                                :|Nonfix| 
                                                                                                                                (applyInfix 
                                                                                                                                 pV22 
                                                                                                                                 pV27 
                                                                                                                                 (cdr 
                                                                                                                                  pV14))) 
                                                                                                                               nil))) 
                                                                                                                            (cdr 
                                                                                                                             pV12))))))) 
                                                                                                               (error 
                                                                                                                "Nonexhaustive match failure in resolveInfixes")))))))))))))) 
                                                                               (if (null 
                                                                                    pV21) 
                                                                                   (return 
                                                                                    (cons 
                                                                                     (cons 
                                                                                      :|Nonfix| 
                                                                                      (applyInfix 
                                                                                       pV42 
                                                                                       pV49 
                                                                                       pV22)) 
                                                                                     nil)))))))) 
                                                               (return 
                                                                (SYSTEM-SPEC::fail 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (POSITION-SPEC::printAll 
                                                                     pos) 
                                                                    " : Infix ") 
                                                                   (ANNSPECPRINTER::printTerm 
                                                                    pV49)) 
                                                                  " given without left argument")))))))))) 
                                                 (if (eq (car pV45) :|Nonfix|) 
                                                     (return 
                                                      (SYSTEM-SPEC::fail 
                                                       (STRING-SPEC::^ 
                                                        (POSITION-SPEC::printAll 
                                                         pos) 
                                                        " : Unreduced nonfix")))))))))))))) 
               (error "Nonexhaustive match failure in resolveInfixes")))) 
            (labels 
              ((scanrec (tagged) 
                (let ((pV55 (scan 0 tagged))) 
                  (block 
                   nil 
                   (if (consp pV55) 
                       (let ((pV58 (cdr pV55))
                             (pV57 (car pV55))) 
                         (if (eq (car pV57) :|Nonfix|) 
                             (let ((pV59 (cdr pV57))) 
                               (if (null pV58) 
                                   (return pV59) 
                                   (if (consp pV58) 
                                       (let ((pV62 (cdr pV58))
                                             (pV61 (car pV58))) 
                                         (if (eq (car pV61) :|Infix|) 
                                             (let ((pV63 (cdr pV61))) 
                                               (let ((pV65 (cdr pV63))
                                                     (pV64 (car pV63))) 
                                                 (progn (if (consp pV62) 
                                                            (let ((pV69 
                                                                   (car pV62))) 
                                                              (if (eq 
                                                                   (car pV69) 
                                                                   :|Nonfix|) 
                                                                  (if (null 
                                                                       (cdr pV62)) 
                                                                      (return 
                                                                       (applyInfix 
                                                                        pV59 
                                                                        pV64 
                                                                        (cdr 
                                                                         pV69))))))) 
                                                        (if (eq 
                                                             (car (car pV65)) 
                                                             :|Left|) 
                                                            (if ( =  
                                                                 0 
                                                                 (cdr pV65)) 
                                                                (return 
                                                                 (applyInfix 
                                                                  pV59 
                                                                  pV64 
                                                                  (scanrec pV62)))))))))))))))) 
                   (return (scanrec pV55)))))) 
              (let ((term (scanrec tagged))) term))))))))

(defun INFIX::resolveInfixes-1 (x) 
  (INFIX::resolveInfixes (svref x 0) (svref x 1) (svref x 2)))

(defun INTEGER-SPEC::|!>|-1 (x) (INTEGER-SPEC::|!>| (car x) (cdr x)))

(defun INTEGER-SPEC::|!>=| (x y) (INTEGER-SPEC::|!<=| y x))

(defun INTEGER-SPEC::|!>=|-1 (x) (INTEGER-SPEC::|!>=| (car x) (cdr x)))

(defun INTEGER-SPEC::|!max| (x y) (if (INTEGER-SPEC::|!<=| x y) y x))

(defun INTEGER-SPEC::|!max|-1 (x) (INTEGER-SPEC::|!max| (car x) (cdr x)))

(defun INTEGER-SPEC::|!min| (x y) (if (INTEGER-SPEC::|!<=| x y) x y))

(defun INTEGER-SPEC::|!min|-1 (x) (INTEGER-SPEC::|!min| (car x) (cdr x)))

(defun INTEGER-SPEC::show (n) (INTEGER-SPEC::toString n))

(defun INTEGERSET::add (x0 x) (SPLAYSET::add x0 x))

(defun INTEGERSET::add-1 (x) (INTEGERSET::add (car x) (cdr x)))

(defun INTEGERSET::addList (x0 x) (SPLAYSET::addList x0 x))

(defun INTEGERSET::addList-1 (x) (INTEGERSET::addList (car x) (cdr x)))

(defun SPLAYSET::appSplay-1-1 (f sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (progn (SPLAYSET::appSplay-1-1 f (svref pV2 0)) 
                     (funcall f (svref pV2 2)) 
                     (SPLAYSET::appSplay-1-1 f (svref pV2 1))))))) 
   (error "Nonexhaustive match failure in appSplay")))

(defun SPLAYSET::app-1-1 (f |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::appSplay-1-1 f (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in app")))

(defun SPLAYSET::app (x1) #'(lambda (x2) (SPLAYSET::app-1-1 x1 x2)))

(defun INTEGERSET::app (x) (SPLAYSET::app x))

(defun INTEGERSET::app-1-1 (x0 x1) (SPLAYSET::app-1-1 x0 x1))

(defun SPLAYTREE::lrotate (sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|SplayNil|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (let ((pV4 (svref pV2 1))) 
               (if (eq (car pV4) :|SplayNil|) 
                   (return sp) 
                   (if (eq (car pV4) :|SplayObj|) 
                       (let ((pV6 (cdr pV4))) 
                         (return 
                          (SPLAYTREE::lrotate 
                           (cons 
                            :|SplayObj| 
                            (vector 
                             (cons 
                              :|SplayObj| 
                              (vector (svref pV2 0) (svref pV6 0) (svref pV2 2))) 
                             (svref pV6 1) 
                             (svref pV6 2)))))))))))) 
   (error "Nonexhaustive match failure in lrotate")))

(defun SPLAYTREE::join (sp1 sp2) 
  (block 
   nil 
   (if (eq (car sp1) :|SplayNil|) 
       (progn (if (eq (car sp2) :|SplayNil|) (return '(:|SplayNil|))) 
              (return sp2))) 
   (if (eq (car sp2) :|SplayNil|) (return sp1)) 
   (return 
    (let ((pV1 (SPLAYTREE::lrotate sp1))) 
      (block 
       nil 
       (if (eq (car pV1) :|SplayNil|) 
           (return sp2) 
           (if (eq (car pV1) :|SplayObj|) 
               (let ((pV2 (cdr pV1))) 
                 (return 
                  (cons :|SplayObj| (vector (svref pV2 0) sp2 (svref pV2 2))))))) 
       (error "Nonexhaustive match failure in join")))) 
   (error "Nonexhaustive match failure in join")))

(defun SPLAYSET::|!delete| (|!set| key) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return |!set|) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV10 (cdr |!set|))) 
             (let ((pV14 (svref pV10 2))
                   (pV13 (svref pV10 1))
                   (pV12 (svref pV10 0))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        (SPLAYSET::compf pV12 key) 
                        (STATE::|!!| pV14)))) 
                  (let ((pV4 (cdr x))) 
                    (block 
                     nil 
                     (if (eq (car (car x)) :|Equal|) 
                         (if (eq (car pV4) :|SplayObj|) 
                             (let ((pV5 (cdr pV4))) 
                               (return 
                                (if ( =  pV13 1) 
                                    (SPLAYSET::empty pV12) 
                                    (cons 
                                     :|SET| 
                                     (vector 
                                      pV12 
                                      (INTEGER-SPEC::|!-| pV13 1) 
                                      (cons 
                                       :|Ref| 
                                       (SPLAYTREE::join 
                                        (svref pV5 0) 
                                        (svref pV5 1)))))))))) 
                     (return (progn (STATE::|:=| pV14 pV4) |!set|)) 
                     (error "Nonexhaustive match failure in delete"))))))))) 
   (error "Nonexhaustive match failure in delete")))

(defun INTEGERSET::|!delete| (x0 x) (SPLAYSET::|!delete| x0 x))

(defun INTEGERSET::|!delete|-1 (x) (INTEGERSET::|!delete| (car x) (cdr x)))

(defun SPLAYSET::split (comp value s) 
  (let ((x (SPLAYTREE::splay (SPLAYSET::compf comp value) s))) 
    (let ((pV3 (cdr x))
          (pV2 (car x))) 
      (block 
       nil 
       (if (eq (car pV2) :|Equal|) 
           (if (eq (car pV3) :|SplayObj|) 
               (let ((pV12 (cdr pV3))) 
                 (return 
                  (vector 
                   (cons :|Some| (svref pV12 2)) 
                   (svref pV12 0) 
                   (svref pV12 1))))) 
           (if (eq (car pV2) :|Less|) 
               (if (eq (car pV3) :|SplayObj|) 
                   (let ((pV8 (cdr pV3))) 
                     (return 
                      (vector 
                       '(:|None|) 
                       (cons 
                        :|SplayObj| 
                        (vector (svref pV8 0) '(:|SplayNil|) (svref pV8 2))) 
                       (svref pV8 1))))) 
               (if (eq (car pV2) :|Greater|) 
                   (if (eq (car pV3) :|SplayObj|) 
                       (let ((pV4 (cdr pV3))) 
                         (return 
                          (vector 
                           '(:|None|) 
                           (svref pV4 0) 
                           (cons 
                            :|SplayObj| 
                            (vector '(:|SplayNil|) (svref pV4 1) (svref pV4 2)))))))))) 
       (if (eq (car pV3) :|SplayNil|) 
           (return (vector '(:|None|) '(:|SplayNil|) '(:|SplayNil|)))) 
       (error "Nonexhaustive match failure in split")))))

(defun SPLAYSET::|!count| (sp n) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return n) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (SPLAYSET::|!count| 
               (svref pV2 0) 
               (SPLAYSET::|!count| (svref pV2 1) (INTEGER-SPEC::|!+| n 1))))))) 
   (error "Nonexhaustive match failure in count")))

(defun SPLAYSET::diffSplay (comp sp1 sp2) 
  (block 
   nil 
   (if (eq (car sp1) :|SplayNil|) (return (cons '(:|SplayNil|) 0))) 
   (if (eq (car sp2) :|SplayNil|) 
       (return (cons sp1 (SPLAYSET::|!count| sp1 0))) 
       (if (eq (car sp2) :|SplayObj|) 
           (let ((pV15 (cdr sp2))) 
             (return 
              (let ((pV9 (SPLAYSET::split comp (svref pV15 2) sp1))) 
                (block 
                 nil 
                 (return 
                  (let ((pV6 
                         (SPLAYSET::diffSplay comp (svref pV9 1) (svref pV15 0)))) 
                    (block 
                     nil 
                     (return 
                      (let ((pV3 
                             (SPLAYSET::diffSplay 
                              comp 
                              (svref pV9 2) 
                              (svref pV15 1)))) 
                        (block 
                         nil 
                         (return 
                          (cons 
                           (SPLAYTREE::join (car pV6) (car pV3)) 
                           (INTEGER-SPEC::|!+| (cdr pV6) (cdr pV3)))) 
                         (error "Nonexhaustive match failure in diffSplay")))) 
                     (error "Nonexhaustive match failure in diffSplay")))) 
                 (error "Nonexhaustive match failure in diffSplay"))))))) 
   (error "Nonexhaustive match failure in diffSplay")))

(defun SPLAYSET::difference (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) (return set1)) 
   (if (eq (car set2) :|EMPTY|) (return set1)) 
   (if (eq (car set1) :|SET|) 
       (let ((pV10 (cdr set1))) 
         (let ((pV11 (svref pV10 0))) 
           (if (eq (car set2) :|SET|) 
               (return 
                (let ((x 
                       (SPLAYSET::diffSplay 
                        pV11 
                        (STATE::|!!| (svref pV10 2)) 
                        (STATE::|!!| (svref (cdr set2) 2))))) 
                  (let ((pV7 (cdr x))) 
                    (block 
                     nil 
                     (if ( =  0 pV7) (return (cons :|EMPTY| pV11))) 
                     (return 
                      (cons :|SET| (vector pV11 pV7 (cons :|Ref| (car x))))) 
                     (error "Nonexhaustive match failure in difference"))))))))) 
   (error "Nonexhaustive match failure in difference")))

(defun INTEGERSET::difference (x0 x) (SPLAYSET::difference x0 x))

(defun INTEGERSET::difference-1 (x) (INTEGERSET::difference (car x) (cdr x)))

(defun SPLAYSET::memberT (comp x tree) 
  (block 
   nil 
   (if (eq (car tree) :|SplayNil|) 
       (return nil) 
       (if (eq (car tree) :|SplayObj|) 
           (let ((pV4 (cdr tree))) 
             (return 
              (let ((pV2 (funcall comp (cons x (svref pV4 2))))) 
                (block 
                 nil 
                 (if (eq (car pV2) :|Less|) 
                     (return (SPLAYSET::memberT comp x (svref pV4 0))) 
                     (if (eq (car pV2) :|Greater|) 
                         (return (SPLAYSET::memberT comp x (svref pV4 1))))) 
                 (return t))))))) 
   (error "Nonexhaustive match failure in memberT")))

(defun SPLAYSET::treeIn (comp |!t| t_) 
  (block 
   nil 
   (if (eq (car |!t|) :|SplayNil|) 
       (return t) 
       (if (eq (car |!t|) :|SplayObj|) 
           (let ((pV2 (cdr |!t|))) 
             (let ((pV5 (svref pV2 2))
                   (pV4 (svref pV2 1))
                   (pV3 (svref pV2 0))) 
               (progn (if (eq (car pV3) :|SplayNil|) 
                          (if (eq (car pV4) :|SplayNil|) 
                              (return (SPLAYSET::memberT comp pV5 t_)))) 
                      (if (eq (car pV4) :|SplayNil|) 
                          (return 
                           (cl:and 
                            (SPLAYSET::memberT comp pV5 t_) 
                            (SPLAYSET::treeIn comp pV3 t_)))) 
                      (if (eq (car pV3) :|SplayNil|) 
                          (return 
                           (cl:and 
                            (SPLAYSET::memberT comp pV5 t_) 
                            (SPLAYSET::treeIn comp pV4 t_)))) 
                      (return 
                       (cl:and 
                        (SPLAYSET::memberT comp pV5 t_) 
                        (cl:and 
                         (SPLAYSET::treeIn comp pV3 t_) 
                         (SPLAYSET::treeIn comp pV4 t_))))))))) 
   (error "Nonexhaustive match failure in treeIn")))

(defun SPLAYSET::|!equal| (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|SET|) 
       (let ((pV7 (cdr set1))) 
         (if (eq (car set2) :|SET|) 
             (let ((pV12 (cdr set2))) 
               (return 
                (cl:and 
                 ( =  (svref pV7 1) (svref pV12 1)) 
                 (SPLAYSET::treeIn 
                  (svref pV7 0) 
                  (STATE::|!!| (svref pV7 2)) 
                  (STATE::|!!| (svref pV12 2)))))))) 
       (if (eq (car set1) :|EMPTY|) (if (eq (car set2) :|EMPTY|) (return t)))) 
   (return nil)))

(defun INTEGERSET::|!equal| (x0 x) (SPLAYSET::|!equal| x0 x))

(defun INTEGERSET::|!equal|-1 (x) (INTEGERSET::|!equal| (car x) (cdr x)))

(defun SPLAYSET::existsSplay-1-1 (p sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (if (funcall p (svref pV2 2)) 
                  t 
                  (if (SPLAYSET::existsSplay-1-1 p (svref pV2 0)) 
                      t 
                      (SPLAYSET::existsSplay-1-1 p (svref pV2 1)))))))) 
   (error "Nonexhaustive match failure in existsSplay")))

(defun SPLAYSET::|!exists|-1-1 (p |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::existsSplay-1-1 p (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in exists")))

(defun SPLAYSET::|!exists| (x1) 
  #'(lambda (x2) (SPLAYSET::|!exists|-1-1 x1 x2)))

(defun INTEGERSET::|!exists| (x) (SPLAYSET::|!exists| x))

(defun INTEGERSET::|!exists|-1-1 (x0 x1) (SPLAYSET::|!exists|-1-1 x0 x1))

(defun SPLAYSET::filterSplay-1-1 (comp x) 
  (let ((p (svref x 0))
        (sp (svref x 1))
        (tree (svref x 2))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return tree) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV2 (cdr sp))) 
               (let ((pV5 (svref pV2 2))) 
                 (return 
                  (let ((t_ 
                         (SPLAYSET::filterSplay-1-1 
                          comp 
                          (vector 
                           p 
                           (svref pV2 1) 
                           (SPLAYSET::filterSplay-1-1 
                            comp 
                            (vector p (svref pV2 0) tree)))))) 
                    (if (funcall p pV5) 
                        (SPLAYSET::insert-1-1 comp (cons pV5 t_)) 
                        t_))))))) 
     (error "Nonexhaustive match failure in filterSplay"))))

(defparameter SPLAYTREE::mkSplayNil '(:|SplayNil|))

(defun SPLAYSET::filter-1-1 (p |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return |!set|) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV6 (cdr |!set|))) 
             (let ((pV8 (svref pV6 0))) 
               (return 
                (let ((x 
                       (SPLAYSET::filterSplay-1-1 
                        pV8 
                        (vector 
                         p 
                         (STATE::|!!| (svref pV6 2)) 
                         (cons 0 SPLAYTREE::mkSplayNil))))) 
                  (let ((pV3 (car x))) 
                    (block 
                     nil 
                     (if ( =  0 pV3) (return (cons :|EMPTY| pV8))) 
                     (return 
                      (cons :|SET| (vector pV8 pV3 (cons :|Ref| (cdr x))))) 
                     (error "Nonexhaustive match failure in filter"))))))))) 
   (error "Nonexhaustive match failure in filter")))

(defun SPLAYSET::filter (x1) #'(lambda (x2) (SPLAYSET::filter-1-1 x1 x2)))

(defun INTEGERSET::filter (x) (SPLAYSET::filter x))

(defun INTEGERSET::filter-1-1 (x0 x1) (SPLAYSET::filter-1-1 x0 x1))

(defun SPLAYSET::findSplay-1-1 (p sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|None|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV6 (cdr sp))) 
             (let ((pV9 (svref pV6 2))) 
               (return 
                (if (funcall p pV9) 
                    (cons :|Some| pV9) 
                    (let ((pV3 (SPLAYSET::findSplay-1-1 p (svref pV6 0)))) 
                      (block 
                       nil 
                       (if (eq (car pV3) :|Some|) (return pV3)) 
                       (return (SPLAYSET::findSplay-1-1 p (svref pV6 1))))))))))) 
   (error "Nonexhaustive match failure in findSplay")))

(defun SPLAYSET::|!find|-1-1 (p |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return '(:|None|)) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::findSplay-1-1 p (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in find")))

(defun SPLAYSET::|!find| (x1) #'(lambda (x2) (SPLAYSET::|!find|-1-1 x1 x2)))

(defun INTEGERSET::|!find| (x) (SPLAYSET::|!find| x))

(defun INTEGERSET::|!find|-1-1 (x0 x1) (SPLAYSET::|!find|-1-1 x0 x1))

(defun SPLAYSET::foldlSplay-1-1-1 (f b sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return b) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (SPLAYSET::foldlSplay-1-1-1 
               f 
               (funcall f 
                        (cons 
                         (svref pV2 2) 
                         (SPLAYSET::foldlSplay-1-1-1 f b (svref pV2 0)))) 
               (svref pV2 1)))))) 
   (error "Nonexhaustive match failure in foldlSplay")))

(defun SPLAYSET::foldl-1-1-1 (abf b |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::foldlSplay-1-1-1 
             abf 
             b 
             (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in foldl")))

(defun SPLAYSET::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldl-1-1-1 x1 x2 x3))))

(defun INTEGERSET::foldl (x) (SPLAYSET::foldl x))

(defun INTEGERSET::foldl-1-1-1 (x0 x1 x2) (SPLAYSET::foldl-1-1-1 x0 x1 x2))

(defun SPLAYSET::foldrSplay-1-1-1 (f b sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return b) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (SPLAYSET::foldrSplay-1-1-1 
               f 
               (funcall f 
                        (cons 
                         (svref pV2 2) 
                         (SPLAYSET::foldrSplay-1-1-1 f b (svref pV2 1)))) 
               (svref pV2 0)))))) 
   (error "Nonexhaustive match failure in foldrSplay")))

(defun SPLAYSET::foldr-1-1-1 (abf b |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::foldrSplay-1-1-1 
             abf 
             b 
             (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in foldr")))

(defun SPLAYSET::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldr-1-1-1 x1 x2 x3))))

(defun INTEGERSET::foldr (x) (SPLAYSET::foldr x))

(defun INTEGERSET::foldr-1-1-1 (x0 x1 x2) (SPLAYSET::foldr-1-1-1 x0 x1 x2))

(defun INTEGERSET::fromList (ls) (SPLAYSET::addList INTEGERSET::empty ls))

(defun SPLAYSET::intersectionSplay (comp s1 s2) 
  (block 
   nil 
   (if (eq (car s1) :|SplayNil|) (return (cons '(:|SplayNil|) 0))) 
   (if (eq (car s2) :|SplayNil|) 
       (return (cons '(:|SplayNil|) 0)) 
       (if (eq (car s2) :|SplayObj|) 
           (let ((pV22 (cdr s2))) 
             (let ((pV24 (svref pV22 1))
                   (pV23 (svref pV22 0))) 
               (return 
                (let ((x (SPLAYSET::split comp (svref pV22 2) s1))) 
                  (let ((pV18 (svref x 2))
                        (pV17 (svref x 1))
                        (pV16 (svref x 0))) 
                    (block 
                     nil 
                     (if (eq (car pV16) :|Some|) 
                         (return 
                          (let ((pV6 
                                 (SPLAYSET::intersectionSplay comp pV17 pV23))) 
                            (block 
                             nil 
                             (return 
                              (let ((pV3 
                                     (SPLAYSET::intersectionSplay comp pV18 pV24))) 
                                (block 
                                 nil 
                                 (return 
                                  (cons 
                                   (cons 
                                    :|SplayObj| 
                                    (vector (car pV6) (car pV3) (cdr pV16))) 
                                   (INTEGER-SPEC::|!+| 
                                    (INTEGER-SPEC::|!+| (cdr pV6) (cdr pV3)) 
                                    1))) 
                                 (error 
                                  "Nonexhaustive match failure in intersectionSplay")))) 
                             (error 
                              "Nonexhaustive match failure in intersectionSplay"))))) 
                     (return 
                      (let ((pV13 (SPLAYSET::intersectionSplay comp pV17 pV23))) 
                        (block 
                         nil 
                         (return 
                          (let ((pV10 
                                 (SPLAYSET::intersectionSplay comp pV18 pV24))) 
                            (block 
                             nil 
                             (return 
                              (cons 
                               (SPLAYTREE::join (car pV13) (car pV10)) 
                               (INTEGER-SPEC::|!+| (cdr pV13) (cdr pV10)))) 
                             (error 
                              "Nonexhaustive match failure in intersectionSplay")))) 
                         (error 
                          "Nonexhaustive match failure in intersectionSplay")))) 
                     (error "Nonexhaustive match failure in intersectionSplay"))))))))) 
   (error "Nonexhaustive match failure in intersectionSplay")))

(defun SPLAYSET::|!intersection| (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) (return set1)) 
   (if (eq (car set2) :|EMPTY|) (return set2)) 
   (if (eq (car set1) :|SET|) 
       (let ((pV10 (cdr set1))) 
         (let ((pV11 (svref pV10 0))) 
           (if (eq (car set2) :|SET|) 
               (return 
                (let ((x 
                       (SPLAYSET::intersectionSplay 
                        pV11 
                        (STATE::|!!| (svref pV10 2)) 
                        (STATE::|!!| (svref (cdr set2) 2))))) 
                  (let ((pV7 (cdr x))) 
                    (block 
                     nil 
                     (if ( =  0 pV7) (return (cons :|EMPTY| pV11))) 
                     (return 
                      (cons :|SET| (vector pV11 pV7 (cons :|Ref| (car x))))) 
                     (error "Nonexhaustive match failure in intersection"))))))))) 
   (error "Nonexhaustive match failure in intersection")))

(defun INTEGERSET::|!intersection| (x0 x) (SPLAYSET::|!intersection| x0 x))

(defun INTEGERSET::|!intersection|-1 (x) 
  (INTEGERSET::|!intersection| (car x) (cdr x)))

(defun SPLAYSET::isEmpty (|!set|) 
  (block nil (if (eq (car |!set|) :|EMPTY|) (return t)) (return nil)))

(defun INTEGERSET::isEmpty (x) (SPLAYSET::isEmpty x))

(defun SPLAYSET::listItemsApp (sp l) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return l) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (SPLAYSET::listItemsApp 
               (svref pV2 0) 
               (LIST-SPEC::|!cons| 
                (svref pV2 2) 
                (SPLAYSET::listItemsApp (svref pV2 1) l))))))) 
   (error "Nonexhaustive match failure in listItemsApp")))

(defun SPLAYSET::listItems (|!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::listItemsApp (STATE::|!!| (svref (cdr |!set|) 2)) nil)))) 
   (error "Nonexhaustive match failure in listItems")))

(defun INTEGERSET::listItems (x) (SPLAYSET::listItems x))

(defun SPLAYSET::mapf (f acc sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return acc) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (SPLAYSET::mapf 
               f 
               (SPLAYSET::add 
                (SPLAYSET::mapf f acc (svref pV2 0)) 
                (funcall f (svref pV2 2))) 
               (svref pV2 1)))))) 
   (error "Nonexhaustive match failure in mapf")))

(defun SPLAYSET::|!map|-1-1 (f |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return |!set|) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV3 (cdr |!set|))) 
             (return 
              (SPLAYSET::mapf 
               f 
               (cons :|EMPTY| (svref pV3 0)) 
               (STATE::|!!| (svref pV3 2))))))) 
   (error "Nonexhaustive match failure in map")))

(defun SPLAYSET::|!map| (x1) #'(lambda (x2) (SPLAYSET::|!map|-1-1 x1 x2)))

(defun INTEGERSET::|!map| (x) (SPLAYSET::|!map| x))

(defun INTEGERSET::|!map|-1-1 (x0 x1) (SPLAYSET::|!map|-1-1 x0 x1))

(defun INTEGERSET::|!member|-1 (x) (INTEGERSET::|!member| (car x) (cdr x)))

(defun SPLAYSET::numItems (|!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return 0) 
       (if (eq (car |!set|) :|SET|) (return (svref (cdr |!set|) 1)))) 
   (error "Nonexhaustive match failure in numItems")))

(defun INTEGERSET::numItems (x) (SPLAYSET::numItems x))

(defun SPLAYSET::unionSplay (comp sp1 sp2) 
  (block 
   nil 
   (if (eq (car sp1) :|SplayNil|) (return (cons sp2 (SPLAYSET::|!count| sp2 0)))) 
   (if (eq (car sp2) :|SplayNil|) 
       (return (cons sp1 (SPLAYSET::|!count| sp1 0))) 
       (if (eq (car sp2) :|SplayObj|) 
           (let ((pV17 (cdr sp2))) 
             (let ((pV20 (svref pV17 2))) 
               (return 
                (let ((pV11 (SPLAYSET::split comp pV20 sp1))) 
                  (block 
                   nil 
                   (return 
                    (let ((pV8 
                           (SPLAYSET::unionSplay 
                            comp 
                            (svref pV11 1) 
                            (svref pV17 0)))) 
                      (block 
                       nil 
                       (return 
                        (let ((pV5 
                               (SPLAYSET::unionSplay 
                                comp 
                                (svref pV11 2) 
                                (svref pV17 1)))) 
                          (block 
                           nil 
                           (return 
                            (cons 
                             (cons :|SplayObj| (vector (car pV8) (car pV5) pV20)) 
                             (INTEGER-SPEC::|!+| 
                              (INTEGER-SPEC::|!+| (cdr pV8) (cdr pV5)) 
                              1))) 
                           (error "Nonexhaustive match failure in unionSplay")))) 
                       (error "Nonexhaustive match failure in unionSplay")))) 
                   (error "Nonexhaustive match failure in unionSplay")))))))) 
   (error "Nonexhaustive match failure in unionSplay")))

(defun SPLAYSET::|!union| (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) (return set2)) 
   (if (eq (car set2) :|EMPTY|) (return set1)) 
   (if (eq (car set1) :|SET|) 
       (let ((pV10 (cdr set1))) 
         (let ((pV11 (svref pV10 0))) 
           (if (eq (car set2) :|SET|) 
               (return 
                (let ((pV5 
                       (SPLAYSET::unionSplay 
                        pV11 
                        (STATE::|!!| (svref pV10 2)) 
                        (STATE::|!!| (svref (cdr set2) 2))))) 
                  (block 
                   nil 
                   (return 
                    (cons :|SET| (vector pV11 (cdr pV5) (cons :|Ref| (car pV5))))) 
                   (error "Nonexhaustive match failure in union")))))))) 
   (error "Nonexhaustive match failure in union")))

(defun INTEGERSET::|!union| (x0 x) (SPLAYSET::|!union| x0 x))

(defun INTEGERSET::|!union|-1 (x) (INTEGERSET::|!union| (car x) (cdr x)))

(defun JGEN::mkArgProj (fieldProj) (STRING-SPEC::^ "arg_" fieldProj))

(defun JGEN::addArgsToTcx (tcx args) 
  (labels 
    ((addArgRec (tcx args n) 
      (block 
       nil 
       (if (null args) 
           (return tcx) 
           (if (consp args) 
               (return 
                (let ((argName (JGEN::mkArgProj (NAT-SPEC::natToString n)))) 
                  (let ((argExpr 
                         (cons 
                          :|CondExp| 
                          (cons 
                           (cons 
                            :|Un| 
                            (cons 
                             :|Prim| 
                             (cons :|Name| (cons (cons "this" nil) argName)))) 
                           '(:|None|))))) 
                    (addArgRec 
                     (STRINGMAP::insert tcx (car args) argExpr) 
                     (cdr args) 
                     (INTEGER-SPEC::|!+| n 1))))))) 
       (error "Nonexhaustive match failure in addArgsToTcx")))) 
    (addArgRec tcx args 1)))

(defun JGEN::addArgsToTcx-1 (x) (JGEN::addArgsToTcx (car x) (cdr x)))

(defun JGEN::setMethods (clsBody methodDecls) 
  (vector 
   (svref clsBody 0) 
   (svref clsBody 1) 
   (svref clsBody 2) 
   (svref clsBody 3) 
   methodDecls 
   (svref clsBody 5)))

(defun JGEN::addMethDeclToClsDecls (srtId methDecl clsDecls) 
  (LIST-SPEC::|!map|-1-1 
   #'(lambda (cd) 
      (let ((pV3 (svref cd 2))
            (pV2 (svref cd 1))) 
        (block 
         nil 
         (let ((pV4 (svref pV2 0))) 
           (return 
            (if (string=  pV4 srtId) 
                (let ((newCb 
                       (JGEN::setMethods 
                        pV3 
                        (LIST-SPEC::|!cons| methDecl (svref pV3 4))))) 
                  (vector 
                   (svref cd 0) 
                   (vector pV4 (svref pV2 1) (svref pV2 2)) 
                   newCb)) 
                cd))) 
         (error "Nonexhaustive match failure in addMethDeclToClsDecls")))) 
   clsDecls))

(defun JGEN::mkSummandId (ty c) (STRING-SPEC::^ (STRING-SPEC::^ ty "_") c))

(defun JGEN::setMethodBody (m b) 
  (block 
   nil 
   (return (cons (car m) (cons :|Some| b))) 
   (error "Nonexhaustive match failure in setMethodBody")))

(defun METASLANG::boolSort? (s) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV4 (cdr s))) 
         (let ((pV5 (svref pV4 0))) 
           (if (eq (car pV5) :|Qualified|) 
               (let ((pV8 (cdr pV5))) 
                 (if (string=  "Boolean" (car pV8)) 
                     (if (string=  "Boolean" (cdr pV8)) 
                         (if (null (svref pV4 1)) (return t))))))))) 
   (return nil)))

(defun METASLANG::integerSort? (s) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV4 (cdr s))) 
         (let ((pV5 (svref pV4 0))) 
           (if (eq (car pV5) :|Qualified|) 
               (let ((pV8 (cdr pV5))) 
                 (if (string=  "Integer" (car pV8)) 
                     (if (string=  "Integer" (cdr pV8)) 
                         (if (null (svref pV4 1)) (return t))))))))) 
   (return nil)))

(defun METASLANG::natSort? (s) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV4 (cdr s))) 
         (let ((pV5 (svref pV4 0))) 
           (if (eq (car pV5) :|Qualified|) 
               (let ((pV8 (cdr pV5))) 
                 (if (string=  "Nat" (car pV8)) 
                     (if (string=  "Nat" (cdr pV8)) 
                         (if (null (svref pV4 1)) (return t))))))))) 
   (return nil)))

(defun JGEN::baseType? (|!type|) 
  (cl:or 
   (METASLANG::boolSort? |!type|) 
   (cl:or (METASLANG::integerSort? |!type|) (METASLANG::natSort? |!type|))))

(defun JGEN::mkJavaNumber (i) 
  (cons 
   :|CondExp| 
   (cons (cons :|Un| (cons :|Prim| (cons :|IntL| i))) '(:|None|))))

(defun JGEN::mkMethInv (srtId opId javaArgs) 
  (cons 
   :|CondExp| 
   (cons 
    (cons 
     :|Un| 
     (cons 
      :|Prim| 
      (cons 
       :|MethInv| 
       (cons :|ViaPrim| (vector (cons :|Name| (cons nil srtId)) opId javaArgs))))) 
    '(:|None|))))

(defun JGEN::mkQualJavaExpr (id1 id2) 
  (cons 
   :|CondExp| 
   (cons 
    (cons :|Un| (cons :|Prim| (cons :|Name| (cons (cons id1 nil) id2)))) 
    '(:|None|))))

(defun JGEN::mkVarJavaExpr (id) 
  (cons 
   :|CondExp| 
   (cons (cons :|Un| (cons :|Prim| (cons :|Name| (cons nil id)))) '(:|None|))))

(defparameter JGEN::mts nil)

(defun JGEN::srtId (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Base|) 
       (let ((pV5 (svref (cdr srt) 0))) 
         (if (eq (car pV5) :|Qualified|) (return (cdr (cdr pV5)))))) 
   (error "Nonexhaustive match failure in srtId")))

(defun JGEN::recordFieldsToTerms (fields) 
  (block 
   nil 
   (if (null fields) 
       (return nil) 
       (if (consp fields) 
           (return 
            (LIST-SPEC::|!cons| 
             (cdr (car fields)) 
             (JGEN::recordFieldsToTerms (cdr fields)))))) 
   (error "Nonexhaustive match failure in recordFieldsToTerms")))

(defun JGEN::applyArgsToTerms (args) 
  (block 
   nil 
   (if (eq (car args) :|Record|) 
       (return (JGEN::recordFieldsToTerms (car (cdr args))))) 
   (return (cons args nil))))

(defun JGEN::javaBaseOp? (id) 
  (block 
   nil 
   (if (string=  "and" id) 
       (return t) 
       (if (string=  "or" id) 
           (return t) 
           (if (string=  "=" id) 
               (return t) 
               (if (string=  ">" id) 
                   (return t) 
                   (if (string=  "<" id) 
                       (return t) 
                       (if (string=  ">=" id) 
                           (return t) 
                           (if (string=  "<=" id) 
                               (return t) 
                               (if (string=  "+" id) 
                                   (return t) 
                                   (if (string=  "-" id) 
                                       (return t) 
                                       (if (string=  "*" id) 
                                           (return t) 
                                           (if (string=  "div" id) 
                                               (return t) 
                                               (if (string=  "rem" id) 
                                                   (return t) 
                                                   (if (string=  "~" id) 
                                                       (return t)))))))))))))) 
   (return nil)))

(defun JGEN::mkBaseJavaBinOp (id) 
  (block 
   nil 
   (if (string=  "and" id) 
       (return '(:|CdAnd|)) 
       (if (string=  "or" id) 
           (return '(:|CdOr|)) 
           (if (string=  "=" id) 
               (return '(:|Eq|)) 
               (if (string=  ">" id) 
                   (return '(:|Gt|)) 
                   (if (string=  "<" id) 
                       (return '(:|Lt|)) 
                       (if (string=  ">=" id) 
                           (return '(:|Ge|)) 
                           (if (string=  "<=" id) 
                               (return '(:|Le|)) 
                               (if (string=  "+" id) 
                                   (return '(:|Plus|)) 
                                   (if (string=  "-" id) 
                                       (return '(:|Minus|)) 
                                       (if (string=  "*" id) 
                                           (return '(:|Mul|)) 
                                           (if (string=  "div" id) 
                                               (return '(:|Div|)) 
                                               (if (string=  "rem" id) 
                                                   (return '(:|Rem|)))))))))))))) 
   (error "Nonexhaustive match failure in mkBaseJavaBinOp")))

(defun JGEN::mkBinExp (opId javaArgs) 
  (block 
   nil 
   (if (consp javaArgs) 
       (let ((pV4 (cdr javaArgs))) 
         (if (consp pV4) 
             (if (null (cdr pV4)) 
                 (return 
                  (cons 
                   :|CondExp| 
                   (cons 
                    (cons 
                     :|Bin| 
                     (vector 
                      (JGEN::mkBaseJavaBinOp opId) 
                      (cons :|Un| (cons :|Prim| (cons :|Paren| (car javaArgs)))) 
                      (cons :|Un| (cons :|Prim| (cons :|Paren| (car pV4)))))) 
                    '(:|None|)))))))) 
   (error "Nonexhaustive match failure in mkBinExp")))

(defun JGEN::mkBaseJavaUnOp (id) 
  (block 
   nil 
   (if (string=  "-" id) 
       (return '(:|Minus|)) 
       (if (string=  "~" id) (return '(:|LogNot|)))) 
   (error "Nonexhaustive match failure in mkBaseJavaUnOp")))

(defun JGEN::mkUnExp (opId javaArgs) 
  (block 
   nil 
   (if (consp javaArgs) 
       (if (null (cdr javaArgs)) 
           (return 
            (cons 
             :|CondExp| 
             (cons 
              (cons 
               :|Un| 
               (cons 
                :|Un| 
                (cons 
                 (JGEN::mkBaseJavaUnOp opId) 
                 (cons :|Prim| (cons :|Paren| (car javaArgs)))))) 
              '(:|None|)))))) 
   (error "Nonexhaustive match failure in mkUnExp")))

(defun JGEN::translateTermsToExpressions (tcx terms k) 
  (block 
   nil 
   (if (null terms) 
       (return (vector nil nil k)) 
       (if (consp terms) 
           (return 
            (let ((pV5 (JGEN::termToExpression tcx (car terms) k))) 
              (block 
               nil 
               (return 
                (let ((pV1 
                       (JGEN::translateTermsToExpressions 
                        tcx 
                        (cdr terms) 
                        (svref pV5 2)))) 
                  (block 
                   nil 
                   (return 
                    (vector 
                     (LIST-SPEC::|!++| (svref pV5 0) (svref pV1 0)) 
                     (LIST-SPEC::|!cons| (svref pV5 1) (svref pV1 1)) 
                     (svref pV1 2))) 
                   (error 
                    "Nonexhaustive match failure in translateTermsToExpressions")))) 
               (error 
                "Nonexhaustive match failure in translateTermsToExpressions")))))) 
   (error "Nonexhaustive match failure in translateTermsToExpressions")))

(defun JGEN::translateBaseApplToExpr (tcx opId argsTerm k) 
  (let ((args (JGEN::applyArgsToTerms argsTerm))) 
    (let ((pV1 (JGEN::translateTermsToExpressions tcx args k))) 
      (block 
       nil 
       (let ((pV4 (svref pV1 2))
             (pV3 (svref pV1 1))
             (pV2 (svref pV1 0))) 
         (return 
          (if (JGEN::javaBaseOp? opId) 
              (if ( =  (LIST-SPEC::|!length| args) 2) 
                  (vector pV2 (JGEN::mkBinExp opId pV3) pV4) 
                  (vector pV2 (JGEN::mkUnExp opId pV3) pV4)) 
              (vector pV2 (JGEN::mkMethInv "Primitive" opId pV3) pV4)))) 
       (error "Nonexhaustive match failure in translateBaseApplToExpr")))))

(defun JGEN::translateBaseArgsApplToExpr (tcx opId argsTerm rng k) 
  (let ((args (JGEN::applyArgsToTerms argsTerm))) 
    (let ((pV1 (JGEN::translateTermsToExpressions tcx args k))) 
      (block 
       nil 
       (let ((pV4 (svref pV1 2))
             (pV3 (svref pV1 1))
             (pV2 (svref pV1 0))) 
         (return 
          (if (JGEN::javaBaseOp? opId) 
              (vector pV2 (JGEN::mkBinExp opId pV3) pV4) 
              (vector pV2 (JGEN::mkMethInv (JGEN::srtId rng) opId pV3) pV4)))) 
       (error "Nonexhaustive match failure in translateBaseArgsApplToExpr")))))

(defun JGEN::translateConstructToExpr (tcx srtId opId argsTerm k) 
  (let ((args (JGEN::applyArgsToTerms argsTerm))) 
    (let ((pV1 (JGEN::translateTermsToExpressions tcx args k))) 
      (block 
       nil 
       (return 
        (vector 
         (svref pV1 0) 
         (JGEN::mkMethInv srtId opId (svref pV1 1)) 
         (svref pV1 2))) 
       (error "Nonexhaustive match failure in translateConstructToExpr")))))

(defun JGEN::mkJavaEq (e1 e2 t1) 
  (if (cl:or (string=  t1 "Boolean") (string=  t1 "Integer")) 
      (cons 
       :|CondExp| 
       (cons 
        (cons 
         :|Bin| 
         (vector 
          '(:|Eq|) 
          (cons :|Un| (cons :|Prim| (cons :|Paren| e1))) 
          (cons :|Un| (cons :|Prim| (cons :|Paren| e2))))) 
        '(:|None|))) 
      (cons 
       :|CondExp| 
       (cons 
        (cons 
         :|Un| 
         (cons 
          :|Prim| 
          (cons 
           :|MethInv| 
           (cons :|ViaPrim| (vector (cons :|Paren| e1) "equals" (cons e2 nil)))))) 
        '(:|None|)))))

(defun LIST-SPEC::hd (l) 
  (block 
   nil 
   (if (consp l) (return (car l))) 
   (error "Nonexhaustive match failure in hd")))

(defun JGEN::translateEqualsToExpr (tcx argsTerm k) 
  (let ((args (JGEN::applyArgsToTerms argsTerm))) 
    (let ((pV1 (JGEN::translateTermsToExpressions tcx args k))) 
      (block 
       nil 
       (let ((pV3 (svref pV1 1))) 
         (if (consp pV3) 
             (let ((pV7 (cdr pV3))) 
               (if (consp pV7) 
                   (if (null (cdr pV7)) 
                       (return 
                        (vector 
                         (svref pV1 0) 
                         (JGEN::mkJavaEq 
                          (car pV3) 
                          (car pV7) 
                          (JGEN::srtId 
                           (METASLANG::termSort (LIST-SPEC::hd args)))) 
                         (svref pV1 2)))))))) 
       (error "Nonexhaustive match failure in translateEqualsToExpr")))))

(defun JGEN::mkFldAcc (e id) 
  (cons 
   :|CondExp| 
   (cons 
    (cons 
     :|Un| 
     (cons 
      :|Prim| 
      (cons :|FldAcc| (cons :|ViaPrim| (cons (cons :|Paren| e) id))))) 
    '(:|None|))))

(defun JGEN::translateProjectToExpr (tcx id argsTerm k) 
  (let ((args (JGEN::applyArgsToTerms argsTerm))) 
    (let ((pV1 (JGEN::translateTermsToExpressions tcx args k))) 
      (block 
       nil 
       (let ((pV3 (svref pV1 1))) 
         (if (consp pV3) 
             (if (null (cdr pV3)) 
                 (return 
                  (vector 
                   (svref pV1 0) 
                   (JGEN::mkFldAcc (car pV3) id) 
                   (svref pV1 2)))))) 
       (error "Nonexhaustive match failure in translateProjectToExpr")))))

(defun JGEN::mkMethExprInv (topJArg opId javaArgs) 
  (cons 
   :|CondExp| 
   (cons 
    (cons 
     :|Un| 
     (cons 
      :|Prim| 
      (cons 
       :|MethInv| 
       (cons :|ViaPrim| (vector (cons :|Paren| topJArg) opId javaArgs))))) 
    '(:|None|))))

(defun JGEN::userType? (|!type|) (BOOLEAN-SPEC::~ (JGEN::baseType? |!type|)))

(defun LIST-SPEC::|!nth| (ls i) 
  (block 
   nil 
   (if (consp ls) 
       (return 
        (if ( =  i 0) 
            (car ls) 
            (LIST-SPEC::|!nth| (cdr ls) (INTEGER-SPEC::|!-| i 1))))) 
   (error "Nonexhaustive match failure in nth")))

(defun LIST-SPEC::tl (l) 
  (block 
   nil 
   (if (consp l) (return (cdr l))) 
   (error "Nonexhaustive match failure in tl")))

(defun LISTUTILITIES::deleteNth (n ls) 
  (if ( =  n 0) 
      (LIST-SPEC::tl ls) 
      (cons 
       (LIST-SPEC::hd ls) 
       (LISTUTILITIES::deleteNth (INTEGER-SPEC::|!-| n 1) (LIST-SPEC::tl ls)))))

(defun LISTUTILITIES::findIndex-1-1 (p l) 
  (labels 
    ((findIndexRec (p l n) 
      (block 
       nil 
       (if (null l) 
           (return '(:|None|)) 
           (if (consp l) 
               (let ((pV3 (car l))) 
                 (return 
                  (if (funcall p pV3) 
                      (cons :|Some| (cons n pV3)) 
                      (findIndexRec p (cdr l) (INTEGER-SPEC::|!+| n 1))))))) 
       (error "Nonexhaustive match failure in findIndex")))) 
    (findIndexRec p l 0)))

(defun JGEN::translateUserApplToExpr (tcx opId dom argsTerm k) 
  (let ((args (JGEN::applyArgsToTerms argsTerm))) 
    (let ((pV6 
           (LISTUTILITIES::findIndex-1-1 
            #'(lambda (srt) (JGEN::userType? srt)) 
            dom))) 
      (block 
       nil 
       (if (eq (car pV6) :|Some|) 
           (let ((pV8 (car (cdr pV6)))) 
             (return 
              (let ((pV2 (JGEN::translateTermsToExpressions tcx args k))) 
                (block 
                 nil 
                 (let ((pV4 (svref pV2 1))) 
                   (return 
                    (let ((topJArg (LIST-SPEC::|!nth| pV4 pV8))) 
                      (let ((resJArgs (LISTUTILITIES::deleteNth pV8 pV4))) 
                        (vector 
                         (svref pV2 0) 
                         (JGEN::mkMethExprInv topJArg opId resJArgs) 
                         (svref pV2 2)))))) 
                 (error "Nonexhaustive match failure in translateUserApplToExpr")))))) 
       (error "Nonexhaustive match failure in translateUserApplToExpr")))))

(defun JGEN::translateApplyToExpr (pV24 pV25 pV26) 
  (block 
   nil 
   (if (eq (car pV25) :|Apply|) 
       (let ((pV27 (cdr pV25))) 
         (let ((pV29 (svref pV27 1))
               (pV28 (svref pV27 0))) 
           (return 
            (block 
             nil 
             (if (eq (car pV28) :|Fun|) 
                 (let ((pV11 (svref (cdr pV28) 0))) 
                   (if (eq (car pV11) :|Equals|) 
                       (return (JGEN::translateEqualsToExpr pV24 pV29 pV26)) 
                       (if (eq (car pV11) :|Project|) 
                           (return 
                            (JGEN::translateProjectToExpr 
                             pV24 
                             (cdr pV11) 
                             pV29 
                             pV26)) 
                           (if (eq (car pV11) :|Embed|) 
                               (return 
                                (JGEN::translateConstructToExpr 
                                 pV24 
                                 (JGEN::srtId (METASLANG::termSort pV25)) 
                                 (car (cdr pV11)) 
                                 pV29 
                                 pV26)) 
                               (if (eq (car pV11) :|Op|) 
                                   (let ((pV17 (car (cdr pV11)))) 
                                     (if (eq (car pV17) :|Qualified|) 
                                         (let ((pV19 (cdr pV17))) 
                                           (let ((pV21 (cdr pV19))
                                                 (pV20 (car pV19))) 
                                             (return 
                                              (let ((id 
                                                     (if (cl:and 
                                                          (string=  pV21 "~") 
                                                          (cl:or 
                                                           (string=  
                                                            pV20 
                                                            "Integer") 
                                                           (string=  pV20 "Nat"))) 
                                                         "-" 
                                                         pV21))) 
                                                (let ((srt 
                                                       (METASLANG::termSort pV25))) 
                                                  (let ((args 
                                                         (JGEN::applyArgsToTerms 
                                                          pV29))) 
                                                    (let ((dom 
                                                           (LIST-SPEC::|!map|-1-1 
                                                            #'METASLANG::termSort 
                                                            args))) 
                                                      (if (LIST-SPEC::all-1-1 
                                                           #'(lambda (srt1) 
                                                              (JGEN::baseType? 
                                                               srt1)) 
                                                           dom) 
                                                          (if (JGEN::baseType? 
                                                               srt) 
                                                              (JGEN::translateBaseApplToExpr 
                                                               pV24 
                                                               id 
                                                               pV29 
                                                               pV26) 
                                                              (JGEN::translateBaseArgsApplToExpr 
                                                               pV24 
                                                               id 
                                                               pV29 
                                                               srt 
                                                               pV26)) 
                                                          (JGEN::translateUserApplToExpr 
                                                           pV24 
                                                           id 
                                                           dom 
                                                           pV29 
                                                           pV26))))))))))))))))) 
             (error "Nonexhaustive match failure in translateApplyToExpr")))))) 
   (error "Nonexhaustive match failure in translateApplyToExpr")))

(defun JGEN::mkIfRes (k) (STRING-SPEC::^ "ifres_" (NAT-SPEC::natToString k)))

(defun JGEN::mkIfStmt (jT0 b1 b2) 
  (cons 
   :|Stmt| 
   (cons :|If| (vector jT0 (cons :|Block| b1) (cons :|Some| (cons :|Block| b2))))))


(defun JGEN::mkVarAssn (v jT1) 
  (cons 
   :|Stmt| 
   (cons 
    :|Expr| 
    (cons :|Ass| (vector (cons :|Name| (cons nil v)) '(:|Assgn|) jT1)))))

(defun JGEN::tt (id) 
  (block 
   nil 
   (if (string=  "Boolean" id) 
       (return (cons (cons :|Basic| '(:|JBool|)) 0)) 
       (if (string=  "Integer" id) (return (cons (cons :|Basic| '(:|JInt|)) 0)))) 
   (return (cons (cons :|Name| (cons nil id)) 0))))

(defun JGEN::mkVarDecl (v srtId) 
  (cons 
   :|LocVarDecl| 
   (vector nil (JGEN::tt srtId) (cons (cons v 0) '(:|None|)) nil)))

(defun JGEN::translateIfThenElseToExpr (pV16 pV17 pV18) 
  (block 
   nil 
   (if (eq (car pV17) :|IfThenElse|) 
       (let ((pV19 (cdr pV17))) 
         (let ((pV22 (svref pV19 2))) 
           (return 
            (let ((pV12 
                   (JGEN::termToExpression 
                    pV16 
                    (svref pV19 0) 
                    (INTEGER-SPEC::|!+| pV18 1)))) 
              (block 
               nil 
               (let ((pV14 (svref pV12 1))
                     (pV13 (svref pV12 0))) 
                 (return 
                  (let ((pV8 
                         (JGEN::termToExpression 
                          pV16 
                          (svref pV19 1) 
                          (svref pV12 2)))) 
                    (block 
                     nil 
                     (let ((pV10 (svref pV8 1))
                           (pV9 (svref pV8 0))) 
                       (return 
                        (let ((pV4 
                               (JGEN::termToExpression pV16 pV22 (svref pV8 2)))) 
                          (block 
                           nil 
                           (let ((pV7 (svref pV4 2))
                                 (pV6 (svref pV4 1))
                                 (pV5 (svref pV4 0))) 
                             (return 
                              (let ((pV3 (LIST-SPEC::|!++| pV9 pV5))) 
                                (block 
                                 nil 
                                 (if (null pV3) 
                                     (return 
                                      (let ((vExpr 
                                             (cons 
                                              :|CondExp| 
                                              (cons 
                                               (cons 
                                                :|Un| 
                                                (cons 
                                                 :|Prim| 
                                                 (cons :|Paren| pV14))) 
                                               (cons 
                                                :|Some| 
                                                (cons 
                                                 pV10 
                                                 (cons 
                                                  (cons 
                                                   :|Un| 
                                                   (cons 
                                                    :|Prim| 
                                                    (cons :|Paren| pV6))) 
                                                  '(:|None|)))))))) 
                                        (vector pV13 vExpr pV7)))) 
                                 (return 
                                  (let ((v (JGEN::mkIfRes pV18))) 
                                    (let ((vDecl 
                                           (JGEN::mkVarDecl 
                                            v 
                                            (JGEN::srtId 
                                             (METASLANG::termSort pV22))))) 
                                      (let ((vAss1 (JGEN::mkVarAssn v pV10))) 
                                        (let ((vAss2 (JGEN::mkVarAssn v pV6))) 
                                          (let ((ifStmt 
                                                 (JGEN::mkIfStmt 
                                                  pV14 
                                                  (LIST-SPEC::|!++| 
                                                   pV9 
                                                   (cons vAss1 nil)) 
                                                  (LIST-SPEC::|!++| 
                                                   pV5 
                                                   (cons vAss2 nil))))) 
                                            (let ((vExpr (JGEN::mkVarJavaExpr v))) 
                                              (vector 
                                               (LIST-SPEC::|!++| 
                                                pV13 
                                                (cons vDecl (cons ifStmt nil))) 
                                               vExpr 
                                               pV7)))))))))))) 
                           (error 
                            "Nonexhaustive match failure in translateIfThenElseToExpr"))))) 
                     (error 
                      "Nonexhaustive match failure in translateIfThenElseToExpr"))))) 
               (error "Nonexhaustive match failure in translateIfThenElseToExpr"))))))) 
   (error "Nonexhaustive match failure in translateIfThenElseToExpr")))

(defun JGEN::mkVarInit (vId srtId jInit) 
  (cons 
   :|LocVarDecl| 
   (vector 
    nil 
    (JGEN::tt srtId) 
    (cons (cons vId 0) (cons :|Some| (cons :|Expr| jInit))) 
    nil)))

(defun JGEN::translateLetToExpr (pV23 pV24 pV25) 
  (block 
   nil 
   (if (eq (car pV24) :|Let|) 
       (let ((pV26 (cdr pV24))) 
         (let ((pV27 (svref pV26 0))) 
           (return 
            (block 
             nil 
             (if (consp pV27) 
                 (let ((pV16 (car pV27))) 
                   (let ((pV18 (car pV16))) 
                     (if (eq (car pV18) :|VarPat|) 
                         (let ((pV21 (car (cdr pV18)))) 
                           (if (null (cdr pV27)) 
                               (return 
                                (let ((pV10 
                                       (JGEN::termToExpression 
                                        pV23 
                                        (cdr pV16) 
                                        pV25))) 
                                  (block 
                                   nil 
                                   (return 
                                    (let ((pV6 
                                           (JGEN::termToExpression 
                                            pV23 
                                            (svref pV26 1) 
                                            (svref pV10 2)))) 
                                      (block 
                                       nil 
                                       (return 
                                        (block 
                                         nil 
                                         (return 
                                          (let ((vInit 
                                                 (JGEN::mkVarInit 
                                                  (car pV21) 
                                                  (JGEN::srtId (cdr pV21)) 
                                                  (svref pV10 1)))) 
                                            (vector 
                                             (LIST-SPEC::|!++| 
                                              (LIST-SPEC::|!++| 
                                               (svref pV10 0) 
                                               (cons vInit nil)) 
                                              (svref pV6 0)) 
                                             (svref pV6 1) 
                                             (svref pV6 2)))) 
                                         (error 
                                          "Nonexhaustive match failure in translateLetToExpr"))) 
                                       (error 
                                        "Nonexhaustive match failure in translateLetToExpr")))) 
                                   (error 
                                    "Nonexhaustive match failure in translateLetToExpr")))))))))) 
             (error "Nonexhaustive match failure in translateLetToExpr")))))) 
   (error "Nonexhaustive match failure in translateLetToExpr")))

(defun JGEN::mkNewClasInst (id javaArgs) 
  (cons 
   :|CondExp| 
   (cons 
    (cons 
     :|Un| 
     (cons 
      :|Prim| 
      (cons 
       :|NewClsInst| 
       (cons :|ForCls| (vector (cons nil id) javaArgs '(:|None|)))))) 
    '(:|None|))))

(defun JGEN::translateRecordToExpr (pV6 pV7 pV8) 
  (block 
   nil 
   (if (eq (car pV7) :|Record|) 
       (return 
        (let ((recordTerms (JGEN::recordFieldsToTerms (car (cdr pV7))))) 
          (let ((pV2 (JGEN::translateTermsToExpressions pV6 recordTerms pV8))) 
            (block 
             nil 
             (return 
              (vector 
               (svref pV2 0) 
               (JGEN::mkNewClasInst "Point" (svref pV2 1)) 
               (svref pV2 2))) 
             (error "Nonexhaustive match failure in translateRecordToExpr")))))) 
   (error "Nonexhaustive match failure in translateRecordToExpr")))

(defun JGEN::termToExpression (tcx term k) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (let ((pV50 (car (car (cdr term))))) 
         (return 
          (let ((pV3 (STRINGMAP::|!find| tcx pV50))) 
            (block 
             nil 
             (if (eq (car pV3) :|Some|) (return (vector JGEN::mts (cdr pV3) k))) 
             (return (vector JGEN::mts (JGEN::mkVarJavaExpr pV50) k)))))) 
       (if (eq (car term) :|Fun|) 
           (let ((pV30 (cdr term))) 
             (let ((pV36 (svref pV30 1))
                   (pV35 (svref pV30 0))) 
               (if (eq (car pV35) :|Op|) 
                   (let ((pV43 (car (cdr pV35)))) 
                     (if (eq (car pV43) :|Qualified|) 
                         (let ((pV47 (cdr (cdr pV43)))) 
                           (return 
                            (if (JGEN::baseType? pV36) 
                                (vector 
                                 JGEN::mts 
                                 (JGEN::mkQualJavaExpr "Primitive" pV47) 
                                 k) 
                                (block 
                                 nil 
                                 (if (eq (car pV36) :|Base|) 
                                     (let ((pV11 (svref (cdr pV36) 0))) 
                                       (if (eq (car pV11) :|Qualified|) 
                                           (return 
                                            (vector 
                                             JGEN::mts 
                                             (JGEN::mkQualJavaExpr 
                                              (cdr (cdr pV11)) 
                                              pV47) 
                                             k))))) 
                                 (error 
                                  "Nonexhaustive match failure in termToExpression"))))))) 
                   (if (eq (car pV35) :|Nat|) 
                       (return 
                        (vector JGEN::mts (JGEN::mkJavaNumber (cdr pV35)) k)) 
                       (if (eq (car pV35) :|Embed|) 
                           (return 
                            (vector 
                             JGEN::mts 
                             (JGEN::mkMethInv 
                              (JGEN::srtId pV36) 
                              (car (cdr pV35)) 
                              nil) 
                             k))))))) 
           (if (eq (car term) :|Apply|) 
               (return (JGEN::translateApplyToExpr tcx term k)) 
               (if (eq (car term) :|Record|) 
                   (return (JGEN::translateRecordToExpr tcx term k)) 
                   (if (eq (car term) :|IfThenElse|) 
                       (return (JGEN::translateIfThenElseToExpr tcx term k)) 
                       (if (eq (car term) :|Let|) 
                           (return (JGEN::translateLetToExpr tcx term k)))))))) 
   (return (SYSTEM-SPEC::fail "unsupported term in termToExpression"))))

(defun JGEN::addSumMethDeclToClsDecls (pV35 pV36 pV37 pV38 pV39 pV40) 
  (block 
   nil 
   (if (eq (car pV37) :|EmbedPat|) 
       (let ((pV41 (cdr pV37))) 
         (let ((pV43 (svref pV41 1))) 
           (return 
            (block 
             nil 
             (if (eq (car pV36) :|Var|) 
                 (return 
                  (let ((args 
                         (block 
                          nil 
                          (if (eq (car pV43) :|Some|) 
                              (let ((pV16 (cdr pV43))) 
                                (if (eq (car pV16) :|RecordPat|) 
                                    (return 
                                     (LIST-SPEC::|!map|-1-1 
                                      #'(lambda (x) 
                                         (let ((pV7 (cdr x))) 
                                           (block 
                                            nil 
                                            (if (eq (car pV7) :|VarPat|) 
                                                (return (car (car (cdr pV7))))) 
                                            (error 
                                             "Nonexhaustive match failure in addSumMethDeclToClsDecls")))) 
                                      (car (cdr pV16)))) 
                                    (if (eq (car pV16) :|VarPat|) 
                                        (return 
                                         (cons (car (car (cdr pV16))) nil))))) 
                              (if (eq (car pV43) :|None|) (return nil))) 
                          (error 
                           "Nonexhaustive match failure in addSumMethDeclToClsDecls")))) 
                    (let ((summandId (JGEN::mkSummandId pV35 (svref pV41 0)))) 
                      (let ((thisExpr 
                             (cons 
                              :|CondExp| 
                              (cons 
                               (cons 
                                :|Un| 
                                (cons :|Prim| (cons :|Name| (cons nil "this")))) 
                               '(:|None|))))) 
                        (let ((tcx 
                               (STRINGMAP::insert 
                                STRINGMAP::empty 
                                (car (car (cdr pV36))) 
                                thisExpr))) 
                          (let ((tcx (JGEN::addArgsToTcx tcx args))) 
                            (let ((pV25 (JGEN::termToExpression tcx pV38 1))) 
                              (block 
                               nil 
                               (return 
                                (let ((JBody 
                                       (LIST-SPEC::|!++| 
                                        (svref pV25 0) 
                                        (cons 
                                         (cons 
                                          :|Stmt| 
                                          (cons 
                                           :|Return| 
                                           (cons :|Some| (svref pV25 1)))) 
                                         nil)))) 
                                  (let ((newMethDecl 
                                         (JGEN::setMethodBody pV39 JBody))) 
                                    (JGEN::addMethDeclToClsDecls 
                                     summandId 
                                     newMethDecl 
                                     pV40)))) 
                               (error 
                                "Nonexhaustive match failure in addSumMethDeclToClsDecls")))))))))) 
             (error "Nonexhaustive match failure in addSumMethDeclToClsDecls")))))) 
   (error "Nonexhaustive match failure in addSumMethDeclToClsDecls")))

(defun JGEN::caseCases (trm) 
  (block 
   nil 
   (if (eq (car trm) :|Apply|) 
       (let ((pV5 (svref (cdr trm) 0))) 
         (if (eq (car pV5) :|Lambda|) (return (car (cdr pV5)))))) 
   (error "Nonexhaustive match failure in caseCases")))

(defun JGEN::caseTerm (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV4 (cdr term))) 
         (if (eq (car (svref pV4 0)) :|Lambda|) (return (svref pV4 1))))) 
   (error "Nonexhaustive match failure in caseTerm")))

(defun METASLANG::mkUnQualifiedId (id) 
  (cons :|Qualified| (cons METASLANG::UnQualified id)))

(defun JGEN::addMethDeclToSummands (spc srthId methodDecl body clsDecls) 
  (let ((pV15 
         (STANDARDSPEC::findTheSort spc (METASLANG::mkUnQualifiedId srthId)))) 
    (block 
     nil 
     (if (eq (car pV15) :|Some|) 
         (let ((pV19 (svref (cdr pV15) 2))) 
           (if (consp pV19) 
               (if (null (cdr pV19)) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car (cdr (car pV19))) :|CoProduct|) 
                         (return 
                          (let ((caseTerm (JGEN::caseTerm body))) 
                            (let ((cases (JGEN::caseCases body))) 
                              (LIST-SPEC::foldr-1-1-1 
                               #'(lambda (x) 
                                  (let ((pV6 (car x))) 
                                    (block 
                                     nil 
                                     (return 
                                      (JGEN::addSumMethDeclToClsDecls 
                                       srthId 
                                       caseTerm 
                                       (svref pV6 0) 
                                       (svref pV6 2) 
                                       methodDecl 
                                       (cdr x))) 
                                     (error 
                                      "Nonexhaustive match failure in addMethDeclToSummands")))) 
                               clsDecls 
                               cases))))) 
                     (error 
                      "Nonexhaustive match failure in addMethDeclToSummands"))))))) 
     (error "Nonexhaustive match failure in addMethDeclToSummands"))))

(defun JGEN::varToFormalParam-1 (var) 
  (let ((pV4 (cdr var))) 
    (block 
     nil 
     (if (eq (car pV4) :|Base|) 
         (let ((pV6 (svref (cdr pV4) 0))) 
           (if (eq (car pV6) :|Qualified|) 
               (return 
                (vector nil (JGEN::tt (cdr (cdr pV6))) (cons (car var) 0)))))) 
     (error "Nonexhaustive match failure in varToFormalParam"))))

(defun JGEN::varsToFormalParams (vars) 
  (LIST-SPEC::|!map|-1-1 #'JGEN::varToFormalParam-1 vars))

(defun LIST-SPEC::splitListHelper (p l res) 
  (block 
   nil 
   (if (null l) 
       (return '(:|None|)) 
       (if (consp l) 
           (let ((pV4 (cdr l))
                 (pV3 (car l))) 
             (return 
              (if (funcall p pV3) 
                  (cons :|Some| (vector (LIST-SPEC::rev res) pV3 pV4)) 
                  (LIST-SPEC::splitListHelper p pV4 (cons pV3 res))))))) 
   (error "Nonexhaustive match failure in splitListHelper")))

(defun LIST-SPEC::splitList-1-1 (p l) (LIST-SPEC::splitListHelper p l nil))

(defun JGEN::addCaseMethodsToClsDecls
 (spc opId dom rng rngId vars body clsDecls) 
  (let ((pV14 
         (LIST-SPEC::splitList-1-1 
          #'(lambda (v) (JGEN::userType? (cdr v))) 
          vars))) 
    (block 
     nil 
     (if (eq (car pV14) :|Some|) 
         (let ((pV15 (cdr pV14))) 
           (let ((pV18 (svref pV15 2))
                 (pV16 (svref pV15 0))) 
             (return 
              (let ((methodDeclA 
                     (cons 
                      (vector 
                       (cons '(:|Abstract|) nil) 
                       (let ((x (JGEN::tt rngId))) 
                         (cons :|Some| (cons (car x) (cdr x)))) 
                       opId 
                       (JGEN::varsToFormalParams (LIST-SPEC::|!++| pV16 pV18)) 
                       nil) 
                      '(:|None|)))) 
                (let ((methodDecl 
                       (cons 
                        (vector 
                         nil 
                         (let ((x (JGEN::tt rngId))) 
                           (cons :|Some| (cons (car x) (cdr x)))) 
                         opId 
                         (JGEN::varsToFormalParams (LIST-SPEC::|!++| pV16 pV18)) 
                         nil) 
                        '(:|None|)))) 
                  (block 
                   nil 
                   (let ((pV6 (cdr (svref pV15 1)))) 
                     (if (eq (car pV6) :|Base|) 
                         (let ((pV8 (svref (cdr pV6) 0))) 
                           (if (eq (car pV8) :|Qualified|) 
                               (let ((pV13 (cdr (cdr pV8)))) 
                                 (return 
                                  (let ((newClsDecls 
                                         (JGEN::addMethDeclToClsDecls 
                                          pV13 
                                          methodDeclA 
                                          clsDecls))) 
                                    (JGEN::addMethDeclToSummands 
                                     spc 
                                     pV13 
                                     methodDecl 
                                     body 
                                     newClsDecls)))))))) 
                   (error 
                    "Nonexhaustive match failure in addCaseMethodsToClsDecls")))))))) 
     (error "Nonexhaustive match failure in addCaseMethodsToClsDecls"))))

(defun JGEN::addCaseMethodsToClsDecls-1 (x) 
  (JGEN::addCaseMethodsToClsDecls 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6) 
   (svref x 7)))

(defun JGEN::setFlds (clsBody fldDecls) 
  (vector 
   (svref clsBody 0) 
   (svref clsBody 1) 
   fldDecls 
   (svref clsBody 3) 
   (svref clsBody 4) 
   (svref clsBody 5)))

(defun JGEN::addFldDeclToClsDecls (srtId fldDecl clsDecls) 
  (LIST-SPEC::|!map|-1-1 
   #'(lambda (cd) 
      (let ((pV3 (svref cd 2))
            (pV2 (svref cd 1))) 
        (block 
         nil 
         (let ((pV4 (svref pV2 0))) 
           (return 
            (if (string=  pV4 srtId) 
                (let ((newCb 
                       (JGEN::setFlds 
                        pV3 
                        (LIST-SPEC::|!cons| fldDecl (svref pV3 2))))) 
                  (vector 
                   (svref cd 0) 
                   (vector pV4 (svref pV2 1) (svref pV2 2)) 
                   newCb)) 
                cd))) 
         (error "Nonexhaustive match failure in addFldDeclToClsDecls")))) 
   clsDecls))

(defun JGEN::addFldDeclToClsDecls-1 (x) 
  (JGEN::addFldDeclToClsDecls (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::addMethDeclToClsDecls-1 (x) 
  (JGEN::addMethDeclToClsDecls (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::addMethDeclToSummands-1 (x) 
  (JGEN::addMethDeclToSummands 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JGEN::mkPrimArgsMethodBody (body) 
  (let ((pV1 (JGEN::termToExpression STRINGMAP::empty body 1))) 
    (block 
     nil 
     (return 
      (LIST-SPEC::|!++| 
       (svref pV1 0) 
       (cons (cons :|Stmt| (cons :|Return| (cons :|Some| (svref pV1 1)))) nil))) 
     (error "Nonexhaustive match failure in mkPrimArgsMethodBody"))))

(defun JGEN::patternNameOpt (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) 
       (return (cons :|Some| (car (car (cdr pattern)))))) 
   (return '(:|None|))))

(defun JGEN::patternNamesOpt (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) 
       (return (cons :|Some| (cons (car (car (cdr pattern))) nil))) 
       (if (eq (car pattern) :|RecordPat|) 
           (return 
            (LIST-SPEC::foldl-1-1-1 
             #'(lambda (x) 
                (let ((pV12 (cdr x))) 
                  (block 
                   nil 
                   (return 
                    (block 
                     nil 
                     (if (eq (car pV12) :|Some|) 
                         (return 
                          (let ((pV6 (JGEN::patternNameOpt (cdr (car x))))) 
                            (block 
                             nil 
                             (if (eq (car pV6) :|Some|) 
                                 (return 
                                  (cons 
                                   :|Some| 
                                   (LIST-SPEC::|!++| 
                                    (cdr pV12) 
                                    (cons (cdr pV6) nil))))) 
                             (return '(:|None|)))))) 
                     (return '(:|None|)))) 
                   (error "Nonexhaustive match failure in patternNamesOpt")))) 
             (cons :|Some| nil) 
             (car (cdr pattern)))))) 
   (return '(:|None|))))

(defun JGEN::srtDom (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV12 (svref (cdr srt) 0))) 
         (return 
          (let ((argSorts 
                 (block 
                  nil 
                  (if (eq (car pV12) :|Product|) 
                      (return 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (x) (cdr x)) 
                        (car (cdr pV12))))) 
                  (return (cons pV12 nil))))) argSorts)))) 
   (return nil)))

(defun JGEN::srtRange (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) (return (svref (cdr srt) 1))) 
   (return srt)))

(defun JGEN::srtTermDelta (srt term) 
  (let ((opDom (JGEN::srtDom srt))) 
    (progn (JGEN::srtRange srt) 
           (block 
            nil 
            (if (eq (car term) :|Lambda|) 
                (let ((pV8 (car (cdr term)))) 
                  (if (consp pV8) 
                      (let ((pV11 (car pV8))) 
                        (if (null (cdr pV8)) 
                            (return 
                             (let ((argNames 
                                    (JGEN::patternNamesOpt (svref pV11 0)))) 
                               (block 
                                nil 
                                (if (eq (car argNames) :|Some|) 
                                    (let ((pV4 (cdr argNames))) 
                                      (return 
                                       (let ((|!numArgs| 
                                              (LIST-SPEC::|!length| pV4))) 
                                         (let ((arity 
                                                (LIST-SPEC::|!length| opDom))) 
                                           (if ( =  arity |!numArgs|) 
                                               (let ((newArgs 
                                                      (LISTPAIR::|!map|-1-1 
                                                       #'(lambda (x) 
                                                          (cons (car x) (cdr x))) 
                                                       (cons pV4 opDom)))) 
                                                 (cons newArgs (svref pV11 2))) 
                                               (SYSTEM-SPEC::fail 
                                                "type Mismatch in delta"))))))) 
                                (return 
                                 (SYSTEM-SPEC::fail "type Mismatch in delta")))))))))) 
            (return (cons nil term))))))

(defun JGEN::addPrimArgsMethodToClsDecls (pV6 pV7 pV8 pV9 pV10 pV11) 
  (declare (ignore pV8)) 
  (block 
   nil 
   (if (eq (car pV9) :|Base|) 
       (let ((pV13 (svref (cdr pV9) 0))) 
         (if (eq (car pV13) :|Qualified|) 
             (let ((pV18 (cdr (cdr pV13)))) 
               (return 
                (let ((pV3 (JGEN::srtTermDelta pV7 pV10))) 
                  (block 
                   nil 
                   (return 
                    (let ((methodDecl 
                           (cons 
                            (vector 
                             (cons '(:|Static|) nil) 
                             (let ((x (JGEN::tt pV18))) 
                               (cons :|Some| (cons (car x) (cdr x)))) 
                             pV6 
                             (JGEN::varsToFormalParams (car pV3)) 
                             nil) 
                            '(:|None|)))) 
                      (let ((methodBody (JGEN::mkPrimArgsMethodBody (cdr pV3)))) 
                        (let ((methodDecl 
                               (JGEN::setMethodBody methodDecl methodBody))) 
                          (JGEN::addMethDeclToClsDecls pV18 methodDecl pV11))))) 
                   (error 
                    "Nonexhaustive match failure in addPrimArgsMethodToClsDecls")))))))) 
   (error "Nonexhaustive match failure in addPrimArgsMethodToClsDecls")))

(defun JGEN::addPrimMethodToClsDecls (pV6 pV7 pV8 pV9 pV10 pV11) 
  (declare (ignore pV8)) 
  (block 
   nil 
   (if (eq (car pV9) :|Base|) 
       (let ((pV13 (svref (cdr pV9) 0))) 
         (if (eq (car pV13) :|Qualified|) 
             (return 
              (let ((pV3 (JGEN::srtTermDelta pV7 pV10))) 
                (block 
                 nil 
                 (return 
                  (let ((methodDecl 
                         (cons 
                          (vector 
                           (cons '(:|Static|) nil) 
                           (let ((x (JGEN::tt (cdr (cdr pV13))))) 
                             (cons :|Some| (cons (car x) (cdr x)))) 
                           pV6 
                           (JGEN::varsToFormalParams (car pV3)) 
                           nil) 
                          '(:|None|)))) 
                    (let ((methodBody (JGEN::mkPrimArgsMethodBody (cdr pV3)))) 
                      (let ((methodDecl 
                             (JGEN::setMethodBody methodDecl methodBody))) 
                        (JGEN::addMethDeclToClsDecls "Primitive" methodDecl pV11))))) 
                 (error "Nonexhaustive match failure in addPrimMethodToClsDecls"))))))) 
   (error "Nonexhaustive match failure in addPrimMethodToClsDecls")))

(defun JGEN::mkNonCaseMethodBody (vId body) 
  (let ((thisExpr 
         (cons 
          :|CondExp| 
          (cons 
           (cons :|Un| (cons :|Prim| (cons :|Name| (cons nil "this")))) 
           '(:|None|))))) 
    (let ((tcx (STRINGMAP::insert STRINGMAP::empty vId thisExpr))) 
      (let ((pV1 (JGEN::termToExpression tcx body 1))) 
        (block 
         nil 
         (return 
          (LIST-SPEC::|!++| 
           (svref pV1 0) 
           (cons 
            (cons :|Stmt| (cons :|Return| (cons :|Some| (svref pV1 1)))) 
            nil))) 
         (error "Nonexhaustive match failure in mkNonCaseMethodBody"))))))

(defun JGEN::addNonCaseMethodsToClsDecls
 (opId dom rng rngId vars body clsDecls) 
  (let ((pV18 
         (LIST-SPEC::splitList-1-1 
          #'(lambda (v) (JGEN::userType? (cdr v))) 
          vars))) 
    (block 
     nil 
     (if (eq (car pV18) :|Some|) 
         (let ((pV19 (cdr pV18))) 
           (let ((pV21 (svref pV19 1))) 
             (return 
              (block 
               nil 
               (return 
                (let ((methodBody (JGEN::mkNonCaseMethodBody (car pV21) body))) 
                  (let ((methodDecl 
                         (cons 
                          (vector 
                           nil 
                           (let ((x (JGEN::tt rngId))) 
                             (cons :|Some| (cons (car x) (cdr x)))) 
                           opId 
                           (JGEN::varsToFormalParams 
                            (LIST-SPEC::|!++| (svref pV19 0) (svref pV19 2))) 
                           nil) 
                          (cons :|Some| methodBody)))) 
                    (block 
                     nil 
                     (let ((pV7 (cdr pV21))) 
                       (if (eq (car pV7) :|Base|) 
                           (let ((pV9 (svref (cdr pV7) 0))) 
                             (if (eq (car pV9) :|Qualified|) 
                                 (return 
                                  (JGEN::addMethDeclToClsDecls 
                                   (cdr (cdr pV9)) 
                                   methodDecl 
                                   clsDecls)))))) 
                     (error 
                      "Nonexhaustive match failure in addNonCaseMethodsToClsDecls"))))) 
               (error 
                "Nonexhaustive match failure in addNonCaseMethodsToClsDecls")))))) 
     (error "Nonexhaustive match failure in addNonCaseMethodsToClsDecls"))))

(defun JGEN::caseTerm? (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (if (eq (car (svref (cdr term) 0)) :|Lambda|) (return t))) 
   (return nil)))

(defun JGEN::addUserMethodToClsDecls (pV6 pV7 pV8 pV9 pV10 pV11 pV12) 
  (block 
   nil 
   (if (eq (car pV10) :|Base|) 
       (let ((pV14 (svref (cdr pV10) 0))) 
         (if (eq (car pV14) :|Qualified|) 
             (let ((pV19 (cdr (cdr pV14)))) 
               (return 
                (let ((pV3 (JGEN::srtTermDelta pV8 pV11))) 
                  (block 
                   nil 
                   (let ((pV5 (cdr pV3))
                         (pV4 (car pV3))) 
                     (return 
                      (if (JGEN::caseTerm? pV5) 
                          (JGEN::addCaseMethodsToClsDecls 
                           pV6 
                           pV7 
                           pV9 
                           pV10 
                           pV19 
                           pV4 
                           pV5 
                           pV12) 
                          (JGEN::addNonCaseMethodsToClsDecls 
                           pV7 
                           pV9 
                           pV10 
                           pV19 
                           pV4 
                           pV5 
                           pV12)))) 
                   (error 
                    "Nonexhaustive match failure in addUserMethodToClsDecls")))))))) 
   (error "Nonexhaustive match failure in addUserMethodToClsDecls")))

(defun JGEN::addMethodFromOpToClsDecls (spc opId srt trm clsDecls) 
  (let ((dom (JGEN::srtDom srt))) 
    (let ((rng (JGEN::srtRange srt))) 
      (if (LIST-SPEC::all-1-1 #'(lambda (srt) (JGEN::baseType? srt)) dom) 
          (if (JGEN::baseType? rng) 
              (JGEN::addPrimMethodToClsDecls opId srt dom rng trm clsDecls) 
              (JGEN::addPrimArgsMethodToClsDecls opId srt dom rng trm clsDecls)) 
          (JGEN::addUserMethodToClsDecls spc opId srt dom rng trm clsDecls)))))

(defun JGEN::addMethodFromOpToClsDecls-1 (x) 
  (JGEN::addMethodFromOpToClsDecls 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JGEN::addNonCaseMethodsToClsDecls-1 (x) 
  (JGEN::addNonCaseMethodsToClsDecls 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun LISTUTILITIES::insert (e l) 
  (block 
   nil 
   (if (null l) 
       (return (cons e nil)) 
       (if (consp l) 
           (let ((pV3 (car l))) 
             (return 
              (if (slang-built-in::slang-term-equals e pV3) 
                  l 
                  (cons pV3 (LISTUTILITIES::insert e (cdr l)))))))) 
   (error "Nonexhaustive match failure in insert")))

(defun LISTUTILITIES::insert-1 (x) (LISTUTILITIES::insert (car x) (cdr x)))

(defun LISTUTILITIES::listUnion (l1 l2) 
  (LIST-SPEC::foldr-1-1-1 #'LISTUTILITIES::insert-1 l1 l2))

(defun SPECCALC::monadBind-1-1 (!x1 state) 
  (let ((x (funcall (car !x1) state))) 
    (let ((pV1 (car x))
          (pV2 (cdr x))) 
      (block 
       nil 
       (if (eq (car pV1) :|Ok|) 
           (return (funcall (funcall (cdr !x1) (cdr pV1)) pV2)) 
           (if (eq (car pV1) :|Exception|) 
               (return (cons (cons :|Exception| (cdr pV1)) pV2)))) 
       (error "Nonexhaustive match failure in monadBind")))))

(defun SPECCALC::monadBind-1 (x1) 
  #'(lambda (x2) (SPECCALC::monadBind-1-1 x1 x2)))

(defun SPECCALC::monadBind (x0 x1) (SPECCALC::monadBind-1 (cons x0 x1)))

(defun SPECCALC::|!return|-1-1 (x state) (cons (cons :|Ok| x) state))

(defun SPECCALC::|!return| (x1) 
  #'(lambda (x2) (SPECCALC::|!return|-1-1 x1 x2)))

(defun SPECCALC::foldM (f) 
  #'(lambda (a) 
     #'(lambda (l) 
        (block 
         nil 
         (if (null l) 
             (return (SPECCALC::|!return| a)) 
             (if (consp l) 
                 (let ((pV4 (cdr l))) 
                   (return 
                    (SPECCALC::monadBind 
                     (funcall (funcall f a) (car l)) 
                     #'(lambda (y) 
                        (funcall (funcall (SPECCALC::foldM f) y) pV4))))))) 
         (error "Nonexhaustive match failure in foldM")))))

(defun SPECCALC::printAliases (pV7) 
  (block 
   nil 
   (if (consp pV7) 
       (let ((pV10 (cdr pV7))
             (pV9 (car pV7))) 
         (return 
          (labels 
            ((print_qid (pV1) 
              (block 
               nil 
               (if (eq (car pV1) :|Qualified|) 
                   (let ((pV2 (cdr pV1))) 
                     (let ((pV4 (cdr pV2))
                           (pV3 (car pV2))) 
                       (return 
                        (if (string=  pV3 METASLANG::UnQualified) 
                            pV4 
                            (STRING-SPEC::^ (STRING-SPEC::^ pV3 ".") pV4)))))) 
               (error "Nonexhaustive match failure in printAliases")))) 
            (let ((str (print_qid pV9))) 
              (block 
               nil 
               (if (null pV10) (return str)) 
               (return 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  "{" 
                  (LIST-SPEC::foldl-1-1-1 
                   #'(lambda (x) 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ (cdr x) ",") 
                       (print_qid (car x)))) 
                   str 
                   pV10)) 
                 "}")))))))) 
   (error "Nonexhaustive match failure in printAliases")))

(defun SPECCALC::printTypeVars (vars) 
  (block 
   nil 
   (if (null vars) 
       (return "()") 
       (if (consp vars) 
           (return 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ "(" (car vars)) 
              (LIST-SPEC::foldl-1-1-1 
               #'(lambda (x) 
                  (STRING-SPEC::^ (STRING-SPEC::^ (cdr x) ",") (car x))) 
               "" 
               (cdr vars))) 
             ")")))) 
   (error "Nonexhaustive match failure in printTypeVars")))

(defun SPECCALC::raise-1-1 (except state) 
  (progn (if SPECCALC::specwareWizard? 
             (SYSTEM-SPEC::fail (SYSTEM-SPEC::toString except)) 
             nil) 
         (cons (cons :|Exception| except) state)))

(defun SPECCALC::raise (x1) #'(lambda (x2) (SPECCALC::raise-1-1 x1 x2)))

(defun SPECCALC::addOp (new_op_names) 
  #'(lambda (new_fixity) 
     #'(lambda (new_sort_scheme) 
        (let ((new_type_vars (car new_sort_scheme))) 
          #'(lambda (new_defs) 
             #'(lambda (old_spec) 
                #'(lambda (|!position|) 
                   (let ((old_infos 
                          (LIST-SPEC::foldl-1-1-1 
                           #'(lambda (x1) 
                              (let ((old_infos (cdr x1))) 
                                (let ((pV2 
                                       (STANDARDSPEC::findTheOp 
                                        old_spec 
                                        (car x1)))) 
                                  (block 
                                   nil 
                                   (if (eq (car pV2) :|Some|) 
                                       (let ((pV3 (cdr pV2))) 
                                         (return 
                                          (if (LIST-SPEC::|!exists|-1-1 
                                               #'(lambda (old_info) 
                                                  (slang-built-in::slang-term-equals 
                                                   pV3 
                                                   old_info)) 
                                               old_infos) 
                                              old_infos 
                                              (LIST-SPEC::|!cons| pV3 old_infos))))) 
                                   (return old_infos))))) 
                           nil 
                           new_op_names))) 
                     (SPECCALC::monadBind 
                      (block 
                       nil 
                       (if (null old_infos) 
                           (return 
                            (let ((new_info 
                                   (vector 
                                    new_op_names 
                                    new_fixity 
                                    new_sort_scheme 
                                    new_defs))) 
                              (SPECCALC::|!return| 
                               (LIST-SPEC::foldl-1-1-1 
                                #'(lambda (x1) 
                                   (let ((pV4 (car x1))) 
                                     (block 
                                      nil 
                                      (if (eq (car pV4) :|Qualified|) 
                                          (let ((pV6 (cdr pV4))) 
                                            (return 
                                             (insertAQualifierMap 
                                              (cdr x1) 
                                              (car pV6) 
                                              (cdr pV6) 
                                              new_info)))) 
                                      (error 
                                       "Nonexhaustive match failure in addOp")))) 
                                (svref old_spec 1) 
                                new_op_names)))) 
                           (if (consp old_infos) 
                               (let ((pV51 (car old_infos))) 
                                 (let ((pV56 (svref pV51 3))
                                       (pV55 (svref pV51 2))) 
                                   (let ((pV57 (car pV55))) 
                                     (if (null (cdr old_infos)) 
                                         (return 
                                          (let ((combined_op_names 
                                                 (LISTUTILITIES::listUnion 
                                                  (svref pV51 0) 
                                                  new_op_names))) 
                                            (block 
                                             nil 
                                             (if (null pV56) 
                                                 (if (null new_defs) 
                                                     (return 
                                                      (SPECCALC::raise 
                                                       (cons 
                                                        :|SpecError| 
                                                        (cons 
                                                         |!position| 
                                                         (STRING-SPEC::^ 
                                                          (STRING-SPEC::^ 
                                                           (STRING-SPEC::^ 
                                                            (STRING-SPEC::^ 
                                                             (STRING-SPEC::^ 
                                                              (STRING-SPEC::^ 
                                                               "Operator " 
                                                               (SPECCALC::printAliases 
                                                                new_op_names)) 
                                                              " has been redeclared") 
                                                             "
 from ") 
                                                            (ANNSPECPRINTER::printSortScheme-1 
                                                             pV55)) 
                                                           "
   to ") 
                                                          (ANNSPECPRINTER::printSortScheme-1 
                                                           new_sort_scheme)))))) 
                                                     (if (consp new_defs) 
                                                         (return 
                                                          (let ((happy? 
                                                                 (block 
                                                                  nil 
                                                                  (if (null 
                                                                       (car 
                                                                        new_sort_scheme)) 
                                                                      (if (eq 
                                                                           (car 
                                                                            (cdr 
                                                                             new_sort_scheme)) 
                                                                           :|MetaTyVar|) 
                                                                          (return 
                                                                           t))) 
                                                                  (return 
                                                                   (slang-built-in::slang-term-equals 
                                                                    new_type_vars 
                                                                    pV57))))) 
                                                            (if happy? 
                                                                (let ((new_info 
                                                                       (vector 
                                                                        combined_op_names 
                                                                        (svref 
                                                                         pV51 
                                                                         1) 
                                                                        pV55 
                                                                        new_defs))) 
                                                                  (SPECCALC::|!return| 
                                                                   (LIST-SPEC::foldl-1-1-1 
                                                                    #'(lambda (x1) 
                                                                       (let ((pV16 
                                                                              (car 
                                                                               x1))) 
                                                                         (block 
                                                                          nil 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV16) 
                                                                               :|Qualified|) 
                                                                              (let ((pV18 
                                                                                     (cdr 
                                                                                      pV16))) 
                                                                                (return 
                                                                                 (insertAQualifierMap 
                                                                                  (cdr 
                                                                                   x1) 
                                                                                  (car 
                                                                                   pV18) 
                                                                                  (cdr 
                                                                                   pV18) 
                                                                                  new_info)))) 
                                                                          (error 
                                                                           "Nonexhaustive match failure in addOp")))) 
                                                                    (svref 
                                                                     old_spec 
                                                                     1) 
                                                                    combined_op_names))) 
                                                                (SPECCALC::raise 
                                                                 (cons 
                                                                  :|SpecError| 
                                                                  (cons 
                                                                   |!position| 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     (STRING-SPEC::^ 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         "Operator " 
                                                                         (SPECCALC::printAliases 
                                                                          new_op_names)) 
                                                                        " has been redeclared or redefined") 
                                                                       "
 with new type variables ") 
                                                                      (SPECCALC::printTypeVars 
                                                                       new_type_vars)) 
                                                                     "
    differing from prior ") 
                                                                    (SPECCALC::printTypeVars 
                                                                     pV57)))))))))) 
                                                 (if (consp pV56) 
                                                     (if (null new_defs) 
                                                         (return 
                                                          (let ((happy? 
                                                                 (let ((pV27 
                                                                        (cdr 
                                                                         pV55))
                                                                       (pV26 
                                                                        (car 
                                                                         pV55))) 
                                                                   (block 
                                                                    nil 
                                                                    (if (null 
                                                                         pV26) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV27) 
                                                                             :|MetaTyVar|) 
                                                                            (return 
                                                                             t))) 
                                                                    (if (eq 
                                                                         (car 
                                                                          pV27) 
                                                                         :|MetaTyVar|) 
                                                                        (return 
                                                                         (slang-built-in::slang-term-equals 
                                                                          new_type_vars 
                                                                          pV26))) 
                                                                    (return nil))))) 
                                                            (if happy? 
                                                                (let ((new_info 
                                                                       (vector 
                                                                        combined_op_names 
                                                                        new_fixity 
                                                                        new_sort_scheme 
                                                                        pV56))) 
                                                                  (SPECCALC::|!return| 
                                                                   (LIST-SPEC::foldl-1-1-1 
                                                                    #'(lambda (x1) 
                                                                       (let ((pV30 
                                                                              (car 
                                                                               x1))) 
                                                                         (block 
                                                                          nil 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV30) 
                                                                               :|Qualified|) 
                                                                              (let ((pV32 
                                                                                     (cdr 
                                                                                      pV30))) 
                                                                                (return 
                                                                                 (insertAQualifierMap 
                                                                                  (cdr 
                                                                                   x1) 
                                                                                  (car 
                                                                                   pV32) 
                                                                                  (cdr 
                                                                                   pV32) 
                                                                                  new_info)))) 
                                                                          (error 
                                                                           "Nonexhaustive match failure in addOp")))) 
                                                                    (svref 
                                                                     old_spec 
                                                                     1) 
                                                                    combined_op_names))) 
                                                                (SPECCALC::raise 
                                                                 (cons 
                                                                  :|SpecError| 
                                                                  (cons 
                                                                   |!position| 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     (STRING-SPEC::^ 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         "Operator " 
                                                                         (SPECCALC::printAliases 
                                                                          new_op_names)) 
                                                                        " has been redeclared") 
                                                                       "
 from type ") 
                                                                      (ANNSPECPRINTER::printSortScheme-1 
                                                                       pV55)) 
                                                                     "
   to type ") 
                                                                    (ANNSPECPRINTER::printSortScheme-1 
                                                                     new_sort_scheme)))))))) 
                                                         (if (consp new_defs) 
                                                             (return 
                                                              (SPECCALC::raise 
                                                               (cons 
                                                                :|SpecError| 
                                                                (cons 
                                                                 |!position| 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     (STRING-SPEC::^ 
                                                                      (STRING-SPEC::^ 
                                                                       "Operator " 
                                                                       (SPECCALC::printAliases 
                                                                        new_op_names)) 
                                                                      " has been redefined") 
                                                                     "
 from ") 
                                                                    (ANNSPECPRINTER::printTermScheme-1 
                                                                     (car pV56))) 
                                                                   "
   to ") 
                                                                  (ANNSPECPRINTER::printTermScheme-1 
                                                                   (car new_defs))))))))))) 
                                             (error 
                                              "Nonexhaustive match failure in addOp")))))))))) 
                       (return 
                        (SPECCALC::raise 
                         (cons 
                          :|SpecError| 
                          (cons 
                           |!position| 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             "Op " 
                             (SPECCALC::printAliases new_op_names)) 
                            " refers to multiple prior ops")))))) 
                      #'(lambda (new_ops) 
                         (SPECCALC::monadBind 
                          (SPECCALC::|!return| (setOps old_spec new_ops)) 
                          #'(lambda (sp) 
                             (funcall (funcall (SPECCALC::foldM 
                                                #'(lambda (sp) 
                                                   #'(lambda (name) 
                                                      (SPECCALC::|!return| 
                                                       (addLocalOpName sp name))))) 
                                               sp) 
                                      new_op_names)))))))))))))

(defun SPECCALC::monadSeq (f g) 
  (SPECCALC::monadBind f #'(lambda (pV1) (declare (ignore pV1)) 
                                         g)))

(defun JGEN::optAddOp (oper srt term spc) 
  (SPECCALC::monadSeq 
   #'SPECWARE::restoreSavedSpecwareState-1 
   (SPECCALC::monadBind 
    (funcall (funcall (funcall (funcall (funcall (SPECCALC::addOp 
                                                  (cons oper nil)) 
                                                 nil) 
                                        (cons nil srt)) 
                               (cons (cons nil term) nil)) 
                      spc) 
             POSITION-SPEC::noPos) 
    #'(lambda (spc) 
       (SPECCALC::|!return| 
        (cons 
         :|Some| 
         (vector (svref spc 0) (svref spc 1) (svref spc 2) (svref spc 3))))))))

(defun POLYMAP::mapPartial-1-1 (f m) 
  (labels 
    ((g (m) 
      #'(lambda (key) 
         #'(lambda (item) 
            (let ((pV1 (funcall f item))) 
              (block 
               nil 
               (if (eq (car pV1) :|None|) 
                   (return m) 
                   (if (eq (car pV1) :|Some|) 
                       (return (POLYMAP::update-1-1-1 m key (cdr pV1))))) 
               (error "Nonexhaustive match failure in mapPartial"))))))) 
    (POLYMAP::foldMap-1-1-1 #'g POLYMAP::emptyMap m)))

(defun SPECCALC::getGlobalContext
 (globalContext localContext uri validatedURIs) 
  (cons 
   (cons :|Ok| globalContext) 
   (vector globalContext localContext uri validatedURIs)))

(defun SPECCALC::getGlobalContext-1 (x) 
  (SPECCALC::getGlobalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::setGlobalContext-1-1 (newGlobalContext x) 
  (cons 
   (cons :|Ok| nil) 
   (vector newGlobalContext (svref x 1) (svref x 2) (svref x 3))))

(defun SPECCALC::setGlobalContext (x1) 
  #'(lambda (x2) (SPECCALC::setGlobalContext-1-1 x1 x2)))

(defun SPECCALC::cleanupGlobalContext (x2 x1 x0 x) 
  (SPECCALC::monadBind-1-1 
   (cons 
    #'SPECCALC::getGlobalContext-1 
    #'(lambda (gCtxt) 
       (SPECCALC::setGlobalContext 
        (POLYMAP::mapPartial-1-1 
         #'(lambda (x) 
            (block 
             nil 
             (if (eq (car (svref x 0)) :|InProcess|) (return '(:|None|))) 
             (return (cons :|Some| (vector (svref x 0) (svref x 1) (svref x 2)))))) 
         gCtxt)))) 
   (vector x2 x1 x0 x)))

(defun SPECCALC::cleanupGlobalContext-1 (x) 
  (SPECCALC::cleanupGlobalContext 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECCALC::|!print|-1-1 (str state) 
  (progn (STRING-SPEC::toScreen str) (cons (cons :|Ok| nil) state)))

(defun SPECCALC::|!print| (x1) 
  #'(lambda (x2) (SPECCALC::|!print|-1-1 x1 x2)))

(defun SPECWARE::getFirstRealPosition (errs) 
  (block 
   nil 
   (if (null errs) 
       (return '(:|None|)) 
       (if (consp errs) 
           (let ((pV13 (cdr errs))) 
             (let ((pV15 (cdr (car errs)))) 
               (return 
                (block 
                 nil 
                 (if (eq (car pV15) :|File|) 
                     (let ((pV5 (svref (cdr pV15) 1))) 
                       (return 
                        (if (cl:and ( =  (svref pV5 0) 0) ( =  (svref pV5 1) 0)) 
                            (SPECWARE::getFirstRealPosition pV13) 
                            (cons :|Some| pV15))))) 
                 (return (SPECWARE::getFirstRealPosition pV13)))))))) 
   (error "Nonexhaustive match failure in getFirstRealPosition")))

(defun SPECWARE::getFirstErrorLocation (except) 
  (block 
   nil 
   (if (eq (car except) :|Unsupported|) 
       (return (cons :|Some| (car (cdr except)))) 
       (if (eq (car except) :|URINotFound|) 
           (return (cons :|Some| (car (cdr except)))) 
           (if (eq (car except) :|FileNotFound|) 
               (return (cons :|Some| (car (cdr except)))) 
               (if (eq (car except) :|SpecError|) 
                   (return (cons :|Some| (car (cdr except)))) 
                   (if (eq (car except) :|MorphError|) 
                       (return (cons :|Some| (car (cdr except)))) 
                       (if (eq (car except) :|DiagError|) 
                           (return (cons :|Some| (car (cdr except)))) 
                           (if (eq (car except) :|TypeCheck|) 
                               (return (cons :|Some| (car (cdr except)))) 
                               (if (eq (car except) :|Proof|) 
                                   (return (cons :|Some| (car (cdr except)))) 
                                   (if (eq (car except) :|TypeCheckErrors|) 
                                       (return 
                                        (SPECWARE::getFirstRealPosition 
                                         (cdr except)))))))))))) 
   (return '(:|None|))))

(defun SPECWARE::gotoErrorLocation (except) 
  (let ((pV2 (SPECWARE::getFirstErrorLocation except))) 
    (block 
     nil 
     (if (eq (car pV2) :|Some|) 
         (let ((pV3 (cdr pV2))) 
           (if (eq (car pV3) :|File|) 
               (let ((pV4 (cdr pV3))) 
                 (let ((pV6 (svref pV4 1))) 
                   (return 
                    (IO-SPEC::gotoFilePosition 
                     (svref pV4 0) 
                     (svref pV6 0) 
                     (svref pV6 1)))))))) 
     (return nil))))

(defun WADLERLINDIG::ppAppend-1-1 (p1 p2) (WADLERLINDIG::ppCons-1-1 p1 p2))

(defun SPECCALC::ppURIlocal (hashSuffix path) 
  (let ((prefix 
         (WADLERLINDIG::ppSep-1-1 
          (WADLERLINDIG::ppString "/") 
          (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString path)))) 
    (block 
     nil 
     (if (eq (car hashSuffix) :|None|) 
         (return prefix) 
         (if (eq (car hashSuffix) :|Some|) 
             (return 
              (WADLERLINDIG::ppAppend-1-1 
               prefix 
               (WADLERLINDIG::ppString (STRING-SPEC::^ "#" (cdr hashSuffix))))))) 
     (error "Nonexhaustive match failure in ppURIlocal"))))

(defun SPECCALC::ppURIlocal-1 (x) (SPECCALC::ppURIlocal (car x) (cdr x)))

(defun SPECCALC::ppRelativeURI (relURI) 
  (block 
   nil 
   (if (eq (car relURI) :|SpecPath_Relative|) 
       (return 
        (WADLERLINDIG::ppAppend-1-1 
         (WADLERLINDIG::ppString "/") 
         (SPECCALC::ppURIlocal-1 (cdr relURI)))) 
       (if (eq (car relURI) :|URI_Relative|) 
           (return (SPECCALC::ppURIlocal-1 (cdr relURI))))) 
   (error "Nonexhaustive match failure in ppRelativeURI")))

(defun WADLERLINDIG::ppFits-1-1 (w x) 
  (cl:and 
   (INTEGER-SPEC::|!>=| w 0) 
   (block 
    nil 
    (if (null x) 
        (return t) 
        (if (consp x) 
            (let ((pV4 (car x))
                  (pV5 (cdr x))) 
              (let ((pV6 (svref pV4 0))
                    (pV7 (svref pV4 1))
                    (pV8 (svref pV4 2))) 
                (progn (if (eq (car pV8) :|DocNil|) 
                           (return (WADLERLINDIG::ppFits-1-1 w pV5)) 
                           (if (eq (car pV8) :|DocCons|) 
                               (let ((pV14 (cdr pV8))) 
                                 (return 
                                  (WADLERLINDIG::ppFits-1-1 
                                   w 
                                   (cons 
                                    (vector pV6 pV7 (car pV14)) 
                                    (cons (vector pV6 pV7 (cdr pV14)) pV5))))) 
                               (if (eq (car pV8) :|DocNest|) 
                                   (let ((pV13 (cdr pV8))) 
                                     (return 
                                      (WADLERLINDIG::ppFits-1-1 
                                       w 
                                       (cons 
                                        (vector 
                                         (INTEGER-SPEC::|!+| pV6 (car pV13)) 
                                         pV7 
                                         (cdr pV13)) 
                                        pV5)))) 
                                   (if (eq (car pV8) :|DocText|) 
                                       (return 
                                        (WADLERLINDIG::ppFits-1-1 
                                         (INTEGER-SPEC::|!-| 
                                          w 
                                          (STRING-SPEC::|!length| (cdr pV8))) 
                                         pV5)))))) 
                       (if (eq (car pV7) :|Flat|) 
                           (if (eq (car pV8) :|DocBreak|) 
                               (return 
                                (WADLERLINDIG::ppFits-1-1 
                                 (INTEGER-SPEC::|!-| 
                                  w 
                                  (STRING-SPEC::|!length| (cdr pV8))) 
                                 pV5))) 
                           (if (eq (car pV7) :|Break|) 
                               (if (eq (car pV8) :|DocBreak|) (return t)))) 
                       (if (eq (car pV8) :|DocGroup|) 
                           (return 
                            (WADLERLINDIG::ppFits-1-1 
                             w 
                             (cons (vector pV6 '(:|Flat|) (cdr pV8)) pV5))))))))) 
    (error "Nonexhaustive match failure in ppFits"))))

(defun WADLERLINDIG::ppBest-1-1-1 (w k x) 
  (block 
   nil 
   (if (null x) 
       (return '(:|SNil|)) 
       (if (consp x) 
           (let ((pV3 (car x))
                 (pV4 (cdr x))) 
             (let ((pV5 (svref pV3 0))
                   (pV6 (svref pV3 1))
                   (pV7 (svref pV3 2))) 
               (progn (if (eq (car pV7) :|DocNil|) 
                          (return (WADLERLINDIG::ppBest-1-1-1 w k pV4)) 
                          (if (eq (car pV7) :|DocCons|) 
                              (let ((pV13 (cdr pV7))) 
                                (return 
                                 (WADLERLINDIG::ppBest-1-1-1 
                                  w 
                                  k 
                                  (cons 
                                   (vector pV5 pV6 (car pV13)) 
                                   (cons (vector pV5 pV6 (cdr pV13)) pV4))))) 
                              (if (eq (car pV7) :|DocNest|) 
                                  (let ((pV12 (cdr pV7))) 
                                    (return 
                                     (WADLERLINDIG::ppBest-1-1-1 
                                      w 
                                      k 
                                      (cons 
                                       (vector 
                                        (INTEGER-SPEC::|!+| pV5 (car pV12)) 
                                        pV6 
                                        (cdr pV12)) 
                                       pV4)))) 
                                  (if (eq (car pV7) :|DocText|) 
                                      (let ((pV11 (cdr pV7))) 
                                        (return 
                                         (cons 
                                          :|SText| 
                                          (cons 
                                           pV11 
                                           (WADLERLINDIG::ppBest-1-1-1 
                                            w 
                                            (INTEGER-SPEC::|!+| 
                                             k 
                                             (STRING-SPEC::|!length| pV11)) 
                                            pV4))))))))) 
                      (if (eq (car pV6) :|Flat|) 
                          (if (eq (car pV7) :|DocBreak|) 
                              (let ((pV10 (cdr pV7))) 
                                (return 
                                 (cons 
                                  :|SText| 
                                  (cons 
                                   pV10 
                                   (WADLERLINDIG::ppBest-1-1-1 
                                    w 
                                    (INTEGER-SPEC::|!+| 
                                     k 
                                     (STRING-SPEC::|!length| pV10)) 
                                    pV4)))))) 
                          (if (eq (car pV6) :|Break|) 
                              (if (eq (car pV7) :|DocBreak|) 
                                  (return 
                                   (cons 
                                    :|SLine| 
                                    (cons 
                                     pV5 
                                     (WADLERLINDIG::ppBest-1-1-1 w pV5 pV4))))))) 
                      (if (eq (car pV7) :|DocGroup|) 
                          (let ((pV8 (cdr pV7))) 
                            (return 
                             (if (WADLERLINDIG::ppFits-1-1 
                                  (INTEGER-SPEC::|!-| w k) 
                                  (cons (vector pV5 '(:|Flat|) pV8) pV4)) 
                                 (WADLERLINDIG::ppBest-1-1-1 
                                  w 
                                  k 
                                  (cons (vector pV5 '(:|Flat|) pV8) pV4)) 
                                 (WADLERLINDIG::ppBest-1-1-1 
                                  w 
                                  k 
                                  (cons (vector pV5 '(:|Break|) pV8) pV4))))))))))) 
   (error "Nonexhaustive match failure in ppBest")))

(defun WADLERLINDIG::ppLayout (doc) 
  (labels 
    ((replicate (cnt) 
      #'(lambda (str) 
         (if ( =  cnt 0) 
             (cons "" nil) 
             (cons str (funcall (replicate (INTEGER-SPEC::|!-| cnt 1)) str)))))) 
    (labels 
      ((makeStringList (doc) 
        (block 
         nil 
         (if (eq (car doc) :|SNil|) 
             (return (cons "" nil)) 
             (if (eq (car doc) :|SText|) 
                 (let ((pV3 (cdr doc))) 
                   (return (cons (car pV3) (makeStringList (cdr pV3))))) 
                 (if (eq (car doc) :|SLine|) 
                     (let ((pV2 (cdr doc))) 
                       (return 
                        (cons 
                         (STRING-SPEC::concatList 
                          (cons "
" (funcall (replicate (car pV2)) " "))) 
                         (makeStringList (cdr pV2)))))))) 
         (error "Nonexhaustive match failure in ppLayout")))) 
      (STRING-SPEC::concatList (makeStringList doc)))))

(defun WADLERLINDIG::ppFormatWidth-1-1 (w doc) 
  (WADLERLINDIG::ppLayout 
   (WADLERLINDIG::ppBest-1-1-1 
    w 
    0 
    (cons (vector 0 '(:|Flat|) (cons :|DocGroup| doc)) nil))))

(defun WADLERLINDIG::ppFormat (doc) (WADLERLINDIG::ppFormatWidth-1-1 80 doc))

(defun SPECCALC::showRelativeURI (uri) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppRelativeURI uri)))

(defun SPECCALC::ppURI-1 (uri) 
  (WADLERLINDIG::ppAppend-1-1 
   (WADLERLINDIG::ppString "/") 
   (SPECCALC::ppURIlocal-1 uri)))

(defun SPECCALC::showURI-1 (uri) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppURI-1 uri)))

(defun POSITION-SPEC::|!print| (|!position|) 
  (block 
   nil 
   (if (eq (car |!position|) :|Internal|) 
       (return (cdr |!position|)) 
       (if (eq (car |!position|) :|String|) 
           (let ((pV3 (cdr |!position|))) 
             (return 
              (let ((printPos 
                     #'(lambda (x) 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ (NAT-SPEC::toString (svref x 0)) ".") 
                         (NAT-SPEC::toString (svref x 1)))))) 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ (funcall printPos (svref pV3 1)) "-") 
                   (funcall printPos (svref pV3 2))) 
                  " in ") 
                 (svref pV3 0))))) 
           (if (eq (car |!position|) :|File|) 
               (let ((pV2 (cdr |!position|))) 
                 (return 
                  (let ((printPos 
                         #'(lambda (x) 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              (NAT-SPEC::toString (svref x 0)) 
                              ".") 
                             (NAT-SPEC::toString (svref x 1)))))) 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ (funcall printPos (svref pV2 1)) "-") 
                     (funcall printPos (svref pV2 2))))))))) 
   (error "Nonexhaustive match failure in print")))

(defun SPECWARE::printTypeErrors (errs) 
  (labels 
    ((printErr (pV7 pV8) 
      (block 
       nil 
       (let ((pV10 (cdr pV7))) 
         (return 
          (let ((filename 
                 (block 
                  nil 
                  (if (eq (car pV10) :|File|) (return (svref (cdr pV10) 0))) 
                  (return "")))) 
            (cons 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 (car pV8) 
                 (if (string=  filename (cdr pV8)) 
                     (POSITION-SPEC::|!print| pV10) 
                     (POSITION-SPEC::printAll pV10))) 
                " : ") 
               (car pV7)) 
              "
") 
             filename)))) 
       (error "Nonexhaustive match failure in printTypeErrors")))) 
    (car 
     (LIST-SPEC::foldl-1-1-1 
      #'(lambda (x) (printErr (car x) (cdr x))) 
      (cons "" "") 
      errs))))

(defun SPECWARE::printException (except) 
  (block 
   nil 
   (if (eq (car except) :|Fail|) 
       (return (STRING-SPEC::^ "Fail: " (cdr except))) 
       (if (eq (car except) :|SyntaxError|) 
           (return (STRING-SPEC::^ "Syntax error: " (cdr except))) 
           (if (eq (car except) :|ParserError|) 
               (return 
                (STRING-SPEC::^ "Syntax error for filename: " (cdr except))) 
               (if (eq (car except) :|Unsupported|) 
                   (let ((pV13 (cdr except))) 
                     (return 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ "Unsupported operation: " (cdr pV13)) 
                        "
  found at ") 
                       (POSITION-SPEC::printAll (car pV13))))) 
                   (if (eq (car except) :|URINotFound|) 
                       (let ((pV12 (cdr except))) 
                         (return 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             "Unknown unit " 
                             (SPECCALC::showRelativeURI (cdr pV12))) 
                            "
  referenced from ") 
                           (POSITION-SPEC::printAll (car pV12))))) 
                       (if (eq (car except) :|FileNotFound|) 
                           (let ((pV11 (cdr except))) 
                             (return 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 "Unknown unit " 
                                 (SPECCALC::showRelativeURI (cdr pV11))) 
                                "
  referenced from ") 
                               (POSITION-SPEC::printAll (car pV11))))) 
                           (if (eq (car except) :|SpecError|) 
                               (let ((pV10 (cdr except))) 
                                 (return 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     "Error in specification: " 
                                     (cdr pV10)) 
                                    "
  found at ") 
                                   (POSITION-SPEC::printAll (car pV10))))) 
                               (if (eq (car except) :|MorphError|) 
                                   (let ((pV9 (cdr except))) 
                                     (return 
                                      (STRING-SPEC::^ 
                                       (STRING-SPEC::^ 
                                        (STRING-SPEC::^ 
                                         "Error in morphism: " 
                                         (cdr pV9)) 
                                        "
  found at ") 
                                       (POSITION-SPEC::printAll (car pV9))))) 
                                   (if (eq (car except) :|DiagError|) 
                                       (let ((pV8 (cdr except))) 
                                         (return 
                                          (STRING-SPEC::^ 
                                           (STRING-SPEC::^ 
                                            (STRING-SPEC::^ 
                                             "Diagram error: " 
                                             (cdr pV8)) 
                                            "
  found at ") 
                                           (POSITION-SPEC::printAll (car pV8))))) 
                                       (if (eq (car except) :|TypeCheck|) 
                                           (let ((pV7 (cdr except))) 
                                             (return 
                                              (STRING-SPEC::^ 
                                               (STRING-SPEC::^ 
                                                (STRING-SPEC::^ 
                                                 "Type error: " 
                                                 (cdr pV7)) 
                                                "
  found at ") 
                                               (POSITION-SPEC::printAll 
                                                (car pV7))))) 
                                           (if (eq (car except) :|Proof|) 
                                               (let ((pV6 (cdr except))) 
                                                 (return 
                                                  (STRING-SPEC::^ 
                                                   (STRING-SPEC::^ 
                                                    (STRING-SPEC::^ 
                                                     "Proof error: " 
                                                     (cdr pV6)) 
                                                    "
  found at ") 
                                                   (POSITION-SPEC::printAll 
                                                    (car pV6))))) 
                                               (if (eq 
                                                    (car except) 
                                                    :|CircularDefinition|) 
                                                   (return 
                                                    (STRING-SPEC::^ 
                                                     "Circular definition: " 
                                                     (SPECCALC::showURI-1 
                                                      (cdr except)))) 
                                                   (if (eq 
                                                        (car except) 
                                                        :|TypeCheckErrors|) 
                                                       (return 
                                                        (SPECWARE::printTypeErrors 
                                                         (cdr except))) 
                                                       (if (eq 
                                                            (car except) 
                                                            :|OldTypeCheck|) 
                                                           (return 
                                                            (STRING-SPEC::^ 
                                                             "Type errors:
" 
                                                             (cdr except))))))))))))))))) 
   (return (STRING-SPEC::^ "Unknown exception: " (SYSTEM-SPEC::toString except)))))


(defun SPECWARE::toplevelHandler (except) 
  (SPECCALC::monadSeq 
   #'SPECCALC::cleanupGlobalContext-1 
   (SPECCALC::monadSeq 
    #'SPECWARE::saveSpecwareState-1 
    (SPECCALC::monadBind 
     (SPECCALC::|!return| (SPECWARE::printException except)) 
     #'(lambda (message) 
        (SPECCALC::monadSeq 
         (SPECCALC::|!return| (SPECWARE::gotoErrorLocation except)) 
         (SPECCALC::monadSeq 
          (if SPECCALC::specwareWizard? 
              (SYSTEM-SPEC::fail message) 
              (SPECCALC::|!print| message)) 
          (SPECCALC::|!return| nil))))))))

(defun JGEN::localHandler (except) 
  (SPECCALC::monadSeq 
   (SPECWARE::toplevelHandler except) 
   (SPECCALC::|!return| '(:|None|))))

(defun SPECCALC::|!catch|-1-1-1 (f handler state) 
  (let ((x (funcall f state))) 
    (let ((pV1 (car x))
          (pV2 (cdr x))) 
      (block 
       nil 
       (if (eq (car pV1) :|Ok|) 
           (return (cons (cons :|Ok| (cdr pV1)) pV2)) 
           (if (eq (car pV1) :|Exception|) 
               (return (funcall (funcall handler (cdr pV1)) pV2)))) 
       (error "Nonexhaustive match failure in catch")))))

(defparameter SPECCALC::initialSpecwareState 
  (vector 
   POLYMAP::emptyMap 
   POLYMAP::emptyMap 
   (cons :|Some| (cons '(:|None|) (cons "/" nil))) 
   nil))

(defparameter SPECWARE::ignoredState SPECCALC::initialSpecwareState)

(defun JGEN::run_monad (monad) 
  (let ((x 
         (SPECCALC::|!catch|-1-1-1 
          monad 
          #'JGEN::localHandler 
          SPECWARE::ignoredState))) 
    (let ((pV4 (car x))) 
      (block 
       nil 
       (if (eq (car pV4) :|Ok|) 
           (return (cdr pV4)) 
           (if (eq (car pV4) :|Exception|) 
               (return 
                (SYSTEM-SPEC::fail 
                 "Specware toplevel handler failed within colimit!")))) 
       (error "Nonexhaustive match failure in run_monad")))))

(defun STANDARDSPEC::mkLambda (pat term) 
  (cons 
   :|Lambda| 
   (cons 
    (cons (vector pat (STANDARDSPEC::mkTrue) term) nil) 
    POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkProduct (sorts) 
  (labels 
    ((|!loop| (n sorts) 
      (block 
       nil 
       (if (null sorts) 
           (return nil) 
           (if (consp sorts) 
               (return 
                (LIST-SPEC::|!cons| 
                 (cons (NAT-SPEC::toString n) (car sorts)) 
                 (|!loop| (INTEGER-SPEC::|!+| n 1) (cdr sorts)))))) 
       (error "Nonexhaustive match failure in mkProduct")))) 
    (cons :|Product| (cons (|!loop| 1 sorts) POSITION-SPEC::noPos))))

(defun STANDARDSPEC::mkTuplePat (pats) 
  (cons :|RecordPat| (cons (STANDARDSPEC::tagTuple pats) POSITION-SPEC::noPos)))

(defun JGEN::addOdToSpec (pV12 pV13) 
  (block 
   nil 
   (let ((pV16 (svref pV12 2))
         (pV15 (svref pV12 1))) 
     (return 
      (let ((srt 
             (block 
              nil 
              (if (null pV15) 
                  (return pV16) 
                  (if (consp pV15) 
                      (if (null (cdr pV15)) 
                          (return (STANDARDSPEC::mkArrow (car pV15) pV16))))) 
              (return 
               (STANDARDSPEC::mkArrow (STANDARDSPEC::mkProduct pV15) pV16))))) 
        (let ((varPatterns 
               (LIST-SPEC::|!map|-1-1 #'STANDARDSPEC::mkVarPat-1 (svref pV12 3)))) 
          (let ((term 
                 (STANDARDSPEC::mkLambda 
                  (STANDARDSPEC::mkTuplePat varPatterns) 
                  (svref pV12 4)))) 
            (progn (JGEN::srtTermDelta srt term) 
                   (block 
                    nil 
                    (return 
                     (let ((pV7 
                            (JGEN::run_monad 
                             (JGEN::optAddOp (svref pV12 0) srt term pV13)))) 
                       (block 
                        nil 
                        (if (eq (car pV7) :|Some|) (return (cdr pV7))) 
                        (return (SYSTEM-SPEC::fail "internal monad error"))))) 
                    (error "Nonexhaustive match failure in addOdToSpec")))))))) 
   (error "Nonexhaustive match failure in addOdToSpec")))

(defun JGEN::addOdToSpec-1 (x) (JGEN::addOdToSpec (car x) (cdr x)))

(defun JGEN::addPrimArgsMethodToClsDecls-1 (x) 
  (JGEN::addPrimArgsMethodToClsDecls 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun JGEN::addPrimMethodToClsDecls-1 (x) 
  (JGEN::addPrimMethodToClsDecls 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun JGEN::addSumMethDeclToClsDecls-1 (x) 
  (JGEN::addSumMethDeclToClsDecls 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun JGEN::addUserMethodToClsDecls-1 (x) 
  (JGEN::addUserMethodToClsDecls 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun JGEN::baseSrtToJavaType (srt) 
  (if (METASLANG::boolSort? srt) (JGEN::tt "Boolean") (JGEN::tt "Integer")))

(defun JGEN::baseVar?-1 (var) 
  (block 
   nil 
   (return (JGEN::baseType? (cdr var))) 
   (error "Nonexhaustive match failure in baseVar?")))

(defun JGEN::baseVar? (x0 x1) (JGEN::baseVar?-1 (cons x0 x1)))

(defparameter JGEN::emptyClsBody (vector nil nil nil nil nil nil))

(defparameter JGEN::mkPrimOpsClsDecl 
  (vector nil (vector "Primitive" '(:|None|) nil) JGEN::emptyClsBody))

(defun JGEN::fieldToFldDecl (fieldProj fieldType) 
  (vector nil (JGEN::tt fieldType) (cons (cons fieldProj 0) '(:|None|)) nil))

(defun JGEN::mkEqarg (id) "eqarg")

(defun JGEN::mkEqualityMethDecl (id) 
  (cons 
   (vector 
    nil 
    (let ((x (JGEN::tt "Boolean"))) (cons :|Some| (cons (car x) (cdr x)))) 
    "equals" 
    (cons (vector nil (JGEN::tt id) (cons (JGEN::mkEqarg id) 0)) nil) 
    nil) 
   '(:|None|)))

(defun JGEN::fieldToFormalParam (fieldProj fieldType) 
  (vector nil (JGEN::tt fieldType) (cons fieldProj 0)))

(defun JGEN::mkNameAssn (|!n1| |!n2|) 
  (cons 
   :|Stmt| 
   (cons 
    :|Expr| 
    (cons 
     :|Ass| 
     (vector 
      (cons :|Name| (cons (car |!n1|) (cdr |!n1|))) 
      '(:|Assgn|) 
      (cons 
       :|CondExp| 
       (cons 
        (cons :|Un| (cons :|Prim| (cons :|Name| (cons (car |!n2|) (cdr |!n2|))))) 
        '(:|None|))))))))

(defun JGEN::mkSumConstBody (n) 
  (if ( =  n 0) 
      nil 
      (let ((thisName 
             (cons (cons "this" nil) (JGEN::mkArgProj (NAT-SPEC::natToString n))))) 
        (let ((argName (cons nil (JGEN::mkArgProj (NAT-SPEC::natToString n))))) 
          (let ((assn (JGEN::mkNameAssn thisName argName))) 
            (let ((restAssns (JGEN::mkSumConstBody (INTEGER-SPEC::|!-| n 1)))) 
              (LIST-SPEC::|!++| restAssns (cons assn nil))))))))

(defun JGEN::mkSumConstrDecl (id fields) 
  (let ((formParams 
         (LIST-SPEC::|!map|-1-1 
          #'(lambda (x) 
             (let ((pV3 (cdr x))) 
               (block 
                nil 
                (if (eq (car pV3) :|Base|) 
                    (let ((pV4 (cdr pV3))) 
                      (let ((pV5 (svref pV4 0))) 
                        (if (eq (car pV5) :|Qualified|) 
                            (if (null (svref pV4 1)) 
                                (return 
                                 (JGEN::fieldToFormalParam 
                                  (JGEN::mkArgProj (car x)) 
                                  (cdr (cdr pV5))))))))) 
                (error "Nonexhaustive match failure in mkSumConstrDecl")))) 
          fields))) 
    (let ((sumConstrBody 
           (JGEN::mkSumConstBody (LIST-SPEC::|!length| formParams)))) 
      (vector nil id formParams nil sumConstrBody))))

(defun JGEN::mkEqualityBodyForSum (fields) 
  (block 
   nil 
   (if (null fields) 
       (return 
        (cons 
         :|CondExp| 
         (cons (cons :|Un| (cons :|Prim| (cons :|Bool| t))) '(:|None|)))) 
       (if (consp fields) 
           (let ((pV4 (cdr fields))
                 (pV3 (car fields))) 
             (let ((pV6 (cdr pV3))
                   (pV5 (car pV3))) 
               (progn (if (null pV4) 
                          (return 
                           (let ((e1 
                                  (cons 
                                   :|CondExp| 
                                   (cons 
                                    (cons 
                                     :|Un| 
                                     (cons 
                                      :|Prim| 
                                      (cons 
                                       :|Name| 
                                       (cons 
                                        (cons "this" nil) 
                                        (JGEN::mkArgProj pV5))))) 
                                    '(:|None|))))) 
                             (let ((e2 
                                    (cons 
                                     :|CondExp| 
                                     (cons 
                                      (cons 
                                       :|Un| 
                                       (cons 
                                        :|Prim| 
                                        (cons 
                                         :|Name| 
                                         (cons 
                                          (cons "eqarg2" nil) 
                                          (JGEN::mkArgProj pV5))))) 
                                      '(:|None|))))) 
                               (JGEN::mkJavaEq e1 e2 (JGEN::srtId pV6)))))) 
                      (return 
                       (let ((e1 
                              (cons 
                               :|CondExp| 
                               (cons 
                                (cons 
                                 :|Un| 
                                 (cons 
                                  :|Prim| 
                                  (cons 
                                   :|Name| 
                                   (cons (cons "this" nil) (JGEN::mkArgProj pV5))))) 
                                '(:|None|))))) 
                         (let ((e2 
                                (cons 
                                 :|CondExp| 
                                 (cons 
                                  (cons 
                                   :|Un| 
                                   (cons 
                                    :|Prim| 
                                    (cons 
                                     :|Name| 
                                     (cons 
                                      (cons "eqarg2" nil) 
                                      (JGEN::mkArgProj pV5))))) 
                                  '(:|None|))))) 
                           (let ((|!eq| (JGEN::mkJavaEq e1 e2 (JGEN::srtId pV6)))) 
                             (let ((restEq (JGEN::mkEqualityBodyForSum pV4))) 
                               (cons 
                                :|CondExp| 
                                (cons 
                                 (cons 
                                  :|Bin| 
                                  (vector 
                                   '(:|CdAnd|) 
                                   (cons 
                                    :|Un| 
                                    (cons :|Prim| (cons :|Paren| |!eq|))) 
                                   (cons 
                                    :|Un| 
                                    (cons :|Prim| (cons :|Paren| restEq))))) 
                                 '(:|None|))))))))))))) 
   (error "Nonexhaustive match failure in mkEqualityBodyForSum")))

(defun JGEN::mkSumEqMethBody (summandId flds) 
  (let ((eqExpr (JGEN::mkEqualityBodyForSum flds))) 
    (let ((s 
           (JGEN::mkVarInit 
            "eqarg2" 
            summandId 
            (cons 
             :|CondExp| 
             (cons 
              (cons 
               :|Un| 
               (cons 
                :|Cast| 
                (cons 
                 (cons (cons :|Name| (cons nil summandId)) 0) 
                 (cons :|Prim| (cons :|Name| (cons nil "eqarg")))))) 
              '(:|None|)))))) 
      (let ((instanceExpr 
             (cons 
              :|CondExp| 
              (cons 
               (cons 
                :|InstOf| 
                (cons 
                 (cons :|Un| (cons :|Prim| (cons :|Name| (cons nil "eqarg")))) 
                 (cons (cons :|Name| (cons nil summandId)) 0))) 
               '(:|None|))))) 
        (let ((negateInstanceExpr 
               (cons 
                :|CondExp| 
                (cons 
                 (cons 
                  :|Un| 
                  (cons 
                   :|Un| 
                   (cons 
                    '(:|LogNot|) 
                    (cons :|Prim| (cons :|Paren| instanceExpr))))) 
                 '(:|None|))))) 
          (cons 
           (JGEN::mkIfStmt 
            negateInstanceExpr 
            (cons 
             (cons 
              :|Stmt| 
              (cons 
               :|Return| 
               (cons 
                :|Some| 
                (cons 
                 :|CondExp| 
                 (cons (cons :|Un| (cons :|Prim| (cons :|Bool| nil))) '(:|None|)))))) 
             nil) 
            (cons 
             s 
             (cons (cons :|Stmt| (cons :|Return| (cons :|Some| eqExpr))) nil))) 
           nil))))))

(defun JGEN::setConstrs (clsBody constrDecls) 
  (vector 
   (svref clsBody 0) 
   constrDecls 
   (svref clsBody 2) 
   (svref clsBody 3) 
   (svref clsBody 4) 
   (svref clsBody 5)))

(defun JGEN::sumToClsDecl (id c args) 
  (let ((summandId (JGEN::mkSummandId id c))) 
    (let ((fldDecls 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (x) 
               (let ((pV3 (cdr x))) 
                 (block 
                  nil 
                  (if (eq (car pV3) :|Base|) 
                      (let ((pV4 (cdr pV3))) 
                        (let ((pV5 (svref pV4 0))) 
                          (if (eq (car pV5) :|Qualified|) 
                              (if (null (svref pV4 1)) 
                                  (return 
                                   (JGEN::fieldToFldDecl 
                                    (JGEN::mkArgProj (car x)) 
                                    (cdr (cdr pV5))))))))) 
                  (error "Nonexhaustive match failure in sumToClsDecl")))) 
            args))) 
      (let ((eqMethDecl (JGEN::mkEqualityMethDecl id))) 
        (let ((eqMethBody (JGEN::mkSumEqMethBody summandId args))) 
          (let ((eqMethDecl (JGEN::setMethodBody eqMethDecl eqMethBody))) 
            (let ((constrDecl 
                   (JGEN::mkSumConstrDecl (JGEN::mkSummandId id c) args))) 
              (vector 
               nil 
               (vector summandId (cons :|Some| (cons nil id)) nil) 
               (JGEN::setConstrs 
                (JGEN::setMethods 
                 (JGEN::setFlds JGEN::emptyClsBody fldDecls) 
                 (cons eqMethDecl nil)) 
                (cons constrDecl nil))))))))))

(defun JGEN::mkSumConstructBody (id n) 
  (labels 
    ((mkArgs (k) 
      (if ( =  k n) 
          (cons 
           (cons 
            :|CondExp| 
            (cons 
             (cons 
              :|Un| 
              (cons 
               :|Prim| 
               (cons 
                :|Name| 
                (cons nil (JGEN::mkArgProj (NAT-SPEC::natToString k)))))) 
             '(:|None|))) 
           nil) 
          (LIST-SPEC::|!cons| 
           (cons 
            :|CondExp| 
            (cons 
             (cons 
              :|Un| 
              (cons 
               :|Prim| 
               (cons 
                :|Name| 
                (cons nil (JGEN::mkArgProj (NAT-SPEC::natToString k)))))) 
             '(:|None|))) 
           (mkArgs (INTEGER-SPEC::|!+| k 1)))))) 
    (let ((args (if ( =  n 0) nil (mkArgs 1)))) 
      (cons 
       (cons 
        :|Stmt| 
        (cons 
         :|Return| 
         (cons 
          :|Some| 
          (cons 
           :|CondExp| 
           (cons 
            (cons 
             :|Un| 
             (cons 
              :|Prim| 
              (cons 
               :|NewClsInst| 
               (cons :|ForCls| (vector (cons nil id) args '(:|None|)))))) 
            '(:|None|)))))) 
       nil))))

(defun JGEN::sumToConsMethodDecl (id c args) 
  (let ((formalParams 
         (LIST-SPEC::|!map|-1-1 
          #'(lambda (x) 
             (let ((pV3 (cdr x))) 
               (block 
                nil 
                (if (eq (car pV3) :|Base|) 
                    (let ((pV4 (cdr pV3))) 
                      (let ((pV5 (svref pV4 0))) 
                        (if (eq (car pV5) :|Qualified|) 
                            (if (null (svref pV4 1)) 
                                (return 
                                 (JGEN::fieldToFormalParam 
                                  (JGEN::mkArgProj (car x)) 
                                  (cdr (cdr pV5))))))))) 
                (error "Nonexhaustive match failure in sumToConsMethodDecl")))) 
          args))) 
    (let ((constBody 
           (JGEN::mkSumConstructBody 
            (JGEN::mkSummandId id c) 
            (LIST-SPEC::|!length| args)))) 
      (cons 
       (vector 
        (cons '(:|Static|) nil) 
        (let ((x (JGEN::tt id))) (cons :|Some| (cons (car x) (cdr x)))) 
        c 
        formalParams 
        nil) 
       (cons :|Some| constBody)))))

(defun JGEN::mkAbstractEqualityMethDecl (id) 
  (cons 
   (vector 
    (cons '(:|Abstract|) nil) 
    (let ((x (JGEN::tt "Boolean"))) (cons :|Some| (cons (car x) (cdr x)))) 
    "equals" 
    (cons (vector nil (JGEN::tt id) (cons (JGEN::mkEqarg id) 0)) nil) 
    nil) 
   '(:|None|)))

(defun JGEN::sumTypeToClsDecl (id sumConstructorMethDecls) 
  (let ((sumEqMethod (JGEN::mkAbstractEqualityMethDecl id))) 
    (vector 
     (cons '(:|Abstract|) nil) 
     (vector id '(:|None|) nil) 
     (JGEN::setMethods 
      JGEN::emptyClsBody 
      (LIST-SPEC::|!cons| sumEqMethod sumConstructorMethDecls)))))

(defun JGEN::coProductToClsDecls (pV16 pV17) 
  (block 
   nil 
   (if (eq (car pV17) :|CoProduct|) 
       (let ((pV19 (car (cdr pV17)))) 
         (return 
          (let ((sumConstructorMethDecls 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) 
                     (let ((pV4 (cdr x))
                           (pV3 (car x))) 
                       (block 
                        nil 
                        (if (eq (car pV4) :|Some|) 
                            (let ((pV5 (cdr pV4))) 
                              (progn (if (eq (car pV5) :|Product|) 
                                         (return 
                                          (JGEN::sumToConsMethodDecl 
                                           pV16 
                                           pV3 
                                           (car (cdr pV5))))) 
                                     (return 
                                      (JGEN::sumToConsMethodDecl 
                                       pV16 
                                       pV3 
                                       (cons (cons "1" pV5) nil))))) 
                            (if (eq (car pV4) :|None|) 
                                (return (JGEN::sumToConsMethodDecl pV16 pV3 nil)))) 
                        (error 
                         "Nonexhaustive match failure in coProductToClsDecls")))) 
                  pV19))) 
            (let ((sumTypeClsDecl 
                   (JGEN::sumTypeToClsDecl pV16 sumConstructorMethDecls))) 
              (let ((sumClsDecls 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x) 
                         (let ((pV11 (cdr x))
                               (pV10 (car x))) 
                           (block 
                            nil 
                            (if (eq (car pV11) :|Some|) 
                                (let ((pV12 (cdr pV11))) 
                                  (progn (if (eq (car pV12) :|Product|) 
                                             (return 
                                              (JGEN::sumToClsDecl 
                                               pV16 
                                               pV10 
                                               (car (cdr pV12))))) 
                                         (return 
                                          (JGEN::sumToClsDecl 
                                           pV16 
                                           pV10 
                                           (cons (cons "1" pV12) nil))))) 
                                (if (eq (car pV11) :|None|) 
                                    (return (JGEN::sumToClsDecl pV16 pV10 nil)))) 
                            (error 
                             "Nonexhaustive match failure in coProductToClsDecls")))) 
                      pV19))) (LIST-SPEC::|!cons| sumTypeClsDecl sumClsDecls))))))) 
   (error "Nonexhaustive match failure in coProductToClsDecls")))

(defun JGEN::mkEqualityBodyForProduct (fields) 
  (block 
   nil 
   (if (null fields) 
       (return 
        (cons 
         :|CondExp| 
         (cons (cons :|Un| (cons :|Prim| (cons :|Bool| t))) '(:|None|)))) 
       (if (consp fields) 
           (let ((pV4 (cdr fields))
                 (pV3 (car fields))) 
             (let ((pV6 (cdr pV3))
                   (pV5 (car pV3))) 
               (progn (if (null pV4) 
                          (return 
                           (let ((e1 
                                  (cons 
                                   :|CondExp| 
                                   (cons 
                                    (cons 
                                     :|Un| 
                                     (cons 
                                      :|Prim| 
                                      (cons :|Name| (cons (cons "this" nil) pV5)))) 
                                    '(:|None|))))) 
                             (let ((e2 
                                    (cons 
                                     :|CondExp| 
                                     (cons 
                                      (cons 
                                       :|Un| 
                                       (cons 
                                        :|Prim| 
                                        (cons 
                                         :|Name| 
                                         (cons (cons "eqarg" nil) pV5)))) 
                                      '(:|None|))))) 
                               (JGEN::mkJavaEq e1 e2 (JGEN::srtId pV6)))))) 
                      (return 
                       (let ((e1 
                              (cons 
                               :|CondExp| 
                               (cons 
                                (cons 
                                 :|Un| 
                                 (cons 
                                  :|Prim| 
                                  (cons :|Name| (cons (cons "this" nil) pV5)))) 
                                '(:|None|))))) 
                         (let ((e2 
                                (cons 
                                 :|CondExp| 
                                 (cons 
                                  (cons 
                                   :|Un| 
                                   (cons 
                                    :|Prim| 
                                    (cons :|Name| (cons (cons "eqarg" nil) pV5)))) 
                                  '(:|None|))))) 
                           (let ((|!eq| (JGEN::mkJavaEq e1 e2 (JGEN::srtId pV6)))) 
                             (let ((restEq (JGEN::mkEqualityBodyForProduct pV4))) 
                               (cons 
                                :|CondExp| 
                                (cons 
                                 (cons 
                                  :|Bin| 
                                  (vector 
                                   '(:|CdAnd|) 
                                   (cons 
                                    :|Un| 
                                    (cons :|Prim| (cons :|Paren| |!eq|))) 
                                   (cons 
                                    :|Un| 
                                    (cons :|Prim| (cons :|Paren| restEq))))) 
                                 '(:|None|))))))))))))) 
   (error "Nonexhaustive match failure in mkEqualityBodyForProduct")))

(defun JGEN::mkProdConstBody (fieldProjs) 
  (block 
   nil 
   (if (null fieldProjs) 
       (return nil) 
       (if (consp fieldProjs) 
           (let ((pV3 (car fieldProjs))) 
             (return 
              (let ((assn 
                     (JGEN::mkNameAssn 
                      (cons (cons "this" nil) pV3) 
                      (cons nil pV3)))) 
                (let ((restAssns (JGEN::mkProdConstBody (cdr fieldProjs)))) 
                  (LIST-SPEC::|!cons| assn restAssns))))))) 
   (error "Nonexhaustive match failure in mkProdConstBody")))

(defun JGEN::mkProdConstrDecl (id fields) 
  (let ((formParams 
         (LIST-SPEC::|!map|-1-1 
          #'(lambda (x) 
             (let ((pV3 (cdr x))) 
               (block 
                nil 
                (if (eq (car pV3) :|Base|) 
                    (let ((pV4 (cdr pV3))) 
                      (let ((pV5 (svref pV4 0))) 
                        (if (eq (car pV5) :|Qualified|) 
                            (if (null (svref pV4 1)) 
                                (return 
                                 (JGEN::fieldToFormalParam 
                                  (car x) 
                                  (cdr (cdr pV5))))))))) 
                (error "Nonexhaustive match failure in mkProdConstrDecl")))) 
          fields))) 
    (let ((fieldProjs (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) fields))) 
      (let ((prodConstrBody (JGEN::mkProdConstBody fieldProjs))) 
        (vector nil id formParams nil prodConstrBody)))))

(defun JGEN::mkProductTypeClsDecl
 (id prodFieldsDecl prodMethodDecls constrDecls) 
  (vector 
   nil 
   (vector id '(:|None|) nil) 
   (JGEN::setConstrs 
    (JGEN::setMethods 
     (JGEN::setFlds JGEN::emptyClsBody prodFieldsDecl) 
     prodMethodDecls) 
    constrDecls)))

(defun JGEN::productToClsDecl (pV12 pV13) 
  (block 
   nil 
   (if (eq (car pV13) :|Product|) 
       (let ((pV15 (car (cdr pV13)))) 
         (return 
          (let ((prodFieldsDecls 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) 
                     (let ((pV4 (cdr x))) 
                       (block 
                        nil 
                        (if (eq (car pV4) :|Base|) 
                            (let ((pV5 (cdr pV4))) 
                              (let ((pV6 (svref pV5 0))) 
                                (if (eq (car pV6) :|Qualified|) 
                                    (if (null (svref pV5 1)) 
                                        (return 
                                         (JGEN::fieldToFldDecl 
                                          (car x) 
                                          (cdr (cdr pV6))))))))) 
                        (error "Nonexhaustive match failure in productToClsDecl")))) 
                  pV15))) 
            (let ((equalityConjunction (JGEN::mkEqualityBodyForProduct pV15))) 
              (let ((prodMethodDecl (JGEN::mkEqualityMethDecl pV12))) 
                (let ((prodMethodDecl 
                       (JGEN::setMethodBody 
                        prodMethodDecl 
                        (cons 
                         (cons 
                          :|Stmt| 
                          (cons :|Return| (cons :|Some| equalityConjunction))) 
                         nil)))) 
                  (let ((prodConstrDecls 
                         (cons (JGEN::mkProdConstrDecl pV12 pV15) nil))) 
                    (JGEN::mkProductTypeClsDecl 
                     pV12 
                     prodFieldsDecls 
                     (cons prodMethodDecl nil) 
                     prodConstrDecls))))))))) 
   (error "Nonexhaustive match failure in productToClsDecl")))

(defun JGEN::userTypeToClsDecl (id) 
  (vector nil (vector id '(:|None|) nil) JGEN::emptyClsBody))

(defun JGEN::sortToClsDecls (qualifier id sort_info) 
  (block 
   nil 
   (let ((pV25 (svref sort_info 2))) 
     (if (consp pV25) 
         (let ((pV30 (cdr (car pV25)))) 
           (if (null (cdr pV25)) 
               (return 
                (if (JGEN::baseType? pV30) 
                    (SYSTEM-SPEC::fail "Unsupported sort definition") 
                    (block 
                     nil 
                     (if (eq (car pV30) :|Product|) 
                         (return (cons (JGEN::productToClsDecl id pV30) nil)) 
                         (if (eq (car pV30) :|CoProduct|) 
                             (return (JGEN::coProductToClsDecls id pV30)) 
                             (if (eq (car pV30) :|Base|) 
                                 (let ((pV9 (cdr pV30))) 
                                   (let ((pV12 (svref pV9 0))) 
                                     (if (eq (car pV12) :|Qualified|) 
                                         (if (null (svref pV9 1)) 
                                             (return 
                                              (cons 
                                               (JGEN::userTypeToClsDecl 
                                                (cdr (cdr pV12))) 
                                               nil))))))))) 
                     (return (SYSTEM-SPEC::fail "unsupported sort defintion"))))))))) 
   (error "Nonexhaustive match failure in sortToClsDecls")))

(defun JGEN::clsDeclsFromSorts-1 (spc) 
  (LIST-SPEC::|!cons| 
   JGEN::mkPrimOpsClsDecl 
   (foldriAQualifierMap-1-1-1 
    #'(lambda (x) 
       (let ((newClsDecls 
              (JGEN::sortToClsDecls (svref x 0) (svref x 1) (svref x 2)))) 
         (LIST-SPEC::|!++| newClsDecls (svref x 3)))) 
    nil 
    (svref spc 3))))

(defun JGEN::clsDeclsFromSorts (x0 x1 x2 x3) 
  (JGEN::clsDeclsFromSorts-1 (vector x0 x1 x2 x3)))

(defun JGEN::coProductToClsDecls-1 (x) 
  (JGEN::coProductToClsDecls (car x) (cdr x)))

(defun JGEN::distinctVars (terms ids) 
  (block 
   nil 
   (if (null terms) 
       (return (cons nil ids)) 
       (if (consp terms) 
           (return 
            (let ((pV4 (JGEN::distinctVar (car terms) ids))) 
              (block 
               nil 
               (return 
                (let ((pV1 (JGEN::distinctVars (cdr terms) (cdr pV4)))) 
                  (block 
                   nil 
                   (return 
                    (cons (LIST-SPEC::|!cons| (car pV4) (car pV1)) (cdr pV1))) 
                   (error "Nonexhaustive match failure in distinctVars")))) 
               (error "Nonexhaustive match failure in distinctVars")))))) 
   (error "Nonexhaustive match failure in distinctVars")))

(defun STANDARDSPEC::mkAppl (t1 tms) 
  (cons :|Apply| (vector t1 (STANDARDSPEC::mkTuple tms) POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkApplication (t1 tms) 
  (block 
   nil 
   (if (consp tms) 
       (progn (if (null (cdr tms)) (return (STANDARDSPEC::mkApply t1 (car tms)))) 
              (return (STANDARDSPEC::mkAppl t1 tms)))) 
   (error "Nonexhaustive match failure in mkApplication")))

(defun JGEN::distinctVarApply (pV5 pV6) 
  (block 
   nil 
   (if (eq (car pV5) :|Apply|) 
       (let ((pV7 (cdr pV5))) 
         (return 
          (let ((args (JGEN::applyArgsToTerms (svref pV7 1)))) 
            (let ((pV2 (JGEN::distinctVars args pV6))) 
              (block 
               nil 
               (return 
                (cons 
                 (STANDARDSPEC::mkApplication (svref pV7 0) (car pV2)) 
                 (cdr pV2))) 
               (error "Nonexhaustive match failure in distinctVarApply"))))))) 
   (error "Nonexhaustive match failure in distinctVarApply")))

(defun JGEN::distinctVarCase (term ids) 
  (let ((caseTerm (JGEN::caseTerm term))) 
    (let ((pV10 (JGEN::distinctVar caseTerm ids))) 
      (block 
       nil 
       (return 
        (let ((cases (JGEN::caseCases term))) 
          (let ((caseBodys 
                 (LIST-SPEC::|!map|-1-1 #'(lambda (x) (svref x 2)) cases))) 
            (let ((pV7 (JGEN::distinctVars caseBodys (cdr pV10)))) 
              (block 
               nil 
               (return 
                (let ((newCases 
                       (LISTPAIR::|!map|-1-1 
                        #'(lambda (x) 
                           (let ((pV2 (car x))) 
                             (block 
                              nil 
                              (return 
                               (vector (svref pV2 0) (svref pV2 1) (cdr x))) 
                              (error 
                               "Nonexhaustive match failure in distinctVarCase")))) 
                        (cons cases (car pV7))))) 
                  (let ((newTerm 
                         (STANDARDSPEC::mkApply 
                          (cons :|Lambda| (cons newCases POSITION-SPEC::noPos)) 
                          (car pV10)))) (cons newTerm (cdr pV7))))) 
               (error "Nonexhaustive match failure in distinctVarCase")))))) 
       (error "Nonexhaustive match failure in distinctVarCase")))))

(defun STANDARDSPEC::mkIfThenElse (t1 t2 t3) 
  (cons :|IfThenElse| (vector t1 t2 t3 POSITION-SPEC::noPos)))

(defun JGEN::distinctVarIfThenElse (pV14 pV15) 
  (block 
   nil 
   (if (eq (car pV14) :|IfThenElse|) 
       (let ((pV16 (cdr pV14))) 
         (return 
          (let ((pV2 
                 (JGEN::distinctVars 
                  (cons 
                   (svref pV16 0) 
                   (cons (svref pV16 1) (cons (svref pV16 2) nil))) 
                  pV15))) 
            (block 
             nil 
             (let ((pV3 (car pV2))) 
               (if (consp pV3) 
                   (let ((pV7 (cdr pV3))) 
                     (if (consp pV7) 
                         (let ((pV10 (cdr pV7))) 
                           (if (consp pV10) 
                               (if (null (cdr pV10)) 
                                   (return 
                                    (cons 
                                     (STANDARDSPEC::mkIfThenElse 
                                      (car pV3) 
                                      (car pV7) 
                                      (car pV10)) 
                                     (cdr pV2)))))))))) 
             (error "Nonexhaustive match failure in distinctVarIfThenElse")))))) 
   (error "Nonexhaustive match failure in distinctVarIfThenElse")))

(defun JGEN::mkNewId (id n) 
  (STRING-SPEC::^ (STRING-SPEC::^ id "___") (NAT-SPEC::natToString n)))

(defun JGEN::findNewId (vId ids) 
  (labels 
    ((findNewIdRec (id ids num) 
      (if (LIST-SPEC::|!member| id ids) 
          (findNewIdRec (JGEN::mkNewId id num) ids (INTEGER-SPEC::|!+| num 1)) 
          id))) (findNewIdRec (JGEN::mkNewId vId 1) ids 2)))

(defun JGEN::renameVarApply (pV2 pV3 pV4) 
  (block 
   nil 
   (if (eq (car pV2) :|Apply|) 
       (let ((pV5 (cdr pV2))) 
         (return 
          (let ((args (JGEN::applyArgsToTerms (svref pV5 1)))) 
            (let ((newArgs 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (arg) (JGEN::renameVar arg pV3 pV4)) 
                    args))) (STANDARDSPEC::mkApplication (svref pV5 0) newArgs)))))) 
   (error "Nonexhaustive match failure in renameVarApply")))

(defun JGEN::renameVarIfThenElse (pV2 pV3 pV4) 
  (block 
   nil 
   (if (eq (car pV2) :|IfThenElse|) 
       (let ((pV5 (cdr pV2))) 
         (return 
          (let ((newT1 (JGEN::renameVar (svref pV5 0) pV3 pV4))) 
            (let ((newT2 (JGEN::renameVar (svref pV5 1) pV3 pV4))) 
              (let ((newT3 (JGEN::renameVar (svref pV5 2) pV3 pV4))) 
                (STANDARDSPEC::mkIfThenElse newT1 newT2 newT3))))))) 
   (error "Nonexhaustive match failure in renameVarIfThenElse")))

(defun JGEN::renameVarLetNewVar (letTerm letBody oldV newV) 
  (let ((newLetTerm (JGEN::renameVar letTerm oldV newV))) 
    (STANDARDSPEC::mkLet 
     (cons (cons (STANDARDSPEC::mkVarPat-1 newV) newLetTerm) nil) 
     letBody)))

(defun JGEN::renameVarLetOldVar (letTerm letBody oldV newV) 
  (let ((newLetTerm (JGEN::renameVar letTerm oldV newV))) 
    (let ((newLetBody (JGEN::renameVar letBody oldV newV))) 
      (STANDARDSPEC::mkLet 
       (cons (cons (STANDARDSPEC::mkVarPat-1 oldV) newLetTerm) nil) 
       newLetBody))))

(defun JGEN::renameVarLet (pV13 pV14 pV15) 
  (block 
   nil 
   (if (eq (car pV13) :|Let|) 
       (let ((pV16 (cdr pV13))) 
         (let ((pV18 (svref pV16 1))
               (pV17 (svref pV16 0))) 
           (return 
            (block 
             nil 
             (if (consp pV17) 
                 (let ((pV6 (car pV17))) 
                   (let ((pV9 (cdr pV6))
                         (pV8 (car pV6))) 
                     (if (eq (car pV8) :|VarPat|) 
                         (if (null (cdr pV17)) 
                             (return 
                              (if (METASLANG::equalVar? (car (cdr pV8)) pV14) 
                                  (JGEN::renameVarLetNewVar pV9 pV18 pV14 pV15) 
                                  (JGEN::renameVarLetOldVar pV9 pV18 pV14 pV15)))))))) 
             (return (SYSTEM-SPEC::fail "unsupported in renameVarLet"))))))) 
   (error "Nonexhaustive match failure in renameVarLet")))

(defun JGEN::renameVarRecord (pV7 pV8 pV9) 
  (block 
   nil 
   (if (eq (car pV7) :|Record|) 
       (let ((pV11 (car (cdr pV7)))) 
         (return 
          (let ((recordTerms (JGEN::recordFieldsToTerms pV11))) 
            (let ((newTerms 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (recordTerm) (JGEN::renameVar recordTerm pV8 pV9)) 
                    recordTerms))) 
              (let ((newFields 
                     (LISTPAIR::|!map|-1-1 
                      #'(lambda (x) 
                         (block 
                          nil 
                          (return (cons (car (car x)) (cdr x))) 
                          (error 
                           "Nonexhaustive match failure in renameVarRecord"))) 
                      (cons pV11 newTerms)))) 
                (STANDARDSPEC::mkRecord newFields))))))) 
   (error "Nonexhaustive match failure in renameVarRecord")))

(defun JGEN::renameVar (term oldV newV) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (let ((pV11 (cdr term))) 
         (return 
          (if (METASLANG::equalVar? (car pV11) oldV) 
              (cons :|Var| (cons newV (cdr pV11))) 
              term))) 
       (if (eq (car term) :|Apply|) 
           (return (JGEN::renameVarApply term oldV newV)) 
           (if (eq (car term) :|Record|) 
               (return (JGEN::renameVarRecord term oldV newV)) 
               (if (eq (car term) :|IfThenElse|) 
                   (return (JGEN::renameVarIfThenElse term oldV newV)) 
                   (if (eq (car term) :|Let|) 
                       (return (JGEN::renameVarLet term oldV newV))))))) 
   (return (SYSTEM-SPEC::fail "unsupported in renameVar"))))

(defun JGEN::distinctVarLetNewVar (pV7 pV8 pV9 pV10) 
  (block 
   nil 
   (let ((pV11 (car pV7))) 
     (return 
      (let ((newId (JGEN::findNewId pV11 pV10))) 
        (let ((newIds (LIST-SPEC::|!cons| pV11 pV10))) 
          (let ((newVar (cons newId (cdr pV7)))) 
            (let ((pV4 (JGEN::distinctVar pV8 newIds))) 
              (block 
               nil 
               (return 
                (let ((renamedLetBody (JGEN::renameVar pV9 pV7 newVar))) 
                  (let ((pV1 (JGEN::distinctVar renamedLetBody (cdr pV4)))) 
                    (block 
                     nil 
                     (return 
                      (cons 
                       (STANDARDSPEC::mkLet 
                        (cons 
                         (cons (STANDARDSPEC::mkVarPat-1 newVar) (car pV4)) 
                         nil) 
                        (car pV1)) 
                       (cdr pV1))) 
                     (error 
                      "Nonexhaustive match failure in distinctVarLetNewVar"))))) 
               (error "Nonexhaustive match failure in distinctVarLetNewVar")))))))) 
   (error "Nonexhaustive match failure in distinctVarLetNewVar")))

(defun JGEN::distinctVarLetNoNewVar (pV7 pV8 pV9 pV10) 
  (block 
   nil 
   (return 
    (let ((newIds (LIST-SPEC::|!cons| (car pV7) pV10))) 
      (let ((pV4 (JGEN::distinctVar pV8 newIds))) 
        (block 
         nil 
         (return 
          (let ((pV1 (JGEN::distinctVar pV9 (cdr pV4)))) 
            (block 
             nil 
             (return 
              (cons 
               (STANDARDSPEC::mkLet 
                (cons (cons (STANDARDSPEC::mkVarPat-1 pV7) (car pV4)) nil) 
                (car pV1)) 
               (cdr pV1))) 
             (error "Nonexhaustive match failure in distinctVarLetNoNewVar")))) 
         (error "Nonexhaustive match failure in distinctVarLetNoNewVar"))))) 
   (error "Nonexhaustive match failure in distinctVarLetNoNewVar")))

(defun JGEN::distinctVarLet (pV16 pV17) 
  (block 
   nil 
   (if (eq (car pV16) :|Let|) 
       (let ((pV18 (cdr pV16))) 
         (let ((pV20 (svref pV18 1))
               (pV19 (svref pV18 0))) 
           (return 
            (block 
             nil 
             (if (consp pV19) 
                 (let ((pV9 (car pV19))) 
                   (let ((pV12 (cdr pV9))
                         (pV11 (car pV9))) 
                     (if (eq (car pV11) :|VarPat|) 
                         (let ((pV14 (car (cdr pV11)))) 
                           (if (null (cdr pV19)) 
                               (return 
                                (block 
                                 nil 
                                 (return 
                                  (if (LIST-SPEC::|!member| (car pV14) pV17) 
                                      (JGEN::distinctVarLetNewVar 
                                       pV14 
                                       pV12 
                                       pV20 
                                       pV17) 
                                      (JGEN::distinctVarLetNoNewVar 
                                       pV14 
                                       pV12 
                                       pV20 
                                       pV17))) 
                                 (error 
                                  "Nonexhaustive match failure in distinctVarLet"))))))))) 
             (return (SYSTEM-SPEC::fail "unsupported in distinctVarLet"))))))) 
   (error "Nonexhaustive match failure in distinctVarLet")))

(defun JGEN::distinctVarRecord (pV10 pV11) 
  (block 
   nil 
   (if (eq (car pV10) :|Record|) 
       (let ((pV13 (car (cdr pV10)))) 
         (return 
          (let ((recordTerms (JGEN::recordFieldsToTerms pV13))) 
            (let ((pV7 (JGEN::distinctVars recordTerms pV11))) 
              (block 
               nil 
               (return 
                (let ((newFields 
                       (LISTPAIR::|!map|-1-1 
                        #'(lambda (x) 
                           (block 
                            nil 
                            (return (cons (car (car x)) (cdr x))) 
                            (error 
                             "Nonexhaustive match failure in distinctVarRecord"))) 
                        (cons pV13 (car pV7))))) 
                  (cons (STANDARDSPEC::mkRecord newFields) (cdr pV7)))) 
               (error "Nonexhaustive match failure in distinctVarRecord"))))))) 
   (error "Nonexhaustive match failure in distinctVarRecord")))

(defun JGEN::distinctVar (term ids) 
  (if (JGEN::caseTerm? term) 
      (JGEN::distinctVarCase term ids) 
      (block 
       nil 
       (if (eq (car term) :|Var|) 
           (return (cons term ids)) 
           (if (eq (car term) :|Fun|) 
               (return (cons term ids)) 
               (if (eq (car term) :|Apply|) 
                   (return (JGEN::distinctVarApply term ids)) 
                   (if (eq (car term) :|Record|) 
                       (return (JGEN::distinctVarRecord term ids)) 
                       (if (eq (car term) :|IfThenElse|) 
                           (return (JGEN::distinctVarIfThenElse term ids)) 
                           (if (eq (car term) :|Let|) 
                               (return (JGEN::distinctVarLet term ids)))))))) 
       (return (SYSTEM-SPEC::fail "unsupported in distinctVar")))))

(defun JGEN::distinctVar-1 (x) (JGEN::distinctVar (car x) (cdr x)))

(defun JGEN::distinctVarApply-1 (x) (JGEN::distinctVarApply (car x) (cdr x)))

(defun JGEN::distinctVarCase-1 (x) (JGEN::distinctVarCase (car x) (cdr x)))

(defun JGEN::distinctVarIfThenElse-1 (x) 
  (JGEN::distinctVarIfThenElse (car x) (cdr x)))

(defun JGEN::distinctVarLet-1 (x) (JGEN::distinctVarLet (car x) (cdr x)))

(defun JGEN::distinctVarLetNewVar-1 (x) 
  (JGEN::distinctVarLetNewVar (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JGEN::distinctVarLetNoNewVar-1 (x) 
  (JGEN::distinctVarLetNoNewVar (svref x 0) (svref x 1) (svref x 2) (svref x 3)))


(defun JGEN::distinctVarRecord-1 (x) (JGEN::distinctVarRecord (car x) (cdr x)))

(defun METASLANG::mkQualifiedId (qualifier id) 
  (cons :|Qualified| (cons qualifier id)))

(defun JGEN::distinctVariable-1 (spc) 
  (let ((newOpDefs 
         (foldriAQualifierMap-1-1-1 
          #'(lambda (x) 
             (let ((pV10 (svref x 2))) 
               (block 
                nil 
                (let ((pV15 (svref pV10 3))) 
                  (let ((pV17 (cdr (svref pV10 2)))) 
                    (if (consp pV15) 
                        (if (null (cdr pV15)) 
                            (return 
                             (let ((origOp 
                                    (METASLANG::mkQualifiedId 
                                     (svref x 0) 
                                     (svref x 1)))) 
                               (let ((pV5 
                                      (JGEN::srtTermDelta pV17 (cdr (car pV15))))) 
                                 (block 
                                  nil 
                                  (let ((pV6 (car pV5))) 
                                    (return 
                                     (let ((ids 
                                            (LIST-SPEC::|!map|-1-1 
                                             #'(lambda (x1) (car x1)) 
                                             pV6))) 
                                       (let ((pV2 
                                              (JGEN::distinctVar (cdr pV5) ids))) 
                                         (block 
                                          nil 
                                          (return 
                                           (let ((origOpNewDef 
                                                  (vector 
                                                   origOp 
                                                   (JGEN::srtDom pV17) 
                                                   (JGEN::srtRange pV17) 
                                                   pV6 
                                                   (car pV2)))) 
                                             (LIST-SPEC::|!cons| 
                                              origOpNewDef 
                                              (svref x 3)))) 
                                          (error 
                                           "Nonexhaustive match failure in distinctVariable")))))) 
                                  (error 
                                   "Nonexhaustive match failure in distinctVariable"))))))))) 
                (error "Nonexhaustive match failure in distinctVariable")))) 
          nil 
          (svref spc 1)))) 
    (let ((result (setSorts emptySpec (svref spc 3)))) 
      (let ((result 
             (LIST-SPEC::foldr-1-1-1 #'JGEN::addOdToSpec-1 result newOpDefs))) 
        result))))

(defun JGEN::distinctVariable (x0 x1 x2 x3) 
  (JGEN::distinctVariable-1 (vector x0 x1 x2 x3)))

(defun JGEN::distinctVars-1 (x) (JGEN::distinctVars (car x) (cdr x)))

(defparameter JGEN::emptyJSpec (vector '(:|None|) nil nil))

(defun JGEN::fieldToFldDecl-1 (x) (JGEN::fieldToFldDecl (car x) (cdr x)))

(defun JGEN::fieldToFormalParam-1 (x) 
  (JGEN::fieldToFormalParam (car x) (cdr x)))

(defun JGEN::findNewId-1 (x) (JGEN::findNewId (car x) (cdr x)))

(defun JGEN::liftCases (oper terms k) 
  (block 
   nil 
   (if (null terms) 
       (return (vector nil k nil)) 
       (if (consp terms) 
           (return 
            (let ((pV5 (JGEN::liftCase oper (car terms) k))) 
              (block 
               nil 
               (return 
                (let ((pV1 (JGEN::liftCases oper (cdr terms) (svref pV5 1)))) 
                  (block 
                   nil 
                   (return 
                    (vector 
                     (LIST-SPEC::|!cons| (svref pV5 0) (svref pV1 0)) 
                     (svref pV1 1) 
                     (LIST-SPEC::|!++| (svref pV5 2) (svref pV1 2)))) 
                   (error "Nonexhaustive match failure in liftCases")))) 
               (error "Nonexhaustive match failure in liftCases")))))) 
   (error "Nonexhaustive match failure in liftCases")))

(defun JGEN::liftCaseApply (pV6 pV7 pV8) 
  (block 
   nil 
   (if (eq (car pV7) :|Apply|) 
       (let ((pV9 (cdr pV7))) 
         (return 
          (let ((args (JGEN::applyArgsToTerms (svref pV9 1)))) 
            (let ((pV2 (JGEN::liftCases pV6 args pV8))) 
              (block 
               nil 
               (return 
                (vector 
                 (STANDARDSPEC::mkApplication (svref pV9 0) (svref pV2 0)) 
                 (svref pV2 1) 
                 (svref pV2 2))) 
               (error "Nonexhaustive match failure in liftCaseApply"))))))) 
   (error "Nonexhaustive match failure in liftCaseApply")))

(defun JGEN::mkNewOp (oper k) 
  (block 
   nil 
   (if (eq (car oper) :|Qualified|) 
       (let ((pV2 (cdr oper))) 
         (return 
          (METASLANG::mkQualifiedId 
           (car pV2) 
           (STRING-SPEC::^ (cdr pV2) (NAT-SPEC::natToString k)))))) 
   (error "Nonexhaustive match failure in mkNewOp")))

(defun JGEN::mkNewVar (oper k |!t|) 
  (block 
   nil 
   (if (eq (car oper) :|Qualified|) 
       (return 
        (cons (STRING-SPEC::^ (cdr (cdr oper)) (NAT-SPEC::natToString k)) |!t|))) 
   (error "Nonexhaustive match failure in mkNewVar")))

(defun NAT-SPEC::div (n m) 
  (if (INTEGER-SPEC::|!<| n m) 
      0 
      (INTEGER-SPEC::|!+| 1 (NAT-SPEC::div (INTEGER-SPEC::|!-| n m) m))))

(defun MERGESORT::uniqueSort-1-1 (cmpfn ls) 
  (labels 
    ((|!merge| (xs ys) 
      (block 
       nil 
       (if (null xs) (return ys)) 
       (if (null ys) (return xs)) 
       (if (consp xs) 
           (let ((pV6 (car xs))
                 (pV7 (cdr xs))) 
             (if (consp ys) 
                 (let ((pV9 (car ys))
                       (pV10 (cdr ys))) 
                   (return 
                    (let ((pV2 (funcall cmpfn (cons pV6 pV9)))) 
                      (block 
                       nil 
                       (if (eq (car pV2) :|Greater|) 
                           (return (cons pV9 (|!merge| (cons pV6 pV7) pV10))) 
                           (if (eq (car pV2) :|Equal|) 
                               (return (|!merge| (cons pV6 pV7) pV10)))) 
                       (return (cons pV6 (|!merge| pV7 (cons pV9 pV10))))))))))) 
       (error "Nonexhaustive match failure in uniqueSort")))) 
    (labels 
      ((mergepairs (ls k) 
        (block 
         nil 
         (if (consp ls) 
             (let ((pV14 (car ls))
                   (pV15 (cdr ls))) 
               (if (null pV15) 
                   (return ls) 
                   (if (consp pV15) 
                       (let ((pV17 (car pV15))
                             (pV18 (cdr pV15))) 
                         (return 
                          (if ( =  (NAT-SPEC::|!rem| k 2) 1) 
                              (cons pV14 (cons pV17 pV18)) 
                              (mergepairs 
                               (cons (|!merge| pV14 pV17) pV18) 
                               (NAT-SPEC::div k 2))))))))) 
         (return (SYSTEM-SPEC::fail "Impossible: mergepairs"))))) 
      (labels 
        ((nextrun (run xs) 
          (block 
           nil 
           (if (null xs) 
               (return (cons (LIST-SPEC::rev run) nil)) 
               (if (consp xs) 
                   (let ((pV23 (car xs))
                         (pV24 (cdr xs))) 
                     (return 
                      (let ((pV20 
                             (funcall cmpfn (cons pV23 (LIST-SPEC::hd run))))) 
                        (block 
                         nil 
                         (if (eq (car pV20) :|Greater|) 
                             (return (nextrun (cons pV23 run) pV24)) 
                             (if (eq (car pV20) :|Equal|) 
                                 (return (nextrun run pV24)))) 
                         (return (cons (LIST-SPEC::rev run) (cons pV23 pV24))))))))) 
           (error "Nonexhaustive match failure in uniqueSort")))) 
        (labels 
          ((samsorting (xs ls k) 
            (block 
             nil 
             (if (null xs) 
                 (return (LIST-SPEC::hd (mergepairs ls 0))) 
                 (if (consp xs) 
                     (return 
                      (let ((pV25 (nextrun (cons (car xs) nil) (cdr xs)))) 
                        (block 
                         nil 
                         (return 
                          (samsorting 
                           (cdr pV25) 
                           (mergepairs 
                            (cons (car pV25) ls) 
                            (INTEGER-SPEC::|!+| k 1)) 
                           (INTEGER-SPEC::|!+| k 1))) 
                         (error "Nonexhaustive match failure in uniqueSort")))))) 
             (error "Nonexhaustive match failure in uniqueSort")))) 
          (block nil (if (null ls) (return nil)) (return (samsorting ls nil 0))))))))


(defun LISTUTILITIES::|!delete| (e l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV4 (cdr l))
                 (pV3 (car l))) 
             (return 
              (if (slang-built-in::slang-term-equals e pV3) 
                  (LISTUTILITIES::|!delete| e pV4) 
                  (cons pV3 (LISTUTILITIES::|!delete| e pV4))))))) 
   (error "Nonexhaustive match failure in delete")))

(defun LISTUTILITIES::|!delete|-1 (x) 
  (LISTUTILITIES::|!delete| (car x) (cdr x)))

(defun UTILITIES::deleteVars (vars1 vars2) 
  (LIST-SPEC::foldr-1-1-1 #'LISTUTILITIES::|!delete|-1 vars1 vars2))

(defun UTILITIES::freeVarsList (|!list|) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (return (LIST-SPEC::|!++| (cdr x) (UTILITIES::freeVarsRec (cdr (car x))))) 
       (error "Nonexhaustive match failure in freeVarsList"))) 
   nil 
   |!list|))

(defun UTILITIES::patVars (pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV33 (cdr pat))) 
         (return 
          (LIST-SPEC::|!++| 
           (UTILITIES::patVars (svref pV33 0)) 
           (UTILITIES::patVars (svref pV33 1))))) 
       (if (eq (car pat) :|VarPat|) 
           (return (cons (car (cdr pat)) nil)) 
           (if (eq (car pat) :|EmbedPat|) 
               (progn (let ((pV43 (svref (cdr pat) 1))) 
                        (if (eq (car pV43) :|Some|) 
                            (return (UTILITIES::patVars (cdr pV43))))) 
                      (return nil)) 
               (if (eq (car pat) :|RecordPat|) 
                   (return 
                    (LIST-SPEC::foldr-1-1-1 
                     #'(lambda (x) 
                        (block 
                         nil 
                         (return 
                          (LIST-SPEC::|!++| 
                           (UTILITIES::patVars (cdr (car x))) 
                           (cdr x))) 
                         (error "Nonexhaustive match failure in patVars"))) 
                     nil 
                     (car (cdr pat)))) 
                   (if (eq (car pat) :|WildPat|) 
                       (return nil) 
                       (if (eq (car pat) :|StringPat|) 
                           (return nil) 
                           (if (eq (car pat) :|BoolPat|) 
                               (return nil) 
                               (if (eq (car pat) :|CharPat|) 
                                   (return nil) 
                                   (if (eq (car pat) :|NatPat|) 
                                       (return nil) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (return 
                                            (UTILITIES::patVars 
                                             (svref (cdr pat) 0))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (return 
                                                (UTILITIES::patVars 
                                                 (svref (cdr pat) 0)))))))))))))) 
   (error "Nonexhaustive match failure in patVars")))

(defun UTILITIES::freeVarsRec (|!M|) 
  (block 
   nil 
   (if (eq (car |!M|) :|Var|) 
       (return (cons (car (cdr |!M|)) nil)) 
       (if (eq (car |!M|) :|Apply|) 
           (let ((pV28 (cdr |!M|))) 
             (return 
              (LIST-SPEC::|!++| 
               (UTILITIES::freeVarsRec (svref pV28 0)) 
               (UTILITIES::freeVarsRec (svref pV28 1))))) 
           (if (eq (car |!M|) :|Record|) 
               (return (UTILITIES::freeVarsList (car (cdr |!M|)))) 
               (if (eq (car |!M|) :|Fun|) 
                   (return nil) 
                   (if (eq (car |!M|) :|Lambda|) 
                       (return 
                        (LIST-SPEC::foldr-1-1-1 
                         #'(lambda (x) 
                            (LIST-SPEC::|!++| 
                             (cdr x) 
                             (UTILITIES::freeVarsMatch-1 (car x)))) 
                         nil 
                         (car (cdr |!M|)))) 
                       (if (eq (car |!M|) :|Let|) 
                           (let ((pV24 (cdr |!M|))) 
                             (return 
                              (let ((pV13 
                                     (LIST-SPEC::foldr-1-1-1 
                                      #'(lambda (x) 
                                         (let ((pV8 (cdr x))
                                               (pV7 (car x))) 
                                           (block 
                                            nil 
                                            (return 
                                             (cons 
                                              (LIST-SPEC::|!++| 
                                               (UTILITIES::patVars (car pV7)) 
                                               (car pV8)) 
                                              (LIST-SPEC::|!++| 
                                               (UTILITIES::freeVarsRec (cdr pV7)) 
                                               (cdr pV8)))) 
                                            (error 
                                             "Nonexhaustive match failure in freeVarsRec")))) 
                                      (cons nil nil) 
                                      (svref pV24 0)))) 
                                (block 
                                 nil 
                                 (return 
                                  (let ((mVars 
                                         (UTILITIES::freeVarsRec (svref pV24 1)))) 
                                    (LIST-SPEC::|!++| 
                                     (cdr pV13) 
                                     (UTILITIES::deleteVars mVars (car pV13))))) 
                                 (error 
                                  "Nonexhaustive match failure in freeVarsRec"))))) 
                           (if (eq (car |!M|) :|LetRec|) 
                               (let ((pV23 (cdr |!M|))) 
                                 (let ((pV38 (svref pV23 0))) 
                                   (return 
                                    (let ((vars1 
                                           (UTILITIES::freeVarsRec 
                                            (svref pV23 1)))) 
                                      (let ((vars2 
                                             (UTILITIES::freeVarsList pV38))) 
                                        (UTILITIES::deleteVars 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) (car x)) 
                                          pV38) 
                                         (LIST-SPEC::|!++| vars1 vars2))))))) 
                               (if (eq (car |!M|) :|Bind|) 
                                   (let ((pV22 (cdr |!M|))) 
                                     (return 
                                      (UTILITIES::deleteVars 
                                       (UTILITIES::freeVarsRec (svref pV22 2)) 
                                       (svref pV22 1)))) 
                                   (if (eq (car |!M|) :|IfThenElse|) 
                                       (let ((pV21 (cdr |!M|))) 
                                         (return 
                                          (LIST-SPEC::|!++| 
                                           (LIST-SPEC::|!++| 
                                            (UTILITIES::freeVarsRec 
                                             (svref pV21 0)) 
                                            (UTILITIES::freeVarsRec 
                                             (svref pV21 1))) 
                                           (UTILITIES::freeVarsRec 
                                            (svref pV21 2)))))))))))))) 
   (error "Nonexhaustive match failure in freeVarsRec")))

(defun UTILITIES::freeVarsMatch (pat |!cond| body) 
  (let ((vars (UTILITIES::patVars pat))) 
    (let ((vars1 (UTILITIES::freeVarsRec |!cond|))) 
      (let ((vars2 (UTILITIES::freeVarsRec body))) 
        (UTILITIES::deleteVars (LIST-SPEC::|!++| vars1 vars2) vars)))))

(defun UTILITIES::freeVarsMatch-1 (x) 
  (UTILITIES::freeVarsMatch (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCaseCase (oper term k) 
  (let ((ttermSort (METASLANG::termSort term))) 
    (let ((caseTerm (JGEN::caseTerm term))) 
      (let ((caseTermSort (METASLANG::termSort caseTerm))) 
        (let ((pV19 (JGEN::liftCase oper caseTerm (INTEGER-SPEC::|!+| k 1)))) 
          (block 
           nil 
           (return 
            (let ((cases (JGEN::caseCases term))) 
              (let ((caseBodys 
                     (LIST-SPEC::|!map|-1-1 #'(lambda (x) (svref x 2)) cases))) 
                (let ((pV15 (JGEN::liftCases oper caseBodys (svref pV19 1)))) 
                  (block 
                   nil 
                   (return 
                    (let ((newCases 
                           (LISTPAIR::|!map|-1-1 
                            #'(lambda (x) 
                               (let ((pV2 (car x))) 
                                 (block 
                                  nil 
                                  (return 
                                   (vector (svref pV2 0) (svref pV2 1) (cdr x))) 
                                  (error 
                                   "Nonexhaustive match failure in liftCaseCase")))) 
                            (cons cases (svref pV15 0))))) 
                      (let ((freeVarsCases 
                             (LIST-SPEC::foldr-1-1-1 
                              #'(lambda (x) 
                                 (LIST-SPEC::|!++| 
                                  (cdr x) 
                                  (UTILITIES::freeVarsMatch-1 (car x)))) 
                              nil 
                              newCases))) 
                        (let ((freeVars 
                               (MERGESORT::uniqueSort-1-1 
                                #'(lambda (x) 
                                   (block 
                                    nil 
                                    (return 
                                     (STRING-SPEC::compare 
                                      (car (car x)) 
                                      (car (cdr x)))) 
                                    (error 
                                     "Nonexhaustive match failure in liftCaseCase"))) 
                                freeVarsCases))) 
                          (let ((freeVarsSorts 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x) (cdr x)) 
                                  freeVars))) 
                            (let ((newOp (JGEN::mkNewOp oper k))) 
                              (let ((newOpSrt 
                                     (STANDARDSPEC::mkArrow 
                                      (STANDARDSPEC::mkProduct 
                                       (LIST-SPEC::|!cons| 
                                        caseTermSort 
                                        freeVarsSorts)) 
                                      ttermSort))) 
                                (let ((newVar 
                                       (JGEN::mkNewVar oper k caseTermSort))) 
                                  (let ((newOpTerm 
                                         (STANDARDSPEC::mkApply 
                                          (cons 
                                           :|Lambda| 
                                           (cons newCases POSITION-SPEC::noPos)) 
                                          (STANDARDSPEC::mkVar-1 newVar)))) 
                                    (let ((newOpDef 
                                           (vector 
                                            newOp 
                                            (LIST-SPEC::|!cons| 
                                             caseTermSort 
                                             freeVarsSorts) 
                                            ttermSort 
                                            (LIST-SPEC::|!cons| newVar freeVars) 
                                            newOpTerm))) 
                                      (let ((newTerm 
                                             (STANDARDSPEC::mkApplication 
                                              (STANDARDSPEC::mkOp newOp newOpSrt) 
                                              (LIST-SPEC::|!cons| 
                                               (svref pV19 0) 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'STANDARDSPEC::mkVar-1 
                                                freeVars))))) 
                                        (vector 
                                         newTerm 
                                         (svref pV15 1) 
                                         (LIST-SPEC::|!++| 
                                          (LIST-SPEC::|!++| 
                                           (svref pV19 2) 
                                           (svref pV15 2)) 
                                          (cons newOpDef nil)))))))))))))) 
                   (error "Nonexhaustive match failure in liftCaseCase")))))) 
           (error "Nonexhaustive match failure in liftCaseCase")))))))

(defun JGEN::liftCaseIfThenElse (pV15 pV16 pV17) 
  (block 
   nil 
   (if (eq (car pV16) :|IfThenElse|) 
       (let ((pV18 (cdr pV16))) 
         (return 
          (let ((pV2 
                 (JGEN::liftCases 
                  pV15 
                  (cons 
                   (svref pV18 0) 
                   (cons (svref pV18 1) (cons (svref pV18 2) nil))) 
                  pV17))) 
            (block 
             nil 
             (let ((pV3 (svref pV2 0))) 
               (if (consp pV3) 
                   (let ((pV8 (cdr pV3))) 
                     (if (consp pV8) 
                         (let ((pV11 (cdr pV8))) 
                           (if (consp pV11) 
                               (if (null (cdr pV11)) 
                                   (return 
                                    (vector 
                                     (STANDARDSPEC::mkIfThenElse 
                                      (car pV3) 
                                      (car pV8) 
                                      (car pV11)) 
                                     (svref pV2 1) 
                                     (svref pV2 2)))))))))) 
             (error "Nonexhaustive match failure in liftCaseIfThenElse")))))) 
   (error "Nonexhaustive match failure in liftCaseIfThenElse")))

(defun JGEN::liftCaseLet (pV24 pV25 pV26) 
  (block 
   nil 
   (if (eq (car pV25) :|Let|) 
       (let ((pV27 (cdr pV25))) 
         (let ((pV28 (svref pV27 0))) 
           (return 
            (block 
             nil 
             (if (consp pV28) 
                 (let ((pV17 (car pV28))) 
                   (let ((pV19 (car pV17))) 
                     (if (eq (car pV19) :|VarPat|) 
                         (if (null (cdr pV28)) 
                             (return 
                              (let ((pV3 
                                     (JGEN::liftCases 
                                      pV24 
                                      (cons (cdr pV17) (cons (svref pV27 1) nil)) 
                                      pV26))) 
                                (block 
                                 nil 
                                 (let ((pV4 (svref pV3 0))) 
                                   (if (consp pV4) 
                                       (let ((pV9 (cdr pV4))) 
                                         (if (consp pV9) 
                                             (if (null (cdr pV9)) 
                                                 (return 
                                                  (vector 
                                                   (STANDARDSPEC::mkLet 
                                                    (cons 
                                                     (cons 
                                                      (STANDARDSPEC::mkVarPat-1 
                                                       (car (cdr pV19))) 
                                                      (car pV4)) 
                                                     nil) 
                                                    (car pV9)) 
                                                   (svref pV3 1) 
                                                   (svref pV3 2)))))))) 
                                 (error 
                                  "Nonexhaustive match failure in liftCaseLet"))))))))) 
             (return (progn (JGEN::unSupported pV24) (vector pV25 pV26 nil)))))))) 
   (error "Nonexhaustive match failure in liftCaseLet")))

(defun JGEN::liftCaseRecord (pV11 pV12 pV13) 
  (block 
   nil 
   (if (eq (car pV12) :|Record|) 
       (let ((pV15 (car (cdr pV12)))) 
         (return 
          (let ((recordTerms (JGEN::recordFieldsToTerms pV15))) 
            (let ((pV7 (JGEN::liftCases pV11 recordTerms pV13))) 
              (block 
               nil 
               (return 
                (let ((newFields 
                       (LISTPAIR::|!map|-1-1 
                        #'(lambda (x) 
                           (block 
                            nil 
                            (return (cons (car (car x)) (cdr x))) 
                            (error 
                             "Nonexhaustive match failure in liftCaseRecord"))) 
                        (cons pV15 (svref pV7 0))))) 
                  (vector 
                   (STANDARDSPEC::mkRecord newFields) 
                   (svref pV7 1) 
                   (svref pV7 2)))) 
               (error "Nonexhaustive match failure in liftCaseRecord"))))))) 
   (error "Nonexhaustive match failure in liftCaseRecord")))

(defun JGEN::liftCase (oper term k) 
  (if (JGEN::caseTerm? term) 
      (JGEN::liftCaseCase oper term k) 
      (block 
       nil 
       (if (eq (car term) :|Var|) 
           (return (vector term k nil)) 
           (if (eq (car term) :|Fun|) 
               (return (vector term k nil)) 
               (if (eq (car term) :|Apply|) 
                   (return (JGEN::liftCaseApply oper term k)) 
                   (if (eq (car term) :|Record|) 
                       (return (JGEN::liftCaseRecord oper term k)) 
                       (if (eq (car term) :|IfThenElse|) 
                           (return (JGEN::liftCaseIfThenElse oper term k)) 
                           (if (eq (car term) :|Let|) 
                               (return (JGEN::liftCaseLet oper term k)))))))) 
       (return (progn (JGEN::unSupported oper) (vector term k nil))))))

(defun JGEN::liftCaseTopCase (oper body k) 
  (let ((caseTerm (JGEN::caseTerm body))) 
    (let ((cases (JGEN::caseCases body))) 
      (let ((caseBodys 
             (LIST-SPEC::|!map|-1-1 #'(lambda (x) (svref x 2)) cases))) 
        (let ((pV7 (JGEN::liftCases oper caseBodys k))) 
          (block 
           nil 
           (return 
            (let ((newCases 
                   (LISTPAIR::|!map|-1-1 
                    #'(lambda (x) 
                       (let ((pV2 (car x))) 
                         (block 
                          nil 
                          (return (vector (svref pV2 0) (svref pV2 1) (cdr x))) 
                          (error 
                           "Nonexhaustive match failure in liftCaseTopCase")))) 
                    (cons cases (svref pV7 0))))) 
              (let ((newTerm 
                     (STANDARDSPEC::mkApply 
                      (cons :|Lambda| (cons newCases POSITION-SPEC::noPos)) 
                      caseTerm))) (vector newTerm (svref pV7 1) (svref pV7 2))))) 
           (error "Nonexhaustive match failure in liftCaseTopCase")))))))

(defun JGEN::userVar?-1 (var) (BOOLEAN-SPEC::~ (JGEN::baseVar?-1 var)))

(defun JGEN::lift (pV30 pV31) 
  (block 
   nil 
   (let ((pV33 (cdr pV31))) 
     (return 
      (let ((firstUserVar (LIST-SPEC::|!find|-1-1 #'JGEN::userVar?-1 (car pV31)))) 
        (block 
         nil 
         (if (eq (car firstUserVar) :|Some|) 
             (return 
              (if (JGEN::caseTerm? pV33) 
                  (let ((pV15 (JGEN::caseTerm pV33))) 
                    (block 
                     nil 
                     (if (eq (car pV15) :|Var|) 
                         (return 
                          (if (METASLANG::equalVar? 
                               (car (cdr pV15)) 
                               (cdr firstUserVar)) 
                              (let ((pV2 (JGEN::liftCaseTopCase pV30 pV33 1))) 
                                (block 
                                 nil 
                                 (return (cons (svref pV2 0) (svref pV2 2))) 
                                 (error "Nonexhaustive match failure in lift"))) 
                              (let ((pV6 (JGEN::liftCase pV30 pV33 1))) 
                                (block 
                                 nil 
                                 (return (cons (svref pV6 0) (svref pV6 2))) 
                                 (error "Nonexhaustive match failure in lift")))))) 
                     (return 
                      (let ((pV11 (JGEN::liftCase pV30 pV33 1))) 
                        (block 
                         nil 
                         (return (cons (svref pV11 0) (svref pV11 2))) 
                         (error "Nonexhaustive match failure in lift")))))) 
                  (let ((pV19 (JGEN::liftCase pV30 pV33 1))) 
                    (block 
                     nil 
                     (return (cons (svref pV19 0) (svref pV19 2))) 
                     (error "Nonexhaustive match failure in lift")))))) 
         (return 
          (let ((pV24 (JGEN::liftCase pV30 pV33 1))) 
            (block 
             nil 
             (return (cons (svref pV24 0) (svref pV24 2))) 
             (error "Nonexhaustive match failure in lift")))))))) 
   (error "Nonexhaustive match failure in lift")))

(defun JGEN::lift-1 (x) (JGEN::lift (car x) (cdr x)))

(defun JGEN::liftCase-1 (x) 
  (JGEN::liftCase (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCaseApply-1 (x) 
  (JGEN::liftCaseApply (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCaseCase-1 (x) 
  (JGEN::liftCaseCase (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCaseIfThenElse-1 (x) 
  (JGEN::liftCaseIfThenElse (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCaseLet-1 (x) 
  (JGEN::liftCaseLet (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCaseRecord-1 (x) 
  (JGEN::liftCaseRecord (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCaseTopCase-1 (x) 
  (JGEN::liftCaseTopCase (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftCases-1 (x) 
  (JGEN::liftCases (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::liftPattern-1 (spc) 
  (let ((newOpDefs 
         (foldriAQualifierMap-1-1-1 
          #'(lambda (x) 
             (let ((pV13 (svref x 2))) 
               (block 
                nil 
                (let ((pV18 (svref pV13 3))) 
                  (let ((pV20 (cdr (svref pV13 2)))) 
                    (if (consp pV18) 
                        (if (null (cdr pV18)) 
                            (return 
                             (let ((origOp 
                                    (METASLANG::mkQualifiedId 
                                     (svref x 0) 
                                     (svref x 1)))) 
                               (let ((pV8 
                                      (JGEN::srtTermDelta pV20 (cdr (car pV18))))) 
                                 (block 
                                  nil 
                                  (let ((pV9 (car pV8))) 
                                    (return 
                                     (let ((pV5 
                                            (JGEN::lift 
                                             origOp 
                                             (cons pV9 (cdr pV8))))) 
                                       (block 
                                        nil 
                                        (let ((pV6 (car pV5))) 
                                          (return 
                                           (progn (JGEN::srtTermDelta pV20 pV6) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (let ((origOpNewDef 
                                                           (vector 
                                                            origOp 
                                                            (JGEN::srtDom pV20) 
                                                            (JGEN::srtRange pV20) 
                                                            pV9 
                                                            pV6))) 
                                                      (LIST-SPEC::|!cons| 
                                                       origOpNewDef 
                                                       (LIST-SPEC::|!++| 
                                                        (cdr pV5) 
                                                        (svref x 3))))) 
                                                   (error 
                                                    "Nonexhaustive match failure in liftPattern"))))) 
                                        (error 
                                         "Nonexhaustive match failure in liftPattern"))))) 
                                  (error 
                                   "Nonexhaustive match failure in liftPattern"))))))))) 
                (error "Nonexhaustive match failure in liftPattern")))) 
          nil 
          (svref spc 1)))) 
    (let ((result (setSorts emptySpec (svref spc 3)))) 
      (let ((result 
             (LIST-SPEC::foldr-1-1-1 #'JGEN::addOdToSpec-1 result newOpDefs))) 
        result))))

(defun JGEN::liftPattern (x0 x1 x2 x3) 
  (JGEN::liftPattern-1 (vector x0 x1 x2 x3)))

(defun JGEN::localHandler-1-1 (x1 x2) (funcall (JGEN::localHandler x1) x2))

(defun JGEN::mkBinExp-1 (x) (JGEN::mkBinExp (car x) (cdr x)))

(defun JGEN::mkFldAcc-1 (x) (JGEN::mkFldAcc (car x) (cdr x)))

(defun JGEN::mkIfStmt-1 (x) 
  (JGEN::mkIfStmt (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::mkJavaEq-1 (x) 
  (JGEN::mkJavaEq (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::mkMethExprInv-1 (x) 
  (JGEN::mkMethExprInv (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::mkMethInv-1 (x) 
  (JGEN::mkMethInv (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::mkNameAssn-1 (x) (JGEN::mkNameAssn (car x) (cdr x)))

(defun JGEN::mkNewClasInst-1 (x) (JGEN::mkNewClasInst (car x) (cdr x)))

(defun JGEN::mkNewId-1 (x) (JGEN::mkNewId (car x) (cdr x)))

(defun JGEN::mkNewOp-1 (x) (JGEN::mkNewOp (car x) (cdr x)))

(defun JGEN::mkNewVar-1 (x) 
  (JGEN::mkNewVar (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::mkNonCaseMethodBody-1 (x) 
  (JGEN::mkNonCaseMethodBody (car x) (cdr x)))

(defun JGEN::mkProdConstrDecl-1 (x) (JGEN::mkProdConstrDecl (car x) (cdr x)))

(defun JGEN::mkProductTypeClsDecl-1 (x) 
  (JGEN::mkProductTypeClsDecl (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JGEN::mkQualJavaExpr-1 (x) (JGEN::mkQualJavaExpr (car x) (cdr x)))

(defun JGEN::mkSumConstrDecl-1 (x) (JGEN::mkSumConstrDecl (car x) (cdr x)))

(defun JGEN::mkSumConstructBody-1 (x) 
  (JGEN::mkSumConstructBody (car x) (cdr x)))

(defun JGEN::mkSumEqMethBody-1 (x) (JGEN::mkSumEqMethBody (car x) (cdr x)))

(defun JGEN::mkSummandId-1 (x) (JGEN::mkSummandId (car x) (cdr x)))

(defun JGEN::mkUnExp-1 (x) (JGEN::mkUnExp (car x) (cdr x)))

(defun JGEN::mkVarAssn-1 (x) (JGEN::mkVarAssn (car x) (cdr x)))

(defun JGEN::mkVarDecl-1 (x) (JGEN::mkVarDecl (car x) (cdr x)))

(defun JGEN::mkVarInit-1 (x) 
  (JGEN::mkVarInit (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::modifyClsDeclsFromOp (pV38 pV39 pV40 pV41 pV42) 
  (declare (ignore pV39)) 
  (block 
   nil 
   (let ((pV46 (svref pV41 3))) 
     (let ((pV48 (cdr (svref pV41 2)))) 
       (if (consp pV46) 
           (let ((pV53 (cdr (car pV46)))) 
             (if (null (cdr pV46)) 
                 (return 
                  (block 
                   nil 
                   (if (eq (car pV48) :|Arrow|) 
                       (return 
                        (JGEN::addMethodFromOpToClsDecls 
                         pV38 
                         pV40 
                         pV48 
                         pV53 
                         pV42))) 
                   (return 
                    (if (JGEN::baseType? pV48) 
                        (let ((pV13 (JGEN::srtTermDelta pV48 pV53))) 
                          (block 
                           nil 
                           (return 
                            (let ((pV9 
                                   (JGEN::termToExpression 
                                    STRINGMAP::empty 
                                    (cdr pV13) 
                                    1))) 
                              (block 
                               nil 
                               (return 
                                (let ((fldDecl 
                                       (vector 
                                        (cons '(:|Static|) nil) 
                                        (JGEN::baseSrtToJavaType pV48) 
                                        (cons 
                                         (cons pV40 0) 
                                         (cons 
                                          :|Some| 
                                          (cons :|Expr| (svref pV9 1)))) 
                                        nil))) 
                                  (let ((newClsDecls 
                                         (JGEN::addFldDeclToClsDecls 
                                          "Primitive" 
                                          fldDecl 
                                          pV42))) newClsDecls))) 
                               (error 
                                "Nonexhaustive match failure in modifyClsDeclsFromOp")))) 
                           (error 
                            "Nonexhaustive match failure in modifyClsDeclsFromOp"))) 
                        (block 
                         nil 
                         (if (eq (car pV48) :|Base|) 
                             (let ((pV30 (svref (cdr pV48) 0))) 
                               (if (eq (car pV30) :|Qualified|) 
                                   (let ((pV35 (cdr (cdr pV30)))) 
                                     (return 
                                      (let ((pV25 (JGEN::srtTermDelta pV48 pV53))) 
                                        (block 
                                         nil 
                                         (return 
                                          (let ((pV21 
                                                 (JGEN::termToExpression 
                                                  STRINGMAP::empty 
                                                  (cdr pV25) 
                                                  1))) 
                                            (block 
                                             nil 
                                             (return 
                                              (let ((fldDecl 
                                                     (vector 
                                                      (cons '(:|Static|) nil) 
                                                      (JGEN::tt pV35) 
                                                      (cons 
                                                       (cons pV40 0) 
                                                       (cons 
                                                        :|Some| 
                                                        (cons 
                                                         :|Expr| 
                                                         (svref pV21 1)))) 
                                                      nil))) 
                                                (let ((newClsDecls 
                                                       (JGEN::addFldDeclToClsDecls 
                                                        pV35 
                                                        fldDecl 
                                                        pV42))) newClsDecls))) 
                                             (error 
                                              "Nonexhaustive match failure in modifyClsDeclsFromOp")))) 
                                         (error 
                                          "Nonexhaustive match failure in modifyClsDeclsFromOp")))))))) 
                         (error 
                          "Nonexhaustive match failure in modifyClsDeclsFromOp"))))))))))) 
   (error "Nonexhaustive match failure in modifyClsDeclsFromOp")))

(defun JGEN::modifyClsDeclsFromOp-1 (x) 
  (JGEN::modifyClsDeclsFromOp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JGEN::modifyClsDeclsFromOps (spc clsDecls) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((newClsDecls 
             (JGEN::modifyClsDeclsFromOp 
              spc 
              (svref x 0) 
              (svref x 1) 
              (svref x 2) 
              (svref x 3)))) newClsDecls)) 
   clsDecls 
   (svref spc 1)))

(defun JGEN::modifyClsDeclsFromOps-1 (x) 
  (JGEN::modifyClsDeclsFromOps (car x) (cdr x)))

(defun JGEN::opDom (spc oper) 
  (let ((opinfo (STANDARDSPEC::findTheOp spc oper))) 
    (block 
     nil 
     (if (eq (car opinfo) :|Some|) 
         (return (JGEN::srtDom (cdr (svref (cdr opinfo) 2))))) 
     (return (progn (JGEN::unSupported oper) nil)))))

(defun JGEN::opRange (spc oper) 
  (let ((opinfo (STANDARDSPEC::findTheOp spc oper))) 
    (block 
     nil 
     (if (eq (car opinfo) :|Some|) 
         (return (JGEN::srtRange (cdr (svref (cdr opinfo) 2))))) 
     (return (progn (JGEN::unSupported oper) STANDARDSPEC::boolSort)))))

(defun STANDARDSPEC::mkFalse () 
  (STANDARDSPEC::mkFun (cons :|Bool| nil) STANDARDSPEC::boolSort))

(defun JGEN::opDelta (spc oper) 
  (let ((opDom (JGEN::opDom spc oper))) 
    (progn (JGEN::opRange spc oper) 
           (let ((opinfo (STANDARDSPEC::findTheOp spc oper))) 
             (block 
              nil 
              (if (eq (car opinfo) :|Some|) 
                  (let ((pV29 (svref (cdr opinfo) 3))) 
                    (if (consp pV29) 
                        (let ((pV34 (cdr (car pV29)))) 
                          (if (null (cdr pV29)) 
                              (return 
                               (block 
                                nil 
                                (if (eq (car pV34) :|Lambda|) 
                                    (let ((pV14 (car (cdr pV34)))) 
                                      (if (consp pV14) 
                                          (let ((pV17 (car pV14))) 
                                            (if (null (cdr pV14)) 
                                                (return 
                                                 (let ((argNames 
                                                        (JGEN::patternNamesOpt 
                                                         (svref pV17 0)))) 
                                                   (block 
                                                    nil 
                                                    (if (eq 
                                                         (car argNames) 
                                                         :|Some|) 
                                                        (let ((pV10 
                                                               (cdr argNames))) 
                                                          (return 
                                                           (let ((|!numArgs| 
                                                                  (LIST-SPEC::|!length| 
                                                                   pV10))) 
                                                             (let ((arity 
                                                                    (LIST-SPEC::|!length| 
                                                                     opDom))) 
                                                               (if ( =  
                                                                    arity 
                                                                    |!numArgs|) 
                                                                   (let ((newArgs 
                                                                          (LISTPAIR::|!map|-1-1 
                                                                           #'(lambda (x) 
                                                                              (cons 
                                                                               (car 
                                                                                x) 
                                                                               (cdr 
                                                                                x))) 
                                                                           (cons 
                                                                            pV10 
                                                                            opDom)))) 
                                                                     (cons 
                                                                      newArgs 
                                                                      (svref 
                                                                       pV17 
                                                                       2))) 
                                                                   (progn (JGEN::unSupported 
                                                                           oper) 
                                                                          (cons 
                                                                           nil 
                                                                           (STANDARDSPEC::mkFalse))))))))) 
                                                    (return 
                                                     (progn (JGEN::unSupported 
                                                             oper) 
                                                            (cons 
                                                             nil 
                                                             (STANDARDSPEC::mkFalse)))))))))))) 
                                (return (cons nil pV34))))))))) 
              (return 
               (progn (JGEN::unSupported oper) 
                      (cons nil (STANDARDSPEC::mkFalse)))))))))

(defun JGEN::opDelta-1 (x) (JGEN::opDelta (car x) (cdr x)))

(defun JGEN::opDom-1 (x) (JGEN::opDom (car x) (cdr x)))

(defun JGEN::opRange-1 (x) (JGEN::opRange (car x) (cdr x)))

(defun JGEN::optAddOp-1 (x) 
  (JGEN::optAddOp (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JGEN::optAddOp-1-1 (x1 x2) (funcall (JGEN::optAddOp-1 x1) x2))

(defun JGEN::productToClsDecl-1 (x) (JGEN::productToClsDecl (car x) (cdr x)))

(defun JGEN::renameVar-1 (x) 
  (JGEN::renameVar (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::renameVarApply-1 (x) 
  (JGEN::renameVarApply (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::renameVarMatch (pV1 pV2 pV3) 
  (block 
   nil 
   (let ((pV6 (svref pV1 2))
         (pV5 (svref pV1 1))
         (pV4 (svref pV1 0))) 
     (return 
      (let ((boundVars (UTILITIES::patVars pV4))) 
        (labels 
          ((newBody (patBody) 
            (if (LIST-SPEC::|!exists|-1-1 
                 #'(lambda (var) (METASLANG::equalVar? var pV2)) 
                 boundVars) 
                patBody 
                (JGEN::renameVar patBody pV2 pV3)))) 
          (let ((newCaseBody (newBody pV6))) 
            (let ((newCond (newBody pV5))) (vector pV4 newCond newCaseBody))))))) 
   (error "Nonexhaustive match failure in renameVarMatch")))

(defun JGEN::renameVarCase (term oldV newV) 
  (let ((caseTerm (JGEN::caseTerm term))) 
    (let ((newCaseTerm (JGEN::renameVar caseTerm oldV newV))) 
      (let ((cases (JGEN::caseCases term))) 
        (let ((newCases 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (match) (JGEN::renameVarMatch match oldV newV)) 
                cases))) 
          (let ((newTerm 
                 (STANDARDSPEC::mkApply 
                  (cons :|Lambda| (cons newCases POSITION-SPEC::noPos)) 
                  newCaseTerm))) newTerm))))))

(defun JGEN::renameVarCase-1 (x) 
  (JGEN::renameVarCase (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::renameVarIfThenElse-1 (x) 
  (JGEN::renameVarIfThenElse (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::renameVarLet-1 (x) 
  (JGEN::renameVarLet (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::renameVarLetNewVar-1 (x) 
  (JGEN::renameVarLetNewVar (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JGEN::renameVarLetOldVar-1 (x) 
  (JGEN::renameVarLetOldVar (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JGEN::renameVarMatch-1 (x) 
  (JGEN::renameVarMatch (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::renameVarRecord-1 (x) 
  (JGEN::renameVarRecord (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::setConstrs-1 (x) (JGEN::setConstrs (car x) (cdr x)))

(defun JGEN::setFlds-1 (x) (JGEN::setFlds (car x) (cdr x)))

(defun JGEN::setMethodBody-1 (x) (JGEN::setMethodBody (car x) (cdr x)))

(defun JGEN::setMethods-1 (x) (JGEN::setMethods (car x) (cdr x)))

(defun JGEN::sortToClsDecls-1 (x) 
  (JGEN::sortToClsDecls (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::specToJava-1 (spc) 
  (progn (STRING-SPEC::writeLine "Lifting Patterns") 
         (let ((spc (JGEN::liftPattern-1 spc))) 
           (progn (STRING-SPEC::writeLine "Renaming Variables") 
                  (let ((spc (JGEN::distinctVariable-1 spc))) 
                    (progn (STRING-SPEC::writeLine "Generating Classes") 
                           (let ((clsDecls (JGEN::clsDeclsFromSorts-1 spc))) 
                             (progn (STRING-SPEC::writeLine "Adding Bodies") 
                                    (let ((clsDecls 
                                           (JGEN::modifyClsDeclsFromOps 
                                            spc 
                                            clsDecls))) 
                                      (progn (STRING-SPEC::writeLine 
                                              "Ready to Write") 
                                             (let ((clsOrInterfDecls 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'(lambda (cd) 
                                                        (cons 
                                                         :|ClsDecl| 
                                                         (vector 
                                                          (svref cd 0) 
                                                          (svref cd 1) 
                                                          (svref cd 2)))) 
                                                     clsDecls))) 
                                               (vector 
                                                '(:|None|) 
                                                nil 
                                                clsOrInterfDecls))))))))))))

(defun JGEN::specToJava (x0 x1 x2 x3) (JGEN::specToJava-1 (vector x0 x1 x2 x3)))

(defun JGEN::srtTermDelta-1 (x) (JGEN::srtTermDelta (car x) (cdr x)))

(defun JGEN::sumArgToClsDecl (ty c) 
  (let ((summandId (JGEN::mkSummandId ty c))) 
    (vector 
     nil 
     (vector summandId (cons :|Some| (cons nil ty)) nil) 
     JGEN::emptyClsBody)))

(defun JGEN::sumArgToClsDecl-1 (x) (JGEN::sumArgToClsDecl (car x) (cdr x)))

(defun JGEN::sumToClsDecl-1 (x) 
  (JGEN::sumToClsDecl (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::sumToConsMethodDecl-1 (x) 
  (JGEN::sumToConsMethodDecl (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::sumTypeToClsDecl-1 (x) (JGEN::sumTypeToClsDecl (car x) (cdr x)))

(defun JGEN::termToExpression-1 (x) 
  (JGEN::termToExpression (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::translateApplyToExpr-1 (x) 
  (JGEN::translateApplyToExpr (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::translateBaseApplToExpr-1 (x) 
  (JGEN::translateBaseApplToExpr (svref x 0) (svref x 1) (svref x 2) (svref x 3)))


(defun JGEN::translateBaseArgsApplToExpr-1 (x) 
  (JGEN::translateBaseArgsApplToExpr 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JGEN::translateConstructToExpr-1 (x) 
  (JGEN::translateConstructToExpr 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JGEN::translateEqualsToExpr-1 (x) 
  (JGEN::translateEqualsToExpr (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::translateIfThenElseToExpr-1 (x) 
  (JGEN::translateIfThenElseToExpr (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::translateLetToExpr-1 (x) 
  (JGEN::translateLetToExpr (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::translateProjectToExpr-1 (x) 
  (JGEN::translateProjectToExpr (svref x 0) (svref x 1) (svref x 2) (svref x 3)))


(defun JGEN::translateRecordToExpr-1 (x) 
  (JGEN::translateRecordToExpr (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::translateTermsToExpressions-1 (x) 
  (JGEN::translateTermsToExpressions (svref x 0) (svref x 1) (svref x 2)))

(defun JGEN::translateUserApplToExpr-1 (x) 
  (JGEN::translateUserApplToExpr 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JGEN::userVar? (x0 x1) (JGEN::userVar?-1 (cons x0 x1)))

(defun JGEN::varToFormalParam (x0 x1) (JGEN::varToFormalParam-1 (cons x0 x1)))

(defun JAVA::toPretty (x) (PRETTYPRINT::|!string| x))

(defun JAVA::addCommentLine (comment ps) 
  (if (string=  comment "") ps (LIST-SPEC::|!cons| (JAVA::toPretty comment) ps)))


(defun JAVA::addCommentLine-1 (x) (JAVA::addCommentLine (car x) (cdr x)))

(defun JAVA::addEmpty (ps) 
  (if (slang-built-in::slang-term-equals ps nil) 
      nil 
      (LIST-SPEC::|!cons| (PRETTYPRINT::emptyPretty) ps)))

(defun JAVA::addPrettys (ps p) 
  (block 
   nil 
   (if (null ps) 
       (return ps) 
       (if (consp ps) 
           (let ((pV4 (cdr ps))) 
             (if (null pV4) 
                 (return ps) 
                 (if (consp pV4) 
                     (return 
                      (LIST-SPEC::|!cons| 
                       (car ps) 
                       (LIST-SPEC::|!cons| 
                        p 
                        (JAVA::addPrettys 
                         (LIST-SPEC::|!cons| (car pV4) (cdr pV4)) 
                         p))))))))) 
   (error "Nonexhaustive match failure in addPrettys")))

(defun JAVA::addEmptys (ps) (JAVA::addPrettys ps (PRETTYPRINT::emptyPretty)))

(defun JAVA::addPrettys-1 (x) (JAVA::addPrettys (car x) (cdr x)))

(defun JAVA::assOpToString (o) 
  (block 
   nil 
   (if (eq (car o) :|Assgn|) 
       (return " = ") 
       (if (eq (car o) :|Mul|) 
           (return "* = ") 
           (if (eq (car o) :|Div|) 
               (return "/ = ") 
               (if (eq (car o) :|Rem|) 
                   (return "% = ") 
                   (if (eq (car o) :|Plus|) 
                       (return "+ = ") 
                       (if (eq (car o) :|Minus|) 
                           (return "- = ") 
                           (if (eq (car o) :|LShift|) 
                               (return "<<= ") 
                               (if (eq (car o) :|RShift|) 
                                   (return ">>= ") 
                                   (if (eq (car o) :|LShiftSpec|) 
                                       (return ">>>= ") 
                                       (if (eq (car o) :|BitAnd|) 
                                           (return "& = ") 
                                           (if (eq (car o) :|BitExclOr|) 
                                               (return "^ = ") 
                                               (if (eq (car o) :|BitInclOr|) 
                                                   (return "| = "))))))))))))) 
   (error "Nonexhaustive match failure in assOpToString")))

(defun JAVA::binOpToString (o) 
  (block 
   nil 
   (if (eq (car o) :|CdAnd|) 
       (return "&&") 
       (if (eq (car o) :|CdOr|) 
           (return "||") 
           (if (eq (car o) :|InclOr|) 
               (return "|") 
               (if (eq (car o) :|ExclOr|) 
                   (return "^") 
                   (if (eq (car o) :|And|) 
                       (return "&") 
                       (if (eq (car o) :|Eq|) 
                           (return " == ") 
                           (if (eq (car o) :|NotEq|) 
                               (return "! = ") 
                               (if (eq (car o) :|Gt|) 
                                   (return ">") 
                                   (if (eq (car o) :|Lt|) 
                                       (return "<") 
                                       (if (eq (car o) :|Ge|) 
                                           (return ">= ") 
                                           (if (eq (car o) :|Le|) 
                                               (return "<= ") 
                                               (if (eq (car o) :|LShft|) 
                                                   (return "<<") 
                                                   (if (eq (car o) :|RShft|) 
                                                       (return ">>") 
                                                       (if (eq 
                                                            (car o) 
                                                            :|RShftSp|) 
                                                           (return ">>>") 
                                                           (if (eq 
                                                                (car o) 
                                                                :|Plus|) 
                                                               (return "+") 
                                                               (if (eq 
                                                                    (car o) 
                                                                    :|Minus|) 
                                                                   (return "-") 
                                                                   (if (eq 
                                                                        (car o) 
                                                                        :|Mul|) 
                                                                       (return 
                                                                        "*") 
                                                                       (if (eq 
                                                                            (car 
                                                                             o) 
                                                                            :|Div|) 
                                                                           (return 
                                                                            "/") 
                                                                           (if (eq 
                                                                                (car 
                                                                                 o) 
                                                                                :|Rem|) 
                                                                               (return 
                                                                                "%")))))))))))))))))))) 
   (error "Nonexhaustive match failure in binOpToString")))

(defun JAVA::clsDecl1 () 
  (vector 
   (cons :|Some| (cons (cons "kestrel" nil) "zhenyu")) 
   (cons 
    (cons (cons "java" (cons "lang" nil)) "*") 
    (cons (cons (cons "java" (cons "swing" nil)) "xyz") nil)) 
   (cons 
    (cons 
     :|ClsDecl| 
     (vector 
      (cons '(:|Public|) nil) 
      (vector 
       "MyClass" 
       (cons :|Some| (cons nil "SuperClass")) 
       (cons (cons nil "SuperI1") (cons (cons nil "SuperI2") nil))) 
      (vector 
       nil 
       nil 
       (cons 
        (vector 
         (cons '(:|Private|) nil) 
         (cons (cons :|Basic| '(:|JInt|)) 2) 
         (cons (cons "xx" 0) '(:|None|)) 
         (cons 
          (cons 
           (cons "yy" 2) 
           (cons 
            :|Some| 
            (cons :|ArrInit| (cons '(:|None|) (cons '(:|None|) nil))))) 
          nil)) 
        nil) 
       nil 
       (cons 
        (cons 
         (vector 
          (cons '(:|Static|) (cons '(:|Public|) nil)) 
          '(:|None|) 
          "mm" 
          (cons 
           (vector t (cons (cons :|Name| (cons nil "String")) 1) (cons "p" 2)) 
           (cons 
            (vector nil (cons (cons :|Basic| '(:|JBool|)) 0) (cons "b" 0)) 
            nil)) 
          (cons (cons nil "Exception") nil)) 
         '(:|None|)) 
        nil) 
       nil))) 
    nil)))

(defun JAVA::clsDecl1-1 (ignore) (declare (ignore ignore)) 
                                 (JAVA::clsDecl1))

(defun JAVA::concatList (sl) 
  (LIST-SPEC::foldr-1-1-1 #'STRING-SPEC::concat-1 "" sl))

(defun JAVA::emptyBrackets (n) 
  (if (INTEGER-SPEC::|!<=| n 0) 
      (PRETTYPRINT::emptyPretty) 
      (PRETTYPRINT::prettysNone 
       (cons 
        (JAVA::toPretty "[]") 
        (cons (JAVA::emptyBrackets (INTEGER-SPEC::|!-| n 1)) nil)))))

(defun JAVA::isEmptyClsBody-1 (cb) 
  (cl:and 
   (LIST-SPEC::|!null| (svref cb 5)) 
   (cl:and 
    (LIST-SPEC::|!null| (svref cb 2)) 
    (cl:and 
     (LIST-SPEC::|!null| (svref cb 1)) 
     (cl:and 
      (LIST-SPEC::|!null| (svref cb 4)) 
      (cl:and 
       (LIST-SPEC::|!null| (svref cb 0)) 
       (LIST-SPEC::|!null| (svref cb 3))))))))

(defun JAVA::isEmptyClsBody (x0 x1 x2 x3 x4 x5) 
  (JAVA::isEmptyClsBody-1 (vector x0 x1 x2 x3 x4 x5)))

(defun JAVA::isEmptyInterfBody-1 (ib) 
  (cl:and 
   (LIST-SPEC::|!null| (svref ib 1)) 
   (cl:and 
    (LIST-SPEC::|!null| (svref ib 3)) 
    (cl:and (LIST-SPEC::|!null| (svref ib 0)) (LIST-SPEC::|!null| (svref ib 2))))))


(defun JAVA::isEmptyInterfBody (x0 x1 x2 x3) 
  (JAVA::isEmptyInterfBody-1 (vector x0 x1 x2 x3)))

(defun JAVA::itfDecl1 () 
  (vector 
   (cons :|Some| (cons (cons "kestrel" nil) "zhenyu")) 
   nil 
   (cons 
    (cons 
     :|InterfDecl| 
     (vector 
      (cons '(:|Public|) nil) 
      (cons 
       "MyClass" 
       (cons (cons nil "SuperI1") (cons (cons nil "SuperI2") nil))) 
      (vector nil nil nil nil))) 
    nil)))

(defun JAVA::itfDecl1-1 (ignore) (declare (ignore ignore)) 
                                 (JAVA::itfDecl1))

(defun JAVA::mkArrAccPr (aac) (cons :|ArrAcc| aac))

(defun JAVA::mkBoolPr (b) (cons :|Bool| b))

(defun JAVA::mkCharPr (c) (cons :|Char| c))

(defun JAVA::mkClsInstPr (oty) (cons :|ClsInst| oty))

(defun JAVA::mkFldAccPr (fac) (cons :|FldAcc| fac))

(defun JAVA::mkFloatPr (i j) (cons :|Float| (cons i j)))

(defun JAVA::mkFloatPr-1 (x) (JAVA::mkFloatPr (car x) (cdr x)))

(defun JAVA::mkForClsNCI (nm args cbd) (cons :|ForCls| (vector nm args cbd)))

(defun JAVA::mkForClsNCI-1 (x) 
  (JAVA::mkForClsNCI (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::mkForInnClsNCI (pm id args cbd) 
  (cons :|ForInnCls| (vector pm id args cbd)))

(defun JAVA::mkForInnClsNCI-1 (x) 
  (JAVA::mkForInnClsNCI (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JAVA::mkIntLPr (i) (cons :|IntL| i))

(defun JAVA::mkMethInvPr (mi) (cons :|MethInv| mi))

(defun JAVA::mkNamePr-1 (nm) (cons :|Name| (cons (car nm) (cdr nm))))

(defun JAVA::mkNamePr (x0 x1) (JAVA::mkNamePr-1 (cons x0 x1)))

(defun JAVA::mkNewArrPr (na) (cons :|NewArr| na))

(defun JAVA::mkNewClsInstPr (nci) (cons :|NewClsInst| nci))

(defun JAVA::mkNullPr () '(:|Null|))

(defun JAVA::mkNullPr-1 (ignore) (declare (ignore ignore)) 
                                 (JAVA::mkNullPr))

(defun JAVA::mkParenPr (e) (cons :|Paren| e))

(defun JAVA::mkStringPr (s) (cons :|String| s))

(defun JAVA::mkThisPr (onm) (cons :|This| onm))

(defun JAVA::mkViaClsFA (nm id) (cons :|ViaCls| (cons nm id)))

(defun JAVA::mkViaClsFA-1 (x) (JAVA::mkViaClsFA (car x) (cdr x)))

(defun JAVA::mkViaClsSuperMI (nm id args) 
  (cons :|ViaClsSuper| (vector nm id args)))

(defun JAVA::mkViaClsSuperMI-1 (x) 
  (JAVA::mkViaClsSuperMI (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::mkViaNameMI (nm args) (cons :|ViaName| (cons nm args)))

(defun JAVA::mkViaNameMI-1 (x) (JAVA::mkViaNameMI (car x) (cdr x)))

(defun JAVA::mkViaPrimFA (pm id) (cons :|ViaPrim| (cons pm id)))

(defun JAVA::mkViaPrimFA-1 (x) (JAVA::mkViaPrimFA (car x) (cdr x)))

(defun JAVA::mkViaPrimMI (pm id args) (cons :|ViaPrim| (vector pm id args)))

(defun JAVA::mkViaPrimMI-1 (x) 
  (JAVA::mkViaPrimMI (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::mkViaSuperFA (id) (cons :|ViaSuper| id))

(defun JAVA::mkViaSuperMI (id args) (cons :|ViaSuper| (cons id args)))

(defun JAVA::mkViaSuperMI-1 (x) (JAVA::mkViaSuperMI (car x) (cdr x)))

(defun JAVA::postUnOpToString (o) 
  (block 
   nil 
   (if (eq (car o) :|PostInc|) 
       (return "++") 
       (if (eq (car o) :|PostDec|) (return "--"))) 
   (error "Nonexhaustive match failure in postUnOpToString")))

(defun JAVA::ppAssOp (o) (JAVA::toPretty (JAVA::assOpToString o)))

(defun JAVA::qualName (ids id) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (let ((y (cdr x))
            (x1 (car x))) 
        (if (string=  x1 "") 
            y 
            (if (string=  y "") 
                x1 
                (JAVA::concatList (cons x1 (cons "." (cons y nil)))))))) 
   "" 
   (LIST-SPEC::concat ids (cons id nil))))

(defun JAVA::ppName (ids id) (JAVA::toPretty (JAVA::qualName ids id)))

(defun JAVA::ppName-1 (x) (JAVA::ppName (car x) (cdr x)))

(defun JAVA::ppMethInv (mi) 
  (labels 
    ((ppArgs (es) 
      (PRETTYPRINT::prettysNone 
       (LIST-SPEC::flatten 
        (cons 
         (cons (JAVA::toPretty "(") nil) 
         (cons 
          (JAVA::addPrettys 
           (LIST-SPEC::|!map|-1-1 #'JAVA::ppExpr es) 
           (JAVA::toPretty ",")) 
          (cons (cons (JAVA::toPretty ")") nil) nil))))))) 
    (block 
     nil 
     (if (eq (car mi) :|ViaName|) 
         (let ((pV5 (cdr mi))) 
           (return 
            (PRETTYPRINT::prettysNone 
             (cons (JAVA::ppName-1 (car pV5)) (cons (ppArgs (cdr pV5)) nil))))) 
         (if (eq (car mi) :|ViaPrim|) 
             (let ((pV4 (cdr mi))) 
               (return 
                (PRETTYPRINT::prettysNone 
                 (cons 
                  (JAVA::ppPrim (svref pV4 0)) 
                  (cons 
                   (JAVA::toPretty ".") 
                   (cons 
                    (JAVA::toPretty (svref pV4 1)) 
                    (cons (ppArgs (svref pV4 2)) nil))))))) 
             (if (eq (car mi) :|ViaSuper|) 
                 (let ((pV3 (cdr mi))) 
                   (return 
                    (PRETTYPRINT::prettysNone 
                     (cons 
                      (JAVA::toPretty "super.") 
                      (cons 
                       (JAVA::toPretty (car pV3)) 
                       (cons (ppArgs (cdr pV3)) nil)))))) 
                 (if (eq (car mi) :|ViaClsSuper|) 
                     (let ((pV2 (cdr mi))) 
                       (return 
                        (PRETTYPRINT::prettysNone 
                         (cons 
                          (JAVA::ppName-1 (svref pV2 0)) 
                          (cons 
                           (JAVA::toPretty ".super.") 
                           (cons 
                            (JAVA::toPretty (svref pV2 1)) 
                            (cons (ppArgs (svref pV2 2)) nil))))))))))) 
     (error "Nonexhaustive match failure in ppMethInv"))))

(defun JAVA::ppVarInit (vin) 
  (block 
   nil 
   (if (eq (car vin) :|Expr|) 
       (return (JAVA::ppExpr (cdr vin))) 
       (if (eq (car vin) :|ArrInit|) 
           (return 
            (PRETTYPRINT::prettysNone 
             (cons 
              (JAVA::toPretty "{") 
              (cons (JAVA::ppArrInit (cdr vin)) (cons (JAVA::toPretty "}") nil))))))) 
   (error "Nonexhaustive match failure in ppVarInit")))

(defun JAVA::ppOptVarInit (oai) 
  (block 
   nil 
   (if (eq (car oai) :|None|) 
       (return (PRETTYPRINT::emptyPretty)) 
       (if (eq (car oai) :|Some|) (return (JAVA::ppVarInit (cdr oai))))) 
   (error "Nonexhaustive match failure in ppOptVarInit")))

(defun JAVA::ppArrInit (ais) 
  (PRETTYPRINT::prettysNone 
   (JAVA::addPrettys 
    (LIST-SPEC::|!map|-1-1 #'JAVA::ppOptVarInit ais) 
    (JAVA::toPretty ", "))))

(defun JAVA::ppNewArr (nw) 
  (block 
   nil 
   (if (eq (car nw) :|Arr|) 
       (let ((pV3 (cdr nw))) 
         (return 
          (PRETTYPRINT::prettysNone 
           (cons 
            (JAVA::toPretty "new ") 
            (cons 
             (JAVA::ppName-1 (svref pV3 0)) 
             (cons 
              (PRETTYPRINT::prettysNone 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (e) 
                   (PRETTYPRINT::prettysNone 
                    (cons 
                     (JAVA::toPretty "[") 
                     (cons (JAVA::ppExpr e) (cons (JAVA::toPretty "]") nil))))) 
                (svref pV3 1))) 
              (cons (JAVA::emptyBrackets (svref pV3 2)) nil))))))) 
       (if (eq (car nw) :|ArrWInit|) 
           (let ((pV2 (cdr nw))) 
             (return 
              (PRETTYPRINT::prettysNone 
               (cons 
                (JAVA::toPretty "new ") 
                (cons 
                 (JAVA::ppName-1 (svref pV2 0)) 
                 (cons 
                  (JAVA::emptyBrackets (svref pV2 1)) 
                  (cons (JAVA::ppArrInit (svref pV2 2)) nil))))))))) 
   (error "Nonexhaustive match failure in ppNewArr")))

(defun JAVA::ppSuperCls (sc) 
  (block 
   nil 
   (if (eq (car sc) :|None|) 
       (return (PRETTYPRINT::emptyPretty)) 
       (if (eq (car sc) :|Some|) (return (JAVA::ppName-1 (cdr sc))))) 
   (error "Nonexhaustive match failure in ppSuperCls")))

(defun JAVA::ppSuperInterf (sis) 
  (if (slang-built-in::slang-term-equals sis nil) 
      (PRETTYPRINT::emptyPretty) 
      (PRETTYPRINT::prettysNone 
       (JAVA::addPrettys 
        (LIST-SPEC::|!map|-1-1 #'JAVA::ppName-1 sis) 
        (JAVA::toPretty ", ")))))

(defun JAVA::ppClsHeader (id sc sis) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::toPretty "class ") 
    (cons 
     (JAVA::toPretty id) 
     (cons 
      (JAVA::toPretty 
       (if (slang-built-in::slang-term-equals sc '(:|None|)) "" " extends ")) 
      (cons 
       (JAVA::ppSuperCls sc) 
       (cons 
        (JAVA::toPretty 
         (if (slang-built-in::slang-term-equals sis nil) "" " implements ")) 
        (cons (JAVA::ppSuperInterf sis) nil))))))))

(defun JAVA::ppClsHeader-1 (x) 
  (JAVA::ppClsHeader (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::ppMods (|!ms|) 
  (let ((ps 
         (LIST-SPEC::|!map|-1-1 
          #'(lambda (n) 
             (JAVA::toPretty 
              (block 
               nil 
               (if (eq (car n) :|Public|) 
                   (return "public ") 
                   (if (eq (car n) :|Protected|) 
                       (return "protected ") 
                       (if (eq (car n) :|Private|) 
                           (return "private ") 
                           (if (eq (car n) :|Static|) 
                               (return "static ") 
                               (if (eq (car n) :|Abstract|) 
                                   (return "abstract ") 
                                   (if (eq (car n) :|Final|) 
                                       (return "final ") 
                                       (if (eq (car n) :|Native|) 
                                           (return "native ") 
                                           (if (eq (car n) :|Synchronized|) 
                                               (return "synchronized ") 
                                               (if (eq (car n) :|Transient|) 
                                                   (return "transient ") 
                                                   (if (eq (car n) :|Volatile|) 
                                                       (return "volatile ") 
                                                       (if (eq 
                                                            (car n) 
                                                            :|Strictfp|) 
                                                           (return "strictfp ")))))))))))) 
               (error "Nonexhaustive match failure in ppMods")))) 
          |!ms|))) (PRETTYPRINT::prettysNone ps)))

(defun JAVA::ppClsDecl (|!ms| ch cb) 
  (PRETTYPRINT::prettysAll 
   (LIST-SPEC::|!cons| 
    (PRETTYPRINT::prettysNone 
     (cons 
      (JAVA::ppMods |!ms|) 
      (cons 
       (JAVA::ppClsHeader-1 ch) 
       (cons (JAVA::toPretty " ") (cons (JAVA::toPretty "{") nil))))) 
    (if (JAVA::isEmptyClsBody-1 cb) 
        (cons (JAVA::toPretty "}") nil) 
        (cons 
         (PRETTYPRINT::emptyPretty) 
         (cons 
          (PRETTYPRINT::prettysNone 
           (cons (JAVA::toPretty "  ") (cons (JAVA::ppClsBody-1 cb) nil))) 
          (cons (PRETTYPRINT::emptyPretty) (cons (JAVA::toPretty "}") nil))))))))


(defun JAVA::ppClsDecl-1 (x) 
  (JAVA::ppClsDecl (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::ppBasic (bt) 
  (JAVA::toPretty 
   (block 
    nil 
    (if (eq (car bt) :|JBool|) 
        (return "boolean") 
        (if (eq (car bt) :|Byte|) 
            (return "byte") 
            (if (eq (car bt) :|Short|) 
                (return "short") 
                (if (eq (car bt) :|Char|) 
                    (return "char") 
                    (if (eq (car bt) :|JInt|) 
                        (return "int") 
                        (if (eq (car bt) :|Long|) 
                            (return "int") 
                            (if (eq (car bt) :|JFloat|) 
                                (return "float") 
                                (if (eq (car bt) :|Double|) (return "double"))))))))) 
    (error "Nonexhaustive match failure in ppBasic"))))

(defun JAVA::ppBasicOrName (btn) 
  (block 
   nil 
   (if (eq (car btn) :|Basic|) 
       (return (JAVA::ppBasic (cdr btn))) 
       (if (eq (car btn) :|Name|) (return (JAVA::ppName-1 (cdr btn))))) 
   (error "Nonexhaustive match failure in ppBasicOrName")))

(defun JAVA::ppType (btn n) 
  (PRETTYPRINT::prettysNone 
   (cons (JAVA::ppBasicOrName btn) (cons (JAVA::emptyBrackets n) nil))))

(defun JAVA::ppType-1 (x) (JAVA::ppType (car x) (cdr x)))

(defun JAVA::ppVarDeclId (id n) 
  (PRETTYPRINT::prettysNone 
   (cons (JAVA::toPretty id) (cons (JAVA::emptyBrackets n) nil))))

(defun JAVA::ppVarDeclId-1 (x) (JAVA::ppVarDeclId (car x) (cdr x)))

(defun JAVA::ppVarDecl (vdi vi) 
  (block 
   nil 
   (if (eq (car vi) :|None|) 
       (return (JAVA::ppVarDeclId-1 vdi)) 
       (if (eq (car vi) :|Some|) 
           (return 
            (PRETTYPRINT::prettysNone 
             (cons 
              (JAVA::ppVarDeclId-1 vdi) 
              (cons (JAVA::toPretty " = ") (cons (JAVA::ppVarInit (cdr vi)) nil))))))) 
   (error "Nonexhaustive match failure in ppVarDecl")))

(defun JAVA::ppVarDecl-1 (x) (JAVA::ppVarDecl (car x) (cdr x)))

(defun JAVA::ppVarDecls (vdl) 
  (PRETTYPRINT::prettysNone 
   (JAVA::addPrettys 
    (LIST-SPEC::|!map|-1-1 #'JAVA::ppVarDecl-1 vdl) 
    (JAVA::toPretty ", "))))

(defun JAVA::ppLocVarDecl (b |!t| vd vds) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::toPretty (if b "final " "")) 
    (cons 
     (JAVA::ppType-1 |!t|) 
     (cons 
      (JAVA::toPretty " ") 
      (cons 
       (JAVA::ppVarDecl-1 vd) 
       (cons 
        (JAVA::toPretty (if (slang-built-in::slang-term-equals vds nil) "" ", ")) 
        (cons (JAVA::ppVarDecls vds) nil))))))))

(defun JAVA::ppLocVarDecl-1 (x) 
  (JAVA::ppLocVarDecl (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JAVA::ppFormPar (b |!t| vdi) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::toPretty (if (eq b t) "final " "")) 
    (cons 
     (JAVA::ppType-1 |!t|) 
     (cons (JAVA::toPretty " ") (cons (JAVA::ppVarDeclId-1 vdi) nil))))))

(defun JAVA::ppFormPar-1 (x) 
  (JAVA::ppFormPar (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::ppOptExpr (ope) 
  (block 
   nil 
   (if (eq (car ope) :|None|) 
       (return (PRETTYPRINT::emptyPretty)) 
       (if (eq (car ope) :|Some|) (return (JAVA::ppExpr (cdr ope))))) 
   (error "Nonexhaustive match failure in ppOptExpr")))

(defun JAVA::ppOptForInit (opfi) 
  (block 
   nil 
   (if (eq (car opfi) :|None|) 
       (return (PRETTYPRINT::emptyPretty)) 
       (if (eq (car opfi) :|Some|) 
           (let ((pV7 (cdr opfi))) 
             (return 
              (block 
               nil 
               (if (eq (car pV7) :|LocVarDecl|) 
                   (return (JAVA::ppLocVarDecl-1 (cdr pV7))) 
                   (if (eq (car pV7) :|StmtExprs|) 
                       (let ((pV2 (cdr pV7))) 
                         (return 
                          (PRETTYPRINT::prettysLinear 
                           (JAVA::addPrettys 
                            (LIST-SPEC::|!map|-1-1 
                             #'JAVA::ppExpr 
                             (LIST-SPEC::|!cons| (car pV2) (cdr pV2))) 
                            (JAVA::toPretty ","))))))) 
               (error "Nonexhaustive match failure in ppOptForInit")))))) 
   (error "Nonexhaustive match failure in ppOptForInit")))

(defun JAVA::ppOptForUpdate (opfu) 
  (block 
   nil 
   (if (eq (car opfu) :|None|) 
       (return (PRETTYPRINT::emptyPretty)) 
       (if (eq (car opfu) :|Some|) 
           (let ((pV2 (cdr opfu))) 
             (return 
              (PRETTYPRINT::prettysLinear 
               (JAVA::addPrettys 
                (LIST-SPEC::|!map|-1-1 
                 #'JAVA::ppExpr 
                 (LIST-SPEC::|!cons| (car pV2) (cdr pV2))) 
                (JAVA::toPretty ","))))))) 
   (error "Nonexhaustive match failure in ppOptForUpdate")))

(defun JAVA::ppSwitchLab (sl) 
  (block 
   nil 
   (if (eq (car sl) :|JCase|) 
       (return 
        (PRETTYPRINT::prettysNone 
         (cons 
          (JAVA::toPretty "case ") 
          (cons (JAVA::ppExpr (cdr sl)) (cons (JAVA::toPretty ":") nil))))) 
       (if (eq (car sl) :|Default|) (return (JAVA::toPretty "default:")))) 
   (error "Nonexhaustive match failure in ppSwitchLab")))

(defun JAVA::ppSwitchLabStmtPa (slabs bksts) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::prettysNone (LIST-SPEC::|!map|-1-1 #'JAVA::ppSwitchLab slabs)) 
    (cons 
     (JAVA::toPretty " ") 
     (cons 
      (PRETTYPRINT::prettysAll (LIST-SPEC::|!map|-1-1 #'JAVA::ppBlockStmt bksts)) 
      nil)))))

(defun JAVA::ppSwitchLabStmtPa-1 (x) (JAVA::ppSwitchLabStmtPa (car x) (cdr x)))

(defun JAVA::ppSwitchBlock (swbk) 
  (PRETTYPRINT::prettysAll 
   (cons 
    (PRETTYPRINT::prettysNone 
     (cons 
      (JAVA::toPretty "{ ") 
      (cons 
       (PRETTYPRINT::prettysNone 
        (LIST-SPEC::|!map|-1-1 #'JAVA::ppSwitchLabStmtPa-1 swbk)) 
       nil))) 
    (cons (JAVA::toPretty "}") nil))))

(defun JAVA::ppStmt (st) 
  (block 
   nil 
   (if (eq (car st) :|Block|) 
       (let ((pV31 (cdr st))) 
         (return 
          (block 
           nil 
           (if (null pV31) (return (JAVA::toPretty "{ }"))) 
           (return 
            (PRETTYPRINT::prettysNone 
             (cons 
              (JAVA::toPretty "{ ") 
              (cons (JAVA::ppBlock pV31) (cons (JAVA::toPretty " }") nil)))))))) 
       (if (eq (car st) :|Labeled|) 
           (let ((pV30 (cdr st))) 
             (return 
              (PRETTYPRINT::prettysNone 
               (cons 
                (JAVA::toPretty (STRING-SPEC::concat (car pV30) " : ")) 
                (cons (JAVA::ppStmt (cdr pV30)) nil))))) 
           (if (eq (car st) :|If|) 
               (let ((pV29 (cdr st))) 
                 (let ((pV49 (svref pV29 2))) 
                   (return 
                    (PRETTYPRINT::prettysAll 
                     (LIST-SPEC::|!cons| 
                      (PRETTYPRINT::prettysNone 
                       (cons 
                        (JAVA::toPretty "if (") 
                        (cons 
                         (JAVA::ppExpr (svref pV29 0)) 
                         (cons 
                          (JAVA::toPretty ") ") 
                          (cons (JAVA::ppStmt (svref pV29 1)) nil))))) 
                      (block 
                       nil 
                       (if (eq (car pV49) :|None|) 
                           (return nil) 
                           (if (eq (car pV49) :|Some|) 
                               (return 
                                (cons 
                                 (JAVA::toPretty "else ") 
                                 (cons (JAVA::ppStmt (cdr pV49)) nil))))) 
                       (error "Nonexhaustive match failure in ppStmt"))))))) 
               (if (eq (car st) :|For|) 
                   (let ((pV28 (cdr st))) 
                     (return 
                      (PRETTYPRINT::prettysAll 
                       (cons 
                        (PRETTYPRINT::prettysNone 
                         (cons 
                          (JAVA::toPretty "for ( ") 
                          (cons 
                           (JAVA::ppOptForInit (svref pV28 0)) 
                           (cons 
                            (JAVA::toPretty "; ") 
                            (cons 
                             (JAVA::ppOptExpr (svref pV28 1)) 
                             (cons 
                              (JAVA::toPretty "; ") 
                              (cons 
                               (JAVA::ppOptForUpdate (svref pV28 2)) 
                               (cons (JAVA::toPretty " )") nil)))))))) 
                        (cons (JAVA::ppStmt (svref pV28 3)) nil))))) 
                   (if (eq (car st) :|While|) 
                       (let ((pV27 (cdr st))) 
                         (return 
                          (PRETTYPRINT::prettysAll 
                           (cons 
                            (PRETTYPRINT::prettysLinear 
                             (cons 
                              (JAVA::toPretty "while ( ") 
                              (cons 
                               (JAVA::ppExpr (car pV27)) 
                               (cons (JAVA::toPretty " ) ") nil)))) 
                            (cons (JAVA::ppStmt (cdr pV27)) nil))))) 
                       (if (eq (car st) :|Do|) 
                           (let ((pV26 (cdr st))) 
                             (return 
                              (PRETTYPRINT::prettysLinear 
                               (cons 
                                (PRETTYPRINT::prettysNone 
                                 (cons 
                                  (JAVA::toPretty "do ") 
                                  (cons 
                                   (JAVA::ppStmt (car pV26)) 
                                   (cons (JAVA::toPretty " ") nil)))) 
                                (cons 
                                 (JAVA::toPretty "while ( ") 
                                 (cons 
                                  (JAVA::ppExpr (cdr pV26)) 
                                  (cons (JAVA::toPretty " )") nil))))))) 
                           (if (eq (car st) :|Try|) 
                               (let ((pV25 (cdr st))) 
                                 (let ((pV38 (svref pV25 2))) 
                                   (return 
                                    (let ((try 
                                           (cons 
                                            (JAVA::toPretty "try { ") 
                                            (cons 
                                             (PRETTYPRINT::prettysNone 
                                              (cons 
                                               (JAVA::toPretty "  ") 
                                               (cons 
                                                (JAVA::ppBlock (svref pV25 0)) 
                                                nil))) 
                                             nil)))) 
                                      (let ((cat 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'(lambda (x) 
                                                 (PRETTYPRINT::prettysAll 
                                                  (cons 
                                                   (PRETTYPRINT::prettysNone 
                                                    (cons 
                                                     (JAVA::toPretty 
                                                      "} catch ( ") 
                                                     (cons 
                                                      (JAVA::ppFormPar-1 (car x)) 
                                                      (cons 
                                                       (JAVA::toPretty " ) {") 
                                                       nil)))) 
                                                   (cons 
                                                    (PRETTYPRINT::prettysNone 
                                                     (cons 
                                                      (JAVA::toPretty "  ") 
                                                      (cons 
                                                       (JAVA::ppBlock (cdr x)) 
                                                       nil))) 
                                                    nil)))) 
                                              (svref pV25 1)))) 
                                        (let ((fin 
                                               (block 
                                                nil 
                                                (if (eq (car pV38) :|None|) 
                                                    (return nil) 
                                                    (if (eq (car pV38) :|Some|) 
                                                        (let ((pV8 (cdr pV38))) 
                                                          (return 
                                                           (block 
                                                            nil 
                                                            (if (null pV8) 
                                                                (return nil)) 
                                                            (return 
                                                             (cons 
                                                              (JAVA::toPretty 
                                                               "} finally {") 
                                                              (cons 
                                                               (PRETTYPRINT::prettysNone 
                                                                (cons 
                                                                 (JAVA::toPretty 
                                                                  "  ") 
                                                                 (cons 
                                                                  (JAVA::ppBlock 
                                                                   pV8) 
                                                                  nil))) 
                                                               nil)))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in ppStmt")))) 
                                          (PRETTYPRINT::prettysAll 
                                           (LIST-SPEC::flatten 
                                            (cons 
                                             try 
                                             (cons 
                                              cat 
                                              (cons 
                                               fin 
                                               (cons 
                                                (cons (JAVA::toPretty "}") nil) 
                                                nil)))))))))))) 
                               (if (eq (car st) :|Switch|) 
                                   (let ((pV24 (cdr st))) 
                                     (return 
                                      (PRETTYPRINT::prettysNone 
                                       (cons 
                                        (JAVA::toPretty "switch (") 
                                        (cons 
                                         (JAVA::ppExpr (car pV24)) 
                                         (cons 
                                          (JAVA::toPretty " ) ") 
                                          (cons 
                                           (JAVA::ppSwitchBlock (cdr pV24)) 
                                           nil))))))) 
                                   (if (eq (car st) :|Synchronized|) 
                                       (let ((pV23 (cdr st))) 
                                         (let ((pV33 (cdr pV23))) 
                                           (return 
                                            (let ((hd 
                                                   (PRETTYPRINT::prettysNone 
                                                    (cons 
                                                     (JAVA::toPretty 
                                                      "synchronized ( ") 
                                                     (cons 
                                                      (JAVA::ppExpr (car pV23)) 
                                                      (cons 
                                                       (JAVA::toPretty " ) { ") 
                                                       nil)))))) 
                                              (block 
                                               nil 
                                               (if (null pV33) 
                                                   (return 
                                                    (PRETTYPRINT::prettysNone 
                                                     (cons 
                                                      hd 
                                                      (cons 
                                                       (JAVA::toPretty "}") 
                                                       nil))))) 
                                               (return 
                                                (PRETTYPRINT::prettysAll 
                                                 (cons 
                                                  hd 
                                                  (cons 
                                                   (PRETTYPRINT::prettysNone 
                                                    (cons 
                                                     (JAVA::toPretty "  ") 
                                                     (cons 
                                                      (JAVA::ppBlock pV33) 
                                                      nil))) 
                                                   (cons 
                                                    (JAVA::toPretty "}") 
                                                    nil)))))))))) 
                                       (if (eq (car st) :|Return|) 
                                           (let ((pV22 (cdr st))) 
                                             (return 
                                              (PRETTYPRINT::prettysNone 
                                               (cons 
                                                (JAVA::toPretty "return") 
                                                (cons 
                                                 (block 
                                                  nil 
                                                  (if (eq (car pV22) :|None|) 
                                                      (return 
                                                       (PRETTYPRINT::emptyPretty)) 
                                                      (if (eq (car pV22) :|Some|) 
                                                          (return 
                                                           (PRETTYPRINT::prettysNone 
                                                            (cons 
                                                             (JAVA::toPretty 
                                                              " ( ") 
                                                             (cons 
                                                              (JAVA::ppExpr 
                                                               (cdr pV22)) 
                                                              (cons 
                                                               (JAVA::toPretty 
                                                                " ) ") 
                                                               nil))))))) 
                                                  (error 
                                                   "Nonexhaustive match failure in ppStmt")) 
                                                 (cons (JAVA::toPretty ";") nil)))))) 
                                           (if (eq (car st) :|Throw|) 
                                               (return 
                                                (PRETTYPRINT::prettysNone 
                                                 (cons 
                                                  (JAVA::toPretty "throw ") 
                                                  (cons 
                                                   (JAVA::ppExpr (cdr st)) 
                                                   (cons 
                                                    (JAVA::toPretty ";") 
                                                    nil))))) 
                                               (if (eq (car st) :|Break|) 
                                                   (let ((pV20 (cdr st))) 
                                                     (return 
                                                      (PRETTYPRINT::prettysNone 
                                                       (cons 
                                                        (JAVA::toPretty "break") 
                                                        (cons 
                                                         (block 
                                                          nil 
                                                          (if (eq 
                                                               (car pV20) 
                                                               :|None|) 
                                                              (return 
                                                               (PRETTYPRINT::emptyPretty)) 
                                                              (if (eq 
                                                                   (car pV20) 
                                                                   :|Some|) 
                                                                  (return 
                                                                   (JAVA::toPretty 
                                                                    (STRING-SPEC::concat 
                                                                     " " 
                                                                     (cdr pV20)))))) 
                                                          (error 
                                                           "Nonexhaustive match failure in ppStmt")) 
                                                         (cons 
                                                          (JAVA::toPretty ";") 
                                                          nil)))))) 
                                                   (if (eq (car st) :|Continue|) 
                                                       (let ((pV19 (cdr st))) 
                                                         (return 
                                                          (PRETTYPRINT::prettysNone 
                                                           (cons 
                                                            (JAVA::toPretty 
                                                             "continue") 
                                                            (cons 
                                                             (block 
                                                              nil 
                                                              (if (eq 
                                                                   (car pV19) 
                                                                   :|None|) 
                                                                  (return 
                                                                   (PRETTYPRINT::emptyPretty)) 
                                                                  (if (eq 
                                                                       (car pV19) 
                                                                       :|Some|) 
                                                                      (return 
                                                                       (JAVA::toPretty 
                                                                        (STRING-SPEC::concat 
                                                                         " " 
                                                                         (cdr 
                                                                          pV19)))))) 
                                                              (error 
                                                               "Nonexhaustive match failure in ppStmt")) 
                                                             (cons 
                                                              (JAVA::toPretty 
                                                               ";") 
                                                              nil)))))) 
                                                       (if (eq (car st) :|Expr|) 
                                                           (return 
                                                            (PRETTYPRINT::prettysNone 
                                                             (cons 
                                                              (JAVA::ppExpr 
                                                               (cdr st)) 
                                                              (cons 
                                                               (JAVA::toPretty 
                                                                ";") 
                                                               nil)))) 
                                                           (if (eq 
                                                                (car st) 
                                                                :|Empty|) 
                                                               (return 
                                                                (JAVA::toPretty 
                                                                 ";"))))))))))))))))) 
   (error "Nonexhaustive match failure in ppStmt")))

(defun JAVA::ppBlockStmt (bs) 
  (block 
   nil 
   (if (eq (car bs) :|LocVarDecl|) 
       (return 
        (PRETTYPRINT::prettysNone 
         (cons (JAVA::ppLocVarDecl-1 (cdr bs)) (cons (JAVA::toPretty ";") nil)))) 
       (if (eq (car bs) :|ClsDecl|) 
           (return (JAVA::ppClsDecl-1 (cdr bs))) 
           (if (eq (car bs) :|Stmt|) (return (JAVA::ppStmt (cdr bs)))))) 
   (error "Nonexhaustive match failure in ppBlockStmt")))

(defun JAVA::ppBlock (bss) 
  (PRETTYPRINT::prettysAll (LIST-SPEC::|!map|-1-1 #'JAVA::ppBlockStmt bss)))

(defun JAVA::ppFormPars (fps) 
  (PRETTYPRINT::prettysNone 
   (JAVA::addPrettys 
    (LIST-SPEC::|!map|-1-1 #'JAVA::ppFormPar-1 fps) 
    (JAVA::toPretty ", "))))

(defun JAVA::ppThrows (ns) 
  (PRETTYPRINT::prettysNone 
   (JAVA::addPrettys 
    (LIST-SPEC::|!map|-1-1 #'JAVA::ppName-1 ns) 
    (JAVA::toPretty ", "))))

(defun JAVA::ppConstrDecl (|!ms| id fps thrs bk) 
  (let ((hd 
         (PRETTYPRINT::prettysNone 
          (cons 
           (JAVA::ppMods |!ms|) 
           (cons 
            (JAVA::toPretty id) 
            (cons 
             (JAVA::toPretty " (") 
             (cons 
              (JAVA::ppFormPars fps) 
              (cons 
               (JAVA::toPretty ")") 
               (cons 
                (if (slang-built-in::slang-term-equals thrs nil) 
                    (PRETTYPRINT::emptyPretty) 
                    (PRETTYPRINT::prettysNone 
                     (cons 
                      (JAVA::toPretty " throws ") 
                      (cons (JAVA::ppThrows thrs) nil)))) 
                nil))))))))) 
    (block 
     nil 
     (if (null bk) 
         (return 
          (PRETTYPRINT::prettysNone (cons hd (cons (JAVA::toPretty " { }") nil))))) 
     (return 
      (PRETTYPRINT::prettysAll 
       (cons 
        (PRETTYPRINT::prettysNone (cons hd (cons (JAVA::toPretty " {") nil))) 
        (cons (JAVA::ppBlock bk) (cons (JAVA::toPretty "}") nil))))))))

(defun JAVA::ppConstrDecl-1 (x) 
  (JAVA::ppConstrDecl 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JAVA::ppFldDecl (|!ms| |!t| vd vds) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::ppMods |!ms|) 
    (cons 
     (JAVA::ppType-1 |!t|) 
     (cons 
      (JAVA::toPretty " ") 
      (cons (JAVA::ppVarDecl-1 vd) (cons (JAVA::toPretty ";") nil)))))))

(defun JAVA::ppFldDecl-1 (x) 
  (JAVA::ppFldDecl (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun JAVA::ppMethHeader (|!ms| rt id fps thrs) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::ppMods |!ms|) 
    (cons 
     (block 
      nil 
      (if (eq (car rt) :|None|) 
          (return (JAVA::toPretty "void")) 
          (if (eq (car rt) :|Some|) (return (JAVA::ppType-1 (cdr rt))))) 
      (error "Nonexhaustive match failure in ppMethHeader")) 
     (cons 
      (JAVA::toPretty " ") 
      (cons 
       (JAVA::toPretty id) 
       (cons 
        (JAVA::toPretty " (") 
        (cons 
         (JAVA::ppFormPars fps) 
         (cons 
          (JAVA::toPretty ")") 
          (cons 
           (if (slang-built-in::slang-term-equals thrs nil) 
               (PRETTYPRINT::emptyPretty) 
               (PRETTYPRINT::prettysNone 
                (cons 
                 (JAVA::toPretty " throws ") 
                 (cons (JAVA::ppThrows thrs) nil)))) 
           nil))))))))))

(defun JAVA::ppMethHeader-1 (x) 
  (JAVA::ppMethHeader 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun JAVA::ppInterfBody-1 (ib) 
  (PRETTYPRINT::prettysAll 
   (JAVA::addEmptys 
    (LIST-SPEC::flatten 
     (cons 
      (LIST-SPEC::|!map|-1-1 #'JAVA::ppFldDecl-1 (svref ib 1)) 
      (cons 
       (LIST-SPEC::|!map|-1-1 
        #'(lambda (mh) 
           (PRETTYPRINT::prettysNone 
            (cons (JAVA::ppMethHeader-1 mh) (cons (JAVA::toPretty ";") nil)))) 
        (svref ib 3)) 
       (cons 
        (LIST-SPEC::|!map|-1-1 #'JAVA::ppClsDecl-1 (svref ib 0)) 
        (cons (LIST-SPEC::|!map|-1-1 #'JAVA::ppInterfDecl-1 (svref ib 2)) nil))))))))


(defun JAVA::ppInterfHeader (id sis) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::toPretty "interface ") 
    (cons 
     (JAVA::toPretty id) 
     (cons 
      (JAVA::toPretty 
       (if (slang-built-in::slang-term-equals sis nil) "" " extends ")) 
      (cons (JAVA::ppSuperInterf sis) nil))))))

(defun JAVA::ppInterfHeader-1 (x) (JAVA::ppInterfHeader (car x) (cdr x)))

(defun JAVA::ppInterfDecl (|!ms| ih ib) 
  (PRETTYPRINT::prettysAll 
   (LIST-SPEC::|!cons| 
    (PRETTYPRINT::prettysNone 
     (cons 
      (JAVA::ppMods |!ms|) 
      (cons 
       (JAVA::ppInterfHeader-1 ih) 
       (cons (JAVA::toPretty " ") (cons (JAVA::toPretty "{") nil))))) 
    (if (JAVA::isEmptyInterfBody-1 ib) 
        (cons (JAVA::toPretty "}") nil) 
        (cons 
         (PRETTYPRINT::emptyPretty) 
         (cons 
          (PRETTYPRINT::prettysNone 
           (cons (JAVA::toPretty "  ") (cons (JAVA::ppInterfBody-1 ib) nil))) 
          (cons (PRETTYPRINT::emptyPretty) (cons (JAVA::toPretty "}") nil))))))))


(defun JAVA::ppInterfDecl-1 (x) 
  (JAVA::ppInterfDecl (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::ppMethDecl (mh obk) 
  (block 
   nil 
   (if (eq (car obk) :|None|) 
       (return 
        (PRETTYPRINT::prettysNone 
         (cons (JAVA::ppMethHeader-1 mh) (cons (JAVA::toPretty ";") nil)))) 
       (if (eq (car obk) :|Some|) 
           (let ((pV4 (cdr obk))) 
             (return 
              (block 
               nil 
               (if (null pV4) 
                   (return 
                    (PRETTYPRINT::prettysNone 
                     (cons 
                      (JAVA::ppMethHeader-1 mh) 
                      (cons (JAVA::toPretty " { }") nil))))) 
               (return 
                (PRETTYPRINT::prettysAll 
                 (cons 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (JAVA::ppMethHeader-1 mh) 
                    (cons (JAVA::toPretty " {") nil))) 
                  (cons (JAVA::ppBlock pV4) (cons (JAVA::toPretty "}") nil)))))))))) 
   (error "Nonexhaustive match failure in ppMethDecl")))

(defun JAVA::ppMethDecl-1 (x) (JAVA::ppMethDecl (car x) (cdr x)))

(defun JAVA::ppStaticInits (bk) 
  (block 
   nil 
   (if (null bk) (return (JAVA::toPretty "static { }"))) 
   (return 
    (PRETTYPRINT::prettysAll 
     (cons 
      (JAVA::toPretty "static {") 
      (cons (JAVA::ppBlock bk) (cons (JAVA::toPretty "}") nil)))))))

(defun JAVA::ppClsBody-1 (cb) 
  (PRETTYPRINT::prettysAll 
   (JAVA::addEmptys 
    (LIST-SPEC::flatten 
     (cons 
      (LIST-SPEC::|!map|-1-1 #'JAVA::ppStaticInits (svref cb 5)) 
      (cons 
       (LIST-SPEC::|!map|-1-1 #'JAVA::ppFldDecl-1 (svref cb 2)) 
       (cons 
        (LIST-SPEC::|!map|-1-1 #'JAVA::ppConstrDecl-1 (svref cb 1)) 
        (cons 
         (LIST-SPEC::|!map|-1-1 #'JAVA::ppMethDecl-1 (svref cb 4)) 
         (cons 
          (LIST-SPEC::|!map|-1-1 #'JAVA::ppClsDecl-1 (svref cb 0)) 
          (cons (LIST-SPEC::|!map|-1-1 #'JAVA::ppInterfDecl-1 (svref cb 3)) nil))))))))))


(defun JAVA::ppNewClsInst (nw) 
  (block 
   nil 
   (if (eq (car nw) :|ForCls|) 
       (let ((pV6 (cdr nw))) 
         (let ((pV13 (svref pV6 2))) 
           (return 
            (PRETTYPRINT::prettysNone 
             (cons 
              (JAVA::toPretty "new ") 
              (cons 
               (JAVA::ppName-1 (svref pV6 0)) 
               (cons 
                (JAVA::toPretty "(") 
                (cons 
                 (PRETTYPRINT::prettysNone 
                  (JAVA::addPrettys 
                   (LIST-SPEC::|!map|-1-1 #'JAVA::ppExpr (svref pV6 1)) 
                   (JAVA::toPretty ","))) 
                 (cons 
                  (JAVA::toPretty ")") 
                  (cons 
                   (block 
                    nil 
                    (if (eq (car pV13) :|None|) 
                        (return (PRETTYPRINT::emptyPretty)) 
                        (if (eq (car pV13) :|Some|) 
                            (return 
                             (PRETTYPRINT::prettysAll 
                              (cons 
                               (JAVA::toPretty "{") 
                               (cons 
                                (JAVA::ppClsBody-1 (cdr pV13)) 
                                (cons (JAVA::toPretty "}") nil))))))) 
                    (error "Nonexhaustive match failure in ppNewClsInst")) 
                   nil)))))))))) 
       (if (eq (car nw) :|ForInnCls|) 
           (let ((pV5 (cdr nw))) 
             (return 
              (PRETTYPRINT::prettysNone 
               (cons 
                (JAVA::toPretty "new ") 
                (cons 
                 (JAVA::ppPrim (svref pV5 0)) 
                 (cons 
                  (JAVA::toPretty ".") 
                  (cons 
                   (JAVA::toPretty (svref pV5 1)) 
                   (cons 
                    (JAVA::toPretty "(") 
                    (cons 
                     (PRETTYPRINT::prettysNone 
                      (JAVA::addPrettys 
                       (LIST-SPEC::|!map|-1-1 #'JAVA::ppExpr (svref pV5 2)) 
                       (JAVA::toPretty ","))) 
                     (cons 
                      (JAVA::toPretty ")") 
                      (cons 
                       (block 
                        nil 
                        (if (eq (car (svref pV5 3)) :|None|) 
                            (return (PRETTYPRINT::emptyPretty))) 
                        (error "Nonexhaustive match failure in ppNewClsInst")) 
                       nil))))))))))))) 
   (error "Nonexhaustive match failure in ppNewClsInst")))

(defun JAVA::ppPrim (pm) 
  (block 
   nil 
   (if (eq (car pm) :|Name|) 
       (return (JAVA::ppName-1 (cdr pm))) 
       (if (eq (car pm) :|IntL|) 
           (return (JAVA::toPretty (INTEGER-SPEC::toString (cdr pm)))) 
           (if (eq (car pm) :|Float|) 
               (let ((pV17 (cdr pm))) 
                 (return 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (JAVA::toPretty (INTEGER-SPEC::toString (car pV17))) 
                    (cons 
                     (JAVA::toPretty ".") 
                     (cons 
                      (JAVA::toPretty (INTEGER-SPEC::toString (cdr pV17))) 
                      nil)))))) 
               (if (eq (car pm) :|Bool|) 
                   (return (JAVA::toPretty (BOOLEAN-SPEC::toString (cdr pm)))) 
                   (if (eq (car pm) :|Char|) 
                       (return (JAVA::toPretty (CHAR-SPEC::toString (cdr pm)))) 
                       (if (eq (car pm) :|String|) 
                           (return 
                            (JAVA::toPretty 
                             (JAVA::concatList 
                              (cons "\"" (cons (cdr pm) (cons "\"" nil)))))) 
                           (if (eq (car pm) :|Null|) 
                               (return (JAVA::toPretty "null")) 
                               (if (eq (car pm) :|ClsInst|) 
                                   (let ((pV13 (cdr pm))) 
                                     (return 
                                      (PRETTYPRINT::prettysNone 
                                       (cons 
                                        (block 
                                         nil 
                                         (if (eq (car pV13) :|None|) 
                                             (return (JAVA::toPretty "void")) 
                                             (if (eq (car pV13) :|Some|) 
                                                 (return 
                                                  (JAVA::ppType-1 (cdr pV13))))) 
                                         (error 
                                          "Nonexhaustive match failure in ppPrim")) 
                                        (cons (JAVA::toPretty ".class") nil))))) 
                                   (if (eq (car pm) :|This|) 
                                       (let ((pV12 (cdr pm))) 
                                         (return 
                                          (block 
                                           nil 
                                           (if (eq (car pV12) :|None|) 
                                               (return (JAVA::toPretty "this")) 
                                               (if (eq (car pV12) :|Some|) 
                                                   (return 
                                                    (PRETTYPRINT::prettysNone 
                                                     (cons 
                                                      (JAVA::ppName-1 (cdr pV12)) 
                                                      (cons 
                                                       (JAVA::toPretty "this") 
                                                       nil)))))) 
                                           (error 
                                            "Nonexhaustive match failure in ppPrim")))) 
                                       (if (eq (car pm) :|Paren|) 
                                           (return 
                                            (PRETTYPRINT::prettysNone 
                                             (cons (JAVA::ppExpr (cdr pm)) nil))) 
                                           (if (eq (car pm) :|NewClsInst|) 
                                               (return 
                                                (JAVA::ppNewClsInst (cdr pm))) 
                                               (if (eq (car pm) :|NewArr|) 
                                                   (return 
                                                    (JAVA::ppNewArr (cdr pm))) 
                                                   (if (eq (car pm) :|FldAcc|) 
                                                       (return 
                                                        (JAVA::ppFldAcc (cdr pm))) 
                                                       (if (eq 
                                                            (car pm) 
                                                            :|MethInv|) 
                                                           (return 
                                                            (JAVA::ppMethInv 
                                                             (cdr pm))) 
                                                           (if (eq 
                                                                (car pm) 
                                                                :|ArrAcc|) 
                                                               (return 
                                                                (JAVA::ppArrAcc 
                                                                 (cdr pm)))))))))))))))))) 
   (error "Nonexhaustive match failure in ppPrim")))

(defun JAVA::ppFldAcc (fac) 
  (block 
   nil 
   (if (eq (car fac) :|ViaPrim|) 
       (let ((pV4 (cdr fac))) 
         (return 
          (PRETTYPRINT::prettysNone 
           (cons 
            (JAVA::ppPrim (car pV4)) 
            (cons (JAVA::toPretty ".") (cons (JAVA::toPretty (cdr pV4)) nil)))))) 
       (if (eq (car fac) :|ViaSuper|) 
           (return (JAVA::toPretty (STRING-SPEC::concat "super." (cdr fac)))) 
           (if (eq (car fac) :|ViaCls|) 
               (let ((pV2 (cdr fac))) 
                 (return 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (JAVA::ppName-1 (car pV2)) 
                    (cons 
                     (JAVA::toPretty (STRING-SPEC::concat ".super." (cdr pV2))) 
                     nil)))))))) 
   (error "Nonexhaustive match failure in ppFldAcc")))

(defun JAVA::ppLHS (l) 
  (block 
   nil 
   (if (eq (car l) :|Name|) 
       (return (JAVA::ppName-1 (cdr l))) 
       (if (eq (car l) :|FldAcc|) 
           (return (JAVA::ppFldAcc (cdr l))) 
           (if (eq (car l) :|ArrAcc|) (return (JAVA::ppArrAcc (cdr l)))))) 
   (error "Nonexhaustive match failure in ppLHS")))

(defun JAVA::ppAss (l o e) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::ppLHS l) 
    (cons 
     (JAVA::toPretty " ") 
     (cons 
      (JAVA::ppAssOp o) 
      (cons (JAVA::toPretty " ") (cons (JAVA::ppExpr e) nil)))))))

(defun JAVA::ppAss-1 (x) (JAVA::ppAss (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::ppBinOp (o) (JAVA::toPretty (JAVA::binOpToString o)))

(defun JAVA::ppPostUnOp (o) (JAVA::toPretty (JAVA::postUnOpToString o)))

(defun JAVA::unOpToString (o) 
  (block 
   nil 
   (if (eq (car o) :|Plus|) 
       (return "+") 
       (if (eq (car o) :|Minus|) 
           (return "-") 
           (if (eq (car o) :|PreInc|) 
               (return "++") 
               (if (eq (car o) :|PreDec|) 
                   (return "--") 
                   (if (eq (car o) :|BitNot|) 
                       (return "~") 
                       (if (eq (car o) :|LogNot|) (return "!"))))))) 
   (error "Nonexhaustive match failure in unOpToString")))

(defun JAVA::ppUnOp (o) (JAVA::toPretty (JAVA::unOpToString o)))

(defun JAVA::ppUnExp (ue) 
  (block 
   nil 
   (if (eq (car ue) :|Un|) 
       (let ((pV5 (cdr ue))) 
         (return 
          (PRETTYPRINT::prettysNone 
           (cons 
            (JAVA::toPretty "( ") 
            (cons 
             (JAVA::ppUnOp (car pV5)) 
             (cons 
              (JAVA::toPretty " ") 
              (cons (JAVA::ppUnExp (cdr pV5)) (cons (JAVA::toPretty " )") nil)))))))) 
       (if (eq (car ue) :|Cast|) 
           (let ((pV4 (cdr ue))) 
             (return 
              (PRETTYPRINT::prettysNone 
               (cons 
                (JAVA::toPretty "(") 
                (cons 
                 (JAVA::ppType-1 (car pV4)) 
                 (cons (JAVA::toPretty ")") (cons (JAVA::ppUnExp (cdr pV4)) nil))))))) 
           (if (eq (car ue) :|PostUn|) 
               (let ((pV3 (cdr ue))) 
                 (return 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (JAVA::ppUnExp (car pV3)) 
                    (cons (JAVA::ppPostUnOp (cdr pV3)) nil))))) 
               (if (eq (car ue) :|Prim|) (return (JAVA::ppPrim (cdr ue))))))) 
   (error "Nonexhaustive match failure in ppUnExp")))

(defun JAVA::ppBinExp (be) 
  (block 
   nil 
   (if (eq (car be) :|Bin|) 
       (let ((pV4 (cdr be))) 
         (return 
          (PRETTYPRINT::prettysNone 
           (cons 
            (JAVA::toPretty "( ") 
            (cons 
             (JAVA::ppBinExp (svref pV4 1)) 
             (cons 
              (JAVA::toPretty " ") 
              (cons 
               (JAVA::ppBinOp (svref pV4 0)) 
               (cons 
                (JAVA::toPretty " ") 
                (cons 
                 (JAVA::ppBinExp (svref pV4 2)) 
                 (cons (JAVA::toPretty " )") nil)))))))))) 
       (if (eq (car be) :|InstOf|) 
           (let ((pV3 (cdr be))) 
             (return 
              (PRETTYPRINT::prettysNone 
               (cons 
                (JAVA::toPretty "( ") 
                (cons 
                 (JAVA::ppBinExp (car pV3)) 
                 (cons 
                  (JAVA::toPretty " instanceof ") 
                  (cons 
                   (JAVA::ppType-1 (cdr pV3)) 
                   (cons (JAVA::toPretty " )") nil)))))))) 
           (if (eq (car be) :|Un|) (return (JAVA::ppUnExp (cdr be)))))) 
   (error "Nonexhaustive match failure in ppBinExp")))

(defun JAVA::ppCondExp (be |!rest|) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::ppBinExp be) 
    (cons 
     (block 
      nil 
      (if (eq (car |!rest|) :|None|) 
          (return (PRETTYPRINT::emptyPretty)) 
          (if (eq (car |!rest|) :|Some|) 
              (let ((pV2 (cdr |!rest|))) 
                (return 
                 (PRETTYPRINT::prettysNone 
                  (cons 
                   (JAVA::toPretty " ? ") 
                   (cons 
                    (JAVA::ppExpr (car pV2)) 
                    (cons 
                     (JAVA::toPretty " : ") 
                     (cons (JAVA::ppCondExp-1 (cdr pV2)) nil))))))))) 
      (error "Nonexhaustive match failure in ppCondExp")) 
     nil))))

(defun JAVA::ppCondExp-1 (x) (JAVA::ppCondExp (car x) (cdr x)))

(defun JAVA::ppExpr (e) 
  (block 
   nil 
   (if (eq (car e) :|Ass|) 
       (return (JAVA::ppAss-1 (cdr e))) 
       (if (eq (car e) :|CondExp|) (return (JAVA::ppCondExp-1 (cdr e))))) 
   (error "Nonexhaustive match failure in ppExpr")))

(defun JAVA::ppArrAcc (aa) 
  (block 
   nil 
   (if (eq (car aa) :|ViaName|) 
       (let ((pV3 (cdr aa))) 
         (return 
          (PRETTYPRINT::prettysNone 
           (cons 
            (JAVA::ppName-1 (car pV3)) 
            (cons 
             (JAVA::toPretty " [ ") 
             (cons (JAVA::ppExpr (cdr pV3)) (cons (JAVA::toPretty " ]") nil))))))) 
       (if (eq (car aa) :|ViaNoNewArray|) 
           (let ((pV2 (cdr aa))) 
             (return 
              (PRETTYPRINT::prettysNone 
               (cons 
                (JAVA::ppPrim (car pV2)) 
                (cons 
                 (JAVA::toPretty " [ ") 
                 (cons (JAVA::ppExpr (cdr pV2)) (cons (JAVA::toPretty " ]") nil))))))))) 
   (error "Nonexhaustive match failure in ppArrAcc")))

(defun JAVA::ppClsBody (x0 x1 x2 x3 x4 x5) 
  (JAVA::ppClsBody-1 (vector x0 x1 x2 x3 x4 x5)))

(defun JAVA::ppClsOrInterfDecl (cid) 
  (block 
   nil 
   (if (eq (car cid) :|ClsDecl|) 
       (return (JAVA::ppClsDecl-1 (cdr cid))) 
       (if (eq (car cid) :|InterfDecl|) 
           (return (JAVA::ppInterfDecl-1 (cdr cid))))) 
   (error "Nonexhaustive match failure in ppClsOrInterfDecl")))

(defun JAVA::ppImports (ims) 
  (PRETTYPRINT::prettysAll 
   (LIST-SPEC::|!map|-1-1 
    #'(lambda (nm) 
       (PRETTYPRINT::prettysNone 
        (cons 
         (JAVA::toPretty "import ") 
         (cons (JAVA::ppName-1 nm) (cons (JAVA::toPretty ";") nil))))) 
    ims)))

(defun JAVA::ppPackageName-1 (nm) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (JAVA::toPretty "package ") 
    (cons (JAVA::ppName-1 nm) (cons (JAVA::toPretty ";") nil)))))

(defun JAVA::ppCompUnit (pn ims cids) 
  (let ((pnps 
         (block 
          nil 
          (if (eq (car pn) :|None|) 
              (return nil) 
              (if (eq (car pn) :|Some|) 
                  (return 
                   (JAVA::addEmpty (cons (JAVA::ppPackageName-1 (cdr pn)) nil))))) 
          (error "Nonexhaustive match failure in ppCompUnit")))) 
    (let ((imsps 
           (if (slang-built-in::slang-term-equals ims nil) 
               nil 
               (JAVA::addEmpty (cons (JAVA::ppImports ims) nil))))) 
      (PRETTYPRINT::prettysAll 
       (LIST-SPEC::flatten 
        (cons 
         pnps 
         (cons 
          imsps 
          (cons 
           (JAVA::addEmpty 
            (JAVA::addEmptys 
             (LIST-SPEC::|!map|-1-1 #'JAVA::ppClsOrInterfDecl cids))) 
           nil))))))))

(defun JAVA::ppCompUnit-1 (x) 
  (JAVA::ppCompUnit (svref x 0) (svref x 1) (svref x 2)))

(defun JAVA::ppInterfBody (x0 x1 x2 x3) 
  (JAVA::ppInterfBody-1 (vector x0 x1 x2 x3)))

(defun JAVA::ppPackageName (x0 x1) (JAVA::ppPackageName-1 (cons x0 x1)))

(defun JAVA::qualName-1 (x) (JAVA::qualName (car x) (cdr x)))

(defun JAVA::testcls1 (n) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| n (JAVA::ppCompUnit-1 (JAVA::clsDecl1)))))

(defun JAVA::testitf1 (n) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| n (JAVA::ppCompUnit-1 (JAVA::itfDecl1)))))

(defun LIST-SPEC::|!++|-1 (x) (LIST-SPEC::|!++| (car x) (cdr x)))

(defun LIST-SPEC::@-1 (x) (LIST-SPEC::@ (car x) (cdr x)))

(defun LIST-SPEC::all (x1) #'(lambda (x2) (LIST-SPEC::all-1-1 x1 x2)))

(defun LIST-SPEC::app (x1) #'(lambda (x2) (LIST-SPEC::app-1-1 x1 x2)))

(defun LIST-SPEC::compare-1-1 (comp x) 
  (let ((l1 (car x))
        (l2 (cdr x))) 
    (block 
     nil 
     (if (null l1) 
         (if (null l2) (return '(:|Equal|)) (if (consp l2) (return '(:|Less|)))) 
         (if (consp l1) 
             (if (consp l2) 
                 (return 
                  (let ((pV1 (funcall comp (cons (car l1) (car l2))))) 
                    (block 
                     nil 
                     (if (eq (car pV1) :|Equal|) 
                         (return 
                          (LIST-SPEC::compare-1-1 comp (cons (cdr l1) (cdr l2))))) 
                     (return pV1)))) 
                 (if (null l2) (return '(:|Greater|)))))) 
     (error "Nonexhaustive match failure in compare"))))

(defun LIST-SPEC::compare (x1) 
  #'(lambda (x2) (LIST-SPEC::compare-1-1 x1 x2)))

(defun LIST-SPEC::concat-1 (x) (LIST-SPEC::concat (car x) (cdr x)))

(defun LIST-SPEC::|!cons|-1 (x) (LIST-SPEC::|!cons| (car x) (cdr x)))

(defun LIST-SPEC::diff (s1 s2) 
  (block 
   nil 
   (if (null s1) 
       (return nil) 
       (if (consp s1) 
           (let ((pV4 (cdr s1))
                 (pV3 (car s1))) 
             (return 
              (if (LIST-SPEC::|!member| pV3 s2) 
                  (LIST-SPEC::diff pV4 s2) 
                  (cons pV3 (LIST-SPEC::diff pV4 s2))))))) 
   (error "Nonexhaustive match failure in diff")))

(defun LIST-SPEC::diff-1 (x) (LIST-SPEC::diff (car x) (cdr x)))

(defun LIST-SPEC::|!exists| (x1) 
  #'(lambda (x2) (LIST-SPEC::|!exists|-1-1 x1 x2)))

(defun LIST-SPEC::filter (x1) #'(lambda (x2) (LIST-SPEC::filter-1-1 x1 x2)))

(defun LIST-SPEC::|!find| (x1) 
  #'(lambda (x2) (LIST-SPEC::|!find|-1-1 x1 x2)))

(defun LIST-SPEC::firstUpToHelper (p l res) 
  (block 
   nil 
   (if (null l) 
       (return '(:|None|)) 
       (if (consp l) 
           (let ((pV3 (car l))) 
             (return 
              (if (funcall p pV3) 
                  (cons :|Some| (cons pV3 res)) 
                  (LIST-SPEC::firstUpToHelper p (cdr l) (cons pV3 res))))))) 
   (error "Nonexhaustive match failure in firstUpToHelper")))

(defun LIST-SPEC::firstUpTo-1-1 (p l) (LIST-SPEC::firstUpToHelper p l nil))

(defun LIST-SPEC::firstUpTo (x1) 
  #'(lambda (x2) (LIST-SPEC::firstUpTo-1-1 x1 x2)))

(defun LIST-SPEC::firstUpToHelper-1 (x) 
  (LIST-SPEC::firstUpToHelper (svref x 0) (svref x 1) (svref x 2)))

(defun LIST-SPEC::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (LIST-SPEC::foldl-1-1-1 x1 x2 x3))))

(defun LIST-SPEC::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (LIST-SPEC::foldr-1-1-1 x1 x2 x3))))

(defun LIST-SPEC::insert (hd tl) (cons hd tl))

(defun LIST-SPEC::insert-1 (x) (LIST-SPEC::insert (car x) (cdr x)))

(defun LIST-SPEC::|!map| (x1) #'(lambda (x2) (LIST-SPEC::|!map|-1-1 x1 x2)))

(defun LIST-SPEC::mapPartial-1-1 (f l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV6 (cdr l))) 
             (return 
              (let ((pV1 (funcall f (car l)))) 
                (block 
                 nil 
                 (if (eq (car pV1) :|Some|) 
                     (return (cons (cdr pV1) (LIST-SPEC::mapPartial-1-1 f pV6))) 
                     (if (eq (car pV1) :|None|) 
                         (return (LIST-SPEC::mapPartial-1-1 f pV6)))) 
                 (error "Nonexhaustive match failure in mapPartial"))))))) 
   (error "Nonexhaustive match failure in mapPartial")))

(defun LIST-SPEC::mapPartial (x1) 
  #'(lambda (x2) (LIST-SPEC::mapPartial-1-1 x1 x2)))

(defun LIST-SPEC::|!member|-1 (x) (LIST-SPEC::|!member| (car x) (cdr x)))

(defparameter LIST-SPEC::|!nil| nil)

(defun LIST-SPEC::|!nth|-1 (x) (LIST-SPEC::|!nth| (car x) (cdr x)))

(defun LIST-SPEC::nthTail (ls i) 
  (block 
   nil 
   (if (null ls) 
       (return nil) 
       (if (consp ls) 
           (let ((pV4 (cdr ls))) 
             (return 
              (if ( =  i 0) 
                  pV4 
                  (LIST-SPEC::nthTail pV4 (INTEGER-SPEC::|!-| i 1))))))) 
   (error "Nonexhaustive match failure in nthTail")))

(defun LIST-SPEC::nthTail-1 (x) (LIST-SPEC::nthTail (car x) (cdr x)))

(defun LIST-SPEC::rev2-1 (x) (LIST-SPEC::rev2 (car x) (cdr x)))

(defun LIST-SPEC::show-1-1 (sep l) 
  (block 
   nil 
   (if (null l) 
       (return "") 
       (if (consp l) 
           (let ((pV3 (car l))
                 (pV4 (cdr l))) 
             (progn (if (null pV4) (return pV3)) 
                    (return 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ pV3 sep) 
                      (LIST-SPEC::show-1-1 sep pV4))))))) 
   (error "Nonexhaustive match failure in show")))

(defun LIST-SPEC::show (x1) #'(lambda (x2) (LIST-SPEC::show-1-1 x1 x2)))

(defun LIST-SPEC::splitList (x1) 
  #'(lambda (x2) (LIST-SPEC::splitList-1-1 x1 x2)))

(defun LIST-SPEC::splitListHelper-1 (x) 
  (LIST-SPEC::splitListHelper (svref x 0) (svref x 1) (svref x 2)))

(defun LIST-SPEC::tabulate (n f) 
  (labels 
    ((tabulateRec (m tl) 
      (if (INTEGER-SPEC::|!<| m 0) 
          tl 
          (tabulateRec 
           (INTEGER-SPEC::|!-| m 1) 
           (LIST-SPEC::|!cons| (funcall f m) tl))))) 
    (tabulateRec (INTEGER-SPEC::|!-| n 1) nil)))

(defun LIST-SPEC::tabulate-1 (x) (LIST-SPEC::tabulate (car x) (cdr x)))

(defun LISTADT::addDefinition (modulename defn |!lspc|) 
  (let ((mname (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase modulename))) 
    (let ((sname 
           (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase (svref |!lspc| 2)))) 
      (if (string=  mname sname) 
          (vector 
           (svref |!lspc| 0) 
           (svref |!lspc| 1) 
           (svref |!lspc| 2) 
           (LIST-SPEC::|!cons| defn (svref |!lspc| 3)) 
           (svref |!lspc| 4)) 
          |!lspc|))))

(defun LISTADT::addDefinition-1 (x) 
  (LISTADT::addDefinition (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::addDefinitions (defns |!lspc|) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (let ((pV1 (car x))) 
        (block 
         nil 
         (return (LISTADT::addDefinition (car pV1) (cdr pV1) (cdr x))) 
         (error "Nonexhaustive match failure in addDefinitions")))) 
   |!lspc| 
   defns))

(defun LISTADT::addDefinitions-1 (x) (LISTADT::addDefinitions (car x) (cdr x)))

(defparameter LISTADT::emptySpec (vector nil nil "BASESPECS" nil nil))

(defun LISTADT::mkDefinition (modulename name |!lispterm|) 
  (let ((|!t| (cons :|Const| (cons :|Cell| (LISP-SPEC::cell |!lispterm|))))) 
    (cons modulename (cons name |!t|))))

(defun LISTADT::mkDefinition-1 (x) 
  (LISTADT::mkDefinition (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::mkLApply (f terms) (cons :|Apply| (cons f terms)))

(defun LISTADT::mkLOp (s) (cons :|Op| s))

(defun LISTADT::mkDefinitionWithOp (modulename name |!opname| |!lispterm|) 
  (let ((|!t| 
         (LISTADT::mkLApply 
          (LISTADT::mkLOp |!opname|) 
          (cons (cons :|Const| (cons :|Cell| (LISP-SPEC::cell |!lispterm|))) nil)))) 
    (cons modulename (cons name |!t|))))

(defun LISTADT::mkDefinitionWithOp-1 (x) 
  (LISTADT::mkDefinitionWithOp (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun LISTADT::mkLApply-1 (x) (LISTADT::mkLApply (car x) (cdr x)))

(defun LISTADT::mkLBool (b) (cons :|Const| (cons :|Boolean| b)))

(defun LISTADT::mkLChar (ch) (cons :|Const| (cons :|Char| ch)))

(defun LISTADT::mkLIf (t1 t2 t3) (cons :|If| (vector t1 t2 t3)))

(defun LISTADT::mkLIf-1 (x) 
  (LISTADT::mkLIf (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::mkLNat (n) (cons :|Const| (cons :|Nat| n)))

(defun LISTADT::mkLInt (n) 
  (if (INTEGER-SPEC::|!>=| n 0) 
      (LISTADT::mkLNat n) 
      (LISTADT::mkLApply 
       (LISTADT::mkLOp "-") 
       (cons (LISTADT::mkLNat (INTEGER-SPEC::~ n)) nil))))

(defun LISTADT::mkLIntern (s) 
  (cons 
   :|Const| 
   (cons :|Parameter| (STRING-SPEC::^ (STRING-SPEC::^ ":|" s) "|"))))

(defun LISTADT::mkLLambda (args decls body) 
  (cons :|Lambda| (vector args decls body)))

(defun LISTADT::mkLLambda-1 (x) 
  (LISTADT::mkLLambda (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::mkLLet (vars terms term) 
  (if (LIST-SPEC::|!null| vars) term (cons :|Let| (vector vars terms term))))

(defun LISTADT::mkLLet-1 (x) 
  (LISTADT::mkLLet (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::mkLLetRec (vars terms term) 
  (cons :|Letrec| (vector vars terms term)))

(defun LISTADT::mkLLetRec-1 (x) 
  (LISTADT::mkLLetRec (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::mkLQuote (id) (LISTADT::mkLOp (STRING-SPEC::^ "'" id)))

(defun LISTADT::mkLSeq (terms) (cons :|Seq| terms))

(defun LISTADT::mkLString (s) 
  (cons :|Const| (cons :|String| (IO-SPEC::formatString1 "~S" s))))

(defun LISTADT::mkLVar (s) (cons :|Var| s))

(defun LISTADT::oldMkLString (s) 
  (STRING-SPEC::translate-1-1 
   #'(lambda (pV1) 
      (block 
       nil 
       (if (eq #\" pV1) (return "\\\"") (if (eq #\\ pV1) (return "\\\\"))) 
       (return (CHAR-SPEC::toString pV1)))) 
   s))

(defun LISTADT::ops-1 (x) (LISTADT::ops (car x) (cdr x)))

(defun LISTADT::ops (term names) 
  (block 
   nil 
   (if (eq (car term) :|Const|) 
       (let ((pV19 (cdr term))) 
         (progn (if (eq (car pV19) :|Parameter|) 
                    (return (STRINGSET::add names (cdr pV19)))) 
                (return names))) 
       (if (eq (car term) :|Op|) 
           (return (STRINGSET::add names (cdr term))) 
           (if (eq (car term) :|Var|) 
               (return names) 
               (if (eq (car term) :|Set|) 
                   (return (LISTADT::ops (cdr (cdr term)) names)) 
                   (if (eq (car term) :|Lambda|) 
                       (return (LISTADT::ops (svref (cdr term) 2) names)) 
                       (if (eq (car term) :|Apply|) 
                           (let ((pV14 (cdr term))) 
                             (return 
                              (LIST-SPEC::foldr-1-1-1 
                               #'LISTADT::ops-1 
                               (LISTADT::ops (car pV14) names) 
                               (cdr pV14)))) 
                           (if (eq (car term) :|If|) 
                               (let ((pV13 (cdr term))) 
                                 (return 
                                  (LISTADT::ops 
                                   (svref pV13 0) 
                                   (LISTADT::ops 
                                    (svref pV13 1) 
                                    (LISTADT::ops (svref pV13 2) names))))) 
                               (if (eq (car term) :|IfThen|) 
                                   (let ((pV12 (cdr term))) 
                                     (return 
                                      (LISTADT::ops 
                                       (car pV12) 
                                       (LISTADT::ops (cdr pV12) names)))) 
                                   (if (eq (car term) :|Let|) 
                                       (let ((pV11 (cdr term))) 
                                         (return 
                                          (LIST-SPEC::foldr-1-1-1 
                                           #'LISTADT::ops-1 
                                           (LISTADT::ops (svref pV11 2) names) 
                                           (svref pV11 1)))) 
                                       (if (eq (car term) :|Letrec|) 
                                           (let ((pV10 (cdr term))) 
                                             (return 
                                              (LIST-SPEC::foldr-1-1-1 
                                               #'LISTADT::ops-1 
                                               (LISTADT::ops 
                                                (svref pV10 2) 
                                                names) 
                                               (svref pV10 1)))) 
                                           (if (eq (car term) :|Seq|) 
                                               (return 
                                                (LIST-SPEC::foldr-1-1-1 
                                                 #'LISTADT::ops-1 
                                                 names 
                                                 (cdr term)))))))))))))) 
   (error "Nonexhaustive match failure in ops")))

(defun LISTADT::ppDecl (decl) 
  (block 
   nil 
   (if (eq (car decl) :|Ignore|) 
       (return 
        (PRETTYPRINT::prettysLinearDelim-1-1 
         (vector "(declare (ignore " " " ")) ") 
         (LIST-SPEC::|!map|-1-1 #'PRETTYPRINT::|!string| (cdr decl))))) 
   (error "Nonexhaustive match failure in ppDecl")))

(defun PRETTYPRINT::prettysAllDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysAll delims ps))

(defun PRETTYPRINT::prettysFillDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysFill delims ps))

(defun LISTADT::ppTerm (|!t|) 
  (block 
   nil 
   (if (eq (car |!t|) :|Const|) 
       (let ((pV28 (cdr |!t|))) 
         (return 
          (block 
           nil 
           (if (eq (car pV28) :|Boolean|) 
               (return (PRETTYPRINT::|!string| (if (cdr pV28) "t" "nil"))) 
               (if (eq (car pV28) :|Nat|) 
                   (return 
                    (PRETTYPRINT::|!string| (NAT-SPEC::toString (cdr pV28)))) 
                   (if (eq (car pV28) :|Char|) 
                       (return 
                        (PRETTYPRINT::strings 
                         (cons "#\\" (cons (CHAR-SPEC::toString (cdr pV28)) nil)))) 
                       (if (eq (car pV28) :|String|) 
                           (return (PRETTYPRINT::|!string| (cdr pV28))) 
                           (if (eq (car pV28) :|Symbol|) 
                               (let ((pV4 (cdr pV28))) 
                                 (return 
                                  (PRETTYPRINT::strings 
                                   (cons 
                                    "'" 
                                    (cons 
                                     (car pV4) 
                                     (cons "::" (cons (cdr pV4) nil))))))) 
                               (if (eq (car pV28) :|Cell|) 
                                   (return 
                                    (PRETTYPRINT::strings 
                                     (cons 
                                      "'" 
                                      (cons 
                                       (SYSTEM-SPEC::toString (cdr pV28)) 
                                       nil)))) 
                                   (if (eq (car pV28) :|Parameter|) 
                                       (return 
                                        (PRETTYPRINT::|!string| (cdr pV28)))))))))) 
           (error "Nonexhaustive match failure in ppTerm")))) 
       (if (eq (car |!t|) :|Op|) 
           (return (PRETTYPRINT::strings (cons "#'" (cons (cdr |!t|) nil)))) 
           (if (eq (car |!t|) :|Var|) 
               (return (PRETTYPRINT::|!string| (cdr |!t|))) 
               (if (eq (car |!t|) :|Set|) 
                   (let ((pV25 (cdr |!t|))) 
                     (return 
                      (PRETTYPRINT::blockFill 
                       0 
                       (cons 
                        (cons 
                         0 
                         (PRETTYPRINT::strings 
                          (cons "(setq " (cons (car pV25) (cons " " nil))))) 
                        (cons 
                         (cons 
                          2 
                          (PRETTYPRINT::prettysNone 
                           (cons 
                            (LISTADT::ppTerm (cdr pV25)) 
                            (cons (PRETTYPRINT::|!string| ")") nil)))) 
                         nil))))) 
                   (if (eq (car |!t|) :|Lambda|) 
                       (let ((pV24 (cdr |!t|))) 
                         (return 
                          (PRETTYPRINT::blockFill 
                           0 
                           (cons 
                            (cons 
                             0 
                             (PRETTYPRINT::prettysLinearDelim-1-1 
                              (vector "#'(lambda (" " " ") ") 
                              (LIST-SPEC::|!map|-1-1 
                               #'PRETTYPRINT::|!string| 
                               (svref pV24 0)))) 
                            (cons 
                             (cons 
                              3 
                              (PRETTYPRINT::prettysAll 
                               (LIST-SPEC::@ 
                                (LIST-SPEC::|!map|-1-1 
                                 #'LISTADT::ppDecl 
                                 (svref pV24 1)) 
                                (cons 
                                 (PRETTYPRINT::prettysNone 
                                  (cons 
                                   (LISTADT::ppTerm (svref pV24 2)) 
                                   (cons (PRETTYPRINT::|!string| ")") nil))) 
                                 nil)))) 
                             nil))))) 
                       (if (eq (car |!t|) :|Apply|) 
                           (let ((pV23 (cdr |!t|))) 
                             (let ((pV41 (cdr pV23))
                                   (pV40 (car pV23))) 
                               (progn (if (eq (car pV40) :|Op|) 
                                          (let ((pV42 (cdr pV40))) 
                                            (progn (if (string=  "list" pV42) 
                                                       (if (consp pV41) 
                                                           (let ((pV44 
                                                                  (car pV41))) 
                                                             (if (eq 
                                                                  (car pV44) 
                                                                  :|Const|) 
                                                                 (let ((pV46 
                                                                        (cdr 
                                                                         pV44))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV46) 
                                                                        :|Parameter|) 
                                                                       (let ((pV47 
                                                                              (cdr 
                                                                               pV46))) 
                                                                         (if (null 
                                                                              (cdr 
                                                                               pV41)) 
                                                                             (return 
                                                                              (if (eq 
                                                                                   (STRING-SPEC::sub 
                                                                                    pV47 
                                                                                    0) 
                                                                                   #\:) 
                                                                                  (PRETTYPRINT::strings 
                                                                                   (cons 
                                                                                    "'(" 
                                                                                    (cons 
                                                                                     pV47 
                                                                                     (cons 
                                                                                      ")" 
                                                                                      nil)))) 
                                                                                  (PRETTYPRINT::strings 
                                                                                   (cons 
                                                                                    "(list " 
                                                                                    (cons 
                                                                                     pV47 
                                                                                     (cons 
                                                                                      ")" 
                                                                                      nil)))))))))))))) 
                                                   (return 
                                                    (PRETTYPRINT::prettysLinearDelim-1-1 
                                                     (vector "(" " " ")") 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       pV42) 
                                                      (LIST-SPEC::|!map|-1-1 
                                                       #'LISTADT::ppTerm 
                                                       pV41))))))) 
                                      (return 
                                       (PRETTYPRINT::prettysLinearDelim-1-1 
                                        (vector "(funcall " " " ")") 
                                        (cons 
                                         (LISTADT::ppTerm pV40) 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'LISTADT::ppTerm 
                                          pV41))))))) 
                           (if (eq (car |!t|) :|If|) 
                               (let ((pV22 (cdr |!t|))) 
                                 (return 
                                  (PRETTYPRINT::prettysLinearDelim-1-1 
                                   (vector "(if " " " ")") 
                                   (cons 
                                    (LISTADT::ppTerm (svref pV22 0)) 
                                    (cons 
                                     (LISTADT::ppTerm (svref pV22 1)) 
                                     (cons (LISTADT::ppTerm (svref pV22 2)) nil)))))) 
                               (if (eq (car |!t|) :|IfThen|) 
                                   (let ((pV21 (cdr |!t|))) 
                                     (return 
                                      (PRETTYPRINT::prettysLinearDelim-1-1 
                                       (vector "(if " " " ")") 
                                       (cons 
                                        (LISTADT::ppTerm (car pV21)) 
                                        (cons (LISTADT::ppTerm (cdr pV21)) nil))))) 
                                   (if (eq (car |!t|) :|Let|) 
                                       (let ((pV20 (cdr |!t|))) 
                                         (return 
                                          (PRETTYPRINT::blockFill 
                                           0 
                                           (cons 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::prettysAllDelim-1-1 
                                              (vector "(let (" "" ") ") 
                                              (LISTPAIR::|!map|-1-1 
                                               #'(lambda (x) 
                                                  (PRETTYPRINT::prettysFillDelim-1-1 
                                                   (vector "(" " " ")") 
                                                   (cons 
                                                    (PRETTYPRINT::|!string| 
                                                     (car x)) 
                                                    (cons 
                                                     (LISTADT::ppTerm (cdr x)) 
                                                     nil)))) 
                                               (cons 
                                                (svref pV20 0) 
                                                (svref pV20 1))))) 
                                            (cons 
                                             (cons 
                                              2 
                                              (PRETTYPRINT::prettysNone 
                                               (cons 
                                                (LISTADT::ppTerm (svref pV20 2)) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| ")") 
                                                 nil)))) 
                                             nil))))) 
                                       (if (eq (car |!t|) :|Letrec|) 
                                           (let ((pV19 (cdr |!t|))) 
                                             (return 
                                              (PRETTYPRINT::blockFill 
                                               0 
                                               (cons 
                                                (cons 
                                                 0 
                                                 (PRETTYPRINT::|!string| 
                                                  "(labels ")) 
                                                (cons 
                                                 (cons 
                                                  2 
                                                  (PRETTYPRINT::prettysAllDelim-1-1 
                                                   (vector "(" "" ") ") 
                                                   (LISTPAIR::|!map|-1-1 
                                                    #'(lambda (x) 
                                                       (let ((pV12 (cdr x))) 
                                                         (block 
                                                          nil 
                                                          (if (eq 
                                                               (car pV12) 
                                                               :|Lambda|) 
                                                              (let ((pV13 
                                                                     (cdr pV12))) 
                                                                (return 
                                                                 (PRETTYPRINT::prettysFillDelim-1-1 
                                                                  (vector 
                                                                   "(" 
                                                                   " " 
                                                                   ")") 
                                                                  (cons 
                                                                   (PRETTYPRINT::|!string| 
                                                                    (car x)) 
                                                                   (cons 
                                                                    (PRETTYPRINT::prettysLinearDelim-1-1 
                                                                     (vector 
                                                                      "(" 
                                                                      " " 
                                                                      ")") 
                                                                     (LIST-SPEC::|!map|-1-1 
                                                                      #'PRETTYPRINT::|!string| 
                                                                      (svref 
                                                                       pV13 
                                                                       0))) 
                                                                    (cons 
                                                                     (PRETTYPRINT::prettysAll 
                                                                      (LIST-SPEC::@ 
                                                                       (LIST-SPEC::|!map|-1-1 
                                                                        #'LISTADT::ppDecl 
                                                                        (svref 
                                                                         pV13 
                                                                         1)) 
                                                                       (cons 
                                                                        (PRETTYPRINT::prettysNone 
                                                                         (cons 
                                                                          (LISTADT::ppTerm 
                                                                           (svref 
                                                                            pV13 
                                                                            2)) 
                                                                          nil)) 
                                                                        nil))) 
                                                                     nil))))))) 
                                                          (error 
                                                           "Nonexhaustive match failure in ppTerm")))) 
                                                    (cons 
                                                     (svref pV19 0) 
                                                     (svref pV19 1))))) 
                                                 (cons 
                                                  (cons 
                                                   2 
                                                   (PRETTYPRINT::prettysNone 
                                                    (cons 
                                                     (LISTADT::ppTerm 
                                                      (svref pV19 2)) 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       ")") 
                                                      nil)))) 
                                                  nil)))))) 
                                           (if (eq (car |!t|) :|Seq|) 
                                               (return 
                                                (PRETTYPRINT::prettysLinearDelim-1-1 
                                                 (vector "(progn " " " ")") 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'LISTADT::ppTerm 
                                                  (cdr |!t|))))))))))))))) 
   (error "Nonexhaustive match failure in ppTerm")))

(defun LISTADT::ppOpDefn (s term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (let ((pV3 (cdr term))) 
         (return 
          (PRETTYPRINT::blockFill 
           0 
           (cons 
            (cons 0 (PRETTYPRINT::|!string| "(defun ")) 
            (cons 
             (cons 0 (PRETTYPRINT::|!string| s)) 
             (cons 
              (cons 
               0 
               (PRETTYPRINT::prettysLinearDelim-1-1 
                (vector " (" " " ") ") 
                (LIST-SPEC::|!map|-1-1 #'PRETTYPRINT::|!string| (svref pV3 0)))) 
              (cons 
               (cons 
                2 
                (PRETTYPRINT::prettysAll 
                 (LIST-SPEC::@ 
                  (LIST-SPEC::|!map|-1-1 #'LISTADT::ppDecl (svref pV3 1)) 
                  (cons 
                   (PRETTYPRINT::prettysNone 
                    (cons 
                     (LISTADT::ppTerm (svref pV3 2)) 
                     (cons (PRETTYPRINT::|!string| ")") nil))) 
                   nil)))) 
               (cons (cons 0 (PRETTYPRINT::newline)) nil))))))))) 
   (return 
    (PRETTYPRINT::blockFill 
     0 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "(defparameter ")) 
      (cons 
       (cons 0 (PRETTYPRINT::|!string| s)) 
       (cons 
        (cons 0 (PRETTYPRINT::|!string| " ")) 
        (cons 
         (cons 
          2 
          (PRETTYPRINT::prettysNone 
           (cons (LISTADT::ppTerm term) (cons (PRETTYPRINT::|!string| ")") nil)))) 
         (cons (cons 0 (PRETTYPRINT::newline)) nil)))))))))

(defun LISTADT::ppOpDefn-1 (x) (LISTADT::ppOpDefn (car x) (cdr x)))

(defun LISTADT::section (title ps) 
  (cons 
   (PRETTYPRINT::emptyPretty) 
   (cons (PRETTYPRINT::|!string| title) (cons (PRETTYPRINT::emptyPretty) ps))))

(defun STRINGSET::listItems (x) (SPLAYSET::listItems x))

(defun LISTADT::sortDefs (defs) 
  (let ((defMap 
         (LIST-SPEC::foldr-1-1-1 
          #'(lambda (x) 
             (let ((pV1 (car x))) 
               (block 
                nil 
                (let ((pV3 (car pV1))) 
                  (return (STRINGMAP::insert (cdr x) pV3 (cons pV3 (cdr pV1))))) 
                (error "Nonexhaustive match failure in sortDefs")))) 
          STRINGMAP::empty 
          defs))) 
    (let ((|!map| 
           (LIST-SPEC::foldr-1-1-1 
            #'(lambda (x) 
               (let ((pV5 (car x))) 
                 (block 
                  nil 
                  (return 
                   (let ((opers (LISTADT::ops (cdr pV5) STRINGSET::empty))) 
                     (let ((opers (STRINGSET::listItems opers))) 
                       (STRINGMAP::insert (cdr x) (car pV5) opers)))) 
                  (error "Nonexhaustive match failure in sortDefs")))) 
            STRINGMAP::empty 
            defs))) 
      (let ((names 
             (TOPSORT::topSort 
              '(:|EQUAL|) 
              #'(lambda (name) 
                 (let ((pV9 (STRINGMAP::|!find| |!map| name))) 
                   (block 
                    nil 
                    (if (eq (car pV9) :|None|) 
                        (return nil) 
                        (if (eq (car pV9) :|Some|) (return (cdr pV9)))) 
                    (error "Nonexhaustive match failure in sortDefs")))) 
              (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) defs)))) 
        (let ((defs 
               (LIST-SPEC::mapPartial-1-1 
                #'(lambda (name1) (STRINGMAP::|!find| defMap name1)) 
                names))) defs)))))

(defun LISTADT::ppSpec-1 (s) 
  (let ((defs (LISTADT::sortDefs (svref s 3)))) 
    (let ((name (svref s 2))) 
      (PRETTYPRINT::prettysAll 
       (LIST-SPEC::|!++| 
        (LISTADT::section 
         ";;; Lisp spec" 
         (LIST-SPEC::|!++| 
          (LIST-SPEC::|!map|-1-1 
           #'(lambda (pkgName) 
              (PRETTYPRINT::|!string| 
               (STRING-SPEC::^ (STRING-SPEC::^ "(defpackage \"" pkgName) "\")"))) 
           (svref s 1)) 
          (cons 
           (PRETTYPRINT::|!string| 
            (STRING-SPEC::^ (STRING-SPEC::^ "(defpackage \"" name) "\")")) 
           (cons 
            (PRETTYPRINT::|!string| 
             (STRING-SPEC::^ (STRING-SPEC::^ "(in-package \"" name) "\")")) 
            nil)))) 
        (LISTADT::section 
         ";;; Definitions" 
         (LIST-SPEC::|!map|-1-1 #'LISTADT::ppOpDefn-1 defs)))))))

(defun LISTADT::ppSpec (x0 x1 x2 x3 x4) 
  (LISTADT::ppSpec-1 (vector x0 x1 x2 x3 x4)))

(defun LISTADT::ppSpecToFile (spc file preamble) 
  (let ((p (LISTADT::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
      (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble)))))

(defun LISTADT::ppSpecToFile-1 (x) 
  (LISTADT::ppSpecToFile (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::ppSpecToTerminal-1 (spc) 
  (let ((p (LISTADT::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) (PRETTYPRINT::toTerminal |!t|))))


(defun LISTADT::ppSpecToTerminal (x0 x1 x2 x3 x4) 
  (LISTADT::ppSpecToTerminal-1 (vector x0 x1 x2 x3 x4)))

(defun LISTADT::ppSpecsToFile (specs file preamble) 
  (let ((ps (LIST-SPEC::|!map|-1-1 #'LISTADT::ppSpec-1 specs))) 
    (let ((p (PRETTYPRINT::prettysAll ps))) 
      (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
        (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble))))))

(defun LISTADT::ppSpecsToFile-1 (x) 
  (LISTADT::ppSpecsToFile (svref x 0) (svref x 1) (svref x 2)))

(defun LISTADT::section-1 (x) (LISTADT::section (car x) (cdr x)))

(defun LISTPAIR::all-1-1 (p x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (cl:and 
               (funcall p (cons (car l) (car r))) 
               (LISTPAIR::all-1-1 p (cons (cdr l) (cdr r))))))) 
     (return t))))

(defun LISTPAIR::all (x1) #'(lambda (x2) (LISTPAIR::all-1-1 x1 x2)))

(defun LISTPAIR::app-1-1 (f x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (progn (funcall f (cons (car l) (car r))) 
                     (LISTPAIR::app-1-1 f (cons (cdr l) (cdr r))))))) 
     (return nil))))

(defun LISTPAIR::app (x1) #'(lambda (x2) (LISTPAIR::app-1-1 x1 x2)))

(defun LISTPAIR::|!exists|-1-1 (p x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (cl:or 
               (funcall p (cons (car l) (car r))) 
               (LISTPAIR::|!exists|-1-1 p (cons (cdr l) (cdr r))))))) 
     (return nil))))

(defun LISTPAIR::|!exists| (x1) 
  #'(lambda (x2) (LISTPAIR::|!exists|-1-1 x1 x2)))

(defun LISTPAIR::foldl-1-1-1 (f u x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (LISTPAIR::foldl-1-1-1 
               f 
               (funcall f (vector (car l) (car r) u)) 
               (cons (cdr l) (cdr r)))))) 
     (return u))))

(defun LISTPAIR::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (LISTPAIR::foldl-1-1-1 x1 x2 x3))))

(defun LISTPAIR::foldr-1-1-1 (f u x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (funcall f 
                       (vector 
                        (car l) 
                        (car r) 
                        (LISTPAIR::foldr-1-1-1 f u (cons (cdr l) (cdr r)))))))) 
     (return u))))

(defun LISTPAIR::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (LISTPAIR::foldr-1-1-1 x1 x2 x3))))

(defun LISTPAIR::|!map| (x1) #'(lambda (x2) (LISTPAIR::|!map|-1-1 x1 x2)))

(defun LISTPAIR::unzip (l) 
  (labels 
    ((unzipLoop (l a b) 
      (block 
       nil 
       (if (null l) 
           (return (cons (LIST-SPEC::rev a) (LIST-SPEC::rev b))) 
           (if (consp l) 
               (let ((pV3 (car l))) 
                 (return 
                  (unzipLoop (cdr l) (cons (car pV3) a) (cons (cdr pV3) b)))))) 
       (error "Nonexhaustive match failure in unzip")))) (unzipLoop l nil nil)))

(defun LISTPAIR::zip-1 (x) (LISTPAIR::zip (car x) (cdr x)))

(defun LISTUTILITIES::appi-1-1 (f xs) 
  (labels 
    ((|!loop| (i xs) 
      (block 
       nil 
       (if (null xs) 
           (return nil) 
           (if (consp xs) 
               (return 
                (progn (funcall f (cons i (car xs))) 
                       (|!loop| (INTEGER-SPEC::|!+| i 1) (cdr xs)))))) 
       (error "Nonexhaustive match failure in appi")))) (|!loop| 0 xs)))

(defun LISTUTILITIES::appi (x1) 
  #'(lambda (x2) (LISTUTILITIES::appi-1-1 x1 x2)))

(defun LISTUTILITIES::split (test l) 
  (labels 
    ((splitAux (l trues falses) 
      (block 
       nil 
       (if (null l) 
           (return (cons (LIST-SPEC::rev trues) (LIST-SPEC::rev falses))) 
           (if (consp l) 
               (let ((pV4 (cdr l))
                     (pV3 (car l))) 
                 (return 
                  (if (funcall test pV3) 
                      (splitAux pV4 (cons pV3 trues) falses) 
                      (splitAux pV4 trues (cons pV3 falses))))))) 
       (error "Nonexhaustive match failure in split")))) (splitAux l nil nil)))

(defun LISTUTILITIES::collectDuplicates (l eqTest) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV6 (car l))) 
             (return 
              (let ((pV1 
                     (LISTUTILITIES::split 
                      #'(lambda (e) (funcall eqTest (cons pV6 e))) 
                      (cdr l)))) 
                (block 
                 nil 
                 (let ((pV3 (cdr pV1))) 
                   (return 
                    (if (LIST-SPEC::|!null| (car pV1)) 
                        (LISTUTILITIES::collectDuplicates pV3 eqTest) 
                        (cons pV6 (LISTUTILITIES::collectDuplicates pV3 eqTest))))) 
                 (error "Nonexhaustive match failure in collectDuplicates"))))))) 
   (error "Nonexhaustive match failure in collectDuplicates")))

(defun LISTUTILITIES::collectDuplicates-1 (x) 
  (LISTUTILITIES::collectDuplicates (car x) (cdr x)))

(defun LISTUTILITIES::deleteNth-1 (x) 
  (LISTUTILITIES::deleteNth (car x) (cdr x)))

(defun LISTUTILITIES::drop (n es) 
  (if ( =  n 0) 
      es 
      (block 
       nil 
       (if (null es) 
           (return nil) 
           (if (consp es) 
               (return (LISTUTILITIES::drop (INTEGER-SPEC::|!-| n 1) (cdr es))))) 
       (error "Nonexhaustive match failure in drop"))))

(defun LISTUTILITIES::drop-1 (x) (LISTUTILITIES::drop (car x) (cdr x)))

(defun LISTUTILITIES::enumerate (i j) 
  (if (INTEGER-SPEC::|!>| i j) 
      nil 
      (cons i (LISTUTILITIES::enumerate (INTEGER-SPEC::|!+| i 1) j))))

(defun LISTUTILITIES::enumerate-1 (x) 
  (LISTUTILITIES::enumerate (car x) (cdr x)))

(defun LISTUTILITIES::findIndex (x1) 
  #'(lambda (x2) (LISTUTILITIES::findIndex-1-1 x1 x2)))

(defun LISTUTILITIES::findOption-1-1 (f l) 
  (block 
   nil 
   (if (null l) 
       (return '(:|None|)) 
       (if (consp l) 
           (return 
            (let ((pV1 (funcall f (car l)))) 
              (block 
               nil 
               (if (eq (car pV1) :|None|) 
                   (return (LISTUTILITIES::findOption-1-1 f (cdr l)))) 
               (return pV1)))))) 
   (error "Nonexhaustive match failure in findOption")))

(defun LISTUTILITIES::findOption (x1) 
  #'(lambda (x2) (LISTUTILITIES::findOption-1-1 x1 x2)))

(defun LISTUTILITIES::findOptionIndexRec (f xs i) 
  (block 
   nil 
   (if (null xs) 
       (return '(:|None|)) 
       (if (consp xs) 
           (return 
            (let ((pV1 (funcall f (cons (car xs) i)))) 
              (block 
               nil 
               (if (eq (car pV1) :|Some|) 
                   (return (cons :|Some| (cons i (cdr pV1)))) 
                   (if (eq (car pV1) :|None|) 
                       (return 
                        (LISTUTILITIES::findOptionIndexRec 
                         f 
                         (cdr xs) 
                         (INTEGER-SPEC::|!+| i 1))))) 
               (error "Nonexhaustive match failure in findOptionIndexRec")))))) 
   (error "Nonexhaustive match failure in findOptionIndexRec")))

(defun LISTUTILITIES::findOptionIndex-1-1 (f l) 
  (LISTUTILITIES::findOptionIndexRec f l 0))

(defun LISTUTILITIES::findOptionIndex (x1) 
  #'(lambda (x2) (LISTUTILITIES::findOptionIndex-1-1 x1 x2)))

(defun LISTUTILITIES::findOptionIndexRec-1 (x) 
  (LISTUTILITIES::findOptionIndexRec (svref x 0) (svref x 1) (svref x 2)))

(defun LISTUTILITIES::flatMap (f) 
  (labels 
    ((|!loop| (l) 
      (block 
       nil 
       (if (null l) 
           (return nil) 
           (if (consp l) 
               (return (LIST-SPEC::@ (funcall f (car l)) (|!loop| (cdr l)))))) 
       (error "Nonexhaustive match failure in flatMap")))) #'|!loop|))

(defun LISTUTILITIES::flatMap-1-1 (x1 x2) 
  (funcall (LISTUTILITIES::flatMap x1) x2))

(defun LISTUTILITIES::index (ls elem) 
  (labels 
    ((indexRec (ls counter) 
      (block 
       nil 
       (if (null ls) 
           (return 0) 
           (if (consp ls) 
               (return 
                (if (slang-built-in::slang-term-equals elem (car ls)) 
                    counter 
                    (indexRec (cdr ls) (INTEGER-SPEC::|!+| counter 1)))))) 
       (error "Nonexhaustive match failure in index")))) (indexRec ls 1)))

(defun LISTUTILITIES::index-1 (x) (LISTUTILITIES::index (car x) (cdr x)))

(defun LISTUTILITIES::listUnion-1 (x) 
  (LISTUTILITIES::listUnion (car x) (cdr x)))

(defun LISTUTILITIES::mapCross-1-1 (f x) 
  (let ((l2 (cdr x))) 
    (LISTUTILITIES::flatMap-1-1 
     #'(lambda (a) 
        (LIST-SPEC::|!map|-1-1 #'(lambda (b) (funcall f (cons a b))) l2)) 
     (car x))))

(defun LISTUTILITIES::mapCross (x1) 
  #'(lambda (x2) (LISTUTILITIES::mapCross-1-1 x1 x2)))

(defun LISTUTILITIES::mapWithIndex (x1) 
  #'(lambda (x2) (LISTUTILITIES::mapWithIndex-1-1 x1 x2)))

(defun LISTUTILITIES::mapWithIndexRec-1 (x) 
  (LISTUTILITIES::mapWithIndexRec (svref x 0) (svref x 1) (svref x 2)))

(defun LISTUTILITIES::mapi-1-1 (f xs) 
  (labels 
    ((|!loop| (i xs) 
      (block 
       nil 
       (if (null xs) 
           (return nil) 
           (if (consp xs) 
               (return 
                (LIST-SPEC::|!cons| 
                 (funcall f (cons i (car xs))) 
                 (|!loop| (INTEGER-SPEC::|!+| i 1) (cdr xs)))))) 
       (error "Nonexhaustive match failure in mapi")))) (|!loop| 0 xs)))

(defun LISTUTILITIES::mapi (x1) 
  #'(lambda (x2) (LISTUTILITIES::mapi-1-1 x1 x2)))

(defun LISTUTILITIES::removeDuplicates (l) 
  (block 
   nil 
   (if (null l) 
       (return l) 
       (if (consp l) 
           (return 
            (LISTUTILITIES::insert 
             (car l) 
             (LISTUTILITIES::removeDuplicates (cdr l)))))) 
   (error "Nonexhaustive match failure in removeDuplicates")))

(defun LISTUTILITIES::replaceNth (n ls elem) 
  (if ( =  n 0) 
      (cons elem (LIST-SPEC::tl ls)) 
      (cons 
       (LIST-SPEC::hd ls) 
       (LISTUTILITIES::replaceNth 
        (INTEGER-SPEC::|!-| n 1) 
        (LIST-SPEC::tl ls) 
        elem))))

(defun LISTUTILITIES::replaceNth-1 (x) 
  (LISTUTILITIES::replaceNth (svref x 0) (svref x 1) (svref x 2)))

(defun LISTUTILITIES::split-1 (x) (LISTUTILITIES::split (car x) (cdr x)))

(defun LISTUTILITIES::subset? (l1 l2) 
  (LIST-SPEC::all-1-1 #'(lambda (x1) (LIST-SPEC::|!member| x1 l2)) l1))

(defun LISTUTILITIES::subset?-1 (x) (LISTUTILITIES::subset? (car x) (cdr x)))

(defun LISTUTILITIES::take (n es) 
  (if ( =  n 0) 
      nil 
      (block 
       nil 
       (if (null es) 
           (return nil) 
           (if (consp es) 
               (return 
                (cons 
                 (car es) 
                 (LISTUTILITIES::take (INTEGER-SPEC::|!-| n 1) (cdr es)))))) 
       (error "Nonexhaustive match failure in take"))))

(defun LISTUTILITIES::take-1 (x) (LISTUTILITIES::take (car x) (cdr x)))

(defun MFSET::augmentMFSetMap-1-1 (mu_map element) 
  (POLYMAP::update-1-1-1 mu_map element (vector '(:|None|) 0 element)))

(defun MFSET::augmentMFSetMap (x1) 
  #'(lambda (x2) (MFSET::augmentMFSetMap-1-1 x1 x2)))

(defun MFSET::class_member (x y) (LIST-SPEC::|!member| x y))

(defun MFSET::class_member-1 (x) (MFSET::class_member (car x) (cdr x)))

(defparameter MFSET::emptyMFSetMap POLYMAP::emptyMap)

(defun MFSET::findRootValue-1-1 (mu_map mu_node) 
  (let ((pV1 (svref mu_node 0))) 
    (block 
     nil 
     (if (eq (car pV1) :|None|) 
         (return (svref mu_node 2)) 
         (if (eq (car pV1) :|Some|) 
             (return 
              (let ((current_parent_node 
                     (POLYMAP::|!eval|-1-1 mu_map (svref (cdr pV1) 2)))) 
                (MFSET::findRootValue-1-1 mu_map current_parent_node))))) 
     (error "Nonexhaustive match failure in findRootValue"))))

(defun POLYMAP::evalPartial-1-1 (|!map| x) 
  (block 
   nil 
   (if (null |!map|) 
       (return '(:|None|)) 
       (if (consp |!map|) 
           (let ((pV3 (car |!map|))) 
             (return 
              (if (slang-built-in::slang-term-equals x (car pV3)) 
                  (cons :|Some| (cdr pV3)) 
                  (POLYMAP::evalPartial-1-1 (cdr |!map|) x)))))) 
   (error "Nonexhaustive match failure in evalPartial")))

(defun MFSET::extractQuotientSet (mu_map) 
  (let ((root_map 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (root_to_class_map) 
             #'(lambda (element) 
                #'(lambda (mu_node) 
                   (let ((root_value (MFSET::findRootValue-1-1 mu_map mu_node))) 
                     (let ((old_class_list 
                            (let ((pV1 
                                   (POLYMAP::evalPartial-1-1 
                                    root_to_class_map 
                                    root_value))) 
                              (block 
                               nil 
                               (if (eq (car pV1) :|None|) 
                                   (return nil) 
                                   (if (eq (car pV1) :|Some|) (return (cdr pV1)))) 
                               (error 
                                "Nonexhaustive match failure in extractQuotientSet"))))) 
                       (POLYMAP::update-1-1-1 
                        root_to_class_map 
                        root_value 
                        (cons element old_class_list))))))) 
          POLYMAP::emptyMap 
          mu_map))) 
    (POLYMAP::foldMap-1-1-1 
     #'(lambda (list_of_class_lists) 
        #'(lambda (pV3) 
           (declare (ignore pV3)) 
           #'(lambda (class_list) (cons class_list list_of_class_lists)))) 
     nil 
     root_map)))

(defun MFSET::|!find|-1-1 (mu_map value) 
  (MFSET::findRootValue-1-1 mu_map (POLYMAP::|!eval|-1-1 mu_map value)))

(defun MFSET::|!find| (x1) #'(lambda (x2) (MFSET::|!find|-1-1 x1 x2)))

(defun MFSET::findRootValue (x1) 
  #'(lambda (x2) (MFSET::findRootValue-1-1 x1 x2)))

(defun MFSET::updateMFSetMap-1-1-1 (mu_map element node) 
  (POLYMAP::update-1-1-1 mu_map element node))

(defun MFSET::|!merge|-1-1-1 (mu_map mu_node_a mu_node_b) 
  (labels 
    ((find_root_node (mu_map) 
      #'(lambda (mu_node) 
         (let ((pV4 (svref mu_node 0))) 
           (block 
            nil 
            (if (eq (car pV4) :|Some|) 
                (return 
                 (let ((pV1 (funcall (find_root_node mu_map) (cdr pV4)))) 
                   (block 
                    nil 
                    (let ((pV3 (cdr pV1))) 
                      (return 
                       (let ((new_map 
                              (MFSET::updateMFSetMap-1-1-1 
                               (car pV1) 
                               (svref mu_node 2) 
                               (vector 
                                (cons 
                                 :|Some| 
                                 (vector 
                                  (svref pV3 0) 
                                  (svref pV3 1) 
                                  (svref pV3 2))) 
                                (svref mu_node 1) 
                                (svref mu_node 2))))) (cons new_map pV3)))) 
                    (error "Nonexhaustive match failure in merge")))) 
                (if (eq (car pV4) :|None|) (return (cons mu_map mu_node)))) 
            (error "Nonexhaustive match failure in merge")))))) 
    (let ((pV9 (funcall (find_root_node mu_map) mu_node_a))) 
      (block 
       nil 
       (let ((pV11 (cdr pV9))) 
         (return 
          (let ((pV6 (funcall (find_root_node (car pV9)) mu_node_b))) 
            (block 
             nil 
             (let ((pV7 (car pV6))
                   (pV8 (cdr pV6))) 
               (return 
                (if (slang-built-in::slang-term-equals pV11 pV8) 
                    pV7 
                    (let ((rank_a (svref pV11 1))) 
                      (let ((rank_b (svref pV8 1))) 
                        (let ((root_value_b (svref pV8 2))) 
                          (if (INTEGER-SPEC::|!>| rank_a rank_b) 
                              (MFSET::updateMFSetMap-1-1-1 
                               pV7 
                               root_value_b 
                               (vector 
                                (cons 
                                 :|Some| 
                                 (vector 
                                  (svref pV11 0) 
                                  (svref pV11 1) 
                                  (svref pV11 2))) 
                                (svref pV8 1) 
                                root_value_b)) 
                              (let ((root_value_a (svref pV11 2))) 
                                (if (INTEGER-SPEC::|!<| rank_a rank_b) 
                                    (MFSET::updateMFSetMap-1-1-1 
                                     pV7 
                                     root_value_a 
                                     (vector 
                                      (cons 
                                       :|Some| 
                                       (vector 
                                        (svref pV8 0) 
                                        (svref pV8 1) 
                                        (svref pV8 2))) 
                                      (svref pV11 1) 
                                      root_value_a)) 
                                    (let ((new_root_node 
                                           (vector 
                                            '(:|None|) 
                                            (INTEGER-SPEC::|!+| (svref pV8 1) 1) 
                                            root_value_b))) 
                                      (MFSET::updateMFSetMap-1-1-1 
                                       (MFSET::updateMFSetMap-1-1-1 
                                        pV7 
                                        root_value_b 
                                        new_root_node) 
                                       root_value_a 
                                       (vector 
                                        (cons 
                                         :|Some| 
                                         (vector 
                                          (svref new_root_node 0) 
                                          (svref new_root_node 1) 
                                          (svref new_root_node 2))) 
                                        (svref pV11 1) 
                                        root_value_a)))))))))))) 
             (error "Nonexhaustive match failure in merge"))))) 
       (error "Nonexhaustive match failure in merge")))))

(defun MFSET::|!merge| (x1) 
  #'(lambda (x2) #'(lambda (x3) (MFSET::|!merge|-1-1-1 x1 x2 x3))))

(defun MFSET::qset_member (y z) (LIST-SPEC::|!member| y z))

(defun MFSET::qset_member-1 (x) (MFSET::qset_member (car x) (cdr x)))

(defun MFSET::updateMFSetMap (x1) 
  #'(lambda (x2) #'(lambda (x3) (MFSET::updateMFSetMap-1-1-1 x1 x2 x3))))

(defun MERGESORT::sortGT-1-1 (|!cmpGT| ls) 
  (block 
   nil 
   (if (null ls) (return nil) (if (consp ls) (if (null (cdr ls)) (return ls)))) 
   (return 
    (labels 
      ((|!merge| (xs ys) 
        (block 
         nil 
         (if (null xs) (return ys)) 
         (if (null ys) (return xs)) 
         (if (consp xs) 
             (let ((pV6 (car xs))
                   (pV7 (cdr xs))) 
               (if (consp ys) 
                   (let ((pV9 (car ys))
                         (pV10 (cdr ys))) 
                     (return 
                      (if (funcall |!cmpGT| (cons pV6 pV9)) 
                          (cons pV9 (|!merge| (cons pV6 pV7) pV10)) 
                          (cons pV6 (|!merge| pV7 (cons pV9 pV10))))))))) 
         (error "Nonexhaustive match failure in sortGT")))) 
      (labels 
        ((mergepairs (ls1 k) 
          (block 
           nil 
           (if (consp ls1) 
               (let ((pV14 (car ls1))
                     (pV15 (cdr ls1))) 
                 (if (null pV15) 
                     (return ls1) 
                     (if (consp pV15) 
                         (let ((pV17 (car pV15))
                               (pV18 (cdr pV15))) 
                           (return 
                            (if ( =  (NAT-SPEC::|!rem| k 2) 1) 
                                (cons pV14 (cons pV17 pV18)) 
                                (mergepairs 
                                 (cons (|!merge| pV14 pV17) pV18) 
                                 (NAT-SPEC::div k 2))))))))) 
           (return (SYSTEM-SPEC::fail "Impossible: mergepairs"))))) 
        (labels 
          ((nextrun (run xs) 
            (block 
             nil 
             (if (null xs) 
                 (return (cons (LIST-SPEC::rev run) nil)) 
                 (if (consp xs) 
                     (let ((pV21 (car xs))
                           (pV22 (cdr xs))) 
                       (return 
                        (if (funcall |!cmpGT| (cons pV21 (LIST-SPEC::hd run))) 
                            (nextrun (cons pV21 run) pV22) 
                            (cons (LIST-SPEC::rev run) (cons pV21 pV22))))))) 
             (error "Nonexhaustive match failure in sortGT")))) 
          (labels 
            ((samsorting (xs ls1 k) 
              (block 
               nil 
               (if (null xs) 
                   (return (LIST-SPEC::hd (mergepairs ls1 0))) 
                   (if (consp xs) 
                       (return 
                        (let ((pV23 (nextrun (cons (car xs) nil) (cdr xs)))) 
                          (block 
                           nil 
                           (return 
                            (samsorting 
                             (cdr pV23) 
                             (mergepairs 
                              (cons (car pV23) ls1) 
                              (INTEGER-SPEC::|!+| k 1)) 
                             (INTEGER-SPEC::|!+| k 1))) 
                           (error "Nonexhaustive match failure in sortGT")))))) 
               (error "Nonexhaustive match failure in sortGT")))) 
            (block 
             nil 
             (if (null ls) (return nil)) 
             (return (samsorting ls nil 0))))))))))

(defun MERGESORT::sortGT (x1) #'(lambda (x2) (MERGESORT::sortGT-1-1 x1 x2)))

(defun MERGESORT::sorted-1-1 (|!cmpGT| xs) 
  (block 
   nil 
   (if (consp xs) 
       (let ((pV6 (cdr xs))) 
         (if (consp pV6) 
             (return 
              (cl:and 
               (BOOLEAN-SPEC::~ (funcall |!cmpGT| (cons (car xs) (car pV6)))) 
               (MERGESORT::sorted-1-1 |!cmpGT| pV6)))))) 
   (return t)))

(defun MERGESORT::sorted (x1) #'(lambda (x2) (MERGESORT::sorted-1-1 x1 x2)))

(defun MERGESORT::uniqueSort (x1) 
  #'(lambda (x2) (MERGESORT::uniqueSort-1-1 x1 x2)))

(defun METASLANG::appPattern-1 (x1) 
  #'(lambda (x2) (METASLANG::appPattern-1-1 x1 x2)))

(defun METASLANG::appPattern (x0 x1 x2) 
  (METASLANG::appPattern-1 (vector x0 x1 x2)))

(defun METASLANG::appSort (x0 x1 x2) (METASLANG::appSort-1 (vector x0 x1 x2)))

(defun METASLANG::appSortOpt-1 (x1) 
  #'(lambda (x2) (METASLANG::appSortOpt-1-1 x1 x2)))

(defun METASLANG::appSortOpt (x0 x1 x2) 
  (METASLANG::appSortOpt-1 (vector x0 x1 x2)))

(defun METASLANG::appSortSchemes (x0 x1 x2) 
  (METASLANG::appSortSchemes-1 (vector x0 x1 x2)))

(defun METASLANG::appTerm (x0 x1 x2) (METASLANG::appTerm-1 (vector x0 x1 x2)))

(defun METASLANG::appTermOpt-1-1 (tsp_apps opt_term) 
  (block 
   nil 
   (if (eq (car opt_term) :|None|) 
       (return nil) 
       (if (eq (car opt_term) :|Some|) 
           (return (METASLANG::appTerm-1-1 tsp_apps (cdr opt_term))))) 
   (error "Nonexhaustive match failure in appTermOpt")))

(defun METASLANG::appTermOpt-1 (x1) 
  #'(lambda (x2) (METASLANG::appTermOpt-1-1 x1 x2)))

(defun METASLANG::appTermOpt (x0 x1 x2) 
  (METASLANG::appTermOpt-1 (vector x0 x1 x2)))

(defun METASLANG::appTermSchemes (x0 x1 x2) 
  (METASLANG::appTermSchemes-1 (vector x0 x1 x2)))

(defun METASLANG::equalFun?-1 (x) (METASLANG::equalFun? (car x) (cdr x)))

(defun METASLANG::equalList?-1 (x) 
  (METASLANG::equalList? (svref x 0) (svref x 1) (svref x 2)))

(defun METASLANG::equalOpt?-1 (x) 
  (METASLANG::equalOpt? (svref x 0) (svref x 1) (svref x 2)))

(defun METASLANG::existsSubTerm-1-1 (pred? term) 
  (cl:or 
   (funcall pred? term) 
   (block 
    nil 
    (if (eq (car term) :|Var|) 
        (return nil) 
        (if (eq (car term) :|Fun|) 
            (return nil) 
            (if (eq (car term) :|Apply|) 
                (let ((pV29 (cdr term))) 
                  (return 
                   (cl:or 
                    (METASLANG::existsSubTerm-1-1 pred? (svref pV29 0)) 
                    (METASLANG::existsSubTerm-1-1 pred? (svref pV29 1))))) 
                (if (eq (car term) :|Record|) 
                    (return 
                     (LIST-SPEC::|!exists|-1-1 
                      #'(lambda (x) 
                         (METASLANG::existsSubTerm-1-1 pred? (cdr x))) 
                      (car (cdr term)))) 
                    (if (eq (car term) :|Let|) 
                        (let ((pV27 (cdr term))) 
                          (return 
                           (cl:or 
                            (METASLANG::existsSubTerm-1-1 pred? (svref pV27 1)) 
                            (LIST-SPEC::|!exists|-1-1 
                             #'(lambda (x) 
                                (METASLANG::existsSubTerm-1-1 pred? (cdr x))) 
                             (svref pV27 0))))) 
                        (if (eq (car term) :|LetRec|) 
                            (let ((pV26 (cdr term))) 
                              (return 
                               (cl:or 
                                (METASLANG::existsSubTerm-1-1 
                                 pred? 
                                 (svref pV26 1)) 
                                (LIST-SPEC::|!exists|-1-1 
                                 #'(lambda (x) 
                                    (METASLANG::existsSubTerm-1-1 pred? (cdr x))) 
                                 (svref pV26 0))))) 
                            (if (eq (car term) :|Seq|) 
                                (return 
                                 (LIST-SPEC::|!exists|-1-1 
                                  (METASLANG::existsSubTerm pred?) 
                                  (car (cdr term)))) 
                                (if (eq (car term) :|IfThenElse|) 
                                    (let ((pV24 (cdr term))) 
                                      (return 
                                       (cl:or 
                                        (METASLANG::existsSubTerm-1-1 
                                         pred? 
                                         (svref pV24 0)) 
                                        (cl:or 
                                         (METASLANG::existsSubTerm-1-1 
                                          pred? 
                                          (svref pV24 1)) 
                                         (METASLANG::existsSubTerm-1-1 
                                          pred? 
                                          (svref pV24 2)))))) 
                                    (if (eq (car term) :|Bind|) 
                                        (return 
                                         (METASLANG::existsSubTerm-1-1 
                                          pred? 
                                          (svref (cdr term) 2))) 
                                        (if (eq (car term) :|Lambda|) 
                                            (return 
                                             (LIST-SPEC::|!exists|-1-1 
                                              #'(lambda (x) 
                                                 (cl:or 
                                                  (METASLANG::existsSubTerm-1-1 
                                                   pred? 
                                                   (svref x 1)) 
                                                  (METASLANG::existsSubTerm-1-1 
                                                   pred? 
                                                   (svref x 2)))) 
                                              (car (cdr term)))) 
                                            (if (eq (car term) :|ApplyN|) 
                                                (return 
                                                 (LIST-SPEC::|!exists|-1-1 
                                                  (METASLANG::existsSubTerm 
                                                   pred?) 
                                                  (car (cdr term)))) 
                                                (if (eq (car term) :|SortedTerm|) 
                                                    (return 
                                                     (METASLANG::existsSubTerm-1-1 
                                                      pred? 
                                                      (svref (cdr term) 0))))))))))))))) 
    (error "Nonexhaustive match failure in existsSubTerm"))))

(defun METASLANG::existsSubTerm (x1) 
  #'(lambda (x2) (METASLANG::existsSubTerm-1-1 x1 x2)))

(defun METASLANG::mapPattern-1 (x1) 
  #'(lambda (x2) (METASLANG::mapPattern-1-1 x1 x2)))

(defun METASLANG::mapPattern (x0 x1 x2) 
  (METASLANG::mapPattern-1 (vector x0 x1 x2)))

(defun METASLANG::mapSort-1 (x1) 
  #'(lambda (x2) (METASLANG::mapSort-1-1 x1 x2)))

(defun METASLANG::mapSort (x0 x1 x2) (METASLANG::mapSort-1 (vector x0 x1 x2)))

(defun METASLANG::mapTerm-1 (x1) 
  #'(lambda (x2) (METASLANG::mapTerm-1-1 x1 x2)))

(defun METASLANG::mapTerm (x0 x1 x2) (METASLANG::mapTerm-1 (vector x0 x1 x2)))

(defun METASLANG::mkABase-1 (x) 
  (METASLANG::mkABase (svref x 0) (svref x 1) (svref x 2)))

(defun METASLANG::mkAQualifiedId (qualifier id x) 
  (cons (cons :|Qualified| (cons qualifier id)) x))

(defun METASLANG::mkAQualifiedId-1 (x) 
  (METASLANG::mkAQualifiedId (svref x 0) (svref x 1) (svref x 2)))

(defun METASLANG::mkAUnQualifiedId (id x) 
  (cons (cons :|Qualified| (cons METASLANG::UnQualified id)) x))

(defun METASLANG::mkAUnQualifiedId-1 (x) 
  (METASLANG::mkAUnQualifiedId (car x) (cdr x)))

(defun METASLANG::mkFalseA (a) 
  (cons :|Fun| (vector (cons :|Bool| nil) (METASLANG::boolSort a) a)))

(defun METASLANG::mkQualifiedId-1 (x) 
  (METASLANG::mkQualifiedId (car x) (cdr x)))

(defun METASLANG::printQualifierDotId (qualifier id) 
  (if (cl:or 
       (string=  qualifier "Nat") 
       (cl:or 
        (string=  qualifier "Boolean") 
        (cl:or 
         (string=  qualifier "String") 
         (cl:or 
          (string=  qualifier "Char") 
          (string=  qualifier METASLANG::UnQualified))))) 
      id 
      (STRING-SPEC::^ (STRING-SPEC::^ qualifier ".") id)))

(defun METASLANG::printQualifiedId (pV1) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV2 (cdr pV1))) 
         (let ((pV4 (cdr pV2))
               (pV3 (car pV2))) 
           (return 
            (if (string=  pV3 METASLANG::UnQualified) 
                pV4 
                (METASLANG::printQualifierDotId pV3 pV4)))))) 
   (error "Nonexhaustive match failure in printQualifiedId")))

(defun METASLANG::printAliases (aliases) 
  (block 
   nil 
   (if (null aliases) 
       (return (SYSTEM-SPEC::fail "printAliases: empty name list")) 
       (if (consp aliases) 
           (let ((pV4 (cdr aliases))
                 (pV3 (car aliases))) 
             (progn (if (null pV4) (return (METASLANG::printQualifiedId pV3))) 
                    (return 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ "{" (METASLANG::printQualifiedId pV3)) 
                       (LIST-SPEC::foldl-1-1-1 
                        #'(lambda (x) 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ (cdr x) ", ") 
                            (METASLANG::printQualifiedId (car x)))) 
                        "" 
                        pV4)) 
                      "}")))))) 
   (error "Nonexhaustive match failure in printAliases")))

(defun METASLANG::printQualifierDotId-1 (x) 
  (METASLANG::printQualifierDotId (car x) (cdr x)))

(defun METASLANG::replaceTerm-1-1 (tsp_maps term) 
  (let ((term_map (svref tsp_maps 0))) 
    (labels 
      ((replaceRec (term) 
        (let ((pV51 (funcall term_map term))) 
          (block 
           nil 
           (if (eq (car pV51) :|None|) 
               (return (|!replace| term)) 
               (if (eq (car pV51) :|Some|) (return (cdr pV51)))) 
           (error "Nonexhaustive match failure in replaceTerm"))))
       (|!replace| (term) 
        (block 
         nil 
         (if (eq (car term) :|Fun|) 
             (let ((pV15 (cdr term))) 
               (return 
                (cons 
                 :|Fun| 
                 (vector 
                  (svref pV15 0) 
                  (METASLANG::replaceSort-1-1 tsp_maps (svref pV15 1)) 
                  (svref pV15 2))))) 
             (if (eq (car term) :|Var|) 
                 (let ((pV14 (cdr term))) 
                   (let ((pV44 (car pV14))) 
                     (return 
                      (cons 
                       :|Var| 
                       (cons 
                        (cons 
                         (car pV44) 
                         (METASLANG::replaceSort-1-1 tsp_maps (cdr pV44))) 
                        (cdr pV14)))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV13 (cdr term))) 
                       (return 
                        (cons 
                         :|Let| 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x1) 
                              (cons 
                               (METASLANG::replacePattern-1-1 tsp_maps (car x1)) 
                               (replaceRec (cdr x1)))) 
                           (svref pV13 0)) 
                          (replaceRec (svref pV13 1)) 
                          (svref pV13 2))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV12 (cdr term))) 
                           (return 
                            (cons 
                             :|LetRec| 
                             (vector 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x1) 
                                  (cons (car x1) (replaceRec (cdr x1)))) 
                               (svref pV12 0)) 
                              (replaceRec (svref pV12 1)) 
                              (svref pV12 2))))) 
                         (if (eq (car term) :|Record|) 
                             (let ((pV11 (cdr term))) 
                               (return 
                                (cons 
                                 :|Record| 
                                 (cons 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'(lambda (x1) 
                                      (cons (car x1) (replaceRec (cdr x1)))) 
                                   (car pV11)) 
                                  (cdr pV11))))) 
                             (if (eq (car term) :|IfThenElse|) 
                                 (let ((pV10 (cdr term))) 
                                   (return 
                                    (cons 
                                     :|IfThenElse| 
                                     (vector 
                                      (replaceRec (svref pV10 0)) 
                                      (replaceRec (svref pV10 1)) 
                                      (replaceRec (svref pV10 2)) 
                                      (svref pV10 3))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (let ((pV9 (cdr term))) 
                                       (return 
                                        (cons 
                                         :|Lambda| 
                                         (cons 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x1) 
                                              (vector 
                                               (METASLANG::replacePattern-1-1 
                                                tsp_maps 
                                                (svref x1 0)) 
                                               (replaceRec (svref x1 1)) 
                                               (replaceRec (svref x1 2)))) 
                                           (car pV9)) 
                                          (cdr pV9))))) 
                                     (if (eq (car term) :|Bind|) 
                                         (let ((pV8 (cdr term))) 
                                           (return 
                                            (cons 
                                             :|Bind| 
                                             (vector 
                                              (svref pV8 0) 
                                              (LIST-SPEC::|!map|-1-1 
                                               #'(lambda (x1) 
                                                  (cons 
                                                   (car x1) 
                                                   (METASLANG::replaceSort-1-1 
                                                    tsp_maps 
                                                    (cdr x1)))) 
                                               (svref pV8 1)) 
                                              (replaceRec (svref pV8 2)) 
                                              (svref pV8 3))))) 
                                         (if (eq (car term) :|Apply|) 
                                             (let ((pV7 (cdr term))) 
                                               (return 
                                                (cons 
                                                 :|Apply| 
                                                 (vector 
                                                  (replaceRec (svref pV7 0)) 
                                                  (replaceRec (svref pV7 1)) 
                                                  (svref pV7 2))))) 
                                             (if (eq (car term) :|Seq|) 
                                                 (let ((pV6 (cdr term))) 
                                                   (return 
                                                    (cons 
                                                     :|Seq| 
                                                     (cons 
                                                      (LIST-SPEC::|!map|-1-1 
                                                       #'replaceRec 
                                                       (car pV6)) 
                                                      (cdr pV6))))) 
                                                 (if (eq (car term) :|ApplyN|) 
                                                     (let ((pV5 (cdr term))) 
                                                       (return 
                                                        (cons 
                                                         :|ApplyN| 
                                                         (cons 
                                                          (LIST-SPEC::|!map|-1-1 
                                                           #'replaceRec 
                                                           (car pV5)) 
                                                          (cdr pV5))))) 
                                                     (if (eq 
                                                          (car term) 
                                                          :|SortedTerm|) 
                                                         (let ((pV4 (cdr term))) 
                                                           (return 
                                                            (cons 
                                                             :|SortedTerm| 
                                                             (vector 
                                                              (replaceRec 
                                                               (svref pV4 0)) 
                                                              (METASLANG::replaceSort-1-1 
                                                               tsp_maps 
                                                               (svref pV4 1)) 
                                                              (svref pV4 2))))))))))))))))) 
         (error "Nonexhaustive match failure in replaceTerm")))) 
      (replaceRec term))))

(defun METASLANG::replaceSort-1-1 (tsp_maps srt) 
  (let ((sort_map (svref tsp_maps 1))) 
    (labels 
      ((replaceRec (srt) 
        (let ((pV29 (funcall sort_map srt))) 
          (block 
           nil 
           (if (eq (car pV29) :|None|) 
               (return (|!replace| srt)) 
               (if (eq (car pV29) :|Some|) (return (cdr pV29)))) 
           (error "Nonexhaustive match failure in replaceSort"))))
       (replaceRecOpt (opt_srt) 
        (block 
         nil 
         (if (eq (car opt_srt) :|None|) 
             (return '(:|None|)) 
             (if (eq (car opt_srt) :|Some|) 
                 (return (cons :|Some| (replaceRec (cdr opt_srt)))))) 
         (error "Nonexhaustive match failure in replaceSort")))
       (|!replace| (srt) 
        (block 
         nil 
         (if (eq (car srt) :|CoProduct|) 
             (let ((pV10 (cdr srt))) 
               (return 
                (cons 
                 :|CoProduct| 
                 (cons 
                  (LIST-SPEC::|!map|-1-1 
                   #'(lambda (x1) (cons (car x1) (replaceRecOpt (cdr x1)))) 
                   (car pV10)) 
                  (cdr pV10))))) 
             (if (eq (car srt) :|Product|) 
                 (let ((pV9 (cdr srt))) 
                   (return 
                    (cons 
                     :|Product| 
                     (cons 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (x1) (cons (car x1) (replaceRec (cdr x1)))) 
                       (car pV9)) 
                      (cdr pV9))))) 
                 (if (eq (car srt) :|Arrow|) 
                     (let ((pV8 (cdr srt))) 
                       (return 
                        (cons 
                         :|Arrow| 
                         (vector 
                          (replaceRec (svref pV8 0)) 
                          (replaceRec (svref pV8 1)) 
                          (svref pV8 2))))) 
                     (if (eq (car srt) :|Quotient|) 
                         (let ((pV7 (cdr srt))) 
                           (return 
                            (cons 
                             :|Quotient| 
                             (vector 
                              (replaceRec (svref pV7 0)) 
                              (METASLANG::replaceTerm-1-1 tsp_maps (svref pV7 1)) 
                              (svref pV7 2))))) 
                         (if (eq (car srt) :|Subsort|) 
                             (let ((pV6 (cdr srt))) 
                               (return 
                                (cons 
                                 :|Subsort| 
                                 (vector 
                                  (replaceRec (svref pV6 0)) 
                                  (METASLANG::replaceTerm-1-1 
                                   tsp_maps 
                                   (svref pV6 1)) 
                                  (svref pV6 2))))) 
                             (if (eq (car srt) :|Base|) 
                                 (let ((pV5 (cdr srt))) 
                                   (let ((pV11 (svref pV5 0))
                                         (pV12 (svref pV5 1))
                                         (pV13 (svref pV5 2))) 
                                     (progn (return 
                                             (cons 
                                              :|Base| 
                                              (vector 
                                               pV11 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'replaceRec 
                                                pV12) 
                                               pV13))) 
                                            (return 
                                             (cons 
                                              :|Base| 
                                              (vector 
                                               pV11 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'replaceRec 
                                                pV12) 
                                               pV13)))))))))))) 
         (return srt)))) (replaceRec srt))))

(defun METASLANG::replacePattern-1-1 (tsp_maps pattern) 
  (let ((pattern_map (svref tsp_maps 2))) 
    (labels 
      ((replaceRec (pattern) 
        (let ((pV34 (funcall pattern_map pattern))) 
          (block 
           nil 
           (if (eq (car pV34) :|None|) 
               (return (|!replace| pattern)) 
               (if (eq (car pV34) :|Some|) (return (cdr pV34)))) 
           (error "Nonexhaustive match failure in replacePattern"))))
       (|!replace| (pattern) 
        (block 
         nil 
         (if (eq (car pattern) :|AliasPat|) 
             (let ((pV11 (cdr pattern))) 
               (return 
                (cons 
                 :|AliasPat| 
                 (vector 
                  (replaceRec (svref pV11 0)) 
                  (replaceRec (svref pV11 1)) 
                  (svref pV11 2))))) 
             (if (eq (car pattern) :|EmbedPat|) 
                 (let ((pV10 (cdr pattern))) 
                   (let ((pV26 (svref pV10 0))
                         (pV27 (svref pV10 1))
                         (pV28 (svref pV10 2))
                         (pV29 (svref pV10 3))) 
                     (if (eq (car pV27) :|Some|) 
                         (return 
                          (cons 
                           :|EmbedPat| 
                           (vector 
                            pV26 
                            (cons :|Some| (replaceRec (cdr pV27))) 
                            (METASLANG::replaceSort-1-1 tsp_maps pV28) 
                            pV29))) 
                         (if (eq (car pV27) :|None|) 
                             (return 
                              (cons 
                               :|EmbedPat| 
                               (vector 
                                pV26 
                                '(:|None|) 
                                (METASLANG::replaceSort-1-1 tsp_maps pV28) 
                                pV29))))))) 
                 (if (eq (car pattern) :|RelaxPat|) 
                     (let ((pV9 (cdr pattern))) 
                       (return 
                        (cons 
                         :|RelaxPat| 
                         (vector 
                          (replaceRec (svref pV9 0)) 
                          (METASLANG::replaceTerm-1-1 tsp_maps (svref pV9 1)) 
                          (svref pV9 2))))) 
                     (if (eq (car pattern) :|QuotientPat|) 
                         (let ((pV8 (cdr pattern))) 
                           (return 
                            (cons 
                             :|QuotientPat| 
                             (vector 
                              (replaceRec (svref pV8 0)) 
                              (METASLANG::replaceTerm-1-1 tsp_maps (svref pV8 1)) 
                              (svref pV8 2))))) 
                         (if (eq (car pattern) :|VarPat|) 
                             (let ((pV7 (cdr pattern))) 
                               (let ((pV16 (car pV7))) 
                                 (return 
                                  (cons 
                                   :|VarPat| 
                                   (cons 
                                    (cons 
                                     (car pV16) 
                                     (METASLANG::replaceSort-1-1 
                                      tsp_maps 
                                      (cdr pV16))) 
                                    (cdr pV7)))))) 
                             (if (eq (car pattern) :|WildPat|) 
                                 (let ((pV6 (cdr pattern))) 
                                   (return 
                                    (cons 
                                     :|WildPat| 
                                     (cons 
                                      (METASLANG::replaceSort-1-1 
                                       tsp_maps 
                                       (car pV6)) 
                                      (cdr pV6))))) 
                                 (if (eq (car pattern) :|RecordPat|) 
                                     (let ((pV5 (cdr pattern))) 
                                       (return 
                                        (cons 
                                         :|RecordPat| 
                                         (cons 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x1) 
                                              (cons 
                                               (car x1) 
                                               (replaceRec (cdr x1)))) 
                                           (car pV5)) 
                                          (cdr pV5)))))))))))) 
         (return pattern)))) (replaceRec pattern))))

(defun METASLANG::replacePattern-1 (x1) 
  #'(lambda (x2) (METASLANG::replacePattern-1-1 x1 x2)))

(defun METASLANG::replacePattern (x0 x1 x2) 
  (METASLANG::replacePattern-1 (vector x0 x1 x2)))

(defun METASLANG::replaceSort-1 (x1) 
  #'(lambda (x2) (METASLANG::replaceSort-1-1 x1 x2)))

(defun METASLANG::replaceSort (x0 x1 x2) 
  (METASLANG::replaceSort-1 (vector x0 x1 x2)))

(defun METASLANG::replaceTerm-1 (x1) 
  #'(lambda (x2) (METASLANG::replaceTerm-1-1 x1 x2)))

(defun METASLANG::replaceTerm (x0 x1 x2) 
  (METASLANG::replaceTerm-1 (vector x0 x1 x2)))

(defun METASLANG::sortAnn (s) 
  (block 
   nil 
   (if (eq (car s) :|Arrow|) 
       (return (svref (cdr s) 2)) 
       (if (eq (car s) :|Product|) 
           (return (cdr (cdr s))) 
           (if (eq (car s) :|CoProduct|) 
               (return (cdr (cdr s))) 
               (if (eq (car s) :|Quotient|) 
                   (return (svref (cdr s) 2)) 
                   (if (eq (car s) :|Subsort|) 
                       (return (svref (cdr s) 2)) 
                       (if (eq (car s) :|Base|) 
                           (return (svref (cdr s) 2)) 
                           (if (eq (car s) :|TyVar|) 
                               (return (cdr (cdr s))) 
                               (if (eq (car s) :|MetaTyVar|) 
                                   (return (cdr (cdr s))))))))))) 
   (error "Nonexhaustive match failure in sortAnn")))

(defun METASLANG::stringSort? (s) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV4 (cdr s))) 
         (let ((pV5 (svref pV4 0))) 
           (if (eq (car pV5) :|Qualified|) 
               (let ((pV8 (cdr pV5))) 
                 (if (string=  "String" (car pV8)) 
                     (if (string=  "String" (cdr pV8)) 
                         (if (null (svref pV4 1)) (return t))))))))) 
   (return nil)))

(defun METASLANG::termAnn (|!t|) 
  (block 
   nil 
   (if (eq (car |!t|) :|Apply|) 
       (return (svref (cdr |!t|) 2)) 
       (if (eq (car |!t|) :|ApplyN|) 
           (return (cdr (cdr |!t|))) 
           (if (eq (car |!t|) :|Record|) 
               (return (cdr (cdr |!t|))) 
               (if (eq (car |!t|) :|Bind|) 
                   (return (svref (cdr |!t|) 3)) 
                   (if (eq (car |!t|) :|Let|) 
                       (return (svref (cdr |!t|) 2)) 
                       (if (eq (car |!t|) :|LetRec|) 
                           (return (svref (cdr |!t|) 2)) 
                           (if (eq (car |!t|) :|Var|) 
                               (return (cdr (cdr |!t|))) 
                               (if (eq (car |!t|) :|SortedTerm|) 
                                   (return (svref (cdr |!t|) 2)) 
                                   (if (eq (car |!t|) :|Fun|) 
                                       (return (svref (cdr |!t|) 2)) 
                                       (if (eq (car |!t|) :|Lambda|) 
                                           (return (cdr (cdr |!t|))) 
                                           (if (eq (car |!t|) :|IfThenElse|) 
                                               (return (svref (cdr |!t|) 3)) 
                                               (if (eq (car |!t|) :|Seq|) 
                                                   (return (cdr (cdr |!t|))))))))))))))) 
   (error "Nonexhaustive match failure in termAnn")))

(defun METASLANG::withAnnS (s a) 
  (block 
   nil 
   (if (eq (car s) :|Arrow|) 
       (let ((pV17 (cdr s))) 
         (return (cons :|Arrow| (vector (svref pV17 0) (svref pV17 1) a)))) 
       (if (eq (car s) :|Product|) 
           (return (cons :|Product| (cons (car (cdr s)) a))) 
           (if (eq (car s) :|CoProduct|) 
               (return (cons :|CoProduct| (cons (car (cdr s)) a))) 
               (if (eq (car s) :|Quotient|) 
                   (let ((pV14 (cdr s))) 
                     (return 
                      (cons :|Quotient| (vector (svref pV14 0) (svref pV14 1) a)))) 
                   (if (eq (car s) :|Subsort|) 
                       (let ((pV13 (cdr s))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector (svref pV13 0) (svref pV13 1) a)))) 
                       (if (eq (car s) :|Base|) 
                           (let ((pV12 (cdr s))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector (svref pV12 0) (svref pV12 1) a)))) 
                           (if (eq (car s) :|TyVar|) 
                               (return (cons :|TyVar| (cons (car (cdr s)) a))) 
                               (if (eq (car s) :|MetaTyVar|) 
                                   (return 
                                    (cons :|MetaTyVar| (cons (car (cdr s)) a))))))))))) 
   (error "Nonexhaustive match failure in withAnnS")))

(defun METASLANG::withAnnS-1 (x) (METASLANG::withAnnS (car x) (cdr x)))

(defun METASLANG::withAnnT (|!t| a) 
  (block 
   nil 
   (if (eq (car |!t|) :|Apply|) 
       (let ((pV25 (cdr |!t|))) 
         (return (cons :|Apply| (vector (svref pV25 0) (svref pV25 1) a)))) 
       (if (eq (car |!t|) :|ApplyN|) 
           (return (cons :|ApplyN| (cons (car (cdr |!t|)) a))) 
           (if (eq (car |!t|) :|Record|) 
               (return (cons :|Record| (cons (car (cdr |!t|)) a))) 
               (if (eq (car |!t|) :|Bind|) 
                   (let ((pV22 (cdr |!t|))) 
                     (return 
                      (cons 
                       :|Bind| 
                       (vector (svref pV22 0) (svref pV22 1) (svref pV22 2) a)))) 
                   (if (eq (car |!t|) :|Let|) 
                       (let ((pV21 (cdr |!t|))) 
                         (return 
                          (cons :|Let| (vector (svref pV21 0) (svref pV21 1) a)))) 
                       (if (eq (car |!t|) :|LetRec|) 
                           (return 
                            (cons :|LetRec| (vector (svref (cdr |!t|) 0) |!t| a))) 
                           (if (eq (car |!t|) :|Var|) 
                               (return (cons :|Var| (cons (car (cdr |!t|)) a))) 
                               (if (eq (car |!t|) :|SortedTerm|) 
                                   (let ((pV18 (cdr |!t|))) 
                                     (return 
                                      (cons 
                                       :|SortedTerm| 
                                       (vector (svref pV18 0) (svref pV18 1) a)))) 
                                   (if (eq (car |!t|) :|Fun|) 
                                       (let ((pV17 (cdr |!t|))) 
                                         (return 
                                          (cons 
                                           :|Fun| 
                                           (vector 
                                            (svref pV17 0) 
                                            (svref pV17 1) 
                                            a)))) 
                                       (if (eq (car |!t|) :|Lambda|) 
                                           (return 
                                            (cons 
                                             :|Lambda| 
                                             (cons (car (cdr |!t|)) a))) 
                                           (if (eq (car |!t|) :|IfThenElse|) 
                                               (let ((pV15 (cdr |!t|))) 
                                                 (return 
                                                  (cons 
                                                   :|IfThenElse| 
                                                   (vector 
                                                    (svref pV15 0) 
                                                    (svref pV15 1) 
                                                    (svref pV15 2) 
                                                    a)))) 
                                               (if (eq (car |!t|) :|Seq|) 
                                                   (return 
                                                    (cons 
                                                     :|Seq| 
                                                     (cons (car (cdr |!t|)) a))))))))))))))) 
   (error "Nonexhaustive match failure in withAnnT")))

(defun METASLANG::withAnnT-1 (x) (METASLANG::withAnnT (car x) (cdr x)))

(defun NAT-SPEC::div-1 (x) (NAT-SPEC::div (car x) (cdr x)))

(defparameter NAT-SPEC::one 1)

(defun NAT-SPEC::posNat? (n) (INTEGER-SPEC::|!>| n 0))

(defun NAT-SPEC::pred (n) (INTEGER-SPEC::|!-| n 1))

(defun NAT-SPEC::show (n) (NAT-SPEC::natToString n))

(defun NAT-SPEC::succ (n) (INTEGER-SPEC::|!+| n 1))

(defparameter NAT-SPEC::two 2)

(defparameter NAT-SPEC::zero 0)

(defun SPLAYMAP::applyi-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV2 (cdr sp))) 
             (return 
              (progn (SPLAYMAP::applyi-1-1 af (svref pV2 0)) 
                     (funcall af (svref pV2 2)) 
                     (SPLAYMAP::applyi-1-1 af (svref pV2 1))))))) 
   (error "Nonexhaustive match failure in applyi")))

(defun SPLAYMAP::appi-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::applyi-1-1 af (STATE::|!!| (svref (cdr |!map|) 2)))))) 
   (error "Nonexhaustive match failure in appi")))

(defun SPLAYMAP::appi (x1) #'(lambda (x2) (SPLAYMAP::appi-1-1 x1 x2)))

(defun NATMAP::appi (x) (SPLAYMAP::appi x))

(defun NATMAP::appi-1-1 (x0 x1) (SPLAYMAP::appi-1-1 x0 x1))

(defun SPLAYMAP::compose (map1 map2) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (let ((map3 (svref x 2))) 
        (let ((pV1 (SPLAYMAP::|!find| map2 (svref x 1)))) 
          (block 
           nil 
           (if (eq (car pV1) :|Some|) 
               (return (SPLAYMAP::insert map3 (svref x 0) (cdr pV1))) 
               (if (eq (car pV1) :|None|) (return map3))) 
           (error "Nonexhaustive match failure in compose"))))) 
   (SPLAYMAP::empty 
    (block 
     nil 
     (if (eq (car map1) :|EMPTY|) 
         (return (cdr map1)) 
         (if (eq (car map1) :|MAP|) (return (svref (cdr map1) 0)))) 
     (error "Nonexhaustive match failure in compose"))) 
   map1))

(defun NATMAP::compose (x0 x) (SPLAYMAP::compose x0 x))

(defun NATMAP::compose-1 (x) (NATMAP::compose (car x) (cdr x)))

(defun NATMAP::|!find| (x0 x) (SPLAYMAP::|!find| x0 x))

(defun NATMAP::|!find|-1 (x) (NATMAP::|!find| (car x) (cdr x)))

(defun SPLAYMAP::foldri (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldri-1-1-1 x1 x2 x3))))

(defun NATMAP::foldri (x) (SPLAYMAP::foldri x))

(defun NATMAP::foldri-1-1-1 (x0 x1 x2) (SPLAYMAP::foldri-1-1-1 x0 x1 x2))

(defun SPLAYMAP::inDomain (|!map| key) 
  (let ((pV2 (SPLAYMAP::|!find| |!map| key))) 
    (block 
     nil 
     (if (eq (car pV2) :|Some|) 
         (return t) 
         (if (eq (car pV2) :|None|) (return nil))) 
     (error "Nonexhaustive match failure in inDomain"))))

(defun NATMAP::inDomain (x0 x) (SPLAYMAP::inDomain x0 x))

(defun NATMAP::inDomain-1 (x) (NATMAP::inDomain (car x) (cdr x)))

(defun NATMAP::insert-1 (x) 
  (NATMAP::insert (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYMAP::listItems (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::listItemsf 
             #'(lambda (x) (cdr x)) 
             (STATE::|!!| (svref (cdr |!map|) 2)) 
             nil)))) 
   (error "Nonexhaustive match failure in listItems")))

(defun NATMAP::listItems (x) (SPLAYMAP::listItems x))

(defun SPLAYMAP::|!map| (x1) #'(lambda (x2) (SPLAYMAP::|!map|-1-1 x1 x2)))

(defun NATMAP::|!map| (x) (SPLAYMAP::|!map| x))

(defun NATMAP::|!map|-1-1 (x0 x1) (SPLAYMAP::|!map|-1-1 x0 x1))

(defun SPLAYMAP::mapi (x1) #'(lambda (x2) (SPLAYMAP::mapi-1-1 x1 x2)))

(defun NATMAP::mapi (x) (SPLAYMAP::mapi x))

(defun NATMAP::mapi-1-1 (x0 x1) (SPLAYMAP::mapi-1-1 x0 x1))

(defun SPLAYMAP::numItems (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return 0) 
       (if (eq (car |!map|) :|MAP|) (return (svref (cdr |!map|) 1)))) 
   (error "Nonexhaustive match failure in numItems")))

(defun NATMAP::numItems (x) (SPLAYMAP::numItems x))

(defun NATTRANS::build-1-1-1 (domFunc codFunc components) 
  (vector codFunc components domFunc))

(defun NATTRANS::build-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (NATTRANS::build-1-1-1 x1 x2 x3))))

(defun NATTRANS::build (x0 x1 x2 x3) (NATTRANS::build-1 (vector x0 x1 x2 x3)))

(defun NATTRANS::cod-1 (nt) (svref nt 0))

(defun NATTRANS::cod (x0 x1 x2) (NATTRANS::cod-1 (vector x0 x1 x2)))

(defun NATTRANS::components-1 (nt) (svref nt 1))

(defun NATTRANS::components (x0 x1 x2) 
  (NATTRANS::components-1 (vector x0 x1 x2)))

(defun NATTRANS::dom-1 (nt) (svref nt 2))

(defun NATTRANS::dom (x0 x1 x2) (NATTRANS::dom-1 (vector x0 x1 x2)))

(defun NATTRANS::emptyNatTrans (x0 x1 x2 x3 x4 x5 x6 x7) 
  (NATTRANS::emptyNatTrans-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))

(defun NATTRANS::ppNatTrans-1 (nt) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "Components=") 
    (cons 
     (WADLERLINDIG::ppNest-1-1 
      2 
      (POLYMAP::ppMap-1-1-1 
       #'VERTEX::ppElem 
       (CAT::ppArr-1 (FUNCTOR::cod-1 (NATTRANS::cod-1 nt))) 
       (NATTRANS::components-1 nt))) 
     nil))))

(defun NATTRANS::ppNatTrans (x0 x1 x2) 
  (NATTRANS::ppNatTrans-1 (vector x0 x1 x2)))

(defun OPTION::compare-1-1 (comp x) 
  (let ((o1 (car x))
        (o2 (cdr x))) 
    (block 
     nil 
     (if (eq (car o1) :|None|) 
         (if (eq (car o2) :|Some|) (return '(:|Less|))) 
         (if (eq (car o1) :|Some|) 
             (if (eq (car o2) :|Some|) 
                 (return (funcall comp (cons (cdr o1) (cdr o2)))) 
                 (if (eq (car o2) :|None|) (return '(:|Greater|)))))) 
     (return '(:|Equal|)))))

(defun OPTION::compare (x1) #'(lambda (x2) (OPTION::compare-1-1 x1 x2)))

(defun OPTION::mapOption-1-1 (f opt) 
  (block 
   nil 
   (if (eq (car opt) :|None|) 
       (return '(:|None|)) 
       (if (eq (car opt) :|Some|) (return (cons :|Some| (funcall f (cdr opt)))))) 
   (error "Nonexhaustive match failure in mapOption")))

(defun OPTION::mapOption (x1) #'(lambda (x2) (OPTION::mapOption-1-1 x1 x2)))

(defun OPTION::some? (x) 
  (block 
   nil 
   (if (eq (car x) :|None|) (return nil) (if (eq (car x) :|Some|) (return t))) 
   (error "Nonexhaustive match failure in some?")))

(defun OPTION::none? (x) (if (OPTION::some? x) nil t))

(defun OPTION::show-1-1 (showX opt) 
  (block 
   nil 
   (if (eq (car opt) :|None|) 
       (return "None") 
       (if (eq (car opt) :|Some|) 
           (return 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ "(Some " (funcall showX (cdr opt))) 
             ")")))) 
   (error "Nonexhaustive match failure in show")))

(defun OPTION::show (x1) #'(lambda (x2) (OPTION::show-1-1 x1 x2)))

(defun PATTERNMATCH::match_type (srt) 
  (STANDARDSPEC::mkBase 
   (cons :|Qualified| (cons "TranslationBuiltIn" "Match")) 
   (cons srt nil)))

(defun PATTERNMATCH::abstract (vs |!t| srt) 
  (let ((srt (STANDARDSPEC::mkArrow (PATTERNMATCH::match_type srt) srt))) 
    (let ((oper 
           (STANDARDSPEC::mkOp 
            (cons :|Qualified| (cons "TranslationBuiltIn" "block")) 
            srt))) 
      (let ((|!t| (STANDARDSPEC::mkApply oper |!t|))) 
        (let ((pat 
               (block 
                nil 
                (if (consp vs) 
                    (if (null (cdr vs)) 
                        (return (STANDARDSPEC::mkVarPat-1 (cdr (car vs)))))) 
                (return 
                 (cons 
                  :|RecordPat| 
                  (cons 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (x) 
                       (cons (car x) (STANDARDSPEC::mkVarPat-1 (cdr x)))) 
                    vs) 
                   POSITION-SPEC::noPos)))))) 
          (cons 
           :|Lambda| 
           (cons 
            (cons (vector pat (STANDARDSPEC::mkTrue) |!t|) nil) 
            POSITION-SPEC::noPos)))))))

(defun PATTERNMATCH::abstract-1 (x) 
  (PATTERNMATCH::abstract (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::wildPattern?-1 (rule) 
  (let ((pV11 (svref rule 1))
        (pV10 (svref rule 0))) 
    (block 
     nil 
     (if (eq (car pV10) :|WildPat|) 
         (if (eq (car pV11) :|Fun|) 
             (let ((pV23 (svref (cdr pV11) 0))) 
               (if (eq (car pV23) :|Bool|) (if (eq t (cdr pV23)) (return t))))) 
         (if (eq (car pV10) :|VarPat|) 
             (if (eq (car pV11) :|Fun|) 
                 (let ((pV18 (svref (cdr pV11) 0))) 
                   (if (eq (car pV18) :|Bool|) (if (eq t (cdr pV18)) (return t))))))) 
     (return nil))))

(defun PATTERNMATCH::checkUnreachableCase (context term rules) 
  (labels 
    ((nonfinalWildPattern? (rules) 
      (block 
       nil 
       (if (null rules) 
           (return nil) 
           (if (consp rules) 
               (let ((pV5 (cdr rules))) 
                 (progn (if (null pV5) (return nil)) 
                        (return 
                         (cl:or 
                          (PATTERNMATCH::wildPattern?-1 (car rules)) 
                          (nonfinalWildPattern? pV5))))))) 
       (error "Nonexhaustive match failure in checkUnreachableCase")))) 
    (if (nonfinalWildPattern? rules) 
        (STRING-SPEC::writeLine 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ "Warning: Unreachable case in " (svref context 1)) 
           "
") 
          (ANNSPECPRINTER::printTerm term))) 
        nil)))

(defun PATTERNMATCH::checkUnreachableCase-1 (x) 
  (PATTERNMATCH::checkUnreachableCase (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::coproductFields (spc srt) 
  (let ((pV5 (SPECENVIRONMENT::unfoldBase spc srt))) 
    (block 
     nil 
     (if (eq (car pV5) :|CoProduct|) 
         (return (car (cdr pV5))) 
         (if (eq (car pV5) :|Subsort|) 
             (return (PATTERNMATCH::coproductFields spc (svref (cdr pV5) 0))))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        "CoProduct sort expected, but got " 
        (ANNSPECPRINTER::printSort srt)))))))

(defun PATTERNMATCH::coproductFields-1 (x) 
  (PATTERNMATCH::coproductFields (car x) (cdr x)))

(defun PATTERNMATCH::eliminateSort-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::eliminateSort-1-1 x1 x2)))

(defun PATTERNMATCH::eliminateTerm-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::eliminateTerm-1-1 x1 x2)))

(defun PATTERNMATCH::freshVar (context srt) 
  (let ((num (INTEGER-SPEC::|!+| (STATE::|!!| (svref context 0)) 1))) 
    (progn (STATE::|:=| (svref context 0) num) 
           (cons (STRING-SPEC::|!++| "pV" (NAT-SPEC::toString num)) srt))))

(defun PATTERNMATCH::zipFields (fields terms) 
  (block 
   nil 
   (if (null fields) 
       (if (null terms) (return nil)) 
       (if (consp fields) 
           (if (consp terms) 
               (return 
                (LIST-SPEC::|!cons| 
                 (cons (cdr (car fields)) (cdr (car terms))) 
                 (PATTERNMATCH::zipFields (cdr fields) (cdr terms))))))) 
   (return (SYSTEM-SPEC::fail "zipFields: Uneven length of fields"))))

(defun SPECENVIRONMENT::product (sp srt) 
  (let ((pV3 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|Product|) (return (car (cdr pV3)))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        "Could not extract product sort " 
        (ANNSPECPRINTER::printSort srt)))))))

(defun SPECENVIRONMENT::mkProjectTerm (sp id term) 
  (let ((srt (SPECENVIRONMENT::inferType sp term))) 
    (let ((fields (SPECENVIRONMENT::product sp srt))) 
      (let ((pV3 
             (LIST-SPEC::|!find|-1-1 
              #'(lambda (x) (string=  id (car x))) 
              fields))) 
        (block 
         nil 
         (if (eq (car pV3) :|Some|) 
             (return 
              (STANDARDSPEC::mkApply 
               (cons 
                :|Fun| 
                (vector 
                 (cons :|Project| id) 
                 (STANDARDSPEC::mkArrow srt (cdr (cdr pV3))) 
                 POSITION-SPEC::noPos)) 
               term))) 
         (return (SYSTEM-SPEC::fail "Projection index not found in product")))))))


(defun PATTERNMATCH::flattenLetDecl (pV28 pV29) 
  (block 
   nil 
   (let ((pV31 (cdr pV28))
         (pV30 (car pV28))) 
     (let ((pV33 (cdr pV29))
           (pV32 (car pV29))) 
       (return 
        (block 
         nil 
         (if (eq (car pV30) :|WildPat|) 
             (progn (if (eq (car pV31) :|Var|) 
                        (return (cons pV32 pV33)) 
                        (if (eq (car pV31) :|Record|) 
                            (if (null (car (cdr pV31))) 
                                (return (cons pV32 pV33))))) 
                    (return 
                     (cons 
                      pV32 
                      (LIST-SPEC::|!cons| 
                       (cons 
                        (STANDARDSPEC::mkVarPat-1 
                         (PATTERNMATCH::freshVar 
                          pV32 
                          (METASLANG::patternSort pV30))) 
                        pV31) 
                       pV33)))) 
             (if (eq (car pV30) :|RecordPat|) 
                 (let ((pV17 (car (cdr pV30)))) 
                   (progn (if (eq (car pV31) :|Record|) 
                              (return 
                               (LIST-SPEC::foldr-1-1-1 
                                #'PATTERNMATCH::flattenLetDecl-1 
                                (cons pV32 pV33) 
                                (PATTERNMATCH::zipFields pV17 (car (cdr pV31)))))) 
                          (return 
                           (let ((v 
                                  (PATTERNMATCH::freshVar 
                                   pV32 
                                   (SPECENVIRONMENT::inferType 
                                    (svref pV32 2) 
                                    pV31)))) 
                             (let ((vTerm (STANDARDSPEC::mkVar-1 v))) 
                               (let ((decls1 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (x) 
                                          (cons 
                                           (cdr x) 
                                           (SPECENVIRONMENT::mkProjectTerm 
                                            (svref pV32 2) 
                                            (car x) 
                                            vTerm))) 
                                       pV17))) 
                                 (let ((pV9 
                                        (LIST-SPEC::foldr-1-1-1 
                                         #'PATTERNMATCH::flattenLetDecl-1 
                                         (cons pV32 pV33) 
                                         decls1))) 
                                   (block 
                                    nil 
                                    (return 
                                     (cons 
                                      (car pV9) 
                                      (LIST-SPEC::|!cons| 
                                       (cons (STANDARDSPEC::mkVarPat-1 v) pV31) 
                                       (LIST-SPEC::@ (cdr pV9) pV33)))) 
                                    (error 
                                     "Nonexhaustive match failure in flattenLetDecl"))))))))))) 
         (return (cons pV32 (LIST-SPEC::|!cons| (cons pV30 pV31) pV33))))))) 
   (error "Nonexhaustive match failure in flattenLetDecl")))

(defun PATTERNMATCH::flattenLetDecl-1 (x) 
  (PATTERNMATCH::flattenLetDecl (car x) (cdr x)))

(defun PATTERNMATCH::freshVars (num context pat) 
  (if ( =  num 0) 
      nil 
      (if ( =  num 1) 
          (cons 
           (cons 
            "" 
            (PATTERNMATCH::freshVar context (METASLANG::patternSort pat))) 
           nil) 
          (block 
           nil 
           (if (eq (car pat) :|RecordPat|) 
               (return 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons 
                     (car x) 
                     (PATTERNMATCH::freshVar 
                      context 
                      (METASLANG::patternSort (cdr x))))) 
                 (car (cdr pat))))) 
           (return (SYSTEM-SPEC::fail "Record pattern expected"))))))

(defparameter STANDARDSPEC::stringSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "String" "String")) nil))

(defun STANDARDSPEC::mkString (str) 
  (STANDARDSPEC::mkFun (cons :|String| str) STANDARDSPEC::stringSort))

(defun PATTERNMATCH::makeFail (name srt pV1) 
  (declare (ignore pV1)) 
  (let ((srt1 (STANDARDSPEC::mkArrow srt (PATTERNMATCH::match_type srt)))) 
    (let ((msg (STRING-SPEC::^ "Nonexhaustive match failure in " name))) 
      (STANDARDSPEC::mkApply 
       (STANDARDSPEC::mkOp 
        (cons :|Qualified| (cons "TranslationBuiltIn" "mkFail")) 
        srt1) 
       (STANDARDSPEC::mkString msg)))))

(defun PATTERNMATCH::mkLet (lets term) 
  (block 
   nil 
   (if (null lets) (return term)) 
   (return (STANDARDSPEC::mkLet lets term))))

(defun PATTERNMATCH::mkSuccess (srt0 trm) 
  (let ((srt (STANDARDSPEC::mkArrow srt0 (PATTERNMATCH::match_type srt0)))) 
    (STANDARDSPEC::mkApply 
     (STANDARDSPEC::mkOp 
      (cons :|Qualified| (cons "TranslationBuiltIn" "mkSuccess")) 
      srt) 
     trm)))

(defun PATTERNMATCH::makeDefault (context srt rules vs term) 
  (labels 
    ((|!loop| (rules firstRules) 
      (block 
       nil 
       (if (null rules) 
           (return 
            (cons 
             (LIST-SPEC::rev firstRules) 
             (PATTERNMATCH::makeFail (svref context 1) srt term))) 
           (if (consp rules) 
               (let ((pV18 (cdr rules))
                     (pV17 (car rules))) 
                 (progn (let ((pV21 (svref pV17 2))
                              (pV20 (svref pV17 1))
                              (pV19 (svref pV17 0))) 
                          (if (eq (car pV19) :|WildPat|) 
                              (if (eq (car pV20) :|Fun|) 
                                  (let ((pV32 (svref (cdr pV20) 0))) 
                                    (if (eq (car pV32) :|Bool|) 
                                        (if (eq t (cdr pV32)) 
                                            (if (null pV18) 
                                                (return 
                                                 (cons 
                                                  (LIST-SPEC::rev firstRules) 
                                                  (PATTERNMATCH::mkSuccess 
                                                   srt 
                                                   pV21)))))))) 
                              (if (eq (car pV19) :|VarPat|) 
                                  (if (eq (car pV20) :|Fun|) 
                                      (let ((pV27 (svref (cdr pV20) 0))) 
                                        (if (eq (car pV27) :|Bool|) 
                                            (if (eq t (cdr pV27)) 
                                                (if (null pV18) 
                                                    (return 
                                                     (let ((term 
                                                            (block 
                                                             nil 
                                                             (if (consp vs) 
                                                                 (if (null 
                                                                      (cdr vs)) 
                                                                     (return 
                                                                      (cons 
                                                                       :|Var| 
                                                                       (cons 
                                                                        (cdr 
                                                                         (car vs)) 
                                                                        POSITION-SPEC::noPos))))) 
                                                             (return 
                                                              (cons 
                                                               :|Record| 
                                                               (cons 
                                                                (LIST-SPEC::|!map|-1-1 
                                                                 #'(lambda (x) 
                                                                    (cons 
                                                                     (car x) 
                                                                     (STANDARDSPEC::mkVar-1 
                                                                      (cdr x)))) 
                                                                 vs) 
                                                                POSITION-SPEC::noPos)))))) 
                                                       (let ((body 
                                                              (PATTERNMATCH::mkLet 
                                                               (cons 
                                                                (cons 
                                                                 (cons 
                                                                  :|VarPat| 
                                                                  (cons 
                                                                   (car 
                                                                    (cdr pV19)) 
                                                                   POSITION-SPEC::noPos)) 
                                                                 term) 
                                                                nil) 
                                                               pV21))) 
                                                         (cons 
                                                          (LIST-SPEC::rev 
                                                           firstRules) 
                                                          (PATTERNMATCH::mkSuccess 
                                                           srt 
                                                           body))))))))))))) 
                        (return 
                         (|!loop| pV18 (LIST-SPEC::|!cons| pV17 firstRules))))))) 
       (error "Nonexhaustive match failure in makeDefault")))) 
    (|!loop| rules nil)))

(defun PATTERNMATCH::isBreak (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV7 (svref (cdr term) 0))) 
         (if (eq (car pV7) :|Op|) 
             (let ((pV11 (car (cdr pV7)))) 
               (if (eq (car pV11) :|Qualified|) 
                   (let ((pV13 (cdr pV11))) 
                     (if (string=  "TranslationBuiltIn" (car pV13)) 
                         (if (string=  "mkBreak" (cdr pV13)) (return t))))))))) 
   (return nil)))

(defun PATTERNMATCH::isSuccess (trm) 
  (block 
   nil 
   (if (eq (car trm) :|Apply|) 
       (let ((pV9 (svref (cdr trm) 0))) 
         (if (eq (car pV9) :|Fun|) 
             (let ((pV13 (svref (cdr pV9) 0))) 
               (if (eq (car pV13) :|Op|) 
                   (let ((pV17 (car (cdr pV13)))) 
                     (if (eq (car pV17) :|Qualified|) 
                         (let ((pV19 (cdr pV17))) 
                           (if (string=  "TranslationBuiltIn" (car pV19)) 
                               (if (string=  "mkSuccess" (cdr pV19)) (return t))))))))))) 
   (return nil)))

(defun PATTERNMATCH::warnUnreachable-1 (context) 
  (STRING-SPEC::writeLine 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     (STRING-SPEC::^ "Warning: Redundant case in " (svref context 1)) 
     "
") 
    (let ((pV2 (svref context 3))) 
      (block 
       nil 
       (if (eq (car pV2) :|Some|) (return (ANNSPECPRINTER::printTerm (cdr pV2)))) 
       (return ""))))))

(defun PATTERNMATCH::failWith-1-1-1 (context t1 t2) 
  (if (PATTERNMATCH::isBreak t2) 
      t1 
      (if (PATTERNMATCH::isSuccess t1) 
          (progn (PATTERNMATCH::warnUnreachable-1 context) t1) 
          (let ((srt (SPECENVIRONMENT::inferType (svref context 2) t1))) 
            (let ((srt 
                   (STANDARDSPEC::mkArrow 
                    (STANDARDSPEC::mkProduct (cons srt (cons srt nil))) 
                    srt))) 
              (let ((trm 
                     (STANDARDSPEC::mkApply 
                      (STANDARDSPEC::mkOp 
                       (cons :|Qualified| (cons "TranslationBuiltIn" "failWith")) 
                       srt) 
                      (STANDARDSPEC::mkRecord 
                       (cons (cons "1" t1) (cons (cons "2" t2) nil)))))) trm))))))


(defun PATTERNMATCH::matchAlias
 (context pat1 pat2 terms rules default |!break|) 
  (let ((|!t| (LIST-SPEC::hd terms))) 
    (let ((rules 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (x) 
               (let ((pV2 (svref x 0))) 
                 (block 
                  nil 
                  (if (consp pV2) 
                      (return 
                       (vector 
                        (cons pat1 (cons pat2 (cdr pV2))) 
                        (svref x 1) 
                        (svref x 2)))) 
                  (error "Nonexhaustive match failure in matchAlias")))) 
            rules))) 
      (PATTERNMATCH::match 
       context 
       (LIST-SPEC::|!cons| |!t| terms) 
       rules 
       default 
       |!break|))))

(defun PATTERNMATCH::isTrue (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV6 (svref (cdr term) 0))) 
         (if (eq (car pV6) :|Bool|) (if (eq t (cdr pV6)) (return t))))) 
   (return nil)))

(defun PATTERNMATCH::mkOptimizedIfThenElse (|!cond| thenBranch elseBranch) 
  (if (PATTERNMATCH::isTrue |!cond|) 
      thenBranch 
      (STANDARDSPEC::mkIfThenElse |!cond| thenBranch elseBranch)))

(defun STANDARDSPEC::mkEmbedded (id srt) 
  (STANDARDSPEC::mkFun 
   (cons :|Embedded| id) 
   (STANDARDSPEC::mkArrow srt STANDARDSPEC::boolSort)))

(defun PATTERNMATCH::embedded-1-1 (constructorName term) 
  (STANDARDSPEC::mkApply 
   (STANDARDSPEC::mkEmbedded constructorName (METASLANG::termSort term)) 
   term))

(defun PATTERNMATCH::embedded (x1) 
  #'(lambda (x2) (PATTERNMATCH::embedded-1-1 x1 x2)))

(defun STANDARDSPEC::mkEquals (srt) (STANDARDSPEC::mkFun '(:|Equals|) srt))

(defun STANDARDSPEC::mkEquality (dom_sort t1 t2) 
  (let ((srt 
         (STANDARDSPEC::mkArrow 
          (STANDARDSPEC::mkProduct (cons dom_sort (cons dom_sort nil))) 
          STANDARDSPEC::boolSort))) 
    (STANDARDSPEC::mkApply 
     (STANDARDSPEC::mkEquals srt) 
     (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil))))))

(defun PATTERNMATCH::equalToConstant-1-1 (!x1 term) 
  (STANDARDSPEC::mkEquality (car !x1) (cdr !x1) term))

(defun PATTERNMATCH::equalToConstant-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::equalToConstant-1-1 x1 x2)))

(defun PATTERNMATCH::equalToConstant (x0 x1) 
  (PATTERNMATCH::equalToConstant-1 (cons x0 x1)))

(defparameter STANDARDSPEC::charSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Char" "Char")) nil))

(defun STANDARDSPEC::mkBool (bool) 
  (STANDARDSPEC::mkFun (cons :|Bool| bool) STANDARDSPEC::boolSort))

(defun STANDARDSPEC::mkChar (|!char|) 
  (STANDARDSPEC::mkFun (cons :|Char| |!char|) STANDARDSPEC::charSort))

(defparameter STANDARDSPEC::natSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Nat" "Nat")) nil))

(defun STANDARDSPEC::mkNat (n) 
  (STANDARDSPEC::mkFun (cons :|Nat| n) STANDARDSPEC::natSort))

(defun PATTERNMATCH::queryPat (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|EmbedPat|) 
       (return (PATTERNMATCH::embedded (svref (cdr pattern) 0))) 
       (if (eq (car pattern) :|NatPat|) 
           (return 
            (PATTERNMATCH::equalToConstant 
             STANDARDSPEC::natSort 
             (STANDARDSPEC::mkNat (car (cdr pattern))))) 
           (if (eq (car pattern) :|CharPat|) 
               (return 
                (PATTERNMATCH::equalToConstant 
                 STANDARDSPEC::charSort 
                 (STANDARDSPEC::mkChar (car (cdr pattern))))) 
               (if (eq (car pattern) :|BoolPat|) 
                   (return 
                    (PATTERNMATCH::equalToConstant 
                     STANDARDSPEC::boolSort 
                     (STANDARDSPEC::mkBool (car (cdr pattern))))) 
                   (if (eq (car pattern) :|StringPat|) 
                       (return 
                        (PATTERNMATCH::equalToConstant 
                         STANDARDSPEC::stringSort 
                         (STANDARDSPEC::mkString (car (cdr pattern))))) 
                       (if (eq (car pattern) :|RecordPat|) 
                           (return 
                            #'(lambda (pV9) 
                               (declare (ignore pV9)) 
                               (STANDARDSPEC::mkTrue))))))))) 
   (return #'(lambda (pV11) (declare (ignore pV11)) 
                            (STANDARDSPEC::mkTrue)))))

(defun PATTERNMATCH::queryPat-1-1 (x1 x2) 
  (funcall (PATTERNMATCH::queryPat x1) x2))

(defun PATTERNMATCH::sameConstructor (pat1 pat2) 
  (block 
   nil 
   (if (eq (car pat1) :|EmbedPat|) 
       (if (eq (car pat2) :|EmbedPat|) 
           (return (string=  (svref (cdr pat1) 0) (svref (cdr pat2) 0)))) 
       (if (eq (car pat1) :|RecordPat|) 
           (if (eq (car pat2) :|RecordPat|) (return t)))) 
   (return (METASLANG::equalPattern? pat1 pat2))))

(defun PATTERNMATCH::partitionConstructors (context |!t| rules) 
  (labels 
    ((patDecompose (pattern) 
      (block 
       nil 
       (if (eq (car pattern) :|RecordPat|) 
           (return 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (x) 
                (cons 
                 (cdr x) 
                 (SPECENVIRONMENT::mkProjectTerm (svref context 2) (car x) |!t|))) 
             (car (cdr pattern)))) 
           (if (eq (car pattern) :|EmbedPat|) 
               (let ((pV12 (cdr pattern))) 
                 (let ((pV16 (svref pV12 2))
                       (pV15 (svref pV12 1))
                       (pV14 (svref pV12 0))) 
                   (if (eq (car pV15) :|Some|) 
                       (return 
                        (let ((fields 
                               (PATTERNMATCH::coproductFields 
                                (svref context 2) 
                                pV16))) 
                          (let ((trm 
                                 (let ((pV5 
                                        (LIST-SPEC::|!find|-1-1 
                                         #'(lambda (x) (string=  pV14 (car x))) 
                                         fields))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV5) :|Some|) 
                                        (let ((pV8 (cdr (cdr pV5)))) 
                                          (if (eq (car pV8) :|Some|) 
                                              (return 
                                               (STANDARDSPEC::mkApply 
                                                (cons 
                                                 :|Fun| 
                                                 (vector 
                                                  (cons :|Select| pV14) 
                                                  (STANDARDSPEC::mkArrow 
                                                   pV16 
                                                   (cdr pV8)) 
                                                  POSITION-SPEC::noPos)) 
                                                |!t|))))) 
                                    (return 
                                     (SYSTEM-SPEC::fail 
                                      "Selection index not found in product")))))) 
                            (cons (cons (cdr pV15) trm) nil))))))))) 
       (return nil)))) 
    (labels 
      ((insert (rule rules) 
        (block 
         nil 
         (let ((pV37 (svref rule 2))
               (pV36 (svref rule 1))
               (pV35 (svref rule 0))) 
           (if (consp pV35) 
               (let ((pV40 (cdr pV35))
                     (pV39 (car pV35))) 
                 (if (null rules) 
                     (return 
                      (let ((query (PATTERNMATCH::queryPat-1-1 pV39 |!t|))) 
                        (let ((decomposition (patDecompose pV39))) 
                          (let ((newVars 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x) 
                                     (PATTERNMATCH::freshVar 
                                      context 
                                      (METASLANG::patternSort (car x)))) 
                                  decomposition))) 
                            (let ((lets 
                                   (LISTPAIR::|!map|-1-1 
                                    #'(lambda (x) 
                                       (block 
                                        nil 
                                        (return 
                                         (cons 
                                          (STANDARDSPEC::mkVarPat-1 (cdr x)) 
                                          (cdr (car x)))) 
                                        (error 
                                         "Nonexhaustive match failure in partitionConstructors"))) 
                                    (cons decomposition newVars)))) 
                              (let ((newPats 
                                     (LIST-SPEC::|!map|-1-1 
                                      #'(lambda (x) (car x)) 
                                      decomposition))) 
                                (cons 
                                 (vector 
                                  query 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'STANDARDSPEC::mkVar-1 
                                   newVars) 
                                  lets 
                                  pV39 
                                  (cons 
                                   (vector 
                                    (LIST-SPEC::concat newPats pV40) 
                                    pV36 
                                    pV37) 
                                   nil)) 
                                 nil))))))) 
                     (if (consp rules) 
                         (let ((pV43 (cdr rules))
                               (pV42 (car rules))) 
                           (let ((pV47 (svref pV42 3))) 
                             (return 
                              (if (PATTERNMATCH::sameConstructor pV39 pV47) 
                                  (let ((decomposition (patDecompose pV39))) 
                                    (let ((newPats 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) (car x)) 
                                            decomposition))) 
                                      (let ((rule1 
                                             (vector 
                                              (LIST-SPEC::concat newPats pV40) 
                                              pV36 
                                              pV37))) 
                                        (cons 
                                         (vector 
                                          (svref pV42 0) 
                                          (svref pV42 1) 
                                          (svref pV42 2) 
                                          pV47 
                                          (cons rule1 (svref pV42 4))) 
                                         pV43)))) 
                                  (if (LIST-SPEC::|!exists|-1-1 
                                       #'(lambda (x) 
                                          (PATTERNMATCH::sameConstructor 
                                           pV39 
                                           (svref x 3))) 
                                       pV43) 
                                      (LIST-SPEC::|!cons| 
                                       pV42 
                                       (insert rule pV43)) 
                                      (LIST-SPEC::concat 
                                       (insert rule nil) 
                                       (LIST-SPEC::|!cons| pV42 pV43)))))))))))) 
         (return rules)))) 
      (LIST-SPEC::foldr-1-1-1 
       #'(lambda (x) (insert (car x) (cdr x))) 
       nil 
       rules))))

(defun PATTERNMATCH::matchCon (context terms rules default |!break|) 
  (let ((|!t| (LIST-SPEC::hd terms))) 
    (let ((terms (LIST-SPEC::tl terms))) 
      (let ((rulePartition 
             (PATTERNMATCH::partitionConstructors context |!t| rules))) 
        (let ((rule 
               (LIST-SPEC::foldr-1-1-1 
                #'(lambda (x) 
                   (let ((pV2 (car x))) 
                     (block 
                      nil 
                      (return 
                       (PATTERNMATCH::mkOptimizedIfThenElse 
                        (svref pV2 0) 
                        (PATTERNMATCH::mkLet 
                         (svref pV2 2) 
                         (PATTERNMATCH::match 
                          context 
                          (LIST-SPEC::@ (svref pV2 1) terms) 
                          (svref pV2 4) 
                          |!break| 
                          |!break|)) 
                        (cdr x))) 
                      (error "Nonexhaustive match failure in matchCon")))) 
                |!break| 
                rulePartition))) 
          (PATTERNMATCH::failWith-1-1-1 context rule default))))))

(defun STANDARDSPEC::mkQuotientSort (srt rel) 
  (cons :|Quotient| (vector srt rel POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkChooseFun (equiv srt1 srt2 f) 
  (let ((chSrt 
         (STANDARDSPEC::mkArrow 
          (STANDARDSPEC::mkArrow srt1 srt2) 
          (STANDARDSPEC::mkArrow (STANDARDSPEC::mkQuotientSort srt1 equiv) srt2)))) 
    (let ((ch (STANDARDSPEC::mkFun '(:|Choose|) chSrt))) 
      (STANDARDSPEC::mkApply ch f))))

(defun PATTERNMATCH::matchQuotient (pV18 pV19 pV20 pV21 pV22) 
  (block 
   nil 
   (if (consp pV19) 
       (let ((pV24 (car pV19))) 
         (return 
          (let ((pV13 (SPECENVIRONMENT::inferType (svref pV18 2) pV24))) 
            (block 
             nil 
             (if (eq (car pV13) :|Quotient|) 
                 (let ((pV14 (cdr pV13))) 
                   (let ((pV15 (svref pV14 0))) 
                     (return 
                      (let ((v (cons "v" pV15))) 
                        (let ((f 
                               (STANDARDSPEC::mkLambda 
                                (cons :|VarPat| (cons v POSITION-SPEC::noPos)) 
                                (cons :|Var| (cons v POSITION-SPEC::noPos))))) 
                          (let ((t1 
                                 (STANDARDSPEC::mkApply 
                                  (STANDARDSPEC::mkChooseFun 
                                   (svref pV14 1) 
                                   pV15 
                                   pV15 
                                   f) 
                                  pV24))) 
                            (let ((rules 
                                   (LIST-SPEC::|!map|-1-1 
                                    #'(lambda (x) 
                                       (let ((pV3 (svref x 0))) 
                                         (block 
                                          nil 
                                          (if (consp pV3) 
                                              (let ((pV7 (car pV3))) 
                                                (if (eq (car pV7) :|QuotientPat|) 
                                                    (return 
                                                     (vector 
                                                      (cons 
                                                       (svref (cdr pV7) 0) 
                                                       (cdr pV3)) 
                                                      (svref x 1) 
                                                      (svref x 2)))))) 
                                          (error 
                                           "Nonexhaustive match failure in matchQuotient")))) 
                                    pV20))) 
                              (PATTERNMATCH::failWith-1-1-1 
                               pV18 
                               (PATTERNMATCH::match 
                                pV18 
                                (LIST-SPEC::|!cons| t1 (cdr pV19)) 
                                rules 
                                pV22 
                                pV22) 
                               pV21))))))))) 
             (error "Nonexhaustive match failure in matchQuotient")))))) 
   (error "Nonexhaustive match failure in matchQuotient")))

(defun SPECENVIRONMENT::mkRestrict (pV1 pV2) 
  (block 
   nil 
   (let ((pV4 (cdr pV2))) 
     (return 
      (let ((srt (SPECENVIRONMENT::inferType pV1 pV4))) 
        (let ((srt 
               (STANDARDSPEC::mkArrow 
                srt 
                (STANDARDSPEC::mkSubsort srt (car pV2))))) 
          (STANDARDSPEC::mkApply 
           (cons :|Fun| (vector '(:|Restrict|) srt POSITION-SPEC::noPos)) 
           pV4))))) 
   (error "Nonexhaustive match failure in mkRestrict")))

(defun PATTERNMATCH::matchSubsort (pV14 pV15 pV16 pV17 pV18 pV19) 
  (block 
   nil 
   (if (consp pV16) 
       (let ((pV21 (car pV16))) 
         (return 
          (progn (SPECENVIRONMENT::inferType (svref pV14 2) pV21) 
                 (let ((t1 
                        (SPECENVIRONMENT::mkRestrict 
                         (svref pV14 2) 
                         (cons pV15 pV21)))) 
                   (let ((rules 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x) 
                              (let ((pV4 (svref x 0))) 
                                (block 
                                 nil 
                                 (if (consp pV4) 
                                     (let ((pV8 (car pV4))) 
                                       (if (eq (car pV8) :|RelaxPat|) 
                                           (return 
                                            (vector 
                                             (LIST-SPEC::|!cons| 
                                              (svref (cdr pV8) 0) 
                                              (cdr pV4)) 
                                             (svref x 1) 
                                             (svref x 2)))))) 
                                 (error 
                                  "Nonexhaustive match failure in matchSubsort")))) 
                           pV17))) 
                     (PATTERNMATCH::failWith-1-1-1 
                      pV14 
                      (STANDARDSPEC::mkIfThenElse 
                       (STANDARDSPEC::mkApply pV15 pV21) 
                       (PATTERNMATCH::match 
                        pV14 
                        (LIST-SPEC::|!cons| t1 (cdr pV16)) 
                        rules 
                        pV19 
                        pV19) 
                       pV19) 
                      pV18))))))) 
   (error "Nonexhaustive match failure in matchSubsort")))

(defun PATTERNMATCH::substPat (e pat |!t|) 
  (if (PATTERNMATCH::isTrue e) 
      e 
      (block 
       nil 
       (if (eq (car pat) :|WildPat|) 
           (return e) 
           (if (eq (car pat) :|VarPat|) 
               (return (PATTERNMATCH::mkLet (cons (cons pat |!t|) nil) e)))) 
       (return e))))

(defun PATTERNMATCH::matchVar (context terms rules default |!break|) 
  (let ((|!t| (LIST-SPEC::hd terms))) 
    (let ((terms (LIST-SPEC::tl terms))) 
      (let ((rules 
             (LIST-SPEC::|!map|-1-1 
              #'(lambda (x) 
                 (let ((pV2 (svref x 0))) 
                   (block 
                    nil 
                    (if (consp pV2) 
                        (let ((pV6 (car pV2))) 
                          (return 
                           (vector 
                            (cdr pV2) 
                            (PATTERNMATCH::substPat (svref x 1) pV6 |!t|) 
                            (PATTERNMATCH::substPat (svref x 2) pV6 |!t|))))) 
                    (return (SYSTEM-SPEC::fail "Empty list of patterns "))))) 
              rules))) 
        (PATTERNMATCH::match context terms rules default |!break|)))))

(defun PATTERNMATCH::ruleType-1 (q) 
  (let ((pV45 (svref q 0))) 
    (block 
     nil 
     (if (consp pV45) 
         (let ((pV49 (car pV45))) 
           (if (eq (car pV49) :|VarPat|) 
               (return '(:|Var|)) 
               (if (eq (car pV49) :|WildPat|) 
                   (return '(:|Var|)) 
                   (if (eq (car pV49) :|AliasPat|) 
                       (let ((pV59 (cdr pV49))) 
                         (return 
                          (cons :|Alias| (cons (svref pV59 0) (svref pV59 1))))) 
                       (if (eq (car pV49) :|EmbedPat|) 
                           (return '(:|Con|)) 
                           (if (eq (car pV49) :|RecordPat|) 
                               (return '(:|Con|)) 
                               (if (eq (car pV49) :|StringPat|) 
                                   (return '(:|Con|)) 
                                   (if (eq (car pV49) :|BoolPat|) 
                                       (return '(:|Con|)) 
                                       (if (eq (car pV49) :|NatPat|) 
                                           (return '(:|Con|)) 
                                           (if (eq (car pV49) :|CharPat|) 
                                               (return '(:|Con|)) 
                                               (if (eq (car pV49) :|RelaxPat|) 
                                                   (let ((pV52 (cdr pV49))) 
                                                     (return 
                                                      (cons 
                                                       :|Relax| 
                                                       (cons 
                                                        (svref pV52 0) 
                                                        (svref pV52 1))))) 
                                                   (if (eq 
                                                        (car pV49) 
                                                        :|QuotientPat|) 
                                                       (let ((pV51 (cdr pV49))) 
                                                         (return 
                                                          (cons 
                                                           :|Quotient| 
                                                           (cons 
                                                            (svref pV51 0) 
                                                            (svref pV51 1)))))))))))))))))) 
     (error "Nonexhaustive match failure in ruleType"))))

(defun PATTERNMATCH::matchRules-1-1 (!x1 x) 
  (let ((vars (svref !x1 2))
        (|!break| (svref !x1 1))
        (context (svref !x1 0))) 
    (let ((rules (car x))
          (default (cdr x))) 
      (let ((pV2 (PATTERNMATCH::ruleType-1 (LIST-SPEC::hd rules)))) 
        (block 
         nil 
         (if (eq (car pV2) :|Var|) 
             (return 
              (PATTERNMATCH::matchVar context vars rules default |!break|)) 
             (if (eq (car pV2) :|Con|) 
                 (return 
                  (PATTERNMATCH::matchCon context vars rules default |!break|)) 
                 (if (eq (car pV2) :|Alias|) 
                     (let ((pV5 (cdr pV2))) 
                       (return 
                        (PATTERNMATCH::matchAlias 
                         context 
                         (car pV5) 
                         (cdr pV5) 
                         vars 
                         rules 
                         default 
                         |!break|))) 
                     (if (eq (car pV2) :|Relax|) 
                         (return 
                          (PATTERNMATCH::matchSubsort 
                           context 
                           (cdr (cdr pV2)) 
                           vars 
                           rules 
                           default 
                           |!break|)) 
                         (if (eq (car pV2) :|Quotient|) 
                             (return 
                              (PATTERNMATCH::matchQuotient 
                               context 
                               vars 
                               rules 
                               default 
                               |!break|))))))) 
         (error "Nonexhaustive match failure in matchRules"))))))

(defun PATTERNMATCH::matchRules-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::matchRules-1-1 x1 x2)))

(defun PATTERNMATCH::matchRules (x0 x1 x2) 
  (PATTERNMATCH::matchRules-1 (vector x0 x1 x2)))

(defun PATTERNMATCH::tack-1-1 (x xss) 
  (cons (cons x (LIST-SPEC::hd xss)) (LIST-SPEC::tl xss)))

(defun PATTERNMATCH::partition-1-1 (f qs) 
  (block 
   nil 
   (if (null qs) 
       (return nil) 
       (if (consp qs) 
           (let ((pV3 (car qs))
                 (pV4 (cdr qs))) 
             (if (null pV4) 
                 (return (cons (cons pV3 nil) nil)) 
                 (if (consp pV4) 
                     (let ((pV6 (car pV4))
                           (pV7 (cdr pV4))) 
                       (return 
                        (if (slang-built-in::slang-term-equals 
                             (funcall f pV3) 
                             (funcall f pV6)) 
                            (PATTERNMATCH::tack-1-1 
                             pV3 
                             (PATTERNMATCH::partition-1-1 
                              f 
                              (LIST-SPEC::|!cons| pV6 pV7))) 
                            (cons 
                             (cons pV3 nil) 
                             (PATTERNMATCH::partition-1-1 
                              f 
                              (LIST-SPEC::|!cons| pV6 pV7))))))))))) 
   (error "Nonexhaustive match failure in partition")))

(defun PATTERNMATCH::match (context vars rules default |!break|) 
  (block 
   nil 
   (if (null vars) 
       (return 
        (LIST-SPEC::foldr-1-1-1 
         #'(lambda (x) 
            (let ((pV2 (car x))) 
              (block 
               nil 
               (return 
                (PATTERNMATCH::failWith-1-1-1 
                 context 
                 (PATTERNMATCH::mkOptimizedIfThenElse 
                  (svref pV2 1) 
                  (svref pV2 2) 
                  |!break|) 
                 (cdr x))) 
               (error "Nonexhaustive match failure in match")))) 
         default 
         rules)) 
       (if (consp vars) 
           (return 
            (let ((rules 
                   (PATTERNMATCH::partition-1-1 #'PATTERNMATCH::ruleType-1 rules))) 
              (LIST-SPEC::foldr-1-1-1 
               (PATTERNMATCH::matchRules context |!break| vars) 
               default 
               rules))))) 
   (error "Nonexhaustive match failure in match")))

(defun PATTERNMATCH::mkBreak (srt) 
  (STANDARDSPEC::mkOp 
   (cons :|Qualified| (cons "TranslationBuiltIn" "mkBreak")) 
   (PATTERNMATCH::match_type srt)))

(defun PATTERNMATCH::normalizeSimpleAlias (rules) 
  (block 
   nil 
   (if (consp rules) 
       (let ((pV4 (car rules))) 
         (let ((pV6 (svref pV4 0))) 
           (if (eq (car pV6) :|AliasPat|) 
               (let ((pV9 (cdr pV6))) 
                 (let ((pV12 (svref pV9 2))
                       (pV10 (svref pV9 0))) 
                   (if (eq (car pV10) :|VarPat|) 
                       (let ((pV13 (cdr pV10))) 
                         (let ((pV15 (cdr pV13))
                               (pV14 (car pV13))) 
                           (if (null (cdr rules)) 
                               (return 
                                (cons 
                                 (vector 
                                  (cons :|VarPat| (cons pV14 pV15)) 
                                  (STANDARDSPEC::mkTrue) 
                                  (cons 
                                   :|Apply| 
                                   (vector 
                                    (cons 
                                     :|Lambda| 
                                     (cons 
                                      (cons 
                                       (vector 
                                        (svref pV9 1) 
                                        (svref pV4 1) 
                                        (svref pV4 2)) 
                                       nil) 
                                      pV12)) 
                                    (cons :|Var| (cons pV14 pV15)) 
                                    pV12))) 
                                 nil)))))))))))) 
   (return rules)))

(defun PATTERNMATCH::simplePattern (pattern) 
  (block nil (if (eq (car pattern) :|VarPat|) (return t)) (return nil)))

(defun PATTERNMATCH::simpleAbstraction (rules) 
  (block 
   nil 
   (if (consp rules) 
       (let ((pV9 (cdr rules))
             (pV8 (car rules))) 
         (let ((pV11 (svref pV8 1))
               (pV10 (svref pV8 0))) 
           (progn (if (eq (car pV10) :|RecordPat|) 
                      (if (null pV9) 
                          (return 
                           (cl:and 
                            (PATTERNMATCH::isTrue pV11) 
                            (LIST-SPEC::all-1-1 
                             #'(lambda (x) 
                                (PATTERNMATCH::simplePattern (cdr x))) 
                             (car (cdr pV10))))))) 
                  (if (null pV9) 
                      (return 
                       (cl:and 
                        (PATTERNMATCH::simplePattern pV10) 
                        (PATTERNMATCH::isTrue pV11)))))))) 
   (return nil)))

(defun PATTERNMATCH::splitPattern (arity pat) 
  (if ( =  arity 1) 
      (cons pat nil) 
      (block 
       nil 
       (if (eq (car pat) :|RecordPat|) 
           (return 
            (LIST-SPEC::|!map|-1-1 #'(lambda (x) (cdr x)) (car (cdr pat)))) 
           (if (eq (car pat) :|WildPat|) 
               (return 
                (LIST-SPEC::tabulate 
                 arity 
                 #'(lambda (pV4) (declare (ignore pV4)) 
                                 pat))))) 
       (return (SYSTEM-SPEC::fail "Unexpected pattern")))))

(defun PATTERNMATCH::storeTerm (pV1 pV2) 
  (block 
   nil 
   (return (vector (svref pV2 0) (svref pV2 1) (svref pV2 2) (cons :|Some| pV1))) 
   (error "Nonexhaustive match failure in storeTerm")))

(defun PATTERNMATCH::eliminateTerm-1-1 (context term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (return 
        (let ((rules (PATTERNMATCH::normalizeSimpleAlias (car (cdr term))))) 
          (let ((arity (ARITYNORMALIZE::matchArity rules))) 
            (let ((rules 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (x) 
                       (vector 
                        (PATTERNMATCH::eliminatePattern-1-1 context (svref x 0)) 
                        (PATTERNMATCH::eliminateTerm-1-1 context (svref x 1)) 
                        (PATTERNMATCH::eliminateTerm-1-1 context (svref x 2)))) 
                    rules))) 
              (if (PATTERNMATCH::simpleAbstraction rules) 
                  (cons :|Lambda| (cons rules POSITION-SPEC::noPos)) 
                  (progn (PATTERNMATCH::checkUnreachableCase context term rules) 
                         (let ((pV6 (LIST-SPEC::hd rules))) 
                           (block 
                            nil 
                            (return 
                             (let ((bdySort 
                                    (SPECENVIRONMENT::inferType 
                                     (svref context 2) 
                                     (svref pV6 2)))) 
                               (let ((vs 
                                      (PATTERNMATCH::freshVars 
                                       arity 
                                       context 
                                       (svref pV6 0)))) 
                                 (let ((pV3 
                                        (PATTERNMATCH::makeDefault 
                                         context 
                                         bdySort 
                                         rules 
                                         vs 
                                         term))) 
                                   (block 
                                    nil 
                                    (return 
                                     (let ((rules 
                                            (LIST-SPEC::|!map|-1-1 
                                             #'(lambda (x) 
                                                (vector 
                                                 (PATTERNMATCH::splitPattern 
                                                  arity 
                                                  (svref x 0)) 
                                                 (svref x 1) 
                                                 (PATTERNMATCH::mkSuccess 
                                                  bdySort 
                                                  (svref x 2)))) 
                                             (car pV3)))) 
                                       (let ((vars 
                                              (LIST-SPEC::|!map|-1-1 
                                               #'(lambda (x) 
                                                  (STANDARDSPEC::mkVar-1 (cdr x))) 
                                               vs))) 
                                         (let ((trm 
                                                (PATTERNMATCH::match 
                                                 (PATTERNMATCH::storeTerm 
                                                  term 
                                                  context) 
                                                 vars 
                                                 rules 
                                                 (cdr pV3) 
                                                 (PATTERNMATCH::mkBreak bdySort)))) 
                                           (let ((trm 
                                                  (PATTERNMATCH::abstract 
                                                   vs 
                                                   trm 
                                                   bdySort))) trm))))) 
                                    (error 
                                     "Nonexhaustive match failure in eliminateTerm")))))) 
                            (error 
                             "Nonexhaustive match failure in eliminateTerm"))))))))) 
       (if (eq (car term) :|Let|) 
           (let ((pV42 (cdr term))) 
             (return 
              (let ((decls 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x) 
                         (cons 
                          (PATTERNMATCH::eliminatePattern-1-1 context (car x)) 
                          (PATTERNMATCH::eliminateTerm-1-1 context (cdr x)))) 
                      (svref pV42 0)))) 
                (let ((body 
                       (PATTERNMATCH::eliminateTerm-1-1 context (svref pV42 1)))) 
                  (let ((pV26 
                         (LIST-SPEC::foldr-1-1-1 
                          #'PATTERNMATCH::flattenLetDecl-1 
                          (cons context decls) 
                          nil))) 
                    (block 
                     nil 
                     (let ((pV27 (car pV26))
                           (pV28 (cdr pV26))) 
                       (return 
                        (if (LIST-SPEC::all-1-1 
                             #'(lambda (x) 
                                (PATTERNMATCH::simplePattern (car x))) 
                             pV28) 
                            (PATTERNMATCH::mkLet pV28 body) 
                            (let ((pV23 (LISTPAIR::unzip pV28))) 
                              (block 
                               nil 
                               (let ((pV24 (car pV23))
                                     (pV25 (cdr pV23))) 
                                 (return 
                                  (let ((trm 
                                         (block 
                                          nil 
                                          (if (consp pV25) 
                                              (if (null (cdr pV25)) 
                                                  (return (car pV25)))) 
                                          (return (STANDARDSPEC::mkTuple pV25))))) 
                                    (let ((bdySrt 
                                           (SPECENVIRONMENT::inferType 
                                            (svref pV27 2) 
                                            body))) 
                                      (let ((vs 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'(lambda (pat) 
                                                 (PATTERNMATCH::freshVar 
                                                  pV27 
                                                  (METASLANG::patternSort pat))) 
                                              pV24))) 
                                        (let ((pV20 
                                               (LIST-SPEC::foldl-1-1-1 
                                                #'(lambda (x) 
                                                   (let ((pV17 (cdr x))) 
                                                     (block 
                                                      nil 
                                                      (let ((pV19 (cdr pV17))) 
                                                        (return 
                                                         (cons 
                                                          (LIST-SPEC::|!cons| 
                                                           (cons 
                                                            (NAT-SPEC::toString 
                                                             pV19) 
                                                            (car x)) 
                                                           (car pV17)) 
                                                          (INTEGER-SPEC::|!+| 
                                                           pV19 
                                                           1)))) 
                                                      (error 
                                                       "Nonexhaustive match failure in eliminateTerm")))) 
                                                (cons nil 1) 
                                                vs))) 
                                          (block 
                                           nil 
                                           (return 
                                            (let ((|!t| 
                                                   (PATTERNMATCH::match 
                                                    pV27 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'STANDARDSPEC::mkVar-1 
                                                     vs) 
                                                    (cons 
                                                     (vector 
                                                      pV24 
                                                      (STANDARDSPEC::mkTrue) 
                                                      (PATTERNMATCH::mkSuccess 
                                                       bdySrt 
                                                       body)) 
                                                     nil) 
                                                    (PATTERNMATCH::makeFail 
                                                     (svref pV27 1) 
                                                     bdySrt 
                                                     term) 
                                                    (PATTERNMATCH::mkBreak 
                                                     bdySrt)))) 
                                              (let ((|!t| 
                                                     (PATTERNMATCH::abstract 
                                                      (car pV20) 
                                                      |!t| 
                                                      bdySrt))) 
                                                (STANDARDSPEC::mkApply |!t| trm)))) 
                                           (error 
                                            "Nonexhaustive match failure in eliminateTerm")))))))) 
                               (error 
                                "Nonexhaustive match failure in eliminateTerm")))))) 
                     (error "Nonexhaustive match failure in eliminateTerm"))))))) 
           (if (eq (car term) :|Apply|) 
               (let ((pV41 (cdr term))) 
                 (return 
                  (cons 
                   :|Apply| 
                   (vector 
                    (PATTERNMATCH::eliminateTerm-1-1 context (svref pV41 0)) 
                    (PATTERNMATCH::eliminateTerm-1-1 context (svref pV41 1)) 
                    (svref pV41 2))))) 
               (if (eq (car term) :|Record|) 
                   (let ((pV40 (cdr term))) 
                     (return 
                      (cons 
                       :|Record| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (PATTERNMATCH::eliminateTerm-1-1 context (cdr x)))) 
                         (car pV40)) 
                        (cdr pV40))))) 
                   (if (eq (car term) :|Bind|) 
                       (let ((pV39 (cdr term))) 
                         (return 
                          (cons 
                           :|Bind| 
                           (vector 
                            (svref pV39 0) 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (car x) 
                                 (PATTERNMATCH::eliminateSort-1-1 
                                  context 
                                  (cdr x)))) 
                             (svref pV39 1)) 
                            (PATTERNMATCH::eliminateTerm-1-1 
                             context 
                             (svref pV39 2)) 
                            (svref pV39 3))))) 
                       (if (eq (car term) :|LetRec|) 
                           (let ((pV38 (cdr term))) 
                             (return 
                              (cons 
                               :|LetRec| 
                               (vector 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (x) 
                                    (let ((pV29 (car x))) 
                                      (block 
                                       nil 
                                       (return 
                                        (cons 
                                         (cons 
                                          (car pV29) 
                                          (PATTERNMATCH::eliminateSort-1-1 
                                           context 
                                           (cdr pV29))) 
                                         (PATTERNMATCH::eliminateTerm-1-1 
                                          context 
                                          (cdr x)))) 
                                       (error 
                                        "Nonexhaustive match failure in eliminateTerm")))) 
                                 (svref pV38 0)) 
                                (PATTERNMATCH::eliminateTerm-1-1 
                                 context 
                                 (svref pV38 1)) 
                                (svref pV38 2))))) 
                           (if (eq (car term) :|Var|) 
                               (let ((pV37 (cdr term))) 
                                 (let ((pV53 (car pV37))) 
                                   (return 
                                    (cons 
                                     :|Var| 
                                     (cons 
                                      (cons 
                                       (car pV53) 
                                       (PATTERNMATCH::eliminateSort-1-1 
                                        context 
                                        (cdr pV53))) 
                                      (cdr pV37)))))) 
                               (if (eq (car term) :|Fun|) 
                                   (let ((pV36 (cdr term))) 
                                     (return 
                                      (cons 
                                       :|Fun| 
                                       (vector 
                                        (svref pV36 0) 
                                        (PATTERNMATCH::eliminateSort-1-1 
                                         context 
                                         (svref pV36 1)) 
                                        (svref pV36 2))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV35 (cdr term))) 
                                         (return 
                                          (cons 
                                           :|IfThenElse| 
                                           (vector 
                                            (PATTERNMATCH::eliminateTerm-1-1 
                                             context 
                                             (svref pV35 0)) 
                                            (PATTERNMATCH::eliminateTerm-1-1 
                                             context 
                                             (svref pV35 1)) 
                                            (PATTERNMATCH::eliminateTerm-1-1 
                                             context 
                                             (svref pV35 2)) 
                                            (svref pV35 3))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (let ((pV34 (cdr term))) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 (PATTERNMATCH::eliminateTerm-1 
                                                  context) 
                                                 (car pV34)) 
                                                (cdr pV34))))))))))))))) 
   (error "Nonexhaustive match failure in eliminateTerm")))

(defun PATTERNMATCH::eliminateSort-1-1 (context srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV12 (cdr srt))) 
         (return 
          (cons 
           :|Arrow| 
           (vector 
            (PATTERNMATCH::eliminateSort-1-1 context (svref pV12 0)) 
            (PATTERNMATCH::eliminateSort-1-1 context (svref pV12 1)) 
            (svref pV12 2))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV11 (cdr srt))) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons 
                     (car x) 
                     (PATTERNMATCH::eliminateSort-1-1 context (cdr x)))) 
                 (car pV11)) 
                (cdr pV11))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV10 (cdr srt))) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((pV1 (car x))
                              (pV2 (cdr x))) 
                          (block 
                           nil 
                           (if (eq (car pV2) :|Some|) 
                               (return 
                                (cons 
                                 pV1 
                                 (cons 
                                  :|Some| 
                                  (PATTERNMATCH::eliminateSort-1-1 
                                   context 
                                   (cdr pV2))))) 
                               (if (eq (car pV2) :|None|) 
                                   (return (cons pV1 '(:|None|))))) 
                           (error "Nonexhaustive match failure in eliminateSort")))) 
                     (car pV10)) 
                    (cdr pV10))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV9 (cdr srt))) 
                     (return 
                      (cons 
                       :|Quotient| 
                       (vector 
                        (PATTERNMATCH::eliminateSort-1-1 context (svref pV9 0)) 
                        (PATTERNMATCH::eliminateTerm-1-1 context (svref pV9 1)) 
                        (svref pV9 2))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV8 (cdr srt))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector 
                            (PATTERNMATCH::eliminateSort-1-1 
                             context 
                             (svref pV8 0)) 
                            (PATTERNMATCH::eliminateTerm-1-1 
                             context 
                             (svref pV8 1)) 
                            (svref pV8 2))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV7 (cdr srt))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector 
                                (svref pV7 0) 
                                (LIST-SPEC::|!map|-1-1 
                                 (PATTERNMATCH::eliminateSort-1 context) 
                                 (svref pV7 1)) 
                                (svref pV7 2))))) 
                           (if (eq (car srt) :|TyVar|) (return srt)))))))) 
   (error "Nonexhaustive match failure in eliminateSort")))

(defun PATTERNMATCH::eliminatePattern-1-1 (context pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV12 (cdr pat))) 
         (return 
          (cons 
           :|AliasPat| 
           (vector 
            (PATTERNMATCH::eliminatePattern-1-1 context (svref pV12 0)) 
            (PATTERNMATCH::eliminatePattern-1-1 context (svref pV12 1)) 
            (svref pV12 2))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV11 (cdr pat))) 
             (let ((pV36 (car pV11))) 
               (return 
                (cons 
                 :|VarPat| 
                 (cons 
                  (cons 
                   (car pV36) 
                   (PATTERNMATCH::eliminateSort-1-1 context (cdr pV36))) 
                  (cdr pV11)))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV10 (cdr pat))) 
                 (let ((pV31 (svref pV10 0))
                       (pV32 (svref pV10 1))
                       (pV33 (svref pV10 2))
                       (pV34 (svref pV10 3))) 
                   (if (eq (car pV32) :|Some|) 
                       (return 
                        (cons 
                         :|EmbedPat| 
                         (vector 
                          pV31 
                          (cons 
                           :|Some| 
                           (PATTERNMATCH::eliminatePattern-1-1 
                            context 
                            (cdr pV32))) 
                          (PATTERNMATCH::eliminateSort-1-1 context pV33) 
                          pV34))) 
                       (if (eq (car pV32) :|None|) 
                           (return 
                            (cons 
                             :|EmbedPat| 
                             (vector 
                              pV31 
                              '(:|None|) 
                              (PATTERNMATCH::eliminateSort-1-1 context pV33) 
                              pV34))))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (let ((pV9 (cdr pat))) 
                     (return 
                      (cons 
                       :|RecordPat| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (PATTERNMATCH::eliminatePattern-1-1 context (cdr x)))) 
                         (car pV9)) 
                        (cdr pV9))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (let ((pV8 (cdr pat))) 
                         (return 
                          (cons 
                           :|VarPat| 
                           (cons 
                            (PATTERNMATCH::freshVar 
                             context 
                             (PATTERNMATCH::eliminateSort-1-1 context (car pV8))) 
                            (cdr pV8))))) 
                       (if (eq (car pat) :|StringPat|) 
                           (let ((pV7 (cdr pat))) 
                             (return 
                              (cons :|StringPat| (cons (car pV7) (cdr pV7))))) 
                           (if (eq (car pat) :|BoolPat|) 
                               (let ((pV6 (cdr pat))) 
                                 (return 
                                  (cons :|BoolPat| (cons (car pV6) (cdr pV6))))) 
                               (if (eq (car pat) :|CharPat|) 
                                   (let ((pV5 (cdr pat))) 
                                     (return 
                                      (cons 
                                       :|CharPat| 
                                       (cons (car pV5) (cdr pV5))))) 
                                   (if (eq (car pat) :|NatPat|) 
                                       (let ((pV4 (cdr pat))) 
                                         (return 
                                          (cons 
                                           :|NatPat| 
                                           (cons (car pV4) (cdr pV4))))) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (let ((pV3 (cdr pat))) 
                                             (return 
                                              (cons 
                                               :|RelaxPat| 
                                               (vector 
                                                (PATTERNMATCH::eliminatePattern-1-1 
                                                 context 
                                                 (svref pV3 0)) 
                                                (PATTERNMATCH::eliminateTerm-1-1 
                                                 context 
                                                 (svref pV3 1)) 
                                                (svref pV3 2))))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (let ((pV2 (cdr pat))) 
                                                 (return 
                                                  (cons 
                                                   :|QuotientPat| 
                                                   (vector 
                                                    (PATTERNMATCH::eliminatePattern-1-1 
                                                     context 
                                                     (svref pV2 0)) 
                                                    (PATTERNMATCH::eliminateTerm-1-1 
                                                     context 
                                                     (svref pV2 1)) 
                                                    (svref pV2 2)))))))))))))))) 
   (error "Nonexhaustive match failure in eliminatePattern")))

(defun PATTERNMATCH::eliminatePattern-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::eliminatePattern-1-1 x1 x2)))

(defun PATTERNMATCH::eliminatePattern (x0 x1 x2 x3) 
  (PATTERNMATCH::eliminatePattern-1 (vector x0 x1 x2 x3)))

(defun PATTERNMATCH::eliminateSort (x0 x1 x2 x3) 
  (PATTERNMATCH::eliminateSort-1 (vector x0 x1 x2 x3)))

(defun PATTERNMATCH::eliminateTerm (x0 x1 x2 x3) 
  (PATTERNMATCH::eliminateTerm-1 (vector x0 x1 x2 x3)))

(defun PATTERNMATCH::failWith-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (PATTERNMATCH::failWith-1-1-1 x1 x2 x3))))

(defun PATTERNMATCH::failWith (x0 x1 x2 x3) 
  (PATTERNMATCH::failWith-1 (vector x0 x1 x2 x3)))

(defun PATTERNMATCH::freshVar-1 (x) (PATTERNMATCH::freshVar (car x) (cdr x)))

(defun PATTERNMATCH::freshVars-1 (x) 
  (PATTERNMATCH::freshVars (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::isShortTuple (i row) 
  (block 
   nil 
   (if (null row) 
       (return t) 
       (if (consp row) 
           (return 
            (cl:and 
             (string=  (car (car row)) (NAT-SPEC::toString i)) 
             (PATTERNMATCH::isShortTuple (INTEGER-SPEC::|!+| i 1) (cdr row)))))) 
   (error "Nonexhaustive match failure in isShortTuple")))

(defun PATTERNMATCH::isShortTuple-1 (x) 
  (PATTERNMATCH::isShortTuple (car x) (cdr x)))

(defun PATTERNMATCH::makeDefault-1 (x) 
  (PATTERNMATCH::makeDefault 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun PATTERNMATCH::makeFail-1 (x) 
  (PATTERNMATCH::makeFail (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::match-1 (x) 
  (PATTERNMATCH::match 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun PATTERNMATCH::matchAlias-1 (x) 
  (PATTERNMATCH::matchAlias 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun PATTERNMATCH::matchCon-1 (x) 
  (PATTERNMATCH::matchCon 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun PATTERNMATCH::matchQuotient-1 (x) 
  (PATTERNMATCH::matchQuotient 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun PATTERNMATCH::matchSubsort-1 (x) 
  (PATTERNMATCH::matchSubsort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun PATTERNMATCH::matchVar-1 (x) 
  (PATTERNMATCH::matchVar 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun PATTERNMATCH::mkLet-1 (x) (PATTERNMATCH::mkLet (car x) (cdr x)))

(defun PATTERNMATCH::mkOptimizedIfThenElse-1 (x) 
  (PATTERNMATCH::mkOptimizedIfThenElse (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::mkSuccess-1 (x) (PATTERNMATCH::mkSuccess (car x) (cdr x)))

(defun PATTERNMATCH::partition (x1) 
  #'(lambda (x2) (PATTERNMATCH::partition-1-1 x1 x2)))

(defun PATTERNMATCH::partitionConstructors-1 (x) 
  (PATTERNMATCH::partitionConstructors (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::printRule (pats |!cond| body) 
  (progn (STRING-SPEC::toScreen "Pattern : ") 
         (LIST-SPEC::app-1-1 
          #'(lambda (p) 
             (STRING-SPEC::toScreen 
              (STRING-SPEC::^ (ANNSPECPRINTER::printPattern p) " "))) 
          pats) 
         (STRING-SPEC::writeLine "") 
         (STRING-SPEC::writeLine 
          (STRING-SPEC::^ "Condition: " (ANNSPECPRINTER::printTerm |!cond|))) 
         (STRING-SPEC::writeLine 
          (STRING-SPEC::^ "Body: " (ANNSPECPRINTER::printTerm body)))))

(defun PATTERNMATCH::printRule-1 (x) 
  (PATTERNMATCH::printRule (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::recordfields? (fields) 
  (BOOLEAN-SPEC::~ (PATTERNMATCH::isShortTuple 1 fields)))

(defun PATTERNMATCH::relaxed-1-1 (predicate term) 
  (STANDARDSPEC::mkApply predicate term))

(defun PATTERNMATCH::relaxed (x1) 
  #'(lambda (x2) (PATTERNMATCH::relaxed-1-1 x1 x2)))

(defun PATTERNMATCH::ruleType (x0 x1 x2) 
  (PATTERNMATCH::ruleType-1 (vector x0 x1 x2)))

(defun PATTERNMATCH::sameConstructor-1 (x) 
  (PATTERNMATCH::sameConstructor (car x) (cdr x)))

(defun PATTERNMATCH::splitPattern-1 (x) 
  (PATTERNMATCH::splitPattern (car x) (cdr x)))

(defun PATTERNMATCH::storeTerm-1 (x) (PATTERNMATCH::storeTerm (car x) (cdr x)))

(defun PATTERNMATCH::substPat-1 (x) 
  (PATTERNMATCH::substPat (svref x 0) (svref x 1) (svref x 2)))

(defun PATTERNMATCH::tack (x1) 
  #'(lambda (x2) (PATTERNMATCH::tack-1-1 x1 x2)))

(defun PATTERNMATCH::translateMatch-1 (spc) 
  (let ((mkContext 
         #'(lambda (funName) (vector (cons :|Ref| 0) funName spc '(:|None|))))) 
    (vector 
     (svref spc 0) 
     (mapiAQualifierMap-1-1 
      #'(lambda (x) 
         (let ((pV3 (svref x 2))
               (pV2 (svref x 1))) 
           (block 
            nil 
            (let ((pV6 (svref pV3 2))) 
              (return 
               (vector 
                (svref pV3 0) 
                (svref pV3 1) 
                (cons 
                 (car pV6) 
                 (PATTERNMATCH::eliminateSort-1-1 
                  (funcall mkContext pV2) 
                  (cdr pV6))) 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x1) 
                    (cons 
                     (car x1) 
                     (PATTERNMATCH::eliminateTerm-1-1 
                      (funcall mkContext pV2) 
                      (cdr x1)))) 
                 (svref pV3 3))))) 
            (error "Nonexhaustive match failure in translateMatch")))) 
      (svref spc 1)) 
     (LIST-SPEC::|!map|-1-1 
      #'(lambda (x) 
         (let ((name (svref x 1))) 
           (vector 
            (svref x 0) 
            name 
            (svref x 2) 
            (PATTERNMATCH::eliminateTerm-1-1 
             (funcall mkContext name) 
             (svref x 3))))) 
      (svref spc 2)) 
     (mapiAQualifierMap-1-1 
      #'(lambda (x) 
         (let ((pV12 (svref x 2))
               (pV11 (svref x 1))) 
           (block 
            nil 
            (return 
             (vector 
              (svref pV12 0) 
              (svref pV12 1) 
              (LIST-SPEC::|!map|-1-1 
               #'(lambda (x1) 
                  (cons 
                   (car x1) 
                   (PATTERNMATCH::eliminateSort-1-1 
                    (funcall mkContext pV11) 
                    (cdr x1)))) 
               (svref pV12 2)))) 
            (error "Nonexhaustive match failure in translateMatch")))) 
      (svref spc 3)))))

(defun PATTERNMATCH::translateMatch (x0 x1 x2 x3) 
  (PATTERNMATCH::translateMatch-1 (vector x0 x1 x2 x3)))

(defun PATTERNMATCH::warnUnreachable (x0 x1 x2 x3) 
  (PATTERNMATCH::warnUnreachable-1 (vector x0 x1 x2 x3)))

(defun PATTERNMATCH::wildPattern? (x0 x1 x2) 
  (PATTERNMATCH::wildPattern?-1 (vector x0 x1 x2)))

(defun PATTERNMATCH::zipFields-1 (x) (PATTERNMATCH::zipFields (car x) (cdr x)))

(defun POLYMAP::compose-1-1 (|!m1| |!m2|) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (new_map) 
      #'(lambda (dom) 
         #'(lambda (med) 
            (let ((cod (POLYMAP::|!eval|-1-1 |!m2| med))) 
              (POLYMAP::update-1-1-1 new_map dom cod))))) 
   POLYMAP::emptyMap 
   |!m1|))

(defun POLYMAP::compose (x1) #'(lambda (x2) (POLYMAP::compose-1-1 x1 x2)))

(defun POLYMAP::|!eval| (x1) #'(lambda (x2) (POLYMAP::|!eval|-1-1 x1 x2)))

(defun POLYMAP::evalPartial (x1) 
  #'(lambda (x2) (POLYMAP::evalPartial-1-1 x1 x2)))

(defun POLYMAP::foldMap (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYMAP::foldMap-1-1-1 x1 x2 x3))))

(defun POLYMAP::imageToList (|!map|) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (|!values|) 
      #'(lambda (pV1) 
         (declare (ignore pV1)) 
         #'(lambda (value) (cons value |!values|)))) 
   nil 
   |!map|))

(defun POLYMAP::inDomain?-1-1 (|!map| key) 
  (block 
   nil 
   (if (null |!map|) 
       (return nil) 
       (if (consp |!map|) 
           (return 
            (cl:or 
             (slang-built-in::slang-term-equals (car (car |!map|)) key) 
             (POLYMAP::inDomain?-1-1 (cdr |!map|) key))))) 
   (error "Nonexhaustive match failure in inDomain?")))

(defun POLYMAP::inDomain? (x1) 
  #'(lambda (x2) (POLYMAP::inDomain?-1-1 x1 x2)))

(defun POLYMAP::mapMap (x1) #'(lambda (x2) (POLYMAP::mapMap-1-1 x1 x2)))

(defun POLYMAP::mapPartial (x1) 
  #'(lambda (x2) (POLYMAP::mapPartial-1-1 x1 x2)))

(defun POLYMAP::ppMap (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYMAP::ppMap-1-1-1 x1 x2 x3))))

(defun POLYMAP::|!remove|-1-1 (|!map| x) 
  (block 
   nil 
   (if (null |!map|) 
       (return nil) 
       (if (consp |!map|) 
           (let ((pV3 (car |!map|))
                 (pV4 (cdr |!map|))) 
             (let ((pV5 (car pV3))) 
               (return 
                (if (slang-built-in::slang-term-equals pV5 x) 
                    pV4 
                    (cons (cons pV5 (cdr pV3)) (POLYMAP::|!remove|-1-1 pV4 x)))))))) 
   (error "Nonexhaustive match failure in remove")))

(defun POLYMAP::|!remove| (x1) 
  #'(lambda (x2) (POLYMAP::|!remove|-1-1 x1 x2)))

(defun POLYMAP::update (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYMAP::update-1-1-1 x1 x2 x3))))

(defun POLYSET::|!find|-1-1 (pred s) 
  (block 
   nil 
   (if (null s) 
       (return '(:|None|)) 
       (if (consp s) 
           (let ((pV3 (car s))) 
             (return 
              (if (funcall pred pV3) 
                  (cons :|Some| pV3) 
                  (POLYSET::|!find|-1-1 pred (cdr s))))))) 
   (error "Nonexhaustive match failure in find")))

(defun POLYSET::|!find| (x1) #'(lambda (x2) (POLYSET::|!find|-1-1 x1 x2)))

(defun POLYSET::ppSet-1-1 (ppElem l) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "{") 
    (cons 
     (WADLERLINDIG::ppSep-1-1 
      (WADLERLINDIG::ppString ",") 
      (POLYSET::|!map|-1-1 ppElem l)) 
     (cons (WADLERLINDIG::ppString "}") nil)))))

(defun POLYSET::ppSet (x1) #'(lambda (x2) (POLYSET::ppSet-1-1 x1 x2)))

(defun POSSPEC::makeTyVarMap (fresh |!tyVars|) 
  (labels 
    ((insert (tv |!map|) (STRINGMAP::insert |!map| tv (funcall fresh tv)))) 
    (let ((m 
           (LIST-SPEC::foldr-1-1-1 
            #'(lambda (x) (insert (car x) (cdr x))) 
            STRINGMAP::empty 
            |!tyVars|))) 
      (cons 
       m 
       #'(lambda (pV4) 
          (block 
           nil 
           (if (eq (car pV4) :|Base|) 
               (let ((pV5 (cdr pV4))) 
                 (let ((pV6 (svref pV5 0))) 
                   (if (eq (car pV6) :|Qualified|) 
                       (if (null (svref pV5 1)) 
                           (return 
                            (let ((pV2 (STRINGMAP::|!find| m (cdr (cdr pV6))))) 
                              (block 
                               nil 
                               (if (eq (car pV2) :|Some|) 
                                   (return 
                                    (cons 
                                     :|TyVar| 
                                     (cons (cdr pV2) (svref pV5 2)))) 
                                   (if (eq (car pV2) :|None|) (return pV4))) 
                               (error 
                                "Nonexhaustive match failure in makeTyVarMap"))))))))) 
           (return pV4)))))))

(defun POSSPEC::mapImage (m vars) 
  (LIST-SPEC::|!map|-1-1 
   #'(lambda (d) 
      (let ((pV1 (STRINGMAP::|!find| m d))) 
        (block 
         nil 
         (if (eq (car pV1) :|Some|) (return (cdr pV1))) 
         (error "Nonexhaustive match failure in mapImage")))) 
   vars))

(defun POSSPEC::abstractSort (fresh |!tyVars| srt) 
  (if (LIST-SPEC::|!null| |!tyVars|) 
      (cons nil srt) 
      (let ((pV1 (POSSPEC::makeTyVarMap fresh |!tyVars|))) 
        (block 
         nil 
         (return 
          (let ((srt 
                 (METASLANG::mapSort-1-1 
                  (vector 
                   #'(lambda (|!M|) |!M|) 
                   (cdr pV1) 
                   #'(lambda (p) p)) 
                  srt))) (cons (POSSPEC::mapImage (car pV1) |!tyVars|) srt))) 
         (error "Nonexhaustive match failure in abstractSort")))))

(defun POSSPEC::abstractSort-1 (x) 
  (POSSPEC::abstractSort (svref x 0) (svref x 1) (svref x 2)))

(defun POSSPEC::abstractTerm (fresh |!tyVars| trm) 
  (let ((pV1 (POSSPEC::makeTyVarMap fresh |!tyVars|))) 
    (block 
     nil 
     (return 
      (let ((trm 
             (METASLANG::mapTerm-1-1 
              (vector #'(lambda (|!M|) |!M|) (cdr pV1) #'(lambda (p) p)) 
              trm))) (cons (POSSPEC::mapImage (car pV1) |!tyVars|) trm))) 
     (error "Nonexhaustive match failure in abstractTerm"))))

(defun POSSPEC::abstractTerm-1 (x) 
  (POSSPEC::abstractTerm (svref x 0) (svref x 1) (svref x 2)))

(defun POSSPEC::addPOp (pV29 pV30) 
  (block 
   nil 
   (let ((pV34 (svref pV29 3))
         (pV33 (svref pV29 2))
         (pV32 (svref pV29 1))
         (pV31 (svref pV29 0))) 
     (if (consp pV31) 
         (let ((pV36 (car pV31))) 
           (if (eq (car pV36) :|Qualified|) 
               (let ((pV38 (cdr pV36))) 
                 (let ((pV40 (cdr pV38))
                       (pV39 (car pV38))) 
                   (return 
                    (let ((old_ops (svref pV30 1))) 
                      (let ((old_qmap 
                             (let ((pV2 (STRINGMAP::|!find| old_ops pV39))) 
                               (block 
                                nil 
                                (if (eq (car pV2) :|None|) 
                                    (return STRINGMAP::empty) 
                                    (if (eq (car pV2) :|Some|) 
                                        (return (cdr pV2)))) 
                                (error "Nonexhaustive match failure in addPOp"))))) 
                        (let ((new_qmap 
                               (let ((pV23 (STRINGMAP::|!find| old_qmap pV40))) 
                                 (block 
                                  nil 
                                  (if (eq (car pV23) :|None|) 
                                      (return 
                                       (STRINGMAP::insert 
                                        old_qmap 
                                        pV40 
                                        (vector pV31 pV32 pV33 pV34))) 
                                      (if (eq (car pV23) :|Some|) 
                                          (let ((pV24 (cdr pV23))) 
                                            (let ((pV28 (svref pV24 3))
                                                  (pV25 (svref pV24 0))) 
                                              (return 
                                               (block 
                                                nil 
                                                (if (null pV34) 
                                                    (if (consp pV28) 
                                                        (return 
                                                         (STRINGMAP::insert 
                                                          old_qmap 
                                                          pV40 
                                                          (vector 
                                                           pV25 
                                                           pV32 
                                                           pV33 
                                                           pV28))) 
                                                        (if (null pV28) 
                                                            (return 
                                                             (SYSTEM-SPEC::fail 
                                                              (STRING-SPEC::^ 
                                                               (STRING-SPEC::^ 
                                                                "Operator " 
                                                                pV40) 
                                                               " has been redeclared"))))) 
                                                    (if (consp pV34) 
                                                        (if (null pV28) 
                                                            (return 
                                                             (STRINGMAP::insert 
                                                              old_qmap 
                                                              pV40 
                                                              (vector 
                                                               pV25 
                                                               (svref pV24 1) 
                                                               (svref pV24 2) 
                                                               pV34))) 
                                                            (if (consp pV28) 
                                                                (return 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Operator " 
                                                                    pV40) 
                                                                   " has been redefined"))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in addPOp"))))))) 
                                  (error "Nonexhaustive match failure in addPOp"))))) 
                          (let ((new_ops 
                                 (STRINGMAP::insert old_ops pV39 new_qmap))) 
                            (let ((sp (setOps pV30 new_ops))) 
                              (LIST-SPEC::foldl-1-1-1 
                               #'(lambda (x) (addLocalOpName (cdr x) (car x))) 
                               sp 
                               pV31))))))))))))) 
   (error "Nonexhaustive match failure in addPOp")))

(defun POSSPEC::addPOp-1 (x) (POSSPEC::addPOp (car x) (cdr x)))

(defun POSSPEC::addPSort (pV28 pV29) 
  (block 
   nil 
   (let ((pV32 (svref pV28 2))
         (pV31 (svref pV28 1))
         (pV30 (svref pV28 0))) 
     (if (consp pV30) 
         (let ((pV34 (car pV30))) 
           (if (eq (car pV34) :|Qualified|) 
               (let ((pV36 (cdr pV34))) 
                 (let ((pV38 (cdr pV36))
                       (pV37 (car pV36))) 
                   (return 
                    (let ((old_sorts (svref pV29 3))) 
                      (let ((old_qmap 
                             (let ((pV2 (STRINGMAP::|!find| old_sorts pV37))) 
                               (block 
                                nil 
                                (if (eq (car pV2) :|None|) 
                                    (return STRINGMAP::empty) 
                                    (if (eq (car pV2) :|Some|) 
                                        (return (cdr pV2)))) 
                                (error "Nonexhaustive match failure in addPSort"))))) 
                        (let ((new_qmap 
                               (let ((pV23 (STRINGMAP::|!find| old_qmap pV38))) 
                                 (block 
                                  nil 
                                  (if (eq (car pV23) :|None|) 
                                      (return 
                                       (STRINGMAP::insert 
                                        old_qmap 
                                        pV38 
                                        (vector pV30 pV31 pV32))) 
                                      (if (eq (car pV23) :|Some|) 
                                          (let ((pV24 (cdr pV23))) 
                                            (let ((pV27 (svref pV24 2))
                                                  (pV26 (svref pV24 1))) 
                                              (return 
                                               (block 
                                                nil 
                                                (if (null pV32) 
                                                    (if (null pV27) 
                                                        (return 
                                                         (SYSTEM-SPEC::fail 
                                                          (STRING-SPEC::^ 
                                                           (STRING-SPEC::^ 
                                                            "Sort " 
                                                            pV38) 
                                                           " has been redeclared"))) 
                                                        (if (consp pV27) 
                                                            (return 
                                                             (if (slang-built-in::slang-term-equals 
                                                                  pV31 
                                                                  pV26) 
                                                                 old_qmap 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Sort " 
                                                                    pV38) 
                                                                   " redefined using different type variable lists")))))) 
                                                    (if (consp pV32) 
                                                        (if (null pV27) 
                                                            (return 
                                                             (if (slang-built-in::slang-term-equals 
                                                                  pV31 
                                                                  pV26) 
                                                                 (STRINGMAP::insert 
                                                                  old_qmap 
                                                                  pV38 
                                                                  (vector 
                                                                   (svref pV24 0) 
                                                                   pV31 
                                                                   pV32)) 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Sort " 
                                                                    pV38) 
                                                                   " redefined using different type variable lists")))) 
                                                            (if (consp pV27) 
                                                                (return 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Sort " 
                                                                    pV38) 
                                                                   " has been redefined"))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in addPSort"))))))) 
                                  (error 
                                   "Nonexhaustive match failure in addPSort"))))) 
                          (let ((new_sorts 
                                 (STRINGMAP::insert old_sorts pV37 new_qmap))) 
                            (let ((sp (setSorts pV29 new_sorts))) 
                              (LIST-SPEC::foldl-1-1-1 
                               #'(lambda (x) (addLocalSortName (cdr x) (car x))) 
                               sp 
                               pV30))))))))))))) 
   (error "Nonexhaustive match failure in addPSort")))

(defun POSSPEC::addPSort-1 (x) (POSSPEC::addPSort (car x) (cdr x)))

(defparameter POSSPEC::boolPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Boolean" "Boolean")) nil))

(defparameter POSSPEC::charPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Char" "Char")) nil))

(defun POSSPEC::exportSpec-1 (spc) spc)

(defun POSSPEC::exportSpec (x0 x1 x2 x3) 
  (POSSPEC::exportSpec-1 (vector x0 x1 x2 x3)))

(defparameter POSITION-SPEC::internalPosition (cons :|Internal| "built-in"))

(defparameter POSSPEC::stringPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "String" "String")) nil))

(defun POSSPEC::mkFail (|!position| srt) 
  (let ((msg 
         (STRING-SPEC::^ 
          "Non-exhaustive match failure near " 
          (POSITION-SPEC::printAll |!position|)))) 
    (cons 
     :|ApplyN| 
     (cons 
      (cons 
       (STANDARDSPEC::mkOp 
        (cons :|Qualified| (cons "BuiltIn" "Fail")) 
        (cons 
         :|Arrow| 
         (vector POSSPEC::stringPSort srt POSITION-SPEC::internalPosition))) 
       (cons (STANDARDSPEC::mkString msg) nil)) 
      POSITION-SPEC::internalPosition))))

(defun POSSPEC::extendMatch (match pos) 
  (labels 
    ((|!loop| (rules) 
      (block 
       nil 
       (if (null rules) 
           (return nil) 
           (if (consp rules) 
               (let ((pV11 (cdr rules))
                     (pV10 (car rules))) 
                 (progn (let ((pV16 (svref pV10 1))
                              (pV15 (svref pV10 0))) 
                          (if (eq (car pV15) :|WildPat|) 
                              (if (eq (car pV16) :|Fun|) 
                                  (let ((pV26 (svref (cdr pV16) 0))) 
                                    (if (eq (car pV26) :|Bool|) 
                                        (if (eq t (cdr pV26)) 
                                            (if (null pV11) (return match)))))) 
                              (if (eq (car pV15) :|VarPat|) 
                                  (if (eq (car pV16) :|Fun|) 
                                      (let ((pV21 (svref (cdr pV16) 0))) 
                                        (if (eq (car pV21) :|Bool|) 
                                            (if (eq t (cdr pV21)) 
                                                (if (null pV11) (return match))))))))) 
                        (if (null pV11) 
                            (return 
                             (LIST-SPEC::|!++| 
                              match 
                              (cons 
                               (vector 
                                (cons 
                                 :|WildPat| 
                                 (cons 
                                  (METASLANG::patternSort (svref pV10 0)) 
                                  pos)) 
                                (STANDARDSPEC::mkTrue) 
                                (POSSPEC::mkFail 
                                 pos 
                                 (METASLANG::termSort (svref pV10 2)))) 
                               nil)))) 
                        (return (|!loop| pV11)))))) 
       (error "Nonexhaustive match failure in extendMatch")))) (|!loop| match)))

(defun POSSPEC::extendMatch-1 (x) (POSSPEC::extendMatch (car x) (cdr x)))

(defun POSSPEC::findTyVar (context uniqueId) 
  (let ((mp (STATE::|!!| (cdr context)))) 
    (let ((pV2 (NATMAP::|!find| mp uniqueId))) 
      (block 
       nil 
       (if (eq (car pV2) :|Some|) 
           (return (cdr pV2)) 
           (if (eq (car pV2) :|None|) 
               (return 
                (let ((|!number| (STATE::|!!| (car context)))) 
                  (let ((increment (NAT-SPEC::div |!number| 5))) 
                    (let ((parity (NAT-SPEC::|!rem| |!number| 5))) 
                      (let ((prefix 
                             (block 
                              nil 
                              (if ( =  0 parity) 
                                  (return "a") 
                                  (if ( =  1 parity) 
                                      (return "b") 
                                      (if ( =  2 parity) 
                                          (return "c") 
                                          (if ( =  3 parity) 
                                              (return "d") 
                                              (if ( =  4 parity) (return "e")))))) 
                              (error "Nonexhaustive match failure in findTyVar")))) 
                        (let ((suffix 
                               (if ( =  increment 0) 
                                   "" 
                                   (NAT-SPEC::toString increment)))) 
                          (let ((name (STRING-SPEC::^ prefix suffix))) name))))))))) 
       (error "Nonexhaustive match failure in findTyVar")))))

(defun POSSPEC::findTyVar-1 (x) (POSSPEC::findTyVar (car x) (cdr x)))

(defun POSSPEC::initializeMetaTyVars () 
  (cons (cons :|Ref| 0) (cons :|Ref| NATMAP::empty)))

(defun POSSPEC::initializeMetaTyVars-1 (ignore) 
  (declare (ignore ignore)) 
  (POSSPEC::initializeMetaTyVars))

(defun POSSPEC::insertDefaultMatches-1 (old_spec) 
  (labels 
    ((doTerm (term) 
      (block 
       nil 
       (if (eq (car term) :|Lambda|) 
           (let ((pV10 (cdr term))) 
             (let ((pV12 (cdr pV10))
                   (pV11 (car pV10))) 
               (return 
                (progn (METASLANG::termSort 
                        (let ((pV4 (LIST-SPEC::hd pV11))) 
                          (block 
                           nil 
                           (return (svref pV4 2)) 
                           (error 
                            "Nonexhaustive match failure in insertDefaultMatches")))) 
                       (let ((match (POSSPEC::extendMatch pV11 pV12))) 
                         (cons :|Lambda| (cons match pV12)))))))) 
       (return term)))) 
    (let ((mkT 
           (METASLANG::mapTerm #'doTerm #'(lambda (s) s) #'(lambda (p) p)))) 
      (setOps 
       old_spec 
       (STRINGMAP::|!map|-1-1 
        #'(lambda (qmap) 
           (STRINGMAP::|!map|-1-1 
            #'(lambda (x) 
               (vector 
                (svref x 0) 
                (svref x 1) 
                (svref x 2) 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x1) (cons (car x1) (funcall mkT (cdr x1)))) 
                 (svref x 3)))) 
            qmap)) 
        (svref old_spec 1))))))

(defun POSSPEC::insertDefaultMatches (x0 x1 x2 x3) 
  (POSSPEC::insertDefaultMatches-1 (vector x0 x1 x2 x3)))

(defun POSSPEC::makeTyVarMap-1 (x) (POSSPEC::makeTyVarMap (car x) (cdr x)))

(defun POSSPEC::mapImage-1 (x) (POSSPEC::mapImage (car x) (cdr x)))

(defun POSSPEC::mkApplyN (t1 t2) 
  (cons :|ApplyN| (cons (cons t1 (cons t2 nil)) POSITION-SPEC::internalPosition)))


(defun POSSPEC::mkApplyN-1 (x) (POSSPEC::mkApplyN (car x) (cdr x)))

(defun POSSPEC::mkConsPattern (p1 p2 pos element_type) 
  (cons 
   :|EmbedPat| 
   (vector 
    "Cons" 
    (cons 
     :|Some| 
     (cons :|RecordPat| (cons (cons (cons "1" p1) (cons (cons "2" p2) nil)) pos))) 
    (cons 
     :|Base| 
     (vector 
      (cons :|Qualified| (cons "List" "List")) 
      (cons element_type nil) 
      pos)) 
    pos)))

(defun POSSPEC::mkConsPattern-1 (x) 
  (POSSPEC::mkConsPattern (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun POSSPEC::mkFail-1 (x) (POSSPEC::mkFail (car x) (cdr x)))

(defun POSSPEC::mkList (terms pos element_type) 
  (let ((list_type 
         (cons 
          :|Base| 
          (vector 
           (cons :|Qualified| (cons "List" "List")) 
           (cons element_type nil) 
           pos)))) 
    (let ((consFun 
           (cons 
            :|Fun| 
            (vector 
             (cons :|Embed| (cons "Cons" t)) 
             (cons 
              :|Arrow| 
              (vector 
               (cons 
                :|Product| 
                (cons 
                 (cons (cons "1" element_type) (cons (cons "2" list_type) nil)) 
                 pos)) 
               list_type 
               pos)) 
             pos)))) 
      (let ((empty_list 
             (cons 
              :|Fun| 
              (vector (cons :|Embed| (cons "Nil" nil)) list_type pos)))) 
        (labels 
          ((mkCons (x xs) 
            (cons 
             :|ApplyN| 
             (cons 
              (cons 
               consFun 
               (cons 
                (cons 
                 :|Record| 
                 (cons (cons (cons "1" x) (cons (cons "2" xs) nil)) pos)) 
                nil)) 
              pos)))) 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) (mkCons (car x) (cdr x))) 
           empty_list 
           terms))))))

(defun POSSPEC::mkList-1 (x) 
  (POSSPEC::mkList (svref x 0) (svref x 1) (svref x 2)))

(defun POSSPEC::mkListPattern (patterns pos element_type) 
  (let ((list_type 
         (cons 
          :|Base| 
          (vector 
           (cons :|Qualified| (cons "List" "List")) 
           (cons element_type nil) 
           pos)))) 
    (let ((empty_list (cons :|EmbedPat| (vector "Nil" '(:|None|) list_type pos)))) 
      (labels 
        ((mkCons (x xs) 
          (cons 
           :|EmbedPat| 
           (vector 
            "Cons" 
            (cons 
             :|Some| 
             (cons 
              :|RecordPat| 
              (cons (cons (cons "1" x) (cons (cons "2" xs) nil)) pos))) 
            list_type 
            pos)))) 
        (LIST-SPEC::foldr-1-1-1 
         #'(lambda (x) (mkCons (car x) (cdr x))) 
         empty_list 
         patterns)))))

(defun POSSPEC::mkListPattern-1 (x) 
  (POSSPEC::mkListPattern (svref x 0) (svref x 1) (svref x 2)))

(defparameter POSSPEC::natPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Nat" "Nat")) nil))

(defun POSSPEC::removeDefinitions-1 (old_spec) 
  (let ((new_ops 
         (STRINGMAP::mapDouble-1-1 
          #'(lambda (x) 
             (let ((pV4 (svref x 2))) 
               (block 
                nil 
                (return 
                 (vector (svref x 0) (svref x 1) (cons (car pV4) (cdr pV4)) nil)) 
                (error "Nonexhaustive match failure in removeDefinitions")))) 
          (svref old_spec 1)))) 
    (vector (svref old_spec 0) new_ops emptyAProperties (svref old_spec 3))))

(defun POSSPEC::removeDefinitions (x0 x1 x2 x3) 
  (POSSPEC::removeDefinitions-1 (vector x0 x1 x2 x3)))

(defun POSSPECTOSPEC::convertPosSpecToSpec-1 (spc) 
  (let ((context (POSSPEC::initializeMetaTyVars))) 
    (labels 
      ((convertPFun (f) 
        (block 
         nil 
         (if (eq (car f) :|PQuotient|) 
             (return '(:|Quotient|)) 
             (if (eq (car f) :|PChoose|) 
                 (return '(:|Choose|)) 
                 (if (eq (car f) :|PRestrict|) 
                     (return '(:|Restrict|)) 
                     (if (eq (car f) :|PRelax|) 
                         (return '(:|Relax|)) 
                         (if (eq (car f) :|OneName|) 
                             (let ((pV30 (cdr f))) 
                               (return 
                                (cons 
                                 :|Op| 
                                 (cons 
                                  (cons 
                                   :|Qualified| 
                                   (cons METASLANG::UnQualified (car pV30))) 
                                  (cdr pV30))))) 
                             (if (eq (car f) :|TwoNames|) 
                                 (let ((pV29 (cdr f))) 
                                   (return 
                                    (cons 
                                     :|Op| 
                                     (cons 
                                      (cons 
                                       :|Qualified| 
                                       (cons (svref pV29 0) (svref pV29 1))) 
                                      (svref pV29 2))))))))))) 
         (return f)))
       (convertPSort (srt) 
        (block 
         nil 
         (if (eq (car srt) :|MetaTyVar|) 
             (let ((pV24 (cdr srt))) 
               (return 
                (let ((pV18 (STATE::|!!| (car pV24)))) 
                  (block 
                   nil 
                   (let ((pV19 (svref pV18 0))) 
                     (return 
                      (block 
                       nil 
                       (if (eq (car pV19) :|None|) 
                           (return 
                            (cons 
                             :|TyVar| 
                             (cons 
                              (POSSPEC::findTyVar context (svref pV18 2)) 
                              (cdr pV24)))) 
                           (if (eq (car pV19) :|Some|) 
                               (return (convertPSort (cdr pV19))))) 
                       (error 
                        "Nonexhaustive match failure in convertPosSpecToSpec")))) 
                   (error "Nonexhaustive match failure in convertPosSpecToSpec")))))) 
         (return srt)))
       (convertPTerm (term) 
        (block 
         nil 
         (if (eq (car term) :|ApplyN|) 
             (let ((pV4 (cdr term))) 
               (let ((pV9 (cdr pV4))
                     (pV8 (car pV4))) 
                 (if (consp pV8) 
                     (let ((pV12 (cdr pV8))
                           (pV11 (car pV8))) 
                       (if (consp pV12) 
                           (let ((pV15 (cdr pV12))
                                 (pV14 (car pV12))) 
                             (progn (if (null pV15) 
                                        (return 
                                         (cons :|Apply| (vector pV11 pV14 pV9)))) 
                                    (return 
                                     (convertPTerm 
                                      (cons 
                                       :|ApplyN| 
                                       (cons 
                                        (cons 
                                         pV11 
                                         (cons 
                                          (cons 
                                           :|ApplyN| 
                                           (cons 
                                            (LIST-SPEC::|!cons| pV14 pV15) 
                                            pV9)) 
                                          nil)) 
                                        pV9))))))))))) 
             (if (eq (car term) :|Fun|) 
                 (let ((pV3 (cdr term))) 
                   (return 
                    (cons 
                     :|Fun| 
                     (vector 
                      (convertPFun (svref pV3 0)) 
                      (svref pV3 1) 
                      (svref pV3 2))))))) 
         (return term)))) 
      (block 
       nil 
       (let ((pV54 (svref spc 0))) 
         (return 
          (block 
           nil 
           (let ((pV52 (svref pV54 3))
                 (pV51 (svref pV54 2))) 
             (return 
              (let ((tsp_maps 
                     (vector #'convertPTerm #'convertPSort #'(lambda (x) x)))) 
                (vector 
                 pV54 
                 (mapAQualifierMap-1-1 
                  #'(lambda (opinfo) 
                     (let ((pV44 (svref opinfo 2))
                           (pV42 (svref opinfo 0))) 
                       (block 
                        nil 
                        (return 
                         (let ((nm (LIST-SPEC::hd pV42))) 
                           (if (LIST-SPEC::|!member| nm pV51) 
                               (vector 
                                pV42 
                                (svref opinfo 1) 
                                (cons 
                                 (car pV44) 
                                 (METASLANG::mapSort-1-1 tsp_maps (cdr pV44))) 
                                (mapTermSchemes-1-1 tsp_maps (svref opinfo 3))) 
                               opinfo))) 
                        (error 
                         "Nonexhaustive match failure in convertPosSpecToSpec")))) 
                  (svref spc 1)) 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) 
                     (vector 
                      (svref x 0) 
                      (svref x 1) 
                      (svref x 2) 
                      (METASLANG::mapTerm-1-1 tsp_maps (svref x 3)))) 
                  (svref spc 2)) 
                 (mapAQualifierMap-1-1 
                  #'(lambda (|!sortinfo|) 
                     (let ((aliases (svref |!sortinfo| 0))) 
                       (let ((nm (LIST-SPEC::hd aliases))) 
                         (if (LIST-SPEC::|!member| nm pV52) 
                             (vector 
                              aliases 
                              (svref |!sortinfo| 1) 
                              (mapSortSchemes-1-1 tsp_maps (svref |!sortinfo| 2))) 
                             |!sortinfo|)))) 
                  (svref spc 3)))))) 
           (error "Nonexhaustive match failure in convertPosSpecToSpec")))) 
       (error "Nonexhaustive match failure in convertPosSpecToSpec")))))

(defun POSSPECTOSPEC::convertPosSpecToSpec (x0 x1 x2 x3) 
  (POSSPECTOSPEC::convertPosSpecToSpec-1 (vector x0 x1 x2 x3)))

(defun POSITION-SPEC::chooseNonZeroPos (p1 p2) 
  (block 
   nil 
   (if (eq (car p1) :|File|) (return p1)) 
   (if (eq (car p2) :|File|) (return p2)) 
   (if (eq (car p1) :|String|) (return p1)) 
   (if (eq (car p2) :|String|) (return p2)) 
   (return p1)))

(defun POSITION-SPEC::chooseNonZeroPos-1 (x) 
  (POSITION-SPEC::chooseNonZeroPos (car x) (cdr x)))

(defun POSITION-SPEC::compare (p1 p2) 
  (labels 
    ((compareLineColumnByte (pV5 pV6) 
      (block 
       nil 
       (let ((pV9 (svref pV5 2))) 
         (let ((pV12 (svref pV6 2))) 
           (return 
            (if (INTEGER-SPEC::|!<| pV9 pV12) 
                '(:|Less|) 
                (if (INTEGER-SPEC::|!>| pV9 pV12) '(:|Greater|) '(:|Equal|)))))) 
       (error "Nonexhaustive match failure in compare")))) 
    (block 
     nil 
     (if (eq (car p1) :|Internal|) 
         (return 
          (block 
           nil 
           (if (eq (car p2) :|Internal|) 
               (return (STRING-SPEC::compare (cdr p1) (cdr p2))) 
               (if (eq (car p2) :|String|) 
                   (return '(:|Less|)) 
                   (if (eq (car p2) :|File|) (return '(:|Less|))))) 
           (error "Nonexhaustive match failure in compare"))) 
         (if (eq (car p1) :|String|) 
             (let ((pV43 (cdr p1))) 
               (return 
                (block 
                 nil 
                 (if (eq (car p2) :|Internal|) 
                     (return '(:|Greater|)) 
                     (if (eq (car p2) :|String|) 
                         (let ((pV25 (cdr p2))) 
                           (return 
                            (let ((pV21 
                                   (STRING-SPEC::compare 
                                    (svref pV43 0) 
                                    (svref pV25 0)))) 
                              (block 
                               nil 
                               (if (eq (car pV21) :|Equal|) 
                                   (return 
                                    (let ((pV20 
                                           (compareLineColumnByte 
                                            (svref pV43 1) 
                                            (svref pV25 1)))) 
                                      (block 
                                       nil 
                                       (if (eq (car pV20) :|Equal|) 
                                           (return 
                                            (compareLineColumnByte 
                                             (svref pV43 2) 
                                             (svref pV25 2)))) 
                                       (return pV20))))) 
                               (return pV21))))) 
                         (if (eq (car p2) :|File|) (return '(:|Less|))))) 
                 (error "Nonexhaustive match failure in compare")))) 
             (if (eq (car p1) :|File|) 
                 (let ((pV42 (cdr p1))) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car p2) :|Internal|) 
                         (return '(:|Greater|)) 
                         (if (eq (car p2) :|String|) 
                             (return '(:|Greater|)) 
                             (if (eq (car p2) :|File|) 
                                 (let ((pV35 (cdr p2))) 
                                   (return 
                                    (let ((pV33 
                                           (STRING-SPEC::compare 
                                            (svref pV42 0) 
                                            (svref pV35 0)))) 
                                      (block 
                                       nil 
                                       (if (eq (car pV33) :|Equal|) 
                                           (return 
                                            (let ((pV32 
                                                   (compareLineColumnByte 
                                                    (svref pV42 1) 
                                                    (svref pV35 1)))) 
                                              (block 
                                               nil 
                                               (if (eq (car pV32) :|Equal|) 
                                                   (return 
                                                    (compareLineColumnByte 
                                                     (svref pV42 2) 
                                                     (svref pV35 2)))) 
                                               (return pV32))))) 
                                       (return pV33)))))))) 
                     (error "Nonexhaustive match failure in compare"))))))) 
     (error "Nonexhaustive match failure in compare"))))

(defun POSITION-SPEC::compare-1 (x) (POSITION-SPEC::compare (car x) (cdr x)))

(defun POSITION-SPEC::endLineColumnByte (|!string|) 
  (let ((|!last| (INTEGER-SPEC::|!-| (STRING-SPEC::|!length| |!string|) 1))) 
    (vector 1 |!last| |!last|)))

(defparameter POSITION-SPEC::startLineColumnByte (vector 1 0 0))

(defun PRETTYPRINT::addBreak-1 (x) 
  (PRETTYPRINT::addBreak (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::addSeparator-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::addSeparator-1-1 x1 x2)))

(defun PRETTYPRINT::addSeparator (x0 x1) 
  (PRETTYPRINT::addSeparator-1 (cons x0 x1)))

(defun PRETTYPRINT::appendFile-1 (x) (PRETTYPRINT::appendFile (car x) (cdr x)))

(defun PRETTYPRINT::appendFileWithNewline-1 (x) 
  (PRETTYPRINT::appendFileWithNewline (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::appendLatexFile-1 (x) 
  (PRETTYPRINT::appendLatexFile (car x) (cdr x)))

(defun PRETTYPRINT::blankLines-1 (x) (PRETTYPRINT::blankLines (car x) (cdr x)))

(defun PRETTYPRINT::|!block| (style |!newlines| lines) 
  (block 
   nil 
   (if (eq (car style) :|None|) 
       (return (PRETTYPRINT::blockNone |!newlines| lines)) 
       (if (eq (car style) :|All|) 
           (return (PRETTYPRINT::blockAll |!newlines| lines)) 
           (if (eq (car style) :|Fill|) 
               (return (PRETTYPRINT::blockFill |!newlines| lines)) 
               (if (eq (car style) :|Linear|) 
                   (return (PRETTYPRINT::blockLinear |!newlines| lines)))))) 
   (error "Nonexhaustive match failure in block")))

(defun PRETTYPRINT::|!block|-1 (x) 
  (PRETTYPRINT::|!block| (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::buttonPretty-1 (x) 
  (PRETTYPRINT::buttonPretty (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun PRETTYPRINT::emptyPretty-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::emptyPretty))

(defun PRETTYPRINT::emptyText-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::emptyText))

(defun PRETTYPRINT::extend-1 (x) 
  (PRETTYPRINT::extend (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::fits?-1 (x) 
  (PRETTYPRINT::fits? (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::|!format|-1 (x) (PRETTYPRINT::|!format| (car x) (cdr x)))

(defun PRETTYPRINT::formatLines-1 (x) 
  (PRETTYPRINT::formatLines (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun PRETTYPRINT::formatPretty-1 (x) 
  (PRETTYPRINT::formatPretty (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::insertElem-1 (x) (PRETTYPRINT::insertElem (car x) (cdr x)))

(defun PRETTYPRINT::lengthString-1 (x) 
  (PRETTYPRINT::lengthString (car x) (cdr x)))

(defun PRETTYPRINT::lines (ps) (PRETTYPRINT::prettysAll ps))

(defun PRETTYPRINT::markLines-1 (x) (PRETTYPRINT::markLines (car x) (cdr x)))

(defun PRETTYPRINT::markPretty-1 (x) (PRETTYPRINT::markPretty (car x) (cdr x)))

(defun PRETTYPRINT::newline-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::newline))

(defun PRETTYPRINT::newlineString-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::newlineString))

(defun PRETTYPRINT::ppList (x1) 
  #'(lambda (x2) #'(lambda (x3) (PRETTYPRINT::ppList-1-1-1 x1 x2 x3))))

(defun PRETTYPRINT::pretty-1 (x) (PRETTYPRINT::pretty (car x) (cdr x)))

(defun PRETTYPRINT::prettysAllDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysAllDelim-1-1 x1 x2)))

(defun PRETTYPRINT::prettysAllDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysAllDelim-1 (vector x0 x1 x2)))

(defun PRETTYPRINT::prettysBlock (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysBlock-1-1 x1 x2)))

(defun PRETTYPRINT::prettysBlockDelim (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (PRETTYPRINT::prettysBlockDelim-1-1-1 x1 x2 x3))))

(defun PRETTYPRINT::prettysFillDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysFillDelim-1-1 x1 x2)))

(defun PRETTYPRINT::prettysFillDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysFillDelim-1 (vector x0 x1 x2)))

(defun PRETTYPRINT::prettysLinearDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysLinearDelim-1-1 x1 x2)))

(defun PRETTYPRINT::prettysLinearDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysLinearDelim-1 (vector x0 x1 x2)))

(defun PRETTYPRINT::prettysNoneDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysNoneDelim-1-1 x1 x2)))

(defun PRETTYPRINT::prettysNoneDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysNoneDelim-1 (vector x0 x1 x2)))

(defun PRETTYPRINT::|!reduce|-1 (x) (PRETTYPRINT::|!reduce| (car x) (cdr x)))

(defun PRETTYPRINT::shift-1 (x) 
  (PRETTYPRINT::shift (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::streamWriter-1 (x) 
  (PRETTYPRINT::streamWriter (car x) (cdr x)))

(defun PRETTYPRINT::toFile-1 (x) (PRETTYPRINT::toFile (car x) (cdr x)))

(defun PRETTYPRINT::toFileWithNewline-1 (x) 
  (PRETTYPRINT::toFileWithNewline (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::toFileWithPathIndexing-1 (x) 
  (PRETTYPRINT::toFileWithPathIndexing (car x) (cdr x)))

(defun PRETTYPRINT::toLatexFile-1 (x) 
  (PRETTYPRINT::toLatexFile (car x) (cdr x)))

(defun PRETTYPRINT::toPathFiles-1 (x) 
  (PRETTYPRINT::toPathFiles (svref x 0) (svref x 1) (svref x 2)))

(defun PRETTYPRINT::toStream-1 (x) 
  (PRETTYPRINT::toStream (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun PRETTYPRINT::toStreamT-1 (x) 
  (PRETTYPRINT::toStreamT (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun PRETTYPRINT::widthPretty (x0 x1) 
  (PRETTYPRINT::widthPretty-1 (cons x0 x1)))

(defun SKETCH::edges (x0 x1 x2 x3) (SKETCH::edges-1 (vector x0 x1 x2 x3)))

(defun SKETCH::|!eval| (x) (POLYMAP::|!eval| x))

(defun SKETCH::|!eval|-1-1 (x0 x1) (POLYMAP::|!eval|-1-1 x0 x1))

(defun SKETCH::foldMap (x) (POLYMAP::foldMap x))

(defun SKETCH::foldMap-1-1-1 (x0 x1 x2) (POLYMAP::foldMap-1-1-1 x0 x1 x2))

(defun SKETCH::insertEdge-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) #'(lambda (x4) (SKETCH::insertEdge-1-1-1-1 x1 x2 x3 x4)))))

(defun SKETCH::insertEdge (x0 x1 x2 x3) 
  (SKETCH::insertEdge-1 (vector x0 x1 x2 x3)))

(defun SKETCH::insertVertex-1 (x1) 
  #'(lambda (x2) (SKETCH::insertVertex-1-1 x1 x2)))

(defun SKETCH::insertVertex (x0 x1 x2 x3) 
  (SKETCH::insertVertex-1 (vector x0 x1 x2 x3)))

(defun SKETCH::ppCod (x) (VERTEX::ppElem x))

(defun SKETCH::ppDom (x) (EDGE::ppElem x))

(defun SKETCH::ppMap (|!map|) 
  (WADLERLINDIG::ppSep-1-1 
   WADLERLINDIG::ppNewline 
   (SKETCH::foldMap-1-1-1 
    #'(lambda (l) 
       #'(lambda (dom) 
          #'(lambda (cod) 
             (cons 
              (WADLERLINDIG::ppConcat 
               (cons 
                (SKETCH::ppDom dom) 
                (cons 
                 (WADLERLINDIG::ppString "+->") 
                 (cons (SKETCH::ppCod cod) nil)))) 
              l)))) 
    nil 
    |!map|)))

(defun SKETCH::ppSketch (x0 x1 x2 x3) (SKETCH::ppSketch-1 (vector x0 x1 x2 x3)))

(defun SKETCH::src (x0 x1 x2 x3) (SKETCH::src-1 (vector x0 x1 x2 x3)))

(defun SKETCH::target (x0 x1 x2 x3) (SKETCH::target-1 (vector x0 x1 x2 x3)))

(defun SKETCH::update (x) (POLYMAP::update x))

(defun SKETCH::vertices (x0 x1 x2 x3) (SKETCH::vertices-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::SpecTermToSpecName-1 (scterm) 
  (let ((term (car scterm))) 
    (block 
     nil 
     (if (eq (car term) :|URI|) 
         (return (cons :|Some| (SPECCALC::showRelativeURI (cdr term)))) 
         (if (eq (car term) :|Spec|) (return '(:|None|)))) 
     (return '(:|None|)))))

(defun SPECCALC::SpecTermToSpecName (x0 x1) 
  (SPECCALC::SpecTermToSpecName-1 (cons x0 x1)))

(defun SPECCALC::|!error| (str) (SPECCALC::raise (cons :|Fail| str)))

(defun SPECCALC::lastElem (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "lastElem: encountered empty string list")) 
       (if (consp elems) 
           (let ((pV5 (cdr elems))) 
             (progn (if (null pV5) (return (SPECCALC::|!return| (car elems)))) 
                    (return (SPECCALC::lastElem pV5)))))) 
   (error "Nonexhaustive match failure in lastElem")))

(defun SPECCALC::removeLastElem (elems) 
  (block 
   nil 
   (if (null elems) 
       (return 
        (SPECCALC::|!error| "removeLastElem: encountered empty string list")) 
       (if (consp elems) 
           (let ((pV4 (cdr elems))
                 (pV3 (car elems))) 
             (progn (if (null pV4) (return (SPECCALC::|!return| nil))) 
                    (return 
                     (SPECCALC::monadBind 
                      (SPECCALC::removeLastElem pV4) 
                      #'(lambda (suffix) 
                         (SPECCALC::|!return| (cons pV3 suffix))))))))) 
   (error "Nonexhaustive match failure in removeLastElem")))

(defun SPECCALC::deviceString? (s) 
  (eq (STRING-SPEC::sub s (INTEGER-SPEC::|!-| (STRING-SPEC::|!length| s) 1)) #\:))


(defun SPECCALC::uriToFullPath (pV1 path) 
  (declare (ignore pV1)) 
  (let ((device? (SPECCALC::deviceString? (LIST-SPEC::hd path)))) 
    (let ((mainPath 
           (STRING-SPEC::concatList 
            (LIST-SPEC::foldr-1-1-1 
             #'(lambda (x) 
                (LIST-SPEC::|!cons| "/" (LIST-SPEC::|!cons| (car x) (cdr x)))) 
             nil 
             (if device? (LIST-SPEC::tl path) path))))) 
      (if device? (STRING-SPEC::^ (LIST-SPEC::hd path) mainPath) mainPath))))

(defun SPECCALC::URItoJavaFile (pV4 pV5) 
  (block 
   nil 
   (let ((pV7 (cdr pV4))) 
     (return 
      (block 
       nil 
       (if (eq (car pV5) :|Some|) (return (SPECCALC::|!return| (cdr pV5)))) 
       (return 
        (SPECCALC::monadBind 
         (SPECCALC::removeLastElem pV7) 
         #'(lambda (prefix) 
            (SPECCALC::monadBind 
             (SPECCALC::lastElem pV7) 
             #'(lambda (mainName) 
                (let ((filNm 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          (SPECCALC::uriToFullPath '(:|None|) prefix) 
                          "/java/") 
                         mainName) 
                        ".java"))) 
                  (SPECCALC::monadSeq 
                   (SPECCALC::|!print| 
                    (STRING-SPEC::^ (STRING-SPEC::^ "Java file name " filNm) "
")) 
                   (SPECCALC::|!return| filNm))))))))))) 
   (error "Nonexhaustive match failure in URItoJavaFile")))

(defun SPECCALC::URItoJavaFile-1 (x) (SPECCALC::URItoJavaFile (car x) (cdr x)))

(defun SPECCALC::URItoJavaFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoJavaFile-1 x1) x2))

(defun SPECCALC::URItoLispFile (pV4 pV5) 
  (block 
   nil 
   (let ((pV7 (cdr pV4))) 
     (return 
      (block 
       nil 
       (if (eq (car pV5) :|Some|) (return (SPECCALC::|!return| (cdr pV5)))) 
       (return 
        (SPECCALC::monadBind 
         (SPECCALC::removeLastElem pV7) 
         #'(lambda (prefix) 
            (SPECCALC::monadBind 
             (SPECCALC::lastElem pV7) 
             #'(lambda (mainName) 
                (SPECCALC::monadBind 
                 (SPECCALC::|!return| 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (SPECCALC::uriToFullPath '(:|None|) prefix) 
                     "/lisp/") 
                    mainName) 
                   ".lisp")) 
                 #'(lambda (|!fileName|) (SPECCALC::|!return| |!fileName|))))))))))) 
   (error "Nonexhaustive match failure in URItoLispFile")))

(defun SPECCALC::URItoLispFile-1 (x) (SPECCALC::URItoLispFile (car x) (cdr x)))

(defun SPECCALC::URItoLispFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoLispFile-1 x1) x2))

(defun SPECCALC::URItoMultipleSnarkLogFile-1 (uri) 
  (let ((path (cdr uri))
        (hashSuffix (car uri))) 
    (block 
     nil 
     (if (eq (car hashSuffix) :|Some|) 
         (let ((pV2 (cdr hashSuffix))) 
           (return 
            (SPECCALC::monadBind 
             (SPECCALC::removeLastElem path) 
             #'(lambda (prefix) 
                (SPECCALC::monadBind 
                 (SPECCALC::lastElem path) 
                 #'(lambda (newSubDir) 
                    (SPECCALC::monadBind 
                     (SPECCALC::|!return| pV2) 
                     #'(lambda (mainName) 
                        (let ((filNm 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (SPECCALC::uriToFullPath '(:|None|) prefix) 
                                    "/snark/") 
                                   newSubDir) 
                                  "/") 
                                 mainName) 
                                ".log"))) (SPECCALC::|!return| filNm))))))))))) 
     (error "Nonexhaustive match failure in URItoMultipleSnarkLogFile"))))

(defun SPECCALC::URItoMultipleSnarkLogFile (x0 x1) 
  (SPECCALC::URItoMultipleSnarkLogFile-1 (cons x0 x1)))

(defun SPECCALC::URItoMultipleSnarkLogFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoMultipleSnarkLogFile-1 x1) x2))

(defun SPECCALC::URItoProofName-1 (uri) (car uri))

(defun SPECCALC::URItoProofName (x0 x1) 
  (SPECCALC::URItoProofName-1 (cons x0 x1)))

(defun SPECCALC::URItoSingleSnarkLogFile-1 (uri) 
  (let ((path (cdr uri))) 
    (SPECCALC::monadBind 
     (SPECCALC::removeLastElem path) 
     #'(lambda (prefix) 
        (SPECCALC::monadBind 
         (SPECCALC::lastElem path) 
         #'(lambda (mainName) 
            (let ((filNm 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (SPECCALC::uriToFullPath '(:|None|) prefix) 
                      "/snark/") 
                     mainName) 
                    ".log"))) (SPECCALC::|!return| filNm))))))))

(defun SPECCALC::URItoSingleSnarkLogFile (x0 x1) 
  (SPECCALC::URItoSingleSnarkLogFile-1 (cons x0 x1)))

(defun SPECCALC::URItoSingleSnarkLogFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoSingleSnarkLogFile-1 x1) x2))

(defun SPECCALC::URItoSnarkFile (pV4 pV5) 
  (block 
   nil 
   (let ((pV7 (cdr pV4))) 
     (return 
      (block 
       nil 
       (if (eq (car pV5) :|Some|) (return (SPECCALC::|!return| (cdr pV5)))) 
       (return 
        (SPECCALC::monadBind 
         (SPECCALC::removeLastElem pV7) 
         #'(lambda (prefix) 
            (SPECCALC::monadBind 
             (SPECCALC::lastElem pV7) 
             #'(lambda (mainName) 
                (let ((filNm 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          (SPECCALC::uriToFullPath '(:|None|) prefix) 
                          "/snark/") 
                         mainName) 
                        ".lisp"))) 
                  (SPECCALC::monadSeq 
                   (SPECCALC::|!print| 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ "Snark file name " filNm) 
                     "
")) 
                   (SPECCALC::|!return| filNm))))))))))) 
   (error "Nonexhaustive match failure in URItoSnarkFile")))

(defun SPECCALC::URItoSnarkFile-1 (x) 
  (SPECCALC::URItoSnarkFile (car x) (cdr x)))

(defun SPECCALC::URItoSnarkFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoSnarkFile-1 x1) x2))

(defun SPECCALC::URItoSnarkLogFile-1 (uri) 
  (let ((hashSuffix (car uri))) 
    (SPECCALC::monadBind 
     (block 
      nil 
      (if (eq (car hashSuffix) :|None|) 
          (return (SPECCALC::URItoSingleSnarkLogFile-1 uri)) 
          (if (eq (car hashSuffix) :|Some|) 
              (return (SPECCALC::URItoMultipleSnarkLogFile-1 uri)))) 
      (error "Nonexhaustive match failure in URItoSnarkLogFile")) 
     #'(lambda (result) (SPECCALC::|!return| result)))))

(defun SPECCALC::URItoSnarkLogFile (x0 x1) 
  (SPECCALC::URItoSnarkLogFile-1 (cons x0 x1)))

(defun SPECCALC::URItoSnarkLogFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoSnarkLogFile-1 x1) x2))

(defun SPECCALC::takeWhile-1-1 (pred l) 
  (block 
   nil 
   (if (null l) 
       (return (cons nil nil)) 
       (if (consp l) 
           (let ((pV6 (car l))) 
             (return 
              (if (funcall pred pV6) 
                  (let ((pV1 (SPECCALC::takeWhile-1-1 pred (cdr l)))) 
                    (block 
                     nil 
                     (return (cons (cons pV6 (car pV1)) (cdr pV1))) 
                     (error "Nonexhaustive match failure in takeWhile"))) 
                  (cons nil l)))))) 
   (error "Nonexhaustive match failure in takeWhile")))

(defun SPECCALC::splitStringAtChar-1-1 (|!char| str) 
  (labels 
    ((parseCharList (chars) 
      (block 
       nil 
       (if (null chars) 
           (return nil) 
           (if (consp chars) 
               (return 
                (if (eq (car chars) |!char|) 
                    (parseCharList (cdr chars)) 
                    (let ((pV1 
                           (SPECCALC::takeWhile-1-1 
                            #'(lambda (c) (BOOLEAN-SPEC::~ (eq c |!char|))) 
                            chars))) 
                      (block 
                       nil 
                       (return 
                        (cons 
                         (STRING-SPEC::implode (car pV1)) 
                         (parseCharList (cdr pV1)))) 
                       (error "Nonexhaustive match failure in splitStringAtChar"))))))) 
       (error "Nonexhaustive match failure in splitStringAtChar")))) 
    (parseCharList (STRING-SPEC::explode str))))

(defun SPECCALC::abbreviatedPath (path) 
  (let ((home 
         (let ((pV3 (SYSTEM-SPEC::getEnv "HOME"))) 
           (block 
            nil 
            (if (eq (car pV3) :|Some|) 
                (return (SPECCALC::splitStringAtChar-1-1 #\/ (cdr pV3))) 
                (if (eq (car pV3) :|None|) 
                    (return 
                     (let ((pV1 (SYSTEM-SPEC::getEnv "HOMEPATH"))) 
                       (block 
                        nil 
                        (if (eq (car pV1) :|Some|) 
                            (return 
                             (SPECCALC::splitStringAtChar-1-1 #\/ (cdr pV1))) 
                            (if (eq (car pV1) :|None|) (return nil))) 
                        (error "Nonexhaustive match failure in abbreviatedPath")))))) 
            (error "Nonexhaustive match failure in abbreviatedPath"))))) 
    (if (slang-built-in::slang-term-equals home nil) 
        path 
        (labels 
          ((removeCommonPrefix (p home) 
            (block 
             nil 
             (if (null home) (return (LIST-SPEC::|!++| (cons "~" nil) p))) 
             (if (null p) 
                 (return path) 
                 (if (consp p) 
                     (if (consp home) 
                         (return 
                          (if (string=  (car p) (car home)) 
                              (removeCommonPrefix (cdr p) (cdr home)) 
                              path))))) 
             (return path)))) (removeCommonPrefix path home)))))

(defun SPECCALC::actualHypothesis (validHypothesis assertions pos) 
  (block 
   nil 
   (if (eq (car assertions) :|All|) 
       (return validHypothesis) 
       (if (eq (car assertions) :|Explicit|) 
           (let ((pV5 (cdr assertions))) 
             (return 
              (let ((hypothesis 
                     (LIST-SPEC::filter-1-1 
                      #'(lambda (x) (LIST-SPEC::|!member| (svref x 1) pV5)) 
                      validHypothesis))) hypothesis))))) 
   (error "Nonexhaustive match failure in actualHypothesis")))

(defun SPECCALC::actualHypothesis-1 (x) 
  (SPECCALC::actualHypothesis (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::addDevice? (path) 
  (if SYSTEM-SPEC::msWindowsSystem? 
      (if (SPECCALC::deviceString? (LIST-SPEC::hd path)) path (cons "C:" path)) 
      path))

(defun SPECCALC::addLabelledVertex-1 (dgm) 
  #'(lambda (nodeId) 
     #'(lambda (spc) 
        #'(lambda (|!position|) 
           (if (CAT::vertexInDiagram?-1-1 dgm nodeId) 
               (if (slang-built-in::slang-term-equals 
                    spc 
                    (CAT::vertexLabel-1-1 dgm nodeId)) 
                   (SPECCALC::|!return| dgm) 
                   (SPECCALC::raise 
                    (cons 
                     :|DiagError| 
                     (cons 
                      |!position| 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ "node " nodeId) 
                       " inconsistently labeled in diagram"))))) 
               (SPECCALC::|!return| 
                (CAT::labelVertex-1-1-1 
                 (CAT::addVertex-1-1 dgm nodeId) 
                 nodeId 
                 spc)))))))

(defun SPECCALC::addLabelledVertex (x0 x1) 
  (SPECCALC::addLabelledVertex-1 (cons x0 x1)))

(defun SPECCALC::addLabelledVertex-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 x1) x2) x3) 
                    x4) 
           x5))

(defun SPECCALC::addOp-1-1-1-1-1-1-1 (x1 x2 x3 x4 x5 x6 x7) 
  (funcall (funcall (funcall (funcall (funcall (funcall (SPECCALC::addOp x1) x2) 
                                               x3) 
                                      x4) 
                             x5) 
                    x6) 
           x7))

(defun SPECCALC::addSort (new_sort_names) 
  #'(lambda (new_type_vars) 
     #'(lambda (new_defs) 
        #'(lambda (old_spec) 
           #'(lambda (|!position|) 
              (let ((old_infos 
                     (LIST-SPEC::foldl-1-1-1 
                      #'(lambda (x) 
                         (let ((old_infos (cdr x))) 
                           (let ((pV2 
                                  (STANDARDSPEC::findTheSort old_spec (car x)))) 
                             (block 
                              nil 
                              (if (eq (car pV2) :|Some|) 
                                  (let ((pV3 (cdr pV2))) 
                                    (return 
                                     (if (LIST-SPEC::|!exists|-1-1 
                                          #'(lambda (old_info) 
                                             (slang-built-in::slang-term-equals 
                                              pV3 
                                              old_info)) 
                                          old_infos) 
                                         old_infos 
                                         (LIST-SPEC::|!cons| pV3 old_infos))))) 
                              (return old_infos))))) 
                      nil 
                      new_sort_names))) 
                (SPECCALC::monadBind 
                 (block 
                  nil 
                  (if (null old_infos) 
                      (return 
                       (let ((new_info 
                              (vector new_sort_names new_type_vars new_defs))) 
                         (SPECCALC::|!return| 
                          (LIST-SPEC::foldl-1-1-1 
                           #'(lambda (x) 
                              (let ((pV4 (car x))) 
                                (block 
                                 nil 
                                 (if (eq (car pV4) :|Qualified|) 
                                     (let ((pV6 (cdr pV4))) 
                                       (return 
                                        (insertAQualifierMap 
                                         (cdr x) 
                                         (car pV6) 
                                         (cdr pV6) 
                                         new_info)))) 
                                 (error "Nonexhaustive match failure in addSort")))) 
                           (svref old_spec 3) 
                           new_sort_names)))) 
                      (if (consp old_infos) 
                          (let ((pV39 (car old_infos))) 
                            (let ((pV43 (svref pV39 2))
                                  (pV42 (svref pV39 1))) 
                              (if (null (cdr old_infos)) 
                                  (return 
                                   (let ((combined_sort_names 
                                          (LISTUTILITIES::listUnion 
                                           (svref pV39 0) 
                                           new_sort_names))) 
                                     (if (slang-built-in::slang-term-equals 
                                          new_type_vars 
                                          pV42) 
                                         (block 
                                          nil 
                                          (if (null pV43) 
                                              (if (null new_defs) 
                                                  (return 
                                                   (SPECCALC::raise 
                                                    (cons 
                                                     :|SpecError| 
                                                     (cons 
                                                      |!position| 
                                                      (STRING-SPEC::^ 
                                                       (STRING-SPEC::^ 
                                                        "Sort " 
                                                        (SPECCALC::printAliases 
                                                         new_sort_names)) 
                                                       " has been redeclared."))))) 
                                                  (if (consp new_defs) 
                                                      (return 
                                                       (let ((new_info 
                                                              (vector 
                                                               combined_sort_names 
                                                               new_type_vars 
                                                               new_defs))) 
                                                         (SPECCALC::|!return| 
                                                          (LIST-SPEC::foldl-1-1-1 
                                                           #'(lambda (x) 
                                                              (let ((pV11 
                                                                     (car x))) 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car pV11) 
                                                                      :|Qualified|) 
                                                                     (let ((pV13 
                                                                            (cdr 
                                                                             pV11))) 
                                                                       (return 
                                                                        (insertAQualifierMap 
                                                                         (cdr x) 
                                                                         (car 
                                                                          pV13) 
                                                                         (cdr 
                                                                          pV13) 
                                                                         new_info)))) 
                                                                 (error 
                                                                  "Nonexhaustive match failure in addSort")))) 
                                                           (svref old_spec 3) 
                                                           combined_sort_names)))))) 
                                              (if (consp pV43) 
                                                  (if (null new_defs) 
                                                      (return 
                                                       (let ((new_info 
                                                              (vector 
                                                               combined_sort_names 
                                                               pV42 
                                                               pV43))) 
                                                         (SPECCALC::|!return| 
                                                          (LIST-SPEC::foldl-1-1-1 
                                                           #'(lambda (x) 
                                                              (let ((pV18 
                                                                     (car x))) 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car pV18) 
                                                                      :|Qualified|) 
                                                                     (let ((pV20 
                                                                            (cdr 
                                                                             pV18))) 
                                                                       (return 
                                                                        (insertAQualifierMap 
                                                                         (cdr x) 
                                                                         (car 
                                                                          pV20) 
                                                                         (cdr 
                                                                          pV20) 
                                                                         new_info)))) 
                                                                 (error 
                                                                  "Nonexhaustive match failure in addSort")))) 
                                                           (svref old_spec 3) 
                                                           combined_sort_names)))) 
                                                      (if (consp new_defs) 
                                                          (return 
                                                           (SPECCALC::raise 
                                                            (cons 
                                                             :|SpecError| 
                                                             (cons 
                                                              |!position| 
                                                              (STRING-SPEC::^ 
                                                               (STRING-SPEC::^ 
                                                                (STRING-SPEC::^ 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Sort " 
                                                                    (SPECCALC::printAliases 
                                                                     new_sort_names)) 
                                                                   " has been redefined") 
                                                                  "
 from ") 
                                                                 (ANNSPECPRINTER::printSortScheme-1 
                                                                  (car pV43))) 
                                                                "
   to ") 
                                                               (ANNSPECPRINTER::printSortScheme-1 
                                                                (car new_defs))))))))))) 
                                          (error 
                                           "Nonexhaustive match failure in addSort")) 
                                         (SPECCALC::raise 
                                          (cons 
                                           :|SpecError| 
                                           (cons 
                                            |!position| 
                                            (STRING-SPEC::^ 
                                             (STRING-SPEC::^ 
                                              (STRING-SPEC::^ 
                                               (STRING-SPEC::^ 
                                                (STRING-SPEC::^ 
                                                 (STRING-SPEC::^ 
                                                  "Sort " 
                                                  (SPECCALC::printAliases 
                                                   new_sort_names)) 
                                                 " has been redeclared or redefined") 
                                                "
 with new type variables ") 
                                               (SPECCALC::printTypeVars 
                                                new_type_vars)) 
                                              "
    differing from prior ") 
                                             (SPECCALC::printTypeVars pV42))))))))))))) 
                  (return 
                   (SPECCALC::raise 
                    (cons 
                     :|SpecError| 
                     (cons 
                      |!position| 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        "Sort " 
                        (SPECCALC::printAliases new_sort_names)) 
                       " refers to multiple prior sorts")))))) 
                 #'(lambda (new_sorts) 
                    (SPECCALC::monadBind 
                     (SPECCALC::|!return| (setSorts old_spec new_sorts)) 
                     #'(lambda (sp) 
                        (funcall (funcall (SPECCALC::foldM 
                                           #'(lambda (sp) 
                                              #'(lambda (name) 
                                                 (SPECCALC::|!return| 
                                                  (addLocalSortName sp name))))) 
                                          sp) 
                                 new_sort_names)))))))))))

(defun SPECCALC::addSort-1-1-1-1-1-1 (x1 x2 x3 x4 x5 x6) 
  (funcall (funcall (funcall (funcall (funcall (SPECCALC::addSort x1) x2) x3) x4) 
                    x5) 
           x6))

(defun SPECCALC::answerVarsFromSnark () 
  (let ((snarkAnswer (SNARK::ANSWER t))) 
    (let ((lispAnswerVars (LISP-SPEC::|!cdr| snarkAnswer))) 
      (let ((answerVars (LISP-SPEC::uncell lispAnswerVars))) 
        (let ((answerStrings 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (lv) (LISP-SPEC::LispString lv)) 
                answerVars))) answerStrings)))))

(defun SPECCALC::answerVarsFromSnark-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECCALC::answerVarsFromSnark))

(defun SPECCALC::foldMapAp (abf) 
  #'(lambda (x) 
     (let ((b (cdr x))
           (sp (car x))) 
       (block 
        nil 
        (if (eq (car sp) :|SplayNil|) 
            (return (SPECCALC::|!return| b)) 
            (if (eq (car sp) :|SplayObj|) 
                (let ((pV2 (cdr sp))) 
                  (let ((pV5 (svref pV2 2))
                        (pV3 (svref pV2 0))) 
                    (let ((pV7 (cdr pV5))
                          (pV6 (car pV5))) 
                      (return 
                       (SPECCALC::monadBind 
                        (funcall (SPECCALC::foldMapAp abf) 
                                 (cons (svref pV2 1) b)) 
                        #'(lambda (rightResult) 
                           (SPECCALC::monadBind 
                            (funcall abf (vector pV6 pV7 rightResult)) 
                            #'(lambda (rootResult) 
                               (funcall (SPECCALC::foldMapAp abf) 
                                        (cons pV3 rootResult)))))))))))) 
        (error "Nonexhaustive match failure in foldMapAp")))))

(defun SPECCALC::foldMap (abf) 
  #'(lambda (b) 
     #'(lambda (|!map|) 
        (block 
         nil 
         (if (eq (car |!map|) :|EMPTY|) 
             (return (SPECCALC::|!return| b)) 
             (if (eq (car |!map|) :|MAP|) 
                 (return 
                  (funcall (SPECCALC::foldMapAp abf) 
                           (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
         (error "Nonexhaustive match failure in foldMap")))))

(defun SPECCALC::foldDoubleMap (f) 
  #'(lambda (ob) 
     #'(lambda (omap) 
        (funcall (funcall (SPECCALC::foldMap 
                           #'(lambda (x) 
                              (let ((key1 (svref x 0))) 
                                (funcall (funcall (SPECCALC::foldMap 
                                                   #'(lambda (x1) 
                                                      (funcall f 
                                                               (vector 
                                                                key1 
                                                                (svref x1 0) 
                                                                (svref x1 1) 
                                                                (svref x1 2))))) 
                                                  (svref x 2)) 
                                         (svref x 1))))) 
                          ob) 
                 omap))))

(defun SPECCALC::foldOverQualifierMap (x) (SPECCALC::foldDoubleMap x))

(defun SPECCALC::mergeOpInfo-1 (newPOpInfo) 
  #'(lambda (optOldPOpInfo) 
     #'(lambda (|!position|) 
        (block 
         nil 
         (if (eq (car optOldPOpInfo) :|None|) 
             (return (SPECCALC::|!return| newPOpInfo))) 
         (let ((pV39 (svref newPOpInfo 3))
               (pV38 (svref newPOpInfo 2))
               (pV37 (svref newPOpInfo 1))) 
           (if (eq (car optOldPOpInfo) :|Some|) 
               (let ((pV40 (cdr optOldPOpInfo))) 
                 (let ((pV44 (svref pV40 3))
                       (pV43 (svref pV40 2))) 
                   (return 
                    (let ((op_names 
                           (LISTUTILITIES::listUnion 
                            (svref pV40 0) 
                            (svref newPOpInfo 0)))) 
                      (if (BOOLEAN-SPEC::~ 
                           (slang-built-in::slang-term-equals 
                            pV37 
                            (svref pV40 1))) 
                          (SPECCALC::raise 
                           (cons 
                            :|SpecError| 
                            (cons 
                             |!position| 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ 
                               "Merged versions of Op " 
                               (SPECCALC::printAliases op_names)) 
                              " have different fixity")))) 
                          (let ((happy? 
                                 (block 
                                  nil 
                                  (if (null (car pV43)) 
                                      (if (eq (car (cdr pV43)) :|MetaTyVar|) 
                                          (return t))) 
                                  (if (null (car pV38)) 
                                      (if (eq (car (cdr pV38)) :|MetaTyVar|) 
                                          (return t))) 
                                  (return 
                                   (slang-built-in::slang-term-equals 
                                    (car pV38) 
                                    (car pV43))) 
                                  (return t)))) 
                            (if (BOOLEAN-SPEC::~ happy?) 
                                (SPECCALC::raise 
                                 (cons 
                                  :|SpecError| 
                                  (cons 
                                   |!position| 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     (STRING-SPEC::^ 
                                      (STRING-SPEC::^ 
                                       (STRING-SPEC::^ 
                                        (STRING-SPEC::^ 
                                         "Merged versions of Op " 
                                         (SPECCALC::printAliases op_names)) 
                                        " have incompatible sorts:") 
                                       "
 ") 
                                      (ANNSPECPRINTER::printSortScheme-1 pV38)) 
                                     "
 ") 
                                    (ANNSPECPRINTER::printSortScheme-1 pV43))))) 
                                (block 
                                 nil 
                                 (if (null pV44) 
                                     (if (null pV39) 
                                         (return 
                                          (SPECCALC::|!return| 
                                           (vector op_names pV37 pV38 nil))) 
                                         (if (consp pV39) 
                                             (return 
                                              (SPECCALC::|!return| 
                                               (vector op_names pV37 pV38 pV39))))) 
                                     (if (consp pV44) 
                                         (if (null pV39) 
                                             (return 
                                              (SPECCALC::|!return| 
                                               (vector op_names pV37 pV38 pV44)))))) 
                                 (return 
                                  (let ((combined_defs 
                                         (LIST-SPEC::foldl-1-1-1 
                                          #'(lambda (x) 
                                             (let ((result_defs (cdr x))
                                                   (new_def (car x))) 
                                               (if (LIST-SPEC::|!exists|-1-1 
                                                    #'(lambda (old_def) 
                                                       (METASLANG::equalTerm? 
                                                        (cdr new_def) 
                                                        (cdr old_def))) 
                                                    result_defs) 
                                                   result_defs 
                                                   (LIST-SPEC::|!cons| 
                                                    new_def 
                                                    result_defs)))) 
                                          pV44 
                                          pV39))) 
                                    (SPECCALC::|!return| 
                                     (vector op_names pV37 pV38 combined_defs)))))))))))))) 
         (error "Nonexhaustive match failure in mergeOpInfo")))))

(defun SPECCALC::mergeSortInfo-1 (newPSortInfo) 
  #'(lambda (optOldPSortInfo) 
     #'(lambda (|!position|) 
        (block 
         nil 
         (if (eq (car optOldPSortInfo) :|None|) 
             (return (SPECCALC::|!return| newPSortInfo))) 
         (let ((pV19 (svref newPSortInfo 2))
               (pV18 (svref newPSortInfo 1))) 
           (if (eq (car optOldPSortInfo) :|Some|) 
               (let ((pV20 (cdr optOldPSortInfo))) 
                 (let ((pV23 (svref pV20 2))
                       (pV22 (svref pV20 1))) 
                   (return 
                    (let ((sort_names 
                           (LISTUTILITIES::listUnion 
                            (svref pV20 0) 
                            (svref newPSortInfo 0)))) 
                      (if (BOOLEAN-SPEC::~ 
                           (slang-built-in::slang-term-equals pV18 pV22)) 
                          (SPECCALC::raise 
                           (cons 
                            :|SpecError| 
                            (cons 
                             |!position| 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   "Merged versions of Sort " 
                                   (SPECCALC::printAliases sort_names)) 
                                  " have differing type variables:") 
                                 "
 ") 
                                (SPECCALC::printTypeVars pV22)) 
                               "
 ") 
                              (SPECCALC::printTypeVars pV18))))) 
                          (block 
                           nil 
                           (if (null pV23) 
                               (if (null pV19) 
                                   (return 
                                    (SPECCALC::|!return| 
                                     (vector sort_names pV18 nil))) 
                                   (if (consp pV19) 
                                       (return 
                                        (SPECCALC::|!return| 
                                         (vector sort_names pV18 pV19))))) 
                               (if (consp pV23) 
                                   (if (null pV19) 
                                       (return 
                                        (SPECCALC::|!return| 
                                         (vector sort_names pV22 pV23)))))) 
                           (return 
                            (let ((combined_defs 
                                   (LIST-SPEC::foldl-1-1-1 
                                    #'(lambda (x) 
                                       (let ((combined_defs (cdr x))
                                             (new_def (car x))) 
                                         (if (LIST-SPEC::|!exists|-1-1 
                                              #'(lambda (old_def) 
                                                 (equalSortScheme? 
                                                  new_def 
                                                  old_def)) 
                                              combined_defs) 
                                             combined_defs 
                                             (LIST-SPEC::|!cons| 
                                              new_def 
                                              combined_defs)))) 
                                    pV23 
                                    pV19))) 
                              (SPECCALC::|!return| 
                               (vector sort_names pV22 combined_defs)))))))))))) 
         (error "Nonexhaustive match failure in mergeSortInfo")))))

(defun SPECCALC::auxTranslateSpec-1 (spc) 
  #'(lambda (x) 
     (let ((sort_id_map (cdr x))
           (op_id_map (car x))) 
       #'(lambda (|!position|) 
          (labels 
            ((translateSortMap (old_sorts) 
              (labels 
                ((translateStep (pV84 pV85 pV86 pV87) 
                  (block 
                   nil 
                   (let ((pV88 (svref pV86 0))) 
                     (if (consp pV88) 
                         (let ((pV92 (car pV88))) 
                           (if (eq (car pV92) :|Qualified|) 
                               (let ((pV94 (cdr pV92))) 
                                 (return 
                                  (if (BOOLEAN-SPEC::~ 
                                       (cl:and 
                                        (string=  pV84 (car pV94)) 
                                        (string=  pV85 (cdr pV94)))) 
                                      (SPECCALC::|!return| pV87) 
                                      (let ((new_aliases 
                                             (LIST-SPEC::rev 
                                              (LIST-SPEC::foldl-1-1-1 
                                               #'(lambda (x1) 
                                                  (let ((new_aliases (cdr x1))) 
                                                    (LIST-SPEC::foldl-1-1-1 
                                                     #'(lambda (x11) 
                                                        (let ((new_aliases 
                                                               (cdr x11))
                                                              (new_alias 
                                                               (car x11))) 
                                                          (if (LIST-SPEC::|!member| 
                                                               new_alias 
                                                               new_aliases) 
                                                              new_aliases 
                                                              (cons 
                                                               new_alias 
                                                               new_aliases)))) 
                                                     new_aliases 
                                                     (translateSortQualifiedIdToAliases 
                                                      (car x1))))) 
                                               nil 
                                               pV88)))) 
                                        (SPECCALC::monadBind 
                                         (SPECCALC::|!return| 
                                          (vector 
                                           new_aliases 
                                           (svref pV86 1) 
                                           (svref pV86 2))) 
                                         #'(lambda (first_sortinfo) 
                                            (SPECCALC::monadBind 
                                             (funcall (funcall (SPECCALC::foldM 
                                                                #'(lambda (merged_sortinfo) 
                                                                   #'(lambda (new_alias) 
                                                                      (block 
                                                                       nil 
                                                                       (if (eq 
                                                                            (car 
                                                                             new_alias) 
                                                                            :|Qualified|) 
                                                                           (let ((pV77 
                                                                                  (cdr 
                                                                                   new_alias))) 
                                                                             (return 
                                                                              (funcall (funcall (SPECCALC::mergeSortInfo-1 
                                                                                                 merged_sortinfo) 
                                                                                                (findAQualifierMap 
                                                                                                 pV87 
                                                                                                 (car 
                                                                                                  pV77) 
                                                                                                 (cdr 
                                                                                                  pV77))) 
                                                                                       |!position|)))) 
                                                                       (error 
                                                                        "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                               first_sortinfo) 
                                                      new_aliases) 
                                             #'(lambda (merged_sortinfo) 
                                                (funcall (funcall (SPECCALC::foldM 
                                                                   #'(lambda (new_sort_map) 
                                                                      #'(lambda (pV80) 
                                                                         (block 
                                                                          nil 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV80) 
                                                                               :|Qualified|) 
                                                                              (let ((pV81 
                                                                                     (cdr 
                                                                                      pV80))) 
                                                                                (return 
                                                                                 (SPECCALC::|!return| 
                                                                                  (insertAQualifierMap 
                                                                                   new_sort_map 
                                                                                   (car 
                                                                                    pV81) 
                                                                                   (cdr 
                                                                                    pV81) 
                                                                                   merged_sortinfo))))) 
                                                                          (error 
                                                                           "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                                  pV87) 
                                                         new_aliases))))))))))))) 
                   (error "Nonexhaustive match failure in auxTranslateSpec")))) 
                (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                   #'(lambda (x1) 
                                      (translateStep 
                                       (svref x1 0) 
                                       (svref x1 1) 
                                       (svref x1 2) 
                                       (svref x1 3)))) 
                                  emptyAQualifierMap) 
                         old_sorts)))
             (translateOpMap (old_ops) 
              (labels 
                ((translateStep (pV61 pV62 pV63 pV64) 
                  (block 
                   nil 
                   (let ((pV65 (svref pV63 0))) 
                     (if (consp pV65) 
                         (let ((pV70 (car pV65))) 
                           (if (eq (car pV70) :|Qualified|) 
                               (let ((pV72 (cdr pV70))) 
                                 (return 
                                  (if (BOOLEAN-SPEC::~ 
                                       (cl:and 
                                        (string=  pV61 (car pV72)) 
                                        (string=  pV62 (cdr pV72)))) 
                                      (SPECCALC::|!return| pV64) 
                                      (let ((new_aliases 
                                             (LIST-SPEC::rev 
                                              (LIST-SPEC::foldl-1-1-1 
                                               #'(lambda (x1) 
                                                  (let ((new_aliases (cdr x1))) 
                                                    (LIST-SPEC::foldl-1-1-1 
                                                     #'(lambda (x11) 
                                                        (let ((new_aliases 
                                                               (cdr x11))
                                                              (new_alias 
                                                               (car x11))) 
                                                          (if (LIST-SPEC::|!member| 
                                                               new_alias 
                                                               new_aliases) 
                                                              new_aliases 
                                                              (cons 
                                                               new_alias 
                                                               new_aliases)))) 
                                                     new_aliases 
                                                     (translateOpQualifiedIdToAliases 
                                                      (car x1))))) 
                                               nil 
                                               pV65)))) 
                                        (SPECCALC::monadBind 
                                         (SPECCALC::|!return| 
                                          (vector 
                                           new_aliases 
                                           (svref pV63 1) 
                                           (svref pV63 2) 
                                           (svref pV63 3))) 
                                         #'(lambda (first_opinfo) 
                                            (SPECCALC::monadBind 
                                             (funcall (funcall (SPECCALC::foldM 
                                                                #'(lambda (merged_opinfo) 
                                                                   #'(lambda (new_alias) 
                                                                      (block 
                                                                       nil 
                                                                       (if (eq 
                                                                            (car 
                                                                             new_alias) 
                                                                            :|Qualified|) 
                                                                           (let ((pV54 
                                                                                  (cdr 
                                                                                   new_alias))) 
                                                                             (return 
                                                                              (funcall (funcall (SPECCALC::mergeOpInfo-1 
                                                                                                 merged_opinfo) 
                                                                                                (findAQualifierMap 
                                                                                                 pV64 
                                                                                                 (car 
                                                                                                  pV54) 
                                                                                                 (cdr 
                                                                                                  pV54))) 
                                                                                       |!position|)))) 
                                                                       (error 
                                                                        "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                               first_opinfo) 
                                                      new_aliases) 
                                             #'(lambda (merged_opinfo) 
                                                (funcall (funcall (SPECCALC::foldM 
                                                                   #'(lambda (new_op_map) 
                                                                      #'(lambda (pV57) 
                                                                         (block 
                                                                          nil 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV57) 
                                                                               :|Qualified|) 
                                                                              (let ((pV58 
                                                                                     (cdr 
                                                                                      pV57))) 
                                                                                (return 
                                                                                 (SPECCALC::|!return| 
                                                                                  (insertAQualifierMap 
                                                                                   new_op_map 
                                                                                   (car 
                                                                                    pV58) 
                                                                                   (cdr 
                                                                                    pV58) 
                                                                                   merged_opinfo))))) 
                                                                          (error 
                                                                           "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                                  pV64) 
                                                         new_aliases))))))))))))) 
                   (error "Nonexhaustive match failure in auxTranslateSpec")))) 
                (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                   #'(lambda (x1) 
                                      (translateStep 
                                       (svref x1 0) 
                                       (svref x1 1) 
                                       (svref x1 2) 
                                       (svref x1 3)))) 
                                  emptyAQualifierMap) 
                         old_ops)))
             (translatePattern (pat) pat)
             (translateSort (sort_term) 
              (block 
               nil 
               (if (eq (car sort_term) :|Base|) 
                   (let ((pV48 (cdr sort_term))) 
                     (let ((pV49 (svref pV48 0))) 
                       (return 
                        (let ((new_qid (translateSortQualifiedId pV49))) 
                          (if (slang-built-in::slang-term-equals new_qid pV49) 
                              sort_term 
                              (cons 
                               :|Base| 
                               (vector new_qid (svref pV48 1) (svref pV48 2))))))))) 
               (return sort_term)))
             (translateOp (op_term) 
              (block 
               nil 
               (if (eq (car op_term) :|Fun|) 
                   (let ((pV39 (cdr op_term))) 
                     (let ((pV40 (svref pV39 0))) 
                       (if (eq (car pV40) :|Op|) 
                           (let ((pV43 (cdr pV40))) 
                             (let ((pV44 (car pV43))) 
                               (return 
                                (let ((new_qid (translateOpQualifiedId pV44))) 
                                  (if (slang-built-in::slang-term-equals 
                                       new_qid 
                                       pV44) 
                                      op_term 
                                      (cons 
                                       :|Fun| 
                                       (vector 
                                        (cons :|Op| (cons new_qid (cdr pV43))) 
                                        (svref pV39 1) 
                                        (svref pV39 2)))))))))))) 
               (return op_term)))
             (translateSortQualifiedIdToAliases (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV34 (cdr qid))) 
                     (return 
                      (let ((pV29 
                             (findAQualifierMap 
                              sort_id_map 
                              (car pV34) 
                              (cdr pV34)))) 
                        (block 
                         nil 
                         (if (eq (car pV29) :|Some|) 
                             (return (cdr (cdr pV29))) 
                             (if (eq (car pV29) :|None|) (return (cons qid nil)))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))
             (translateOpQualifiedIdToAliases (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV25 (cdr qid))) 
                     (return 
                      (let ((pV20 
                             (findAQualifierMap op_id_map (car pV25) (cdr pV25)))) 
                        (block 
                         nil 
                         (if (eq (car pV20) :|Some|) 
                             (return (cdr (cdr pV20))) 
                             (if (eq (car pV20) :|None|) (return (cons qid nil)))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))
             (translateSortQualifiedId (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV16 (cdr qid))) 
                     (return 
                      (let ((pV11 
                             (findAQualifierMap 
                              sort_id_map 
                              (car pV16) 
                              (cdr pV16)))) 
                        (block 
                         nil 
                         (if (eq (car pV11) :|Some|) 
                             (return (car (cdr pV11))) 
                             (if (eq (car pV11) :|None|) (return qid))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))
             (translateOpQualifiedId (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV7 (cdr qid))) 
                     (return 
                      (let ((pV2 
                             (findAQualifierMap op_id_map (car pV7) (cdr pV7)))) 
                        (block 
                         nil 
                         (if (eq (car pV2) :|Some|) 
                             (return (car (cdr pV2))) 
                             (if (eq (car pV2) :|None|) (return qid))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))) 
            (let ((pV97 
                   (mapSpec-1-1 
                    (vector #'translateOp #'translateSort #'translatePattern) 
                    spc))) 
              (block 
               nil 
               (let ((pV100 (svref pV97 2))
                     (pV99 (svref pV97 1))
                     (pV98 (svref pV97 0))) 
                 (let ((pV105 (svref pV98 3))
                       (pV104 (svref pV98 2))) 
                   (return 
                    (SPECCALC::monadBind 
                     (translateSortMap (svref pV97 3)) 
                     #'(lambda (newSorts) 
                        (SPECCALC::monadBind 
                         (translateOpMap pV99) 
                         #'(lambda (newOps) 
                            (SPECCALC::|!return| 
                             (vector 
                              (vector 
                               '(:|None|) 
                               nil 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateOpQualifiedId 
                                pV104) 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateSortQualifiedId 
                                pV105)) 
                              newOps 
                              pV100 
                              newSorts))))))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec"))))))))

(defun SPECCALC::opMap-1 (morph) (svref morph 2))

(defun SPECCALC::sortMap-1 (morph) (svref morph 3))

(defun SPECCALC::applyMorphism-1 (sm) 
  #'(lambda (spc) 
     #'(lambda (|!position|) 
        (let ((op_id_map 
               (POLYMAP::foldMap-1-1-1 
                #'(lambda (op_id_map) 
                   #'(lambda (pV1) 
                      (block 
                       nil 
                       (if (eq (car pV1) :|Qualified|) 
                           (let ((pV2 (cdr pV1))) 
                             (let ((pV4 (cdr pV2))
                                   (pV3 (car pV2))) 
                               (return 
                                #'(lambda (cod_qid) 
                                   (insertAQualifierMap 
                                    op_id_map 
                                    pV3 
                                    pV4 
                                    (cons cod_qid (cons cod_qid nil)))))))) 
                       (error "Nonexhaustive match failure in applyMorphism")))) 
                emptyAQualifierMap 
                (SPECCALC::opMap-1 sm)))) 
          (let ((sort_id_map 
                 (POLYMAP::foldMap-1-1-1 
                  #'(lambda (sort_id_map) 
                     #'(lambda (pV5) 
                        (block 
                         nil 
                         (if (eq (car pV5) :|Qualified|) 
                             (let ((pV6 (cdr pV5))) 
                               (let ((pV8 (cdr pV6))
                                     (pV7 (car pV6))) 
                                 (return 
                                  #'(lambda (cod_qid) 
                                     (insertAQualifierMap 
                                      sort_id_map 
                                      pV7 
                                      pV8 
                                      (cons cod_qid (cons cod_qid nil)))))))) 
                         (error "Nonexhaustive match failure in applyMorphism")))) 
                  emptyAQualifierMap 
                  (SPECCALC::sortMap-1 sm)))) 
            (funcall (funcall (SPECCALC::auxTranslateSpec-1 spc) 
                              (cons op_id_map sort_id_map)) 
                     |!position|))))))

(defun SPECCALC::applyMorphism (x0 x1 x2 x3) 
  (SPECCALC::applyMorphism-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::applyMorphism-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::applyMorphism-1 x1) x2) x3) x4))

(defun SPECCALC::cod-1 (morph) (svref morph 0))

(defun SPECCALC::dom-1 (morph) (svref morph 1))

(defun SPECCALC::ppDecls (decls) 
  (labels 
    ((ppDecl (name term) 
      (WADLERLINDIG::ppConcat 
       (cons 
        (WADLERLINDIG::ppString name) 
        (cons 
         (WADLERLINDIG::ppString " = ") 
         (cons (SPECCALC::ppTerm-1 term) nil)))))) 
    (WADLERLINDIG::ppSep-1-1 
     WADLERLINDIG::ppNewline 
     (LIST-SPEC::|!map|-1-1 #'(lambda (x) (ppDecl (car x) (cdr x))) decls))))

(defun SPECCALC::ppDiagElem (elem pV1) 
  (declare (ignore pV1)) 
  (block 
   nil 
   (if (eq (car elem) :|Node|) 
       (let ((pV4 (cdr elem))) 
         (return 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString (car pV4)) 
            (cons 
             (WADLERLINDIG::ppString " |-> ") 
             (cons (SPECCALC::ppTerm-1 (cdr pV4)) nil)))))) 
       (if (eq (car elem) :|Edge|) 
           (let ((pV3 (cdr elem))) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons 
                (WADLERLINDIG::ppString (svref pV3 0)) 
                (cons 
                 (WADLERLINDIG::ppString " : ") 
                 (cons 
                  (WADLERLINDIG::ppString (svref pV3 1)) 
                  (cons 
                   (WADLERLINDIG::ppString " -> ") 
                   (cons 
                    (WADLERLINDIG::ppString (svref pV3 2)) 
                    (cons 
                     (WADLERLINDIG::ppString " |-> ") 
                     (cons (SPECCALC::ppTerm-1 (svref pV3 3)) nil)))))))))))) 
   (error "Nonexhaustive match failure in ppDiagElem")))

(defun SPECCALC::ppDiagElem-1 (x) (SPECCALC::ppDiagElem (car x) (cdr x)))

(defun SPECCALC::ppOtherTerm (term) (WADLERLINDIG::ppString "<some OtherTerm>"))

(defun SPECCALC::ppQualifier (pV1) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV2 (cdr pV1))) 
         (let ((pV4 (cdr pV2))
               (pV3 (car pV2))) 
           (return 
            (if (string=  pV3 METASLANG::UnQualified) 
                (WADLERLINDIG::ppString pV4) 
                (WADLERLINDIG::ppString 
                 (STRING-SPEC::^ (STRING-SPEC::^ pV3 ".") pV4))))))) 
   (error "Nonexhaustive match failure in ppQualifier")))

(defun SPECCALC::isSimpleSort? (srt) 
  (block nil (if (eq (car srt) :|Base|) (return t)) (return nil)))

(defun SPECCALC::isFiniteList (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV46 (svref (cdr term) 0))) 
         (if (eq (car pV46) :|Embed|) 
             (let ((pV49 (cdr pV46))) 
               (if (string=  "Nil" (car pV49)) 
                   (if (eq nil (cdr pV49)) (return (cons :|Some| nil))))))) 
       (if (eq (car term) :|Apply|) 
           (let ((pV21 (cdr term))) 
             (let ((pV24 (svref pV21 1))
                   (pV23 (svref pV21 0))) 
               (if (eq (car pV23) :|Fun|) 
                   (let ((pV27 (svref (cdr pV23) 0))) 
                     (if (eq (car pV27) :|Embed|) 
                         (let ((pV30 (cdr pV27))) 
                           (if (string=  "Cons" (car pV30)) 
                               (if (eq t (cdr pV30)) 
                                   (if (eq (car pV24) :|Record|) 
                                       (let ((pV34 (car (cdr pV24)))) 
                                         (if (consp pV34) 
                                             (let ((pV38 (cdr pV34))) 
                                               (let ((pV40 (cdr (car pV34)))) 
                                                 (if (consp pV38) 
                                                     (let ((pV45 
                                                            (cdr (car pV38)))) 
                                                       (if (null (cdr pV38)) 
                                                           (progn (return 
                                                                   (let ((pV9 
                                                                          (SPECCALC::isFiniteList 
                                                                           pV45))) 
                                                                     (block 
                                                                      nil 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV9) 
                                                                           :|Some|) 
                                                                          (return 
                                                                           (cons 
                                                                            :|Some| 
                                                                            (cons 
                                                                             pV40 
                                                                             (cdr 
                                                                              pV9)))) 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV9) 
                                                                               :|None|) 
                                                                              (return 
                                                                               '(:|None|)))) 
                                                                      (error 
                                                                       "Nonexhaustive match failure in isFiniteList")))) 
                                                                  (return 
                                                                   (let ((pV17 
                                                                          (SPECCALC::isFiniteList 
                                                                           pV45))) 
                                                                     (block 
                                                                      nil 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV17) 
                                                                           :|Some|) 
                                                                          (return 
                                                                           (cons 
                                                                            :|Some| 
                                                                            (cons 
                                                                             pV40 
                                                                             (cdr 
                                                                              pV17)))) 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV17) 
                                                                               :|None|) 
                                                                              (return 
                                                                               '(:|None|)))) 
                                                                      (error 
                                                                       "Nonexhaustive match failure in isFiniteList"))))))))))))))))))))))) 
   (return '(:|None|))))

(defun SPECCALC::isSimpleTerm? (trm) 
  (block 
   nil 
   (if (eq (car trm) :|Var|) (return t) (if (eq (car trm) :|Fun|) (return t))) 
   (return nil)))

(defun SPECCALC::ppBoolean (b) 
  (block 
   nil 
   (if (eq t b) 
       (return (WADLERLINDIG::ppString "true")) 
       (if (eq nil b) (return (WADLERLINDIG::ppString "false")))) 
   (error "Nonexhaustive match failure in ppBoolean")))

(defun SPECCALC::ppFixity (fix) 
  (block 
   nil 
   (if (consp fix) 
       (let ((pV4 (cdr fix))
             (pV3 (car fix))) 
         (if (eq (car pV3) :|Left|) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons 
                (WADLERLINDIG::ppString "infixl ") 
                (cons (WADLERLINDIG::ppString (NAT-SPEC::toString pV4)) nil)))) 
             (if (eq (car pV3) :|Right|) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString "infixr ") 
                    (cons (WADLERLINDIG::ppString (NAT-SPEC::toString pV4)) nil))))))) 
       (if (null fix) (return WADLERLINDIG::ppNil))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "No match in ppFixity with: '" (SYSTEM-SPEC::toString fix)) 
      "'")))))

(defun WADLERLINDIG::ppGroup (d) (cons :|DocGroup| d))

(defun SPECCALC::ppGrConcat (x) 
  (WADLERLINDIG::ppGroup (WADLERLINDIG::ppConcat x)))

(defparameter SPECCALC::omittedQualifiers 
  (cons 
   "Boolean" 
   (cons 
    "Integer" 
    (cons "Nat" (cons "Double" (cons "List" (cons "String" (cons "Char" nil))))))))


(defun SPECCALC::ppQualifiedId (pV1) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV2 (cdr pV1))) 
         (let ((pV4 (cdr pV2))
               (pV3 (car pV2))) 
           (return 
            (if (cl:or 
                 (string=  pV3 METASLANG::UnQualified) 
                 (LIST-SPEC::|!member| pV3 SPECCALC::omittedQualifiers)) 
                (WADLERLINDIG::ppString pV4) 
                (WADLERLINDIG::ppString 
                 (STRING-SPEC::^ (STRING-SPEC::^ pV3 ".") pV4))))))) 
   (error "Nonexhaustive match failure in ppQualifiedId")))

(defun SPECCALC::ppAFun (fun) 
  (block 
   nil 
   (if (eq (car fun) :|Equals|) 
       (return (WADLERLINDIG::ppString "=")) 
       (if (eq (car fun) :|Quotient|) 
           (return (WADLERLINDIG::ppString "quotient")) 
           (if (eq (car fun) :|Choose|) 
               (return (WADLERLINDIG::ppString "choose")) 
               (if (eq (car fun) :|Restrict|) 
                   (return (WADLERLINDIG::ppString "restrict")) 
                   (if (eq (car fun) :|Relax|) 
                       (return (WADLERLINDIG::ppString "relax")) 
                       (if (eq (car fun) :|Op|) 
                           (let ((pV12 (cdr fun))) 
                             (let ((pV21 (cdr pV12))
                                   (pV20 (car pV12))) 
                               (progn (if (null pV21) 
                                          (return (SPECCALC::ppQualifiedId pV20))) 
                                      (return 
                                       (SPECCALC::ppGrConcat 
                                        (cons 
                                         (WADLERLINDIG::ppString "(") 
                                         (cons 
                                          (SPECCALC::ppQualifiedId pV20) 
                                          (cons 
                                           (WADLERLINDIG::ppString ",") 
                                           (cons 
                                            (SPECCALC::ppFixity pV21) 
                                            (cons 
                                             (WADLERLINDIG::ppString ")") 
                                             nil)))))))))) 
                           (if (eq (car fun) :|Project|) 
                               (return 
                                (WADLERLINDIG::ppConcat 
                                 (cons 
                                  (WADLERLINDIG::ppString "project ") 
                                  (cons (WADLERLINDIG::ppString (cdr fun)) nil)))) 
                               (if (eq (car fun) :|Embed|) 
                                   (return 
                                    (WADLERLINDIG::ppString (car (cdr fun)))) 
                                   (if (eq (car fun) :|Embedded|) 
                                       (return 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (WADLERLINDIG::ppString "embedded ") 
                                          (cons 
                                           (WADLERLINDIG::ppString (cdr fun)) 
                                           nil)))) 
                                       (if (eq (car fun) :|Select|) 
                                           (return 
                                            (WADLERLINDIG::ppConcat 
                                             (cons 
                                              (WADLERLINDIG::ppString "select ") 
                                              (cons 
                                               (WADLERLINDIG::ppString (cdr fun)) 
                                               nil)))) 
                                           (if (eq (car fun) :|Nat|) 
                                               (return 
                                                (WADLERLINDIG::ppString 
                                                 (NAT-SPEC::toString (cdr fun)))) 
                                               (if (eq (car fun) :|Char|) 
                                                   (return 
                                                    (WADLERLINDIG::ppString 
                                                     (CHAR-SPEC::toString 
                                                      (cdr fun)))) 
                                                   (if (eq (car fun) :|String|) 
                                                       (return 
                                                        (WADLERLINDIG::ppString 
                                                         (cdr fun))) 
                                                       (if (eq (car fun) :|Bool|) 
                                                           (return 
                                                            (SPECCALC::ppBoolean 
                                                             (cdr fun))) 
                                                           (if (eq 
                                                                (car fun) 
                                                                :|OneName|) 
                                                               (return 
                                                                (WADLERLINDIG::ppString 
                                                                 (car (cdr fun)))) 
                                                               (if (eq 
                                                                    (car fun) 
                                                                    :|TwoNames|) 
                                                                   (let ((pV2 
                                                                          (cdr 
                                                                           fun))) 
                                                                     (return 
                                                                      (SPECCALC::ppQualifiedId 
                                                                       (cons 
                                                                        :|Qualified| 
                                                                        (cons 
                                                                         (svref 
                                                                          pV2 
                                                                          0) 
                                                                         (svref 
                                                                          pV2 
                                                                          1)))))))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "No match in ppAFun with: '" (SYSTEM-SPEC::toString fun)) 
      "'")))))

(defun SPECCALC::ppAVarWithoutSort (id pV1) 
  (declare (ignore pV1)) 
  (WADLERLINDIG::ppString id))

(defun SPECCALC::ppAVarWithoutSort-1 (x) 
  (SPECCALC::ppAVarWithoutSort (car x) (cdr x)))

(defun SPECCALC::ppAPattern (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|AliasPat|) 
       (let ((pV35 (cdr pattern))) 
         (return 
          (SPECCALC::ppGrConcat 
           (cons 
            (SPECCALC::ppAPattern (svref pV35 0)) 
            (cons 
             (WADLERLINDIG::ppString " as ") 
             (cons (SPECCALC::ppAPattern (svref pV35 1)) nil)))))) 
       (if (eq (car pattern) :|VarPat|) 
           (return (SPECCALC::ppAVarWithoutSort-1 (car (cdr pattern)))) 
           (if (eq (car pattern) :|EmbedPat|) 
               (let ((pV33 (cdr pattern))) 
                 (let ((pV55 (svref pV33 1))) 
                   (return 
                    (SPECCALC::ppGrConcat 
                     (cons 
                      (WADLERLINDIG::ppString (svref pV33 0)) 
                      (cons 
                       (block 
                        nil 
                        (if (eq (car pV55) :|None|) 
                            (return WADLERLINDIG::ppNil) 
                            (if (eq (car pV55) :|Some|) 
                                (return 
                                 (WADLERLINDIG::ppAppend-1-1 
                                  (WADLERLINDIG::ppString " ") 
                                  (SPECCALC::ppAPattern (cdr pV55)))))) 
                        (error "Nonexhaustive match failure in ppAPattern")) 
                       nil)))))) 
               (if (eq (car pattern) :|RecordPat|) 
                   (let ((pV52 (car (cdr pattern)))) 
                     (return 
                      (block 
                       nil 
                       (if (null pV52) 
                           (return (WADLERLINDIG::ppString "()")) 
                           (if (consp pV52) 
                               (if (string=  "1" (car (car pV52))) 
                                   (return 
                                    (labels 
                                      ((ppField (pV9 pat) 
                                        (declare (ignore pV9)) 
                                        (SPECCALC::ppAPattern pat))) 
                                      (WADLERLINDIG::ppConcat 
                                       (cons 
                                        (WADLERLINDIG::ppString "(") 
                                        (cons 
                                         (WADLERLINDIG::ppSep-1-1 
                                          (WADLERLINDIG::ppString ",") 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x) 
                                              (ppField (car x) (cdr x))) 
                                           pV52)) 
                                         (cons (WADLERLINDIG::ppString ")") nil))))))))) 
                       (return 
                        (labels 
                          ((ppField (x pat) 
                            (WADLERLINDIG::ppConcat 
                             (cons 
                              (WADLERLINDIG::ppString x) 
                              (cons 
                               (WADLERLINDIG::ppString "=") 
                               (cons (SPECCALC::ppAPattern pat) nil)))))) 
                          (WADLERLINDIG::ppConcat 
                           (cons 
                            (WADLERLINDIG::ppString "{") 
                            (cons 
                             (WADLERLINDIG::ppSep-1-1 
                              (WADLERLINDIG::ppString ",") 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x) (ppField (car x) (cdr x))) 
                               pV52)) 
                             (cons (WADLERLINDIG::ppString "}") nil))))))))) 
                   (if (eq (car pattern) :|WildPat|) 
                       (return (WADLERLINDIG::ppString "_")) 
                       (if (eq (car pattern) :|StringPat|) 
                           (return (WADLERLINDIG::ppString (car (cdr pattern)))) 
                           (if (eq (car pattern) :|BoolPat|) 
                               (return (SPECCALC::ppBoolean (car (cdr pattern)))) 
                               (if (eq (car pattern) :|CharPat|) 
                                   (return 
                                    (WADLERLINDIG::ppString 
                                     (CHAR-SPEC::toString (car (cdr pattern))))) 
                                   (if (eq (car pattern) :|NatPat|) 
                                       (return 
                                        (WADLERLINDIG::ppString 
                                         (NAT-SPEC::toString (car (cdr pattern))))) 
                                       (if (eq (car pattern) :|RelaxPat|) 
                                           (let ((pV26 (cdr pattern))) 
                                             (return 
                                              (SPECCALC::ppGrConcat 
                                               (cons 
                                                (WADLERLINDIG::ppString 
                                                 "(relax ") 
                                                (cons 
                                                 (SPECCALC::ppAPattern 
                                                  (svref pV26 0)) 
                                                 (cons 
                                                  (WADLERLINDIG::ppString " ") 
                                                  (cons 
                                                   (SPECCALC::ppATerm 
                                                    (svref pV26 1)) 
                                                   (cons 
                                                    (WADLERLINDIG::ppString ")") 
                                                    nil)))))))) 
                                           (if (eq (car pattern) :|QuotientPat|) 
                                               (let ((pV25 (cdr pattern))) 
                                                 (return 
                                                  (SPECCALC::ppGrConcat 
                                                   (cons 
                                                    (WADLERLINDIG::ppString 
                                                     "(quotient ") 
                                                    (cons 
                                                     (SPECCALC::ppAPattern 
                                                      (svref pV25 0)) 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       " ") 
                                                      (cons 
                                                       (SPECCALC::ppATerm 
                                                        (svref pV25 1)) 
                                                       (cons 
                                                        (WADLERLINDIG::ppString 
                                                         ")") 
                                                        nil))))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       "No match in ppAPattern with: '" 
       (SYSTEM-SPEC::toString pattern)) 
      "'")))))

(defun SPECCALC::ppAMatch (cases) 
  (labels 
    ((ppCase (pattern pV1 term) 
      (declare (ignore pV1)) 
      (SPECCALC::ppGrConcat 
       (cons 
        (WADLERLINDIG::ppString "| ") 
        (cons 
         (SPECCALC::ppAPattern pattern) 
         (cons 
          (WADLERLINDIG::ppString " -> ") 
          (cons (SPECCALC::ppATerm term) nil))))))) 
    (WADLERLINDIG::ppGroup 
     (WADLERLINDIG::ppSep-1-1 
      WADLERLINDIG::ppNewline 
      (LIST-SPEC::|!map|-1-1 
       #'(lambda (x) (ppCase (svref x 0) (svref x 1) (svref x 2))) 
       cases)))))

(defun SPECCALC::ppBinder (binder) 
  (block 
   nil 
   (if (eq (car binder) :|Forall|) 
       (return (WADLERLINDIG::ppString "fa")) 
       (if (eq (car binder) :|Exists|) (return (WADLERLINDIG::ppString "ex")))) 
   (error "Nonexhaustive match failure in ppBinder")))

(defun SPECCALC::ppATerm (term) 
  (let ((pV132 (SPECCALC::isFiniteList term))) 
    (block 
     nil 
     (if (eq (car pV132) :|Some|) 
         (return 
          (SPECCALC::ppGrConcat 
           (cons 
            (WADLERLINDIG::ppString "[") 
            (cons 
             (WADLERLINDIG::ppSep-1-1 
              (WADLERLINDIG::ppString ",") 
              (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppATerm (cdr pV132))) 
             (cons (WADLERLINDIG::ppString "]") nil))))) 
         (if (eq (car pV132) :|None|) 
             (return 
              (block 
               nil 
               (if (eq (car term) :|Apply|) 
                   (let ((pV50 (cdr term))) 
                     (let ((pV85 (svref pV50 1))
                           (pV84 (svref pV50 0))) 
                       (progn (if (eq (car pV84) :|Fun|) 
                                  (let ((pV97 (svref (cdr pV84) 0))) 
                                    (if (eq (car pV97) :|Op|) 
                                        (let ((pV100 (cdr pV97))) 
                                          (let ((pV114 (car pV100))) 
                                            (if (consp (cdr pV100)) 
                                                (if (eq (car pV85) :|Record|) 
                                                    (let ((pV120 
                                                           (car (cdr pV85)))) 
                                                      (if (consp pV120) 
                                                          (let ((pV124 
                                                                 (cdr pV120))
                                                                (pV123 
                                                                 (car pV120))) 
                                                            (let ((pV126 
                                                                   (cdr pV123))) 
                                                              (if (string=  
                                                                   "1" 
                                                                   (car pV123)) 
                                                                  (if (consp 
                                                                       pV124) 
                                                                      (let ((pV128 
                                                                             (car 
                                                                              pV124))) 
                                                                        (let ((pV131 
                                                                               (cdr 
                                                                                pV128))) 
                                                                          (if (string=  
                                                                               "2" 
                                                                               (car 
                                                                                pV128)) 
                                                                              (if (null 
                                                                                   (cdr 
                                                                                    pV124)) 
                                                                                  (return 
                                                                                   (if (cl:or 
                                                                                        (SPECCALC::isSimpleTerm? 
                                                                                         pV126) 
                                                                                        (SPECCALC::isSimpleTerm? 
                                                                                         pV131)) 
                                                                                       (WADLERLINDIG::ppGroup 
                                                                                        (WADLERLINDIG::ppConcat 
                                                                                         (cons 
                                                                                          (WADLERLINDIG::ppString 
                                                                                           "(") 
                                                                                          (cons 
                                                                                           (SPECCALC::ppATerm 
                                                                                            pV126) 
                                                                                           (cons 
                                                                                            (WADLERLINDIG::ppString 
                                                                                             " ") 
                                                                                            (cons 
                                                                                             (SPECCALC::ppQualifiedId 
                                                                                              pV114) 
                                                                                             (cons 
                                                                                              (WADLERLINDIG::ppString 
                                                                                               " ") 
                                                                                              (cons 
                                                                                               (SPECCALC::ppATerm 
                                                                                                pV131) 
                                                                                               (cons 
                                                                                                (WADLERLINDIG::ppString 
                                                                                                 ")") 
                                                                                                nil))))))))) 
                                                                                       (SPECCALC::ppGrConcat 
                                                                                        (cons 
                                                                                         (WADLERLINDIG::ppString 
                                                                                          "(") 
                                                                                         (cons 
                                                                                          (SPECCALC::ppATerm 
                                                                                           pV126) 
                                                                                          (cons 
                                                                                           (WADLERLINDIG::ppGroup 
                                                                                            (WADLERLINDIG::ppIndent 
                                                                                             (WADLERLINDIG::ppConcat 
                                                                                              (cons 
                                                                                               (WADLERLINDIG::ppString 
                                                                                                " ") 
                                                                                               (cons 
                                                                                                (SPECCALC::ppQualifiedId 
                                                                                                 pV114) 
                                                                                                (cons 
                                                                                                 WADLERLINDIG::ppBreak 
                                                                                                 (cons 
                                                                                                  (WADLERLINDIG::ppAppend-1-1 
                                                                                                   (SPECCALC::ppATerm 
                                                                                                    pV131) 
                                                                                                   (WADLERLINDIG::ppString 
                                                                                                    ")")) 
                                                                                                  nil))))))) 
                                                                                           nil)))))))))))))))))))) 
                                        (if (eq (car pV97) :|Equals|) 
                                            (if (eq (car pV85) :|Record|) 
                                                (let ((pV102 (car (cdr pV85)))) 
                                                  (if (consp pV102) 
                                                      (let ((pV106 (cdr pV102))
                                                            (pV105 (car pV102))) 
                                                        (let ((pV108 (cdr pV105))) 
                                                          (if (string=  
                                                               "1" 
                                                               (car pV105)) 
                                                              (if (consp pV106) 
                                                                  (let ((pV110 
                                                                         (car 
                                                                          pV106))) 
                                                                    (let ((pV113 
                                                                           (cdr 
                                                                            pV110))) 
                                                                      (if (string=  
                                                                           "2" 
                                                                           (car 
                                                                            pV110)) 
                                                                          (if (null 
                                                                               (cdr 
                                                                                pV106)) 
                                                                              (return 
                                                                               (if (cl:or 
                                                                                    (SPECCALC::isSimpleTerm? 
                                                                                     pV108) 
                                                                                    (SPECCALC::isSimpleTerm? 
                                                                                     pV113)) 
                                                                                   (WADLERLINDIG::ppGroup 
                                                                                    (WADLERLINDIG::ppConcat 
                                                                                     (cons 
                                                                                      (WADLERLINDIG::ppString 
                                                                                       "(") 
                                                                                      (cons 
                                                                                       (SPECCALC::ppATerm 
                                                                                        pV108) 
                                                                                       (cons 
                                                                                        (WADLERLINDIG::ppString 
                                                                                         " = ") 
                                                                                        (cons 
                                                                                         (SPECCALC::ppATerm 
                                                                                          pV113) 
                                                                                         (cons 
                                                                                          (WADLERLINDIG::ppString 
                                                                                           ")") 
                                                                                          nil))))))) 
                                                                                   (SPECCALC::ppGrConcat 
                                                                                    (cons 
                                                                                     (WADLERLINDIG::ppString 
                                                                                      "(") 
                                                                                     (cons 
                                                                                      (SPECCALC::ppATerm 
                                                                                       pV108) 
                                                                                      (cons 
                                                                                       (WADLERLINDIG::ppGroup 
                                                                                        (WADLERLINDIG::ppIndent 
                                                                                         (WADLERLINDIG::ppConcat 
                                                                                          (cons 
                                                                                           (WADLERLINDIG::ppString 
                                                                                            " =") 
                                                                                           (cons 
                                                                                            WADLERLINDIG::ppBreak 
                                                                                            (cons 
                                                                                             (WADLERLINDIG::ppAppend-1-1 
                                                                                              (SPECCALC::ppATerm 
                                                                                               pV113) 
                                                                                              (WADLERLINDIG::ppString 
                                                                                               ")")) 
                                                                                             nil)))))) 
                                                                                       nil)))))))))))))))))))) 
                                  (if (eq (car pV84) :|Lambda|) 
                                      (let ((pV89 (car (cdr pV84)))) 
                                        (if (consp pV89) 
                                            (if (consp (cdr pV89)) 
                                                (return 
                                                 (WADLERLINDIG::ppIndent 
                                                  (SPECCALC::ppGrConcat 
                                                   (cons 
                                                    (WADLERLINDIG::ppString 
                                                     "case ") 
                                                    (cons 
                                                     (SPECCALC::ppATerm pV85) 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       " of") 
                                                      (cons 
                                                       (WADLERLINDIG::ppIndent 
                                                        (WADLERLINDIG::ppAppend-1-1 
                                                         WADLERLINDIG::ppBreak 
                                                         (SPECCALC::ppAMatch 
                                                          pV89))) 
                                                       nil)))))))))))) 
                              (return 
                               (if (cl:or 
                                    (SPECCALC::isSimpleTerm? pV84) 
                                    (SPECCALC::isSimpleTerm? pV85)) 
                                   (WADLERLINDIG::ppGroup 
                                    (WADLERLINDIG::ppConcat 
                                     (cons 
                                      (WADLERLINDIG::ppString "(") 
                                      (cons 
                                       (SPECCALC::ppATerm pV84) 
                                       (cons 
                                        (WADLERLINDIG::ppString " ") 
                                        (cons 
                                         (SPECCALC::ppATerm pV85) 
                                         (cons (WADLERLINDIG::ppString ")") nil))))))) 
                                   (SPECCALC::ppGrConcat 
                                    (cons 
                                     (WADLERLINDIG::ppString "(") 
                                     (cons 
                                      (WADLERLINDIG::ppGroup 
                                       (WADLERLINDIG::ppIndent 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (SPECCALC::ppATerm pV84) 
                                          (cons 
                                           WADLERLINDIG::ppBreak 
                                           (cons 
                                            (WADLERLINDIG::ppAppend-1-1 
                                             (SPECCALC::ppATerm pV85) 
                                             (WADLERLINDIG::ppString ")")) 
                                            nil)))))) 
                                      nil)))))))) 
                   (if (eq (car term) :|ApplyN|) 
                       (let ((pV82 (car (cdr term)))) 
                         (return 
                          (labels 
                            ((ppTerms (l) 
                              (block 
                               nil 
                               (if (null l) 
                                   (return WADLERLINDIG::ppNil) 
                                   (if (consp l) 
                                       (let ((pV17 (cdr l))
                                             (pV16 (car l))) 
                                         (progn (if (null pV17) 
                                                    (return 
                                                     (SPECCALC::ppATerm pV16))) 
                                                (return 
                                                 (WADLERLINDIG::ppGroup 
                                                  (WADLERLINDIG::ppIndent 
                                                   (WADLERLINDIG::ppCons-1-1 
                                                    (SPECCALC::ppATerm pV16) 
                                                    (WADLERLINDIG::ppCons-1-1 
                                                     WADLERLINDIG::ppBreak 
                                                     (ppTerms pV17)))))))))) 
                               (error "Nonexhaustive match failure in ppATerm")))) 
                            (ppTerms pV82)))) 
                       (if (eq (car term) :|Record|) 
                           (let ((pV80 (car (cdr term)))) 
                             (return 
                              (block 
                               nil 
                               (if (null pV80) 
                                   (return (WADLERLINDIG::ppString "()")) 
                                   (if (consp pV80) 
                                       (if (string=  "1" (car (car pV80))) 
                                           (return 
                                            (labels 
                                              ((ppField (pV21 y) 
                                                (declare (ignore pV21)) 
                                                (SPECCALC::ppATerm y))) 
                                              (WADLERLINDIG::ppConcat 
                                               (cons 
                                                (WADLERLINDIG::ppString "(") 
                                                (cons 
                                                 (WADLERLINDIG::ppSep-1-1 
                                                  (WADLERLINDIG::ppString ",") 
                                                  (LIST-SPEC::|!map|-1-1 
                                                   #'(lambda (x) 
                                                      (ppField (car x) (cdr x))) 
                                                   pV80)) 
                                                 (cons 
                                                  (WADLERLINDIG::ppString ")") 
                                                  nil))))))))) 
                               (return 
                                (labels 
                                  ((ppField (x y) 
                                    (WADLERLINDIG::ppConcat 
                                     (cons 
                                      (WADLERLINDIG::ppString x) 
                                      (cons 
                                       (WADLERLINDIG::ppString "=") 
                                       (cons (SPECCALC::ppATerm y) nil)))))) 
                                  (WADLERLINDIG::ppConcat 
                                   (cons 
                                    (WADLERLINDIG::ppString "{") 
                                    (cons 
                                     (WADLERLINDIG::ppSep-1-1 
                                      (WADLERLINDIG::ppString ",") 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (x) (ppField (car x) (cdr x))) 
                                       pV80)) 
                                     (cons (WADLERLINDIG::ppString "}") nil))))))))) 
                           (if (eq (car term) :|Bind|) 
                               (let ((pV47 (cdr term))) 
                                 (return 
                                  (SPECCALC::ppGrConcat 
                                   (cons 
                                    (SPECCALC::ppBinder (svref pV47 0)) 
                                    (cons 
                                     (WADLERLINDIG::ppString " (") 
                                     (cons 
                                      (WADLERLINDIG::ppSep-1-1 
                                       (WADLERLINDIG::ppString ",") 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'SPECCALC::ppAVarWithoutSort-1 
                                        (svref pV47 1))) 
                                      (cons 
                                       (WADLERLINDIG::ppString ") ") 
                                       (cons 
                                        (SPECCALC::ppATerm (svref pV47 2)) 
                                        nil)))))))) 
                               (if (eq (car term) :|Let|) 
                                   (let ((pV46 (cdr term))) 
                                     (let ((pV74 (svref pV46 1))
                                           (pV73 (svref pV46 0))) 
                                       (return 
                                        (labels 
                                          ((ppDecl (pattern term1) 
                                            (WADLERLINDIG::ppConcat 
                                             (cons 
                                              (SPECCALC::ppAPattern pattern) 
                                              (cons 
                                               (WADLERLINDIG::ppString "=") 
                                               (cons 
                                                (SPECCALC::ppATerm term1) 
                                                nil)))))) 
                                          (SPECCALC::ppGrConcat 
                                           (cons 
                                            (WADLERLINDIG::ppString "let ") 
                                            (cons 
                                             (WADLERLINDIG::ppIndent 
                                              (WADLERLINDIG::ppSep-1-1 
                                               WADLERLINDIG::ppNewline 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'(lambda (x) 
                                                   (ppDecl (car x) (cdr x))) 
                                                pV73))) 
                                             (cons 
                                              (WADLERLINDIG::ppString "in") 
                                              (cons 
                                               WADLERLINDIG::ppNewline 
                                               (cons 
                                                (WADLERLINDIG::ppIndent 
                                                 (SPECCALC::ppATerm pV74)) 
                                                nil)))))))))) 
                                   (if (eq (car term) :|LetRec|) 
                                       (let ((pV45 (cdr term))) 
                                         (let ((pV71 (svref pV45 1))
                                               (pV70 (svref pV45 0))) 
                                           (return 
                                            (labels 
                                              ((ppDecl (var term1) 
                                                (SPECCALC::ppGrConcat 
                                                 (cons 
                                                  (WADLERLINDIG::ppString "def ") 
                                                  (cons 
                                                   (SPECCALC::ppAVarWithoutSort-1 
                                                    var) 
                                                   (cons 
                                                    (WADLERLINDIG::ppString 
                                                     " = ") 
                                                    (cons 
                                                     (SPECCALC::ppATerm term1) 
                                                     nil))))))) 
                                              (SPECCALC::ppGrConcat 
                                               (cons 
                                                (WADLERLINDIG::ppString "let") 
                                                (cons 
                                                 WADLERLINDIG::ppNewline 
                                                 (cons 
                                                  (WADLERLINDIG::ppString "  ") 
                                                  (cons 
                                                   (WADLERLINDIG::ppIndent 
                                                    (WADLERLINDIG::ppSep-1-1 
                                                     WADLERLINDIG::ppNewline 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (ppDecl (car x) (cdr x))) 
                                                      pV70))) 
                                                   (cons 
                                                    WADLERLINDIG::ppNewline 
                                                    (cons 
                                                     (WADLERLINDIG::ppString 
                                                      "in") 
                                                     (cons 
                                                      WADLERLINDIG::ppNewline 
                                                      (cons 
                                                       (SPECCALC::ppATerm pV71) 
                                                       nil))))))))))))) 
                                       (if (eq (car term) :|Var|) 
                                           (return 
                                            (SPECCALC::ppAVarWithoutSort-1 
                                             (car (cdr term)))) 
                                           (if (eq (car term) :|Fun|) 
                                               (return 
                                                (SPECCALC::ppAFun 
                                                 (svref (cdr term) 0))) 
                                               (if (eq (car term) :|Lambda|) 
                                                   (let ((pV57 (car (cdr term)))) 
                                                     (progn (if (consp pV57) 
                                                                (let ((pV60 
                                                                       (car pV57))) 
                                                                  (if (null 
                                                                       (cdr pV57)) 
                                                                      (return 
                                                                       (SPECCALC::ppGrConcat 
                                                                        (cons 
                                                                         (WADLERLINDIG::ppString 
                                                                          "(fn ") 
                                                                         (cons 
                                                                          (SPECCALC::ppAPattern 
                                                                           (svref 
                                                                            pV60 
                                                                            0)) 
                                                                          (cons 
                                                                           (WADLERLINDIG::ppGroup 
                                                                            (WADLERLINDIG::ppIndent 
                                                                             (WADLERLINDIG::ppConcat 
                                                                              (cons 
                                                                               (WADLERLINDIG::ppString 
                                                                                " ->") 
                                                                               (cons 
                                                                                WADLERLINDIG::ppBreak 
                                                                                (cons 
                                                                                 (WADLERLINDIG::ppAppend-1-1 
                                                                                  (SPECCALC::ppATerm 
                                                                                   (svref 
                                                                                    pV60 
                                                                                    2)) 
                                                                                  (WADLERLINDIG::ppString 
                                                                                   ")")) 
                                                                                 nil)))))) 
                                                                           nil)))))))) 
                                                            (return 
                                                             (SPECCALC::ppAMatch 
                                                              pV57)))) 
                                                   (if (eq 
                                                        (car term) 
                                                        :|IfThenElse|) 
                                                       (let ((pV41 (cdr term))) 
                                                         (return 
                                                          (SPECCALC::ppGrConcat 
                                                           (cons 
                                                            (WADLERLINDIG::ppString 
                                                             "if ") 
                                                            (cons 
                                                             (SPECCALC::ppATerm 
                                                              (svref pV41 0)) 
                                                             (cons 
                                                              (WADLERLINDIG::ppString 
                                                               " then") 
                                                              (cons 
                                                               WADLERLINDIG::ppBreak 
                                                               (cons 
                                                                (WADLERLINDIG::ppIndent 
                                                                 (SPECCALC::ppATerm 
                                                                  (svref pV41 1))) 
                                                                (cons 
                                                                 WADLERLINDIG::ppBreak 
                                                                 (cons 
                                                                  (WADLERLINDIG::ppString 
                                                                   "else") 
                                                                  (cons 
                                                                   WADLERLINDIG::ppBreak 
                                                                   (cons 
                                                                    (WADLERLINDIG::ppIndent 
                                                                     (SPECCALC::ppATerm 
                                                                      (svref 
                                                                       pV41 
                                                                       2))) 
                                                                    nil)))))))))))) 
                                                       (if (eq (car term) :|Seq|) 
                                                           (return 
                                                            (WADLERLINDIG::ppSep-1-1 
                                                             (WADLERLINDIG::ppString 
                                                              "; ") 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'SPECCALC::ppATerm 
                                                              (car (cdr term)))))))))))))))) 
               (return 
                (SYSTEM-SPEC::fail 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   "No match in ppATerm with: '" 
                   (SYSTEM-SPEC::toString term)) 
                  "'"))))))) 
     (error "Nonexhaustive match failure in ppATerm"))))

(defun SPECCALC::ppASort (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV35 (cdr srt))) 
         (let ((pV57 (svref pV35 1))
               (pV56 (svref pV35 0))) 
           (return 
            (if (cl:or 
                 (SPECCALC::isSimpleSort? pV56) 
                 (SPECCALC::isSimpleSort? pV57)) 
                (WADLERLINDIG::ppGroup 
                 (WADLERLINDIG::ppConcat 
                  (cons 
                   (WADLERLINDIG::ppString "(") 
                   (cons 
                    (SPECCALC::ppASort pV56) 
                    (cons 
                     (WADLERLINDIG::ppString " -> ") 
                     (cons 
                      (SPECCALC::ppASort pV57) 
                      (cons (WADLERLINDIG::ppString ")") nil))))))) 
                (SPECCALC::ppGrConcat 
                 (cons 
                  (WADLERLINDIG::ppString "(") 
                  (cons 
                   (SPECCALC::ppASort pV56) 
                   (cons 
                    (WADLERLINDIG::ppGroup 
                     (WADLERLINDIG::ppIndent 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (WADLERLINDIG::ppString " ->") 
                        (cons 
                         WADLERLINDIG::ppBreak 
                         (cons 
                          (SPECCALC::ppASort pV57) 
                          (cons (WADLERLINDIG::ppString ")") nil))))))) 
                    nil)))))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV54 (car (cdr srt)))) 
             (return 
              (block 
               nil 
               (if (null pV54) 
                   (return (WADLERLINDIG::ppString "()")) 
                   (if (consp pV54) 
                       (if (string=  "1" (car (car pV54))) 
                           (return 
                            (labels 
                              ((ppField (pV5 y) 
                                (declare (ignore pV5)) 
                                (SPECCALC::ppASort y))) 
                              (SPECCALC::ppGrConcat 
                               (cons 
                                (WADLERLINDIG::ppString "(") 
                                (cons 
                                 (WADLERLINDIG::ppSep-1-1 
                                  (WADLERLINDIG::ppString " * ") 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'(lambda (x) (ppField (car x) (cdr x))) 
                                   pV54)) 
                                 (cons (WADLERLINDIG::ppString ")") nil))))))))) 
               (return 
                (labels 
                  ((ppField (x y) 
                    (WADLERLINDIG::ppGroup 
                     (WADLERLINDIG::ppConcat 
                      (cons 
                       (WADLERLINDIG::ppString x) 
                       (cons 
                        (WADLERLINDIG::ppString " : ") 
                        (cons (SPECCALC::ppASort y) nil))))))) 
                  (WADLERLINDIG::ppIndent 
                   (SPECCALC::ppGrConcat 
                    (cons 
                     (WADLERLINDIG::ppString "{") 
                     (cons 
                      (WADLERLINDIG::ppSep-1-1 
                       (WADLERLINDIG::ppAppend-1-1 
                        (WADLERLINDIG::ppString ",") 
                        WADLERLINDIG::ppBreak) 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (x) (ppField (car x) (cdr x))) 
                        pV54)) 
                      (cons (WADLERLINDIG::ppString "}") nil)))))))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV52 (car (cdr srt)))) 
                 (return 
                  (labels 
                    ((ppTaggedSort (id |!optSrt|) 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (WADLERLINDIG::ppString "(") 
                        (cons 
                         (WADLERLINDIG::ppString id) 
                         (cons 
                          (WADLERLINDIG::ppString " ") 
                          (cons 
                           (block 
                            nil 
                            (if (eq (car |!optSrt|) :|None|) 
                                (return WADLERLINDIG::ppNil) 
                                (if (eq (car |!optSrt|) :|Some|) 
                                    (return (SPECCALC::ppASort (cdr |!optSrt|))))) 
                            (error "Nonexhaustive match failure in ppASort")) 
                           (cons (WADLERLINDIG::ppString ")") nil)))))))) 
                    (SPECCALC::ppGrConcat 
                     (cons 
                      (WADLERLINDIG::ppString "(") 
                      (cons 
                       WADLERLINDIG::ppBreak 
                       (cons 
                        (WADLERLINDIG::ppSep-1-1 
                         (WADLERLINDIG::ppAppend-1-1 
                          WADLERLINDIG::ppBreak 
                          (WADLERLINDIG::ppString "|")) 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (x) (ppTaggedSort (car x) (cdr x))) 
                          pV52)) 
                        (cons (WADLERLINDIG::ppString ")") nil)))))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV32 (cdr srt))) 
                     (return 
                      (SPECCALC::ppGrConcat 
                       (cons 
                        (WADLERLINDIG::ppString "(") 
                        (cons 
                         (SPECCALC::ppASort (svref pV32 0)) 
                         (cons 
                          (WADLERLINDIG::ppString " \\ ") 
                          (cons 
                           (SPECCALC::ppATerm (svref pV32 1)) 
                           (cons (WADLERLINDIG::ppString ")") nil)))))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV31 (cdr srt))) 
                         (return 
                          (SPECCALC::ppGrConcat 
                           (cons 
                            (WADLERLINDIG::ppString "(") 
                            (cons 
                             (SPECCALC::ppASort (svref pV31 0)) 
                             (cons 
                              (WADLERLINDIG::ppString " | ") 
                              (cons 
                               (SPECCALC::ppATerm (svref pV31 1)) 
                               (cons (WADLERLINDIG::ppString ")") nil)))))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV30 (cdr srt))) 
                             (let ((pV41 (svref pV30 1))
                                   (pV40 (svref pV30 0))) 
                               (progn (if (null pV41) 
                                          (return (SPECCALC::ppQualifiedId pV40)) 
                                          (if (consp pV41) 
                                              (if (null (cdr pV41)) 
                                                  (return 
                                                   (SPECCALC::ppGrConcat 
                                                    (cons 
                                                     (SPECCALC::ppQualifiedId 
                                                      pV40) 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       " ") 
                                                      (cons 
                                                       (SPECCALC::ppASort 
                                                        (car pV41)) 
                                                       nil)))))))) 
                                      (return 
                                       (SPECCALC::ppGrConcat 
                                        (cons 
                                         (SPECCALC::ppQualifiedId pV40) 
                                         (cons 
                                          (WADLERLINDIG::ppString " (") 
                                          (cons 
                                           (WADLERLINDIG::ppSep-1-1 
                                            (WADLERLINDIG::ppString ",") 
                                            (LIST-SPEC::|!map|-1-1 
                                             #'SPECCALC::ppASort 
                                             pV41)) 
                                           (cons 
                                            (WADLERLINDIG::ppString ")") 
                                            nil))))))))) 
                           (if (eq (car srt) :|TyVar|) 
                               (return (WADLERLINDIG::ppString (car (cdr srt)))) 
                               (if (eq (car srt) :|MetaTyVar|) 
                                   (return 
                                    (let ((pV23 (STATE::|!!| (car (cdr srt))))) 
                                      (block 
                                       nil 
                                       (return 
                                        (WADLERLINDIG::ppString 
                                         (STRING-SPEC::^ 
                                          (svref pV23 1) 
                                          (NAT-SPEC::toString (svref pV23 2))))) 
                                       (error 
                                        "Nonexhaustive match failure in ppASort")))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "No match in ppASort with: '" (SYSTEM-SPEC::toString srt)) 
      "'")))))

(defun SPECCALC::ppIdInfo (qids) 
  (WADLERLINDIG::ppSep-1-1 
   (WADLERLINDIG::ppString ",") 
   (LIST-SPEC::|!map|-1-1 
    #'WADLERLINDIG::ppString 
    (LIST-SPEC::|!map|-1-1 #'METASLANG::printQualifiedId qids))))

(defun SPECCALC::ppAOpDecl (pV3 pV4 pV5) 
  (declare (ignore pV4)) 
  (block 
   nil 
   (let ((pV6 (car pV5))) 
     (return 
      (WADLERLINDIG::ppConcat 
       (cons 
        (WADLERLINDIG::ppString "op ") 
        (cons 
         (SPECCALC::ppIdInfo pV3) 
         (cons 
          (WADLERLINDIG::ppString " : ") 
          (cons 
           (block 
            nil 
            (if (null pV6) (return WADLERLINDIG::ppNil)) 
            (return 
             (WADLERLINDIG::ppConcat 
              (cons 
               (WADLERLINDIG::ppString "fa (") 
               (cons 
                (WADLERLINDIG::ppSep-1-1 
                 (WADLERLINDIG::ppString ",") 
                 (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString pV6)) 
                (cons (WADLERLINDIG::ppString ") ") nil)))))) 
           (cons (SPECCALC::ppASort (cdr pV5)) nil)))))))) 
   (error "Nonexhaustive match failure in ppAOpDecl")))

(defun SPECCALC::ppAOpDefs (aliases defs) 
  (let ((prefix 
         (WADLERLINDIG::ppConcat 
          (cons 
           (WADLERLINDIG::ppString "def ") 
           (cons (SPECCALC::ppIdInfo aliases) nil))))) 
    (labels 
      ((pp_def (type_vars term) 
        (WADLERLINDIG::ppConcat 
         (cons 
          prefix 
          (cons 
           (block 
            nil 
            (if (null type_vars) (return WADLERLINDIG::ppNil)) 
            (return 
             (WADLERLINDIG::ppConcat 
              (cons 
               (WADLERLINDIG::ppString "fa (") 
               (cons 
                (WADLERLINDIG::ppSep-1-1 
                 (WADLERLINDIG::ppString ",") 
                 (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString type_vars)) 
                (cons (WADLERLINDIG::ppString ")") nil)))))) 
           (cons 
            (WADLERLINDIG::ppString " = ") 
            (cons (SPECCALC::ppATerm term) nil))))))) 
      (block 
       nil 
       (if (consp defs) 
           (let ((pV6 (car defs))) 
             (if (null (cdr defs)) (return (pp_def (car pV6) (cdr pV6)))))) 
       (return 
        (WADLERLINDIG::ppConcat 
         (cons 
          WADLERLINDIG::ppNewline 
          (cons 
           (WADLERLINDIG::ppString 
            " (* Warning: Multiple definitions for following sort: *) ") 
           (cons 
            WADLERLINDIG::ppNewline 
            (cons 
             (WADLERLINDIG::ppSep-1-1 
              WADLERLINDIG::ppNewline 
              (LIST-SPEC::|!map|-1-1 
               #'(lambda (x) (pp_def (car x) (cdr x))) 
               defs)) 
             nil))))))))))

(defun SPECCALC::myppAOpInfo (pV3 pV4) 
  (block 
   nil 
   (let ((pV7 (svref pV4 2))) 
     (return 
      (block 
       nil 
       (if (null pV7) 
           (return (SPECCALC::ppAOpDecl pV3 (svref pV4 0) (svref pV4 1)))) 
       (return (SPECCALC::ppAOpDefs pV3 pV7))))) 
   (error "Nonexhaustive match failure in myppAOpInfo")))

(defun SPECCALC::ppTyVars (type_vars) 
  (block 
   nil 
   (if (null type_vars) (return WADLERLINDIG::ppNil)) 
   (return 
    (WADLERLINDIG::ppConcat 
     (cons 
      (WADLERLINDIG::ppString " (") 
      (cons 
       (WADLERLINDIG::ppSep-1-1 
        (WADLERLINDIG::ppString ",") 
        (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString type_vars)) 
       (cons (WADLERLINDIG::ppString ") ") nil)))))))

(defun SPECCALC::myppASortInfo (aliases sortInfo) 
  (let ((prefix 
         (WADLERLINDIG::ppConcat 
          (cons 
           (WADLERLINDIG::ppString "sort ") 
           (cons (SPECCALC::ppIdInfo aliases) nil))))) 
    (let ((pV3 (cdr sortInfo))) 
      (block 
       nil 
       (if (null (car sortInfo)) (if (null pV3) (return prefix))) 
       (if (consp pV3) 
           (let ((pV5 (car pV3))) 
             (if (null (cdr pV3)) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    prefix 
                    (cons 
                     (SPECCALC::ppTyVars (car pV5)) 
                     (cons 
                      (WADLERLINDIG::ppAppend-1-1 
                       (WADLERLINDIG::ppString " = ") 
                       (SPECCALC::ppASort (cdr pV5))) 
                      nil)))))))) 
       (return 
        (WADLERLINDIG::ppConcat 
         (cons 
          WADLERLINDIG::ppNewline 
          (cons 
           (WADLERLINDIG::ppString 
            " (* Warning: Multiple definitions for following sort: *) ") 
           (cons 
            WADLERLINDIG::ppNewline 
            (cons 
             (WADLERLINDIG::ppSep-1-1 
              WADLERLINDIG::ppNewline 
              (LIST-SPEC::|!map|-1-1 
               #'(lambda (x1) 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    prefix 
                    (cons 
                     (SPECCALC::ppTyVars (car x1)) 
                     (cons 
                      (WADLERLINDIG::ppAppend-1-1 
                       (WADLERLINDIG::ppString " = ") 
                       (SPECCALC::ppASort (cdr x1))) 
                      nil))))) 
               pV3)) 
             nil)))))) 
       (error "Nonexhaustive match failure in myppASortInfo")))))

(defun SPECCALC::ppPropertyType (propType) 
  (block 
   nil 
   (if (eq (car propType) :|Axiom|) 
       (return (WADLERLINDIG::ppString "axiom")) 
       (if (eq (car propType) :|Theorem|) 
           (return (WADLERLINDIG::ppString "theorem")) 
           (if (eq (car propType) :|Conjecture|) 
               (return (WADLERLINDIG::ppString "conjecture"))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       "No match in ppPropertyType with: '" 
       (SYSTEM-SPEC::toString propType)) 
      "'")))))

(defun SPECCALC::ppAProperty (propType name |!tyVars| term) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (SPECCALC::ppPropertyType propType) 
    (cons 
     (WADLERLINDIG::ppString " ") 
     (cons 
      (WADLERLINDIG::ppString name) 
      (cons 
       (WADLERLINDIG::ppGroup 
        (WADLERLINDIG::ppIndent 
         (WADLERLINDIG::ppConcat 
          (cons 
           (WADLERLINDIG::ppString " is") 
           (cons 
            WADLERLINDIG::ppBreak 
            (cons 
             (WADLERLINDIG::ppGroup 
              (WADLERLINDIG::ppConcat 
               (cons 
                (block 
                 nil 
                 (if (null |!tyVars|) (return WADLERLINDIG::ppNil)) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString "fa (") 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      (WADLERLINDIG::ppString ",") 
                      (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString |!tyVars|)) 
                     (cons (WADLERLINDIG::ppString ") ") nil)))))) 
                (cons 
                 (WADLERLINDIG::ppString " ") 
                 (cons (SPECCALC::ppATerm term) nil))))) 
             nil)))))) 
       nil))))))

(defun SPECCALC::ppAProperty-1 (x) 
  (SPECCALC::ppAProperty (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::ppSpecElem (elem pV1) 
  (declare (ignore pV1)) 
  (block 
   nil 
   (if (eq (car elem) :|Import|) 
       (return 
        (WADLERLINDIG::ppConcat 
         (cons 
          (WADLERLINDIG::ppString "import ") 
          (cons (SPECCALC::ppTerm-1 (cdr elem)) nil)))) 
       (if (eq (car elem) :|Sort|) 
           (let ((pV5 (cdr elem))) 
             (return (SPECCALC::myppASortInfo (car pV5) (cdr pV5)))) 
           (if (eq (car elem) :|Op|) 
               (let ((pV4 (cdr elem))) 
                 (return (SPECCALC::myppAOpInfo (car pV4) (cdr pV4)))) 
               (if (eq (car elem) :|Claim|) 
                   (return (SPECCALC::ppAProperty-1 (cdr elem))))))) 
   (error "Nonexhaustive match failure in ppSpecElem")))

(defun SPECCALC::ppSpecElem-1 (x) (SPECCALC::ppSpecElem (car x) (cdr x)))

(defun SPECCALC::ppSpecElems (elems) 
  (WADLERLINDIG::ppSep-1-1 
   WADLERLINDIG::ppNewline 
   (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppSpecElem-1 elems)))

(defun SPECCALC::ppTerm (term pV1) 
  (declare (ignore pV1)) 
  (block 
   nil 
   (if (eq (car term) :|Print|) 
       (return 
        (WADLERLINDIG::ppConcat 
         (cons 
          (WADLERLINDIG::ppString "print ") 
          (cons (SPECCALC::ppTerm-1 (cdr term)) nil)))) 
       (if (eq (car term) :|URI|) 
           (return (SPECCALC::ppRelativeURI (cdr term))) 
           (if (eq (car term) :|Spec|) 
               (return 
                (WADLERLINDIG::ppConcat 
                 (cons 
                  (WADLERLINDIG::ppString "spec {") 
                  (cons 
                   WADLERLINDIG::ppNewline 
                   (cons 
                    (WADLERLINDIG::ppString "  ") 
                    (cons 
                     (WADLERLINDIG::ppNest-1-1 
                      2 
                      (SPECCALC::ppSpecElems (cdr term))) 
                     (cons 
                      WADLERLINDIG::ppNewline 
                      (cons (WADLERLINDIG::ppString "}") nil)))))))) 
               (if (eq (car term) :|Qualify|) 
                   (let ((pV35 (cdr term))) 
                     (return 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (WADLERLINDIG::ppString (cdr pV35)) 
                        (cons 
                         (WADLERLINDIG::ppString " qualifying ") 
                         (cons (SPECCALC::ppTerm-1 (car pV35)) nil)))))) 
                   (if (eq (car term) :|Translate|) 
                       (let ((pV34 (cdr term))) 
                         (let ((pV48 (car pV34))) 
                           (let ((pV50 (car (cdr pV34)))) 
                             (return 
                              (labels 
                                ((ppTranslateRule (rule pV3) 
                                  (declare (ignore pV3)) 
                                  (block 
                                   nil 
                                   (if (eq (car rule) :|Sort|) 
                                       (let ((pV9 (cdr rule))) 
                                         (return 
                                          (WADLERLINDIG::ppConcat 
                                           (cons 
                                            (SPECCALC::ppQualifier (svref pV9 0)) 
                                            (cons 
                                             (WADLERLINDIG::ppString " -> ") 
                                             (cons 
                                              (SPECCALC::ppQualifier 
                                               (svref pV9 1)) 
                                              nil)))))) 
                                       (if (eq (car rule) :|Op|) 
                                           (let ((pV8 (cdr rule))) 
                                             (return 
                                              (WADLERLINDIG::ppConcat 
                                               (cons 
                                                (SPECCALC::ppQualifier 
                                                 (car (svref pV8 0))) 
                                                (cons 
                                                 (WADLERLINDIG::ppString " -> ") 
                                                 (cons 
                                                  (SPECCALC::ppQualifier 
                                                   (car (svref pV8 1))) 
                                                  nil)))))) 
                                           (if (eq (car rule) :|Ambiguous|) 
                                               (let ((pV7 (cdr rule))) 
                                                 (return 
                                                  (WADLERLINDIG::ppConcat 
                                                   (cons 
                                                    (SPECCALC::ppQualifier 
                                                     (svref pV7 0)) 
                                                    (cons 
                                                     (WADLERLINDIG::ppString 
                                                      " -> ") 
                                                     (cons 
                                                      (SPECCALC::ppQualifier 
                                                       (svref pV7 1)) 
                                                      nil))))))))) 
                                   (error 
                                    "Nonexhaustive match failure in ppTerm")))) 
                                (WADLERLINDIG::ppConcat 
                                 (cons 
                                  (WADLERLINDIG::ppString "{") 
                                  (cons 
                                   (WADLERLINDIG::ppSep-1-1 
                                    (WADLERLINDIG::ppString ", ") 
                                    (LIST-SPEC::|!map|-1-1 
                                     #'(lambda (x) 
                                        (ppTranslateRule (car x) (cdr x))) 
                                     pV50)) 
                                   (cons 
                                    (WADLERLINDIG::ppString "}") 
                                    (cons 
                                     (WADLERLINDIG::ppString " translating ") 
                                     (cons (SPECCALC::ppTerm-1 pV48) nil))))))))))) 
                       (if (eq (car term) :|Let|) 
                           (let ((pV33 (cdr term))) 
                             (return 
                              (WADLERLINDIG::ppConcat 
                               (cons 
                                (WADLERLINDIG::ppString "let {") 
                                (cons 
                                 WADLERLINDIG::ppNewline 
                                 (cons 
                                  (WADLERLINDIG::ppString "  ") 
                                  (cons 
                                   (WADLERLINDIG::ppNest-1-1 
                                    2 
                                    (SPECCALC::ppDecls (car pV33))) 
                                   (cons 
                                    WADLERLINDIG::ppNewline 
                                    (cons 
                                     (WADLERLINDIG::ppString "} in") 
                                     (cons 
                                      WADLERLINDIG::ppNewline 
                                      (cons 
                                       (WADLERLINDIG::ppNest-1-1 
                                        2 
                                        (SPECCALC::ppTerm-1 (cdr pV33))) 
                                       nil))))))))))) 
                           (if (eq (car term) :|Where|) 
                               (let ((pV32 (cdr term))) 
                                 (return 
                                  (WADLERLINDIG::ppConcat 
                                   (cons 
                                    (SPECCALC::ppTerm-1 (cdr pV32)) 
                                    (cons 
                                     WADLERLINDIG::ppNewline 
                                     (cons 
                                      (WADLERLINDIG::ppString "  ") 
                                      (cons 
                                       (WADLERLINDIG::ppString "where {") 
                                       (cons 
                                        WADLERLINDIG::ppNewline 
                                        (cons 
                                         (WADLERLINDIG::ppString "    ") 
                                         (cons 
                                          (WADLERLINDIG::ppNest-1-1 
                                           4 
                                           (SPECCALC::ppDecls (car pV32))) 
                                          (cons 
                                           WADLERLINDIG::ppNewline 
                                           (cons 
                                            (WADLERLINDIG::ppString "}") 
                                            nil)))))))))))) 
                               (if (eq (car term) :|Diag|) 
                                   (return 
                                    (WADLERLINDIG::ppConcat 
                                     (cons 
                                      (WADLERLINDIG::ppString "diag {") 
                                      (cons 
                                       WADLERLINDIG::ppNewline 
                                       (cons 
                                        (WADLERLINDIG::ppString "  ") 
                                        (cons 
                                         (WADLERLINDIG::ppNest-1-1 
                                          2 
                                          (WADLERLINDIG::ppSep-1-1 
                                           WADLERLINDIG::ppNewline 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'SPECCALC::ppDiagElem-1 
                                            (cdr term)))) 
                                         (cons 
                                          WADLERLINDIG::ppNewline 
                                          (cons (WADLERLINDIG::ppString "}") nil)))))))) 
                                   (if (eq (car term) :|Colimit|) 
                                       (return 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (WADLERLINDIG::ppString "colim ") 
                                          (cons 
                                           (SPECCALC::ppTerm-1 (cdr term)) 
                                           nil)))) 
                                       (if (eq (car term) :|Subst|) 
                                           (let ((pV29 (cdr term))) 
                                             (return 
                                              (WADLERLINDIG::ppConcat 
                                               (cons 
                                                (SPECCALC::ppTerm-1 (car pV29)) 
                                                (cons 
                                                 (WADLERLINDIG::ppString " [") 
                                                 (cons 
                                                  (SPECCALC::ppTerm-1 (cdr pV29)) 
                                                  (cons 
                                                   (WADLERLINDIG::ppString "]") 
                                                   nil))))))) 
                                           (if (eq (car term) :|Generate|) 
                                               (let ((pV28 (cdr term))) 
                                                 (let ((pV41 (svref pV28 2))) 
                                                   (return 
                                                    (WADLERLINDIG::ppConcat 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       (STRING-SPEC::^ 
                                                        (STRING-SPEC::^ 
                                                         "generate " 
                                                         (svref pV28 0)) 
                                                        " ")) 
                                                      (cons 
                                                       (SPECCALC::ppTerm-1 
                                                        (svref pV28 1)) 
                                                       (cons 
                                                        (block 
                                                         nil 
                                                         (if (eq 
                                                              (car pV41) 
                                                              :|Some|) 
                                                             (return 
                                                              (WADLERLINDIG::ppString 
                                                               (STRING-SPEC::^ 
                                                                " in " 
                                                                (cdr pV41))))) 
                                                         (return 
                                                          WADLERLINDIG::ppNil)) 
                                                        nil))))))) 
                                               (if (eq (car term) :|Other|) 
                                                   (return 
                                                    (SPECCALC::ppOtherTerm 
                                                     (cdr term))))))))))))))) 
   (error "Nonexhaustive match failure in ppTerm")))

(defun SPECCALC::ppTerm-1 (x) (SPECCALC::ppTerm (car x) (cdr x)))

(defun SPECCALC::showTerm-1 (term) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppTerm-1 term)))

(defun SPECCALC::equivFun?-1-1 (spc x) 
  (let ((f1 (car x))
        (f2 (cdr x))) 
    (block 
     nil 
     (if (eq (car f1) :|PQuotient|) 
         (if (eq (car f2) :|PQuotient|) 
             (return (SPECCALC::equivTerm?-1-1 spc (cons (cdr f1) (cdr f2))))) 
         (if (eq (car f1) :|PChoose|) 
             (if (eq (car f2) :|PChoose|) 
                 (return (SPECCALC::equivTerm?-1-1 spc (cons (cdr f1) (cdr f2))))) 
             (if (eq (car f1) :|PRestrict|) 
                 (if (eq (car f2) :|PRestrict|) 
                     (return 
                      (SPECCALC::equivTerm?-1-1 spc (cons (cdr f1) (cdr f2))))) 
                 (if (eq (car f1) :|PRelax|) 
                     (if (eq (car f2) :|PRelax|) 
                         (return 
                          (SPECCALC::equivTerm?-1-1 spc (cons (cdr f1) (cdr f2))))))))) 
     (return t) 
     (if (eq (car f1) :|Quotient|) 
         (if (eq (car f2) :|Quotient|) (return t)) 
         (if (eq (car f1) :|Choose|) 
             (if (eq (car f2) :|Choose|) (return t)) 
             (if (eq (car f1) :|Restrict|) 
                 (if (eq (car f2) :|Restrict|) (return t)) 
                 (if (eq (car f1) :|Relax|) 
                     (if (eq (car f2) :|Relax|) (return t)) 
                     (if (eq (car f1) :|Op|) 
                         (let ((pV13 (cdr f1))) 
                           (if (eq (car f2) :|Op|) 
                               (let ((pV25 (cdr f2))) 
                                 (return 
                                  (cl:and 
                                   (slang-built-in::slang-term-equals 
                                    (cdr pV13) 
                                    (cdr pV25)) 
                                   (slang-built-in::slang-term-equals 
                                    (STANDARDSPEC::findTheOp spc (car pV13)) 
                                    (STANDARDSPEC::findTheOp spc (car pV25)))))))) 
                         (if (eq (car f1) :|Project|) 
                             (if (eq (car f2) :|Project|) 
                                 (return (string=  (cdr f1) (cdr f2)))) 
                             (if (eq (car f1) :|Embed|) 
                                 (if (eq (car f2) :|Embed|) 
                                     (return 
                                      (slang-built-in::slang-term-equals 
                                       (cdr f1) 
                                       (cdr f2)))) 
                                 (if (eq (car f1) :|Embedded|) 
                                     (if (eq (car f2) :|Embedded|) 
                                         (return (string=  (cdr f1) (cdr f2)))) 
                                     (if (eq (car f1) :|Nat|) 
                                         (if (eq (car f2) :|Nat|) 
                                             (return ( =  (cdr f1) (cdr f2)))) 
                                         (if (eq (car f1) :|Char|) 
                                             (if (eq (car f2) :|Char|) 
                                                 (return (eq (cdr f1) (cdr f2)))) 
                                             (if (eq (car f1) :|String|) 
                                                 (if (eq (car f2) :|String|) 
                                                     (return 
                                                      (string=  
                                                       (cdr f1) 
                                                       (cdr f2)))) 
                                                 (if (eq (car f1) :|Bool|) 
                                                     (if (eq (car f2) :|Bool|) 
                                                         (return 
                                                          (eq (cdr f1) (cdr f2)))) 
                                                     (if (eq (car f1) :|OneName|) 
                                                         (if (eq 
                                                              (car f2) 
                                                              :|OneName|) 
                                                             (return 
                                                              (slang-built-in::slang-term-equals 
                                                               (cdr f1) 
                                                               (cdr f2)))) 
                                                         (if (eq 
                                                              (car f1) 
                                                              :|TwoNames|) 
                                                             (if (eq 
                                                                  (car f2) 
                                                                  :|TwoNames|) 
                                                                 (return 
                                                                  (slang-built-in::slang-term-equals 
                                                                   (cdr f1) 
                                                                   (cdr f2)))))))))))))))))) 
     (return nil))))

(defun SPECCALC::equivList?-1-1 (spc x) 
  (let ((x1 (svref x 0))
        (y (svref x 1))
        (eqFn (svref x 2))) 
    (cl:and 
     ( =  (LIST-SPEC::|!length| x1) (LIST-SPEC::|!length| y)) 
     (block 
      nil 
      (if (null x1) 
          (if (null y) (return t)) 
          (if (consp x1) 
              (if (consp y) 
                  (return 
                   (cl:and 
                    (funcall (funcall eqFn spc) (cons (car x1) (car y))) 
                    (SPECCALC::equivList?-1-1 spc (vector (cdr x1) (cdr y) eqFn))))))) 
      (return nil)))))

(defun SPECCALC::equivOpt?-1-1 (spc x) 
  (let ((x1 (svref x 0))
        (y (svref x 1))) 
    (block 
     nil 
     (if (eq (car x1) :|None|) 
         (if (eq (car y) :|None|) (return t)) 
         (if (eq (car x1) :|Some|) 
             (if (eq (car y) :|Some|) 
                 (return 
                  (funcall (funcall (svref x 2) spc) (cons (cdr x1) (cdr y))))))) 
     (return nil))))

(defun SPECCALC::equivPattern?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivPattern?-1-1 x1 x2)))

(defun SPECCALC::equivSort?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivSort?-1-1 x1 x2)))

(defun SPECCALC::equivSort?-1-1 (spc x) 
  (let ((s1 (car x))
        (s2 (cdr x))) 
    (block 
     nil 
     (if (eq (car s1) :|Arrow|) 
         (let ((pV76 (cdr s1))) 
           (if (eq (car s2) :|Arrow|) 
               (let ((pV121 (cdr s2))) 
                 (return 
                  (cl:and 
                   (SPECCALC::equivSort?-1-1 
                    spc 
                    (cons (svref pV76 0) (svref pV121 0))) 
                   (SPECCALC::equivSort?-1-1 
                    spc 
                    (cons (svref pV76 1) (svref pV121 1)))))))) 
         (if (eq (car s1) :|Product|) 
             (if (eq (car s2) :|Product|) 
                 (return 
                  (SPECCALC::equivList?-1-1 
                   spc 
                   (vector 
                    (car (cdr s1)) 
                    (car (cdr s2)) 
                    #'(lambda (spc) 
                       #'(lambda (x1) 
                          (let ((pV5 (car x1))
                                (pV6 (cdr x1))) 
                            (block 
                             nil 
                             (return 
                              (cl:and 
                               (string=  (car pV5) (car pV6)) 
                               (SPECCALC::equivSort?-1-1 
                                spc 
                                (cons (cdr pV5) (cdr pV6))))) 
                             (error "Nonexhaustive match failure in equivSort?"))))))))) 
             (if (eq (car s1) :|CoProduct|) 
                 (if (eq (car s2) :|CoProduct|) 
                     (return 
                      (SPECCALC::equivList?-1-1 
                       spc 
                       (vector 
                        (car (cdr s1)) 
                        (car (cdr s2)) 
                        #'(lambda (spc) 
                           #'(lambda (x1) 
                              (let ((pV13 (car x1))
                                    (pV14 (cdr x1))) 
                                (block 
                                 nil 
                                 (return 
                                  (cl:and 
                                   (string=  (car pV13) (car pV14)) 
                                   (SPECCALC::equivOpt?-1-1 
                                    spc 
                                    (vector 
                                     (cdr pV13) 
                                     (cdr pV14) 
                                     #'SPECCALC::equivSort?-1)))) 
                                 (error 
                                  "Nonexhaustive match failure in equivSort?"))))))))) 
                 (if (eq (car s1) :|Quotient|) 
                     (let ((pV73 (cdr s1))) 
                       (if (eq (car s2) :|Quotient|) 
                           (let ((pV104 (cdr s2))) 
                             (return 
                              (cl:and 
                               (SPECCALC::equivSort?-1-1 
                                spc 
                                (cons (svref pV73 0) (svref pV104 0))) 
                               (SPECCALC::equivTerm?-1-1 
                                spc 
                                (cons (svref pV73 1) (svref pV104 1)))))))) 
                     (if (eq (car s1) :|Subsort|) 
                         (let ((pV72 (cdr s1))) 
                           (if (eq (car s2) :|Subsort|) 
                               (let ((pV97 (cdr s2))) 
                                 (return 
                                  (cl:and 
                                   (SPECCALC::equivSort?-1-1 
                                    spc 
                                    (cons (svref pV72 0) (svref pV97 0))) 
                                   (SPECCALC::equivTerm?-1-1 
                                    spc 
                                    (cons (svref pV72 1) (svref pV97 1)))))))) 
                         (if (eq (car s1) :|Base|) 
                             (let ((pV71 (cdr s1))) 
                               (if (eq (car s2) :|Base|) 
                                   (let ((pV90 (cdr s2))) 
                                     (return 
                                      (cl:and 
                                       (slang-built-in::slang-term-equals 
                                        (STANDARDSPEC::findTheSort 
                                         spc 
                                         (svref pV71 0)) 
                                        (STANDARDSPEC::findTheSort 
                                         spc 
                                         (svref pV90 0))) 
                                       (SPECCALC::equivList?-1-1 
                                        spc 
                                        (vector 
                                         (svref pV71 1) 
                                         (svref pV90 1) 
                                         #'SPECCALC::equivSort?-1))))))) 
                             (if (eq (car s1) :|TyVar|) 
                                 (if (eq (car s2) :|TyVar|) 
                                     (return 
                                      (string=  (car (cdr s1)) (car (cdr s2))))) 
                                 (if (eq (car s1) :|MetaTyVar|) 
                                     (let ((pV77 (car (cdr s1)))) 
                                       (progn (if (eq (car s2) :|MetaTyVar|) 
                                                  (return 
                                                   (let ((pV41 
                                                          (STATE::|!!| pV77))) 
                                                     (block 
                                                      nil 
                                                      (let ((pV42 (svref pV41 0))) 
                                                        (return 
                                                         (let ((pV37 
                                                                (STATE::|!!| 
                                                                 (car (cdr s2))))) 
                                                           (block 
                                                            nil 
                                                            (let ((pV38 
                                                                   (svref pV37 0))) 
                                                              (return 
                                                               (cl:or 
                                                                ( =  
                                                                 (svref pV41 2) 
                                                                 (svref pV37 2)) 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car pV42) 
                                                                      :|Some|) 
                                                                     (let ((pV35 
                                                                            (cdr 
                                                                             pV42))) 
                                                                       (progn (if (eq 
                                                                                   (car 
                                                                                    pV38) 
                                                                                   :|Some|) 
                                                                                  (return 
                                                                                   (SPECCALC::equivSort?-1-1 
                                                                                    spc 
                                                                                    (cons 
                                                                                     pV35 
                                                                                     (cdr 
                                                                                      pV38))))) 
                                                                              (return 
                                                                               (SPECCALC::equivSort?-1-1 
                                                                                spc 
                                                                                (cons 
                                                                                 pV35 
                                                                                 s2)))))) 
                                                                 (if (eq 
                                                                      (car pV38) 
                                                                      :|Some|) 
                                                                     (return 
                                                                      (SPECCALC::equivSort?-1-1 
                                                                       spc 
                                                                       (cons 
                                                                        s1 
                                                                        (cdr 
                                                                         pV38))))) 
                                                                 (return nil))))) 
                                                            (error 
                                                             "Nonexhaustive match failure in equivSort?"))))) 
                                                      (error 
                                                       "Nonexhaustive match failure in equivSort?"))))) 
                                              (return 
                                               (let ((pV50 (STATE::|!!| pV77))) 
                                                 (block 
                                                  nil 
                                                  (let ((pV51 (svref pV50 0))) 
                                                    (return 
                                                     (block 
                                                      nil 
                                                      (if (eq (car pV51) :|Some|) 
                                                          (return 
                                                           (SPECCALC::equivSort?-1-1 
                                                            spc 
                                                            (cons (cdr pV51) s2)))) 
                                                      (return nil)))) 
                                                  (error 
                                                   "Nonexhaustive match failure in equivSort?")))))))))))))) 
     (if (eq (car s2) :|MetaTyVar|) 
         (return 
          (let ((pV59 (STATE::|!!| (car (cdr s2))))) 
            (block 
             nil 
             (let ((pV60 (svref pV59 0))) 
               (return 
                (block 
                 nil 
                 (if (eq (car pV60) :|Some|) 
                     (return (SPECCALC::equivSort?-1-1 spc (cons s1 (cdr pV60))))) 
                 (return nil)))) 
             (error "Nonexhaustive match failure in equivSort?"))))) 
     (return nil))))

(defun SPECCALC::equivVar?-1-1 (spc x) 
  (let ((pV1 (car x))
        (pV2 (cdr x))) 
    (block 
     nil 
     (return 
      (cl:and 
       (string=  (car pV1) (car pV2)) 
       (SPECCALC::equivSort?-1-1 spc (cons (cdr pV1) (cdr pV2))))) 
     (error "Nonexhaustive match failure in equivVar?"))))

(defun SPECCALC::equivPattern?-1-1 (spc x) 
  (let ((p1 (car x))
        (p2 (cdr x))) 
    (block 
     nil 
     (if (eq (car p1) :|AliasPat|) 
         (let ((pV45 (cdr p1))) 
           (if (eq (car p2) :|AliasPat|) 
               (let ((pV114 (cdr p2))) 
                 (return 
                  (cl:and 
                   (SPECCALC::equivPattern?-1-1 
                    spc 
                    (cons (svref pV45 0) (svref pV114 0))) 
                   (SPECCALC::equivPattern?-1-1 
                    spc 
                    (cons (svref pV45 1) (svref pV114 1)))))))) 
         (if (eq (car p1) :|VarPat|) 
             (if (eq (car p2) :|VarPat|) 
                 (return 
                  (SPECCALC::equivVar?-1-1 
                   spc 
                   (cons (car (cdr p1)) (car (cdr p2)))))) 
             (if (eq (car p1) :|EmbedPat|) 
                 (let ((pV43 (cdr p1))) 
                   (if (eq (car p2) :|EmbedPat|) 
                       (let ((pV101 (cdr p2))) 
                         (return 
                          (cl:and 
                           (string=  (svref pV43 0) (svref pV101 0)) 
                           (cl:and 
                            (SPECCALC::equivSort?-1-1 
                             spc 
                             (cons (svref pV43 2) (svref pV101 2))) 
                            (SPECCALC::equivOpt?-1-1 
                             spc 
                             (vector 
                              (svref pV43 1) 
                              (svref pV101 1) 
                              #'SPECCALC::equivPattern?-1)))))))) 
                 (if (eq (car p1) :|RecordPat|) 
                     (if (eq (car p2) :|RecordPat|) 
                         (return 
                          (SPECCALC::equivList?-1-1 
                           spc 
                           (vector 
                            (car (cdr p1)) 
                            (car (cdr p2)) 
                            #'(lambda (spc) 
                               #'(lambda (x1) 
                                  (let ((pV9 (car x1))
                                        (pV10 (cdr x1))) 
                                    (block 
                                     nil 
                                     (return 
                                      (cl:and 
                                       (string=  (car pV9) (car pV10)) 
                                       (SPECCALC::equivPattern?-1-1 
                                        spc 
                                        (cons (cdr pV9) (cdr pV10))))) 
                                     (error 
                                      "Nonexhaustive match failure in equivPattern?"))))))))) 
                     (if (eq (car p1) :|WildPat|) 
                         (if (eq (car p2) :|WildPat|) 
                             (return 
                              (SPECCALC::equivSort?-1-1 
                               spc 
                               (cons (car (cdr p1)) (car (cdr p2)))))) 
                         (if (eq (car p1) :|StringPat|) 
                             (if (eq (car p2) :|StringPat|) 
                                 (return 
                                  (string=  (car (cdr p1)) (car (cdr p2))))) 
                             (if (eq (car p1) :|BoolPat|) 
                                 (if (eq (car p2) :|BoolPat|) 
                                     (return (eq (car (cdr p1)) (car (cdr p2))))) 
                                 (if (eq (car p1) :|CharPat|) 
                                     (if (eq (car p2) :|CharPat|) 
                                         (return 
                                          (eq (car (cdr p1)) (car (cdr p2))))) 
                                     (if (eq (car p1) :|NatPat|) 
                                         (if (eq (car p2) :|NatPat|) 
                                             (return 
                                              ( =  (car (cdr p1)) (car (cdr p2))))) 
                                         (if (eq (car p1) :|RelaxPat|) 
                                             (let ((pV36 (cdr p1))) 
                                               (if (eq (car p2) :|RelaxPat|) 
                                                   (let ((pV63 (cdr p2))) 
                                                     (return 
                                                      (cl:and 
                                                       (SPECCALC::equivPattern?-1-1 
                                                        spc 
                                                        (cons 
                                                         (svref pV36 0) 
                                                         (svref pV63 0))) 
                                                       (SPECCALC::equivTerm?-1-1 
                                                        spc 
                                                        (cons 
                                                         (svref pV36 1) 
                                                         (svref pV63 1)))))))) 
                                             (if (eq (car p1) :|QuotientPat|) 
                                                 (let ((pV35 (cdr p1))) 
                                                   (if (eq 
                                                        (car p2) 
                                                        :|QuotientPat|) 
                                                       (let ((pV56 (cdr p2))) 
                                                         (return 
                                                          (cl:and 
                                                           (SPECCALC::equivPattern?-1-1 
                                                            spc 
                                                            (cons 
                                                             (svref pV35 0) 
                                                             (svref pV56 0))) 
                                                           (SPECCALC::equivTerm?-1-1 
                                                            spc 
                                                            (cons 
                                                             (svref pV35 1) 
                                                             (svref pV56 1)))))))) 
                                                 (if (eq (car p1) :|SortedPat|) 
                                                     (let ((pV34 (cdr p1))) 
                                                       (if (eq 
                                                            (car p2) 
                                                            :|SortedPat|) 
                                                           (let ((pV49 (cdr p2))) 
                                                             (return 
                                                              (cl:and 
                                                               (SPECCALC::equivPattern?-1-1 
                                                                spc 
                                                                (cons 
                                                                 (svref pV34 0) 
                                                                 (svref pV49 0))) 
                                                               (SPECCALC::equivSort?-1-1 
                                                                spc 
                                                                (cons 
                                                                 (svref pV34 1) 
                                                                 (svref pV49 1)))))))))))))))))))) 
     (return nil))))

(defun SPECCALC::equivTerm?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivTerm?-1-1 x1 x2)))

(defun SPECCALC::equivVar?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivVar?-1-1 x1 x2)))

(defun SPECCALC::equivTerm?-1-1 (spc x) 
  (let ((t1 (car x))
        (t2 (cdr x))) 
    (block 
     nil 
     (if (eq (car t1) :|Apply|) 
         (let ((pV65 (cdr t1))) 
           (if (eq (car t2) :|Apply|) 
               (let ((pV140 (cdr t2))) 
                 (return 
                  (cl:and 
                   (SPECCALC::equivTerm?-1-1 
                    spc 
                    (cons (svref pV65 0) (svref pV140 0))) 
                   (SPECCALC::equivTerm?-1-1 
                    spc 
                    (cons (svref pV65 1) (svref pV140 1)))))))) 
         (if (eq (car t1) :|ApplyN|) 
             (if (eq (car t2) :|ApplyN|) 
                 (return 
                  (SPECCALC::equivList?-1-1 
                   spc 
                   (vector 
                    (car (cdr t1)) 
                    (car (cdr t2)) 
                    #'SPECCALC::equivTerm?-1)))) 
             (if (eq (car t1) :|Record|) 
                 (if (eq (car t2) :|Record|) 
                     (return 
                      (SPECCALC::equivList?-1-1 
                       spc 
                       (vector 
                        (car (cdr t1)) 
                        (car (cdr t2)) 
                        #'(lambda (spc) 
                           #'(lambda (x1) 
                              (let ((pV7 (car x1))
                                    (pV8 (cdr x1))) 
                                (block 
                                 nil 
                                 (return 
                                  (cl:and 
                                   (string=  (car pV7) (car pV8)) 
                                   (SPECCALC::equivTerm?-1-1 
                                    spc 
                                    (cons (cdr pV7) (cdr pV8))))) 
                                 (error 
                                  "Nonexhaustive match failure in equivTerm?"))))))))) 
                 (if (eq (car t1) :|Bind|) 
                     (let ((pV62 (cdr t1))) 
                       (if (eq (car t2) :|Bind|) 
                           (let ((pV122 (cdr t2))) 
                             (return 
                              (cl:and 
                               (slang-built-in::slang-term-equals 
                                (svref pV62 0) 
                                (svref pV122 0)) 
                               (cl:and 
                                (SPECCALC::equivList?-1-1 
                                 spc 
                                 (vector 
                                  (svref pV62 1) 
                                  (svref pV122 1) 
                                  #'SPECCALC::equivVar?-1)) 
                                (SPECCALC::equivTerm?-1-1 
                                 spc 
                                 (cons (svref pV62 2) (svref pV122 2))))))))) 
                     (if (eq (car t1) :|Let|) 
                         (let ((pV61 (cdr t1))) 
                           (if (eq (car t2) :|Let|) 
                               (let ((pV114 (cdr t2))) 
                                 (return 
                                  (cl:and 
                                   (SPECCALC::equivTerm?-1-1 
                                    spc 
                                    (cons (svref pV61 1) (svref pV114 1))) 
                                   (SPECCALC::equivList?-1-1 
                                    spc 
                                    (vector 
                                     (svref pV61 0) 
                                     (svref pV114 0) 
                                     #'(lambda (spc) 
                                        #'(lambda (x1) 
                                           (let ((pV17 (car x1))
                                                 (pV18 (cdr x1))) 
                                             (block 
                                              nil 
                                              (return 
                                               (cl:and 
                                                (SPECCALC::equivPattern?-1-1 
                                                 spc 
                                                 (cons (car pV17) (car pV18))) 
                                                (SPECCALC::equivTerm?-1-1 
                                                 spc 
                                                 (cons (cdr pV17) (cdr pV18))))) 
                                              (error 
                                               "Nonexhaustive match failure in equivTerm?")))))))))))) 
                         (if (eq (car t1) :|LetRec|) 
                             (let ((pV60 (cdr t1))) 
                               (if (eq (car t2) :|LetRec|) 
                                   (let ((pV107 (cdr t2))) 
                                     (return 
                                      (cl:and 
                                       (SPECCALC::equivTerm?-1-1 
                                        spc 
                                        (cons (svref pV60 1) (svref pV107 1))) 
                                       (SPECCALC::equivList?-1-1 
                                        spc 
                                        (vector 
                                         (svref pV60 0) 
                                         (svref pV107 0) 
                                         #'(lambda (spc) 
                                            #'(lambda (x1) 
                                               (let ((pV25 (car x1))
                                                     (pV26 (cdr x1))) 
                                                 (block 
                                                  nil 
                                                  (return 
                                                   (cl:and 
                                                    (SPECCALC::equivVar?-1-1 
                                                     spc 
                                                     (cons (car pV25) (car pV26))) 
                                                    (SPECCALC::equivTerm?-1-1 
                                                     spc 
                                                     (cons (cdr pV25) (cdr pV26))))) 
                                                  (error 
                                                   "Nonexhaustive match failure in equivTerm?")))))))))))) 
                             (if (eq (car t1) :|Var|) 
                                 (if (eq (car t2) :|Var|) 
                                     (return 
                                      (SPECCALC::equivVar?-1-1 
                                       spc 
                                       (cons (car (cdr t1)) (car (cdr t2)))))) 
                                 (if (eq (car t1) :|Fun|) 
                                     (let ((pV58 (cdr t1))) 
                                       (if (eq (car t2) :|Fun|) 
                                           (let ((pV95 (cdr t2))) 
                                             (return 
                                              (cl:and 
                                               (SPECCALC::equivFun?-1-1 
                                                spc 
                                                (cons 
                                                 (svref pV58 0) 
                                                 (svref pV95 0))) 
                                               (SPECCALC::equivSort?-1-1 
                                                spc 
                                                (cons 
                                                 (svref pV58 1) 
                                                 (svref pV95 1)))))))) 
                                     (if (eq (car t1) :|Lambda|) 
                                         (if (eq (car t2) :|Lambda|) 
                                             (return 
                                              (SPECCALC::equivList?-1-1 
                                               spc 
                                               (vector 
                                                (car (cdr t1)) 
                                                (car (cdr t2)) 
                                                #'(lambda (spc) 
                                                   #'(lambda (x1) 
                                                      (let ((pV37 (car x1))
                                                            (pV38 (cdr x1))) 
                                                        (block 
                                                         nil 
                                                         (return 
                                                          (cl:and 
                                                           (SPECCALC::equivPattern?-1-1 
                                                            spc 
                                                            (cons 
                                                             (svref pV37 0) 
                                                             (svref pV38 0))) 
                                                           (cl:and 
                                                            (SPECCALC::equivTerm?-1-1 
                                                             spc 
                                                             (cons 
                                                              (svref pV37 1) 
                                                              (svref pV38 1))) 
                                                            (SPECCALC::equivTerm?-1-1 
                                                             spc 
                                                             (cons 
                                                              (svref pV37 2) 
                                                              (svref pV38 2)))))) 
                                                         (error 
                                                          "Nonexhaustive match failure in equivTerm?"))))))))) 
                                         (if (eq (car t1) :|IfThenElse|) 
                                             (let ((pV56 (cdr t1))) 
                                               (if (eq (car t2) :|IfThenElse|) 
                                                   (let ((pV82 (cdr t2))) 
                                                     (return 
                                                      (cl:and 
                                                       (SPECCALC::equivTerm?-1-1 
                                                        spc 
                                                        (cons 
                                                         (svref pV56 0) 
                                                         (svref pV82 0))) 
                                                       (cl:and 
                                                        (SPECCALC::equivTerm?-1-1 
                                                         spc 
                                                         (cons 
                                                          (svref pV56 1) 
                                                          (svref pV82 1))) 
                                                        (SPECCALC::equivTerm?-1-1 
                                                         spc 
                                                         (cons 
                                                          (svref pV56 2) 
                                                          (svref pV82 2))))))))) 
                                             (if (eq (car t1) :|Seq|) 
                                                 (if (eq (car t2) :|Seq|) 
                                                     (return 
                                                      (SPECCALC::equivList?-1-1 
                                                       spc 
                                                       (vector 
                                                        (car (cdr t1)) 
                                                        (car (cdr t2)) 
                                                        #'SPECCALC::equivTerm?-1)))) 
                                                 (if (eq (car t1) :|SortedTerm|) 
                                                     (let ((pV54 (cdr t1))) 
                                                       (if (eq 
                                                            (car t2) 
                                                            :|SortedTerm|) 
                                                           (let ((pV69 (cdr t2))) 
                                                             (return 
                                                              (cl:and 
                                                               (SPECCALC::equivTerm?-1-1 
                                                                spc 
                                                                (cons 
                                                                 (svref pV54 0) 
                                                                 (svref pV69 0))) 
                                                               (SPECCALC::equivSort?-1-1 
                                                                spc 
                                                                (cons 
                                                                 (svref pV54 1) 
                                                                 (svref pV69 1)))))))))))))))))))) 
     (return nil))))

(defun SPECCALC::equivTermScheme?-1-1 (spc x) 
  (let ((pV1 (car x))
        (pV2 (cdr x))) 
    (block 
     nil 
     (return 
      (cl:and 
       (slang-built-in::slang-term-equals (car pV1) (car pV2)) 
       (SPECCALC::equivTerm?-1-1 spc (cons (cdr pV1) (cdr pV2))))) 
     (error "Nonexhaustive match failure in equivTermScheme?"))))

(defun SPECCALC::compressOpDefs-1-1 (spc info) 
  (let ((old_defs (svref info 3))) 
    (block 
     nil 
     (if (null old_defs) 
         (return info) 
         (if (consp old_defs) (if (null (cdr old_defs)) (return info)))) 
     (return 
      (let ((distinct_defs 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x1) 
                 (let ((old_def (car x1))
                       (distinct_defs (cdr x1))) 
                   (if (LIST-SPEC::|!exists|-1-1 
                        #'(lambda (distinct_def) 
                           (SPECCALC::equivTermScheme?-1-1 
                            spc 
                            (cons old_def distinct_def))) 
                        distinct_defs) 
                       distinct_defs 
                       (LIST-SPEC::|!cons| old_def distinct_defs)))) 
              nil 
              old_defs))) 
        (vector (svref info 0) (svref info 1) (svref info 2) distinct_defs))))))

(defun SPECCALC::equivSortScheme?-1-1 (spc x) 
  (let ((pV1 (car x))
        (pV2 (cdr x))) 
    (block 
     nil 
     (return 
      (cl:and 
       (slang-built-in::slang-term-equals (car pV1) (car pV2)) 
       (SPECCALC::equivSort?-1-1 spc (cons (cdr pV1) (cdr pV2))))) 
     (error "Nonexhaustive match failure in equivSortScheme?"))))

(defun STANDARDSPEC::mkTyVar (name) 
  (cons :|TyVar| (cons name POSITION-SPEC::noPos)))

(defun SPECCALC::compressSortDefs-1-1 (spc info) 
  (let ((names (svref info 0))
        (|!tyVars| (svref info 1))
        (old_defs (svref info 2))) 
    (block 
     nil 
     (if (null old_defs) 
         (return info) 
         (if (consp old_defs) (if (null (cdr old_defs)) (return info)))) 
     (return 
      (let ((tyVarsSorts 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x) 
                 (LIST-SPEC::|!cons| (STANDARDSPEC::mkTyVar (car x)) (cdr x))) 
              nil 
              |!tyVars|))) 
        (let ((new_sorts 
               (LIST-SPEC::foldl-1-1-1 
                #'(lambda (x) 
                   (LIST-SPEC::|!cons| 
                    (STANDARDSPEC::mkBase (car x) tyVarsSorts) 
                    (cdr x))) 
                nil 
                names))) 
          (let ((new_sort_schemas 
                 (LIST-SPEC::foldl-1-1-1 
                  #'(lambda (x) 
                     (LIST-SPEC::|!cons| (cons |!tyVars| (car x)) (cdr x))) 
                  nil 
                  new_sorts))) 
            (let ((distinct_defs 
                   (LIST-SPEC::foldl-1-1-1 
                    #'(lambda (x) 
                       (let ((old_def (car x))
                             (distinct_defs (cdr x))) 
                         (if (cl:or 
                              (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (new_sort_scheme) 
                                  (SPECCALC::equivSortScheme?-1-1 
                                   spc 
                                   (cons old_def new_sort_scheme))) 
                               new_sort_schemas) 
                              (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (distinct_def) 
                                  (SPECCALC::equivSortScheme?-1-1 
                                   spc 
                                   (cons old_def distinct_def))) 
                               distinct_defs)) 
                             distinct_defs 
                             (LIST-SPEC::|!cons| old_def distinct_defs)))) 
                    nil 
                    old_defs))) (vector names |!tyVars| distinct_defs)))))))))

(defun SPECCALC::compressDefs-1 (spc) 
  (let ((new_sorts 
         (foldriAQualifierMap-1-1-1 
          #'(lambda (x) 
             (let ((revised_sorts (svref x 3))
                   (old_info (svref x 2))) 
               (let ((new_info (SPECCALC::compressSortDefs-1-1 spc old_info))) 
                 (if (slang-built-in::slang-term-equals new_info old_info) 
                     revised_sorts 
                     (insertAQualifierMap 
                      revised_sorts 
                      (svref x 0) 
                      (svref x 1) 
                      new_info))))) 
          (svref spc 3) 
          (svref spc 3)))) 
    (let ((new_ops 
           (foldriAQualifierMap-1-1-1 
            #'(lambda (x) 
               (let ((revised_ops (svref x 3))
                     (old_info (svref x 2))) 
                 (let ((new_info (SPECCALC::compressOpDefs-1-1 spc old_info))) 
                   (if (slang-built-in::slang-term-equals new_info old_info) 
                       revised_ops 
                       (insertAQualifierMap 
                        revised_ops 
                        (svref x 0) 
                        (svref x 1) 
                        new_info))))) 
            (svref spc 1) 
            (svref spc 1)))) 
      (vector (svref spc 0) new_ops (svref spc 2) new_sorts))))

(defun SPECUNION::importsUnion (specs) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) (LISTUTILITIES::listUnion (svref (svref (car x) 0) 1) (cdr x))) 
   nil 
   specs))

(defun SPECUNION::unionOpMaps (old_op_map) 
  #'(lambda (new_op_map) 
     (labels 
       ((augmentOpMap (new_qualifier new_id new_info merged_op_map) 
         (let ((pV5 (LIST-SPEC::hd (svref new_info 0)))) 
           (block 
            nil 
            (if (eq (car pV5) :|Qualified|) 
                (let ((pV6 (cdr pV5))) 
                  (return 
                   (if (cl:and 
                        (string=  new_qualifier (car pV6)) 
                        (string=  new_id (cdr pV6))) 
                       (let ((optional_old_info 
                              (findAQualifierMap 
                               merged_op_map 
                               new_qualifier 
                               new_id))) 
                         (SPECCALC::monadBind 
                          (funcall (funcall (SPECCALC::mergeOpInfo-1 new_info) 
                                            optional_old_info) 
                                   POSITION-SPEC::noPos) 
                          #'(lambda (merged_info) 
                             (SPECCALC::monadBind 
                              (SPECCALC::|!return| (svref merged_info 0)) 
                              #'(lambda (all_names) 
                                 (funcall (funcall (SPECCALC::foldM 
                                                    #'(lambda (merged_op_map) 
                                                       #'(lambda (pV1) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car pV1) 
                                                                :|Qualified|) 
                                                               (let ((pV2 
                                                                      (cdr pV1))) 
                                                                 (return 
                                                                  (SPECCALC::|!return| 
                                                                   (insertAQualifierMap 
                                                                    merged_op_map 
                                                                    (car pV2) 
                                                                    (cdr pV2) 
                                                                    merged_info))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in unionOpMaps"))))) 
                                                   merged_op_map) 
                                          all_names)))))) 
                       (SPECCALC::|!return| merged_op_map))))) 
            (error "Nonexhaustive match failure in unionOpMaps"))))) 
       (funcall (funcall (SPECCALC::foldOverQualifierMap 
                          #'(lambda (x) 
                             (augmentOpMap 
                              (svref x 0) 
                              (svref x 1) 
                              (svref x 2) 
                              (svref x 3)))) 
                         old_op_map) 
                new_op_map))))

(defparameter STANDARDSPEC::emptyOpMap emptyASortMap)

(defun SPECUNION::opsUnion (specs) 
  (funcall (funcall (SPECCALC::foldM #'SPECUNION::unionOpMaps) 
                    STANDARDSPEC::emptyOpMap) 
           (LIST-SPEC::foldl-1-1-1 
            #'(lambda (x) (LIST-SPEC::|!cons| (svref (car x) 1) (cdr x))) 
            nil 
            specs)))

(defun SPECUNION::propertiesUnion (specs) 
  (SPECCALC::|!return| 
   (LIST-SPEC::foldl-1-1-1 
    #'(lambda (x) (LISTUTILITIES::listUnion (svref (car x) 2) (cdr x))) 
    nil 
    specs)))

(defun SPECUNION::unionSortMaps (old_sort_map) 
  #'(lambda (new_sort_map) 
     (labels 
       ((augmentSortMap (new_qualifier new_id new_info merged_sort_map) 
         (let ((pV5 (LIST-SPEC::hd (svref new_info 0)))) 
           (block 
            nil 
            (if (eq (car pV5) :|Qualified|) 
                (let ((pV6 (cdr pV5))) 
                  (return 
                   (if (cl:and 
                        (string=  new_qualifier (car pV6)) 
                        (string=  new_id (cdr pV6))) 
                       (let ((optional_old_info 
                              (findAQualifierMap 
                               merged_sort_map 
                               new_qualifier 
                               new_id))) 
                         (SPECCALC::monadBind 
                          (funcall (funcall (SPECCALC::mergeSortInfo-1 new_info) 
                                            optional_old_info) 
                                   POSITION-SPEC::noPos) 
                          #'(lambda (merged_info) 
                             (SPECCALC::monadBind 
                              (SPECCALC::|!return| (svref merged_info 0)) 
                              #'(lambda (all_names) 
                                 (funcall (funcall (SPECCALC::foldM 
                                                    #'(lambda (merged_sort_map) 
                                                       #'(lambda (pV1) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car pV1) 
                                                                :|Qualified|) 
                                                               (let ((pV2 
                                                                      (cdr pV1))) 
                                                                 (return 
                                                                  (SPECCALC::|!return| 
                                                                   (insertAQualifierMap 
                                                                    merged_sort_map 
                                                                    (car pV2) 
                                                                    (cdr pV2) 
                                                                    merged_info))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in unionSortMaps"))))) 
                                                   merged_sort_map) 
                                          all_names)))))) 
                       (SPECCALC::|!return| merged_sort_map))))) 
            (error "Nonexhaustive match failure in unionSortMaps"))))) 
       (funcall (funcall (SPECCALC::foldOverQualifierMap 
                          #'(lambda (x) 
                             (augmentSortMap 
                              (svref x 0) 
                              (svref x 1) 
                              (svref x 2) 
                              (svref x 3)))) 
                         old_sort_map) 
                new_sort_map))))

(defparameter STANDARDSPEC::emptySortMap emptyASortMap)

(defun SPECUNION::sortsUnion (specs) 
  (funcall (funcall (SPECCALC::foldM #'SPECUNION::unionSortMaps) 
                    STANDARDSPEC::emptySortMap) 
           (LIST-SPEC::foldl-1-1-1 
            #'(lambda (x) (LIST-SPEC::|!cons| (svref (car x) 3) (cdr x))) 
            nil 
            specs)))

(defun SPECUNION::specUnion (specs) 
  (let ((merged_imports (SPECUNION::importsUnion specs))) 
    (SPECCALC::monadBind 
     (SPECUNION::sortsUnion specs) 
     #'(lambda (merged_sorts) 
        (SPECCALC::monadBind 
         (SPECUNION::opsUnion specs) 
         #'(lambda (merged_ops) 
            (SPECCALC::monadBind 
             (SPECUNION::propertiesUnion specs) 
             #'(lambda (merged_props) 
                (SPECCALC::monadBind 
                 (SPECCALC::|!return| 
                  (vector 
                   (vector '(:|None|) merged_imports emptyOpNames emptySortNames) 
                   merged_ops 
                   merged_props 
                   merged_sorts)) 
                 #'(lambda (merged_spec) 
                    (SPECCALC::|!return| (SPECCALC::compressDefs-1 merged_spec))))))))))))


(defun SPECCALC::applySubstitution-1 (sm) 
  #'(lambda (spc) 
     #'(lambda (sm_tm) 
        #'(lambda (|!position|) 
           (let ((dom_spec (SPECCALC::dom-1 sm))) 
             (let ((cod_spec (SPECCALC::cod-1 sm))) 
               (let ((residue (subtractSpec-1-1 spc dom_spec))) 
                 (SPECCALC::monadBind 
                  (funcall (funcall (SPECCALC::applyMorphism-1 sm) residue) 
                           |!position|) 
                  #'(lambda (translated_residue) 
                     (SPECCALC::monadBind 
                      (SPECUNION::specUnion 
                       (cons translated_residue (cons cod_spec nil))) 
                      #'(lambda (new_spec) 
                         (SPECCALC::monadBind 
                          (SPECCALC::|!return| 
                           (let ((pV5 (car sm_tm))) 
                             (block 
                              nil 
                              (if (eq (car pV5) :|SpecMorph|) 
                                  (return 
                                   (SPECCALC::showTerm-1 (svref (cdr pV5) 1)))) 
                              (return 
                               (let ((sm_desc (SPECCALC::showTerm-1 sm_tm))) 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    sm_desc 
                                    " (* effect is to import codomain of ") 
                                   sm_desc) 
                                  " *) ")))))) 
                          #'(lambda (spec_ref) 
                             (SPECCALC::|!return| 
                              (setImportInfo 
                               new_spec 
                               (vector 
                                (cons 
                                 :|Some| 
                                 (vector 
                                  (svref cod_spec 0) 
                                  (svref cod_spec 1) 
                                  (svref cod_spec 2) 
                                  (svref cod_spec 3))) 
                                (cons (cons spec_ref cod_spec) nil) 
                                emptyOpNames 
                                emptySortNames))))))))))))))))

(defun SPECCALC::applySubstitution (x0 x1 x2 x3) 
  (SPECCALC::applySubstitution-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::applySubstitution-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::applySubstitution-1 x1) x2) x3) 
                    x4) 
           x5))

(defparameter SPECCALC::declare_function 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-FUNCTION-SYMBOL"))

(defparameter SPECCALC::arithmeticFunctions 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_function 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "+")) 
      (cons 
       (LISP-SPEC::|!nat| 2) 
       (cons 
        (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
        (cons 
         (LISP-SPEC::bool t) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
          (cons (LISP-SPEC::bool t) nil)))))))) 
   (cons 
    (LISP-SPEC::|!list| 
     (cons 
      SPECCALC::declare_function 
      (cons 
       (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "*")) 
       (cons 
        (LISP-SPEC::|!nat| 2) 
        (cons 
         (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
         (cons 
          (LISP-SPEC::bool t) 
          (cons 
           (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
           (cons (LISP-SPEC::bool t) nil)))))))) 
    nil)))

(defparameter SPECCALC::declare_sort 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-SORT"))

(defparameter SPECCALC::declare_subsorts 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-SUBSORTS"))

(defparameter SPECCALC::arithmeticSorts 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_sort 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Integer")) 
      (cons 
       (LISP-SPEC::|!symbol| "KEYWORD" "IFF") 
       (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "INTEGER")) nil))))) 
   (cons 
    (LISP-SPEC::|!list| 
     (cons 
      SPECCALC::declare_sort 
      (cons 
       (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Nat")) 
       (cons 
        (LISP-SPEC::|!symbol| "KEYWORD" "IFF") 
        (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "NATURAL")) nil))))) 
    (cons 
     (LISP-SPEC::|!list| 
      (cons 
       SPECCALC::declare_sort 
       (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "PosNat")) nil))) 
     (cons 
      (LISP-SPEC::|!list| 
       (cons 
        SPECCALC::declare_sort 
        (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "LOGICAL")) nil))) 
      (cons 
       (LISP-SPEC::|!list| 
        (cons 
         SPECCALC::declare_sort 
         (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Char")) nil))) 
       (cons 
        (LISP-SPEC::|!list| 
         (cons 
          SPECCALC::declare_sort 
          (cons 
           (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "String")) 
           nil))) 
        (cons 
         (LISP-SPEC::|!list| 
          (cons 
           SPECCALC::declare_subsorts 
           (cons 
            (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Integer")) 
            (cons 
             (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Nat")) 
             (cons 
              (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "PosNat")) 
              nil))))) 
         (cons 
          (LISP-SPEC::|!list| 
           (cons 
            SPECCALC::declare_subsorts 
            (cons 
             (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Nat")) 
             (cons 
              (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "PosNat")) 
              nil)))) 
          nil)))))))))

(defun SPECCALC::printNamesInAQualifierMap (qmap) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((str (svref x 3))) 
        (let ((qid (METASLANG::printQualifierDotId (svref x 0) (svref x 1)))) 
          (if (string=  str "") 
              qid 
              (STRING-SPEC::^ (STRING-SPEC::^ str ", ") qid))))) 
   "" 
   qmap))

(defun SPECCALC::warnAboutMissingItems-1 (should_be_empty_spec) 
  (let ((sorts_msg 
         (SPECCALC::printNamesInAQualifierMap (svref should_be_empty_spec 3)))) 
    (let ((ops_msg 
           (SPECCALC::printNamesInAQualifierMap (svref should_be_empty_spec 1)))) 
      (let ((props_msg 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x) 
                 (let ((pV5 (cdr x))) 
                   (block 
                    nil 
                    (let ((pV7 (svref (car x) 1))) 
                      (return 
                       (if (string=  pV5 "") 
                           pV7 
                           (STRING-SPEC::^ (STRING-SPEC::^ pV5 ", ") pV7)))) 
                    (error 
                     "Nonexhaustive match failure in warnAboutMissingItems")))) 
              "" 
              (svref should_be_empty_spec 2)))) 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ 
            "
" 
            (if (string=  sorts_msg "") 
                "" 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  "  These sorts from the domain of the morphism are not in the source spec: " 
                  sorts_msg) 
                 "
"))) 
           (if (string=  ops_msg "") 
               "" 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 "  These ops from the domain of the morphism are not in the source spec: " 
                 ops_msg) 
                "
"))) 
          (if (string=  props_msg "") 
              "" 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                "  These axioms, etc. from the domain of the morphism are not in the source spec: " 
                props_msg) 
               "
"))) 
         "  in substitution term")))))

(defun SPECCALC::|!when| (p) 
  #'(lambda (command) 
     (if p #'(lambda (s) (funcall command s)) (SPECCALC::|!return| nil))))

(defparameter STANDARDSPEC::emptyProperties emptyAProperties)

(defun SPECCALC::attemptSubstitution-1 (original_spec) 
  #'(lambda (sm) 
     #'(lambda (sm_tm) 
        #'(lambda (term_pos) 
           (let ((sub_spec (SPECCALC::dom-1 sm))) 
             (let ((should_be_empty_spec 
                    (subtractSpec-1-1 sub_spec original_spec))) 
               (SPECCALC::monadSeq 
                (funcall (SPECCALC::|!when| 
                          (cl:or 
                           (BOOLEAN-SPEC::~ 
                            (slang-built-in::slang-term-equals 
                             (svref should_be_empty_spec 3) 
                             emptyASortMap)) 
                           (cl:or 
                            (BOOLEAN-SPEC::~ 
                             (slang-built-in::slang-term-equals 
                              (svref should_be_empty_spec 1) 
                              emptyAOpMap)) 
                            (BOOLEAN-SPEC::~ 
                             (slang-built-in::slang-term-equals 
                              (svref should_be_empty_spec 2) 
                              STANDARDSPEC::emptyProperties))))) 
                         (SPECCALC::raise 
                          (cons 
                           :|TypeCheck| 
                           (cons 
                            term_pos 
                            (SPECCALC::warnAboutMissingItems-1 
                             should_be_empty_spec))))) 
                (funcall (funcall (funcall (SPECCALC::applySubstitution-1 sm) 
                                           original_spec) 
                                  sm_tm) 
                         term_pos))))))))

(defun SPECCALC::attemptSubstitution (x0 x1 x2 x3) 
  (SPECCALC::attemptSubstitution-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::attemptSubstitution-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::attemptSubstitution-1 x1) x2) 
                             x3) 
                    x4) 
           x5))

(defun SPECCALC::auxTranslateSpec (x0 x1 x2 x3) 
  (SPECCALC::auxTranslateSpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::auxTranslateSpec-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::auxTranslateSpec-1 x1) x2) x3) x4))

(defun SPECCALC::patternNameOpt (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) 
       (return (cons :|Some| (car (car (cdr pattern)))))) 
   (return '(:|None|))))

(defun SPECCALC::patternNamesOpt (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) 
       (return (cons :|Some| (cons (car (car (cdr pattern))) nil))) 
       (if (eq (car pattern) :|RecordPat|) 
           (return 
            (LIST-SPEC::foldl-1-1-1 
             #'(lambda (x) 
                (let ((pV12 (cdr x))) 
                  (block 
                   nil 
                   (return 
                    (block 
                     nil 
                     (if (eq (car pV12) :|Some|) 
                         (return 
                          (let ((pV6 (SPECCALC::patternNameOpt (cdr (car x))))) 
                            (block 
                             nil 
                             (if (eq (car pV6) :|Some|) 
                                 (return 
                                  (cons 
                                   :|Some| 
                                   (LIST-SPEC::|!++| 
                                    (cdr pV12) 
                                    (cons (cdr pV6) nil))))) 
                             (return '(:|None|)))))) 
                     (return '(:|None|)))) 
                   (error "Nonexhaustive match failure in patternNamesOpt")))) 
             (cons :|Some| nil) 
             (car (cdr pattern)))))) 
   (return '(:|None|))))

(defun SPECCALC::mkUncurryEqualityRec
 (sp topSrt topTrm topFunOp srt trm prevArgs) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV34 (cdr srt))) 
         (let ((pV35 (svref pV34 0))) 
           (return 
            (block 
             nil 
             (if (eq (car trm) :|Lambda|) 
                 (let ((pV12 (car (cdr trm)))) 
                   (if (consp pV12) 
                       (let ((pV15 (car pV12))) 
                         (if (null (cdr pV12)) 
                             (return 
                              (let ((argNames 
                                     (SPECCALC::patternNamesOpt (svref pV15 0)))) 
                                (block 
                                 nil 
                                 (if (eq (car argNames) :|Some|) 
                                     (let ((pV8 (cdr argNames))) 
                                       (return 
                                        (let ((numargs 
                                               (LIST-SPEC::|!length| pV8))) 
                                          (let ((argSorts 
                                                 (let ((pV4 
                                                        (SPECENVIRONMENT::productOpt 
                                                         sp 
                                                         pV35))) 
                                                   (block 
                                                    nil 
                                                    (if (eq (car pV4) :|Some|) 
                                                        (return 
                                                         (LIST-SPEC::|!map|-1-1 
                                                          #'(lambda (x) (cdr x)) 
                                                          (cdr pV4))) 
                                                        (if (eq 
                                                             (car pV4) 
                                                             :|None|) 
                                                            (return 
                                                             (cons pV35 nil)))) 
                                                    (error 
                                                     "Nonexhaustive match failure in mkUncurryEqualityRec"))))) 
                                            (let ((arity 
                                                   (LIST-SPEC::|!length| 
                                                    argSorts))) 
                                              (if ( =  arity numargs) 
                                                  (let ((newArgs 
                                                         (LISTPAIR::|!map|-1-1 
                                                          #'(lambda (x) 
                                                             (STANDARDSPEC::mkVar 
                                                              (car x) 
                                                              (cdr x))) 
                                                          (cons pV8 argSorts)))) 
                                                    (SPECCALC::mkUncurryEqualityRec 
                                                     sp 
                                                     topSrt 
                                                     topTrm 
                                                     topFunOp 
                                                     (svref pV34 1) 
                                                     (svref pV15 2) 
                                                     (LIST-SPEC::|!++| 
                                                      prevArgs 
                                                      newArgs))) 
                                                  (STANDARDSPEC::mkEquality 
                                                   topSrt 
                                                   topFunOp 
                                                   topTrm)))))))) 
                                 (return 
                                  (STANDARDSPEC::mkEquality 
                                   topSrt 
                                   topFunOp 
                                   topTrm)))))))))) 
             (return (STANDARDSPEC::mkEquality topSrt topFunOp topTrm))))))) 
   (return 
    (block 
     nil 
     (if (eq (car trm) :|Lambda|) 
         (let ((pV25 (car (cdr trm)))) 
           (if (consp pV25) 
               (if (null (cdr pV25)) 
                   (return (STANDARDSPEC::mkEquality topSrt topFunOp topTrm)))))) 
     (return 
      (STANDARDSPEC::mkEquality srt (STANDARDSPEC::mkAppl topFunOp prevArgs) trm))))))


(defun SPECCALC::mkUncurryEquality (sp srt qid trm) 
  (let ((funOp (STANDARDSPEC::mkOp qid srt))) 
    (SPECCALC::mkUncurryEqualityRec sp srt trm funOp srt trm nil)))

(defun SPECCALC::unLambdaDef (spc srt name term) 
  (let ((new_equality (SPECCALC::mkUncurryEquality spc srt name term))) 
    (let ((eqltyWithPos 
           (METASLANG::withAnnT new_equality (METASLANG::termAnn term)))) 
      (cons eqltyWithPos nil))))

(defun SPECCALC::axiomFromOpDefTop (spc qname name decl) 
  (let ((pV5 (svref decl 3))) 
    (block 
     nil 
     (if (consp pV5) 
         (let ((pV12 (cdr (car pV5)))) 
           (if (null (cdr pV5)) 
               (return 
                (if (memberQualifiedId qname name (svref (svref spc 0) 2)) 
                    (progn (METASLANG::termAnn pV12) 
                           (let ((opName (METASLANG::mkQualifiedId qname name))) 
                             (let ((ax 
                                    (vector 
                                     '(:|Axiom|) 
                                     (STRING-SPEC::^ name "_def") 
                                     nil 
                                     (LIST-SPEC::hd 
                                      (SPECCALC::unLambdaDef 
                                       spc 
                                       (cdr (svref decl 2)) 
                                       opName 
                                       pV12))))) (cons ax nil)))) 
                    nil))))) 
     (return nil))))

(defun SPECCALC::axiomFromOpDefTop-1 (x) 
  (SPECCALC::axiomFromOpDefTop (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defparameter SPECCALC::snark_assert (LISP-SPEC::|!symbol| "SNARK" "ASSERT"))

(defparameter SPECCALC::baseAxioms 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::snark_assert 
     (cons 
      (LISP-SPEC::|!quote| 
       (LISP-SPEC::|!list| 
        (cons 
         (LISP-SPEC::|!symbol| "SNARK" "ALL") 
         (cons 
          (LISP-SPEC::|!list| 
           (cons 
            (LISP-SPEC::|!list| 
             (cons 
              (LISP-SPEC::|!symbol| "SNARK" "?X") 
              (cons 
               (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
               (cons (LISP-SPEC::|!symbol| "SNARK" "Option") nil)))) 
            nil)) 
          (cons 
           (LISP-SPEC::|!list| 
            (cons 
             (LISP-SPEC::|!symbol| "SNARK" "OR") 
             (cons 
              (LISP-SPEC::|!list| 
               (cons 
                (LISP-SPEC::|!symbol| "SNARK" "embed?") 
                (cons 
                 (LISP-SPEC::|!symbol| "SNARK" "Some") 
                 (cons (LISP-SPEC::|!symbol| "SNARK" "?X") nil)))) 
              (cons 
               (LISP-SPEC::|!list| 
                (cons 
                 (LISP-SPEC::|!symbol| "SNARK" "embed?") 
                 (cons 
                  (LISP-SPEC::|!symbol| "SNARK" "None") 
                  (cons (LISP-SPEC::|!symbol| "SNARK" "?X") nil)))) 
               nil)))) 
           nil))))) 
      nil))) 
   nil))

(defparameter SPECCALC::baseSorts 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_sort 
     (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Option")) nil))) 
   nil))

(defun SPECCALC::baseSpecPath? (path) 
  (block 
   nil 
   (if (null path) 
       (return nil) 
       (if (consp path) 
           (let ((pV9 (cdr path))
                 (pV8 (car path))) 
             (progn (if (null pV9) (return nil)) 
                    (if (string=  "Library" pV8) 
                        (if (consp pV9) 
                            (if (string=  "Base" (car pV9)) 
                                (if (null (cdr pV9)) (return t))))) 
                    (if (consp pV9) (if (null (cdr pV9)) (return nil))) 
                    (if (string=  "Library" pV8) 
                        (if (consp pV9) 
                            (let ((pV12 (cdr pV9))) 
                              (if (string=  "Base" (car pV9)) 
                                  (if (consp pV12) 
                                      (if (null (cdr pV12)) (return t))))))) 
                    (return (SPECCALC::baseSpecPath? pV9)))))) 
   (error "Nonexhaustive match failure in baseSpecPath?")))

(defun SPECCALC::baseSpecURI?-1 (uri) 
  (block 
   nil 
   (if (eq (car (car uri)) :|None|) (return (SPECCALC::baseSpecPath? (cdr uri)))) 
   (return nil)))

(defun SPECCALC::baseSpecURI? (x0 x1) (SPECCALC::baseSpecURI?-1 (cons x0 x1)))

(defun SPECCALC::bindInGlobalContext-1-1-1 (uri value x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (POLYMAP::update-1-1-1 (svref x 0) uri value) 
    (svref x 1) 
    (svref x 2) 
    (svref x 3))))

(defun SPECCALC::bindInGlobalContext-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::bindInGlobalContext-1-1-1 x1 x2 x3))))

(defun SPECCALC::bindInGlobalContext (x0 x1) 
  (SPECCALC::bindInGlobalContext-1 (cons x0 x1)))

(defun SPECCALC::bindInLocalContext-1-1-1 (uri value x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (svref x 0) 
    (POLYMAP::update-1-1-1 (svref x 1) uri value) 
    (svref x 2) 
    (svref x 3))))

(defun SPECCALC::bindInLocalContext (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::bindInLocalContext-1-1-1 x1 x2 x3))))

(defun SPECCALC::bndrString (bndr) 
  (block 
   nil 
   (if (eq (car bndr) :|Forall|) 
       (return "ALL") 
       (if (eq (car bndr) :|Exists|) (return "EXISTS"))) 
   (error "Nonexhaustive match failure in bndrString")))

(defun SPECCALC::completeMorphismMap (trans_map) 
  #'(lambda (dom_map) 
     #'(lambda (cod_map) 
        #'(lambda (|!position|) 
           (labels 
             ((compl (qualifier id val new_map) 
               (let ((pV6 (findAQualifierMap trans_map qualifier id))) 
                 (block 
                  nil 
                  (if (eq (car pV6) :|Some|) 
                      (return 
                       (SPECCALC::|!return| 
                        (POLYMAP::update-1-1-1 
                         new_map 
                         (cons :|Qualified| (cons qualifier id)) 
                         (cdr pV6))))) 
                  (return 
                   (let ((pV4 (findAQualifierMap cod_map qualifier id))) 
                     (block 
                      nil 
                      (if (eq (car pV4) :|Some|) 
                          (return 
                           (SPECCALC::|!return| 
                            (POLYMAP::update-1-1-1 
                             new_map 
                             (cons :|Qualified| (cons qualifier id)) 
                             (cons :|Qualified| (cons qualifier id)))))) 
                      (return 
                       (SPECCALC::raise 
                        (cons 
                         :|MorphError| 
                         (cons 
                          |!position| 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ "No mapping for " qualifier) 
                            ".") 
                           id)))))))))))) 
             (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                #'(lambda (x) 
                                   (compl 
                                    (svref x 0) 
                                    (svref x 1) 
                                    (svref x 2) 
                                    (svref x 3)))) 
                               POLYMAP::emptyMap) 
                      dom_map))))))

(defun SPECCALC::buildSpecMorphism-1 (domSpec) 
  #'(lambda (codSpec) 
     #'(lambda (x) 
        (let ((sortMap (cdr x))
              (opMap (car x))) 
          #'(lambda (|!position|) 
             (SPECCALC::monadBind 
              (funcall (funcall (funcall (SPECCALC::completeMorphismMap opMap) 
                                         (svref domSpec 1)) 
                                (svref codSpec 1)) 
                       |!position|) 
              #'(lambda (newOpMap) 
                 (SPECCALC::monadBind 
                  (funcall (funcall (funcall (SPECCALC::completeMorphismMap 
                                              sortMap) 
                                             (svref domSpec 3)) 
                                    (svref codSpec 3)) 
                           |!position|) 
                  #'(lambda (newSortMap) 
                     (SPECCALC::|!return| 
                      (vector codSpec domSpec newOpMap newSortMap)))))))))))

(defun SPECCALC::buildSpecMorphism (x0 x1 x2 x3) 
  (SPECCALC::buildSpecMorphism-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::buildSpecMorphism-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::buildSpecMorphism-1 x1) x2) x3) 
                    x4) 
           x5))

(defun SPECCALC::|!catch| (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::|!catch|-1-1-1 x1 x2 x3))))

(defparameter SPECCALC::checkSpecPathsExistence? t)

(defparameter SPECCALC::specPathSeparator 
  (if SYSTEM-SPEC::msWindowsSystem? #\; #\:))

(defun SPECCALC::checkSpecPathsExistence (str) 
  (if SPECCALC::checkSpecPathsExistence? 
      (LIST-SPEC::app-1-1 
       #'(lambda (dir) 
          (if (IO-SPEC::fileExists? dir) 
              nil 
              (SYSTEM-SPEC::|!warn| 
               (STRING-SPEC::^ "Directory does not exist: " dir)))) 
       (SPECCALC::splitStringAtChar-1-1 SPECCALC::specPathSeparator str)) 
      nil))

(defun SPECCALC::setLocalContext-1-1 (newLocalContext x) 
  (cons 
   (cons :|Ok| nil) 
   (vector (svref x 0) newLocalContext (svref x 2) (svref x 3))))

(defun SPECCALC::clearLocalContext (x2 x1 x0 x) 
  (SPECCALC::setLocalContext-1-1 POLYMAP::emptyMap (vector x2 x1 x0 x)))

(defun SPECCALC::clearLocalContext-1 (x) 
  (SPECCALC::clearLocalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::cod (x0 x1 x2 x3) (SPECCALC::cod-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::coerceToSpec (value) 
  (block 
   nil 
   (if (eq (car value) :|Morph|) 
       (return 
        (let ((x (SPECCALC::cod-1 (cdr value)))) 
          (cons :|Spec| (vector (svref x 0) (svref x 1) (svref x 2) (svref x 3))))) 
       (if (eq (car value) :|Colimit|) 
           (return 
            (let ((x (CAT::apex-1 (CAT::cocone-1 (cdr value))))) 
              (cons 
               :|Spec| 
               (vector (svref x 0) (svref x 1) (svref x 2) (svref x 3))))))) 
   (return value)))

(defun SPECCALC::complainIfAmbiguous-1 (spc) 
  #'(lambda (|!position|) 
     (let ((ambiguous_sorts 
            (foldriAQualifierMap-1-1-1 
             #'(lambda (x) 
                (let ((pV14 (svref x 3))
                      (pV13 (svref x 2))) 
                  (block 
                   nil 
                   (let ((pV17 (svref pV13 2))) 
                     (return 
                      (block 
                       nil 
                       (if (null pV17) 
                           (return pV14) 
                           (if (consp pV17) (if (null (cdr pV17)) (return pV14)))) 
                       (return (LISTUTILITIES::insert pV13 pV14))))) 
                   (error "Nonexhaustive match failure in complainIfAmbiguous")))) 
             nil 
             (svref spc 3)))) 
       (let ((ambiguous_ops 
              (foldriAQualifierMap-1-1-1 
               #'(lambda (x) 
                  (let ((pV32 (svref x 3))
                        (pV31 (svref x 2))) 
                    (block 
                     nil 
                     (let ((pV36 (svref pV31 3))) 
                       (return 
                        (block 
                         nil 
                         (if (null pV36) 
                             (return pV32) 
                             (if (consp pV36) 
                                 (if (null (cdr pV36)) (return pV32)))) 
                         (return (LISTUTILITIES::insert pV31 pV32))))) 
                     (error "Nonexhaustive match failure in complainIfAmbiguous")))) 
               nil 
               (svref spc 1)))) 
         (if (cl:and 
              (slang-built-in::slang-term-equals ambiguous_sorts nil) 
              (slang-built-in::slang-term-equals ambiguous_ops nil)) 
             (SPECCALC::|!return| spc) 
             (labels 
               ((print_qid (pV37) 
                 (block 
                  nil 
                  (if (eq (car pV37) :|Qualified|) 
                      (let ((pV38 (cdr pV37))) 
                        (let ((pV40 (cdr pV38))
                              (pV39 (car pV38))) 
                          (return 
                           (if (string=  pV39 METASLANG::UnQualified) 
                               pV40 
                               (STRING-SPEC::^ (STRING-SPEC::^ pV39 ".") pV40)))))) 
                  (error "Nonexhaustive match failure in complainIfAmbiguous")))) 
               (let ((sort_msg 
                      (block 
                       nil 
                       (if (null ambiguous_sorts) 
                           (return "") 
                           (if (consp ambiguous_sorts) 
                               (let ((pV59 (svref (car ambiguous_sorts) 0))) 
                                 (if (consp pV59) 
                                     (return 
                                      (STRING-SPEC::^ 
                                       (LIST-SPEC::foldl-1-1-1 
                                        #'(lambda (x) 
                                           (block 
                                            nil 
                                            (let ((pV49 (svref (car x) 0))) 
                                              (if (consp pV49) 
                                                  (return 
                                                   (STRING-SPEC::^ 
                                                    (STRING-SPEC::^ (cdr x) ", ") 
                                                    (print_qid (car pV49)))))) 
                                            (error 
                                             "Nonexhaustive match failure in complainIfAmbiguous"))) 
                                        (STRING-SPEC::^ 
                                         "Ambiguous sorts: " 
                                         (print_qid (car pV59))) 
                                        (cdr ambiguous_sorts)) 
                                       "
")))))) 
                       (error 
                        "Nonexhaustive match failure in complainIfAmbiguous")))) 
                 (let ((op_msg 
                        (block 
                         nil 
                         (if (null ambiguous_ops) 
                             (return "") 
                             (if (consp ambiguous_ops) 
                                 (let ((pV86 (svref (car ambiguous_ops) 0))) 
                                   (if (consp pV86) 
                                       (return 
                                        (STRING-SPEC::^ 
                                         (LIST-SPEC::foldl-1-1-1 
                                          #'(lambda (x) 
                                             (block 
                                              nil 
                                              (let ((pV75 (svref (car x) 0))) 
                                                (if (consp pV75) 
                                                    (return 
                                                     (STRING-SPEC::^ 
                                                      (STRING-SPEC::^ 
                                                       (cdr x) 
                                                       ", ") 
                                                      (print_qid (car pV75)))))) 
                                              (error 
                                               "Nonexhaustive match failure in complainIfAmbiguous"))) 
                                          (STRING-SPEC::^ 
                                           "Ambiguous ops: " 
                                           (print_qid (car pV86))) 
                                          (cdr ambiguous_ops)) 
                                         "
")))))) 
                         (error 
                          "Nonexhaustive match failure in complainIfAmbiguous")))) 
                   (let ((spc_msg 
                          (STRING-SPEC::^ 
                           "
 in following spec: 
" 
                           (ANNSPECPRINTER::printSpec-1 spc)))) 
                     (SPECCALC::raise 
                      (cons 
                       :|SpecError| 
                       (cons 
                        |!position| 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ (STRING-SPEC::^ "
" sort_msg) op_msg) 
                         spc_msg)))))))))))))

(defun SPECCALC::complainIfAmbiguous (x0 x1 x2 x3) 
  (SPECCALC::complainIfAmbiguous-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::complainIfAmbiguous-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::complainIfAmbiguous-1 x1) x2) x3))

(defun SPECCALC::completeMorphismMap-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::completeMorphismMap x1) x2) x3) 
                    x4) 
           x5))

(defun SPECCALC::compose-1-1 (mor1 mor2) 
  (vector 
   (svref mor2 0) 
   (svref mor1 1) 
   (POLYMAP::compose-1-1 (svref mor1 2) (svref mor2 2)) 
   (POLYMAP::compose-1-1 (svref mor1 3) (svref mor2 3))))

(defun SPECCALC::compose-1 (x1) 
  #'(lambda (x2) (SPECCALC::compose-1-1 x1 x2)))

(defun SPECCALC::compose (x0 x1 x2 x3) 
  (SPECCALC::compose-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::compressDefs (x0 x1 x2 x3) 
  (SPECCALC::compressDefs-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::compressOpDefs-1 (x1) 
  #'(lambda (x2) (SPECCALC::compressOpDefs-1-1 x1 x2)))

(defun SPECCALC::compressOpDefs (x0 x1 x2 x3) 
  (SPECCALC::compressOpDefs-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::compressSortDefs-1 (x1) 
  #'(lambda (x2) (SPECCALC::compressSortDefs-1-1 x1 x2)))

(defun SPECCALC::compressSortDefs (x0 x1 x2 x3) 
  (SPECCALC::compressSortDefs-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::computeQuotientSet-1-1-1 (dg non_base_items sm_qid_map) 
  (let ((initial_mfset_vqid_map 
         (CAT::foldOverVertices-1-1-1 
          #'(lambda (mfset_map) 
             #'(lambda (vertex) 
                (LIST-SPEC::foldl-1-1-1 
                 #'(lambda (x) 
                    (let ((pV1 (car x))) 
                      (block 
                       nil 
                       (return 
                        (MFSET::augmentMFSetMap-1-1 
                         (cdr x) 
                         (cons 
                          vertex 
                          (cons :|Qualified| (cons (svref pV1 0) (svref pV1 1)))))) 
                       (error 
                        "Nonexhaustive match failure in computeQuotientSet")))) 
                 mfset_map 
                 (funcall non_base_items (CAT::vertexLabel-1-1 dg vertex))))) 
          MFSET::emptyMFSetMap 
          dg))) 
    (let ((final_mfset_vqid_map 
           (let ((sketch (CAT::shape-1 dg))) 
             (let ((source_fn (SKETCH::|!eval| (SKETCH::src-1 sketch)))) 
               (let ((target_fn (SKETCH::|!eval| (SKETCH::target-1 sketch)))) 
                 (CAT::foldOverEdges-1-1-1 
                  #'(lambda (mfset_map) 
                     #'(lambda (edge) 
                        (let ((sm (CAT::edgeLabel-1-1 dg edge))) 
                          (let ((source_vertex (funcall source_fn edge))) 
                            (let ((target_vertex (funcall target_fn edge))) 
                              (POLYMAP::foldMap-1-1-1 
                               #'(lambda (mfset_map) 
                                  #'(lambda (dom_qid) 
                                     #'(lambda (cod_qid) 
                                        (let ((pV8 
                                               (POLYMAP::evalPartial-1-1 
                                                mfset_map 
                                                (cons source_vertex dom_qid)))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV8) :|None|) 
                                               (return mfset_map) 
                                               (if (eq (car pV8) :|Some|) 
                                                   (return 
                                                    (let ((pV6 
                                                           (POLYMAP::evalPartial-1-1 
                                                            mfset_map 
                                                            (cons 
                                                             target_vertex 
                                                             cod_qid)))) 
                                                      (block 
                                                       nil 
                                                       (if (eq (car pV6) :|None|) 
                                                           (return mfset_map) 
                                                           (if (eq 
                                                                (car pV6) 
                                                                :|Some|) 
                                                               (return 
                                                                (MFSET::|!merge|-1-1-1 
                                                                 mfset_map 
                                                                 (cdr pV8) 
                                                                 (cdr pV6))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in computeQuotientSet")))))) 
                                           (error 
                                            "Nonexhaustive match failure in computeQuotientSet")))))) 
                               mfset_map 
                               (funcall sm_qid_map sm))))))) 
                  initial_mfset_vqid_map 
                  dg)))))) (MFSET::extractQuotientSet final_mfset_vqid_map))))

(defun SPECCALC::computeQuotientSet-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::computeQuotientSet-1-1-1 x1 x2 x3))))

(defun SPECCALC::computeQuotientSet (x0 x1) 
  (SPECCALC::computeQuotientSet-1 (cons x0 x1)))

(defun SPECCALC::makeIdToQualifiersMap (qset) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (LIST-SPEC::foldl-1-1-1 
       #'(lambda (x1) 
          (let ((pV5 (cdr x1))) 
            (block 
             nil 
             (let ((pV7 (cdr (car x1)))) 
               (if (eq (car pV7) :|Qualified|) 
                   (let ((pV8 (cdr pV7))) 
                     (let ((pV10 (cdr pV8))
                           (pV9 (car pV8))) 
                       (return 
                        (let ((pV2 (POLYMAP::evalPartial-1-1 pV5 pV10))) 
                          (block 
                           nil 
                           (if (eq (car pV2) :|None|) 
                               (return 
                                (POLYMAP::update-1-1-1 pV5 pV10 (cons pV9 nil))) 
                               (if (eq (car pV2) :|Some|) 
                                   (let ((pV3 (cdr pV2))) 
                                     (return 
                                      (if (LIST-SPEC::|!member| pV9 pV3) 
                                          pV5 
                                          (POLYMAP::update-1-1-1 
                                           pV5 
                                           pV10 
                                           (cons pV9 pV3))))))) 
                           (error 
                            "Nonexhaustive match failure in makeIdToQualifiersMap")))))))) 
             (error "Nonexhaustive match failure in makeIdToQualifiersMap")))) 
       (cdr x) 
       (car x))) 
   POLYMAP::emptyMap 
   qset))

(defun SPECCALC::makeQidToClassIndicesMap (qset) 
  (let ((pV12 
         (LIST-SPEC::foldl-1-1-1 
          #'(lambda (x) 
             (let ((pV9 (cdr x))) 
               (block 
                nil 
                (let ((pV11 (cdr pV9))) 
                  (return 
                   (cons 
                    (LIST-SPEC::foldl-1-1-1 
                     #'(lambda (x1) 
                        (let ((qid_to_class_indices (cdr x1))) 
                          (let ((qid (cdr (car x1)))) 
                            (let ((pV3 
                                   (POLYMAP::evalPartial-1-1 
                                    qid_to_class_indices 
                                    qid))) 
                              (block 
                               nil 
                               (if (eq (car pV3) :|None|) 
                                   (return 
                                    (POLYMAP::update-1-1-1 
                                     qid_to_class_indices 
                                     qid 
                                     (cons pV11 nil))) 
                                   (if (eq (car pV3) :|Some|) 
                                       (let ((pV4 (cdr pV3))) 
                                         (if (consp pV4) 
                                             (return 
                                              (if ( =  pV11 (car pV4)) 
                                                  qid_to_class_indices 
                                                  (POLYMAP::update-1-1-1 
                                                   qid_to_class_indices 
                                                   qid 
                                                   (cons pV11 pV4)))))))) 
                               (error 
                                "Nonexhaustive match failure in makeQidToClassIndicesMap")))))) 
                     (car pV9) 
                     (car x)) 
                    (INTEGER-SPEC::|!+| pV11 1)))) 
                (error "Nonexhaustive match failure in makeQidToClassIndicesMap")))) 
          (cons POLYMAP::emptyMap 0) 
          qset))) 
    (block 
     nil 
     (return (car pV12)) 
     (error "Nonexhaustive match failure in makeQidToClassIndicesMap"))))

(defun SPECCALC::vertexName (v) v)

(defun SPECCALC::reviseQId (vertex qualifier id id_to_qualifiers) 
  (let ((qualifiers_to_avoid (POLYMAP::|!eval|-1-1 id_to_qualifiers id))) 
    (labels 
      ((revised (old_qualifier) 
        (let ((new_qualifier 
               (if (string=  old_qualifier METASLANG::UnQualified) 
                   (SPECCALC::vertexName vertex) 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ (SPECCALC::vertexName vertex) "_") 
                    old_qualifier)))) 
          (if (LIST-SPEC::|!member| new_qualifier qualifiers_to_avoid) 
              (revised new_qualifier) 
              new_qualifier)))) 
      (cons :|Qualified| (cons (revised qualifier) id)))))

(defun SPECCALC::computeVQidToApexQidAndAliasesMap (qset) 
  (let ((qid_to_class_indices (SPECCALC::makeQidToClassIndicesMap qset))) 
    (let ((id_to_qualifiers (SPECCALC::makeIdToQualifiersMap qset))) 
      (LIST-SPEC::foldl-1-1-1 
       #'(lambda (x) 
          (let ((|!class| (car x))) 
            (let ((pV16 
                   (LIST-SPEC::foldl-1-1-1 
                    #'(lambda (x1) 
                       (let ((pV8 (cdr x1))
                             (pV7 (car x1))) 
                         (block 
                          nil 
                          (let ((pV10 (cdr pV7))) 
                            (if (eq (car pV10) :|Qualified|) 
                                (let ((pV11 (cdr pV10))) 
                                  (return 
                                   (let ((apex_qid 
                                          (let ((pV3 
                                                 (POLYMAP::|!eval|-1-1 
                                                  qid_to_class_indices 
                                                  pV10))) 
                                            (block 
                                             nil 
                                             (if (consp pV3) 
                                                 (if (null (cdr pV3)) 
                                                     (return pV10))) 
                                             (return 
                                              (SPECCALC::reviseQId 
                                               (car pV7) 
                                               (car pV11) 
                                               (cdr pV11) 
                                               id_to_qualifiers)))))) 
                                     (cons 
                                      (LIST-SPEC::|!cons| apex_qid (car pV8)) 
                                      (POLYMAP::update-1-1-1 
                                       (cdr pV8) 
                                       pV7 
                                       apex_qid))))))) 
                          (error 
                           "Nonexhaustive match failure in computeVQidToApexQidAndAliasesMap")))) 
                    (cons nil POLYMAP::emptyMap) 
                    |!class|))) 
              (block 
               nil 
               (let ((pV18 (cdr pV16))
                     (pV17 (car pV16))) 
                 (return 
                  (LIST-SPEC::foldl-1-1-1 
                   #'(lambda (x1) 
                      (let ((vqid (car x1))) 
                        (POLYMAP::update-1-1-1 
                         (cdr x1) 
                         vqid 
                         (cons (POLYMAP::|!eval|-1-1 pV18 vqid) pV17)))) 
                   (cdr x) 
                   |!class|))) 
               (error 
                "Nonexhaustive match failure in computeVQidToApexQidAndAliasesMap"))))) 
       POLYMAP::emptyMap 
       qset))))

(defun SPECCALC::convertOpRules (translate_rules) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (let ((pV6 (car (car x)))) 
         (if (eq (car pV6) :|Op|) 
             (let ((pV8 (cdr pV6))) 
               (return 
                (POLYMAP::update-1-1-1 
                 (cdr x) 
                 (car (svref pV8 0)) 
                 (car (svref pV8 1))))))) 
       (error "Nonexhaustive match failure in convertOpRules"))) 
   POLYMAP::emptyMap 
   translate_rules))

(defun SPECCALC::convertSortRules (translate_rules) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (let ((pV4 (car (car x)))) 
         (if (eq (car pV4) :|Sort|) 
             (let ((pV6 (cdr pV4))) 
               (return 
                (POLYMAP::update-1-1-1 (cdr x) (svref pV6 0) (svref pV6 1)))))) 
       (error "Nonexhaustive match failure in convertSortRules"))) 
   POLYMAP::emptyMap 
   translate_rules))

(defun SPECCALC::countKeysInAQualifierMap (qmap) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) (INTEGER-SPEC::|!+| (svref x 3) 1)) 
   0 
   qmap))

(defun SPECCALC::curryShapeNum (sp srt) 
  (let ((pV2 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV2) :|Some|) 
         (return 
          (INTEGER-SPEC::|!+| 1 (SPECCALC::curryShapeNum sp (cdr (cdr pV2)))))) 
     (return 0))))

(defun SPECCALC::curryShapeNum-1 (x) (SPECCALC::curryShapeNum (car x) (cdr x)))

(defparameter SPECCALC::declare_constant 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-CONSTANT-SYMBOL"))

(defparameter SPECCALC::declare_predicate 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-PREDICATE-SYMBOL"))

(defparameter SPECCALC::declare_proposition_symbol 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-PROPOSITION-SYMBOL"))

(defun SPECCALC::displayMultipleAnonymousProofResult
 (proof_name claim_type claim_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ (STRING-SPEC::^ proof_name ": ") claim_type) 
                " ") 
               claim_name) 
              " ") 
             provedString)) 
           proved)))

(defun SPECCALC::displayMultipleAnonymousProofResult-1 (x) 
  (SPECCALC::displayMultipleAnonymousProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECCALC::displayMultipleProofResult
 (proof_name claim_type claim_name spec_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ (STRING-SPEC::^ proof_name ": ") claim_type) 
                  " ") 
                 claim_name) 
                " in ") 
               spec_name) 
              " ") 
             provedString)) 
           proved)))

(defun SPECCALC::displayMultipleProofResult-1 (x) 
  (SPECCALC::displayMultipleProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun SPECCALC::displaySingleAnonymousProofResult
 (claim_type claim_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ (STRING-SPEC::^ claim_type " ") claim_name) 
              " ") 
             provedString)) 
           proved)))

(defun SPECCALC::displaySingleProofResult
 (claim_type claim_name spec_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ (STRING-SPEC::^ claim_type " ") claim_name) 
                " in ") 
               spec_name) 
              " ") 
             provedString)) 
           proved)))

(defun SPECCALC::displayProofResult
 (proof_name claim_type claim_name spec_name proved snarkLogFileName) 
  (progn (block 
          nil 
          (if (eq (car proof_name) :|None|) 
              (return 
               (block 
                nil 
                (if (eq (car spec_name) :|None|) 
                    (return 
                     (SPECCALC::displaySingleAnonymousProofResult 
                      claim_type 
                      claim_name 
                      proved)) 
                    (if (eq (car spec_name) :|Some|) 
                        (return 
                         (SPECCALC::displaySingleProofResult 
                          claim_type 
                          claim_name 
                          (cdr spec_name) 
                          proved)))) 
                (error "Nonexhaustive match failure in displayProofResult"))) 
              (if (eq (car proof_name) :|Some|) 
                  (let ((pV7 (cdr proof_name))) 
                    (return 
                     (block 
                      nil 
                      (if (eq (car spec_name) :|None|) 
                          (return 
                           (SPECCALC::displayMultipleAnonymousProofResult 
                            pV7 
                            claim_type 
                            claim_name 
                            proved)) 
                          (if (eq (car spec_name) :|Some|) 
                              (return 
                               (SPECCALC::displayMultipleProofResult 
                                pV7 
                                claim_type 
                                claim_name 
                                (cdr spec_name) 
                                proved)))) 
                      (error "Nonexhaustive match failure in displayProofResult")))))) 
          (error "Nonexhaustive match failure in displayProofResult")) 
         (progn (STRING-SPEC::writeLine 
                 (STRING-SPEC::^ "    Snark Log file: " snarkLogFileName)) 
                proved)))

(defun SPECCALC::displayProofResult-1 (x) 
  (SPECCALC::displayProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun SPECCALC::displaySingleAnonymousProofResult-1 (x) 
  (SPECCALC::displaySingleAnonymousProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2)))

(defun SPECCALC::displaySingleProofResult-1 (x) 
  (SPECCALC::displaySingleProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECCALC::dom (x0 x1 x2 x3) (SPECCALC::dom-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::getCurrentURI-1 (state) 
  (let ((optURI (svref state 2))) 
    (block 
     nil 
     (if (eq (car optURI) :|None|) 
         (return 
          (cons (cons :|Exception| (cons :|Fail| "No current URI")) state)) 
         (if (eq (car optURI) :|Some|) 
             (let ((pV2 (cdr optURI))) 
               (return (cons (cons :|Ok| (cons (car pV2) (cdr pV2))) state))))) 
     (error "Nonexhaustive match failure in getCurrentURI"))))

(defun SPECCALC::uriToFullPath-1 (x) (SPECCALC::uriToFullPath (car x) (cdr x)))

(defun TYPECHECKER::checkDifferent (tvs setOfUniqueIds) 
  (block 
   nil 
   (if (null tvs) 
       (return t) 
       (if (consp tvs) 
           (let ((pV3 (car tvs))) 
             (return 
              (if (STRINGSET::|!member| setOfUniqueIds pV3) 
                  nil 
                  (TYPECHECKER::checkDifferent 
                   (cdr tvs) 
                   (STRINGSET::add setOfUniqueIds pV3))))))) 
   (error "Nonexhaustive match failure in checkDifferent")))

(defun STANDARDSPEC::wildFindUnQualified (qualifier_map id) 
  (STRINGMAP::foldri-1-1-1 
   #'(lambda (x) 
      (let ((results (svref x 2))) 
        (let ((pV1 (STRINGMAP::|!find| (svref x 1) id))) 
          (block 
           nil 
           (if (eq (car pV1) :|Some|) 
               (return (LIST-SPEC::|!++| results (cons (cdr pV1) nil))) 
               (if (eq (car pV1) :|None|) (return results))) 
           (error "Nonexhaustive match failure in wildFindUnQualified"))))) 
   nil 
   qualifier_map))

(defun STANDARDSPEC::findAllSorts (pV3 pV4) 
  (block 
   nil 
   (if (eq (car pV4) :|Qualified|) 
       (let ((pV5 (cdr pV4))) 
         (let ((pV7 (cdr pV5))
               (pV6 (car pV5))) 
           (return 
            (let ((found 
                   (let ((pV1 (findAQualifierMap (svref pV3 3) pV6 pV7))) 
                     (block 
                      nil 
                      (if (eq (car pV1) :|Some|) 
                          (return (cons (cdr pV1) nil)) 
                          (if (eq (car pV1) :|None|) (return nil))) 
                      (error "Nonexhaustive match failure in findAllSorts"))))) 
              (if (string=  pV6 METASLANG::UnQualified) 
                  (LIST-SPEC::|!++| 
                   found 
                   (LIST-SPEC::filter-1-1 
                    #'(lambda (op_info) 
                       (BOOLEAN-SPEC::~ (LIST-SPEC::|!member| op_info found))) 
                    (STANDARDSPEC::wildFindUnQualified (svref pV3 3) pV7))) 
                  found)))))) 
   (error "Nonexhaustive match failure in findAllSorts")))

(defun UTILITIES::unlinkPSort (srt) 
  (block 
   nil 
   (if (eq (car srt) :|MetaTyVar|) 
       (return 
        (let ((x (STATE::|!!| (car (cdr srt))))) 
          (let ((pV3 (svref x 0))) 
            (block 
             nil 
             (if (eq (car pV3) :|Some|) 
                 (return (UTILITIES::unlinkPSort (cdr pV3)))) 
             (return srt)))))) 
   (return srt)))

(defun UTILITIES::|!error| (pV1 pV2 pV3) 
  (block 
   nil 
   (let ((pV5 (svref pV1 1))) 
     (return 
      (STATE::|:=| pV5 (LIST-SPEC::|!cons| (cons pV2 pV3) (STATE::|!!| pV5))))) 
   (error "Nonexhaustive match failure in error")))

(defun TYPECHECKER::adjustEqualitySort (env srt t1 eq_args) 
  (let ((pV8 (UTILITIES::unlinkPSort srt))) 
    (block 
     nil 
     (if (eq (car eq_args) :|Record|) 
         (let ((pV10 (car (cdr eq_args)))) 
           (if (consp pV10) 
               (let ((pV14 (cdr pV10))) 
                 (if (string=  "1" (car (car pV10))) 
                     (if (consp pV14) 
                         (if (string=  "2" (car (car pV14))) 
                             (if (null (cdr pV14)) 
                                 (if (eq (car pV8) :|Arrow|) 
                                     (let ((pV23 (svref (cdr pV8) 0))) 
                                       (if (eq (car pV23) :|Product|) 
                                           (let ((pV27 (car (cdr pV23)))) 
                                             (if (consp pV27) 
                                                 (let ((pV31 (cdr pV27))) 
                                                   (if (string=  
                                                        "1" 
                                                        (car (car pV27))) 
                                                       (if (consp pV31) 
                                                           (if (string=  
                                                                "2" 
                                                                (car (car pV31))) 
                                                               (if (null 
                                                                    (cdr pV31)) 
                                                                   (return t1))))))))))))))))))) 
     (return 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               "Illegal Equality" 
               (ANNSPECPRINTER::printTerm eq_args)) 
              (METASLANG::sortAnn srt)) 
             t1)))))

(defun TYPECHECKER::consistentInfixPTerms (competing_pterms optional_priority) 
  (block 
   nil 
   (if (null competing_pterms) 
       (return (cons t optional_priority)) 
       (if (consp competing_pterms) 
           (let ((pV16 (cdr competing_pterms))
                 (pV15 (car competing_pterms))) 
             (progn (if (eq (car pV15) :|Fun|) 
                        (let ((pV18 (svref (cdr pV15) 0))) 
                          (if (eq (car pV18) :|OneName|) 
                              (let ((pV28 (cdr (cdr pV18)))) 
                                (if (consp pV28) 
                                    (return 
                                     (block 
                                      nil 
                                      (if (eq (car optional_priority) :|None|) 
                                          (return (cons nil '(:|None|))) 
                                          (if (eq 
                                               (car optional_priority) 
                                               :|Some|) 
                                              (return 
                                               (if (slang-built-in::slang-term-equals 
                                                    pV28 
                                                    (cdr optional_priority)) 
                                                   (TYPECHECKER::consistentInfixPTerms 
                                                    pV16 
                                                    optional_priority) 
                                                   (cons nil '(:|None|)))))) 
                                      (error 
                                       "Nonexhaustive match failure in consistentInfixPTerms"))))) 
                              (if (eq (car pV18) :|TwoNames|) 
                                  (let ((pV25 (svref (cdr pV18) 2))) 
                                    (if (consp pV25) 
                                        (return 
                                         (block 
                                          nil 
                                          (if (eq 
                                               (car optional_priority) 
                                               :|None|) 
                                              (return (cons nil '(:|None|))) 
                                              (if (eq 
                                                   (car optional_priority) 
                                                   :|Some|) 
                                                  (return 
                                                   (if (slang-built-in::slang-term-equals 
                                                        pV25 
                                                        (cdr optional_priority)) 
                                                       (TYPECHECKER::consistentInfixPTerms 
                                                        pV16 
                                                        optional_priority) 
                                                       (cons nil '(:|None|)))))) 
                                          (error 
                                           "Nonexhaustive match failure in consistentInfixPTerms"))))))))) 
                    (return 
                     (block 
                      nil 
                      (if (eq (car optional_priority) :|None|) 
                          (return 
                           (TYPECHECKER::consistentInfixPTerms 
                            pV16 
                            optional_priority))) 
                      (return (cons nil '(:|None|))))))))) 
   (error "Nonexhaustive match failure in consistentInfixPTerms")))

(defun TYPECHECKER::consistentTag (competing_pterms) 
  (block 
   nil 
   (if (consp competing_pterms) 
       (let ((pV11 (cdr competing_pterms))
             (pV10 (car competing_pterms))) 
         (progn (if (eq (car pV10) :|Fun|) 
                    (let ((pV13 (svref (cdr pV10) 0))) 
                      (if (eq (car pV13) :|OneName|) 
                          (let ((pV23 (cdr (cdr pV13)))) 
                            (if (consp pV23) 
                                (return 
                                 (TYPECHECKER::consistentInfixPTerms 
                                  pV11 
                                  (cons :|Some| (cons (car pV23) (cdr pV23))))))) 
                          (if (eq (car pV13) :|TwoNames|) 
                              (let ((pV20 (svref (cdr pV13) 2))) 
                                (if (consp pV20) 
                                    (return 
                                     (TYPECHECKER::consistentInfixPTerms 
                                      pV11 
                                      (cons :|Some| (cons (car pV20) (cdr pV20))))))))))) 
                (return (TYPECHECKER::consistentInfixPTerms pV11 '(:|None|)))))) 
   (return (cons t '(:|None|)))))

(defun TYPECHECKER::blankString (n) 
  (if (INTEGER-SPEC::|!<=| n 0) 
      "" 
      (if (INTEGER-SPEC::|!<| n 100) 
          (STRING-SPEC::substring 
           "                                                                                                    " 
           0 
           n) 
          (STRING-SPEC::^ 
           "                                                                                                    " 
           (TYPECHECKER::blankString (INTEGER-SPEC::|!-| n 100))))))

(defun TYPECHECKER::newLines (lines) 
  (block 
   nil 
   (if (null lines) 
       (return "") 
       (if (consp lines) 
           (let ((pV4 (cdr lines))
                 (pV3 (car lines))) 
             (progn (if (null pV4) (return pV3)) 
                    (return 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        pV3 
                        (CHAR-SPEC::toString (CHAR-SPEC::chr 10))) 
                       "          ") 
                      (TYPECHECKER::newLines pV4))))))) 
   (error "Nonexhaustive match failure in newLines")))

(defun UTILITIES::linkMetaTyVar-1-1 (v |!t|) 
  (let ((pV1 (STATE::|!!| v))) 
    (block 
     nil 
     (return 
      (STATE::|:=| v (vector (cons :|Some| |!t|) (svref pV1 1) (svref pV1 2)))) 
     (error "Nonexhaustive match failure in linkMetaTyVar"))))

(defun UTILITIES::occursT (v pred) 
  (block 
   nil 
   (if (eq (car pred) :|ApplyN|) 
       (return 
        (LIST-SPEC::|!exists|-1-1 
         #'(lambda (|!M|) (UTILITIES::occursT v |!M|)) 
         (car (cdr pred)))) 
       (if (eq (car pred) :|Record|) 
           (return 
            (LIST-SPEC::|!exists|-1-1 
             #'(lambda (x) (UTILITIES::occursT v (cdr x))) 
             (car (cdr pred)))) 
           (if (eq (car pred) :|Bind|) 
               (let ((pV25 (cdr pred))) 
                 (return 
                  (cl:or 
                   (LIST-SPEC::|!exists|-1-1 
                    #'(lambda (x) (UTILITIES::occurs v (cdr x))) 
                    (svref pV25 1)) 
                   (UTILITIES::occursT v (svref pV25 2))))) 
               (if (eq (car pred) :|IfThenElse|) 
                   (let ((pV24 (cdr pred))) 
                     (return 
                      (cl:or 
                       (UTILITIES::occursT v (svref pV24 0)) 
                       (cl:or 
                        (UTILITIES::occursT v (svref pV24 1)) 
                        (UTILITIES::occursT v (svref pV24 2)))))) 
                   (if (eq (car pred) :|Var|) 
                       (return (UTILITIES::occurs v (cdr (car (cdr pred))))) 
                       (if (eq (car pred) :|Fun|) 
                           (return (UTILITIES::occurs v (svref (cdr pred) 1))) 
                           (if (eq (car pred) :|Seq|) 
                               (return 
                                (LIST-SPEC::|!exists|-1-1 
                                 #'(lambda (|!M|) (UTILITIES::occursT v |!M|)) 
                                 (car (cdr pred)))) 
                               (if (eq (car pred) :|Let|) 
                                   (let ((pV20 (cdr pred))) 
                                     (return 
                                      (cl:or 
                                       (UTILITIES::occursT v (svref pV20 1)) 
                                       (LIST-SPEC::|!exists|-1-1 
                                        #'(lambda (x) 
                                           (UTILITIES::occursT v (cdr x))) 
                                        (svref pV20 0))))) 
                                   (if (eq (car pred) :|LetRec|) 
                                       (let ((pV19 (cdr pred))) 
                                         (return 
                                          (cl:or 
                                           (UTILITIES::occursT v (svref pV19 1)) 
                                           (LIST-SPEC::|!exists|-1-1 
                                            #'(lambda (x) 
                                               (UTILITIES::occursT v (cdr x))) 
                                            (svref pV19 0))))) 
                                       (if (eq (car pred) :|Lambda|) 
                                           (return 
                                            (LIST-SPEC::|!exists|-1-1 
                                             #'(lambda (x) 
                                                (UTILITIES::occursT 
                                                 v 
                                                 (svref x 2))) 
                                             (car (cdr pred)))))))))))))) 
   (return nil)))

(defun UTILITIES::occurs (v srt) 
  (labels 
    ((occursRow (v row) 
      (block 
       nil 
       (if (null row) 
           (return nil) 
           (if (consp row) 
               (return 
                (cl:or 
                 (UTILITIES::occurs v (cdr (car row))) 
                 (occursRow v (cdr row)))))) 
       (error "Nonexhaustive match failure in occurs")))
     (occursOptRow (v row) 
      (block 
       nil 
       (if (null row) 
           (return nil) 
           (if (consp row) 
               (let ((pV6 (cdr row))) 
                 (let ((pV8 (cdr (car row)))) 
                   (if (eq (car pV8) :|Some|) 
                       (return 
                        (cl:or 
                         (UTILITIES::occurs v (cdr pV8)) 
                         (occursOptRow v pV6))) 
                       (if (eq (car pV8) :|None|) (return (occursOptRow v pV6)))))))) 
       (error "Nonexhaustive match failure in occurs")))) 
    (block 
     nil 
     (if (eq (car srt) :|CoProduct|) 
         (return (occursOptRow v (car (cdr srt)))) 
         (if (eq (car srt) :|Product|) 
             (return (occursRow v (car (cdr srt)))) 
             (if (eq (car srt) :|Arrow|) 
                 (let ((pV37 (cdr srt))) 
                   (return 
                    (cl:or 
                     (UTILITIES::occurs v (svref pV37 0)) 
                     (UTILITIES::occurs v (svref pV37 1))))) 
                 (if (eq (car srt) :|Quotient|) 
                     (let ((pV36 (cdr srt))) 
                       (return 
                        (cl:or 
                         (UTILITIES::occurs v (svref pV36 0)) 
                         (UTILITIES::occursT v (svref pV36 1))))) 
                     (if (eq (car srt) :|Subsort|) 
                         (let ((pV35 (cdr srt))) 
                           (return 
                            (cl:or 
                             (UTILITIES::occurs v (svref pV35 0)) 
                             (UTILITIES::occursT v (svref pV35 1))))) 
                         (if (eq (car srt) :|Base|) 
                             (return 
                              (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (s) (UTILITIES::occurs v s)) 
                               (svref (cdr srt) 1))) 
                             (if (eq (car srt) :|TyVar|) 
                                 (return nil) 
                                 (if (eq (car srt) :|MetaTyVar|) 
                                     (return 
                                      (let ((pV27 (UTILITIES::unlinkPSort srt))) 
                                        (block 
                                         nil 
                                         (if (eq (car pV27) :|MetaTyVar|) 
                                             (return 
                                              (slang-built-in::slang-term-equals 
                                               v 
                                               (car (cdr pV27))))) 
                                         (return (UTILITIES::occurs v pV27))))))))))))) 
     (error "Nonexhaustive match failure in occurs"))))

(defun UTILITIES::compareQId (pV2 pV3) 
  (block 
   nil 
   (if (eq (car pV2) :|Qualified|) 
       (let ((pV4 (cdr pV2))) 
         (if (eq (car pV3) :|Qualified|) 
             (let ((pV7 (cdr pV3))) 
               (return 
                (let ((pV1 (STRING-SPEC::compare (car pV4) (car pV7)))) 
                  (block 
                   nil 
                   (if (eq (car pV1) :|Equal|) 
                       (return (STRING-SPEC::compare (cdr pV4) (cdr pV7)))) 
                   (return pV1)))))))) 
   (error "Nonexhaustive match failure in compareQId")))

(defun UTILITIES::compareQId-1 (x) (UTILITIES::compareQId (car x) (cdr x)))

(defparameter UTILITIES::counter (cons :|Ref| 0))

(defun UTILITIES::freshMetaTyVar (pos) 
  (progn (STATE::|:=| 
          UTILITIES::counter 
          (INTEGER-SPEC::|!+| 1 (STATE::|!!| UTILITIES::counter))) 
         (cons 
          :|MetaTyVar| 
          (cons 
           (cons 
            :|Ref| 
            (vector '(:|None|) "#fresh" (STATE::|!!| UTILITIES::counter))) 
           pos))))

(defun UTILITIES::copySort (|!tyVars| srt) 
  (if (LIST-SPEC::|!null| |!tyVars|) 
      (cons nil srt) 
      (let ((mtvar_position (cons :|Internal| "copySort"))) 
        (let ((tyVarMap 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (tv) 
                   (cons tv (UTILITIES::freshMetaTyVar mtvar_position))) 
                |!tyVars|))) 
          (labels 
            ((mapTyVar (tv tvs pos) 
              (block 
               nil 
               (if (null tvs) 
                   (return (cons :|TyVar| (cons tv pos))) 
                   (if (consp tvs) 
                       (let ((pV3 (car tvs))) 
                         (return 
                          (if (string=  tv (car pV3)) 
                              (cdr pV3) 
                              (mapTyVar tv (cdr tvs) pos)))))) 
               (error "Nonexhaustive match failure in copySort")))) 
            (labels 
              ((cp (srt) 
                (block 
                 nil 
                 (if (eq (car srt) :|TyVar|) 
                     (let ((pV8 (cdr srt))) 
                       (return (mapTyVar (car pV8) tyVarMap (cdr pV8))))) 
                 (return srt)))) 
              (let ((srt 
                     (METASLANG::mapSort-1-1 
                      (vector #'(lambda (x) x) #'cp #'(lambda (x) x)) 
                      srt))) 
                (let ((metaTyVars 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (x) 
                           (let ((pV14 (cdr x))) 
                             (block 
                              nil 
                              (if (eq (car pV14) :|MetaTyVar|) 
                                  (return (car (cdr pV14)))) 
                              (error "Nonexhaustive match failure in copySort")))) 
                        tyVarMap))) (cons metaTyVars srt)))))))))

(defun UTILITIES::instantiateScheme (env pos types type_vars srt) 
  (if (BOOLEAN-SPEC::~ 
       ( =  (LIST-SPEC::|!length| types) (LIST-SPEC::|!length| type_vars))) 
      (progn (UTILITIES::|!error| 
              env 
              "
  Instantiation list does not match argument list" 
              pos) 
             srt) 
      (let ((pV5 (UTILITIES::copySort type_vars srt))) 
        (block 
         nil 
         (return 
          (progn (LISTPAIR::app-1-1 
                  #'(lambda (x) 
                     (let ((new_type_var (cdr x))) 
                       (let ((pV1 (STATE::|!!| new_type_var))) 
                         (block 
                          nil 
                          (return 
                           (STATE::|:=| 
                            new_type_var 
                            (vector 
                             (cons :|Some| (car x)) 
                             (svref pV1 1) 
                             (svref pV1 2)))) 
                          (error 
                           "Nonexhaustive match failure in instantiateScheme"))))) 
                  (cons types (car pV5))) 
                 (cdr pV5))) 
         (error "Nonexhaustive match failure in instantiateScheme")))))

(defun UTILITIES::unfoldPSortRec (env srt qids) 
  (let ((unlinked_sort (UTILITIES::unlinkPSort srt))) 
    (block 
     nil 
     (if (eq (car unlinked_sort) :|Base|) 
         (let ((pV33 (cdr unlinked_sort))) 
           (let ((pV36 (svref pV33 2))
                 (pV35 (svref pV33 1))
                 (pV34 (svref pV33 0))) 
             (return 
              (if (SPLAYSET::|!member| qids pV34) 
                  (progn (UTILITIES::|!error| 
                          env 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            "The sort " 
                            (METASLANG::printQualifiedId pV34)) 
                           " is recursively defined using itself") 
                          pV36) 
                         unlinked_sort) 
                  (let ((pV28 (STANDARDSPEC::findAllSorts (svref env 5) pV34))) 
                    (block 
                     nil 
                     (if (consp pV28) 
                         (let ((pV30 (car pV28))) 
                           (return 
                            (let ((pV24 (svref pV30 2))
                                  (pV22 (svref pV30 0))) 
                              (block 
                               nil 
                               (if (consp pV22) 
                                   (if (null pV24) 
                                       (return 
                                        (let ((l1 
                                               (LIST-SPEC::|!length| 
                                                (svref pV30 1)))) 
                                          (let ((l2 (LIST-SPEC::|!length| pV35))) 
                                            (progn (if (BOOLEAN-SPEC::~ 
                                                        ( =  l1 l2)) 
                                                       (UTILITIES::|!error| 
                                                        env 
                                                        "
  Instantiation list does not match argument list" 
                                                        pV36) 
                                                       nil) 
                                                   (cons 
                                                    :|Base| 
                                                    (vector (car pV22) pV35 pV36)))))))) 
                               (return 
                                (let ((possible_base_def 
                                       (LIST-SPEC::|!find|-1-1 
                                        #'(lambda (srt_def) 
                                           (block 
                                            nil 
                                            (if (eq (car (cdr srt_def)) :|Base|) 
                                                (return t)) 
                                            (return nil))) 
                                        pV24))) 
                                  (block 
                                   nil 
                                   (if (eq (car possible_base_def) :|Some|) 
                                       (let ((pV15 (cdr possible_base_def))) 
                                         (let ((pV17 (cdr pV15))) 
                                           (if (eq (car pV17) :|Base|) 
                                               (return 
                                                (UTILITIES::unfoldPSortRec 
                                                 env 
                                                 (UTILITIES::instantiateScheme 
                                                  env 
                                                  (svref (cdr pV17) 2) 
                                                  pV35 
                                                  (car pV15) 
                                                  pV17) 
                                                 (LIST-SPEC::foldl-1-1-1 
                                                  #'(lambda (x1) 
                                                     (SPLAYSET::add 
                                                      (cdr x1) 
                                                      (car x1))) 
                                                  qids 
                                                  pV22))))))) 
                                   (return 
                                    (let ((pV11 (LIST-SPEC::hd pV24))) 
                                      (block 
                                       nil 
                                       (return 
                                        (UTILITIES::instantiateScheme 
                                         env 
                                         pV36 
                                         pV35 
                                         (car pV11) 
                                         (cdr pV11))) 
                                       (error 
                                        "Nonexhaustive match failure in unfoldPSortRec"))))))) 
                               (error 
                                "Nonexhaustive match failure in unfoldPSortRec"))))) 
                         (if (null pV28) 
                             (return 
                              (progn (UTILITIES::|!error| 
                                      env 
                                      (STRING-SPEC::^ 
                                       "Could not find definition of sort " 
                                       (METASLANG::printQualifiedId pV34)) 
                                      pV36) 
                                     unlinked_sort)))) 
                     (error "Nonexhaustive match failure in unfoldPSortRec")))))))) 
     (return unlinked_sort))))

(defun UTILITIES::unfoldPSort (env srt) 
  (UTILITIES::unfoldPSortRec env srt (SPLAYSET::empty #'UTILITIES::compareQId-1)))


(defun UTILITIES::unifyL (srt1 srt2 l1 l2 pairs unify) 
  (block 
   nil 
   (if (null l1) 
       (if (null l2) (return (cons :|Unify| pairs))) 
       (if (consp l1) 
           (if (consp l2) 
               (return 
                (let ((pV1 (funcall unify (vector (car l1) (car l2) pairs)))) 
                  (block 
                   nil 
                   (if (eq (car pV1) :|Unify|) 
                       (return 
                        (UTILITIES::unifyL 
                         srt1 
                         srt2 
                         (cdr l1) 
                         (cdr l2) 
                         (cdr pV1) 
                         unify))) 
                   (return pV1))))))) 
   (return (cons :|NotUnify| (cons srt1 srt2)))))

(defun UTILITIES::unifySorts-1-1-1 (env s1 s2) 
  (labels 
    ((unify (s1 s2 pairs) 
      (let ((pos1 (METASLANG::sortAnn s1))) 
        (let ((pos2 (METASLANG::sortAnn s2))) 
          (let ((srt1 (METASLANG::withAnnS (UTILITIES::unlinkPSort s1) pos1))) 
            (let ((srt2 (METASLANG::withAnnS (UTILITIES::unlinkPSort s2) pos2))) 
              (if (METASLANG::equalSort? srt1 srt2) 
                  (cons :|Unify| pairs) 
                  (block 
                   nil 
                   (if (eq (car srt1) :|CoProduct|) 
                       (if (eq (car srt2) :|CoProduct|) 
                           (return 
                            (unifyCP 
                             srt1 
                             srt2 
                             (car (cdr srt1)) 
                             (car (cdr srt2)) 
                             pairs))) 
                       (if (eq (car srt1) :|Product|) 
                           (if (eq (car srt2) :|Product|) 
                               (return 
                                (unifyP 
                                 srt1 
                                 srt2 
                                 (car (cdr srt1)) 
                                 (car (cdr srt2)) 
                                 pairs))) 
                           (if (eq (car srt1) :|Arrow|) 
                               (let ((pV63 (cdr srt1))) 
                                 (if (eq (car srt2) :|Arrow|) 
                                     (let ((pV90 (cdr srt2))) 
                                       (return 
                                        (let ((pV26 
                                               (unify 
                                                (svref pV63 0) 
                                                (svref pV90 0) 
                                                pairs))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV26) :|Unify|) 
                                               (return 
                                                (unify 
                                                 (svref pV63 1) 
                                                 (svref pV90 1) 
                                                 (cdr pV26)))) 
                                           (return pV26))))))) 
                               (if (eq (car srt1) :|Quotient|) 
                                   (if (eq (car srt2) :|Quotient|) 
                                       (return 
                                        (unify 
                                         (svref (cdr srt1) 0) 
                                         (svref (cdr srt2) 0) 
                                         pairs))) 
                                   (if (eq (car srt1) :|Base|) 
                                       (let ((pV61 (cdr srt1))) 
                                         (if (eq (car srt2) :|Base|) 
                                             (let ((pV76 (cdr srt2))) 
                                               (return 
                                                (if (LIST-SPEC::|!exists|-1-1 
                                                     #'(lambda (x) 
                                                        (cl:and 
                                                         (METASLANG::equalSort? 
                                                          (car x) 
                                                          srt1) 
                                                         (METASLANG::equalSort? 
                                                          (cdr x) 
                                                          srt2))) 
                                                     pairs) 
                                                    (cons :|Unify| pairs) 
                                                    (if (slang-built-in::slang-term-equals 
                                                         (svref pV61 0) 
                                                         (svref pV76 0)) 
                                                        (UTILITIES::unifyL 
                                                         srt1 
                                                         srt2 
                                                         (svref pV61 1) 
                                                         (svref pV76 1) 
                                                         pairs 
                                                         #'(lambda (x) 
                                                            (unify 
                                                             (svref x 0) 
                                                             (svref x 1) 
                                                             (svref x 2)))) 
                                                        (let ((s1_ 
                                                               (UTILITIES::unfoldPSort 
                                                                env 
                                                                srt1))) 
                                                          (let ((s2_ 
                                                                 (UTILITIES::unfoldPSort 
                                                                  env 
                                                                  srt2))) 
                                                            (if (cl:and 
                                                                 (METASLANG::equalSort? 
                                                                  s1 
                                                                  s1_) 
                                                                 (METASLANG::equalSort? 
                                                                  s2_ 
                                                                  s2)) 
                                                                (cons 
                                                                 :|NotUnify| 
                                                                 (cons srt1 srt2)) 
                                                                (unify 
                                                                 (METASLANG::withAnnS 
                                                                  s1_ 
                                                                  (svref pV61 2)) 
                                                                 (METASLANG::withAnnS 
                                                                  s2_ 
                                                                  (svref pV76 2)) 
                                                                 (LIST-SPEC::|!cons| 
                                                                  (cons s1 s2) 
                                                                  pairs))))))))))) 
                                       (if (eq (car srt1) :|TyVar|) 
                                           (if (eq (car srt2) :|TyVar|) 
                                               (return 
                                                (if (string=  
                                                     (car (cdr srt1)) 
                                                     (car (cdr srt2))) 
                                                    (cons :|Unify| pairs) 
                                                    (cons 
                                                     :|NotUnify| 
                                                     (cons srt1 srt2))))) 
                                           (if (eq (car srt1) :|MetaTyVar|) 
                                               (let ((pV66 (car (cdr srt1)))) 
                                                 (return 
                                                  (let ((s2_ 
                                                         (UTILITIES::unfoldPSort 
                                                          env 
                                                          srt2))) 
                                                    (let ((|!t| 
                                                           (UTILITIES::unlinkPSort 
                                                            s2_))) 
                                                      (if (METASLANG::equalSort? 
                                                           |!t| 
                                                           s1) 
                                                          (cons :|Unify| pairs) 
                                                          (if (UTILITIES::occurs 
                                                               pV66 
                                                               |!t|) 
                                                              (cons 
                                                               :|NotUnify| 
                                                               (cons srt1 srt2)) 
                                                              (progn (UTILITIES::linkMetaTyVar-1-1 
                                                                      pV66 
                                                                      (METASLANG::withAnnS 
                                                                       s2 
                                                                       pos2)) 
                                                                     (cons 
                                                                      :|Unify| 
                                                                      pairs))))))))))))))) 
                   (if (eq (car srt2) :|MetaTyVar|) 
                       (let ((pV57 (car (cdr srt2)))) 
                         (return 
                          (let ((|!t| (UTILITIES::unfoldPSort env srt1))) 
                            (let ((|!t| (UTILITIES::unlinkPSort |!t|))) 
                              (if (METASLANG::equalSort? |!t| s2) 
                                  (cons :|Unify| pairs) 
                                  (if (UTILITIES::occurs pV57 |!t|) 
                                      (cons :|NotUnify| (cons srt1 srt2)) 
                                      (progn (UTILITIES::linkMetaTyVar-1-1 
                                              pV57 
                                              (METASLANG::withAnnS s1 pos1)) 
                                             (cons :|Unify| pairs))))))))) 
                   (if (eq (car srt1) :|Subsort|) 
                       (return (unify (svref (cdr srt1) 0) srt2 pairs))) 
                   (if (eq (car srt2) :|Subsort|) 
                       (return (unify srt1 (svref (cdr srt2) 0) pairs))) 
                   (if (eq (car srt1) :|Base|) 
                       (return 
                        (let ((s1_ (UTILITIES::unfoldPSort env srt1))) 
                          (if (METASLANG::equalSort? s1 s1_) 
                              (cons :|NotUnify| (cons srt1 srt2)) 
                              (unify s1_ s2 pairs))))) 
                   (if (eq (car srt2) :|Base|) 
                       (return 
                        (let ((s2_ (UTILITIES::unfoldPSort env srt2))) 
                          (if (METASLANG::equalSort? s2 s2_) 
                              (cons :|NotUnify| (cons srt1 srt2)) 
                              (unify s1 s2_ pairs))))) 
                   (return (cons :|NotUnify| (cons srt1 srt2))))))))))
     (unifyP (srt1 srt2 r1 r2 pairs) 
      (UTILITIES::unifyL 
       srt1 
       srt2 
       r1 
       r2 
       pairs 
       #'(lambda (x) 
          (let ((pV13 (svref x 0))
                (pV14 (svref x 1))) 
            (block 
             nil 
             (return 
              (if (string=  (car pV13) (car pV14)) 
                  (unify (cdr pV13) (cdr pV14) (svref x 2)) 
                  (cons :|NotUnify| (cons srt1 srt2)))) 
             (error "Nonexhaustive match failure in unifySorts"))))))
     (unifyCP (srt1 srt2 r1 r2 pairs) 
      (UTILITIES::unifyL 
       srt1 
       srt2 
       r1 
       r2 
       pairs 
       #'(lambda (x) 
          (let ((pV6 (svref x 0))
                (pV7 (svref x 1))
                (pV8 (svref x 2))) 
            (block 
             nil 
             (let ((pV10 (cdr pV6))) 
               (let ((pV12 (cdr pV7))) 
                 (return 
                  (if (string=  (car pV6) (car pV7)) 
                      (block 
                       nil 
                       (if (eq (car pV10) :|None|) 
                           (if (eq (car pV12) :|None|) 
                               (return (cons :|Unify| pV8))) 
                           (if (eq (car pV10) :|Some|) 
                               (if (eq (car pV12) :|Some|) 
                                   (return (unify (cdr pV10) (cdr pV12) pV8))))) 
                       (return (cons :|NotUnify| (cons srt1 srt2)))) 
                      (cons :|NotUnify| (cons srt1 srt2)))))) 
             (error "Nonexhaustive match failure in unifySorts"))))))) 
    (let ((pV105 (unify s1 s2 nil))) 
      (block 
       nil 
       (if (eq (car pV105) :|Unify|) 
           (return (cons t "")) 
           (if (eq (car pV105) :|NotUnify|) 
               (let ((pV106 (cdr pV105))) 
                 (return 
                  (cons 
                   nil 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (ANNSPECPRINTER::printSort (car pV106)) 
                     " ! = ") 
                    (ANNSPECPRINTER::printSort (cdr pV106)))))))) 
       (error "Nonexhaustive match failure in unifySorts")))))

(defun TYPECHECKER::elaborateSortForTerm (env term givenSort expectedSort) 
  (let ((pV1 (UTILITIES::unifySorts-1-1-1 env givenSort expectedSort))) 
    (block 
     nil 
     (return 
      (progn (if (car pV1) 
                 nil 
                 (let ((pos (METASLANG::termAnn term))) 
                   (let ((termString (ANNSPECPRINTER::printTerm term))) 
                     (let ((tsLength (STRING-SPEC::|!length| termString))) 
                       (let ((fillerA 
                              (TYPECHECKER::blankString 
                               (INTEGER-SPEC::|!-| 10 tsLength)))) 
                         (let ((fillerB 
                                (TYPECHECKER::blankString 
                                 (INTEGER-SPEC::|!-| tsLength 10)))) 
                           (UTILITIES::|!error| 
                            env 
                            (TYPECHECKER::newLines 
                             (cons 
                              " Could not match sort constraint" 
                              (cons 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ fillerA termString) 
                                 " of sort ") 
                                (ANNSPECPRINTER::printSort givenSort)) 
                               (cons 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ fillerB "with expected sort ") 
                                 (ANNSPECPRINTER::printSort expectedSort)) 
                                nil)))) 
                            pos))))))) 
             givenSort)) 
     (error "Nonexhaustive match failure in elaborateSortForTerm"))))

(defun TYPECHECKER::elaborateCheckSortForTerm (env term givenSort expectedSort) 
  (TYPECHECKER::elaborateSortForTerm 
   env 
   term 
   (TYPECHECKER::checkSort env givenSort) 
   expectedSort))

(defun TYPECHECKER::elaborateSort (env s1 s2) 
  (let ((s1Checked (TYPECHECKER::checkSort env s1))) 
    (let ((pV1 (UTILITIES::unifySorts-1-1-1 env s1Checked s2))) 
      (block 
       nil 
       (return 
        (progn (if (car pV1) 
                   nil 
                   (UTILITIES::|!error| 
                    env 
                    (TYPECHECKER::newLines 
                     (cons 
                      (STRING-SPEC::^ 
                       "Could not match sort " 
                       (ANNSPECPRINTER::printSort s1)) 
                      (cons 
                       (STRING-SPEC::^ 
                        "                with " 
                        (ANNSPECPRINTER::printSort s2)) 
                       nil))) 
                    (POSITION-SPEC::chooseNonZeroPos 
                     (METASLANG::sortAnn s1) 
                     (METASLANG::sortAnn s2)))) 
               s1Checked)) 
       (error "Nonexhaustive match failure in elaborateSort")))))

(defun TYPECHECKER::lookupEmbedId (env id srt) 
  (let ((pV12 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV12) :|CoProduct|) 
         (let ((pV18 (car (cdr pV12)))) 
           (return 
            (labels 
              ((lookup (row) 
                (block 
                 nil 
                 (if (null row) 
                     (return '(:|None|)) 
                     (if (consp row) 
                         (let ((pV6 (car row))) 
                           (let ((pV9 (cdr pV6))) 
                             (return 
                              (if (string=  id (car pV6)) 
                                  (cons 
                                   :|Some| 
                                   (block 
                                    nil 
                                    (if (eq (car pV9) :|None|) 
                                        (return '(:|None|)) 
                                        (if (eq (car pV9) :|Some|) 
                                            (return 
                                             (cons 
                                              :|Some| 
                                              (TYPECHECKER::checkSort 
                                               env 
                                               (cdr pV9)))))) 
                                    (error 
                                     "Nonexhaustive match failure in lookupEmbedId"))) 
                                  (lookup (cdr row)))))))) 
                 (error "Nonexhaustive match failure in lookupEmbedId")))) 
              (lookup pV18)))) 
         (if (eq (car pV12) :|Subsort|) 
             (return (TYPECHECKER::lookupEmbedId env id (svref (cdr pV12) 0))))) 
     (return '(:|None|)))))

(defparameter TYPECHECKER::type_bool POSSPEC::boolPSort)

(defparameter TYPECHECKER::type_char POSSPEC::charPSort)

(defparameter TYPECHECKER::type_nat POSSPEC::natPSort)

(defparameter TYPECHECKER::type_string POSSPEC::stringPSort)

(defun TYPECHECKER::undeterminedSort? (srt) 
  (let ((pV3 (UTILITIES::unlinkPSort srt))) 
    (block nil (if (eq (car pV3) :|MetaTyVar|) (return t)) (return nil))))

(defun UTILITIES::addVariable (pV1 pV2 pV3) 
  (block 
   nil 
   (return 
    (vector 
     (svref pV1 0) 
     (svref pV1 1) 
     (svref pV1 2) 
     (svref pV1 3) 
     (svref pV1 4) 
     (svref pV1 5) 
     (STRINGMAP::insert (svref pV1 6) pV2 pV3))) 
   (error "Nonexhaustive match failure in addVariable")))

(defun UTILITIES::copySort-1 (x) (UTILITIES::copySort (car x) (cdr x)))

(defun TYPECHECKER::elaboratePattern (env p sort1) 
  (let ((sort1 (TYPECHECKER::checkSort env sort1))) 
    (labels 
      ((elab (p) 
        (block 
         nil 
         (if (eq (car p) :|WildPat|) 
             (let ((pV100 (cdr p))) 
               (return 
                (cons 
                 (cons 
                  :|WildPat| 
                  (cons 
                   (TYPECHECKER::elaborateSort env (car pV100) sort1) 
                   (cdr pV100))) 
                 env))) 
             (if (eq (car p) :|BoolPat|) 
                 (return 
                  (progn (TYPECHECKER::elaborateSort 
                          env 
                          sort1 
                          TYPECHECKER::type_bool) 
                         (cons p env))) 
                 (if (eq (car p) :|NatPat|) 
                     (return 
                      (progn (TYPECHECKER::elaborateSort 
                              env 
                              sort1 
                              TYPECHECKER::type_nat) 
                             (cons p env))) 
                     (if (eq (car p) :|StringPat|) 
                         (return 
                          (progn (TYPECHECKER::elaborateSort 
                                  env 
                                  sort1 
                                  TYPECHECKER::type_string) 
                                 (cons p env))) 
                         (if (eq (car p) :|CharPat|) 
                             (return 
                              (progn (TYPECHECKER::elaborateSort 
                                      env 
                                      sort1 
                                      TYPECHECKER::type_char) 
                                     (cons p env))) 
                             (if (eq (car p) :|VarPat|) 
                                 (let ((pV95 (cdr p))) 
                                   (let ((pV120 (cdr pV95))
                                         (pV119 (car pV95))) 
                                     (let ((pV121 (car pV119))) 
                                       (return 
                                        (let ((srt 
                                               (TYPECHECKER::elaborateSort 
                                                env 
                                                (cdr pV119) 
                                                sort1))) 
                                          (let ((pV16 
                                                 (TYPECHECKER::lookupEmbedId 
                                                  env 
                                                  pV121 
                                                  srt))) 
                                            (block 
                                             nil 
                                             (if (eq (car pV16) :|Some|) 
                                                 (progn (if (eq 
                                                             (car (cdr pV16)) 
                                                             :|None|) 
                                                            (return 
                                                             (cons 
                                                              (cons 
                                                               :|EmbedPat| 
                                                               (vector 
                                                                pV121 
                                                                '(:|None|) 
                                                                srt 
                                                                pV120)) 
                                                              env))) 
                                                        (return 
                                                         (progn (UTILITIES::|!error| 
                                                                 env 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   "Constructor " 
                                                                   pV121) 
                                                                  " expects an argument, but was given none") 
                                                                 pV120) 
                                                                (cons 
                                                                 (cons 
                                                                  :|VarPat| 
                                                                  (cons 
                                                                   (cons 
                                                                    pV121 
                                                                    srt) 
                                                                   pV120)) 
                                                                 env)))) 
                                                 (if (eq (car pV16) :|None|) 
                                                     (return 
                                                      (if (TYPECHECKER::undeterminedSort? 
                                                           srt) 
                                                          (let ((pV11 
                                                                 (STRINGMAP::|!find| 
                                                                  (svref env 0) 
                                                                  pV121))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV11) 
                                                                  :|None|) 
                                                                 (return 
                                                                  (cons 
                                                                   (cons 
                                                                    :|VarPat| 
                                                                    (cons 
                                                                     (cons 
                                                                      pV121 
                                                                      srt) 
                                                                     pV120)) 
                                                                   (UTILITIES::addVariable 
                                                                    env 
                                                                    pV121 
                                                                    srt))) 
                                                                 (if (eq 
                                                                      (car pV11) 
                                                                      :|Some|) 
                                                                     (let ((pV12 
                                                                            (cdr 
                                                                             pV11))) 
                                                                       (progn (if (consp 
                                                                                   pV12) 
                                                                                  (if (null 
                                                                                       (cdr 
                                                                                        pV12)) 
                                                                                      (return 
                                                                                       (let ((pV7 
                                                                                              (UTILITIES::copySort-1 
                                                                                               (car 
                                                                                                pV12)))) 
                                                                                         (block 
                                                                                          nil 
                                                                                          (return 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             :|VarPat| 
                                                                                             (cons 
                                                                                              (cons 
                                                                                               pV121 
                                                                                               (cdr 
                                                                                                pV7)) 
                                                                                              pV120)) 
                                                                                            env)) 
                                                                                          (error 
                                                                                           "Nonexhaustive match failure in elaboratePattern")))))) 
                                                                              (return 
                                                                               (cons 
                                                                                (cons 
                                                                                 :|VarPat| 
                                                                                 (cons 
                                                                                  (cons 
                                                                                   pV121 
                                                                                   srt) 
                                                                                  pV120)) 
                                                                                env)))))) 
                                                             (error 
                                                              "Nonexhaustive match failure in elaboratePattern"))) 
                                                          (cons 
                                                           (cons 
                                                            :|VarPat| 
                                                            (cons 
                                                             (cons pV121 srt) 
                                                             pV120)) 
                                                           (UTILITIES::addVariable 
                                                            env 
                                                            pV121 
                                                            srt)))))) 
                                             (error 
                                              "Nonexhaustive match failure in elaboratePattern")))))))) 
                                 (if (eq (car p) :|SortedPat|) 
                                     (let ((pV94 (cdr p))) 
                                       (return 
                                        (let ((srt 
                                               (TYPECHECKER::elaborateSort 
                                                env 
                                                (svref pV94 1) 
                                                sort1))) 
                                          (let ((pV19 
                                                 (TYPECHECKER::elaboratePattern 
                                                  env 
                                                  (svref pV94 0) 
                                                  srt))) 
                                            (block 
                                             nil 
                                             (return 
                                              (cons (car pV19) (cdr pV19))) 
                                             (error 
                                              "Nonexhaustive match failure in elaboratePattern")))))) 
                                     (if (eq (car p) :|AliasPat|) 
                                         (let ((pV93 (cdr p))) 
                                           (return 
                                            (let ((pV25 
                                                   (TYPECHECKER::elaboratePattern 
                                                    env 
                                                    (svref pV93 0) 
                                                    sort1))) 
                                              (block 
                                               nil 
                                               (return 
                                                (let ((pV22 
                                                       (TYPECHECKER::elaboratePattern 
                                                        (cdr pV25) 
                                                        (svref pV93 1) 
                                                        sort1))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (cons 
                                                     (cons 
                                                      :|AliasPat| 
                                                      (vector 
                                                       (car pV25) 
                                                       (car pV22) 
                                                       (svref pV93 2))) 
                                                     (cdr pV22))) 
                                                   (error 
                                                    "Nonexhaustive match failure in elaboratePattern")))) 
                                               (error 
                                                "Nonexhaustive match failure in elaboratePattern"))))) 
                                         (if (eq (car p) :|EmbedPat|) 
                                             (let ((pV92 (cdr p))) 
                                               (let ((pV112 (svref pV92 3))
                                                     (pV110 (svref pV92 1))
                                                     (pV109 (svref pV92 0))) 
                                                 (return 
                                                  (let ((sort0 
                                                         (TYPECHECKER::elaborateSort 
                                                          env 
                                                          (svref pV92 2) 
                                                          sort1))) 
                                                    (let ((sort0 
                                                           (if (TYPECHECKER::undeterminedSort? 
                                                                sort0) 
                                                               (let ((pV33 
                                                                      (STRINGMAP::|!find| 
                                                                       (svref 
                                                                        env 
                                                                        0) 
                                                                       pV109))) 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car pV33) 
                                                                       :|Some|) 
                                                                      (let ((pV34 
                                                                             (cdr 
                                                                              pV33))) 
                                                                        (if (consp 
                                                                             pV34) 
                                                                            (if (null 
                                                                                 (cdr 
                                                                                  pV34)) 
                                                                                (return 
                                                                                 (let ((pV29 
                                                                                        (UTILITIES::copySort-1 
                                                                                         (car 
                                                                                          pV34)))) 
                                                                                   (block 
                                                                                    nil 
                                                                                    (return 
                                                                                     (TYPECHECKER::elaborateSort 
                                                                                      env 
                                                                                      (cdr 
                                                                                       pV29) 
                                                                                      sort1)) 
                                                                                    (error 
                                                                                     "Nonexhaustive match failure in elaboratePattern")))))))) 
                                                                  (return sort0))) 
                                                               sort0))) 
                                                      (if (cl:and 
                                                           (svref env 3) 
                                                           (TYPECHECKER::undeterminedSort? 
                                                            sort0)) 
                                                          (let ((pV43 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV110) 
                                                                       :|None|) 
                                                                      (return 
                                                                       (cons 
                                                                        env 
                                                                        '(:|None|))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV110) 
                                                                           :|Some|) 
                                                                          (return 
                                                                           (let ((alpha 
                                                                                  (UTILITIES::freshMetaTyVar 
                                                                                   pV112))) 
                                                                             (let ((pV38 
                                                                                    (TYPECHECKER::elaboratePattern 
                                                                                     env 
                                                                                     (cdr 
                                                                                      pV110) 
                                                                                     alpha))) 
                                                                               (block 
                                                                                nil 
                                                                                (return 
                                                                                 (cons 
                                                                                  (cdr 
                                                                                   pV38) 
                                                                                  (cons 
                                                                                   :|Some| 
                                                                                   (car 
                                                                                    pV38)))) 
                                                                                (error 
                                                                                 "Nonexhaustive match failure in elaboratePattern"))))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in elaboratePattern")))) 
                                                            (block 
                                                             nil 
                                                             (return 
                                                              (cons 
                                                               (cons 
                                                                :|EmbedPat| 
                                                                (vector 
                                                                 pV109 
                                                                 (cdr pV43) 
                                                                 sort0 
                                                                 pV112)) 
                                                               (car pV43))) 
                                                             (error 
                                                              "Nonexhaustive match failure in elaboratePattern"))) 
                                                          (let ((srt 
                                                                 (TYPECHECKER::lookupEmbedId 
                                                                  env 
                                                                  pV109 
                                                                  sort0))) 
                                                            (let ((pV60 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          srt) 
                                                                         :|None|) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV110) 
                                                                             :|None|) 
                                                                            (return 
                                                                             (progn (UTILITIES::|!error| 
                                                                                     env 
                                                                                     (STRING-SPEC::^ 
                                                                                      (STRING-SPEC::^ 
                                                                                       (STRING-SPEC::^ 
                                                                                        "Sort for constructor " 
                                                                                        pV109) 
                                                                                       " not found. Resolving with sort ") 
                                                                                      (ANNSPECPRINTER::printSort 
                                                                                       sort1)) 
                                                                                     pV112) 
                                                                                    (cons 
                                                                                     env 
                                                                                     '(:|None|)))) 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV110) 
                                                                                 :|Some|) 
                                                                                (return 
                                                                                 (let ((alpha 
                                                                                        (UTILITIES::freshMetaTyVar 
                                                                                         pV112))) 
                                                                                   (let ((pV49 
                                                                                          (TYPECHECKER::elaboratePattern 
                                                                                           env 
                                                                                           (cdr 
                                                                                            pV110) 
                                                                                           alpha))) 
                                                                                     (block 
                                                                                      nil 
                                                                                      (let ((pV51 
                                                                                             (cdr 
                                                                                              pV49))) 
                                                                                        (return 
                                                                                         (progn (UTILITIES::|!error| 
                                                                                                 pV51 
                                                                                                 (STRING-SPEC::^ 
                                                                                                  (STRING-SPEC::^ 
                                                                                                   (STRING-SPEC::^ 
                                                                                                    "Sort for constructor " 
                                                                                                    pV109) 
                                                                                                   " not found. Resolving with sort ") 
                                                                                                  (ANNSPECPRINTER::printSort 
                                                                                                   sort1)) 
                                                                                                 pV112) 
                                                                                                (cons 
                                                                                                 pV51 
                                                                                                 '(:|None|))))) 
                                                                                      (error 
                                                                                       "Nonexhaustive match failure in elaboratePattern"))))))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              srt) 
                                                                             :|Some|) 
                                                                            (let ((pV55 
                                                                                   (cdr 
                                                                                    srt))) 
                                                                              (if (eq 
                                                                                   (car 
                                                                                    pV55) 
                                                                                   :|None|) 
                                                                                  (if (eq 
                                                                                       (car 
                                                                                        pV110) 
                                                                                       :|None|) 
                                                                                      (return 
                                                                                       (cons 
                                                                                        env 
                                                                                        '(:|None|))) 
                                                                                      (if (eq 
                                                                                           (car 
                                                                                            pV110) 
                                                                                           :|Some|) 
                                                                                          (let ((pV58 
                                                                                                 (cdr 
                                                                                                  pV110))) 
                                                                                            (return 
                                                                                             (progn (UTILITIES::|!error| 
                                                                                                     env 
                                                                                                     (TYPECHECKER::newLines 
                                                                                                      (cons 
                                                                                                       (STRING-SPEC::^ 
                                                                                                        (STRING-SPEC::^ 
                                                                                                         "Constructor " 
                                                                                                         pV109) 
                                                                                                        " takes no argument") 
                                                                                                       (cons 
                                                                                                        (STRING-SPEC::^ 
                                                                                                         "but was given " 
                                                                                                         (ANNSPECPRINTER::printPattern 
                                                                                                          pV58)) 
                                                                                                        nil))) 
                                                                                                     pV112) 
                                                                                                    (cons 
                                                                                                     env 
                                                                                                     (cons 
                                                                                                      :|Some| 
                                                                                                      pV58))))))) 
                                                                                  (if (eq 
                                                                                       (car 
                                                                                        pV55) 
                                                                                       :|Some|) 
                                                                                      (if (eq 
                                                                                           (car 
                                                                                            pV110) 
                                                                                           :|Some|) 
                                                                                          (return 
                                                                                           (let ((pV46 
                                                                                                  (TYPECHECKER::elaboratePattern 
                                                                                                   env 
                                                                                                   (cdr 
                                                                                                    pV110) 
                                                                                                   (cdr 
                                                                                                    pV55)))) 
                                                                                             (block 
                                                                                              nil 
                                                                                              (return 
                                                                                               (cons 
                                                                                                (cdr 
                                                                                                 pV46) 
                                                                                                (cons 
                                                                                                 :|Some| 
                                                                                                 (car 
                                                                                                  pV46)))) 
                                                                                              (error 
                                                                                               "Nonexhaustive match failure in elaboratePattern")))) 
                                                                                          (if (eq 
                                                                                               (car 
                                                                                                pV110) 
                                                                                               :|None|) 
                                                                                              (return 
                                                                                               (progn (UTILITIES::|!error| 
                                                                                                       env 
                                                                                                       (STRING-SPEC::^ 
                                                                                                        "Argument expected for constructor " 
                                                                                                        pV109) 
                                                                                                       pV112) 
                                                                                                      (cons 
                                                                                                       env 
                                                                                                       '(:|None|))))))))))) 
                                                                    (error 
                                                                     "Nonexhaustive match failure in elaboratePattern")))) 
                                                              (block 
                                                               nil 
                                                               (return 
                                                                (cons 
                                                                 (cons 
                                                                  :|EmbedPat| 
                                                                  (vector 
                                                                   pV109 
                                                                   (cdr pV60) 
                                                                   sort1 
                                                                   pV112)) 
                                                                 (car pV60))) 
                                                               (error 
                                                                "Nonexhaustive match failure in elaboratePattern")))))))))) 
                                             (if (eq (car p) :|RecordPat|) 
                                                 (let ((pV91 (cdr p))) 
                                                   (let ((pV108 (cdr pV91))
                                                         (pV107 (car pV91))) 
                                                     (return 
                                                      (let ((r 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'(lambda (x) 
                                                                 (cons 
                                                                  (car x) 
                                                                  (UTILITIES::freshMetaTyVar 
                                                                   pV108))) 
                                                              pV107))) 
                                                        (progn (TYPECHECKER::elaborateSort 
                                                                env 
                                                                (cons 
                                                                 :|Product| 
                                                                 (cons r pV108)) 
                                                                sort1) 
                                                               (let ((r 
                                                                      (LISTPAIR::zip 
                                                                       r 
                                                                       pV107))) 
                                                                 (let ((pV78 
                                                                        (LIST-SPEC::foldr-1-1-1 
                                                                         #'(lambda (x) 
                                                                            (let ((pV69 
                                                                                   (cdr 
                                                                                    x))
                                                                                  (pV68 
                                                                                   (car 
                                                                                    x))) 
                                                                              (block 
                                                                               nil 
                                                                               (let ((pV70 
                                                                                      (car 
                                                                                       pV68))) 
                                                                                 (return 
                                                                                  (let ((pV65 
                                                                                         (TYPECHECKER::elaboratePattern 
                                                                                          (cdr 
                                                                                           pV69) 
                                                                                          (cdr 
                                                                                           (cdr 
                                                                                            pV68)) 
                                                                                          (cdr 
                                                                                           pV70)))) 
                                                                                    (block 
                                                                                     nil 
                                                                                     (return 
                                                                                      (cons 
                                                                                       (LIST-SPEC::|!cons| 
                                                                                        (cons 
                                                                                         (car 
                                                                                          pV70) 
                                                                                         (car 
                                                                                          pV65)) 
                                                                                        (car 
                                                                                         pV69)) 
                                                                                       (cdr 
                                                                                        pV65))) 
                                                                                     (error 
                                                                                      "Nonexhaustive match failure in elaboratePattern"))))) 
                                                                               (error 
                                                                                "Nonexhaustive match failure in elaboratePattern")))) 
                                                                         (cons 
                                                                          nil 
                                                                          env) 
                                                                         r))) 
                                                                   (block 
                                                                    nil 
                                                                    (return 
                                                                     (cons 
                                                                      (cons 
                                                                       :|RecordPat| 
                                                                       (cons 
                                                                        (car 
                                                                         pV78) 
                                                                        pV108)) 
                                                                      (cdr pV78))) 
                                                                    (error 
                                                                     "Nonexhaustive match failure in elaboratePattern"))))))))) 
                                                 (if (eq (car p) :|RelaxPat|) 
                                                     (let ((pV90 (cdr p))) 
                                                       (let ((pV106 
                                                              (svref pV90 2))) 
                                                         (return 
                                                          (let ((term 
                                                                 (TYPECHECKER::elaborateTerm 
                                                                  env 
                                                                  (svref pV90 1) 
                                                                  (cons 
                                                                   :|Arrow| 
                                                                   (vector 
                                                                    sort1 
                                                                    TYPECHECKER::type_bool 
                                                                    pV106))))) 
                                                            (let ((pV81 
                                                                   (TYPECHECKER::elaboratePattern 
                                                                    env 
                                                                    (svref 
                                                                     pV90 
                                                                     0) 
                                                                    (cons 
                                                                     :|Subsort| 
                                                                     (vector 
                                                                      sort1 
                                                                      term 
                                                                      pV106))))) 
                                                              (block 
                                                               nil 
                                                               (return 
                                                                (cons 
                                                                 (cons 
                                                                  :|RelaxPat| 
                                                                  (vector 
                                                                   (car pV81) 
                                                                   term 
                                                                   pV106)) 
                                                                 (cdr pV81))) 
                                                               (error 
                                                                "Nonexhaustive match failure in elaboratePattern"))))))) 
                                                     (if (eq 
                                                          (car p) 
                                                          :|QuotientPat|) 
                                                         (let ((pV89 (cdr p))) 
                                                           (let ((pV103 
                                                                  (svref pV89 2))
                                                                 (pV102 
                                                                  (svref pV89 1))) 
                                                             (return 
                                                              (let ((v 
                                                                     (UTILITIES::freshMetaTyVar 
                                                                      pV103))) 
                                                                (progn (TYPECHECKER::elaborateSort 
                                                                        env 
                                                                        (cons 
                                                                         :|Quotient| 
                                                                         (vector 
                                                                          v 
                                                                          pV102 
                                                                          pV103)) 
                                                                        sort1) 
                                                                       (let ((term1 
                                                                              (TYPECHECKER::elaborateTerm 
                                                                               env 
                                                                               pV102 
                                                                               (cons 
                                                                                :|Arrow| 
                                                                                (vector 
                                                                                 (cons 
                                                                                  :|Product| 
                                                                                  (cons 
                                                                                   (cons 
                                                                                    (cons 
                                                                                     "1" 
                                                                                     v) 
                                                                                    (cons 
                                                                                     (cons 
                                                                                      "2" 
                                                                                      v) 
                                                                                     nil)) 
                                                                                   pV103)) 
                                                                                 TYPECHECKER::type_bool 
                                                                                 pV103))))) 
                                                                         (let ((pV85 
                                                                                (TYPECHECKER::elaboratePattern 
                                                                                 env 
                                                                                 (svref 
                                                                                  pV89 
                                                                                  0) 
                                                                                 v))) 
                                                                           (block 
                                                                            nil 
                                                                            (return 
                                                                             (cons 
                                                                              (cons 
                                                                               :|QuotientPat| 
                                                                               (vector 
                                                                                (car 
                                                                                 pV85) 
                                                                                term1 
                                                                                pV103)) 
                                                                              (cdr 
                                                                               pV85))) 
                                                                            (error 
                                                                             "Nonexhaustive match failure in elaboratePattern"))))))))))))))))))))) 
         (return 
          (progn (SYSTEM-SPEC::|!print| p) (SYSTEM-SPEC::fail "Nonexhaustive")))))) 
      (let ((pV125 (elab p))) 
        (block 
         nil 
         (return (cons (car pV125) (cdr pV125))) 
         (error "Nonexhaustive match failure in elaboratePattern"))))))

(defun TYPECHECKER::isCoproduct (env srt) 
  (let ((pV5 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV5) :|CoProduct|) 
         (return (cons :|Some| (car (cdr pV5)))) 
         (if (eq (car pV5) :|Subsort|) 
             (return (TYPECHECKER::isCoproduct env (svref (cdr pV5) 0))))) 
     (return '(:|None|)))))

(defun TYPECHECKER::mkEmbed0 (env srt id) 
  (let ((pV2 (TYPECHECKER::lookupEmbedId env id srt))) 
    (block 
     nil 
     (if (eq (car pV2) :|Some|) 
         (if (eq (car (cdr pV2)) :|None|) (return (cons :|Some| id)))) 
     (return '(:|None|)))))

(defun TYPECHECKER::isArrowCoProduct (env srt) 
  (let ((pV5 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV5) :|Arrow|) 
         (let ((pV6 (cdr pV5))) 
           (return 
            (let ((pV2 (TYPECHECKER::isCoproduct env (svref pV6 1)))) 
              (block 
               nil 
               (if (eq (car pV2) :|Some|) 
                   (return (cons :|Some| (cons (svref pV6 0) (cdr pV2)))) 
                   (if (eq (car pV2) :|None|) (return '(:|None|)))) 
               (error "Nonexhaustive match failure in isArrowCoProduct")))))) 
     (return '(:|None|)))))

(defun TYPECHECKER::undeclared (env fun id srt pos) 
  (if (svref env 3) 
      fun 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ "Name " id) 
               " has not been declared") 
              pos) 
             (cons :|Fun| (vector (cons :|OneName| (cons id nil)) srt pos)))))

(defun TYPECHECKER::mkEmbed1 (env srt trm id pos) 
  (let ((pV11 (TYPECHECKER::isArrowCoProduct env srt))) 
    (block 
     nil 
     (if (eq (car pV11) :|Some|) 
         (let ((pV12 (cdr pV11))) 
           (let ((pV14 (cdr pV12))
                 (pV13 (car pV12))) 
             (return 
              (labels 
                ((findId (ls) 
                  (block 
                   nil 
                   (if (null ls) 
                       (return 
                        (cons 
                         :|Some| 
                         (TYPECHECKER::undeclared env trm id srt pos))) 
                       (if (consp ls) 
                           (let ((pV6 (cdr ls))
                                 (pV5 (car ls))) 
                             (progn (let ((pV8 (cdr pV5))) 
                                      (if (eq (car pV8) :|Some|) 
                                          (return 
                                           (if (string=  id (car pV5)) 
                                               (let ((constructor_dom_sort 
                                                      (TYPECHECKER::checkSort 
                                                       env 
                                                       (cdr pV8)))) 
                                                 (progn (TYPECHECKER::elaborateSort 
                                                         env 
                                                         (METASLANG::withAnnS 
                                                          pV13 
                                                          pos) 
                                                         constructor_dom_sort) 
                                                        (cons 
                                                         :|Some| 
                                                         (cons 
                                                          :|Fun| 
                                                          (vector 
                                                           (cons 
                                                            :|Embed| 
                                                            (cons id t)) 
                                                           (TYPECHECKER::checkSort 
                                                            env 
                                                            srt) 
                                                           pos))))) 
                                               (findId pV6))))) 
                                    (return (findId pV6)))))) 
                   (error "Nonexhaustive match failure in mkEmbed1")))) 
                (findId pV14)))))) 
     (return '(:|None|)))))

(defun TYPECHECKER::mkProject (env id srt pos) 
  (let ((pV23 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV23) :|Arrow|) 
         (let ((pV25 (cdr pV23))) 
           (let ((pV30 (svref pV25 1))
                 (pV29 (svref pV25 0))) 
             (return 
              (labels 
                ((analyzeDom (dom) 
                  (let ((pV12 (UTILITIES::unfoldPSort env dom))) 
                    (block 
                     nil 
                     (if (eq (car pV12) :|Product|) 
                         (let ((pV18 (car (cdr pV12)))) 
                           (return 
                            (labels 
                              ((findId (ls) 
                                (block 
                                 nil 
                                 (if (null ls) 
                                     (return '(:|None|)) 
                                     (if (consp ls) 
                                         (let ((pV5 (car ls))) 
                                           (return 
                                            (if (string=  id (car pV5)) 
                                                (progn (TYPECHECKER::elaborateSort 
                                                        env 
                                                        (METASLANG::withAnnS 
                                                         pV30 
                                                         pos) 
                                                        (cdr pV5)) 
                                                       (cons 
                                                        :|Some| 
                                                        (cons 
                                                         :|Fun| 
                                                         (vector 
                                                          (cons :|Project| id) 
                                                          srt 
                                                          pos)))) 
                                                (findId (cdr ls))))))) 
                                 (error 
                                  "Nonexhaustive match failure in mkProject")))) 
                              (findId pV18)))) 
                         (if (eq (car pV12) :|Subsort|) 
                             (return (analyzeDom (svref (cdr pV12) 0))))) 
                     (return '(:|None|)))))) (analyzeDom pV29))))) 
         (if (eq (car pV23) :|Subsort|) 
             (return (TYPECHECKER::mkProject env id (svref (cdr pV23) 0) pos)))) 
     (return '(:|None|)))))

(defun TYPECHECKER::pass2Error (env pV1 msg pos) 
  (declare (ignore pV1)) 
  (if (svref env 3) nil (UTILITIES::|!error| env msg pos)))

(defun UTILITIES::clearMetaTyVarLinks (meta_ty_vars) 
  (LIST-SPEC::app-1-1 
   #'(lambda (mtv) 
      (let ((pV1 (STATE::|!!| mtv))) 
        (block 
         nil 
         (return 
          (STATE::|:=| mtv (vector '(:|None|) (svref pV1 1) (svref pV1 2)))) 
         (error "Nonexhaustive match failure in clearMetaTyVarLinks")))) 
   meta_ty_vars))

(defun UTILITIES::freeTypeVars (srt) 
  (let ((vars (cons :|Ref| nil))) 
    (labels 
      ((vr (srt) 
        (block 
         nil 
         (if (eq (car srt) :|MetaTyVar|) 
             (return 
              (let ((pV2 (UTILITIES::unlinkPSort srt))) 
                (block 
                 nil 
                 (if (eq (car pV2) :|MetaTyVar|) 
                     (return 
                      (progn (STATE::|:=| 
                              vars 
                              (LIST-SPEC::|!cons| 
                               (car (cdr pV2)) 
                               (STATE::|!!| vars))) 
                             srt))) 
                 (return 
                  (METASLANG::mapSort-1-1 
                   (vector #'(lambda (x) x) #'vr #'(lambda (x) x)) 
                   (METASLANG::withAnnS pV2 (cdr (cdr srt))))))))) 
         (return srt)))) 
      (progn (METASLANG::mapSort-1-1 
              (vector #'(lambda (x) x) #'vr #'(lambda (x) x)) 
              srt) 
             (STATE::|!!| vars)))))

(defun UTILITIES::consistentSorts? (env srt1 srt2) 
  (let ((free_meta_ty_vars 
         (LIST-SPEC::|!++| 
          (UTILITIES::freeTypeVars srt1) 
          (UTILITIES::freeTypeVars srt2)))) 
    (let ((pV2 (UTILITIES::unifySorts-1-1-1 env srt1 srt2))) 
      (block 
       nil 
       (return 
        (progn (UTILITIES::clearMetaTyVarLinks free_meta_ty_vars) (car pV2))) 
       (error "Nonexhaustive match failure in consistentSorts?")))))

(defun TYPECHECKER::consistentSortOp?-1-1 (!x1 pV3) 
  (block 
   nil 
   (if (eq (car pV3) :|Fun|) 
       (return 
        (UTILITIES::consistentSorts? (car !x1) (cdr !x1) (svref (cdr pV3) 1)))) 
   (error "Nonexhaustive match failure in consistentSortOp?")))

(defun TYPECHECKER::consistentSortOp?-1 (x1) 
  #'(lambda (x2) (TYPECHECKER::consistentSortOp?-1-1 x1 x2)))

(defun TYPECHECKER::consistentSortOp? (x0 x1) 
  (TYPECHECKER::consistentSortOp?-1 (cons x0 x1)))

(defun TYPECHECKER::selectTermWithConsistentSort (env id pos terms srt) 
  (block 
   nil 
   (if (consp terms) (if (null (cdr terms)) (return (cons :|Some| (car terms))))) 
   (return 
    (let ((pV52 (UTILITIES::unlinkPSort srt))) 
      (block 
       nil 
       (if (eq (car pV52) :|MetaTyVar|) (return '(:|None|))) 
       (return 
        (let ((srtPos (METASLANG::sortAnn srt))) 
          (let ((pV48 
                 (LIST-SPEC::filter-1-1 
                  (TYPECHECKER::consistentSortOp? 
                   env 
                   (METASLANG::withAnnS pV52 srtPos)) 
                  terms))) 
            (block 
             nil 
             (if (null pV48) 
                 (return 
                  (progn (UTILITIES::|!error| 
                          env 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ "No matches for op " id) 
                            " of sort ") 
                           (ANNSPECPRINTER::printSort srt)) 
                          pos) 
                         '(:|None|))) 
                 (if (consp pV48) 
                     (if (null (cdr pV48)) (return (cons :|Some| (car pV48)))))) 
             (return 
              (if (svref env 3) 
                  '(:|None|) 
                  (labels 
                    ((findUnqualified (tms) 
                      (block 
                       nil 
                       (if (null tms) 
                           (return '(:|None|)) 
                           (if (consp tms) 
                               (let ((pV27 (cdr tms))
                                     (pV26 (car tms))) 
                                 (return 
                                  (block 
                                   nil 
                                   (if (eq (car pV26) :|Fun|) 
                                       (let ((pV14 (svref (cdr pV26) 0))) 
                                         (if (eq (car pV14) :|OneName|) 
                                             (return (cons :|Some| pV26)) 
                                             (if (eq (car pV14) :|TwoNames|) 
                                                 (return 
                                                  (if (string=  
                                                       (svref (cdr pV14) 0) 
                                                       METASLANG::UnQualified) 
                                                      (cons :|Some| pV26) 
                                                      (findUnqualified pV27))))))) 
                                   (return (findUnqualified pV27))))))) 
                       (error 
                        "Nonexhaustive match failure in selectTermWithConsistentSort")))) 
                    (let ((pV46 (findUnqualified pV48))) 
                      (block 
                       nil 
                       (if (eq (car pV46) :|Some|) 
                           (return (cons :|Some| (cdr pV46))) 
                           (if (eq (car pV46) :|None|) 
                               (return 
                                (progn (UTILITIES::|!error| 
                                        env 
                                        (STRING-SPEC::^ 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ 
                                           (STRING-SPEC::^ 
                                            "Several matches for overloaded op " 
                                            id) 
                                           " of sort ") 
                                          (ANNSPECPRINTER::printSort srt)) 
                                         (LIST-SPEC::foldl-1-1-1 
                                          #'(lambda (x) 
                                             (let ((tm (car x))) 
                                               (STRING-SPEC::^ 
                                                (cdr x) 
                                                (block 
                                                 nil 
                                                 (if (eq (car tm) :|Fun|) 
                                                     (let ((pV36 
                                                            (svref (cdr tm) 0))) 
                                                       (if (eq 
                                                            (car pV36) 
                                                            :|OneName|) 
                                                           (return 
                                                            (STRING-SPEC::^ 
                                                             " " 
                                                             (car (cdr pV36)))) 
                                                           (if (eq 
                                                                (car pV36) 
                                                                :|TwoNames|) 
                                                               (let ((pV39 
                                                                      (cdr pV36))) 
                                                                 (return 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     " " 
                                                                     (svref 
                                                                      pV39 
                                                                      0)) 
                                                                    ".") 
                                                                   (svref pV39 1)))))))) 
                                                 (error 
                                                  "Nonexhaustive match failure in selectTermWithConsistentSort"))))) 
                                          " : " 
                                          terms)) 
                                        pos) 
                                       '(:|None|))))) 
                       (error 
                        "Nonexhaustive match failure in selectTermWithConsistentSort")))))))))))))))


(defun TYPECHECKER::undeclared2 (env fun id1 id2 srt pos) 
  (if (svref env 3) 
      fun 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ (STRING-SPEC::^ id1 ".") id2) 
               " has not been declared as a qualified name or as a field selection") 
              pos) 
             (cons 
              :|Fun| 
              (vector (cons :|TwoNames| (vector id1 id2 nil)) srt pos)))))

(defun TYPECHECKER::undeclaredResolving (env fun id srt pos) 
  (if (svref env 3) 
      fun 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ "Name " id) 
                 " has not been declared.") 
                " Resolving with ") 
               (ANNSPECPRINTER::printSort srt)) 
              pos) 
             (cons :|Fun| (vector (cons :|OneName| (cons id nil)) srt pos)))))

(defun TYPECHECKER::uniqueConstr (env trm id pos) 
  (let ((pV21 (STRINGMAP::|!find| (svref env 0) id))) 
    (block 
     nil 
     (if (eq (car pV21) :|Some|) 
         (let ((pV22 (cdr pV21))) 
           (if (consp pV22) 
               (if (null (cdr pV22)) 
                   (return 
                    (let ((pV17 (UTILITIES::copySort-1 (car pV22)))) 
                      (block 
                       nil 
                       (let ((pV19 (cdr pV17))) 
                         (return 
                          (let ((id_srt 
                                 (block 
                                  nil 
                                  (if (eq (car pV19) :|CoProduct|) 
                                      (let ((pV12 (cdr pV19))) 
                                        (return 
                                         (let ((pV4 
                                                (LIST-SPEC::|!find|-1-1 
                                                 #'(lambda (x) 
                                                    (string=  id (car x))) 
                                                 (car pV12)))) 
                                           (block 
                                            nil 
                                            (if (eq (car pV4) :|Some|) 
                                                (let ((pV7 (cdr (cdr pV4)))) 
                                                  (if (eq (car pV7) :|Some|) 
                                                      (return 
                                                       (cons 
                                                        :|Arrow| 
                                                        (vector 
                                                         (cdr pV7) 
                                                         pV19 
                                                         (cdr pV12))))))) 
                                            (return pV19)))))) 
                                  (return pV19)))) 
                            (let ((pV15 (TYPECHECKER::mkEmbed0 env id_srt id))) 
                              (block 
                               nil 
                               (if (eq (car pV15) :|Some|) 
                                   (return 
                                    (cons 
                                     :|Some| 
                                     (cons 
                                      :|Fun| 
                                      (vector 
                                       (cons :|Embed| (cons (cdr pV15) nil)) 
                                       (TYPECHECKER::checkSort env id_srt) 
                                       pos)))) 
                                   (if (eq (car pV15) :|None|) 
                                       (return 
                                        (TYPECHECKER::mkEmbed1 
                                         env 
                                         id_srt 
                                         trm 
                                         id 
                                         pos)))) 
                               (error 
                                "Nonexhaustive match failure in uniqueConstr")))))) 
                       (error "Nonexhaustive match failure in uniqueConstr")))))))) 
     (return '(:|None|)))))

(defun UTILITIES::findTheOp2 (env qualifier id) 
  (findAQualifierMap (svref (svref env 5) 1) qualifier id))

(defun UTILITIES::findVarOrOps (pV23 pV24 pV25) 
  (block 
   nil 
   (let ((pV32 (svref pV23 6))
         (pV31 (svref pV23 5))) 
     (return 
      (labels 
        ((mkTerms (infos) 
          (LIST-SPEC::|!map|-1-1 #'(lambda (info) (mkTerm pV25 info)) infos))
         (mkTerm (pV13 pV14) 
          (block 
           nil 
           (let ((pV17 (svref pV14 2))
                 (pV15 (svref pV14 0))) 
             (return 
              (let ((pV10 (UTILITIES::copySort (car pV17) (cdr pV17)))) 
                (block 
                 nil 
                 (return 
                  (block 
                   nil 
                   (if (consp pV15) 
                       (let ((pV5 (car pV15))) 
                         (if (eq (car pV5) :|Qualified|) 
                             (let ((pV7 (cdr pV5))) 
                               (return 
                                (cons 
                                 :|Fun| 
                                 (vector 
                                  (cons 
                                   :|TwoNames| 
                                   (vector (car pV7) (cdr pV7) (svref pV14 1))) 
                                  (cdr pV10) 
                                  pV13))))))) 
                   (error "Nonexhaustive match failure in findVarOrOps"))) 
                 (error "Nonexhaustive match failure in findVarOrOps"))))) 
           (error "Nonexhaustive match failure in findVarOrOps")))) 
        (let ((pV21 (STRINGMAP::|!find| pV32 pV24))) 
          (block 
           nil 
           (if (eq (car pV21) :|Some|) 
               (return 
                (cons (cons :|Var| (cons (cons pV24 (cdr pV21)) pV25)) nil)) 
               (if (eq (car pV21) :|None|) 
                   (return 
                    (mkTerms 
                     (STANDARDSPEC::wildFindUnQualified (svref pV31 1) pV24))))) 
           (error "Nonexhaustive match failure in findVarOrOps")))))) 
   (error "Nonexhaustive match failure in findVarOrOps")))

(defun TYPECHECKER::aux_elaborateTerm (env trm term_sort) 
  (block 
   nil 
   (if (eq (car trm) :|Fun|) 
       (let ((pV239 (cdr trm))) 
         (let ((pV300 (svref pV239 2))
               (pV299 (svref pV239 1))
               (pV298 (svref pV239 0))) 
           (if (eq (car pV298) :|OneName|) 
               (let ((pV319 (car (cdr pV298)))) 
                 (return 
                  (progn (TYPECHECKER::elaborateCheckSortForTerm 
                          env 
                          trm 
                          pV299 
                          term_sort) 
                         (let ((pV29 (UTILITIES::findVarOrOps env pV319 pV300))) 
                           (block 
                            nil 
                            (if (consp pV29) 
                                (return 
                                 (let ((pV20 
                                        (TYPECHECKER::selectTermWithConsistentSort 
                                         env 
                                         pV319 
                                         pV300 
                                         pV29 
                                         term_sort))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV20) :|None|) 
                                        (return trm) 
                                        (if (eq (car pV20) :|Some|) 
                                            (let ((pV21 (cdr pV20))) 
                                              (return 
                                               (let ((srt 
                                                      (METASLANG::termSort pV21))) 
                                                 (let ((srt 
                                                        (TYPECHECKER::elaborateCheckSortForTerm 
                                                         env 
                                                         pV21 
                                                         srt 
                                                         term_sort))) 
                                                   (block 
                                                    nil 
                                                    (if (eq (car pV21) :|Var|) 
                                                        (let ((pV10 (cdr pV21))) 
                                                          (return 
                                                           (cons 
                                                            :|Var| 
                                                            (cons 
                                                             (cons 
                                                              (car (car pV10)) 
                                                              srt) 
                                                             (cdr pV10))))) 
                                                        (if (eq 
                                                             (car pV21) 
                                                             :|Fun|) 
                                                            (let ((pV9 
                                                                   (cdr pV21))) 
                                                              (let ((pV13 
                                                                     (svref 
                                                                      pV9 
                                                                      2))
                                                                    (pV11 
                                                                     (svref 
                                                                      pV9 
                                                                      0))) 
                                                                (if (eq 
                                                                     (car pV11) 
                                                                     :|OneName|) 
                                                                    (let ((pV15 
                                                                           (cdr 
                                                                            pV11))) 
                                                                      (return 
                                                                       (cons 
                                                                        :|Fun| 
                                                                        (vector 
                                                                         (cons 
                                                                          :|OneName| 
                                                                          (cons 
                                                                           (car 
                                                                            pV15) 
                                                                           (cdr 
                                                                            pV15))) 
                                                                         srt 
                                                                         pV13)))) 
                                                                    (if (eq 
                                                                         (car 
                                                                          pV11) 
                                                                         :|TwoNames|) 
                                                                        (let ((pV14 
                                                                               (cdr 
                                                                                pV11))) 
                                                                          (return 
                                                                           (cons 
                                                                            :|Fun| 
                                                                            (vector 
                                                                             (cons 
                                                                              :|TwoNames| 
                                                                              (vector 
                                                                               (svref 
                                                                                pV14 
                                                                                0) 
                                                                               (svref 
                                                                                pV14 
                                                                                1) 
                                                                               (svref 
                                                                                pV14 
                                                                                2))) 
                                                                             srt 
                                                                             pV13)))))))))) 
                                                    (return 
                                                     (SYSTEM-SPEC::fail 
                                                      "Variable or constant expected"))))))))) 
                                    (error 
                                     "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                            (if (null pV29) 
                                (return 
                                 (let ((pV27 
                                        (TYPECHECKER::mkEmbed0 env pV299 pV319))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV27) :|Some|) 
                                        (return 
                                         (cons 
                                          :|Fun| 
                                          (vector 
                                           (cons :|Embed| (cons (cdr pV27) nil)) 
                                           (TYPECHECKER::checkSort env pV299) 
                                           pV300))) 
                                        (if (eq (car pV27) :|None|) 
                                            (return 
                                             (let ((pV25 
                                                    (TYPECHECKER::mkEmbed1 
                                                     env 
                                                     pV299 
                                                     trm 
                                                     pV319 
                                                     pV300))) 
                                               (block 
                                                nil 
                                                (if (eq (car pV25) :|Some|) 
                                                    (return (cdr pV25)) 
                                                    (if (eq (car pV25) :|None|) 
                                                        (return 
                                                         (let ((pV23 
                                                                (TYPECHECKER::uniqueConstr 
                                                                 env 
                                                                 trm 
                                                                 pV319 
                                                                 pV300))) 
                                                           (block 
                                                            nil 
                                                            (if (eq 
                                                                 (car pV23) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (cdr pV23))) 
                                                            (return 
                                                             (TYPECHECKER::undeclared 
                                                              env 
                                                              trm 
                                                              pV319 
                                                              term_sort 
                                                              pV300))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                    (error 
                                     "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                            (error 
                             "Nonexhaustive match failure in aux_elaborateTerm")))))) 
               (if (eq (car pV298) :|TwoNames|) 
                   (let ((pV312 (cdr pV298))) 
                     (let ((pV317 (svref pV312 1))
                           (pV316 (svref pV312 0))) 
                       (return 
                        (progn (TYPECHECKER::elaborateCheckSortForTerm 
                                env 
                                trm 
                                pV299 
                                term_sort) 
                               (let ((pV74 
                                      (UTILITIES::findTheOp2 env pV316 pV317))) 
                                 (block 
                                  nil 
                                  (if (eq (car pV74) :|Some|) 
                                      (let ((pV75 (cdr pV74))) 
                                        (let ((pV78 (svref pV75 2))
                                              (pV76 (svref pV75 0))) 
                                          (if (consp pV76) 
                                              (let ((pV81 (car pV76))) 
                                                (if (eq (car pV81) :|Qualified|) 
                                                    (let ((pV83 (cdr pV81))) 
                                                      (let ((pV85 (cdr pV83))
                                                            (pV84 (car pV83))) 
                                                        (return 
                                                         (let ((pV44 
                                                                (UTILITIES::copySort 
                                                                 (car pV78) 
                                                                 (cdr pV78)))) 
                                                           (block 
                                                            nil 
                                                            (let ((pV46 
                                                                   (cdr pV44))) 
                                                              (return 
                                                               (let ((term 
                                                                      (cons 
                                                                       :|Fun| 
                                                                       (vector 
                                                                        (cons 
                                                                         :|TwoNames| 
                                                                         (vector 
                                                                          pV84 
                                                                          pV85 
                                                                          (svref 
                                                                           pV75 
                                                                           1))) 
                                                                        pV46 
                                                                        pV300)))) 
                                                                 (let ((srt 
                                                                        (TYPECHECKER::elaborateCheckSortForTerm 
                                                                         env 
                                                                         term 
                                                                         pV46 
                                                                         term_sort))) 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          term) 
                                                                         :|Fun|) 
                                                                        (let ((pV39 
                                                                               (cdr 
                                                                                term))) 
                                                                          (let ((pV40 
                                                                                 (svref 
                                                                                  pV39 
                                                                                  0))) 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV40) 
                                                                                 :|TwoNames|) 
                                                                                (let ((pV43 
                                                                                       (cdr 
                                                                                        pV40))) 
                                                                                  (return 
                                                                                   (cons 
                                                                                    :|Fun| 
                                                                                    (vector 
                                                                                     (cons 
                                                                                      :|TwoNames| 
                                                                                      (vector 
                                                                                       (svref 
                                                                                        pV43 
                                                                                        0) 
                                                                                       (svref 
                                                                                        pV43 
                                                                                        1) 
                                                                                       (svref 
                                                                                        pV43 
                                                                                        2))) 
                                                                                     srt 
                                                                                     (svref 
                                                                                      pV39 
                                                                                      2))))))))) 
                                                                    (return 
                                                                     (SYSTEM-SPEC::fail 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         (STRING-SPEC::^ 
                                                                          (STRING-SPEC::^ 
                                                                           (STRING-SPEC::^ 
                                                                            (STRING-SPEC::^ 
                                                                             "Op expected for elaboration of " 
                                                                             pV316) 
                                                                            ".") 
                                                                           pV317) 
                                                                          " as resolved to ") 
                                                                         pV84) 
                                                                        ".") 
                                                                       pV85)))))))) 
                                                            (error 
                                                             "Nonexhaustive match failure in aux_elaborateTerm"))))))))))) 
                                      (if (eq (car pV74) :|None|) 
                                          (return 
                                           (let ((pV69 
                                                  (UTILITIES::findVarOrOps 
                                                   env 
                                                   pV316 
                                                   pV300))) 
                                             (block 
                                              nil 
                                              (if (consp pV69) 
                                                  (let ((pV71 (car pV69))) 
                                                    (if (null (cdr pV69)) 
                                                        (return 
                                                         (let ((big_sort 
                                                                (METASLANG::termSort 
                                                                 pV71))) 
                                                           (let ((big_sort 
                                                                  (TYPECHECKER::checkSort 
                                                                   env 
                                                                   big_sort))) 
                                                             (labels 
                                                               ((getProduct 
                                                                 (srt) 
                                                                 (let ((pV57 
                                                                        (UTILITIES::unfoldPSort 
                                                                         env 
                                                                         srt))) 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          pV57) 
                                                                         :|Product|) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Some| 
                                                                          (car 
                                                                           (cdr 
                                                                            pV57)))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV57) 
                                                                             :|Subsort|) 
                                                                            (return 
                                                                             (getProduct 
                                                                              (svref 
                                                                               (cdr 
                                                                                pV57) 
                                                                               0))))) 
                                                                    (return 
                                                                     '(:|None|)))))
                                                                (projectRow 
                                                                 (big_term 
                                                                  big_sort 
                                                                  row 
                                                                  id2) 
                                                                 (block 
                                                                  nil 
                                                                  (if (null row) 
                                                                      (return 
                                                                       (TYPECHECKER::undeclared2 
                                                                        env 
                                                                        trm 
                                                                        pV316 
                                                                        id2 
                                                                        term_sort 
                                                                        pV300)) 
                                                                      (if (consp 
                                                                           row) 
                                                                          (let ((pV50 
                                                                                 (car 
                                                                                  row))) 
                                                                            (return 
                                                                             (if (string=  
                                                                                  id2 
                                                                                  (car 
                                                                                   pV50)) 
                                                                                 (let ((field_sort 
                                                                                        (TYPECHECKER::checkSort 
                                                                                         env 
                                                                                         (cdr 
                                                                                          pV50)))) 
                                                                                   (let ((projection 
                                                                                          (cons 
                                                                                           :|ApplyN| 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             (cons 
                                                                                              :|Fun| 
                                                                                              (vector 
                                                                                               (cons 
                                                                                                :|Project| 
                                                                                                id2) 
                                                                                               (cons 
                                                                                                :|Arrow| 
                                                                                                (vector 
                                                                                                 big_sort 
                                                                                                 field_sort 
                                                                                                 pV300)) 
                                                                                               pV300)) 
                                                                                             (cons 
                                                                                              big_term 
                                                                                              nil)) 
                                                                                            pV300)))) 
                                                                                     (progn (TYPECHECKER::elaborateSortForTerm 
                                                                                             env 
                                                                                             projection 
                                                                                             field_sort 
                                                                                             term_sort) 
                                                                                            projection))) 
                                                                                 (projectRow 
                                                                                  big_term 
                                                                                  big_sort 
                                                                                  (cdr 
                                                                                   row) 
                                                                                  id2)))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                                               (let ((pV66 
                                                                      (getProduct 
                                                                       big_sort))) 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car pV66) 
                                                                       :|Some|) 
                                                                      (return 
                                                                       (projectRow 
                                                                        pV71 
                                                                        big_sort 
                                                                        (cdr 
                                                                         pV66) 
                                                                        pV317)) 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV66) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (TYPECHECKER::undeclared2 
                                                                            env 
                                                                            trm 
                                                                            pV316 
                                                                            pV317 
                                                                            term_sort 
                                                                            pV300)))) 
                                                                  (return 
                                                                   (TYPECHECKER::undeclared2 
                                                                    env 
                                                                    trm 
                                                                    pV316 
                                                                    pV317 
                                                                    term_sort 
                                                                    pV300))))))))))) 
                                              (return 
                                               (TYPECHECKER::undeclared2 
                                                env 
                                                trm 
                                                pV316 
                                                pV317 
                                                term_sort 
                                                pV300))))))) 
                                  (return 
                                   (TYPECHECKER::undeclared2 
                                    env 
                                    trm 
                                    pV316 
                                    pV317 
                                    term_sort 
                                    pV300)))))))) 
                   (if (eq (car pV298) :|Embed|) 
                       (let ((pV314 (car (cdr pV298)))) 
                         (return 
                          (progn (TYPECHECKER::elaborateCheckSortForTerm 
                                  env 
                                  trm 
                                  pV299 
                                  term_sort) 
                                 (let ((pV92 
                                        (TYPECHECKER::mkEmbed0 
                                         env 
                                         term_sort 
                                         pV314))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV92) :|Some|) 
                                        (return 
                                         (cons 
                                          :|Fun| 
                                          (vector 
                                           (cons :|Embed| (cons (cdr pV92) nil)) 
                                           (TYPECHECKER::checkSort env term_sort) 
                                           pV300))) 
                                        (if (eq (car pV92) :|None|) 
                                            (return 
                                             (let ((pV90 
                                                    (TYPECHECKER::mkEmbed1 
                                                     env 
                                                     term_sort 
                                                     trm 
                                                     pV314 
                                                     pV300))) 
                                               (block 
                                                nil 
                                                (if (eq (car pV90) :|Some|) 
                                                    (return (cdr pV90)) 
                                                    (if (eq (car pV90) :|None|) 
                                                        (return 
                                                         (TYPECHECKER::undeclared 
                                                          env 
                                                          trm 
                                                          pV314 
                                                          term_sort 
                                                          pV300)))) 
                                                (error 
                                                 "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                    (error 
                                     "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                       (if (eq (car pV298) :|Project|) 
                           (let ((pV310 (cdr pV298))) 
                             (return 
                              (let ((srt 
                                     (TYPECHECKER::elaborateCheckSortForTerm 
                                      env 
                                      trm 
                                      pV299 
                                      term_sort))) 
                                (let ((pV94 
                                       (TYPECHECKER::mkProject 
                                        env 
                                        pV310 
                                        srt 
                                        pV300))) 
                                  (block 
                                   nil 
                                   (if (eq (car pV94) :|Some|) 
                                       (return (cdr pV94)) 
                                       (if (eq (car pV94) :|None|) 
                                           (return 
                                            (TYPECHECKER::undeclaredResolving 
                                             env 
                                             trm 
                                             pV310 
                                             term_sort 
                                             pV300)))) 
                                   (error 
                                    "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                           (if (eq (car pV298) :|Embedded|) 
                               (let ((pV309 (cdr pV298))) 
                                 (return 
                                  (let ((srt 
                                         (TYPECHECKER::elaborateCheckSortForTerm 
                                          env 
                                          trm 
                                          pV299 
                                          term_sort))) 
                                    (progn (let ((pV102 
                                                  (UTILITIES::unfoldPSort 
                                                   env 
                                                   srt))) 
                                             (block 
                                              nil 
                                              (if (eq (car pV102) :|Arrow|) 
                                                  (let ((pV104 
                                                         (svref (cdr pV102) 0))) 
                                                    (return 
                                                     (let ((pV99 
                                                            (TYPECHECKER::isCoproduct 
                                                             env 
                                                             pV104))) 
                                                       (block 
                                                        nil 
                                                        (if (eq 
                                                             (car pV99) 
                                                             :|Some|) 
                                                            (return 
                                                             (if (LIST-SPEC::|!exists|-1-1 
                                                                  #'(lambda (x) 
                                                                     (string=  
                                                                      pV309 
                                                                      (car x))) 
                                                                  (cdr pV99)) 
                                                                 nil 
                                                                 (UTILITIES::|!error| 
                                                                  env 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     "Name " 
                                                                     pV309) 
                                                                    " is not among the constructors of ") 
                                                                   (ANNSPECPRINTER::printSort 
                                                                    pV104)) 
                                                                  pV300))) 
                                                            (if (eq 
                                                                 (car pV99) 
                                                                 :|None|) 
                                                                (return 
                                                                 (TYPECHECKER::pass2Error 
                                                                  env 
                                                                  pV104 
                                                                  (TYPECHECKER::newLines 
                                                                   (cons 
                                                                    (STRING-SPEC::^ 
                                                                     (STRING-SPEC::^ 
                                                                      "Sum sort with constructor " 
                                                                      pV309) 
                                                                     " expected") 
                                                                    (cons 
                                                                     (STRING-SPEC::^ 
                                                                      "found instead " 
                                                                      (ANNSPECPRINTER::printSort 
                                                                       pV104)) 
                                                                     nil))) 
                                                                  pV300)))) 
                                                        (error 
                                                         "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                              (return 
                                               (TYPECHECKER::pass2Error 
                                                env 
                                                srt 
                                                "Function sort expected " 
                                                pV300)))) 
                                           (cons 
                                            :|Fun| 
                                            (vector 
                                             (cons :|Embedded| pV309) 
                                             srt 
                                             pV300)))))) 
                               (if (eq (car pV298) :|PChoose|) 
                                   (return 
                                    (let ((a (UTILITIES::freshMetaTyVar pV300))) 
                                      (let ((b (UTILITIES::freshMetaTyVar pV300))) 
                                        (let ((equiv 
                                               (TYPECHECKER::elaborateTerm 
                                                env 
                                                (cdr pV298) 
                                                (cons 
                                                 :|Arrow| 
                                                 (vector 
                                                  (cons 
                                                   :|Product| 
                                                   (cons 
                                                    (cons 
                                                     (cons "1" a) 
                                                     (cons (cons "2" a) nil)) 
                                                    pV300)) 
                                                  TYPECHECKER::type_bool 
                                                  pV300))))) 
                                          (let ((ty4 
                                                 (cons 
                                                  :|Arrow| 
                                                  (vector 
                                                   (cons 
                                                    :|Arrow| 
                                                    (vector a b pV300)) 
                                                   (cons 
                                                    :|Arrow| 
                                                    (vector 
                                                     (cons 
                                                      :|Quotient| 
                                                      (vector a equiv pV300)) 
                                                     b 
                                                     pV300)) 
                                                   pV300)))) 
                                            (progn (TYPECHECKER::elaborateSortForTerm 
                                                    env 
                                                    trm 
                                                    ty4 
                                                    term_sort) 
                                                   (TYPECHECKER::elaborateSortForTerm 
                                                    env 
                                                    trm 
                                                    pV299 
                                                    ty4) 
                                                   (cons 
                                                    :|Fun| 
                                                    (vector 
                                                     (cons :|PChoose| equiv) 
                                                     pV299 
                                                     pV300)))))))) 
                                   (if (eq (car pV298) :|PQuotient|) 
                                       (return 
                                        (let ((a 
                                               (UTILITIES::freshMetaTyVar pV300))) 
                                          (let ((equiv 
                                                 (TYPECHECKER::elaborateTerm 
                                                  env 
                                                  (cdr pV298) 
                                                  (cons 
                                                   :|Arrow| 
                                                   (vector 
                                                    (cons 
                                                     :|Product| 
                                                     (cons 
                                                      (cons 
                                                       (cons "1" a) 
                                                       (cons (cons "2" a) nil)) 
                                                      pV300)) 
                                                    TYPECHECKER::type_bool 
                                                    pV300))))) 
                                            (let ((ty2 
                                                   (cons 
                                                    :|Arrow| 
                                                    (vector 
                                                     a 
                                                     (cons 
                                                      :|Quotient| 
                                                      (vector a equiv pV300)) 
                                                     pV300)))) 
                                              (progn (TYPECHECKER::elaborateSortForTerm 
                                                      env 
                                                      trm 
                                                      ty2 
                                                      term_sort) 
                                                     (TYPECHECKER::elaborateSortForTerm 
                                                      env 
                                                      trm 
                                                      pV299 
                                                      ty2) 
                                                     (cons 
                                                      :|Fun| 
                                                      (vector 
                                                       (cons :|PQuotient| equiv) 
                                                       pV299 
                                                       pV300))))))) 
                                       (if (eq (car pV298) :|Equals|) 
                                           (return 
                                            (let ((a 
                                                   (UTILITIES::freshMetaTyVar 
                                                    pV300))) 
                                              (let ((ty 
                                                     (cons 
                                                      :|Arrow| 
                                                      (vector 
                                                       (cons 
                                                        :|Product| 
                                                        (cons 
                                                         (cons 
                                                          (cons "1" a) 
                                                          (cons (cons "2" a) nil)) 
                                                         pV300)) 
                                                       TYPECHECKER::type_bool 
                                                       pV300)))) 
                                                (progn (TYPECHECKER::elaborateSortForTerm 
                                                        env 
                                                        trm 
                                                        ty 
                                                        term_sort) 
                                                       (TYPECHECKER::elaborateSortForTerm 
                                                        env 
                                                        trm 
                                                        pV299 
                                                        ty) 
                                                       (cons 
                                                        :|Fun| 
                                                        (vector 
                                                         '(:|Equals|) 
                                                         pV299 
                                                         pV300)))))) 
                                           (if (eq (car pV298) :|Bool|) 
                                               (return 
                                                (progn (TYPECHECKER::elaborateSortForTerm 
                                                        env 
                                                        trm 
                                                        TYPECHECKER::type_bool 
                                                        term_sort) 
                                                       (TYPECHECKER::elaborateCheckSortForTerm 
                                                        env 
                                                        trm 
                                                        pV299 
                                                        TYPECHECKER::type_bool) 
                                                       (cons 
                                                        :|Fun| 
                                                        (vector 
                                                         (cons 
                                                          :|Bool| 
                                                          (cdr pV298)) 
                                                         pV299 
                                                         pV300)))) 
                                               (if (eq (car pV298) :|Nat|) 
                                                   (return 
                                                    (progn (TYPECHECKER::elaborateSortForTerm 
                                                            env 
                                                            trm 
                                                            TYPECHECKER::type_nat 
                                                            term_sort) 
                                                           (TYPECHECKER::elaborateCheckSortForTerm 
                                                            env 
                                                            trm 
                                                            pV299 
                                                            TYPECHECKER::type_nat) 
                                                           (cons 
                                                            :|Fun| 
                                                            (vector 
                                                             (cons 
                                                              :|Nat| 
                                                              (cdr pV298)) 
                                                             pV299 
                                                             pV300)))) 
                                                   (if (eq (car pV298) :|String|) 
                                                       (return 
                                                        (progn (TYPECHECKER::elaborateSortForTerm 
                                                                env 
                                                                trm 
                                                                TYPECHECKER::type_string 
                                                                term_sort) 
                                                               (TYPECHECKER::elaborateCheckSortForTerm 
                                                                env 
                                                                trm 
                                                                pV299 
                                                                TYPECHECKER::type_string) 
                                                               (cons 
                                                                :|Fun| 
                                                                (vector 
                                                                 (cons 
                                                                  :|String| 
                                                                  (cdr pV298)) 
                                                                 pV299 
                                                                 pV300)))) 
                                                       (if (eq 
                                                            (car pV298) 
                                                            :|Char|) 
                                                           (return 
                                                            (progn (TYPECHECKER::elaborateSortForTerm 
                                                                    env 
                                                                    trm 
                                                                    TYPECHECKER::type_char 
                                                                    term_sort) 
                                                                   (TYPECHECKER::elaborateCheckSortForTerm 
                                                                    env 
                                                                    trm 
                                                                    pV299 
                                                                    TYPECHECKER::type_char) 
                                                                   (cons 
                                                                    :|Fun| 
                                                                    (vector 
                                                                     (cons 
                                                                      :|Char| 
                                                                      (cdr pV298)) 
                                                                     pV299 
                                                                     pV300)))) 
                                                           (if (eq 
                                                                (car pV298) 
                                                                :|PRelax|) 
                                                               (return 
                                                                (let ((a 
                                                                       (UTILITIES::freshMetaTyVar 
                                                                        pV300))) 
                                                                  (let ((pred 
                                                                         (TYPECHECKER::elaborateTerm 
                                                                          env 
                                                                          (cdr 
                                                                           pV298) 
                                                                          (cons 
                                                                           :|Arrow| 
                                                                           (vector 
                                                                            a 
                                                                            TYPECHECKER::type_bool 
                                                                            pV300))))) 
                                                                    (let ((ty2 
                                                                           (cons 
                                                                            :|Arrow| 
                                                                            (vector 
                                                                             (cons 
                                                                              :|Subsort| 
                                                                              (vector 
                                                                               a 
                                                                               pred 
                                                                               pV300)) 
                                                                             a 
                                                                             pV300)))) 
                                                                      (progn (TYPECHECKER::elaborateSortForTerm 
                                                                              env 
                                                                              trm 
                                                                              ty2 
                                                                              term_sort) 
                                                                             (TYPECHECKER::elaborateSortForTerm 
                                                                              env 
                                                                              trm 
                                                                              pV299 
                                                                              ty2) 
                                                                             (cons 
                                                                              :|Fun| 
                                                                              (vector 
                                                                               (cons 
                                                                                :|PRelax| 
                                                                                pred) 
                                                                               pV299 
                                                                               pV300))))))) 
                                                               (if (eq 
                                                                    (car pV298) 
                                                                    :|PRestrict|) 
                                                                   (return 
                                                                    (let ((a 
                                                                           (UTILITIES::freshMetaTyVar 
                                                                            pV300))) 
                                                                      (let ((pred 
                                                                             (TYPECHECKER::elaborateTerm 
                                                                              env 
                                                                              (cdr 
                                                                               pV298) 
                                                                              (cons 
                                                                               :|Arrow| 
                                                                               (vector 
                                                                                a 
                                                                                TYPECHECKER::type_bool 
                                                                                pV300))))) 
                                                                        (let ((ty2 
                                                                               (cons 
                                                                                :|Arrow| 
                                                                                (vector 
                                                                                 a 
                                                                                 (cons 
                                                                                  :|Subsort| 
                                                                                  (vector 
                                                                                   a 
                                                                                   pred 
                                                                                   pV300)) 
                                                                                 pV300)))) 
                                                                          (progn (TYPECHECKER::elaborateSortForTerm 
                                                                                  env 
                                                                                  trm 
                                                                                  ty2 
                                                                                  term_sort) 
                                                                                 (TYPECHECKER::elaborateSortForTerm 
                                                                                  env 
                                                                                  trm 
                                                                                  pV299 
                                                                                  ty2) 
                                                                                 (cons 
                                                                                  :|Fun| 
                                                                                  (vector 
                                                                                   (cons 
                                                                                    :|PRestrict| 
                                                                                    pred) 
                                                                                   pV299 
                                                                                   pV300))))))))))))))))))))))) 
       (if (eq (car trm) :|Var|) 
           (let ((pV238 (cdr trm))) 
             (let ((pV294 (car pV238))) 
               (return 
                (let ((srt 
                       (TYPECHECKER::elaborateCheckSortForTerm 
                        env 
                        trm 
                        (cdr pV294) 
                        term_sort))) 
                  (cons :|Var| (cons (cons (car pV294) srt) (cdr pV238))))))) 
           (if (eq (car trm) :|LetRec|) 
               (let ((pV237 (cdr trm))) 
                 (let ((pV293 (svref pV237 2))
                       (pV292 (svref pV237 1))
                       (pV291 (svref pV237 0))) 
                   (return 
                    (labels 
                      ((declareFun (pV107 pV108) 
                        (block 
                         nil 
                         (let ((pV109 (car pV107))) 
                           (return 
                            (UTILITIES::addVariable 
                             pV108 
                             (car pV109) 
                             (cdr pV109)))) 
                         (error 
                          "Nonexhaustive match failure in aux_elaborateTerm")))) 
                      (labels 
                        ((elaborateDecl (env) 
                          #'(lambda (x) 
                             (block 
                              nil 
                              (let ((pV115 (car (car x)))) 
                                (return 
                                 (let ((terms 
                                        (UTILITIES::findVarOrOps env pV115 pV293))) 
                                   (let ((srt 
                                          (METASLANG::termSort 
                                           (LIST-SPEC::hd terms)))) 
                                     (let ((bdy 
                                            (TYPECHECKER::elaborateTerm 
                                             env 
                                             (cdr x) 
                                             srt))) (cons (cons pV115 srt) bdy)))))) 
                              (error 
                               "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                        (let ((env 
                               (LIST-SPEC::foldr-1-1-1 
                                #'(lambda (x) (declareFun (car x) (cdr x))) 
                                env 
                                pV291))) 
                          (let ((decls 
                                 (LIST-SPEC::|!map|-1-1 
                                  (elaborateDecl env) 
                                  pV291))) 
                            (let ((bdy 
                                   (TYPECHECKER::elaborateTerm 
                                    env 
                                    pV292 
                                    term_sort))) 
                              (cons :|LetRec| (vector decls bdy pV293)))))))))) 
               (if (eq (car trm) :|Let|) 
                   (let ((pV236 (cdr trm))) 
                     (let ((pV290 (svref pV236 2))
                           (pV289 (svref pV236 1))
                           (pV288 (svref pV236 0))) 
                       (return 
                        (labels 
                          ((doDeclaration (pV129 pV130) 
                            (block 
                             nil 
                             (let ((pV132 (cdr pV129))
                                   (pV131 (car pV129))) 
                               (return 
                                (let ((alpha (UTILITIES::freshMetaTyVar pV290))) 
                                  (let ((pV126 
                                         (block 
                                          nil 
                                          (if (eq (car pV131) :|SortedPat|) 
                                              (let ((pV119 (cdr pV131))) 
                                                (return 
                                                 (cons 
                                                  (svref pV119 0) 
                                                  (cons 
                                                   :|SortedTerm| 
                                                   (vector 
                                                    pV132 
                                                    (svref pV119 1) 
                                                    (svref pV119 2))))))) 
                                          (return (cons pV131 pV132))))) 
                                    (block 
                                     nil 
                                     (return 
                                      (let ((bdy 
                                             (TYPECHECKER::elaborateTerm 
                                              env 
                                              (cdr pV126) 
                                              alpha))) 
                                        (let ((pV123 
                                               (TYPECHECKER::elaboratePattern 
                                                (cdr pV130) 
                                                (car pV126) 
                                                alpha))) 
                                          (block 
                                           nil 
                                           (return 
                                            (cons 
                                             (LIST-SPEC::|!cons| 
                                              (cons (car pV123) bdy) 
                                              (car pV130)) 
                                             (cdr pV123))) 
                                           (error 
                                            "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                                     (error 
                                      "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                             (error 
                              "Nonexhaustive match failure in aux_elaborateTerm")))) 
                          (let ((pV135 
                                 (LIST-SPEC::foldr-1-1-1 
                                  #'(lambda (x) (doDeclaration (car x) (cdr x))) 
                                  (cons nil env) 
                                  pV288))) 
                            (block 
                             nil 
                             (return 
                              (let ((body 
                                     (TYPECHECKER::elaborateTerm 
                                      (cdr pV135) 
                                      pV289 
                                      term_sort))) 
                                (cons :|Let| (vector (car pV135) body pV290)))) 
                             (error 
                              "Nonexhaustive match failure in aux_elaborateTerm"))))))) 
                   (if (eq (car trm) :|IfThenElse|) 
                       (let ((pV235 (cdr trm))) 
                         (return 
                          (let ((test 
                                 (TYPECHECKER::elaborateTerm 
                                  env 
                                  (svref pV235 0) 
                                  TYPECHECKER::type_bool))) 
                            (let ((thenTrm 
                                   (TYPECHECKER::elaborateTerm 
                                    env 
                                    (svref pV235 1) 
                                    term_sort))) 
                              (let ((elseTrm 
                                     (TYPECHECKER::elaborateTerm 
                                      env 
                                      (svref pV235 2) 
                                      term_sort))) 
                                (cons 
                                 :|IfThenElse| 
                                 (vector test thenTrm elseTrm (svref pV235 3)))))))) 
                       (if (eq (car trm) :|Record|) 
                           (let ((pV234 (cdr trm))) 
                             (let ((pV283 (cdr pV234))
                                   (pV282 (car pV234))) 
                               (return 
                                (labels 
                                  ((unfoldConstraint (srt) 
                                    (let ((pV143 
                                           (UTILITIES::unfoldPSort env srt))) 
                                      (block 
                                       nil 
                                       (if (eq (car pV143) :|Product|) 
                                           (let ((pV152 (car (cdr pV143)))) 
                                             (return 
                                              (progn (if (BOOLEAN-SPEC::~ 
                                                          ( =  
                                                           (LIST-SPEC::|!length| 
                                                            pV282) 
                                                           (LIST-SPEC::|!length| 
                                                            pV152))) 
                                                         (UTILITIES::|!error| 
                                                          env 
                                                          (TYPECHECKER::newLines 
                                                           (cons 
                                                            (ANNSPECPRINTER::printTerm 
                                                             trm) 
                                                            (cons 
                                                             "is incompatible with constraint" 
                                                             (cons 
                                                              (ANNSPECPRINTER::printSort 
                                                               term_sort) 
                                                              nil)))) 
                                                          pV283) 
                                                         nil) 
                                                     pV152))) 
                                           (if (eq (car pV143) :|MetaTyVar|) 
                                               (return 
                                                (let ((row 
                                                       (LIST-SPEC::|!map|-1-1 
                                                        #'(lambda (x) 
                                                           (cons 
                                                            (car x) 
                                                            (UTILITIES::freshMetaTyVar 
                                                             pV283))) 
                                                        pV282))) 
                                                  (progn (UTILITIES::linkMetaTyVar-1-1 
                                                          (car (cdr pV143)) 
                                                          (cons 
                                                           :|Product| 
                                                           (cons row pV283))) 
                                                         row))) 
                                               (if (eq (car pV143) :|Subsort|) 
                                                   (return 
                                                    (unfoldConstraint 
                                                     (svref (cdr pV143) 0)))))) 
                                       (return 
                                        (progn (TYPECHECKER::pass2Error 
                                                env 
                                                pV143 
                                                (STRING-SPEC::^ 
                                                 (STRING-SPEC::^ 
                                                  (STRING-SPEC::^ 
                                                   (ANNSPECPRINTER::printTerm 
                                                    trm) 
                                                   " is constrained to be of an incompatible sort ") 
                                                  STRING-SPEC::newline) 
                                                 (ANNSPECPRINTER::printSort 
                                                  term_sort)) 
                                                pV283) 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'(lambda (x) 
                                                   (cons 
                                                    (car x) 
                                                    (UTILITIES::freshMetaTyVar 
                                                     pV283))) 
                                                pV282))))))) 
                                  (let ((tyrows (unfoldConstraint term_sort))) 
                                    (let ((trow (LISTPAIR::zip pV282 tyrows))) 
                                      (let ((row 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'(lambda (x) 
                                                 (let ((pV155 (cdr x))
                                                       (pV154 (car x))) 
                                                   (block 
                                                    nil 
                                                    (let ((pV157 (cdr pV154))
                                                          (pV156 (car pV154))) 
                                                      (let ((pV158 (car pV155))) 
                                                        (return 
                                                         (if (string=  
                                                              pV156 
                                                              pV158) 
                                                             (cons 
                                                              pV156 
                                                              (TYPECHECKER::elaborateTerm 
                                                               env 
                                                               pV157 
                                                               (cdr pV155))) 
                                                             (progn (UTILITIES::|!error| 
                                                                     env 
                                                                     (STRING-SPEC::^ 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        "Field-name " 
                                                                        pV156) 
                                                                       " is not the one imposed by sort constraint.  Expected field-name is: ") 
                                                                      pV158) 
                                                                     pV283) 
                                                                    (cons 
                                                                     pV156 
                                                                     pV157)))))) 
                                                    (error 
                                                     "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                              trow))) 
                                        (cons :|Record| (cons row pV283))))))))) 
                           (if (eq (car trm) :|Lambda|) 
                               (let ((pV233 (cdr trm))) 
                                 (let ((pV281 (cdr pV233))) 
                                   (return 
                                    (let ((alpha 
                                           (UTILITIES::freshMetaTyVar pV281))) 
                                      (let ((beta 
                                             (UTILITIES::freshMetaTyVar pV281))) 
                                        (progn (TYPECHECKER::elaborateSort 
                                                env 
                                                (cons 
                                                 :|Arrow| 
                                                 (vector alpha beta pV281)) 
                                                term_sort) 
                                               (cons 
                                                :|Lambda| 
                                                (cons 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'(lambda (x) 
                                                     (let ((term (svref x 2))
                                                           (|!cond| (svref x 1))) 
                                                       (let ((pV161 
                                                              (TYPECHECKER::elaboratePattern 
                                                               env 
                                                               (svref x 0) 
                                                               alpha))) 
                                                         (block 
                                                          nil 
                                                          (let ((pV163 
                                                                 (cdr pV161))) 
                                                            (return 
                                                             (let ((term 
                                                                    (TYPECHECKER::elaborateTerm 
                                                                     pV163 
                                                                     term 
                                                                     beta))) 
                                                               (let ((|!cond| 
                                                                      (TYPECHECKER::elaborateTerm 
                                                                       pV163 
                                                                       |!cond| 
                                                                       TYPECHECKER::type_bool))) 
                                                                 (vector 
                                                                  (car pV161) 
                                                                  |!cond| 
                                                                  term))))) 
                                                          (error 
                                                           "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                                                  (car pV233)) 
                                                 pV281)))))))) 
                               (if (eq (car trm) :|Bind|) 
                                   (let ((pV232 (cdr trm))) 
                                     (return 
                                      (progn (TYPECHECKER::elaborateSort 
                                              env 
                                              term_sort 
                                              TYPECHECKER::type_bool) 
                                             (let ((pV171 
                                                    (LIST-SPEC::foldl-1-1-1 
                                                     #'(lambda (x) 
                                                        (let ((pV166 (cdr x))
                                                              (pV165 (car x))) 
                                                          (block 
                                                           nil 
                                                           (let ((pV167 
                                                                  (car pV165))) 
                                                             (let ((pV170 
                                                                    (cdr pV166))) 
                                                               (return 
                                                                (let ((srt 
                                                                       (TYPECHECKER::checkSort 
                                                                        pV170 
                                                                        (cdr 
                                                                         pV165)))) 
                                                                  (cons 
                                                                   (LIST-SPEC::|!cons| 
                                                                    (cons 
                                                                     pV167 
                                                                     srt) 
                                                                    (car pV166)) 
                                                                   (UTILITIES::addVariable 
                                                                    pV170 
                                                                    pV167 
                                                                    srt)))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                                     (cons nil env) 
                                                     (svref pV232 1)))) 
                                               (block 
                                                nil 
                                                (return 
                                                 (let ((vars 
                                                        (LIST-SPEC::rev 
                                                         (car pV171)))) 
                                                   (cons 
                                                    :|Bind| 
                                                    (vector 
                                                     (svref pV232 0) 
                                                     vars 
                                                     (TYPECHECKER::elaborateTerm 
                                                      (cdr pV171) 
                                                      (svref pV232 2) 
                                                      term_sort) 
                                                     (svref pV232 3))))) 
                                                (error 
                                                 "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                   (if (eq (car trm) :|SortedTerm|) 
                                       (let ((pV231 (cdr trm))) 
                                         (return 
                                          (let ((srt 
                                                 (TYPECHECKER::elaborateSort 
                                                  env 
                                                  (svref pV231 1) 
                                                  term_sort))) 
                                            (let ((term 
                                                   (TYPECHECKER::elaborateTerm 
                                                    env 
                                                    (svref pV231 0) 
                                                    srt))) term)))) 
                                       (if (eq (car trm) :|Seq|) 
                                           (let ((pV230 (cdr trm))) 
                                             (let ((pV272 (cdr pV230))
                                                   (pV271 (car pV230))) 
                                               (return 
                                                (labels 
                                                  ((elab (ts) 
                                                    (block 
                                                     nil 
                                                     (if (null ts) 
                                                         (return nil) 
                                                         (if (consp ts) 
                                                             (let ((pV178 
                                                                    (cdr ts))
                                                                   (pV177 
                                                                    (car ts))) 
                                                               (progn (if (null 
                                                                           pV178) 
                                                                          (return 
                                                                           (cons 
                                                                            (TYPECHECKER::elaborateTerm 
                                                                             env 
                                                                             pV177 
                                                                             term_sort) 
                                                                            nil))) 
                                                                      (return 
                                                                       (let ((alpha 
                                                                              (UTILITIES::freshMetaTyVar 
                                                                               pV272))) 
                                                                         (let ((|!t| 
                                                                                (TYPECHECKER::elaborateTerm 
                                                                                 env 
                                                                                 pV177 
                                                                                 alpha))) 
                                                                           (LIST-SPEC::|!cons| 
                                                                            |!t| 
                                                                            (elab 
                                                                             pV178))))))))) 
                                                     (error 
                                                      "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                                  (cons 
                                                   :|Seq| 
                                                   (cons (elab pV271) pV272)))))) 
                                           (if (eq (car trm) :|ApplyN|) 
                                               (let ((pV229 (cdr trm))) 
                                                 (let ((pV241 (cdr pV229))
                                                       (pV240 (car pV229))) 
                                                   (progn (if (consp pV240) 
                                                              (let ((pV244 
                                                                     (cdr pV240))
                                                                    (pV243 
                                                                     (car pV240))) 
                                                                (progn (if (eq 
                                                                            (car 
                                                                             pV243) 
                                                                            :|Fun|) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 (svref 
                                                                                  (cdr 
                                                                                   pV243) 
                                                                                  0)) 
                                                                                :|Embedded|) 
                                                                               (if (consp 
                                                                                    pV244) 
                                                                                   (if (null 
                                                                                        (cdr 
                                                                                         pV244)) 
                                                                                       (return 
                                                                                        (let ((alpha 
                                                                                               (UTILITIES::freshMetaTyVar 
                                                                                                pV241))) 
                                                                                          (let ((t2 
                                                                                                 (TYPECHECKER::elaborateTerm 
                                                                                                  env 
                                                                                                  (car 
                                                                                                   pV244) 
                                                                                                  alpha))) 
                                                                                            (let ((t1 
                                                                                                   (TYPECHECKER::elaborateTerm 
                                                                                                    env 
                                                                                                    pV243 
                                                                                                    (cons 
                                                                                                     :|Arrow| 
                                                                                                     (vector 
                                                                                                      alpha 
                                                                                                      term_sort 
                                                                                                      pV241))))) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 t1 
                                                                                                 (cons 
                                                                                                  t2 
                                                                                                  nil)) 
                                                                                                pV241)))))))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV243) 
                                                                            :|Fun|) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 (svref 
                                                                                  (cdr 
                                                                                   pV243) 
                                                                                  0)) 
                                                                                :|Project|) 
                                                                               (if (consp 
                                                                                    pV244) 
                                                                                   (if (null 
                                                                                        (cdr 
                                                                                         pV244)) 
                                                                                       (return 
                                                                                        (let ((alpha 
                                                                                               (UTILITIES::freshMetaTyVar 
                                                                                                pV241))) 
                                                                                          (let ((t2 
                                                                                                 (TYPECHECKER::elaborateTerm 
                                                                                                  env 
                                                                                                  (car 
                                                                                                   pV244) 
                                                                                                  alpha))) 
                                                                                            (let ((t1 
                                                                                                   (TYPECHECKER::elaborateTerm 
                                                                                                    env 
                                                                                                    pV243 
                                                                                                    (cons 
                                                                                                     :|Arrow| 
                                                                                                     (vector 
                                                                                                      alpha 
                                                                                                      term_sort 
                                                                                                      pV241))))) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 t1 
                                                                                                 (cons 
                                                                                                  t2 
                                                                                                  nil)) 
                                                                                                pV241)))))))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV243) 
                                                                            :|Fun|) 
                                                                           (let ((pV248 
                                                                                  (cdr 
                                                                                   pV243))) 
                                                                             (if (consp 
                                                                                  pV244) 
                                                                                 (if (null 
                                                                                      (cdr 
                                                                                       pV244)) 
                                                                                     (return 
                                                                                      (let ((alpha 
                                                                                             (UTILITIES::freshMetaTyVar 
                                                                                              pV241))) 
                                                                                        (let ((t1 
                                                                                               (TYPECHECKER::elaborateTerm 
                                                                                                env 
                                                                                                pV243 
                                                                                                (cons 
                                                                                                 :|Arrow| 
                                                                                                 (vector 
                                                                                                  alpha 
                                                                                                  term_sort 
                                                                                                  pV241))))) 
                                                                                          (let ((t2 
                                                                                                 (TYPECHECKER::elaborateTerm 
                                                                                                  env 
                                                                                                  (car 
                                                                                                   pV244) 
                                                                                                  alpha))) 
                                                                                            (let ((t1 
                                                                                                   (if (cl:and 
                                                                                                        (BOOLEAN-SPEC::~ 
                                                                                                         (svref 
                                                                                                          env 
                                                                                                          3)) 
                                                                                                        (slang-built-in::slang-term-equals 
                                                                                                         (svref 
                                                                                                          pV248 
                                                                                                          0) 
                                                                                                         '(:|Equals|))) 
                                                                                                       (TYPECHECKER::adjustEqualitySort 
                                                                                                        env 
                                                                                                        (svref 
                                                                                                         pV248 
                                                                                                         1) 
                                                                                                        t1 
                                                                                                        t2) 
                                                                                                       t1))) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 t1 
                                                                                                 (cons 
                                                                                                  t2 
                                                                                                  nil)) 
                                                                                                pV241))))))))))) 
                                                                       (if (consp 
                                                                            pV244) 
                                                                           (if (null 
                                                                                (cdr 
                                                                                 pV244)) 
                                                                               (return 
                                                                                (let ((alpha 
                                                                                       (UTILITIES::freshMetaTyVar 
                                                                                        pV241))) 
                                                                                  (let ((t2 
                                                                                         (TYPECHECKER::elaborateTerm 
                                                                                          env 
                                                                                          (car 
                                                                                           pV244) 
                                                                                          alpha))) 
                                                                                    (let ((t1 
                                                                                           (TYPECHECKER::elaborateTerm 
                                                                                            env 
                                                                                            pV243 
                                                                                            (cons 
                                                                                             :|Arrow| 
                                                                                             (vector 
                                                                                              alpha 
                                                                                              term_sort 
                                                                                              pV241))))) 
                                                                                      (cons 
                                                                                       :|ApplyN| 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         t1 
                                                                                         (cons 
                                                                                          t2 
                                                                                          nil)) 
                                                                                        pV241))))))))))) 
                                                          (return 
                                                           (labels 
                                                             ((tagTermWithInfixInfo 
                                                               (term) 
                                                               (block 
                                                                nil 
                                                                (if (eq 
                                                                     (car term) 
                                                                     :|Fun|) 
                                                                    (let ((pV215 
                                                                           (cdr 
                                                                            term))) 
                                                                      (let ((pV218 
                                                                             (svref 
                                                                              pV215 
                                                                              2))
                                                                            (pV216 
                                                                             (svref 
                                                                              pV215 
                                                                              0))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV216) 
                                                                             :|OneName|) 
                                                                            (let ((pV220 
                                                                                   (cdr 
                                                                                    pV216))) 
                                                                              (let ((pV226 
                                                                                     (cdr 
                                                                                      pV220))
                                                                                    (pV225 
                                                                                     (car 
                                                                                      pV220))) 
                                                                                (progn (if (consp 
                                                                                            pV226) 
                                                                                           (return 
                                                                                            (cons 
                                                                                             :|Infix| 
                                                                                             (cons 
                                                                                              term 
                                                                                              pV226)))) 
                                                                                       (return 
                                                                                        (let ((x 
                                                                                               (TYPECHECKER::consistentTag 
                                                                                                (UTILITIES::findVarOrOps 
                                                                                                 env 
                                                                                                 pV225 
                                                                                                 pV218)))) 
                                                                                          (let ((pV193 
                                                                                                 (cdr 
                                                                                                  x))) 
                                                                                            (block 
                                                                                             nil 
                                                                                             (if (eq 
                                                                                                  t 
                                                                                                  (car 
                                                                                                   x)) 
                                                                                                 (progn (if (eq 
                                                                                                             (car 
                                                                                                              pV193) 
                                                                                                             :|Some|) 
                                                                                                            (return 
                                                                                                             (cons 
                                                                                                              :|Infix| 
                                                                                                              (cons 
                                                                                                               term 
                                                                                                               (cdr 
                                                                                                                pV193))))) 
                                                                                                        (return 
                                                                                                         (cons 
                                                                                                          :|Nonfix| 
                                                                                                          term)))) 
                                                                                             (return 
                                                                                              (progn (UTILITIES::|!error| 
                                                                                                      env 
                                                                                                      (STRING-SPEC::^ 
                                                                                                       "Inconsistent infix information for overloaded op: " 
                                                                                                       pV225) 
                                                                                                      pV218) 
                                                                                                     (cons 
                                                                                                      :|Nonfix| 
                                                                                                      term)))))))))) 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV216) 
                                                                                 :|TwoNames|) 
                                                                                (let ((pV219 
                                                                                       (cdr 
                                                                                        pV216))) 
                                                                                  (let ((pV223 
                                                                                         (svref 
                                                                                          pV219 
                                                                                          2))) 
                                                                                    (progn (if (consp 
                                                                                                pV223) 
                                                                                               (return 
                                                                                                (cons 
                                                                                                 :|Infix| 
                                                                                                 (cons 
                                                                                                  term 
                                                                                                  pV223)))) 
                                                                                           (return 
                                                                                            (let ((pV204 
                                                                                                   (UTILITIES::findTheOp2 
                                                                                                    env 
                                                                                                    (svref 
                                                                                                     pV219 
                                                                                                     0) 
                                                                                                    (svref 
                                                                                                     pV219 
                                                                                                     1)))) 
                                                                                              (block 
                                                                                               nil 
                                                                                               (if (eq 
                                                                                                    (car 
                                                                                                     pV204) 
                                                                                                    :|Some|) 
                                                                                                   (let ((pV207 
                                                                                                          (svref 
                                                                                                           (cdr 
                                                                                                            pV204) 
                                                                                                           1))) 
                                                                                                     (if (consp 
                                                                                                          pV207) 
                                                                                                         (return 
                                                                                                          (cons 
                                                                                                           :|Infix| 
                                                                                                           (cons 
                                                                                                            term 
                                                                                                            pV207)))))) 
                                                                                               (return 
                                                                                                (cons 
                                                                                                 :|Nonfix| 
                                                                                                 term)))))))) 
                                                                                (if (eq 
                                                                                     (car 
                                                                                      pV216) 
                                                                                     :|Equals|) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Infix| 
                                                                                      (cons 
                                                                                       term 
                                                                                       (cons 
                                                                                        '(:|Left|) 
                                                                                        20)))))))))) 
                                                                (return 
                                                                 (cons 
                                                                  :|Nonfix| 
                                                                  term))))) 
                                                             (let ((term 
                                                                    (INFIX::resolveInfixes 
                                                                     #'tagTermWithInfixInfo 
                                                                     pV241 
                                                                     pV240))) 
                                                               (TYPECHECKER::elaborateTerm 
                                                                env 
                                                                term 
                                                                term_sort)))))))))))))))))) 
   (return trm)))

(defun TYPECHECKER::elaborateTerm (env trm term_sort) 
  (TYPECHECKER::aux_elaborateTerm env trm term_sort))

(defun TYPECHECKER::checkSort (env srt) 
  (block 
   nil 
   (if (eq (car srt) :|TyVar|) 
       (return srt) 
       (if (eq (car srt) :|MetaTyVar|) 
           (return 
            (let ((x (STATE::|!!| (car (cdr srt))))) 
              (let ((pV4 (svref x 0))) 
                (block 
                 nil 
                 (if (eq (car pV4) :|Some|) 
                     (return (TYPECHECKER::checkSort env (cdr pV4)))) 
                 (return srt))))) 
           (if (eq (car srt) :|Base|) 
               (let ((pV41 (cdr srt))) 
                 (let ((pV59 (svref pV41 2))
                       (pV58 (svref pV41 1))
                       (pV57 (svref pV41 0))) 
                   (return 
                    (labels 
                      ((given_sort_str () 
                        (STRING-SPEC::^ 
                         (METASLANG::printQualifiedId pV57) 
                         (block 
                          nil 
                          (if (null pV58) 
                              (return "") 
                              (if (consp pV58) 
                                  (return 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     (STRING-SPEC::^ "(" "??") 
                                     (LIST-SPEC::foldl-1-1-1 
                                      #'(lambda (x) 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ (cdr x) ", ") 
                                          "??")) 
                                      "" 
                                      (cdr pV58))) 
                                    ")")))) 
                          (error "Nonexhaustive match failure in checkSort"))))) 
                      (let ((pV25 
                             (STANDARDSPEC::findAllSorts (svref env 5) pV57))) 
                        (block 
                         nil 
                         (if (null pV25) 
                             (return 
                              (progn (UTILITIES::|!error| 
                                      env 
                                      (STRING-SPEC::^ 
                                       (STRING-SPEC::^ 
                                        "Sort identifier in " 
                                        (given_sort_str)) 
                                       " has not been declared") 
                                      pV59) 
                                     (cons :|Base| (vector pV57 pV58 pV59)))) 
                             (if (consp pV25) 
                                 (let ((pV28 (cdr pV25))
                                       (pV27 (car pV25))) 
                                   (let ((pV30 (svref pV27 1))
                                         (pV29 (svref pV27 0))) 
                                     (return 
                                      (progn (if (cl:or 
                                                  (LIST-SPEC::|!null| pV28) 
                                                  (LIST-SPEC::|!exists|-1-1 
                                                   #'(lambda (alias) 
                                                      (slang-built-in::slang-term-equals 
                                                       alias 
                                                       pV57)) 
                                                   pV29)) 
                                                 (if (BOOLEAN-SPEC::~ 
                                                      ( =  
                                                       (LIST-SPEC::|!length| 
                                                        pV30) 
                                                       (LIST-SPEC::|!length| 
                                                        pV58))) 
                                                     (let ((found_sort_str 
                                                            (STRING-SPEC::^ 
                                                             (METASLANG::printAliases 
                                                              pV29) 
                                                             (block 
                                                              nil 
                                                              (if (null pV30) 
                                                                  (return "") 
                                                                  (if (consp 
                                                                       pV30) 
                                                                      (return 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         (STRING-SPEC::^ 
                                                                          "(" 
                                                                          (car 
                                                                           pV30)) 
                                                                         (LIST-SPEC::foldl-1-1-1 
                                                                          #'(lambda (x) 
                                                                             (STRING-SPEC::^ 
                                                                              (STRING-SPEC::^ 
                                                                               (cdr 
                                                                                x) 
                                                                               ", ") 
                                                                              (car 
                                                                               x))) 
                                                                          "" 
                                                                          (cdr 
                                                                           pV30))) 
                                                                        ")")))) 
                                                              (error 
                                                               "Nonexhaustive match failure in checkSort"))))) 
                                                       (UTILITIES::|!error| 
                                                        env 
                                                        (STRING-SPEC::^ 
                                                         (STRING-SPEC::^ 
                                                          (STRING-SPEC::^ 
                                                           "Sort reference " 
                                                           (given_sort_str)) 
                                                          " does not match declared sort ") 
                                                         found_sort_str) 
                                                        pV59)) 
                                                     nil) 
                                                 (let ((candidates_str 
                                                        (LIST-SPEC::foldl-1-1-1 
                                                         #'(lambda (x) 
                                                            (block 
                                                             nil 
                                                             (return 
                                                              (STRING-SPEC::^ 
                                                               (STRING-SPEC::^ 
                                                                (cdr x) 
                                                                ", ") 
                                                               (METASLANG::printAliases 
                                                                (svref (car x) 0)))) 
                                                             (error 
                                                              "Nonexhaustive match failure in checkSort"))) 
                                                         (METASLANG::printAliases 
                                                          pV29) 
                                                         pV28))) 
                                                   (UTILITIES::|!error| 
                                                    env 
                                                    (STRING-SPEC::^ 
                                                     (STRING-SPEC::^ 
                                                      (STRING-SPEC::^ 
                                                       "Sort reference " 
                                                       (given_sort_str)) 
                                                      " is ambiguous among ") 
                                                     candidates_str) 
                                                    pV59))) 
                                             (cons 
                                              :|Base| 
                                              (vector 
                                               (LIST-SPEC::hd pV29) 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'(lambda (instance_sort) 
                                                   (TYPECHECKER::checkSort 
                                                    env 
                                                    instance_sort)) 
                                                pV58) 
                                               pV59)))))))) 
                         (error "Nonexhaustive match failure in checkSort"))))))) 
               (if (eq (car srt) :|CoProduct|) 
                   (let ((pV40 (cdr srt))) 
                     (return 
                      (cons 
                       :|CoProduct| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (let ((pV33 (cdr x))
                                  (pV32 (car x))) 
                              (block 
                               nil 
                               (if (eq (car pV33) :|None|) 
                                   (return (cons pV32 '(:|None|))) 
                                   (if (eq (car pV33) :|Some|) 
                                       (return 
                                        (cons 
                                         pV32 
                                         (cons 
                                          :|Some| 
                                          (TYPECHECKER::checkSort env (cdr pV33))))))) 
                               (error "Nonexhaustive match failure in checkSort")))) 
                         (car pV40)) 
                        (cdr pV40))))) 
                   (if (eq (car srt) :|Product|) 
                       (let ((pV39 (cdr srt))) 
                         (return 
                          (cons 
                           :|Product| 
                           (cons 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (car x) 
                                 (TYPECHECKER::checkSort env (cdr x)))) 
                             (car pV39)) 
                            (cdr pV39))))) 
                       (if (eq (car srt) :|Quotient|) 
                           (let ((pV38 (cdr srt))) 
                             (let ((pV52 (svref pV38 2))) 
                               (return 
                                (let ((new_base_sort 
                                       (TYPECHECKER::checkSort 
                                        env 
                                        (svref pV38 0)))) 
                                  (let ((new_relation 
                                         (TYPECHECKER::elaborateTerm 
                                          env 
                                          (svref pV38 1) 
                                          (cons 
                                           :|Arrow| 
                                           (vector 
                                            (cons 
                                             :|Product| 
                                             (cons 
                                              (cons 
                                               (cons "1" new_base_sort) 
                                               (cons 
                                                (cons "2" new_base_sort) 
                                                nil)) 
                                              pV52)) 
                                            TYPECHECKER::type_bool 
                                            pV52))))) 
                                    (cons 
                                     :|Quotient| 
                                     (vector new_base_sort new_relation pV52))))))) 
                           (if (eq (car srt) :|Subsort|) 
                               (let ((pV37 (cdr srt))) 
                                 (let ((pV49 (svref pV37 2))) 
                                   (return 
                                    (let ((new_super_sort 
                                           (TYPECHECKER::checkSort 
                                            env 
                                            (svref pV37 0)))) 
                                      (let ((new_predicate 
                                             (TYPECHECKER::elaborateTerm 
                                              env 
                                              (svref pV37 1) 
                                              (cons 
                                               :|Arrow| 
                                               (vector 
                                                new_super_sort 
                                                TYPECHECKER::type_bool 
                                                pV49))))) 
                                        (cons 
                                         :|Subsort| 
                                         (vector 
                                          new_super_sort 
                                          new_predicate 
                                          pV49))))))) 
                               (if (eq (car srt) :|Arrow|) 
                                   (let ((pV36 (cdr srt))) 
                                     (return 
                                      (cons 
                                       :|Arrow| 
                                       (vector 
                                        (TYPECHECKER::checkSort 
                                         env 
                                         (svref pV36 0)) 
                                        (TYPECHECKER::checkSort 
                                         env 
                                         (svref pV36 1)) 
                                        (svref pV36 2))))))))))))) 
   (error "Nonexhaustive match failure in checkSort")))

(defun TYPECHECKER::checkSortScheme (pV1 pV2) 
  (block 
   nil 
   (return (cons (car pV2) (TYPECHECKER::checkSort pV1 (cdr pV2)))) 
   (error "Nonexhaustive match failure in checkSortScheme")))

(defun UTILITIES::sameCPSort? (s1 s2) 
  (block 
   nil 
   (if (eq (car s1) :|CoProduct|) 
       (let ((pV7 (car (cdr s1)))) 
         (if (eq (car s2) :|CoProduct|) 
             (let ((pV10 (car (cdr s2)))) 
               (return 
                (cl:and 
                 ( =  (LIST-SPEC::|!length| pV7) (LIST-SPEC::|!length| pV10)) 
                 (LIST-SPEC::all-1-1 
                  #'(lambda (x) 
                     (let ((cs1 (cdr x))
                           (id1 (car x))) 
                       (LIST-SPEC::|!exists|-1-1 
                        #'(lambda (x1) 
                           (cl:and 
                            (string=  id1 (car x1)) 
                            (slang-built-in::slang-term-equals cs1 (cdr x1)))) 
                        pV10))) 
                  pV7))))))) 
   (return nil)))

(defun UTILITIES::computeConstrMap-1 (spc) 
  (let ((sorts (svref spc 3))) 
    (let ((constrMap (cons :|Ref| STRINGMAP::empty))) 
      (labels 
        ((addConstr (id tvs cp_srt constrMap) 
          (let ((cMap (STATE::|!!| constrMap))) 
            (let ((pV2 (STRINGMAP::|!find| cMap id))) 
              (block 
               nil 
               (if (eq (car pV2) :|None|) 
                   (return 
                    (STATE::|:=| 
                     constrMap 
                     (STRINGMAP::insert cMap id (cons (cons tvs cp_srt) nil)))) 
                   (if (eq (car pV2) :|Some|) 
                       (let ((pV3 (cdr pV2))) 
                         (return 
                          (if (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (x) 
                                  (UTILITIES::sameCPSort? (cdr x) cp_srt)) 
                               pV3) 
                              nil 
                              (STATE::|:=| 
                               constrMap 
                               (STRINGMAP::insert 
                                cMap 
                                id 
                                (LIST-SPEC::|!cons| (cons tvs cp_srt) pV3)))))))) 
               (error "Nonexhaustive match failure in computeConstrMap")))))) 
        (labels 
          ((addSort (tvs srt constrMap) 
            (block 
             nil 
             (if (eq (car srt) :|CoProduct|) 
                 (return 
                  (LIST-SPEC::app-1-1 
                   #'(lambda (x) (addConstr (car x) tvs srt constrMap)) 
                   (car (cdr srt))))) 
             (return nil)))) 
          (progn (appAQualifierMap-1-1 
                  #'(lambda (x) 
                     (LIST-SPEC::app-1-1 
                      #'(lambda (x1) (addSort (car x1) (cdr x1) constrMap)) 
                      (svref x 2))) 
                  sorts) 
                 (STATE::|!!| constrMap)))))))

(defun UTILITIES::addConstrsEnv (pV1 pV2) 
  (block 
   nil 
   (return 
    (vector 
     (UTILITIES::computeConstrMap-1 pV2) 
     (svref pV1 1) 
     (svref pV1 2) 
     (svref pV1 3) 
     (svref pV1 4) 
     pV2 
     (svref pV1 6))) 
   (error "Nonexhaustive match failure in addConstrsEnv")))

(defun UTILITIES::checkErrors-1 (env) 
  (let ((errors (svref env 1))) 
    (labels 
      ((compare (pV2 pV3) 
        (block 
         nil 
         (return 
          (let ((pV1 (POSITION-SPEC::compare (cdr pV2) (cdr pV3)))) 
            (block 
             nil 
             (if (eq (car pV1) :|Equal|) 
                 (return (STRING-SPEC::compare (car pV2) (car pV3)))) 
             (return pV1)))) 
         (error "Nonexhaustive match failure in checkErrors")))) 
      (let ((errors 
             (MERGESORT::uniqueSort-1-1 
              #'(lambda (x) (compare (car x) (cdr x))) 
              (STATE::|!!| errors)))) errors))))

(defun UTILITIES::initialEnv (spc file) 
  (block 
   nil 
   (return 
    (let ((pV2 (UTILITIES::freshMetaTyVar (cons :|Internal| "ignored")))) 
      (block 
       nil 
       (if (eq (car pV2) :|MetaTyVar|) 
           (return 
            (vector 
             STRINGMAP::empty 
             (cons :|Ref| nil) 
             file 
             t 
             STRINGMAP::empty 
             (vector (svref spc 0) (svref spc 1) (svref spc 2) (svref spc 3)) 
             STRINGMAP::empty))) 
       (error "Nonexhaustive match failure in initialEnv")))) 
   (error "Nonexhaustive match failure in initialEnv")))

(defun UTILITIES::initializeMetaTyVar () (STATE::|:=| UTILITIES::counter 0))

(defun UTILITIES::secondPass (constrs errors file pV1 importMap internal vars) 
  (declare (ignore pV1)) 
  (vector constrs errors file nil importMap internal vars))

(defun UTILITIES::secondPass-1 (x) 
  (UTILITIES::secondPass 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun TYPECHECKER::elaboratePosSpec (given_spec filename) 
  (progn (UTILITIES::initializeMetaTyVar) 
         (let ((env_1 (UTILITIES::initialEnv given_spec filename))) 
           (block 
            nil 
            (let ((pV93 (svref given_spec 3))
                  (pV92 (svref given_spec 2))
                  (pV91 (svref given_spec 1))
                  (pV90 (svref given_spec 0))) 
              (let ((pV97 (svref pV90 3))
                    (pV96 (svref pV90 2))) 
                (return 
                 (labels 
                   ((elaborate_sort_0 (pV4 pV5 pV6) 
                     (block 
                      nil 
                      (return 
                       (if (BOOLEAN-SPEC::~ (memberQualifiedId pV4 pV5 pV97)) 
                           pV6 
                           (vector 
                            (svref pV6 0) 
                            (svref pV6 1) 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (def_0) 
                                (TYPECHECKER::checkSortScheme env_1 def_0)) 
                             (svref pV6 2))))) 
                      (error "Nonexhaustive match failure in elaboratePosSpec")))) 
                   (let ((sorts_1 
                          (mapiAQualifierMap-1-1 
                           #'(lambda (x) 
                              (elaborate_sort_0 
                               (svref x 0) 
                               (svref x 1) 
                               (svref x 2))) 
                           pV93))) 
                     (let ((env_2 
                            (UTILITIES::addConstrsEnv 
                             env_1 
                             (vector pV90 pV91 pV92 sorts_1)))) 
                       (labels 
                         ((elaborate_op_1 (poly?) 
                           #'(lambda (x) 
                              (let ((pV13 (svref x 2))) 
                                (block 
                                 nil 
                                 (let ((pV16 (svref pV13 2))) 
                                   (return 
                                    (if (BOOLEAN-SPEC::~ 
                                         (memberQualifiedId 
                                          (svref x 0) 
                                          (svref x 1) 
                                          pV96)) 
                                        pV13 
                                        (let ((sort_scheme_2 
                                               (TYPECHECKER::checkSortScheme 
                                                env_2 
                                                pV16))) 
                                          (vector 
                                           (svref pV13 0) 
                                           (svref pV13 1) 
                                           sort_scheme_2 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x1) 
                                               (let ((term_1 (cdr x1))) 
                                                 (let ((type_vars_1 (car pV16))) 
                                                   (let ((term_2 
                                                          (if (eq 
                                                               poly? 
                                                               (BOOLEAN-SPEC::~ 
                                                                (slang-built-in::slang-term-equals 
                                                                 type_vars_1 
                                                                 nil))) 
                                                              (TYPECHECKER::elaborateTerm 
                                                               env_2 
                                                               term_1 
                                                               (cdr 
                                                                sort_scheme_2)) 
                                                              term_1))) 
                                                     (cons type_vars_1 term_2))))) 
                                            (svref pV13 3))))))) 
                                 (error 
                                  "Nonexhaustive match failure in elaboratePosSpec")))))) 
                         (let ((ops_2_a 
                                (mapiAQualifierMap-1-1 (elaborate_op_1 t) pV91))) 
                           (let ((ops_2_b 
                                  (mapiAQualifierMap-1-1 
                                   (elaborate_op_1 nil) 
                                   ops_2_a))) 
                             (let ((ops_2_c 
                                    (mapiAQualifierMap-1-1 
                                     (elaborate_op_1 t) 
                                     ops_2_b))) 
                               (let ((ops_2 
                                      (mapiAQualifierMap-1-1 
                                       (elaborate_op_1 nil) 
                                       ops_2_c))) 
                                 (labels 
                                   ((elaborate_fm_1 
                                     (prop_type name type_vars_1 fm_1) 
                                     (let ((fm_2 
                                            (TYPECHECKER::elaborateTerm 
                                             env_2 
                                             fm_1 
                                             TYPECHECKER::type_bool))) 
                                       (vector prop_type name type_vars_1 fm_2)))) 
                                   (let ((props_2 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x) 
                                              (elaborate_fm_1 
                                               (svref x 0) 
                                               (svref x 1) 
                                               (svref x 2) 
                                               (svref x 3))) 
                                           pV92))) 
                                     (let ((env_3 
                                            (UTILITIES::secondPass-1 env_2))) 
                                       (labels 
                                         ((elaborate_sort_2 (pV18 pV19 pV20) 
                                           (declare (ignore pV18 pV19)) 
                                           (block 
                                            nil 
                                            (return 
                                             (vector 
                                              (svref pV20 0) 
                                              (svref pV20 1) 
                                              (LIST-SPEC::|!map|-1-1 
                                               #'(lambda (def_2) 
                                                  (TYPECHECKER::checkSortScheme 
                                                   env_3 
                                                   def_2)) 
                                               (svref pV20 2)))) 
                                            (error 
                                             "Nonexhaustive match failure in elaboratePosSpec")))) 
                                         (let ((sorts_3 
                                                (mapiAQualifierMap-1-1 
                                                 #'(lambda (x) 
                                                    (elaborate_sort_2 
                                                     (svref x 0) 
                                                     (svref x 1) 
                                                     (svref x 2))) 
                                                 sorts_1))) 
                                           (labels 
                                             ((elaborate_op_2 (pV81 pV82 pV83) 
                                               (block 
                                                nil 
                                                (return 
                                                 (if (BOOLEAN-SPEC::~ 
                                                      (memberQualifiedId 
                                                       pV81 
                                                       pV82 
                                                       pV96)) 
                                                     pV83 
                                                     (let ((pV78 
                                                            (TYPECHECKER::checkSortScheme 
                                                             env_3 
                                                             (svref pV83 2)))) 
                                                       (block 
                                                        nil 
                                                        (let ((pV80 (cdr pV78))
                                                              (pV79 (car pV78))) 
                                                          (return 
                                                           (let ((all_different? 
                                                                  (TYPECHECKER::checkDifferent 
                                                                   pV79 
                                                                   STRINGSET::empty))) 
                                                             (vector 
                                                              (svref pV83 0) 
                                                              (svref pV83 1) 
                                                              pV78 
                                                              (LIST-SPEC::|!map|-1-1 
                                                               #'(lambda (x) 
                                                                  (let ((term_2 
                                                                         (cdr x))) 
                                                                    (let ((pos 
                                                                           (METASLANG::termAnn 
                                                                            term_2))) 
                                                                      (let ((term_3 
                                                                             (TYPECHECKER::elaborateTerm 
                                                                              env_3 
                                                                              term_2 
                                                                              pV80))) 
                                                                        (let ((type_vars_used 
                                                                               (let ((tv_cell 
                                                                                      (cons 
                                                                                       :|Ref| 
                                                                                       nil))) 
                                                                                 (labels 
                                                                                   ((insert 
                                                                                     (tv) 
                                                                                     (STATE::|:=| 
                                                                                      tv_cell 
                                                                                      (LISTUTILITIES::insert 
                                                                                       tv 
                                                                                       (STATE::|!!| 
                                                                                        tv_cell))))) 
                                                                                   (labels 
                                                                                     ((record_type_vars_used 
                                                                                       (aSrt) 
                                                                                       (block 
                                                                                        nil 
                                                                                        (if (eq 
                                                                                             (car 
                                                                                              aSrt) 
                                                                                             :|MetaTyVar|) 
                                                                                            (return 
                                                                                             (let ((pV28 
                                                                                                    (STATE::|!!| 
                                                                                                     (car 
                                                                                                      (cdr 
                                                                                                       aSrt))))) 
                                                                                               (block 
                                                                                                nil 
                                                                                                (let ((pV29 
                                                                                                       (svref 
                                                                                                        pV28 
                                                                                                        0))) 
                                                                                                  (return 
                                                                                                   (block 
                                                                                                    nil 
                                                                                                    (if (eq 
                                                                                                         (car 
                                                                                                          pV29) 
                                                                                                         :|Some|) 
                                                                                                        (return 
                                                                                                         (record_type_vars_used 
                                                                                                          (cdr 
                                                                                                           pV29))) 
                                                                                                        (if (eq 
                                                                                                             (car 
                                                                                                              pV29) 
                                                                                                             :|None|) 
                                                                                                            (return 
                                                                                                             (UTILITIES::|!error| 
                                                                                                              env_3 
                                                                                                              (STRING-SPEC::^ 
                                                                                                               (STRING-SPEC::^ 
                                                                                                                (STRING-SPEC::^ 
                                                                                                                 (STRING-SPEC::^ 
                                                                                                                  "Incomplete sort for op " 
                                                                                                                  pV82) 
                                                                                                                 ":") 
                                                                                                                STRING-SPEC::newline) 
                                                                                                               (ANNSPECPRINTER::printSort 
                                                                                                                pV80)) 
                                                                                                              pos)))) 
                                                                                                    (error 
                                                                                                     "Nonexhaustive match failure in elaboratePosSpec")))) 
                                                                                                (error 
                                                                                                 "Nonexhaustive match failure in elaboratePosSpec")))) 
                                                                                            (if (eq 
                                                                                                 (car 
                                                                                                  aSrt) 
                                                                                                 :|TyVar|) 
                                                                                                (return 
                                                                                                 (insert 
                                                                                                  (car 
                                                                                                   (cdr 
                                                                                                    aSrt)))) 
                                                                                                (if (eq 
                                                                                                     (car 
                                                                                                      aSrt) 
                                                                                                     :|Product|) 
                                                                                                    (return 
                                                                                                     (LIST-SPEC::app-1-1 
                                                                                                      #'(lambda (x1) 
                                                                                                         (record_type_vars_used 
                                                                                                          (cdr 
                                                                                                           x1))) 
                                                                                                      (car 
                                                                                                       (cdr 
                                                                                                        aSrt)))) 
                                                                                                    (if (eq 
                                                                                                         (car 
                                                                                                          aSrt) 
                                                                                                         :|CoProduct|) 
                                                                                                        (return 
                                                                                                         (LIST-SPEC::app-1-1 
                                                                                                          #'(lambda (x1) 
                                                                                                             (let ((pV39 
                                                                                                                    (cdr 
                                                                                                                     x1))) 
                                                                                                               (block 
                                                                                                                nil 
                                                                                                                (if (eq 
                                                                                                                     (car 
                                                                                                                      pV39) 
                                                                                                                     :|Some|) 
                                                                                                                    (return 
                                                                                                                     (record_type_vars_used 
                                                                                                                      (cdr 
                                                                                                                       pV39)))) 
                                                                                                                (return 
                                                                                                                 nil)))) 
                                                                                                          (car 
                                                                                                           (cdr 
                                                                                                            aSrt)))) 
                                                                                                        (if (eq 
                                                                                                             (car 
                                                                                                              aSrt) 
                                                                                                             :|Subsort|) 
                                                                                                            (return 
                                                                                                             (record_type_vars_used 
                                                                                                              (svref 
                                                                                                               (cdr 
                                                                                                                aSrt) 
                                                                                                               0))) 
                                                                                                            (if (eq 
                                                                                                                 (car 
                                                                                                                  aSrt) 
                                                                                                                 :|Quotient|) 
                                                                                                                (return 
                                                                                                                 (record_type_vars_used 
                                                                                                                  (svref 
                                                                                                                   (cdr 
                                                                                                                    aSrt) 
                                                                                                                   0))) 
                                                                                                                (if (eq 
                                                                                                                     (car 
                                                                                                                      aSrt) 
                                                                                                                     :|Arrow|) 
                                                                                                                    (let ((pV50 
                                                                                                                           (cdr 
                                                                                                                            aSrt))) 
                                                                                                                      (return 
                                                                                                                       (progn (record_type_vars_used 
                                                                                                                               (svref 
                                                                                                                                pV50 
                                                                                                                                0)) 
                                                                                                                              (record_type_vars_used 
                                                                                                                               (svref 
                                                                                                                                pV50 
                                                                                                                                1))))) 
                                                                                                                    (if (eq 
                                                                                                                         (car 
                                                                                                                          aSrt) 
                                                                                                                         :|Base|) 
                                                                                                                        (return 
                                                                                                                         (LIST-SPEC::app-1-1 
                                                                                                                          #'record_type_vars_used 
                                                                                                                          (svref 
                                                                                                                           (cdr 
                                                                                                                            aSrt) 
                                                                                                                           1))))))))))) 
                                                                                        (error 
                                                                                         "Nonexhaustive match failure in elaboratePosSpec")))) 
                                                                                     (progn (record_type_vars_used 
                                                                                             pV80) 
                                                                                            (STATE::|!!| 
                                                                                             tv_cell))))))) 
                                                                          (let ((type_vars_3_b 
                                                                                 (if (LIST-SPEC::|!null| 
                                                                                      pV79) 
                                                                                     type_vars_used 
                                                                                     (if ( =  
                                                                                          (LIST-SPEC::|!length| 
                                                                                           type_vars_used) 
                                                                                          (LIST-SPEC::|!length| 
                                                                                           pV79)) 
                                                                                         pV79 
                                                                                         (let ((scheme 
                                                                                                (cons 
                                                                                                 pV79 
                                                                                                 pV80))) 
                                                                                           (let ((scheme 
                                                                                                  (ANNSPECPRINTER::printSortScheme-1 
                                                                                                   scheme))) 
                                                                                             (progn (UTILITIES::|!error| 
                                                                                                     env_3 
                                                                                                     (STRING-SPEC::^ 
                                                                                                      "mismatch between bound and free variables " 
                                                                                                      scheme) 
                                                                                                     pos) 
                                                                                                    pV79))))))) 
                                                                            (progn (if all_different? 
                                                                                       nil 
                                                                                       (UTILITIES::|!error| 
                                                                                        env_3 
                                                                                        (STRING-SPEC::^ 
                                                                                         "Repeated sort variables contained in " 
                                                                                         (ANNSPECPRINTER::printSortScheme-1 
                                                                                          (cons 
                                                                                           type_vars_3_b 
                                                                                           pV80))) 
                                                                                        pos)) 
                                                                                   (cons 
                                                                                    type_vars_3_b 
                                                                                    term_3)))))))) 
                                                               (svref pV83 3)))))) 
                                                        (error 
                                                         "Nonexhaustive match failure in elaboratePosSpec"))))) 
                                                (error 
                                                 "Nonexhaustive match failure in elaboratePosSpec")))) 
                                             (let ((ops_3 
                                                    (mapiAQualifierMap-1-1 
                                                     #'(lambda (x) 
                                                        (elaborate_op_2 
                                                         (svref x 0) 
                                                         (svref x 1) 
                                                         (svref x 2))) 
                                                     ops_2))) 
                                               (labels 
                                                 ((elaborate_fm_2 
                                                   (prop_type 
                                                    name 
                                                    type_vars_2 
                                                    fm_2) 
                                                   (let ((fm_3 
                                                          (TYPECHECKER::elaborateTerm 
                                                           env_3 
                                                           fm_2 
                                                           TYPECHECKER::type_bool))) 
                                                     (vector 
                                                      prop_type 
                                                      name 
                                                      type_vars_2 
                                                      fm_3)))) 
                                                 (let ((props_3 
                                                        (LIST-SPEC::|!map|-1-1 
                                                         #'(lambda (x) 
                                                            (elaborate_fm_2 
                                                             (svref x 0) 
                                                             (svref x 1) 
                                                             (svref x 2) 
                                                             (svref x 3))) 
                                                         props_2))) 
                                                   (let ((pV88 
                                                          (UTILITIES::checkErrors-1 
                                                           env_3))) 
                                                     (block 
                                                      nil 
                                                      (if (null pV88) 
                                                          (return 
                                                           (let ((x 
                                                                  (POSSPECTOSPEC::convertPosSpecToSpec-1 
                                                                   (vector 
                                                                    pV90 
                                                                    ops_3 
                                                                    props_3 
                                                                    sorts_3)))) 
                                                             (cons 
                                                              :|Spec| 
                                                              (vector 
                                                               (svref x 0) 
                                                               (svref x 1) 
                                                               (svref x 2) 
                                                               (svref x 3)))))) 
                                                      (return 
                                                       (cons :|Errors| pV88)))))))))))))))))))))))) 
            (error "Nonexhaustive match failure in elaboratePosSpec")))))

(defun SPECCALC::elaborateSpecM-1 (spc) 
  (SPECCALC::monadBind 
   #'SPECCALC::getCurrentURI-1 
   #'(lambda (uri) 
      (SPECCALC::monadBind 
       (SPECCALC::|!return| 
        (STRING-SPEC::^ (SPECCALC::uriToFullPath-1 uri) ".sw")) 
       #'(lambda (filename) 
          (let ((pV1 (TYPECHECKER::elaboratePosSpec spc filename))) 
            (block 
             nil 
             (if (eq (car pV1) :|Spec|) 
                 (return (SPECCALC::|!return| (cdr pV1))) 
                 (if (eq (car pV1) :|Errors|) 
                     (return 
                      (SPECCALC::raise (cons :|TypeCheckErrors| (cdr pV1)))))) 
             (error "Nonexhaustive match failure in elaborateSpecM"))))))))

(defun SPECCALC::elaborateSpecM (x0 x1 x2 x3) 
  (SPECCALC::elaborateSpecM-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::elaborateSpecM-1-1 (x1 x2) 
  (funcall (SPECCALC::elaborateSpecM-1 x1) x2))

(defun SPECCALC::equivFun?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivFun?-1-1 x1 x2)))

(defun SPECCALC::equivFun? (x0 x1 x2 x3) 
  (SPECCALC::equivFun?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivList?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivList?-1-1 x1 x2)))

(defun SPECCALC::equivList? (x0 x1 x2 x3) 
  (SPECCALC::equivList?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivOpt?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivOpt?-1-1 x1 x2)))

(defun SPECCALC::equivOpt? (x0 x1 x2 x3) 
  (SPECCALC::equivOpt?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivPattern? (x0 x1 x2 x3) 
  (SPECCALC::equivPattern?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivSort? (x0 x1 x2 x3) 
  (SPECCALC::equivSort?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivSortScheme?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivSortScheme?-1-1 x1 x2)))

(defun SPECCALC::equivSortScheme? (x0 x1 x2 x3) 
  (SPECCALC::equivSortScheme?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivTerm? (x0 x1 x2 x3) 
  (SPECCALC::equivTerm?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivTermScheme?-1 (x1) 
  #'(lambda (x2) (SPECCALC::equivTermScheme?-1-1 x1 x2)))

(defun SPECCALC::equivTermScheme? (x0 x1 x2 x3) 
  (SPECCALC::equivTermScheme?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::equivVar? (x0 x1 x2 x3) 
  (SPECCALC::equivVar?-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::|!error|-1-1 (x1 x2) (funcall (SPECCALC::|!error| x1) x2))

(defun SPECCALC::positionOf (pV1 |!position|) 
  (declare (ignore pV1)) 
  |!position|)

(defun SPECCALC::positionOf-1 (x) (SPECCALC::positionOf (car x) (cdr x)))

(defun SPECCALC::valueOf (value pV1) (declare (ignore pV1)) 
                                     value)

(defun SPECCALC::valueOf-1 (x) (SPECCALC::valueOf (car x) (cdr x)))

(defun SPECCALC::evaluateDiagElem (dgm timeStamp depURIs) 
  #'(lambda (elem) 
     (let ((pV7 (SPECCALC::valueOf-1 elem))) 
       (block 
        nil 
        (if (eq (car pV7) :|Node|) 
            (let ((pV9 (cdr pV7))) 
              (let ((pV15 (cdr pV9))
                    (pV14 (car pV9))) 
                (return 
                 (SPECCALC::monadBind 
                  (SPECCALC::evaluateTermInfo-1 pV15) 
                  #'(lambda (x) 
                     (let ((termDeps (svref x 2))
                           (termTime (svref x 1))) 
                       (let ((pV2 (SPECCALC::coerceToSpec (svref x 0)))) 
                         (block 
                          nil 
                          (if (eq (car pV2) :|Spec|) 
                              (return 
                               (SPECCALC::monadBind 
                                (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 
                                                            dgm) 
                                                           pV14) 
                                                  (cdr pV2)) 
                                         (SPECCALC::positionOf-1 pV15)) 
                                #'(lambda (newDgm) 
                                   (SPECCALC::|!return| 
                                    (vector 
                                     newDgm 
                                     (INTEGER-SPEC::|!max| timeStamp termTime) 
                                     (LISTUTILITIES::listUnion depURIs termDeps))))))) 
                          (return 
                           (SPECCALC::raise 
                            (cons 
                             :|TypeCheck| 
                             (cons 
                              (SPECCALC::positionOf-1 pV15) 
                              "diagram node not labeled with a specification")))))))))))) 
            (if (eq (car pV7) :|Edge|) 
                (let ((pV8 (cdr pV7))) 
                  (let ((pV13 (svref pV8 3))
                        (pV12 (svref pV8 2))
                        (pV11 (svref pV8 1))
                        (pV10 (svref pV8 0))) 
                    (return 
                     (SPECCALC::monadBind 
                      (SPECCALC::evaluateTermInfo-1 pV13) 
                      #'(lambda (x) 
                         (let ((termDeps (svref x 2))
                               (termTime (svref x 1))
                               (termValue (svref x 0))) 
                           (block 
                            nil 
                            (if (eq (car termValue) :|Morph|) 
                                (let ((pV6 (cdr termValue))) 
                                  (return 
                                   (if (CAT::edgeInDiagram?-1-1 dgm pV10) 
                                       (if (cl:and 
                                            (string=  
                                             pV11 
                                             (SKETCH::|!eval|-1-1 
                                              (SKETCH::src-1 (CAT::shape-1 dgm)) 
                                              pV10)) 
                                            (string=  
                                             pV12 
                                             (SKETCH::|!eval|-1-1 
                                              (SKETCH::target-1 
                                               (CAT::shape-1 dgm)) 
                                              pV10))) 
                                           (if (slang-built-in::slang-term-equals 
                                                pV6 
                                                (CAT::edgeLabel-1-1 dgm pV10)) 
                                               (SPECCALC::|!return| 
                                                (vector 
                                                 dgm 
                                                 (INTEGER-SPEC::|!max| 
                                                  timeStamp 
                                                  termTime) 
                                                 (LISTUTILITIES::listUnion 
                                                  depURIs 
                                                  termDeps))) 
                                               (SPECCALC::raise 
                                                (cons 
                                                 :|DiagError| 
                                                 (cons 
                                                  (SPECCALC::positionOf-1 pV13) 
                                                  (STRING-SPEC::^ 
                                                   (STRING-SPEC::^ "edge " pV10) 
                                                   " inconsistently labeled in diagram"))))) 
                                           (SPECCALC::raise 
                                            (cons 
                                             :|DiagError| 
                                             (cons 
                                              (SPECCALC::positionOf-1 pV13) 
                                              (STRING-SPEC::^ 
                                               (STRING-SPEC::^ "edge " pV10) 
                                               " has inconsisent source and/or target"))))) 
                                       (SPECCALC::monadBind 
                                        (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 
                                                                    dgm) 
                                                                   pV11) 
                                                          (SPECCALC::dom-1 pV6)) 
                                                 (SPECCALC::positionOf-1 pV13)) 
                                        #'(lambda (dgm1) 
                                           (SPECCALC::monadBind 
                                            (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 
                                                                        dgm1) 
                                                                       pV12) 
                                                              (SPECCALC::cod-1 
                                                               pV6)) 
                                                     (SPECCALC::positionOf-1 
                                                      pV13)) 
                                            #'(lambda (dgm2) 
                                               (let ((dgm3 
                                                      (CAT::labelEdge-1-1-1 
                                                       (CAT::addEdge-1-1-1-1 
                                                        dgm2 
                                                        pV10 
                                                        pV11 
                                                        pV12) 
                                                       pV10 
                                                       pV6))) 
                                                 (SPECCALC::|!return| 
                                                  (vector 
                                                   dgm3 
                                                   (INTEGER-SPEC::|!max| 
                                                    timeStamp 
                                                    termTime) 
                                                   (LISTUTILITIES::listUnion 
                                                    depURIs 
                                                    termDeps)))))))))))) 
                            (return 
                             (SPECCALC::raise 
                              (cons 
                               :|TypeCheck| 
                               (cons 
                                (SPECCALC::positionOf-1 pV13) 
                                "diagram edge not labeled by a morphism"))))))))))))) 
        (error "Nonexhaustive match failure in evaluateDiagElem")))))

(defun SPECCALC::evaluateDiagElem-1 (x) 
  (SPECCALC::evaluateDiagElem (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::ppAOpInfo-1 (|!opInfo|) 
  (let ((defs (svref |!opInfo| 3))
        (srtScheme (svref |!opInfo| 2))
        (names (svref |!opInfo| 0))) 
    (let ((ppNames 
           (block 
            nil 
            (if (null names) 
                (return 
                 (SYSTEM-SPEC::fail "ppAOpInfo: empty name list in sort info")) 
                (if (consp names) 
                    (if (null (cdr names)) 
                        (return (SPECCALC::ppQualifiedId (car names)))))) 
            (return 
             (WADLERLINDIG::ppConcat 
              (cons 
               (WADLERLINDIG::ppString "{") 
               (cons 
                (WADLERLINDIG::ppSep-1-1 
                 (WADLERLINDIG::ppString ",") 
                 (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppQualifiedId names)) 
                (cons (WADLERLINDIG::ppString "}") nil)))))))) 
      (let ((ppSrtScheme 
             (let ((pV7 (cdr srtScheme))
                   (pV6 (car srtScheme))) 
               (block 
                nil 
                (if (null pV6) (return (SPECCALC::ppASort pV7))) 
                (return 
                 (WADLERLINDIG::ppConcat 
                  (cons 
                   (WADLERLINDIG::ppString "fa (") 
                   (cons 
                    (WADLERLINDIG::ppSep-1-1 
                     (WADLERLINDIG::ppString ",") 
                     (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString pV6)) 
                    (cons 
                     (WADLERLINDIG::ppString ") ") 
                     (cons (SPECCALC::ppASort pV7) nil)))))) 
                (error "Nonexhaustive match failure in ppAOpInfo"))))) 
        (labels 
          ((doOpDef (type_vars term) 
            (WADLERLINDIG::ppGroup 
             (WADLERLINDIG::ppConcat 
              (cons 
               (WADLERLINDIG::ppString "def ") 
               (cons 
                (block 
                 nil 
                 (if (null type_vars) (return WADLERLINDIG::ppNil)) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString "fa (") 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      (WADLERLINDIG::ppString ",") 
                      (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString type_vars)) 
                     (cons (WADLERLINDIG::ppString ") ") nil)))))) 
                (cons 
                 ppNames 
                 (cons 
                  (WADLERLINDIG::ppGroup 
                   (WADLERLINDIG::ppIndent 
                    (WADLERLINDIG::ppConcat 
                     (cons 
                      (WADLERLINDIG::ppString " =") 
                      (cons 
                       WADLERLINDIG::ppBreak 
                       (cons 
                        (WADLERLINDIG::ppGroup (SPECCALC::ppATerm term)) 
                        nil)))))) 
                  nil)))))))) 
          (let ((ppDefs 
                 (block 
                  nil 
                  (if (null defs) 
                      (return WADLERLINDIG::ppNil) 
                      (if (consp defs) 
                          (let ((pV13 (car defs))) 
                            (if (null (cdr defs)) 
                                (return (doOpDef (car pV13) (cdr pV13))))))) 
                  (return 
                   (WADLERLINDIG::ppConcat 
                    (cons 
                     WADLERLINDIG::ppNewline 
                     (cons 
                      (WADLERLINDIG::ppString 
                       " (* Warning: Multiple Definitions for following op *) ") 
                      (cons 
                       WADLERLINDIG::ppNewline 
                       (cons 
                        (WADLERLINDIG::ppSep-1-1 
                         WADLERLINDIG::ppNewline 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (x1) (doOpDef (car x1) (cdr x1))) 
                          defs)) 
                        nil))))))))) 
            (WADLERLINDIG::ppConcat 
             (cons 
              ppNames 
              (cons 
               (WADLERLINDIG::ppString " : ") 
               (cons ppSrtScheme (cons ppDefs nil)))))))))))

(defun SPECCALC::ppASortInfo-1 (sortInfo) 
  (let ((defs (svref sortInfo 2))
        (|!tyVars| (svref sortInfo 1))
        (names (svref sortInfo 0))) 
    (let ((ppNames 
           (block 
            nil 
            (if (null names) 
                (return 
                 (SYSTEM-SPEC::fail "ppASortInfo: empty name list in sort info")) 
                (if (consp names) 
                    (if (null (cdr names)) 
                        (return (SPECCALC::ppQualifiedId (car names)))))) 
            (return 
             (WADLERLINDIG::ppConcat 
              (cons 
               (WADLERLINDIG::ppString "{") 
               (cons 
                (WADLERLINDIG::ppSep-1-1 
                 (WADLERLINDIG::ppString ",") 
                 (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppQualifiedId names)) 
                (cons (WADLERLINDIG::ppString "}") nil)))))))) 
      (labels 
        ((doSortDef (type_vars srt) 
          (WADLERLINDIG::ppConcat 
           (cons 
            ppNames 
            (cons 
             (doTyVars type_vars) 
             (cons 
              (WADLERLINDIG::ppString " = ") 
              (cons (SPECCALC::ppASort srt) nil))))))
         (doTyVars (ty_vars) 
          (block 
           nil 
           (if (null ty_vars) 
               (return WADLERLINDIG::ppNil) 
               (if (consp ty_vars) 
                   (progn (if (null (cdr ty_vars)) 
                              (return 
                               (WADLERLINDIG::ppString 
                                (STRING-SPEC::^ " " (car ty_vars))))) 
                          (return 
                           (WADLERLINDIG::ppConcat 
                            (cons 
                             (WADLERLINDIG::ppString " (") 
                             (cons 
                              (WADLERLINDIG::ppSep-1-1 
                               (WADLERLINDIG::ppString ",") 
                               (LIST-SPEC::|!map|-1-1 
                                #'WADLERLINDIG::ppString 
                                ty_vars)) 
                              (cons (WADLERLINDIG::ppString ")") nil)))))))) 
           (error "Nonexhaustive match failure in ppASortInfo")))) 
        (block 
         nil 
         (if (null defs) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons ppNames (cons (doTyVars |!tyVars|) nil)))) 
             (if (consp defs) 
                 (let ((pV15 (car defs))) 
                   (if (null (cdr defs)) 
                       (return (doSortDef (car pV15) (cdr pV15))))))) 
         (return 
          (WADLERLINDIG::ppConcat 
           (cons 
            WADLERLINDIG::ppNewline 
            (cons 
             (WADLERLINDIG::ppString 
              " (* Warning: Multiple Sort Definitions for following sort *) ") 
             (cons 
              WADLERLINDIG::ppNewline 
              (cons 
               (WADLERLINDIG::ppSep-1-1 
                WADLERLINDIG::ppNewline 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) (doSortDef (car x) (cdr x))) 
                 defs)) 
               nil)))))))))))

(defun SPECCALC::ppASpec-1 (spc) 
  (let ((properties (svref spc 2))) 
    (let ((ppImports 
           (block 
            nil 
            (return 
             (let ((ppNames 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x1) 
                        (WADLERLINDIG::ppString 
                         (STRING-SPEC::^ "import " (car x1)))) 
                     (svref (svref spc 0) 1)))) 
               (WADLERLINDIG::ppSep-1-1 WADLERLINDIG::ppNewline ppNames))) 
            (error "Nonexhaustive match failure in ppASpec")))) 
      (labels 
        ((doSortInfo (sortInfo) 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString "sort ") 
            (cons (SPECCALC::ppASortInfo-1 sortInfo) nil))))) 
        (labels 
          ((doOpInfo (|!opInfo|) 
            (WADLERLINDIG::ppConcat 
             (cons 
              (WADLERLINDIG::ppString "op ") 
              (cons (SPECCALC::ppAOpInfo-1 |!opInfo|) nil))))) 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString "spec {") 
            (cons 
             (WADLERLINDIG::ppIndent 
              (WADLERLINDIG::ppConcat 
               (cons 
                WADLERLINDIG::ppNewline 
                (cons 
                 (WADLERLINDIG::ppSep-1-1 
                  WADLERLINDIG::ppNewline 
                  (cons 
                   ppImports 
                   (cons 
                    (WADLERLINDIG::ppSep-1-1 
                     WADLERLINDIG::ppNewline 
                     (LIST-SPEC::|!map|-1-1 #'doSortInfo (sortInfosAsList-1 spc))) 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      WADLERLINDIG::ppNewline 
                      (LIST-SPEC::|!map|-1-1 #'doOpInfo (opInfosAsList-1 spc))) 
                     (cons 
                      (WADLERLINDIG::ppSep-1-1 
                       WADLERLINDIG::ppNewline 
                       (LIST-SPEC::|!map|-1-1 
                        #'SPECCALC::ppAProperty-1 
                        properties)) 
                      nil))))) 
                 nil)))) 
             (cons (WADLERLINDIG::ppString "}") nil)))))))))

(defun SPECCALC::ppMorphMap (|!map|) 
  (let ((abbrevMap 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (newMap) 
             #'(lambda (d) 
                #'(lambda (c) 
                   (if (slang-built-in::slang-term-equals d c) 
                       newMap 
                       (POLYMAP::update-1-1-1 newMap d c))))) 
          POLYMAP::emptyMap 
          |!map|))) 
    (if (slang-built-in::slang-term-equals abbrevMap POLYMAP::emptyMap) 
        (WADLERLINDIG::ppString "{}") 
        (WADLERLINDIG::ppGroup 
         (WADLERLINDIG::ppIndent 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString "{") 
            (cons 
             WADLERLINDIG::ppBreak 
             (cons 
              (WADLERLINDIG::ppGroup 
               (WADLERLINDIG::ppSep-1-1 
                (WADLERLINDIG::ppCons-1-1 
                 (WADLERLINDIG::ppString ",") 
                 WADLERLINDIG::ppBreak) 
                (POLYMAP::foldMap-1-1-1 
                 #'(lambda (l) 
                    #'(lambda (dom) 
                       #'(lambda (cod) 
                          (cons 
                           (WADLERLINDIG::ppConcat 
                            (cons 
                             (SPECCALC::ppQualifiedId dom) 
                             (cons 
                              (WADLERLINDIG::ppString " +-> ") 
                              (cons (SPECCALC::ppQualifiedId cod) nil)))) 
                           l)))) 
                 nil 
                 abbrevMap))) 
              (cons 
               WADLERLINDIG::ppBreak 
               (cons (WADLERLINDIG::ppString "}") nil)))))))))))

(defun SPECCALC::ppMorphism (pV1 pV2 opMap sortMap) 
  (declare (ignore pV1 pV2)) 
  (WADLERLINDIG::ppGroup 
   (WADLERLINDIG::ppConcat 
    (cons 
     (WADLERLINDIG::ppString "sort map = ") 
     (cons 
      (SPECCALC::ppMorphMap sortMap) 
      (cons 
       WADLERLINDIG::ppNewline 
       (cons 
        (WADLERLINDIG::ppString "op map = ") 
        (cons (SPECCALC::ppMorphMap opMap) nil))))))))

(defun SPECCALC::ppMorphism-1 (x) 
  (SPECCALC::ppMorphism (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::generateFileList-1 (uri) 
  (SPECCALC::|!return| 
   (cons (cons uri (STRING-SPEC::^ (SPECCALC::uriToFullPath-1 uri) ".sw")) nil)))


(defun SPECCALC::mapM (f) 
  #'(lambda (l) 
     (block 
      nil 
      (if (null l) 
          (return (SPECCALC::|!return| nil)) 
          (if (consp l) 
              (let ((pV4 (cdr l))) 
                (return 
                 (SPECCALC::monadBind 
                  (funcall f (car l)) 
                  #'(lambda (xNew) 
                     (SPECCALC::monadBind 
                      (funcall (SPECCALC::mapM f) pV4) 
                      #'(lambda (xsNew) (SPECCALC::|!return| (cons xNew xsNew)))))))))) 
      (error "Nonexhaustive match failure in mapM"))))

(defun SPECCALC::pathStringToCanonicalURI (str) 
  (let ((str 
         (STRING-SPEC::|!map|-1-1 
          #'(lambda (pV1) 
             (block nil (if (eq #\\ pV1) (return #\/)) (return pV1))) 
          str))) 
    (let ((absoluteString 
           (let ((pV4 (STRING-SPEC::explode str))) 
             (block 
              nil 
              (if (consp pV4) 
                  (let ((pV7 (cdr pV4))
                        (pV6 (car pV4))) 
                    (progn (if (eq #\/ pV6) (return str)) 
                           (if (consp pV7) 
                               (if (eq #\: (car pV7)) 
                                   (return 
                                    (STRING-SPEC::^ 
                                     (STRING-SPEC::^ 
                                      (CHAR-SPEC::toString 
                                       (CHAR-SPEC::toUpperCase pV6)) 
                                      ":") 
                                     (STRING-SPEC::implode (cdr pV7))))))))) 
              (return 
               (STRING-SPEC::|!++| 
                (STRING-SPEC::|!++| (IO-SPEC::getCurrentDirectory) "/") 
                str)))))) 
      (cons '(:|None|) (SPECCALC::splitStringAtChar-1-1 #\/ absoluteString)))))

(defun SPECCALC::pathToCanonicalURI (str) 
  (SPECCALC::|!return| (SPECCALC::pathStringToCanonicalURI str)))

(defun SPECCALC::getSpecPath (x2 x1 x0 x) 
  (funcall (let ((specware4Dirs 
                  (let ((pV1 (SYSTEM-SPEC::getEnv "SPECWARE4"))) 
                    (block 
                     nil 
                     (if (eq (car pV1) :|Some|) 
                         (return (cons (cdr pV1) nil)) 
                         (if (eq (car pV1) :|None|) (return nil))) 
                     (error "Nonexhaustive match failure in getSpecPath"))))) 
             (let ((currDir (IO-SPEC::getCurrentDirectory))) 
               (let ((strings 
                      (let ((pV4 (SYSTEM-SPEC::getEnv "SWPATH"))) 
                        (block 
                         nil 
                         (if (eq (car pV4) :|Some|) 
                             (return 
                              (let ((path 
                                     (SPECCALC::splitStringAtChar-1-1 
                                      SPECCALC::specPathSeparator 
                                      (cdr pV4)))) 
                                (LIST-SPEC::|!++| 
                                 (LIST-SPEC::|!++| path (cons currDir nil)) 
                                 (if (cl:or 
                                      (slang-built-in::slang-term-equals 
                                       specware4Dirs 
                                       nil) 
                                      (LIST-SPEC::|!member| 
                                       (LIST-SPEC::hd specware4Dirs) 
                                       path)) 
                                     nil 
                                     specware4Dirs))))) 
                         (return 
                          (LIST-SPEC::|!++| 
                           (cons currDir (cons "/" nil)) 
                           specware4Dirs)))))) 
                 (funcall (SPECCALC::mapM #'SPECCALC::pathToCanonicalURI) 
                          strings)))) 
           (vector x2 x1 x0 x)))

(defun SPECCALC::getSpecPath-1 (x) 
  (SPECCALC::getSpecPath (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::normalizeURI (hashSuffix path) 
  (labels 
    ((iterate (current) 
      #'(lambda (next) 
         (if (slang-built-in::slang-term-equals current next) 
             current 
             (funcall (iterate next) (onePass next)))))
     (onePass (elems) 
      (block 
       nil 
       (if (null elems) 
           (return nil) 
           (if (consp elems) 
               (let ((pV4 (cdr elems))
                     (pV3 (car elems))) 
                 (progn (if (consp pV4) 
                            (let ((pV7 (cdr pV4))
                                  (pV6 (car pV4))) 
                              (if (string=  "." pV6) 
                                  (return (cons pV3 pV7)) 
                                  (if (string=  ".." pV6) (return pV7))))) 
                        (return (cons pV3 (onePass pV4))))))) 
       (error "Nonexhaustive match failure in normalizeURI")))) 
    (cons 
     hashSuffix 
     (SPECCALC::addDevice? (funcall (iterate path) (onePass path))))))

(defun SPECCALC::removeLast (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "removeLast: encountered empty list")) 
       (if (consp elems) 
           (let ((pV4 (cdr elems))
                 (pV3 (car elems))) 
             (progn (if (null pV4) (return (SPECCALC::|!return| nil))) 
                    (return 
                     (SPECCALC::monadBind 
                      (SPECCALC::removeLast pV4) 
                      #'(lambda (suffix) 
                         (SPECCALC::|!return| (cons pV3 suffix))))))))) 
   (error "Nonexhaustive match failure in removeLast")))

(defun SPECCALC::generateURIList (uri) 
  (block 
   nil 
   (if (eq (car uri) :|SpecPath_Relative|) 
       (let ((pV18 (cdr uri))) 
         (let ((pV22 (cdr pV18))
               (pV21 (car pV18))) 
           (return 
            (SPECCALC::monadBind 
             #'SPECCALC::getSpecPath-1 
             #'(lambda (specPath) 
                (SPECCALC::|!return| 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) 
                     (SPECCALC::normalizeURI 
                      pV21 
                      (LIST-SPEC::|!++| (cdr x) pV22))) 
                  specPath))))))) 
       (if (eq (car uri) :|URI_Relative|) 
           (let ((pV17 (cdr uri))) 
             (let ((pV20 (cdr pV17))
                   (pV19 (car pV17))) 
               (return 
                (SPECCALC::monadBind 
                 #'SPECCALC::getCurrentURI-1 
                 #'(lambda (x) 
                    (let ((currentPath (cdr x))
                          (currentSuffix (car x))) 
                      (SPECCALC::monadBind 
                       (SPECCALC::removeLast currentPath) 
                       #'(lambda (root) 
                          (block 
                           nil 
                           (if (eq (car currentSuffix) :|Some|) 
                               (if (consp pV20) 
                                   (if (null (cdr pV20)) 
                                       (if (eq (car pV19) :|None|) 
                                           (return 
                                            (SPECCALC::|!return| 
                                             (cons 
                                              (SPECCALC::normalizeURI 
                                               (cons :|Some| (car pV20)) 
                                               currentPath) 
                                              (cons 
                                               (SPECCALC::normalizeURI 
                                                '(:|None|) 
                                                (LIST-SPEC::|!++| root pV20)) 
                                               nil)))))))) 
                           (return 
                            (SPECCALC::|!return| 
                             (cons 
                              (SPECCALC::normalizeURI 
                               pV19 
                               (LIST-SPEC::|!++| root pV20)) 
                              nil))) 
                           (error 
                            "Nonexhaustive match failure in generateURIList")))))))))))) 
   (error "Nonexhaustive match failure in generateURIList")))

(defun SPECCALC::lookupInLocalContext-1-1 (uri state) 
  (cons (cons :|Ok| (POLYMAP::evalPartial-1-1 (svref state 1) uri)) state))

(defun SPECCALC::lookupInLocalContext (x1) 
  #'(lambda (x2) (SPECCALC::lookupInLocalContext-1-1 x1 x2)))

(defun SPECCALC::lookupInGlobalContext-1-1 (uri state) 
  (cons (cons :|Ok| (POLYMAP::evalPartial-1-1 (svref state 0) uri)) state))

(defun SPECCALC::lookupInGlobalContext-1 (x1) 
  #'(lambda (x2) (SPECCALC::lookupInGlobalContext-1-1 x1 x2)))

(defparameter SPECCALC::futureTimeStamp 9999999999)

(defun SPECCALC::removeFromGlobalContext-1-1 (uri x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (POLYMAP::|!remove|-1-1 (svref x 0) uri) 
    (svref x 1) 
    (svref x 2) 
    (svref x 3))))

(defun SPECCALC::removeFromGlobalContext-1 (x1) 
  #'(lambda (x2) (SPECCALC::removeFromGlobalContext-1-1 x1 x2)))

(defun SPECCALC::setValidatedURI-1-1 (uri x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (svref x 0) 
    (svref x 1) 
    (svref x 2) 
    (LIST-SPEC::|!cons| uri (svref x 3)))))

(defun SPECCALC::setValidatedURI-1 (x1) 
  #'(lambda (x2) (SPECCALC::setValidatedURI-1-1 x1 x2)))

(defun SPECCALC::upToDate? (uri timeStamp) 
  (let ((|!fileName| (STRING-SPEC::^ (SPECCALC::uriToFullPath-1 uri) ".sw"))) 
    (INTEGER-SPEC::|!<=| (IO-SPEC::fileWriteTime |!fileName|) timeStamp)))

(defun SPECCALC::validatedURI?-1-1 (uri state) 
  (cons (cons :|Ok| (LIST-SPEC::|!member| uri (svref state 3))) state))

(defun SPECCALC::validatedURI?-1 (x1) 
  #'(lambda (x2) (SPECCALC::validatedURI?-1-1 x1 x2)))

(defun SPECCALC::validateCache-1 (uri) 
  (SPECCALC::monadBind 
   (SPECCALC::validatedURI?-1 uri) 
   #'(lambda (validated?) 
      (if validated? 
          (SPECCALC::|!return| 0) 
          (SPECCALC::monadBind 
           (SPECCALC::lookupInGlobalContext-1 uri) 
           #'(lambda (optValue) 
              (block 
               nil 
               (if (eq (car optValue) :|None|) 
                   (return (SPECCALC::|!return| SPECCALC::futureTimeStamp)) 
                   (if (eq (car optValue) :|Some|) 
                       (let ((pV3 (cdr optValue))) 
                         (let ((pV5 (svref pV3 1))) 
                           (return 
                            (SPECCALC::monadBind 
                             (funcall (funcall (SPECCALC::foldM 
                                                #'(lambda (val) 
                                                   #'(lambda (depURI) 
                                                      (SPECCALC::monadBind 
                                                       (SPECCALC::validateCache-1 
                                                        depURI) 
                                                       #'(lambda (dVal) 
                                                          (SPECCALC::|!return| 
                                                           (INTEGER-SPEC::|!max| 
                                                            val 
                                                            dVal))))))) 
                                               pV5) 
                                      (svref pV3 2)) 
                             #'(lambda (rVal) 
                                (if (cl:and 
                                     (INTEGER-SPEC::|!>=| pV5 rVal) 
                                     (SPECCALC::upToDate? uri rVal)) 
                                    (SPECCALC::monadSeq 
                                     (SPECCALC::setValidatedURI-1 uri) 
                                     (SPECCALC::|!return| rVal)) 
                                    (SPECCALC::monadSeq 
                                     (SPECCALC::removeFromGlobalContext-1 uri) 
                                     (SPECCALC::|!return| 
                                      SPECCALC::futureTimeStamp)))))))))) 
               (error "Nonexhaustive match failure in validateCache"))))))))

(defun SPECCALC::searchContextForURI (uris) 
  (block 
   nil 
   (if (null uris) 
       (return (SPECCALC::|!return| '(:|None|))) 
       (if (consp uris) 
           (let ((pV12 (cdr uris))
                 (pV11 (car uris))) 
             (return 
              (SPECCALC::monadBind 
               (SPECCALC::lookupInGlobalContext-1 pV11) 
               #'(lambda (optValue) 
                  (block 
                   nil 
                   (if (eq (car optValue) :|Some|) 
                       (let ((pV5 (cdr optValue))) 
                         (let ((pV7 (svref pV5 1))
                               (pV6 (svref pV5 0))) 
                           (return 
                            (block 
                             nil 
                             (if (eq (car pV6) :|InProcess|) 
                                 (return 
                                  (SPECCALC::raise 
                                   (cons 
                                    :|CircularDefinition| 
                                    (cons (car pV11) (cdr pV11)))))) 
                             (return 
                              (SPECCALC::monadBind 
                               (SPECCALC::validateCache-1 pV11) 
                               #'(lambda (cacheTS) 
                                  (SPECCALC::|!return| 
                                   (if (INTEGER-SPEC::|!<=| cacheTS pV7) 
                                       (cons 
                                        :|Some| 
                                        (cons 
                                         (vector pV6 pV7 (cons pV11 nil)) 
                                         pV11)) 
                                       '(:|None|)))))))))) 
                       (if (eq (car optValue) :|None|) 
                           (return (SPECCALC::searchContextForURI pV12)))) 
                   (error "Nonexhaustive match failure in searchContextForURI")))))))) 
   (error "Nonexhaustive match failure in searchContextForURI")))

(defun SPECCALC::fileExistsAndReadable? (|!fileName|) 
  (SPECCALC::|!return| (IO-SPEC::fileExistsAndReadable |!fileName|)))

(defun SPECCALC::inSameFile? (uri currentURI) 
  (block 
   nil 
   (if (eq (car (car uri)) :|Some|) 
       (return (slang-built-in::slang-term-equals (cdr uri) (cdr currentURI)))) 
   (return nil)))

(defun SPECCALC::getLocalContext (globalContext localContext uri validatedURIs) 
  (cons 
   (cons :|Ok| localContext) 
   (vector globalContext localContext uri validatedURIs)))

(defun SPECCALC::getLocalContext-1 (x) 
  (SPECCALC::getLocalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::setCurrentURI-1-1 (newURI x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (svref x 0) 
    (svref x 1) 
    (cons :|Some| (cons (car newURI) (cdr newURI))) 
    (svref x 3))))

(defun SPECCALC::setCurrentURI-1 (x1) 
  #'(lambda (x2) (SPECCALC::setCurrentURI-1-1 x1 x2)))

(defun SPECCALC::setLocalContext (x1) 
  #'(lambda (x2) (SPECCALC::setLocalContext-1-1 x1 x2)))

(defun SPECCALC::evaluateGlobalDecls (pV1 path) 
  (declare (ignore pV1)) 
  #'(lambda (|!fileName|) 
     #'(lambda (decls) 
        (labels 
          ((evaluateGlobalDecl (name term) 
            (let ((newURI (cons (cons :|Some| name) path))) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 newURI) 
               (SPECCALC::monadBind 
                (SPECCALC::evaluateTermInfo-1 term) 
                #'(lambda (x) 
                   (funcall (SPECCALC::bindInGlobalContext-1 newURI) 
                            (vector 
                             (svref x 0) 
                             (INTEGER-SPEC::|!max| 
                              (svref x 1) 
                              (IO-SPEC::fileWriteTime |!fileName|)) 
                             (svref x 2))))))))) 
          (SPECCALC::monadBind 
           #'SPECCALC::getCurrentURI-1 
           #'(lambda (saveURI) 
              (SPECCALC::monadBind 
               #'SPECCALC::getLocalContext-1 
               #'(lambda (saveLocalContext) 
                  (SPECCALC::monadSeq 
                   #'SPECCALC::clearLocalContext-1 
                   (SPECCALC::monadSeq 
                    (funcall (SPECCALC::mapM 
                              #'(lambda (x) 
                                 (evaluateGlobalDecl (car x) (cdr x)))) 
                             decls) 
                    (SPECCALC::monadSeq 
                     (SPECCALC::setCurrentURI-1 saveURI) 
                     (SPECCALC::setLocalContext saveLocalContext))))))))))))

(defun SPECCALC::evaluateGlobalDecls-1 (x) 
  (SPECCALC::evaluateGlobalDecls (car x) (cdr x)))

(defun SPECCALC::parseFile (file) 
  (let ((file (LISP-SPEC::|!string| file))) 
    (let ((result 
           (LISP-SPEC::|!apply| 
            (LISP-SPEC::|!symbol| "PARSER4" "PARSEFILE") 
            (cons file nil)))) (LISP-SPEC::uncell result))))

(defun SPECCALC::loadFile-1 (uri) 
  #'(lambda (|!fileName|) 
     (let ((pV7 (SPECCALC::parseFile |!fileName|))) 
       (block 
        nil 
        (if (eq (car pV7) :|None|) 
            (return (SPECCALC::raise (cons :|ParserError| |!fileName|))) 
            (if (eq (car pV7) :|Some|) 
                (return 
                 (let ((pV4 (SPECCALC::valueOf-1 (cdr pV7)))) 
                   (block 
                    nil 
                    (if (eq (car pV4) :|Term|) 
                        (let ((pV6 (cdr pV4))) 
                          (return 
                           (block 
                            nil 
                            (if (eq (car (car uri)) :|Some|) 
                                (return (SPECCALC::|!return| nil))) 
                            (return 
                             (SPECCALC::monadBind 
                              #'SPECCALC::getCurrentURI-1 
                              #'(lambda (saveURI) 
                                 (SPECCALC::monadBind 
                                  #'SPECCALC::getLocalContext-1 
                                  #'(lambda (saveLocalContext) 
                                     (SPECCALC::monadSeq 
                                      (SPECCALC::setCurrentURI-1 uri) 
                                      (SPECCALC::monadSeq 
                                       #'SPECCALC::clearLocalContext-1 
                                       (SPECCALC::monadSeq 
                                        (funcall (SPECCALC::bindInGlobalContext-1 
                                                  uri) 
                                                 (vector '(:|InProcess|) 0 nil)) 
                                        (SPECCALC::monadBind 
                                         (SPECCALC::evaluateTermInfo-1 pV6) 
                                         #'(lambda (x) 
                                            (SPECCALC::monadSeq 
                                             (SPECCALC::setCurrentURI-1 saveURI) 
                                             (SPECCALC::monadSeq 
                                              (SPECCALC::setLocalContext 
                                               saveLocalContext) 
                                              (funcall (SPECCALC::bindInGlobalContext-1 
                                                        uri) 
                                                       (vector 
                                                        (svref x 0) 
                                                        (INTEGER-SPEC::|!max| 
                                                         (svref x 1) 
                                                         (IO-SPEC::fileWriteTime 
                                                          |!fileName|)) 
                                                        (svref x 2)))))))))))))))))) 
                        (if (eq (car pV4) :|Decls|) 
                            (return 
                             (funcall (funcall (SPECCALC::evaluateGlobalDecls-1 
                                                uri) 
                                               |!fileName|) 
                                      (cdr pV4))))) 
                    (error "Nonexhaustive match failure in loadFile")))))) 
        (error "Nonexhaustive match failure in loadFile")))))

(defun SPECCALC::searchFileSystemForURI (|!position| relURI pairs currentURI) 
  (block 
   nil 
   (if (null pairs) 
       (return 
        (SPECCALC::raise (cons :|FileNotFound| (cons |!position| relURI)))) 
       (if (consp pairs) 
           (let ((pV10 (cdr pairs))
                 (pV9 (car pairs))) 
             (let ((pV12 (cdr pV9))
                   (pV11 (car pV9))) 
               (return 
                (SPECCALC::monadBind 
                 (SPECCALC::fileExistsAndReadable? pV12) 
                 #'(lambda (test) 
                    (if (cl:and 
                         test 
                         (BOOLEAN-SPEC::~ 
                          (SPECCALC::inSameFile? pV11 currentURI))) 
                        (SPECCALC::monadSeq 
                         (funcall (SPECCALC::loadFile-1 pV11) pV12) 
                         (SPECCALC::monadBind 
                          (SPECCALC::lookupInGlobalContext-1 pV11) 
                          #'(lambda (optValue) 
                             (block 
                              nil 
                              (if (eq (car optValue) :|Some|) 
                                  (let ((pV3 (cdr optValue))) 
                                    (return 
                                     (SPECCALC::|!return| 
                                      (cons 
                                       (vector 
                                        (svref pV3 0) 
                                        (svref pV3 1) 
                                        (cons pV11 nil)) 
                                       pV11)))) 
                                  (if (eq (car optValue) :|None|) 
                                      (return 
                                       (SPECCALC::raise 
                                        (cons 
                                         :|URINotFound| 
                                         (cons |!position| relURI)))))) 
                              (error 
                               "Nonexhaustive match failure in searchFileSystemForURI"))))) 
                        (SPECCALC::searchFileSystemForURI 
                         |!position| 
                         relURI 
                         pV10 
                         currentURI))))))))) 
   (error "Nonexhaustive match failure in searchFileSystemForURI")))

(defun SPECCALC::evaluateReturnURI (|!position|) 
  #'(lambda (uri) 
     (SPECCALC::monadBind 
      (SPECCALC::lookupInLocalContext uri) 
      #'(lambda (optValue) 
         (SPECCALC::monadBind 
          #'SPECCALC::getCurrentURI-1 
          #'(lambda (currentURI) 
             (block 
              nil 
              (if (eq (car optValue) :|Some|) 
                  (return (SPECCALC::|!return| (cons (cdr optValue) currentURI))) 
                  (if (eq (car optValue) :|None|) 
                      (return 
                       (SPECCALC::monadBind 
                        (SPECCALC::generateURIList uri) 
                        #'(lambda (uriList) 
                           (SPECCALC::monadBind 
                            (SPECCALC::searchContextForURI uriList) 
                            #'(lambda (optValue1) 
                               (block 
                                nil 
                                (if (eq (car optValue1) :|Some|) 
                                    (return 
                                     (SPECCALC::|!return| (cdr optValue1))) 
                                    (if (eq (car optValue1) :|None|) 
                                        (return 
                                         (SPECCALC::monadBind 
                                          (funcall (funcall (SPECCALC::foldM 
                                                             #'(lambda (l) 
                                                                #'(lambda (uri) 
                                                                   (SPECCALC::monadBind 
                                                                    (SPECCALC::generateFileList-1 
                                                                     uri) 
                                                                    #'(lambda (pair) 
                                                                       (SPECCALC::|!return| 
                                                                        (LIST-SPEC::|!++| 
                                                                         l 
                                                                         pair))))))) 
                                                            nil) 
                                                   uriList) 
                                          #'(lambda (uriPathPairs) 
                                             (SPECCALC::searchFileSystemForURI 
                                              |!position| 
                                              uri 
                                              uriPathPairs 
                                              currentURI)))))) 
                                (error 
                                 "Nonexhaustive match failure in evaluateReturnURI"))))))))) 
              (error "Nonexhaustive match failure in evaluateReturnURI"))))))))

(defun SPECCALC::evaluateURI (|!position|) 
  #'(lambda (uri) 
     (SPECCALC::monadBind 
      (funcall (SPECCALC::evaluateReturnURI |!position|) uri) 
      #'(lambda (x) (SPECCALC::|!return| (car x))))))

(defun SPECCALC::splitAtChar-1-1 (|!char| charList) 
  (labels 
    ((parseCharList (chars) 
      (block 
       nil 
       (if (null chars) 
           (return nil) 
           (if (consp chars) 
               (return 
                (if (eq (car chars) |!char|) 
                    (parseCharList (cdr chars)) 
                    (let ((pV1 
                           (SPECCALC::takeWhile-1-1 
                            #'(lambda (c) (BOOLEAN-SPEC::~ (eq c |!char|))) 
                            chars))) 
                      (block 
                       nil 
                       (return (cons (car pV1) (parseCharList (cdr pV1)))) 
                       (error "Nonexhaustive match failure in splitAtChar"))))))) 
       (error "Nonexhaustive match failure in splitAtChar")))) 
    (parseCharList charList)))

(defun SPECCALC::|!first| (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "first: encountered empty list")) 
       (if (consp elems) (return (SPECCALC::|!return| (car elems))))) 
   (error "Nonexhaustive match failure in first")))

(defun SPECCALC::|!last| (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "last: encountered empty list")) 
       (if (consp elems) 
           (let ((pV5 (cdr elems))) 
             (progn (if (null pV5) (return (SPECCALC::|!return| (car elems)))) 
                    (return (SPECCALC::|!last| pV5)))))) 
   (error "Nonexhaustive match failure in last")))

(defun SPECCALC::pathToRelativeURI (str) 
  (let ((charList (STRING-SPEC::explode str))) 
    (let ((pathElems (SPECCALC::splitAtChar-1-1 #\/ charList))) 
      (labels 
        ((validElem (charList) 
          (funcall (SPECCALC::|!when| (LIST-SPEC::|!member| #\# charList)) 
                   (SPECCALC::raise 
                    (cons :|SyntaxError| "URI path element contains # symbol"))))) 
        (SPECCALC::monadSeq 
         (funcall (SPECCALC::|!when| 
                   (slang-built-in::slang-term-equals pathElems nil)) 
                  (SPECCALC::raise (cons :|SyntaxError| "Empty URI"))) 
         (SPECCALC::monadBind 
          (SPECCALC::|!last| pathElems) 
          #'(lambda (suffix) 
             (SPECCALC::monadBind 
              (SPECCALC::removeLast pathElems) 
              #'(lambda (pathPrefix) 
                 (SPECCALC::monadSeq 
                  (funcall (SPECCALC::mapM #'validElem) pathPrefix) 
                  (SPECCALC::monadBind 
                   (SPECCALC::|!first| suffix) 
                   #'(lambda (firstSuffixChar) 
                      (SPECCALC::monadBind 
                       (SPECCALC::|!last| suffix) 
                       #'(lambda (lastSuffixChar) 
                          (SPECCALC::monadSeq 
                           (funcall (SPECCALC::|!when| (eq firstSuffixChar #\#)) 
                                    (SPECCALC::raise 
                                     (cons :|SyntaxError| "Misplaced #"))) 
                           (SPECCALC::monadSeq 
                            (funcall (SPECCALC::|!when| (eq lastSuffixChar #\#)) 
                                     (SPECCALC::raise 
                                      (cons :|SyntaxError| "Misplaced #"))) 
                            (let ((pV14 (SPECCALC::splitAtChar-1-1 #\# suffix))) 
                              (block 
                               nil 
                               (if (null pV14) 
                                   (return 
                                    (SPECCALC::|!error| 
                                     "pathToRelativeURI: Internal error")) 
                                   (if (consp pV14) 
                                       (let ((pV17 (cdr pV14))
                                             (pV16 (car pV14))) 
                                         (if (null pV17) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (consp charList) 
                                                   (if (eq #\/ (car charList)) 
                                                       (return 
                                                        (SPECCALC::|!return| 
                                                         (cons 
                                                          :|SpecPath_Relative| 
                                                          (cons 
                                                           '(:|None|) 
                                                           (LIST-SPEC::|!map|-1-1 
                                                            #'STRING-SPEC::implode 
                                                            (LIST-SPEC::|!++| 
                                                             pathPrefix 
                                                             (cons pV16 nil))))))))) 
                                               (return 
                                                (SPECCALC::|!return| 
                                                 (cons 
                                                  :|URI_Relative| 
                                                  (cons 
                                                   '(:|None|) 
                                                   (LIST-SPEC::|!map|-1-1 
                                                    #'STRING-SPEC::implode 
                                                    (LIST-SPEC::|!++| 
                                                     pathPrefix 
                                                     (cons pV16 nil))))))))) 
                                             (if (consp pV17) 
                                                 (let ((pV19 (car pV17))) 
                                                   (if (null (cdr pV17)) 
                                                       (return 
                                                        (block 
                                                         nil 
                                                         (if (consp charList) 
                                                             (if (eq 
                                                                  #\/ 
                                                                  (car charList)) 
                                                                 (return 
                                                                  (SPECCALC::|!return| 
                                                                   (cons 
                                                                    :|SpecPath_Relative| 
                                                                    (cons 
                                                                     (cons 
                                                                      :|Some| 
                                                                      (STRING-SPEC::implode 
                                                                       pV19)) 
                                                                     (LIST-SPEC::|!map|-1-1 
                                                                      #'STRING-SPEC::implode 
                                                                      (LIST-SPEC::|!++| 
                                                                       pathPrefix 
                                                                       (cons 
                                                                        pV16 
                                                                        nil))))))))) 
                                                         (return 
                                                          (SPECCALC::|!return| 
                                                           (cons 
                                                            :|URI_Relative| 
                                                            (cons 
                                                             (cons 
                                                              :|Some| 
                                                              (STRING-SPEC::implode 
                                                               pV19)) 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'STRING-SPEC::implode 
                                                              (LIST-SPEC::|!++| 
                                                               pathPrefix 
                                                               (cons pV16 nil)))))))))))))))) 
                               (return 
                                (SPECCALC::raise 
                                 (cons 
                                  :|SyntaxError| 
                                  "URI contains two or more # symbols")))))))))))))))))))))


(defun SPECCALC::getBaseSpec () 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToRelativeURI "/Library/Base") 
           #'(lambda (base_URI) 
              (SPECCALC::monadBind 
               (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                        base_URI) 
               #'(lambda (x) 
                  (let ((pV3 (svref x 0))) 
                    (block 
                     nil 
                     (if (eq (car pV3) :|Spec|) 
                         (return 
                          (SPECCALC::monadSeq 
                           #'SPECWARE::saveSpecwareState-1 
                           (SPECCALC::|!return| (cdr pV3))))) 
                     (error "Nonexhaustive match failure in getBaseSpec")))))))))) 
    (labels 
      ((myHandler (except) 
        (SPECCALC::monadSeq 
         (SPECWARE::toplevelHandler except) 
         (SPECCALC::|!return| emptySpec)))) 
      (let ((x (SPECCALC::|!catch|-1-1-1 run #'myHandler SPECWARE::ignoredState))) 
        (let ((pV10 (car x))) 
          (block 
           nil 
           (if (eq (car pV10) :|Ok|) 
               (return (cdr pV10)) 
               (if (eq (car pV10) :|Exception|) 
                   (return (SYSTEM-SPEC::fail "Can't find base spec!")))) 
           (error "Nonexhaustive match failure in getBaseSpec")))))))

(defun SPECCALC::makeMorphism (dom_spec cod_spec sort_map op_map) 
  (vector cod_spec dom_spec op_map sort_map))

(defun SPECCALC::makeSpecCocone-1-1-1 (dg apex_spec cc_map) 
  (let ((apex_functor (CAT::functor-1 dg))) 
    (let ((cc_nt (NATTRANS::build-1-1-1 (CAT::functor-1 dg) apex_functor cc_map))) 
      (vector apex_spec dg cc_nt))))

(defun SPECCALC::makeSpecInitialCocone-1-1-1 (dg apex_spec cc_map) 
  (let ((cat (FUNCTOR::cod-1 (CAT::functor-1 dg)))) 
    (cons 
     (SPECCALC::makeSpecCocone-1-1-1 dg apex_spec cc_map) 
     #'(lambda (other_cocone) (CAT::ident-1-1 cat (CAT::initialObject-1 cat))))))


(defun SPECCALC::makeTranslateOpRule (dom_qid cod_qid cod_aliases) 
  (let ((rule_ 
         (cons 
          :|Op| 
          (vector 
           (cons dom_qid '(:|None|)) 
           (cons cod_qid '(:|None|)) 
           cod_aliases)))) (cons rule_ (cons :|Internal| "Colimit Op"))))

(defun SPECCALC::makeTranslateOpRule-1 (x) 
  (SPECCALC::makeTranslateOpRule (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::makeTranslateSortRule (dom_qid cod_qid cod_aliases) 
  (cons 
   (cons :|Sort| (vector dom_qid cod_qid cod_aliases)) 
   (cons :|Internal| "Colimit Sort")))

(defun SPECCALC::makeTranslateSortRule-1 (x) 
  (SPECCALC::makeTranslateSortRule (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1
 (dg vqid_to_apex_qid_and_aliases extract_non_base_items make_translate_rule) 
  (CAT::foldOverVertices-1-1-1 
   #'(lambda (vertex_to_translation) 
      #'(lambda (vertex) 
         (let ((spc (CAT::vertexLabel-1-1 dg vertex))) 
           (let ((translate_rules 
                  (LIST-SPEC::foldl-1-1-1 
                   #'(lambda (x) 
                      (let ((pV4 (car x))) 
                        (block 
                         nil 
                         (return 
                          (let ((vertex_qid 
                                 (cons 
                                  :|Qualified| 
                                  (cons (svref pV4 0) (svref pV4 1))))) 
                            (let ((pV1 
                                   (POLYMAP::|!eval|-1-1 
                                    vqid_to_apex_qid_and_aliases 
                                    (cons vertex vertex_qid)))) 
                              (block 
                               nil 
                               (return 
                                (cons 
                                 (funcall make_translate_rule 
                                          (vector vertex_qid (car pV1) (cdr pV1))) 
                                 (cdr x))) 
                               (error 
                                "Nonexhaustive match failure in makeVertexToTranslateRulesMap"))))) 
                         (error 
                          "Nonexhaustive match failure in makeVertexToTranslateRulesMap")))) 
                   nil 
                   (funcall extract_non_base_items spc)))) 
             (POLYMAP::update-1-1-1 vertex_to_translation vertex translate_rules))))) 
   POLYMAP::emptyMap 
   dg))

(defun SPECCALC::optSpecUnion (specs) 
  (SPECCALC::monadSeq 
   #'SPECWARE::restoreSavedSpecwareState-1 
   (SPECCALC::monadBind 
    (SPECUNION::specUnion specs) 
    #'(lambda (spc) 
       (SPECCALC::|!return| 
        (cons 
         :|Some| 
         (vector (svref spc 0) (svref spc 1) (svref spc 2) (svref spc 3))))))))

(defun STANDARDSPEC::findAllOps (pV3 pV4) 
  (block 
   nil 
   (if (eq (car pV4) :|Qualified|) 
       (let ((pV5 (cdr pV4))) 
         (let ((pV7 (cdr pV5))
               (pV6 (car pV5))) 
           (return 
            (if (string=  pV6 METASLANG::UnQualified) 
                (STANDARDSPEC::wildFindUnQualified (svref pV3 1) pV7) 
                (let ((pV1 (findAQualifierMap (svref pV3 1) pV6 pV7))) 
                  (block 
                   nil 
                   (if (eq (car pV1) :|Some|) 
                       (return (cons (cdr pV1) nil)) 
                       (if (eq (car pV1) :|None|) (return nil))) 
                   (error "Nonexhaustive match failure in findAllOps")))))))) 
   (error "Nonexhaustive match failure in findAllOps")))

(defun SPECCALC::makeTranslationMaps-1 (dom_spec) 
  #'(lambda (x) 
     (let ((translation_rules (car x))) 
       (labels 
         ((insert (translation_op_map translation_sort_map) 
           #'(lambda (x1) 
              (let ((rule_pos (cdr x1))
                    (translation_rule (car x1))) 
                (block 
                 nil 
                 (if (eq (car translation_rule) :|Sort|) 
                     (let ((pV92 (cdr translation_rule))) 
                       (let ((pV115 (svref pV92 0))) 
                         (if (eq (car pV115) :|Qualified|) 
                             (let ((pV118 (cdr pV115))) 
                               (let ((pV120 (cdr pV118))
                                     (pV119 (car pV118))) 
                                 (return 
                                  (let ((pV8 
                                         (STANDARDSPEC::findAllSorts 
                                          dom_spec 
                                          pV115))) 
                                    (block 
                                     nil 
                                     (if (consp pV8) 
                                         (let ((pV12 (svref (car pV8) 0))) 
                                           (if (consp pV12) 
                                               (let ((pV16 (car pV12))) 
                                                 (if (eq (car pV16) :|Qualified|) 
                                                     (return 
                                                      (if (cl:or 
                                                           (slang-built-in::slang-term-equals 
                                                            (cdr pV8) 
                                                            nil) 
                                                           (string=  
                                                            (car (cdr pV16)) 
                                                            METASLANG::UnQualified)) 
                                                          (let ((pV6 
                                                                 (findAQualifierMap 
                                                                  translation_sort_map 
                                                                  pV119 
                                                                  pV120))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV6) 
                                                                  :|None|) 
                                                                 (return 
                                                                  (SPECCALC::|!return| 
                                                                   (cons 
                                                                    translation_op_map 
                                                                    (insertAQualifierMap 
                                                                     translation_sort_map 
                                                                     pV119 
                                                                     pV120 
                                                                     (cons 
                                                                      (svref 
                                                                       pV92 
                                                                       1) 
                                                                      (svref 
                                                                       pV92 
                                                                       2))))))) 
                                                             (return 
                                                              (SPECCALC::raise 
                                                               (cons 
                                                                :|SpecError| 
                                                                (cons 
                                                                 rule_pos 
                                                                 (STRING-SPEC::^ 
                                                                  "translate: Duplicate rules for source sort " 
                                                                  (METASLANG::printQualifiedId 
                                                                   pV115)))))))) 
                                                          (SPECCALC::raise 
                                                           (cons 
                                                            :|SpecError| 
                                                            (cons 
                                                             rule_pos 
                                                             (STRING-SPEC::^ 
                                                              "translate: Ambiguous source sort " 
                                                              (METASLANG::printQualifiedId 
                                                               pV115)))))))))))) 
                                     (return 
                                      (SPECCALC::raise 
                                       (cons 
                                        :|SpecError| 
                                        (cons 
                                         rule_pos 
                                         (STRING-SPEC::^ 
                                          "translate: Unrecognized source sort " 
                                          (METASLANG::printQualifiedId pV115)))))))))))))) 
                     (if (eq (car translation_rule) :|Op|) 
                         (let ((pV91 (cdr translation_rule))) 
                           (let ((pV108 (car (svref pV91 0)))) 
                             (if (eq (car pV108) :|Qualified|) 
                                 (let ((pV110 (cdr pV108))) 
                                   (let ((pV112 (cdr pV110))
                                         (pV111 (car pV110))) 
                                     (return 
                                      (let ((pV29 
                                             (STANDARDSPEC::findAllOps 
                                              dom_spec 
                                              pV108))) 
                                        (block 
                                         nil 
                                         (if (consp pV29) 
                                             (let ((pV33 (svref (car pV29) 0))) 
                                               (if (consp pV33) 
                                                   (let ((pV38 (car pV33))) 
                                                     (if (eq 
                                                          (car pV38) 
                                                          :|Qualified|) 
                                                         (return 
                                                          (if (cl:or 
                                                               (slang-built-in::slang-term-equals 
                                                                (cdr pV29) 
                                                                nil) 
                                                               (string=  
                                                                (car (cdr pV38)) 
                                                                METASLANG::UnQualified)) 
                                                              (let ((pV27 
                                                                     (findAQualifierMap 
                                                                      translation_op_map 
                                                                      pV111 
                                                                      pV112))) 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car pV27) 
                                                                      :|None|) 
                                                                     (return 
                                                                      (SPECCALC::|!return| 
                                                                       (cons 
                                                                        (insertAQualifierMap 
                                                                         translation_op_map 
                                                                         pV111 
                                                                         pV112 
                                                                         (cons 
                                                                          (car 
                                                                           (svref 
                                                                            pV91 
                                                                            1)) 
                                                                          (svref 
                                                                           pV91 
                                                                           2))) 
                                                                        translation_sort_map)))) 
                                                                 (return 
                                                                  (SPECCALC::raise 
                                                                   (cons 
                                                                    :|SpecError| 
                                                                    (cons 
                                                                     rule_pos 
                                                                     (STRING-SPEC::^ 
                                                                      "translate: Duplicate rules for source op " 
                                                                      (METASLANG::printQualifiedId 
                                                                       pV108)))))))) 
                                                              (SPECCALC::raise 
                                                               (cons 
                                                                :|SpecError| 
                                                                (cons 
                                                                 rule_pos 
                                                                 (STRING-SPEC::^ 
                                                                  "translate: Ambiguous source op " 
                                                                  (METASLANG::printQualifiedId 
                                                                   pV108)))))))))))) 
                                         (return 
                                          (SPECCALC::raise 
                                           (cons 
                                            :|SpecError| 
                                            (cons 
                                             rule_pos 
                                             (STRING-SPEC::^ 
                                              "translate: Unrecognized source op " 
                                              (METASLANG::printQualifiedId pV108)))))))))))))) 
                         (if (eq (car translation_rule) :|Ambiguous|) 
                             (let ((pV90 (cdr translation_rule))) 
                               (let ((pV95 (svref pV90 2))
                                     (pV94 (svref pV90 1))
                                     (pV93 (svref pV90 0))) 
                                 (progn (if (eq (car pV93) :|Qualified|) 
                                            (let ((pV99 (cdr pV93))) 
                                              (let ((pV100 (car pV99))) 
                                                (if (string=  "_" (cdr pV99)) 
                                                    (if (eq 
                                                         (car pV94) 
                                                         :|Qualified|) 
                                                        (let ((pV102 (cdr pV94))) 
                                                          (let ((pV103 
                                                                 (car pV102))) 
                                                            (if (string=  
                                                                 "_" 
                                                                 (cdr pV102)) 
                                                                (return 
                                                                 (labels 
                                                                   ((extend_sort_map 
                                                                     (sort_qualifier 
                                                                      sort_id 
                                                                      sort_info 
                                                                      translation_sort_map) 
                                                                     (if (string=  
                                                                          sort_qualifier 
                                                                          pV100) 
                                                                         (let ((pV46 
                                                                                (findAQualifierMap 
                                                                                 translation_sort_map 
                                                                                 sort_qualifier 
                                                                                 sort_id))) 
                                                                           (block 
                                                                            nil 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV46) 
                                                                                 :|None|) 
                                                                                (return 
                                                                                 (let ((new_cod_qid 
                                                                                        (METASLANG::mkQualifiedId 
                                                                                         pV103 
                                                                                         sort_id))) 
                                                                                   (SPECCALC::|!return| 
                                                                                    (insertAQualifierMap 
                                                                                     translation_sort_map 
                                                                                     sort_qualifier 
                                                                                     sort_id 
                                                                                     (cons 
                                                                                      new_cod_qid 
                                                                                      (cons 
                                                                                       new_cod_qid 
                                                                                       nil))))))) 
                                                                            (return 
                                                                             (SPECCALC::raise 
                                                                              (cons 
                                                                               :|SpecError| 
                                                                               (cons 
                                                                                rule_pos 
                                                                                (STRING-SPEC::^ 
                                                                                 "translate: Duplicate rules for source sort " 
                                                                                 (METASLANG::printQualifiedId 
                                                                                  (METASLANG::mkQualifiedId 
                                                                                   sort_qualifier 
                                                                                   sort_id))))))))) 
                                                                         (SPECCALC::|!return| 
                                                                          translation_sort_map)))
                                                                    (extend_op_map 
                                                                     (op_qualifier 
                                                                      op_id 
                                                                      op_info 
                                                                      translation_op_map) 
                                                                     (if (string=  
                                                                          op_qualifier 
                                                                          pV100) 
                                                                         (let ((pV44 
                                                                                (findAQualifierMap 
                                                                                 translation_op_map 
                                                                                 op_qualifier 
                                                                                 op_id))) 
                                                                           (block 
                                                                            nil 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV44) 
                                                                                 :|None|) 
                                                                                (return 
                                                                                 (let ((new_cod_qid 
                                                                                        (METASLANG::mkQualifiedId 
                                                                                         pV103 
                                                                                         op_id))) 
                                                                                   (SPECCALC::|!return| 
                                                                                    (insertAQualifierMap 
                                                                                     translation_op_map 
                                                                                     op_qualifier 
                                                                                     op_id 
                                                                                     (cons 
                                                                                      new_cod_qid 
                                                                                      (cons 
                                                                                       new_cod_qid 
                                                                                       nil))))))) 
                                                                            (return 
                                                                             (SPECCALC::raise 
                                                                              (cons 
                                                                               :|SpecError| 
                                                                               (cons 
                                                                                rule_pos 
                                                                                (STRING-SPEC::^ 
                                                                                 "translate: Duplicate rules for source op " 
                                                                                 (METASLANG::printQualifiedId 
                                                                                  (METASLANG::mkQualifiedId 
                                                                                   op_qualifier 
                                                                                   op_id))))))))) 
                                                                         (SPECCALC::|!return| 
                                                                          translation_op_map)))) 
                                                                   (SPECCALC::monadBind 
                                                                    (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                                                                       #'(lambda (x11) 
                                                                                          (extend_op_map 
                                                                                           (svref 
                                                                                            x11 
                                                                                            0) 
                                                                                           (svref 
                                                                                            x11 
                                                                                            1) 
                                                                                           (svref 
                                                                                            x11 
                                                                                            2) 
                                                                                           (svref 
                                                                                            x11 
                                                                                            3)))) 
                                                                                      translation_op_map) 
                                                                             (svref 
                                                                              dom_spec 
                                                                              1)) 
                                                                    #'(lambda (translation_op_map) 
                                                                       (SPECCALC::monadBind 
                                                                        (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                                                                           #'(lambda (x11) 
                                                                                              (extend_sort_map 
                                                                                               (svref 
                                                                                                x11 
                                                                                                0) 
                                                                                               (svref 
                                                                                                x11 
                                                                                                1) 
                                                                                               (svref 
                                                                                                x11 
                                                                                                2) 
                                                                                               (svref 
                                                                                                x11 
                                                                                                3)))) 
                                                                                          translation_sort_map) 
                                                                                 (svref 
                                                                                  dom_spec 
                                                                                  3)) 
                                                                        #'(lambda (translation_sort_map) 
                                                                           (SPECCALC::|!return| 
                                                                            (cons 
                                                                             translation_op_map 
                                                                             translation_sort_map)))))))))))))))) 
                                        (if (eq (car pV93) :|Qualified|) 
                                            (let ((pV96 (cdr pV93))) 
                                              (let ((pV98 (cdr pV96))
                                                    (pV97 (car pV96))) 
                                                (return 
                                                 (let ((dom_sorts 
                                                        (STANDARDSPEC::findAllSorts 
                                                         dom_spec 
                                                         pV93))) 
                                                   (let ((dom_ops 
                                                          (STANDARDSPEC::findAllOps 
                                                           dom_spec 
                                                           pV93))) 
                                                     (block 
                                                      nil 
                                                      (if (consp dom_sorts) 
                                                          (let ((pV80 
                                                                 (svref 
                                                                  (car dom_sorts) 
                                                                  0))) 
                                                            (if (consp pV80) 
                                                                (let ((pV84 
                                                                       (car pV80))) 
                                                                  (if (eq 
                                                                       (car pV84) 
                                                                       :|Qualified|) 
                                                                      (if (null 
                                                                           dom_ops) 
                                                                          (return 
                                                                           (if (cl:or 
                                                                                (slang-built-in::slang-term-equals 
                                                                                 (cdr 
                                                                                  dom_sorts) 
                                                                                 nil) 
                                                                                (string=  
                                                                                 (car 
                                                                                  (cdr 
                                                                                   pV84)) 
                                                                                 METASLANG::UnQualified)) 
                                                                               (let ((pV52 
                                                                                      (findAQualifierMap 
                                                                                       translation_sort_map 
                                                                                       pV97 
                                                                                       pV98))) 
                                                                                 (block 
                                                                                  nil 
                                                                                  (if (eq 
                                                                                       (car 
                                                                                        pV52) 
                                                                                       :|None|) 
                                                                                      (return 
                                                                                       (SPECCALC::|!return| 
                                                                                        (cons 
                                                                                         translation_op_map 
                                                                                         (insertAQualifierMap 
                                                                                          translation_sort_map 
                                                                                          pV97 
                                                                                          pV98 
                                                                                          (cons 
                                                                                           pV94 
                                                                                           pV95)))))) 
                                                                                  (return 
                                                                                   (SPECCALC::raise 
                                                                                    (cons 
                                                                                     :|SpecError| 
                                                                                     (cons 
                                                                                      rule_pos 
                                                                                      (STRING-SPEC::^ 
                                                                                       "translate: Duplicate rules for source sort " 
                                                                                       (METASLANG::printQualifiedId 
                                                                                        pV93)))))))) 
                                                                               (SPECCALC::raise 
                                                                                (cons 
                                                                                 :|SpecError| 
                                                                                 (cons 
                                                                                  rule_pos 
                                                                                  (STRING-SPEC::^ 
                                                                                   "translate: Ambiguous source sort " 
                                                                                   (METASLANG::printQualifiedId 
                                                                                    pV93)))))))))))) 
                                                          (if (null dom_sorts) 
                                                              (if (null dom_ops) 
                                                                  (return 
                                                                   (SPECCALC::raise 
                                                                    (cons 
                                                                     :|SpecError| 
                                                                     (cons 
                                                                      rule_pos 
                                                                      (STRING-SPEC::^ 
                                                                       "translate: Unrecognized source sort/op " 
                                                                       (METASLANG::printQualifiedId 
                                                                        pV93)))))) 
                                                                  (if (consp 
                                                                       dom_ops) 
                                                                      (let ((pV68 
                                                                             (svref 
                                                                              (car 
                                                                               dom_ops) 
                                                                              0))) 
                                                                        (if (consp 
                                                                             pV68) 
                                                                            (let ((pV73 
                                                                                   (car 
                                                                                    pV68))) 
                                                                              (if (eq 
                                                                                   (car 
                                                                                    pV73) 
                                                                                   :|Qualified|) 
                                                                                  (return 
                                                                                   (if (cl:or 
                                                                                        (slang-built-in::slang-term-equals 
                                                                                         (cdr 
                                                                                          dom_ops) 
                                                                                         nil) 
                                                                                        (string=  
                                                                                         (car 
                                                                                          (cdr 
                                                                                           pV73)) 
                                                                                         METASLANG::UnQualified)) 
                                                                                       (let ((pV59 
                                                                                              (findAQualifierMap 
                                                                                               translation_op_map 
                                                                                               pV97 
                                                                                               pV98))) 
                                                                                         (block 
                                                                                          nil 
                                                                                          (if (eq 
                                                                                               (car 
                                                                                                pV59) 
                                                                                               :|None|) 
                                                                                              (return 
                                                                                               (SPECCALC::|!return| 
                                                                                                (cons 
                                                                                                 (insertAQualifierMap 
                                                                                                  translation_op_map 
                                                                                                  pV97 
                                                                                                  pV98 
                                                                                                  (cons 
                                                                                                   pV94 
                                                                                                   pV95)) 
                                                                                                 translation_sort_map)))) 
                                                                                          (return 
                                                                                           (SPECCALC::raise 
                                                                                            (cons 
                                                                                             :|SpecError| 
                                                                                             (cons 
                                                                                              rule_pos 
                                                                                              (STRING-SPEC::^ 
                                                                                               "translate: Duplicate rules for source op " 
                                                                                               (METASLANG::printQualifiedId 
                                                                                                pV93)))))))) 
                                                                                       (SPECCALC::raise 
                                                                                        (cons 
                                                                                         :|SpecError| 
                                                                                         (cons 
                                                                                          rule_pos 
                                                                                          (STRING-SPEC::^ 
                                                                                           "translate: Ambiguous source op " 
                                                                                           (METASLANG::printQualifiedId 
                                                                                            pV93))))))))))))))) 
                                                      (return 
                                                       (SPECCALC::raise 
                                                        (cons 
                                                         :|SpecError| 
                                                         (cons 
                                                          rule_pos 
                                                          (STRING-SPEC::^ 
                                                           "translate: Ambiguous source sort/op " 
                                                           (METASLANG::printQualifiedId 
                                                            pV93)))))) 
                                                      (error 
                                                       "Nonexhaustive match failure in makeTranslationMaps")))))))))))))) 
                 (error "Nonexhaustive match failure in makeTranslationMaps")))))) 
         (funcall (funcall (SPECCALC::foldM 
                            #'(lambda (x1) (insert (car x1) (cdr x1)))) 
                           (cons emptyAQualifierMap emptyAQualifierMap)) 
                  translation_rules)))))

(defun SPECCALC::translateSpec-1 (spc) 
  #'(lambda (expr) 
     (SPECCALC::monadBind 
      (funcall (SPECCALC::makeTranslationMaps-1 spc) expr) 
      #'(lambda (translation_maps) 
         (SPECCALC::monadBind 
          (funcall (funcall (SPECCALC::auxTranslateSpec-1 spc) translation_maps) 
                   (SPECCALC::positionOf-1 expr)) 
          #'(lambda (new_spec) 
             (funcall (SPECCALC::complainIfAmbiguous-1 
                       (SPECCALC::compressDefs-1 new_spec)) 
                      (SPECCALC::positionOf-1 expr))))))))

(defun SPECCALC::optTranslateSpec-1 (vertex_spec) 
  #'(lambda (cocone_translation_expr) 
     (SPECCALC::monadSeq 
      #'SPECWARE::restoreSavedSpecwareState-1 
      (SPECCALC::monadBind 
       (funcall (SPECCALC::translateSpec-1 vertex_spec) cocone_translation_expr) 
       #'(lambda (spc) 
          (SPECCALC::|!return| 
           (cons 
            :|Some| 
            (vector (svref spc 0) (svref spc 1) (svref spc 2) (svref spc 3)))))))))


(defun SPECCALC::localHandler (except) 
  (SPECCALC::monadSeq 
   (SPECWARE::toplevelHandler except) 
   (SPECCALC::|!return| '(:|None|))))

(defun SPECCALC::run_monad (monad) 
  (let ((x 
         (SPECCALC::|!catch|-1-1-1 
          monad 
          #'SPECCALC::localHandler 
          SPECWARE::ignoredState))) 
    (let ((pV4 (car x))) 
      (block 
       nil 
       (if (eq (car pV4) :|Ok|) 
           (return (cdr pV4)) 
           (if (eq (car pV4) :|Exception|) 
               (return 
                (SYSTEM-SPEC::fail 
                 "Specware toplevel handler failed within colimit!")))) 
       (error "Nonexhaustive match failure in run_monad")))))

(defun SPECCALC::specColimit-1 (dg) 
  (let ((base_spec (SPECCALC::getBaseSpec))) 
    (labels 
      ((extract_non_base_ops (spc) 
        (let ((base_ops (svref base_spec 1))) 
          (foldriAQualifierMap-1-1-1 
           #'(lambda (x) 
              (let ((non_base_ops (svref x 3))
                    (id (svref x 1))
                    (qualifier (svref x 0))) 
                (let ((pV4 (findAQualifierMap base_ops qualifier id))) 
                  (block 
                   nil 
                   (if (eq (car pV4) :|None|) 
                       (return 
                        (LIST-SPEC::|!cons| 
                         (vector qualifier id (svref x 2)) 
                         non_base_ops))) 
                   (return non_base_ops))))) 
           nil 
           (svref spc 1))))
       (extract_non_base_sorts (spc) 
        (let ((base_sorts (svref base_spec 3))) 
          (foldriAQualifierMap-1-1-1 
           #'(lambda (x) 
              (let ((non_base_sorts (svref x 3))
                    (id (svref x 1))
                    (qualifier (svref x 0))) 
                (let ((pV2 (findAQualifierMap base_sorts qualifier id))) 
                  (block 
                   nil 
                   (if (eq (car pV2) :|None|) 
                       (return 
                        (LIST-SPEC::|!cons| 
                         (vector qualifier id (svref x 2)) 
                         non_base_sorts))) 
                   (return non_base_sorts))))) 
           nil 
           (svref spc 3))))) 
      (let ((sort_qset 
             (SPECCALC::computeQuotientSet-1-1-1 
              dg 
              #'extract_non_base_sorts 
              #'SPECCALC::sortMap-1))) 
        (let ((op_qset 
               (SPECCALC::computeQuotientSet-1-1-1 
                dg 
                #'extract_non_base_ops 
                #'SPECCALC::opMap-1))) 
          (let ((vqid_to_apex_qid_and_aliases_sort_map 
                 (SPECCALC::computeVQidToApexQidAndAliasesMap sort_qset))) 
            (let ((vqid_to_apex_qid_and_aliases_op_map 
                   (SPECCALC::computeVQidToApexQidAndAliasesMap op_qset))) 
              (let ((vertex_to_sm_sort_rules 
                     (SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1 
                      dg 
                      vqid_to_apex_qid_and_aliases_sort_map 
                      #'extract_non_base_sorts 
                      #'SPECCALC::makeTranslateSortRule-1))) 
                (let ((vertex_to_sm_op_rules 
                       (SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1 
                        dg 
                        vqid_to_apex_qid_and_aliases_op_map 
                        #'extract_non_base_ops 
                        #'SPECCALC::makeTranslateOpRule-1))) 
                  (let ((vertex_to_sm_rules 
                         (CAT::foldOverVertices-1-1-1 
                          #'(lambda (cocone_translations) 
                             #'(lambda (vertex) 
                                (let ((cocone_sm_rules 
                                       (LIST-SPEC::|!++| 
                                        (let ((pV6 
                                               (POLYMAP::evalPartial-1-1 
                                                vertex_to_sm_sort_rules 
                                                vertex))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV6) :|Some|) 
                                               (return (cdr pV6))) 
                                           (return nil))) 
                                        (let ((pV9 
                                               (POLYMAP::evalPartial-1-1 
                                                vertex_to_sm_op_rules 
                                                vertex))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV9) :|Some|) 
                                               (return (cdr pV9))) 
                                           (return nil)))))) 
                                  (POLYMAP::update-1-1-1 
                                   cocone_translations 
                                   vertex 
                                   (cons 
                                    cocone_sm_rules 
                                    (cons :|Internal| "Colimit")))))) 
                          POLYMAP::emptyMap 
                          dg))) 
                    (let ((apex_spec 
                           (CAT::foldOverVertices-1-1-1 
                            #'(lambda (apex_spec) 
                               #'(lambda (vertex) 
                                  (let ((vertex_spec 
                                         (CAT::vertexLabel-1-1 dg vertex))) 
                                    (let ((cocone_translation_expr 
                                           (POLYMAP::|!eval|-1-1 
                                            vertex_to_sm_rules 
                                            vertex))) 
                                      (let ((pV15 
                                             (SPECCALC::run_monad 
                                              (funcall (SPECCALC::optTranslateSpec-1 
                                                        (subtractSpec-1-1 
                                                         vertex_spec 
                                                         base_spec)) 
                                                       cocone_translation_expr)))) 
                                        (block 
                                         nil 
                                         (if (eq (car pV15) :|Some|) 
                                             (return 
                                              (let ((pV12 
                                                     (SPECCALC::run_monad 
                                                      (SPECCALC::optSpecUnion 
                                                       (cons 
                                                        apex_spec 
                                                        (cons (cdr pV15) nil)))))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV12) :|Some|) 
                                                     (return (cdr pV12))) 
                                                 (return 
                                                  (SYSTEM-SPEC::fail 
                                                   "Internal error: spec union inside colimit failed.")))))) 
                                         (return 
                                          (SYSTEM-SPEC::fail 
                                           "Internal error: translation inside colimit failed.")))))))) 
                            base_spec 
                            dg))) 
                      (let ((vertex_to_sm_map 
                             (CAT::foldOverVertices-1-1-1 
                              #'(lambda (cc_map) 
                                 #'(lambda (vertex) 
                                    (let ((sm 
                                           (let ((dom_spec 
                                                  (CAT::vertexLabel-1-1 
                                                   dg 
                                                   vertex))) 
                                             (SPECCALC::makeMorphism 
                                              dom_spec 
                                              apex_spec 
                                              (let ((pV18 
                                                     (POLYMAP::evalPartial-1-1 
                                                      vertex_to_sm_sort_rules 
                                                      vertex))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV18) :|Some|) 
                                                     (return 
                                                      (SPECCALC::convertSortRules 
                                                       (cdr pV18)))) 
                                                 (return nil))) 
                                              (let ((pV21 
                                                     (POLYMAP::evalPartial-1-1 
                                                      vertex_to_sm_op_rules 
                                                      vertex))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV21) :|Some|) 
                                                     (return 
                                                      (SPECCALC::convertOpRules 
                                                       (cdr pV21)))) 
                                                 (return nil))))))) 
                                      (POLYMAP::update-1-1-1 cc_map vertex sm)))) 
                              POLYMAP::emptyMap 
                              dg))) 
                        (SPECCALC::makeSpecInitialCocone-1-1-1 
                         dg 
                         apex_spec 
                         vertex_to_sm_map)))))))))))))

(defun SPECCALC::specCat () 
  (vector 
   #'(lambda (x) (svref x 0)) 
   #'SPECCALC::specColimit-1 
   #'SPECCALC::compose-1 
   #'(lambda (x) (svref x 1)) 
   #'(lambda (spc) (vector spc spc POLYMAP::emptyMap POLYMAP::emptyMap)) 
   emptySpec 
   #'SPECCALC::ppMorphism-1 
   #'SPECCALC::ppASpec-1))

(defun SPECCALC::uriToString (hashSuffix path) 
  (let ((path (SPECCALC::abbreviatedPath path))) 
    (let ((device? (SPECCALC::deviceString? (LIST-SPEC::hd path)))) 
      (let ((tildaPath? (string=  (LIST-SPEC::hd path) "~"))) 
        (let ((mainPath 
               (STRING-SPEC::concatList 
                (LIST-SPEC::foldr-1-1-1 
                 #'(lambda (x) 
                    (LIST-SPEC::|!cons| "/" (LIST-SPEC::|!cons| (car x) (cdr x)))) 
                 nil 
                 (if (cl:or tildaPath? device?) (LIST-SPEC::tl path) path))))) 
          (let ((|!fileName| 
                 (if tildaPath? 
                     (STRING-SPEC::^ "~" mainPath) 
                     (if device? 
                         (STRING-SPEC::^ (LIST-SPEC::hd path) mainPath) 
                         mainPath)))) 
            (block 
             nil 
             (if (eq (car hashSuffix) :|None|) 
                 (return |!fileName|) 
                 (if (eq (car hashSuffix) :|Some|) 
                     (let ((pV2 (cdr hashSuffix))) 
                       (return 
                        (if (string=  |!fileName| "") 
                            pV2 
                            (STRING-SPEC::^ (STRING-SPEC::^ |!fileName| "#") pV2)))))) 
             (error "Nonexhaustive match failure in uriToString"))))))))

(defun SPECCALC::uriToString-1 (x) (SPECCALC::uriToString (car x) (cdr x)))

(defun SPECCALC::evaluateDiag (elems) 
  (SPECCALC::monadBind 
   #'SPECCALC::getCurrentURI-1 
   #'(lambda (uri) 
      (SPECCALC::monadSeq 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          ";;; Processing spec diagram at " 
          (SPECCALC::uriToString-1 uri)) 
         "
")) 
       (SPECCALC::monadBind 
        (funcall (funcall (SPECCALC::foldM #'SPECCALC::evaluateDiagElem-1) 
                          (vector 
                           (CAT::emptyDiagram-1 (SPECCALC::specCat)) 
                           0 
                           nil)) 
                 elems) 
        #'(lambda (x) 
           (let ((dgm (svref x 0))) 
             (SPECCALC::|!return| 
              (vector 
               (cons :|Diag| (cons (car dgm) (cdr dgm))) 
               (svref x 1) 
               (svref x 2))))))))))

(defun SPECCALC::ppColimit (cocone pV1) 
  (declare (ignore pV1)) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "colimit ") 
    (cons 
     WADLERLINDIG::ppNewline 
     (cons (CAT::ppDiagram-1 (CAT::diagram-1 cocone)) nil)))))

(defun SPECCALC::ppColimit-1 (x) (SPECCALC::ppColimit (car x) (cdr x)))

(defun SPECCALC::ppOtherValue (value) 
  (WADLERLINDIG::ppString "<some OtherValue>"))

(defun SPECCALC::ppValue (value) 
  (block 
   nil 
   (if (eq (car value) :|Spec|) 
       (return 
        (WADLERLINDIG::ppString (ANNSPECPRINTER::printSpec-1 (cdr value)))) 
       (if (eq (car value) :|Morph|) 
           (return (SPECCALC::ppMorphism-1 (cdr value))) 
           (if (eq (car value) :|Diag|) 
               (return (CAT::ppDiagram-1 (cdr value))) 
               (if (eq (car value) :|Colimit|) 
                   (return (SPECCALC::ppColimit-1 (cdr value))) 
                   (if (eq (car value) :|InProcess|) 
                       (return (WADLERLINDIG::ppString "InProcess")) 
                       (if (eq (car value) :|Other|) 
                           (return (SPECCALC::ppOtherValue (cdr value))))))))) 
   (error "Nonexhaustive match failure in ppValue")))

(defun SPECCALC::showValue (value) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppValue value)))

(defun SPECCALC::evaluateDiagMorph (domTerm codTerm morphRules) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 domTerm) 
   #'(lambda (domValueInfo) 
      (SPECCALC::monadBind 
       (SPECCALC::evaluateTermInfo-1 codTerm) 
       #'(lambda (codValueInfo) 
          (block 
           nil 
           (return 
            (block 
             nil 
             (return 
              (SPECCALC::raise 
               (cons 
                :|Unsupported| 
                (cons 
                 (SPECCALC::positionOf-1 domTerm) 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         "diagram morphisms not available yet
" 
                         "Dom diagram  = 
") 
                        (SPECCALC::showValue (svref domValueInfo 0))) 
                       "
") 
                      "Cod diagram  = 
") 
                     (SPECCALC::showValue (svref codValueInfo 0))) 
                    "
") 
                   (NAT-SPEC::toString (LIST-SPEC::|!length| morphRules))) 
                  " diagram-morphism rules 
"))))) 
             (error "Nonexhaustive match failure in evaluateDiagMorph"))) 
           (error "Nonexhaustive match failure in evaluateDiagMorph")))))))

(defun SPECCALC::evaluateDiagMorph-1 (x) 
  (SPECCALC::evaluateDiagMorph (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::extendMorphismWithAnswer (morph domVars) 
  (let ((codIds (SPECCALC::answerVarsFromSnark))) 
    (let ((domIds (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) domVars))) 
      (let ((newOpMap 
             (LISTPAIR::foldl-1-1-1 
              #'(lambda (x) 
                 (POLYMAP::update-1-1-1 
                  (svref x 2) 
                  (METASLANG::mkUnQualifiedId (svref x 0)) 
                  (METASLANG::mkUnQualifiedId (svref x 1)))) 
              (svref morph 2) 
              (cons domIds codIds)))) 
        (progn (if SYSTEM-SPEC::specwareDebug? 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (id) 
                       (SYSTEM-SPEC::|!print| 
                        (STRING-SPEC::^ (STRING-SPEC::^ "domOp: " id) "
"))) 
                    domIds) 
                   (cons "" nil)) 
               (progn (if SYSTEM-SPEC::specwareDebug? 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (id) 
                              (SYSTEM-SPEC::|!print| 
                               (STRING-SPEC::^ (STRING-SPEC::^ "codOp: " id) "
"))) 
                           codIds) 
                          (cons "" nil)) 
                      (SPECCALC::makeMorphism 
                       (svref morph 1) 
                       (svref morph 0) 
                       (svref morph 3) 
                       newOpMap)))))))

(defun SPECCALC::termOpsInSpec (term spc) 
  (labels 
    ((mapRec (term) (mapT spc term))
     (mapT (spc term) 
      (block 
       nil 
       (if (eq (car term) :|Fun|) 
           (let ((pV60 (svref (cdr term) 0))) 
             (progn (if (eq (car pV60) :|Op|) 
                        (return 
                         (let ((pV3 
                                (STANDARDSPEC::findTheOp spc (car (cdr pV60))))) 
                           (block 
                            nil 
                            (if (eq (car pV3) :|Some|) (return (cons term nil))) 
                            (return nil))))) 
                    (return nil))) 
           (if (eq (car term) :|Var|) 
               (return nil) 
               (if (eq (car term) :|Let|) 
                   (return (let ((res (mapRec (svref (cdr term) 1)))) res)) 
                   (if (eq (car term) :|LetRec|) 
                       (return (let ((res (mapRec (svref (cdr term) 1)))) res)) 
                       (if (eq (car term) :|Record|) 
                           (return 
                            (let ((res 
                                   (LIST-SPEC::foldl-1-1-1 
                                    #'(lambda (x) 
                                       (block 
                                        nil 
                                        (return 
                                         (LIST-SPEC::|!++| 
                                          (cdr x) 
                                          (mapRec (cdr (car x))))) 
                                        (error 
                                         "Nonexhaustive match failure in termOpsInSpec"))) 
                                    nil 
                                    (car (cdr term))))) res)) 
                           (if (eq (car term) :|IfThenElse|) 
                               (let ((pV22 (cdr term))) 
                                 (return 
                                  (let ((resT1 (mapRec (svref pV22 0)))) 
                                    (let ((resT2 (mapRec (svref pV22 1)))) 
                                      (let ((resT3 (mapRec (svref pV22 2)))) 
                                        (LIST-SPEC::|!++| 
                                         (LIST-SPEC::|!++| resT1 resT2) 
                                         resT3)))))) 
                               (if (eq (car term) :|Lambda|) 
                                   (return 
                                    (let ((resMatch 
                                           (LIST-SPEC::foldl-1-1-1 
                                            #'(lambda (x) 
                                               (block 
                                                nil 
                                                (return 
                                                 (LIST-SPEC::|!++| 
                                                  (cdr x) 
                                                  (mapRec (svref (car x) 2)))) 
                                                (error 
                                                 "Nonexhaustive match failure in termOpsInSpec"))) 
                                            nil 
                                            (car (cdr term))))) resMatch)) 
                                   (if (eq (car term) :|Bind|) 
                                       (return 
                                        (let ((resTrm 
                                               (mapRec (svref (cdr term) 2)))) 
                                          resTrm)) 
                                       (if (eq (car term) :|Apply|) 
                                           (let ((pV19 (cdr term))) 
                                             (return 
                                              (let ((resT1 
                                                     (mapRec (svref pV19 0)))) 
                                                (let ((resT2 
                                                       (mapRec (svref pV19 1)))) 
                                                  (LIST-SPEC::|!++| resT1 resT2))))) 
                                           (if (eq (car term) :|Seq|) 
                                               (return 
                                                (let ((resTerms 
                                                       (LIST-SPEC::foldl-1-1-1 
                                                        #'(lambda (x) 
                                                           (LIST-SPEC::|!++| 
                                                            (cdr x) 
                                                            (mapRec (car x)))) 
                                                        nil 
                                                        (car (cdr term))))) 
                                                  resTerms)) 
                                               (if (eq (car term) :|ApplyN|) 
                                                   (return 
                                                    (let ((resTerms 
                                                           (LIST-SPEC::foldl-1-1-1 
                                                            #'(lambda (x) 
                                                               (LIST-SPEC::|!++| 
                                                                (cdr x) 
                                                                (mapRec (car x)))) 
                                                            nil 
                                                            (car (cdr term))))) 
                                                      resTerms)) 
                                                   (if (eq 
                                                        (car term) 
                                                        :|SortedTerm|) 
                                                       (return 
                                                        (let ((resTrm 
                                                               (mapRec 
                                                                (svref 
                                                                 (cdr term) 
                                                                 0)))) resTrm)))))))))))))) 
       (error "Nonexhaustive match failure in termOpsInSpec")))) (mapRec term)))

(defun SPECCALC::mkExistential (spc term) 
  (let ((opsToQuantify (SPECCALC::termOpsInSpec term spc))) 
    (let ((newVars 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (pV2) 
               (block 
                nil 
                (if (eq (car pV2) :|Fun|) 
                    (let ((pV3 (cdr pV2))) 
                      (let ((pV4 (svref pV3 0))) 
                        (if (eq (car pV4) :|Op|) 
                            (let ((pV8 (car (cdr pV4)))) 
                              (if (eq (car pV8) :|Qualified|) 
                                  (return (cons (cdr (cdr pV8)) (svref pV3 1))))))))) 
                (error "Nonexhaustive match failure in mkExistential"))) 
            opsToQuantify))) 
      (let ((opToVarMap 
             (LISTPAIR::foldl-1-1-1 
              #'(lambda (x) 
                 (let ((pV16 (svref x 0))) 
                   (block 
                    nil 
                    (if (eq (car pV16) :|Fun|) 
                        (let ((pV20 (svref (cdr pV16) 0))) 
                          (if (eq (car pV20) :|Op|) 
                              (return 
                               (POLYMAP::update-1-1-1 
                                (svref x 2) 
                                (car (cdr pV20)) 
                                (svref x 1)))))) 
                    (error "Nonexhaustive match failure in mkExistential")))) 
              POLYMAP::emptyMap 
              (cons opsToQuantify newVars)))) 
        (labels 
          ((substVarForOp (term) 
            (block 
             nil 
             (if (eq (car term) :|Fun|) 
                 (let ((pV31 (svref (cdr term) 0))) 
                   (if (eq (car pV31) :|Op|) 
                       (return 
                        (let ((newVar 
                               (POLYMAP::evalPartial-1-1 
                                opToVarMap 
                                (car (cdr pV31))))) 
                          (block 
                           nil 
                           (if (eq (car newVar) :|Some|) 
                               (return (STANDARDSPEC::mkVar-1 (cdr newVar))) 
                               (if (eq (car newVar) :|None|) (return term))) 
                           (error "Nonexhaustive match failure in mkExistential"))))))) 
             (return term)))) 
          (let ((newTerm 
                 (METASLANG::mapTerm-1-1 
                  (vector 
                   #'(lambda (trm) (substVarForOp trm)) 
                   #'(lambda (s) s) 
                   #'(lambda (p) p)) 
                  term))) 
            (let ((existTerm 
                   (cons 
                    :|Bind| 
                    (vector '(:|Exists|) newVars newTerm POSITION-SPEC::noPos)))) 
              (progn (if SYSTEM-SPEC::specwareDebug? 
                         (ANNSPECPRINTER::printTermToTerminal existTerm) 
                         nil) 
                     (cons 
                      (vector 
                       '(:|Conjecture|) 
                       "morphismExistential" 
                       nil 
                       existTerm) 
                      newVars)))))))))

(defun SPECCALC::makeSnarkAnsEvalForm
 (prover_options 
  snarkSortDecl 
  snarkOpDecls 
  snarkBaseHypothesis 
  snarkHypothesis 
  snarkConjecture 
  snarkLogFileName) 
  (LISP-SPEC::|!list| 
   (cons 
    (LISP-SPEC::|!symbol| "CL-USER" "WITH-OPEN-FILE") 
    (cons 
     (LISP-SPEC::|!list| 
      (cons 
       (LISP-SPEC::|!symbol| "CL-USER" "LOGFILE") 
       (cons 
        (LISP-SPEC::|!string| snarkLogFileName) 
        (cons 
         (LISP-SPEC::|!symbol| "KEYWORD" "DIRECTION") 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "OUTPUT") 
          (cons 
           (LISP-SPEC::|!symbol| "KEYWORD" "IF-EXISTS") 
           (cons (LISP-SPEC::|!symbol| "KEYWORD" "SUPERSEDE") nil))))))) 
     (cons 
      (LISP-SPEC::|!++| 
       (LISP-SPEC::|!++| 
        (LISP-SPEC::|!++| 
         (LISP-SPEC::|!++| 
          (LISP-SPEC::|!++| 
           (LISP-SPEC::|!++| 
            (LISP-SPEC::|!++| 
             (LISP-SPEC::|!list| 
              (cons 
               (LISP-SPEC::|!symbol| "CL" "LET") 
               (cons 
                (LISP-SPEC::|!list| nil) 
                (cons 
                 (LISP-SPEC::|!list| 
                  (cons (LISP-SPEC::|!symbol| "SNARK" "INITIALIZE") nil)) 
                 (cons 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| "SNARK" "RUN-TIME-LIMIT") 
                    (cons (LISP-SPEC::|!nat| 60) nil))) 
                  (cons 
                   (LISP-SPEC::|!list| 
                    (cons 
                     (LISP-SPEC::|!symbol| "SNARK" "USE-LISP-TYPES-AS-SORTS") 
                     (cons (LISP-SPEC::bool t) nil))) 
                   (cons 
                    (LISP-SPEC::|!list| 
                     (cons 
                      (LISP-SPEC::|!symbol| "SNARK" "USE-CODE-FOR-NUMBERS") 
                      (cons (LISP-SPEC::bool t) nil))) 
                    (cons 
                     (LISP-SPEC::|!list| 
                      (cons 
                       (LISP-SPEC::|!symbol| "SNARK" "USE-RESOLUTION") 
                       (cons (LISP-SPEC::bool t) nil))) 
                     nil)))))))) 
             (LISP-SPEC::|!list| prover_options)) 
            (LISP-SPEC::|!list| snarkSortDecl)) 
           (LISP-SPEC::|!list| snarkOpDecls)) 
          (LISP-SPEC::|!list| snarkBaseHypothesis)) 
         (LISP-SPEC::|!list| SPECCALC::baseAxioms)) 
        (LISP-SPEC::|!list| snarkHypothesis)) 
       (LISP-SPEC::|!list| (cons snarkConjecture nil))) 
      nil)))))

(defparameter SPECCALC::newContext (vector (cons :|Ref| 0)))

(defun SPECCALC::mkSnarkName (qual id) 
  (block 
   nil 
   (if (string=  "Boolean" qual) 
       (if (string=  "~" id) 
           (return "NOT") 
           (if (string=  "&" id) 
               (return "AND") 
               (if (string=  "or" id) 
                   (return "OR") 
                   (if (string=  "=>" id) 
                       (return "IMPLIES") 
                       (if (string=  "<=>" id) (return "IFF")))))) 
       (if (string=  "Nat" qual) 
           (if (string=  "<=" id) (return "=<")) 
           (if (string=  "Integer" qual) (if (string=  "<=" id) (return "=<"))))) 
   (return id)))

(defun SPECCALC::mkNewSnarkOp (context) 
  (let ((num (INTEGER-SPEC::|!+| (STATE::|!!| (svref context 0)) 1))) 
    (progn (STATE::|:=| (svref context 0) num) 
           (LISP-SPEC::|!symbol| 
            "SNARK" 
            (STRING-SPEC::|!++| "sApply" (NAT-SPEC::toString num))))))

(defun SPECCALC::snarkVar-1 (v) 
  (LISP-SPEC::|!symbol| "SNARK" (STRING-SPEC::^ "?" (car v))))

(defun UTILITIES::freeVars (|!M|) 
  (let ((vars (UTILITIES::freeVarsRec |!M|))) 
    (LISTUTILITIES::removeDuplicates vars)))

(defun SPECCALC::mkNewSnarkTerm (context term) 
  (let ((vars (UTILITIES::freeVars term))) 
    (let ((newFun (SPECCALC::mkNewSnarkOp context))) 
      (let ((snarkVars 
             (LIST-SPEC::|!map|-1-1 
              #'(lambda (v) (SPECCALC::snarkVar-1 v)) 
              vars))) 
        (block 
         nil 
         (if (null snarkVars) (return newFun)) 
         (return (LISP-SPEC::|!cons| newFun (LISP-SPEC::|!list| snarkVars))))))))


(defun SPECCALC::mkSnarkTermApp (context sp dpn vars f arg) 
  (let ((args 
         (block 
          nil 
          (if (eq (car arg) :|Record|) 
              (return 
               (LIST-SPEC::|!map|-1-1 #'(lambda (x) (cdr x)) (car (cdr arg))))) 
          (return (cons arg nil))))) 
    (block 
     nil 
     (if (eq (car f) :|Op|) 
         (let ((pV11 (car (cdr f)))) 
           (if (eq (car pV11) :|Qualified|) 
               (let ((pV13 (cdr pV11))) 
                 (return 
                  (let ((snarkArgs 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (arg) 
                             (SPECCALC::mkSnarkTerm context sp dpn vars arg)) 
                          args))) 
                    (LISP-SPEC::|!cons| 
                     (LISP-SPEC::|!symbol| 
                      "SNARK" 
                      (SPECCALC::mkSnarkName (car pV13) (cdr pV13))) 
                     (LISP-SPEC::|!list| snarkArgs)))))))) 
     (error "Nonexhaustive match failure in mkSnarkTermApp"))))

(defun SPECCALC::mkSnarkTerm (context sp dpn vars term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV14 (cdr term))) 
         (let ((pV31 (svref pV14 0))) 
           (if (eq (car pV31) :|Fun|) 
               (return 
                (SPECCALC::mkSnarkTermApp 
                 context 
                 sp 
                 dpn 
                 vars 
                 (svref (cdr pV31) 0) 
                 (svref pV14 1)))))) 
       (if (eq (car term) :|IfThenElse|) 
           (let ((pV13 (cdr term))) 
             (return 
              (LISP-SPEC::|!list| 
               (cons 
                (LISP-SPEC::|!symbol| "SNARK" "IF") 
                (cons 
                 (SPECCALC::mkSnarkTerm context sp dpn vars (svref pV13 0)) 
                 (cons 
                  (SPECCALC::mkSnarkTerm context sp dpn vars (svref pV13 1)) 
                  (cons 
                   (SPECCALC::mkSnarkTerm context sp dpn vars (svref pV13 2)) 
                   nil))))))) 
           (if (eq (car term) :|Fun|) 
               (let ((pV17 (svref (cdr term) 0))) 
                 (if (eq (car pV17) :|Op|) 
                     (let ((pV22 (car (cdr pV17)))) 
                       (if (eq (car pV22) :|Qualified|) 
                           (let ((pV24 (cdr pV22))) 
                             (return 
                              (LISP-SPEC::|!symbol| 
                               "SNARK" 
                               (SPECCALC::mkSnarkName (car pV24) (cdr pV24))))))) 
                     (if (eq (car pV17) :|Nat|) 
                         (return (LISP-SPEC::|!nat| (cdr pV17)))))) 
               (if (eq (car term) :|Var|) 
                   (return (SPECCALC::snarkVar-1 (car (cdr term)))))))) 
   (return (SPECCALC::mkNewSnarkTerm context term))))

(defun SPECCALC::snarkBoolOp (id) 
  (let ((name (SPECCALC::mkSnarkName "Boolean" id))) 
    (LISP-SPEC::|!symbol| "SNARK" name)))

(defun SPECCALC::mkSnarkFmlaApp (context sp dpn vars f srt arg) 
  (let ((args 
         (block 
          nil 
          (if (eq (car arg) :|Record|) 
              (return 
               (LIST-SPEC::|!map|-1-1 #'(lambda (x) (cdr x)) (car (cdr arg))))) 
          (return (cons arg nil))))) 
    (block 
     nil 
     (if (eq (car f) :|Op|) 
         (let ((pV72 (car (cdr f)))) 
           (if (eq (car pV72) :|Qualified|) 
               (let ((pV74 (cdr pV72))) 
                 (let ((pV76 (cdr pV74))
                       (pV75 (car pV74))) 
                   (progn (if (string=  "Boolean" pV75) 
                              (return 
                               (let ((snarkArgs 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (arg) 
                                          (SPECCALC::mkSnarkFmla 
                                           context 
                                           sp 
                                           dpn 
                                           vars 
                                           nil 
                                           arg)) 
                                       args))) 
                                 (LISP-SPEC::|!cons| 
                                  (SPECCALC::snarkBoolOp pV76) 
                                  (LISP-SPEC::|!list| snarkArgs))))) 
                          (return 
                           (let ((snarkArgs 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'(lambda (arg) 
                                      (SPECCALC::mkSnarkTerm 
                                       context 
                                       sp 
                                       dpn 
                                       vars 
                                       arg)) 
                                   args))) 
                             (LISP-SPEC::|!cons| 
                              (LISP-SPEC::|!symbol| 
                               "SNARK" 
                               (SPECCALC::mkSnarkName pV75 pV76)) 
                              (LISP-SPEC::|!list| snarkArgs))))))))) 
         (if (eq (car f) :|Embedded|) 
             (let ((pV70 (cdr f))) 
               (return 
                (labels 
                  ((boolArgp (srt) 
                    (block 
                     nil 
                     (if (eq (car srt) :|Base|) 
                         (let ((pV15 (svref (cdr srt) 0))) 
                           (if (eq (car pV15) :|Qualified|) 
                               (let ((pV18 (cdr pV15))) 
                                 (return 
                                  (cl:or 
                                   (string=  (car pV18) "Boolean") 
                                   (string=  (cdr pV18) "Boolean"))))))) 
                     (return nil)))) 
                  (block 
                   nil 
                   (if (eq (car srt) :|Arrow|) 
                       (return 
                        (let ((isfmla (boolArgp (svref (cdr srt) 0)))) 
                          (let ((snarkArg 
                                 (if isfmla 
                                     (SPECCALC::mkSnarkFmla 
                                      context 
                                      sp 
                                      dpn 
                                      vars 
                                      nil 
                                      arg) 
                                     (SPECCALC::mkSnarkTerm 
                                      context 
                                      sp 
                                      dpn 
                                      vars 
                                      arg)))) 
                            (LISP-SPEC::|!cons| 
                             (LISP-SPEC::|!symbol| "SNARK" "embed?") 
                             (LISP-SPEC::|!list| 
                              (cons 
                               (LISP-SPEC::|!symbol| "SNARK" pV70) 
                               (cons snarkArg nil)))))))) 
                   (error "Nonexhaustive match failure in mkSnarkFmlaApp"))))) 
             (if (eq (car f) :|Equals|) 
                 (return 
                  (labels 
                    ((boolArgp (srt) 
                      (block 
                       nil 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV32 (svref (cdr srt) 0))) 
                             (if (eq (car pV32) :|Qualified|) 
                                 (let ((pV35 (cdr pV32))) 
                                   (return 
                                    (cl:or 
                                     (string=  (car pV35) "Boolean") 
                                     (string=  (cdr pV35) "Boolean"))))))) 
                       (return nil)))) 
                    (block 
                     nil 
                     (if (consp args) 
                         (let ((pV65 (cdr args))
                               (pV64 (car args))) 
                           (if (consp pV65) 
                               (let ((pV67 (car pV65))) 
                                 (if (null (cdr pV65)) 
                                     (return 
                                      (block 
                                       nil 
                                       (if (eq (car srt) :|Arrow|) 
                                           (let ((pV59 (svref (cdr srt) 0))) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV59) :|Product|) 
                                                   (let ((pV55 (car (cdr pV59)))) 
                                                     (return 
                                                      (block 
                                                       nil 
                                                       (if (consp pV55) 
                                                           (let ((pV45 
                                                                  (cdr pV55))) 
                                                             (if (consp pV45) 
                                                                 (if (null 
                                                                      (cdr pV45)) 
                                                                     (return 
                                                                      (let ((isfmla 
                                                                             (cl:or 
                                                                              (boolArgp 
                                                                               (cdr 
                                                                                (car 
                                                                                 pV55))) 
                                                                              (boolArgp 
                                                                               (cdr 
                                                                                (car 
                                                                                 pV45)))))) 
                                                                        (let ((snarkArg1 
                                                                               (if isfmla 
                                                                                   (SPECCALC::mkSnarkFmla 
                                                                                    context 
                                                                                    sp 
                                                                                    dpn 
                                                                                    vars 
                                                                                    nil 
                                                                                    pV64) 
                                                                                   (SPECCALC::mkSnarkTerm 
                                                                                    context 
                                                                                    sp 
                                                                                    dpn 
                                                                                    vars 
                                                                                    pV64)))) 
                                                                          (let ((snarkArg2 
                                                                                 (if isfmla 
                                                                                     (SPECCALC::mkSnarkFmla 
                                                                                      context 
                                                                                      sp 
                                                                                      dpn 
                                                                                      vars 
                                                                                      nil 
                                                                                      pV67) 
                                                                                     (SPECCALC::mkSnarkTerm 
                                                                                      context 
                                                                                      sp 
                                                                                      dpn 
                                                                                      vars 
                                                                                      pV67)))) 
                                                                            (if isfmla 
                                                                                (LISP-SPEC::|!cons| 
                                                                                 (LISP-SPEC::|!symbol| 
                                                                                  "SNARK" 
                                                                                  "IFF") 
                                                                                 (LISP-SPEC::|!list| 
                                                                                  (cons 
                                                                                   snarkArg1 
                                                                                   (cons 
                                                                                    snarkArg2 
                                                                                    nil)))) 
                                                                                (LISP-SPEC::|!cons| 
                                                                                 (LISP-SPEC::|!symbol| 
                                                                                  "SNARK" 
                                                                                  "=") 
                                                                                 (LISP-SPEC::|!list| 
                                                                                  (cons 
                                                                                   snarkArg1 
                                                                                   (cons 
                                                                                    snarkArg2 
                                                                                    nil))))))))))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in mkSnarkFmlaApp"))))) 
                                               (error 
                                                "Nonexhaustive match failure in mkSnarkFmlaApp"))))) 
                                       (error 
                                        "Nonexhaustive match failure in mkSnarkFmlaApp")))))))) 
                     (error "Nonexhaustive match failure in mkSnarkFmlaApp"))))))) 
     (error "Nonexhaustive match failure in mkSnarkFmlaApp"))))

(defun SPECCALC::findPBuiltInSort (pV52 pV53 pV54) 
  (block 
   nil 
   (if (eq (car pV53) :|Qualified|) 
       (let ((pV57 (cdr (cdr pV53)))) 
         (return 
          (let ((|!optSrt| (STANDARDSPEC::findTheSort pV52 pV53))) 
            (block 
             nil 
             (if (eq (car |!optSrt|) :|Some|) 
                 (let ((pV51 (svref (cdr |!optSrt|) 2))) 
                   (return 
                    (labels 
                      ((builtinSort? (s) 
                        (block 
                         nil 
                         (if (eq (car s) :|Base|) 
                             (let ((pV11 (svref (cdr s) 0))) 
                               (if (eq (car pV11) :|Qualified|) 
                                   (let ((pV14 (cdr pV11))) 
                                     (let ((pV16 (cdr pV14))
                                           (pV15 (car pV14))) 
                                       (if (string=  "Nat" pV15) 
                                           (if (string=  "Nat" pV16) (return t)) 
                                           (if (string=  "Integer" pV15) 
                                               (if (string=  "Integer" pV16) 
                                                   (return t)) 
                                               (if (string=  "Boolean" pV15) 
                                                   (if (string=  "Boolean" pV16) 
                                                       (return t)))))))))) 
                         (return nil)))) 
                      (labels 
                        ((builtinSnarkSort (s) 
                          (block 
                           nil 
                           (if (eq (car s) :|Base|) 
                               (let ((pV25 (svref (cdr s) 0))) 
                                 (if (eq (car pV25) :|Qualified|) 
                                     (let ((pV28 (cdr pV25))) 
                                       (let ((pV30 (cdr pV28))
                                             (pV29 (car pV28))) 
                                         (if (string=  "Nat" pV29) 
                                             (if (string=  "Nat" pV30) 
                                                 (return 
                                                  (LISP-SPEC::|!symbol| 
                                                   "SNARK" 
                                                   "NATURAL"))) 
                                             (if (string=  "Integer" pV29) 
                                                 (if (string=  "Integer" pV30) 
                                                     (return 
                                                      (LISP-SPEC::|!symbol| 
                                                       "SNARK" 
                                                       "INTEGER"))) 
                                                 (if (string=  "Boolean" pV29) 
                                                     (if (string=  
                                                          "Boolean" 
                                                          pV30) 
                                                         (return 
                                                          (if pV54 
                                                              (LISP-SPEC::|!symbol| 
                                                               "SNARK" 
                                                               "BOOLEAN") 
                                                              (LISP-SPEC::|!symbol| 
                                                               "SNARK" 
                                                               "TRUE")))))))))))) 
                           (error 
                            "Nonexhaustive match failure in findPBuiltInSort")))) 
                        (let ((builtinScheme 
                               (LIST-SPEC::|!find|-1-1 
                                #'(lambda (x) (builtinSort? (cdr x))) 
                                pV51))) 
                          (block 
                           nil 
                           (if (eq (car builtinScheme) :|Some|) 
                               (return 
                                (builtinSnarkSort (cdr (cdr builtinScheme))))) 
                           (return 
                            (block 
                             nil 
                             (if (consp pV51) 
                                 (if (null (cdr pV51)) 
                                     (return 
                                      (SPECCALC::snarkPBaseSort 
                                       pV52 
                                       (cdr (car pV51)) 
                                       pV54)))) 
                             (return (LISP-SPEC::|!symbol| "SNARK" pV57))))))))))) 
             (return (LISP-SPEC::|!symbol| "SNARK" pV57))))))) 
   (error "Nonexhaustive match failure in findPBuiltInSort")))

(defun SPECCALC::snarkPBaseSort (spc s rng?) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV21 (svref (cdr s) 0))) 
         (if (eq (car pV21) :|Qualified|) 
             (let ((pV24 (cdr pV21))) 
               (let ((pV26 (cdr pV24))
                     (pV25 (car pV24))) 
                 (progn (if (string=  "Nat" pV25) 
                            (if (string=  "Nat" pV26) 
                                (return (LISP-SPEC::|!symbol| "SNARK" "NATURAL"))) 
                            (if (string=  "Integer" pV25) 
                                (if (string=  "Integer" pV26) 
                                    (return 
                                     (LISP-SPEC::|!symbol| "SNARK" "INTEGER"))) 
                                (if (string=  "Boolean" pV25) 
                                    (if (string=  "Boolean" pV26) 
                                        (return 
                                         (if rng? 
                                             (LISP-SPEC::|!symbol| 
                                              "SNARK" 
                                              "BOOLEAN") 
                                             (LISP-SPEC::|!symbol| 
                                              "SNARK" 
                                              "TRUE"))))))) 
                        (return 
                         (SPECCALC::findPBuiltInSort 
                          spc 
                          (cons :|Qualified| (cons pV25 pV26)) 
                          rng?)) 
                        (return 
                         (if rng? 
                             (LISP-SPEC::|!symbol| "SNARK" pV26) 
                             (LISP-SPEC::|!symbol| "SNARK" pV26)))))))) 
       (if (eq (car s) :|Product|) 
           (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
           (if (eq (car s) :|Arrow|) 
               (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
               (if (eq (car s) :|TyVar|) 
                   (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")))))) 
   (return (LISP-SPEC::|!symbol| "SNARK" "TRUE"))))

(defun SPECCALC::snarkBndVar (sp var globalVars) 
  (block 
   nil 
   (let ((pV4 (cdr var))
         (pV3 (car var))) 
     (return 
      (if (LIST-SPEC::|!exists|-1-1 
           #'(lambda (x) (string=  pV3 (car x))) 
           globalVars) 
          (LISP-SPEC::|!list| 
           (cons 
            (SPECCALC::snarkVar-1 var) 
            (cons 
             (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
             (cons 
              (SPECCALC::snarkPBaseSort sp pV4 nil) 
              (cons 
               (LISP-SPEC::|!symbol| "KEYWORD" "GLOBAL") 
               (cons (LISP-SPEC::|!symbol| "SNARK" "T") nil)))))) 
          (LISP-SPEC::|!list| 
           (cons 
            (SPECCALC::snarkVar-1 var) 
            (cons 
             (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
             (cons (SPECCALC::snarkPBaseSort sp pV4 nil) nil))))))) 
   (error "Nonexhaustive match failure in snarkBndVar")))

(defun SPECCALC::snarkBndVars (sp vars globalVars) 
  (let ((snarkVarList 
         (LIST-SPEC::|!map|-1-1 
          #'(lambda (var) (SPECCALC::snarkBndVar sp var globalVars)) 
          vars))) (let ((res (LISP-SPEC::|!list| snarkVarList))) res)))

(defparameter SPECTOLISP::lispStrings 
  (STRINGSET::fromList 
   (cons 
    "NIL" 
    (cons 
     "T" 
     (cons 
      "CONS" 
      (cons 
       "NULL" 
       (cons 
        "CAR" 
        (cons 
         "CDR" 
         (cons 
          "LIST" 
          (cons 
           "LISP" 
           (cons 
            "APPEND" 
            (cons 
             "REVAPPEND" 
             (cons 
              "REVERSE" 
              (cons 
               "COMPILE" 
               (cons 
                "REDUCE" 
                (cons 
                 "SUBSTITUTE" 
                 (cons 
                  "COUNT" 
                  (cons 
                   "ENCLOSE" 
                   (cons 
                    "EVAL" 
                    (cons 
                     "ERROR" 
                     (cons 
                      "FIRST" 
                      (cons 
                       "LAST" 
                       (cons 
                        "SECOND" 
                        (cons 
                         "THIRD" 
                         (cons 
                          "FOURTH" 
                          (cons 
                           "FIFTH" 
                           (cons 
                            "SIXTH" 
                            (cons 
                             "SEVENTH" 
                             (cons 
                              "EIGHTH" 
                              (cons 
                               "NINTH" 
                               (cons 
                                "TENTH" 
                                (cons 
                                 "UNION" 
                                 (cons 
                                  "INTERSECTION" 
                                  (cons 
                                   "SET" 
                                   (cons 
                                    "SETQ" 
                                    (cons 
                                     "SOME" 
                                     (cons 
                                      "ARRAY" 
                                      (cons 
                                       "POP" 
                                       (cons 
                                        "PUSH" 
                                        (cons 
                                         "TOP" 
                                         (cons 
                                          "REMOVE" 
                                          (cons 
                                           "GET" 
                                           (cons 
                                            "REPLACE" 
                                            (cons 
                                             "PI" 
                                             (cons 
                                              "DELETE" 
                                              (cons 
                                               "IDENTITY" 
                                               (cons 
                                                "REM" 
                                                (cons 
                                                 "NTH" 
                                                 (cons 
                                                  "EQ" 
                                                  (cons 
                                                   "EQL" 
                                                   (cons 
                                                    "EQUAL" 
                                                    (cons 
                                                     "ZEROP" 
                                                     (cons 
                                                      "ODDP" 
                                                      (cons 
                                                       "EVENP" 
                                                       (cons 
                                                        "SEARCH" 
                                                        (cons 
                                                         "COMPILE" 
                                                         (cons 
                                                          "MERGE" 
                                                          (cons 
                                                           "RETURN" 
                                                           (cons 
                                                            "VECTOR" 
                                                            (cons 
                                                             "SVREF" 
                                                             (cons 
                                                              "FORALL" 
                                                              (cons 
                                                               "EXISTS" 
                                                               (cons 
                                                                "SETF" 
                                                                (cons 
                                                                 "LOOP" 
                                                                 (cons 
                                                                  "OR" 
                                                                  (cons 
                                                                   "AND" 
                                                                   (cons 
                                                                    "NOT" 
                                                                    (cons 
                                                                     "LENGTH" 
                                                                     (cons 
                                                                      "MAP" 
                                                                      (cons 
                                                                       "MEMBER" 
                                                                       (cons 
                                                                        "TIME" 
                                                                        (cons 
                                                                         "CHAR" 
                                                                         (cons 
                                                                          "STRING" 
                                                                          (cons 
                                                                           "SYMBOL" 
                                                                           (cons 
                                                                            "NAT" 
                                                                            (cons 
                                                                             "MAKE-STRING" 
                                                                             (cons 
                                                                              "CONST" 
                                                                              (cons 
                                                                               "IF" 
                                                                               (cons 
                                                                                "APPLY" 
                                                                                (cons 
                                                                                 "QUOTE" 
                                                                                 (cons 
                                                                                  "MIN" 
                                                                                  (cons 
                                                                                   "GO" 
                                                                                   (cons 
                                                                                    "PRINT" 
                                                                                    (cons 
                                                                                     "READ" 
                                                                                     (cons 
                                                                                      "WRITE" 
                                                                                      (cons 
                                                                                       "LOAD" 
                                                                                       (cons 
                                                                                        ".." 
                                                                                        (cons 
                                                                                         "BLOCK" 
                                                                                         (cons 
                                                                                          "FORMAT" 
                                                                                          (cons 
                                                                                           "BREAK" 
                                                                                           (cons 
                                                                                            "SUBST" 
                                                                                            (cons 
                                                                                             "FIND" 
                                                                                             (cons 
                                                                                              "CLASS" 
                                                                                              (cons 
                                                                                               "+" 
                                                                                               (cons 
                                                                                                "++" 
                                                                                                (cons 
                                                                                                 "**" 
                                                                                                 (cons 
                                                                                                  "-" 
                                                                                                  (cons 
                                                                                                   "*" 
                                                                                                   (cons 
                                                                                                    ">" 
                                                                                                    (cons 
                                                                                                     "<" 
                                                                                                     (cons 
                                                                                                      "<=" 
                                                                                                      (cons 
                                                                                                       ">= " 
                                                                                                       (cons 
                                                                                                        "\\=" 
                                                                                                        (cons 
                                                                                                         "BOOLEAN" 
                                                                                                         (cons 
                                                                                                          "INTEGER" 
                                                                                                          (cons 
                                                                                                           "SHADOW" 
                                                                                                           (cons 
                                                                                                            "TRACE" 
                                                                                                            (cons 
                                                                                                             "WHEN" 
                                                                                                             (cons 
                                                                                                              "SYSTEM" 
                                                                                                              (cons 
                                                                                                               "IO" 
                                                                                                               (cons 
                                                                                                                "BOOTSTRAP" 
                                                                                                                (cons 
                                                                                                                 "HASHTABLE" 
                                                                                                                 nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))


(defparameter SPECTOLISP::notReallyLispStrings 
  (cons 
   "C" 
   (cons 
    "D" 
    (cons 
     "I" 
     (cons 
      "M" 
      (cons 
       "N" 
       (cons 
        "P" 
        (cons 
         "S" 
         (cons 
          "V" 
          (cons 
           "X" 
           (cons 
            "Y" 
            (cons 
             "Z" 
             (cons "KEY" (cons "NAME" (cons "VALUE" (cons "PATTERN" nil))))))))))))))))


(defun SPECTOLISP::isLispString (id) 
  (cl:or 
   (STRINGSET::|!member| SPECTOLISP::lispStrings id) 
   (cl:and 
    (LISP-SPEC::uncell 
     (LISP-SPEC::|!apply| 
      (LISP-SPEC::|!symbol| "CL" "FIND-SYMBOL") 
      (cons (LISP-SPEC::|!string| id) (cons (LISP-SPEC::|!string| "CL") nil)))) 
    (BOOLEAN-SPEC::~ (LIST-SPEC::|!member| id SPECTOLISP::notReallyLispStrings)))))


(defparameter SPECTOLISP::userStrings (cons :|Ref| STRINGSET::empty))

(defparameter SPECTOLISP::userUpper (cons :|Ref| STRINGSET::empty))

(defun SPECTOLISP::lookupSpecId (id |!ID|) 
  (if (STRINGSET::|!member| (STATE::|!!| SPECTOLISP::userUpper) |!ID|) 
      (if (STRINGSET::|!member| (STATE::|!!| SPECTOLISP::userStrings) id) 
          id 
          (STRING-SPEC::^ (STRING-SPEC::^ "|!" id) "|")) 
      (progn (STATE::|:=| 
              SPECTOLISP::userUpper 
              (STRINGSET::add (STATE::|!!| SPECTOLISP::userUpper) |!ID|)) 
             (STATE::|:=| 
              SPECTOLISP::userStrings 
              (STRINGSET::add (STATE::|!!| SPECTOLISP::userStrings) id)) 
             id)))

(defun SPECTOLISP::specId (id) 
  (let ((id 
         (STRING-SPEC::translate-1-1 
          #'(lambda (pV1) 
             (block 
              nil 
              (if (eq #\| pV1) (return "\\|") (if (eq #\# pV1) (return "\\#"))) 
              (return (CHAR-SPEC::toString pV1)))) 
          id))) 
    (let ((|!ID| (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase id))) 
      (if (cl:or 
           (SPECTOLISP::isLispString |!ID|) 
           (eq (STRING-SPEC::sub id 0) #\!)) 
          (STRING-SPEC::^ (STRING-SPEC::^ "|!" id) "|") 
          (if (LIST-SPEC::|!exists|-1-1 
               #'(lambda (ch) (eq ch #\:)) 
               (STRING-SPEC::explode id)) 
              (STRING-SPEC::^ (STRING-SPEC::^ "|" id) "|") 
              (SPECTOLISP::lookupSpecId id |!ID|))))))

(defun STRINGSET::addList (x0 x) (SPLAYSET::addList x0 x))

(defun SPECCALC::mkSnarkFmla (context sp dpn vars globalVars fmla) 
  (block 
   nil 
   (if (eq (car fmla) :|Bind|) 
       (let ((pV12 (cdr fmla))) 
         (let ((pV29 (svref pV12 1))) 
           (return 
            (let ((snarkBndList (SPECCALC::snarkBndVars sp pV29 globalVars))) 
              (let ((newVars 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x) (SPECTOLISP::specId (car x))) 
                      pV29))) 
                (let ((snarkFmla 
                       (SPECCALC::mkSnarkFmla 
                        context 
                        sp 
                        dpn 
                        (STRINGSET::addList vars newVars) 
                        globalVars 
                        (svref pV12 2)))) 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| 
                     "SNARK" 
                     (SPECCALC::bndrString (svref pV12 0))) 
                    (cons snarkBndList (cons snarkFmla nil)))))))))) 
       (if (eq (car fmla) :|Apply|) 
           (let ((pV11 (cdr fmla))) 
             (let ((pV21 (svref pV11 0))) 
               (if (eq (car pV21) :|Fun|) 
                   (let ((pV24 (cdr pV21))) 
                     (return 
                      (SPECCALC::mkSnarkFmlaApp 
                       context 
                       sp 
                       dpn 
                       vars 
                       (svref pV24 0) 
                       (svref pV24 1) 
                       (svref pV11 1))))))) 
           (if (eq (car fmla) :|IfThenElse|) 
               (let ((pV10 (cdr fmla))) 
                 (return 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| "SNARK" "IF") 
                    (cons 
                     (SPECCALC::mkSnarkFmla 
                      context 
                      sp 
                      dpn 
                      vars 
                      globalVars 
                      (svref pV10 0)) 
                     (cons 
                      (SPECCALC::mkSnarkFmla 
                       context 
                       sp 
                       dpn 
                       vars 
                       globalVars 
                       (svref pV10 1)) 
                      (cons 
                       (SPECCALC::mkSnarkFmla 
                        context 
                        sp 
                        dpn 
                        vars 
                        globalVars 
                        (svref pV10 2)) 
                       nil))))))) 
               (if (eq (car fmla) :|Fun|) 
                   (let ((pV13 (svref (cdr fmla) 0))) 
                     (if (eq (car pV13) :|Bool|) 
                         (let ((pV16 (cdr pV13))) 
                           (if (eq t pV16) 
                               (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
                               (if (eq nil pV16) 
                                   (return 
                                    (LISP-SPEC::|!symbol| "SNARK" "FALSE"))))))))))) 
   (return (SPECCALC::mkSnarkTerm context sp dpn vars fmla))))

(defparameter SPECCALC::snark_prove (LISP-SPEC::|!symbol| "SNARK" "PROVE"))

(defun SPECCALC::snarkAnswer (pV1 pV2 pV3 pV4) 
  (block 
   nil 
   (return 
    (let ((snarkFmla 
           (SPECCALC::mkSnarkFmla 
            pV1 
            pV2 
            "SNARK" 
            STRINGSET::empty 
            pV4 
            (svref pV3 3)))) 
      (let ((snarkAnsVars 
             (LIST-SPEC::|!map|-1-1 
              #'(lambda (v) (SPECCALC::snarkVar-1 v)) 
              pV4))) 
        (let ((snarkAnsTerm 
               (LISP-SPEC::|!list| 
                (LIST-SPEC::|!++| 
                 (cons (LISP-SPEC::|!symbol| "SNARK" "ANS") nil) 
                 snarkAnsVars)))) 
          (LISP-SPEC::|!list| 
           (cons 
            SPECCALC::snark_prove 
            (cons 
             (LISP-SPEC::|!quote| snarkFmla) 
             (cons 
              (LISP-SPEC::|!symbol| "KEYWORD" "ANSWER") 
              (cons 
               (LISP-SPEC::|!quote| snarkAnsTerm) 
               (cons 
                (LISP-SPEC::|!symbol| "KEYWORD" "NAME") 
                (cons (LISP-SPEC::|!symbol| "KEYWORD" (svref pV3 1)) nil))))))))))) 
   (error "Nonexhaustive match failure in snarkAnswer")))

(defparameter SPECCALC::snarkBaseDecls 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_predicate 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "embed?")) 
      (cons (LISP-SPEC::|!nat| 2) nil)))) 
   nil))

(defun SPECCALC::snarkFunctionCurryDecl () (LISP-SPEC::|!nil|))

(defun SPECCALC::findBuiltInSort (pV52 pV53 pV54) 
  (block 
   nil 
   (if (eq (car pV53) :|Qualified|) 
       (let ((pV57 (cdr (cdr pV53)))) 
         (return 
          (let ((|!optSrt| (STANDARDSPEC::findTheSort pV52 pV53))) 
            (block 
             nil 
             (if (eq (car |!optSrt|) :|Some|) 
                 (let ((pV51 (svref (cdr |!optSrt|) 2))) 
                   (return 
                    (labels 
                      ((builtinSort? (s) 
                        (block 
                         nil 
                         (if (eq (car s) :|Base|) 
                             (let ((pV11 (svref (cdr s) 0))) 
                               (if (eq (car pV11) :|Qualified|) 
                                   (let ((pV14 (cdr pV11))) 
                                     (let ((pV16 (cdr pV14))
                                           (pV15 (car pV14))) 
                                       (if (string=  "Nat" pV15) 
                                           (if (string=  "Nat" pV16) (return t)) 
                                           (if (string=  "Integer" pV15) 
                                               (if (string=  "Integer" pV16) 
                                                   (return t)) 
                                               (if (string=  "Boolean" pV15) 
                                                   (if (string=  "Boolean" pV16) 
                                                       (return t)))))))))) 
                         (return nil)))) 
                      (labels 
                        ((builtinSnarkSort (s) 
                          (block 
                           nil 
                           (if (eq (car s) :|Base|) 
                               (let ((pV25 (svref (cdr s) 0))) 
                                 (if (eq (car pV25) :|Qualified|) 
                                     (let ((pV28 (cdr pV25))) 
                                       (let ((pV30 (cdr pV28))
                                             (pV29 (car pV28))) 
                                         (if (string=  "Nat" pV29) 
                                             (if (string=  "Nat" pV30) 
                                                 (return 
                                                  (LISP-SPEC::|!symbol| 
                                                   "SNARK" 
                                                   "NATURAL"))) 
                                             (if (string=  "Integer" pV29) 
                                                 (if (string=  "Integer" pV30) 
                                                     (return 
                                                      (LISP-SPEC::|!symbol| 
                                                       "SNARK" 
                                                       "INTEGER"))) 
                                                 (if (string=  "Boolean" pV29) 
                                                     (if (string=  
                                                          "Boolean" 
                                                          pV30) 
                                                         (return 
                                                          (if pV54 
                                                              (LISP-SPEC::|!symbol| 
                                                               "SNARK" 
                                                               "BOOLEAN") 
                                                              (LISP-SPEC::|!symbol| 
                                                               "SNARK" 
                                                               "TRUE")))))))))))) 
                           (error 
                            "Nonexhaustive match failure in findBuiltInSort")))) 
                        (let ((builtinScheme 
                               (LIST-SPEC::|!find|-1-1 
                                #'(lambda (x) (builtinSort? (cdr x))) 
                                pV51))) 
                          (block 
                           nil 
                           (if (eq (car builtinScheme) :|Some|) 
                               (return 
                                (builtinSnarkSort (cdr (cdr builtinScheme))))) 
                           (return 
                            (block 
                             nil 
                             (if (consp pV51) 
                                 (if (null (cdr pV51)) 
                                     (return 
                                      (SPECCALC::snarkBaseSort 
                                       pV52 
                                       (cdr (car pV51)) 
                                       pV54)))) 
                             (return (LISP-SPEC::|!symbol| "SNARK" pV57))))))))))) 
             (return (LISP-SPEC::|!symbol| "SNARK" pV57))))))) 
   (error "Nonexhaustive match failure in findBuiltInSort")))

(defun SPECCALC::snarkBaseSort (spc s rng?) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV21 (svref (cdr s) 0))) 
         (if (eq (car pV21) :|Qualified|) 
             (let ((pV24 (cdr pV21))) 
               (let ((pV26 (cdr pV24))
                     (pV25 (car pV24))) 
                 (progn (if (string=  "Nat" pV25) 
                            (if (string=  "Nat" pV26) 
                                (return (LISP-SPEC::|!symbol| "SNARK" "NATURAL"))) 
                            (if (string=  "Integer" pV25) 
                                (if (string=  "Integer" pV26) 
                                    (return 
                                     (LISP-SPEC::|!symbol| "SNARK" "INTEGER"))) 
                                (if (string=  "Boolean" pV25) 
                                    (if (string=  "Boolean" pV26) 
                                        (return 
                                         (if rng? 
                                             (LISP-SPEC::|!symbol| 
                                              "SNARK" 
                                              "BOOLEAN") 
                                             (LISP-SPEC::|!symbol| 
                                              "SNARK" 
                                              "TRUE"))))))) 
                        (return 
                         (SPECCALC::findBuiltInSort 
                          spc 
                          (cons :|Qualified| (cons pV25 pV26)) 
                          rng?)) 
                        (return 
                         (if rng? 
                             (LISP-SPEC::|!symbol| "SNARK" pV26) 
                             (LISP-SPEC::|!symbol| "SNARK" pV26)))))))) 
       (if (eq (car s) :|Product|) 
           (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
           (if (eq (car s) :|Arrow|) 
               (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
               (if (eq (car s) :|TyVar|) 
                   (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")))))) 
   (return (LISP-SPEC::|!symbol| "SNARK" "TRUE"))))

(defun SPECCALC::snarkPropositionSymbolDecl (name) 
  (LISP-SPEC::|!list| 
   (cons 
    SPECCALC::declare_proposition_symbol 
    (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" name)) nil))))

(defun SPECCALC::snarkFunctionNoArityDecl (spc name srt) 
  (block 
   nil 
   (if (eq (car srt) :|Base|) 
       (let ((pV8 (svref (cdr srt) 0))) 
         (if (eq (car pV8) :|Qualified|) 
             (progn (if (string=  "Boolean" (cdr (cdr pV8))) 
                        (return (SPECCALC::snarkPropositionSymbolDecl name))) 
                    (return 
                     (LISP-SPEC::|!list| 
                      (cons 
                       SPECCALC::declare_constant 
                       (cons 
                        (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" name)) 
                        (cons 
                         (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
                         (cons 
                          (LISP-SPEC::|!quote| 
                           (SPECCALC::snarkBaseSort spc srt t)) 
                          nil)))))))))) 
   (return (LISP-SPEC::|!nil|))))

(defun SPECCALC::snarkFunctionCurryNoArityDecl (spc name srt) 
  (SPECCALC::snarkFunctionNoArityDecl spc name srt))

(defun SPECCALC::snarkPredicateDecl (spc name dom arity) 
  (let ((pV1 (SPECENVIRONMENT::productOpt spc dom))) 
    (block 
     nil 
     (if (eq (car pV1) :|Some|) 
         (return 
          (let ((domSortList 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) (SPECCALC::snarkBaseSort spc (cdr x) nil)) 
                  (cdr pV1)))) 
            (LISP-SPEC::|!list| 
             (cons 
              SPECCALC::declare_predicate 
              (cons 
               (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" name)) 
               (cons 
                (LISP-SPEC::|!nat| arity) 
                (cons 
                 (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
                 (cons 
                  (LISP-SPEC::|!quote| 
                   (LISP-SPEC::|!cons| 
                    (LISP-SPEC::|!symbol| "SNARK" "BOOLEAN") 
                    (LISP-SPEC::|!list| domSortList))) 
                  nil))))))))) 
     (error "Nonexhaustive match failure in snarkPredicateDecl"))))

(defun SPECCALC::snarkFunctionNoCurryDecl (spc name srt arity) 
  (let ((pV15 (SPECENVIRONMENT::arrowOpt spc srt))) 
    (block 
     nil 
     (if (eq (car pV15) :|Some|) 
         (let ((pV16 (cdr pV15))) 
           (let ((pV18 (cdr pV16))
                 (pV17 (car pV16))) 
             (return 
              (block 
               nil 
               (if (eq (car pV18) :|Base|) 
                   (let ((pV9 (svref (cdr pV18) 0))) 
                     (if (eq (car pV9) :|Qualified|) 
                         (if (string=  "Boolean" (cdr (cdr pV9))) 
                             (return 
                              (SPECCALC::snarkPredicateDecl spc name pV17 arity)))))) 
               (return 
                (let ((pV5 (SPECENVIRONMENT::productOpt spc pV17))) 
                  (block 
                   nil 
                   (if (eq (car pV5) :|Some|) 
                       (return 
                        (let ((domSortList 
                               (LIST-SPEC::|!map|-1-1 
                                #'(lambda (x) 
                                   (SPECCALC::snarkBaseSort spc (cdr x) nil)) 
                                (cdr pV5)))) 
                          (LISP-SPEC::|!list| 
                           (cons 
                            SPECCALC::declare_function 
                            (cons 
                             (LISP-SPEC::|!quote| 
                              (LISP-SPEC::|!symbol| "SNARK" name)) 
                             (cons 
                              (LISP-SPEC::|!nat| arity) 
                              (cons 
                               (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
                               (cons 
                                (LISP-SPEC::|!quote| 
                                 (LISP-SPEC::|!cons| 
                                  (SPECCALC::snarkBaseSort spc pV18 t) 
                                  (LISP-SPEC::|!list| domSortList))) 
                                nil))))))))) 
                   (error 
                    "Nonexhaustive match failure in snarkFunctionNoCurryDecl"))))))))) 
     (error "Nonexhaustive match failure in snarkFunctionNoCurryDecl"))))

(defun SPECTOLISP::curryShapeNum (sp srt) 
  (let ((pV2 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV2) :|Some|) 
         (return 
          (INTEGER-SPEC::|!+| 1 (SPECTOLISP::curryShapeNum sp (cdr (cdr pV2)))))) 
     (return 0))))

(defun SPECCALC::snarkFunctionDecl (spc name srt) 
  (let ((pV5 (ARITYNORMALIZE::sortArity spc srt))
        (pV4 (SPECTOLISP::curryShapeNum spc srt))) 
    (block 
     nil 
     (if ( =  1 pV4) 
         (if (eq (car pV5) :|None|) 
             (return (SPECCALC::snarkFunctionNoArityDecl spc name srt)) 
             (if (eq (car pV5) :|Some|) 
                 (return 
                  (SPECCALC::snarkFunctionNoCurryDecl 
                   spc 
                   name 
                   srt 
                   (cdr (cdr pV5))))))) 
     (if (eq (car pV5) :|None|) 
         (return (SPECCALC::snarkFunctionCurryNoArityDecl spc name srt)) 
         (if (eq (car pV5) :|Some|) (return (SPECCALC::snarkFunctionCurryDecl)))) 
     (return (SPECCALC::snarkFunctionNoArityDecl spc name srt)))))

(defun SPECTOLISP::functionSort? (sp srt) 
  (let ((pV5 (SPECENVIRONMENT::unfoldBase sp srt))) 
    (block 
     nil 
     (if (eq (car pV5) :|Arrow|) 
         (return t) 
         (if (eq (car pV5) :|Subsort|) 
             (return (SPECTOLISP::functionSort? sp (svref (cdr pV5) 0))))) 
     (return nil))))

(defun SPECCALC::snarkOpDecl (spc name srt) 
  (if (SPECTOLISP::functionSort? spc srt) 
      (SPECCALC::snarkFunctionDecl spc name srt) 
      (SPECCALC::snarkFunctionDecl spc name srt)))

(defun SPECCALC::snarkOpDeclPartial (spc name srt) 
  (let ((decl (SPECCALC::snarkOpDecl spc name srt))) 
    (if (LISP-SPEC::|!null| decl) '(:|None|) (cons :|Some| decl))))

(defun SPECCALC::snarkOpDecls-1 (spc) 
  (let ((opsigs (specOps-1 spc))) 
    (let ((snarkOpDecls 
           (LIST-SPEC::mapPartial-1-1 
            #'(lambda (x) 
               (SPECCALC::snarkOpDeclPartial 
                spc 
                (SPECCALC::mkSnarkName (svref x 0) (svref x 1)) 
                (svref x 3))) 
            opsigs))) (LIST-SPEC::|!++| SPECCALC::snarkBaseDecls snarkOpDecls))))


(defun SPECCALC::snarkProperty (pV1 pV2 pV3) 
  (block 
   nil 
   (return 
    (let ((snarkFmla 
           (SPECCALC::mkSnarkFmla 
            pV1 
            pV2 
            "SNARK" 
            STRINGSET::empty 
            nil 
            (svref pV3 3)))) 
      (LISP-SPEC::|!list| 
       (cons 
        SPECCALC::snark_assert 
        (cons 
         (LISP-SPEC::|!quote| snarkFmla) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "NAME") 
          (cons (LISP-SPEC::|!symbol| "KEYWORD" (svref pV3 1)) nil))))))) 
   (error "Nonexhaustive match failure in snarkProperty")))

(defparameter SPECCALC::logicalSorts 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_function 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "logical-&")) 
      (cons 
       (LISP-SPEC::|!nat| 2) 
       (cons 
        (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
        (cons 
         (LISP-SPEC::|!quote| 
          (LISP-SPEC::|!list| 
           (cons 
            (LISP-SPEC::|!symbol| "SNARK" "logical") 
            (cons 
             (LISP-SPEC::|!symbol| "SNARK" "logical") 
             (cons (LISP-SPEC::|!symbol| "SNARK" "logical") nil))))) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
          (cons 
           (LISP-SPEC::bool t) 
           (cons 
            (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
            (cons (LISP-SPEC::bool t) nil)))))))))) 
   (cons 
    (LISP-SPEC::|!list| 
     (cons 
      SPECCALC::declare_function 
      (cons 
       (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "logical-or")) 
       (cons 
        (LISP-SPEC::|!nat| 2) 
        (cons 
         (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
         (cons 
          (LISP-SPEC::|!quote| 
           (LISP-SPEC::|!list| 
            (cons 
             (LISP-SPEC::|!symbol| "SNARK" "logical") 
             (cons 
              (LISP-SPEC::|!symbol| "SNARK" "logical") 
              (cons (LISP-SPEC::|!symbol| "SNARK" "logical") nil))))) 
          (cons 
           (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
           (cons 
            (LISP-SPEC::bool t) 
            (cons 
             (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
             (cons (LISP-SPEC::bool t) nil)))))))))) 
    nil)))

(defun SPECCALC::snarkBuiltInSorts (useLogicalSorts) 
  (LIST-SPEC::|!++| 
   (LIST-SPEC::|!++| 
    (if useLogicalSorts SPECCALC::logicalSorts nil) 
    SPECCALC::arithmeticSorts) 
   SPECCALC::baseSorts))

(defun SPECCALC::snarkSorts-1 (spc) 
  (let ((sorts (sortsAsList-1 spc))) 
    (let ((snarkSorts 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (x) 
               (LISP-SPEC::|!list| 
                (cons 
                 SPECCALC::declare_sort 
                 (cons 
                  (LISP-SPEC::|!quote| 
                   (LISP-SPEC::|!symbol| "SNARK" (svref x 1))) 
                  nil)))) 
            sorts))) 
      (LIST-SPEC::|!++| (SPECCALC::snarkBuiltInSorts nil) snarkSorts))))

(defun SPECCALC::proveForAns
 (ansVars claim spc base_hypothesis base_spc prover_options snarkLogFileName) 
  (block 
   nil 
   (let ((pV7 (svref claim 0))) 
     (return 
      (labels 
        ((claimType (ct) 
          (block 
           nil 
           (if (eq (car ct) :|Conjecture|) 
               (return "Conjecture") 
               (if (eq (car ct) :|Theorem|) 
                   (return "Theorem") 
                   (if (eq (car ct) :|Axiom|) (return "Axiom")))) 
           (error "Nonexhaustive match failure in proveForAns")))) 
        (let ((claim_type (claimType pV7))) 
          (let ((snarkSortDecls (SPECCALC::snarkSorts-1 spc))) 
            (let ((snarkOpDecls (SPECCALC::snarkOpDecls-1 spc))) 
              (let ((snarkBaseHypothesis 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (prop) 
                         (SPECCALC::snarkProperty 
                          SPECCALC::newContext 
                          base_spc 
                          prop)) 
                      base_hypothesis))) 
                (let ((snarkHypothesis 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (prop) 
                           (SPECCALC::snarkProperty 
                            SPECCALC::newContext 
                            spc 
                            prop)) 
                        (svref spc 2)))) 
                  (let ((snarkConjecture 
                         (SPECCALC::snarkAnswer 
                          SPECCALC::newContext 
                          spc 
                          claim 
                          ansVars))) 
                    (let ((snarkEvalForm 
                           (SPECCALC::makeSnarkAnsEvalForm 
                            prover_options 
                            snarkSortDecls 
                            snarkOpDecls 
                            snarkBaseHypothesis 
                            snarkHypothesis 
                            snarkConjecture 
                            snarkLogFileName))) 
                      (progn (if SYSTEM-SPEC::specwareDebug? 
                                 (STRING-SPEC::writeLine 
                                  "Calling Snark by evaluating: ") 
                                 nil) 
                             (progn (if SYSTEM-SPEC::specwareDebug? 
                                        (LISP-SPEC::|!PPRINT| snarkEvalForm) 
                                        (LISP-SPEC::|!list| nil)) 
                                    (let ((result 
                                           (LISP-SPEC::|!apply| 
                                            (LISP-SPEC::|!symbol| "CL" "FUNCALL") 
                                            (cons 
                                             (LISP-SPEC::|!list| 
                                              (cons 
                                               (LISP-SPEC::|!symbol| 
                                                "SNARK" 
                                                "LAMBDA") 
                                               (cons 
                                                (LISP-SPEC::|!nil|) 
                                                (cons snarkEvalForm nil)))) 
                                             nil)))) 
                                      (let ((proved 
                                             (string=  
                                              ":PROOF-FOUND" 
                                              (SYSTEM-SPEC::toString result)))) 
                                        proved)))))))))))))) 
   (error "Nonexhaustive match failure in proveForAns")))

(defun SPECCALC::substOpMap (opMap term) 
  (labels 
    ((mapRec (term) (mapT opMap term))
     (mapT (opMap term) 
      (block 
       nil 
       (if (eq (car term) :|Fun|) 
           (let ((pV15 (cdr term))) 
             (let ((pV48 (svref pV15 0))) 
               (progn (if (eq (car pV48) :|Op|) 
                          (let ((pV51 (cdr pV48))) 
                            (return 
                             (let ((newQid 
                                    (POLYMAP::evalPartial-1-1 opMap (car pV51)))) 
                               (block 
                                nil 
                                (if (eq (car newQid) :|Some|) 
                                    (return 
                                     (cons 
                                      :|Fun| 
                                      (vector 
                                       (cons 
                                        :|Op| 
                                        (cons (cdr newQid) (cdr pV51))) 
                                       (svref pV15 1) 
                                       (svref pV15 2)))) 
                                    (if (eq (car newQid) :|None|) (return term))) 
                                (error 
                                 "Nonexhaustive match failure in substOpMap")))))) 
                      (return term)))) 
           (if (eq (car term) :|Var|) 
               (return term) 
               (if (eq (car term) :|Let|) 
                   (let ((pV13 (cdr term))) 
                     (let ((pV42 (svref pV13 1))
                           (pV41 (svref pV13 0))) 
                       (return 
                        (let ((newBdy (mapRec pV42))) 
                          (if (cl:and 
                               (slang-built-in::slang-term-equals pV41 pV41) 
                               (slang-built-in::slang-term-equals pV42 newBdy)) 
                              term 
                              (cons :|Let| (vector pV41 newBdy (svref pV13 2)))))))) 
                   (if (eq (car term) :|LetRec|) 
                       (let ((pV12 (cdr term))) 
                         (let ((pV39 (svref pV12 1))
                               (pV38 (svref pV12 0))) 
                           (return 
                            (let ((newBdy (mapRec pV39))) 
                              (if (cl:and 
                                   (slang-built-in::slang-term-equals pV38 pV38) 
                                   (slang-built-in::slang-term-equals 
                                    pV39 
                                    newBdy)) 
                                  term 
                                  (cons 
                                   :|LetRec| 
                                   (vector pV38 newBdy (svref pV12 2)))))))) 
                       (if (eq (car term) :|Record|) 
                           (let ((pV11 (cdr term))) 
                             (let ((pV36 (car pV11))) 
                               (return 
                                (let ((newRow 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'(lambda (x) 
                                           (cons (car x) (mapRec (cdr x)))) 
                                        pV36))) 
                                  (if (slang-built-in::slang-term-equals 
                                       pV36 
                                       newRow) 
                                      term 
                                      (cons :|Record| (cons newRow (cdr pV11)))))))) 
                           (if (eq (car term) :|IfThenElse|) 
                               (let ((pV10 (cdr term))) 
                                 (let ((pV34 (svref pV10 2))
                                       (pV33 (svref pV10 1))
                                       (pV32 (svref pV10 0))) 
                                   (return 
                                    (let ((newT1 (mapRec pV32))) 
                                      (let ((newT2 (mapRec pV33))) 
                                        (let ((newT3 (mapRec pV34))) 
                                          (if (cl:and 
                                               (slang-built-in::slang-term-equals 
                                                newT1 
                                                pV32) 
                                               (cl:and 
                                                (slang-built-in::slang-term-equals 
                                                 newT2 
                                                 pV33) 
                                                (slang-built-in::slang-term-equals 
                                                 newT3 
                                                 pV34))) 
                                              term 
                                              (cons 
                                               :|IfThenElse| 
                                               (vector 
                                                newT1 
                                                newT2 
                                                newT3 
                                                (svref pV10 3)))))))))) 
                               (if (eq (car term) :|Lambda|) 
                                   (let ((pV9 (cdr term))) 
                                     (let ((pV30 (car pV9))) 
                                       (return 
                                        (let ((|!newMatch| 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'(lambda (x) 
                                                   (vector 
                                                    (svref x 0) 
                                                    (mapRec (svref x 1)) 
                                                    (mapRec (svref x 2)))) 
                                                pV30))) 
                                          (if (slang-built-in::slang-term-equals 
                                               pV30 
                                               |!newMatch|) 
                                              term 
                                              (cons 
                                               :|Lambda| 
                                               (cons |!newMatch| (cdr pV9)))))))) 
                                   (if (eq (car term) :|Bind|) 
                                       (let ((pV8 (cdr term))) 
                                         (let ((pV28 (svref pV8 2))
                                               (pV27 (svref pV8 1))) 
                                           (return 
                                            (let ((newTrm (mapRec pV28))) 
                                              (if (cl:and 
                                                   (slang-built-in::slang-term-equals 
                                                    pV27 
                                                    pV27) 
                                                   (slang-built-in::slang-term-equals 
                                                    pV28 
                                                    newTrm)) 
                                                  term 
                                                  (cons 
                                                   :|Bind| 
                                                   (vector 
                                                    (svref pV8 0) 
                                                    pV27 
                                                    newTrm 
                                                    (svref pV8 3)))))))) 
                                       (if (eq (car term) :|Apply|) 
                                           (let ((pV7 (cdr term))) 
                                             (let ((pV24 (svref pV7 1))
                                                   (pV23 (svref pV7 0))) 
                                               (return 
                                                (let ((newT1 (mapRec pV23))) 
                                                  (let ((newT2 (mapRec pV24))) 
                                                    (if (cl:and 
                                                         (slang-built-in::slang-term-equals 
                                                          newT1 
                                                          pV23) 
                                                         (slang-built-in::slang-term-equals 
                                                          newT2 
                                                          pV24)) 
                                                        term 
                                                        (cons 
                                                         :|Apply| 
                                                         (vector 
                                                          (mapRec newT1) 
                                                          (mapRec newT2) 
                                                          (svref pV7 2))))))))) 
                                           (if (eq (car term) :|Seq|) 
                                               (let ((pV6 (cdr term))) 
                                                 (let ((pV21 (car pV6))) 
                                                   (return 
                                                    (let ((newTerms 
                                                           (LIST-SPEC::|!map|-1-1 
                                                            #'mapRec 
                                                            pV21))) 
                                                      (if (slang-built-in::slang-term-equals 
                                                           newTerms 
                                                           pV21) 
                                                          term 
                                                          (cons 
                                                           :|Seq| 
                                                           (cons 
                                                            newTerms 
                                                            (cdr pV6)))))))) 
                                               (if (eq (car term) :|ApplyN|) 
                                                   (let ((pV5 (cdr term))) 
                                                     (let ((pV19 (car pV5))) 
                                                       (return 
                                                        (let ((newTerms 
                                                               (LIST-SPEC::|!map|-1-1 
                                                                #'mapRec 
                                                                pV19))) 
                                                          (if (slang-built-in::slang-term-equals 
                                                               newTerms 
                                                               pV19) 
                                                              term 
                                                              (cons 
                                                               :|ApplyN| 
                                                               (cons 
                                                                newTerms 
                                                                (cdr pV5)))))))) 
                                                   (if (eq 
                                                        (car term) 
                                                        :|SortedTerm|) 
                                                       (let ((pV4 (cdr term))) 
                                                         (let ((pV17 
                                                                (svref pV4 1))
                                                               (pV16 
                                                                (svref pV4 0))) 
                                                           (return 
                                                            (let ((newTrm 
                                                                   (mapRec pV16))) 
                                                              (if (cl:and 
                                                                   (slang-built-in::slang-term-equals 
                                                                    newTrm 
                                                                    pV16) 
                                                                   (slang-built-in::slang-term-equals 
                                                                    pV17 
                                                                    pV17)) 
                                                                  term 
                                                                  (cons 
                                                                   :|SortedTerm| 
                                                                   (vector 
                                                                    newTrm 
                                                                    pV17 
                                                                    (svref pV4 2)))))))))))))))))))) 
       (error "Nonexhaustive match failure in substOpMap")))) (mapRec term)))

(defun SPECCALC::termOpsInSpec? (term spc) 
  (labels 
    ((mapRec (term) (mapT spc term))
     (mapT (spc term) 
      (block 
       nil 
       (if (eq (car term) :|Fun|) 
           (let ((pV60 (svref (cdr term) 0))) 
             (progn (if (eq (car pV60) :|Op|) 
                        (return 
                         (let ((pV3 
                                (STANDARDSPEC::findTheOp spc (car (cdr pV60))))) 
                           (block 
                            nil 
                            (if (eq (car pV3) :|Some|) (return t)) 
                            (return nil))))) 
                    (return nil))) 
           (if (eq (car term) :|Var|) 
               (return nil) 
               (if (eq (car term) :|Let|) 
                   (return (let ((res (mapRec (svref (cdr term) 1)))) res)) 
                   (if (eq (car term) :|LetRec|) 
                       (return (let ((res (mapRec (svref (cdr term) 1)))) res)) 
                       (if (eq (car term) :|Record|) 
                           (return 
                            (let ((res 
                                   (LIST-SPEC::foldl-1-1-1 
                                    #'(lambda (x) 
                                       (block 
                                        nil 
                                        (return 
                                         (cl:or (cdr x) (mapRec (cdr (car x))))) 
                                        (error 
                                         "Nonexhaustive match failure in termOpsInSpec?"))) 
                                    nil 
                                    (car (cdr term))))) res)) 
                           (if (eq (car term) :|IfThenElse|) 
                               (let ((pV22 (cdr term))) 
                                 (return 
                                  (let ((resT1 (mapRec (svref pV22 0)))) 
                                    (let ((resT2 (mapRec (svref pV22 1)))) 
                                      (let ((resT3 (mapRec (svref pV22 2)))) 
                                        (cl:or resT1 (cl:or resT2 resT3))))))) 
                               (if (eq (car term) :|Lambda|) 
                                   (return 
                                    (let ((resMatch 
                                           (LIST-SPEC::foldl-1-1-1 
                                            #'(lambda (x) 
                                               (block 
                                                nil 
                                                (return 
                                                 (cl:or 
                                                  (cdr x) 
                                                  (mapRec (svref (car x) 2)))) 
                                                (error 
                                                 "Nonexhaustive match failure in termOpsInSpec?"))) 
                                            nil 
                                            (car (cdr term))))) resMatch)) 
                                   (if (eq (car term) :|Bind|) 
                                       (return 
                                        (let ((resTrm 
                                               (mapRec (svref (cdr term) 2)))) 
                                          resTrm)) 
                                       (if (eq (car term) :|Apply|) 
                                           (let ((pV19 (cdr term))) 
                                             (return 
                                              (let ((resT1 
                                                     (mapRec (svref pV19 0)))) 
                                                (let ((resT2 
                                                       (mapRec (svref pV19 1)))) 
                                                  (cl:or resT1 resT2))))) 
                                           (if (eq (car term) :|Seq|) 
                                               (return 
                                                (let ((resTerms 
                                                       (LIST-SPEC::foldl-1-1-1 
                                                        #'(lambda (x) 
                                                           (cl:or 
                                                            (cdr x) 
                                                            (mapRec (car x)))) 
                                                        nil 
                                                        (car (cdr term))))) 
                                                  resTerms)) 
                                               (if (eq (car term) :|ApplyN|) 
                                                   (return 
                                                    (let ((resTerms 
                                                           (LIST-SPEC::foldl-1-1-1 
                                                            #'(lambda (x) 
                                                               (cl:or 
                                                                (cdr x) 
                                                                (mapRec (car x)))) 
                                                            nil 
                                                            (car (cdr term))))) 
                                                      resTerms)) 
                                                   (if (eq 
                                                        (car term) 
                                                        :|SortedTerm|) 
                                                       (return 
                                                        (let ((resTrm 
                                                               (mapRec 
                                                                (svref 
                                                                 (cdr term) 
                                                                 0)))) resTrm)))))))))))))) 
       (error "Nonexhaustive match failure in termOpsInSpec?")))) (mapRec term)))


(defun SPECCALC::extendMorphism (morph base_spc) 
  (let ((dom (svref morph 1))) 
    (let ((opMap (svref morph 2))) 
      (let ((axioms 
             (LIST-SPEC::filter-1-1 
              #'(lambda (x) 
                 (slang-built-in::slang-term-equals (svref x 0) '(:|Axiom|))) 
              (svref dom 2)))) 
        (let ((axiomFmlas 
               (LIST-SPEC::|!map|-1-1 #'(lambda (x) (svref x 3)) axioms))) 
          (let ((newAxiomFmlas 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (fmla) (SPECCALC::substOpMap opMap fmla)) 
                  axiomFmlas))) 
            (let ((incompleteAxioms 
                   (LIST-SPEC::filter-1-1 
                    #'(lambda (fmla) (SPECCALC::termOpsInSpec? fmla dom)) 
                    newAxiomFmlas))) 
              (progn (if SYSTEM-SPEC::specwareDebug? 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (f) (ANNSPECPRINTER::printTermToTerminal f)) 
                          incompleteAxioms) 
                         (cons nil nil)) 
                     (let ((testAxiom (LIST-SPEC::hd incompleteAxioms))) 
                       (progn (if SYSTEM-SPEC::specwareDebug? 
                                  (ANNSPECPRINTER::printTermToTerminal testAxiom) 
                                  nil) 
                              (let ((pV9 (SPECCALC::mkExistential dom testAxiom))) 
                                (block 
                                 nil 
                                 (let ((pV11 (cdr pV9))) 
                                   (return 
                                    (let ((succ 
                                           (SPECCALC::proveForAns 
                                            pV11 
                                            (car pV9) 
                                            (subtractSpec-1-1 
                                             (svref morph 0) 
                                             base_spc) 
                                            (svref base_spc 2) 
                                            base_spc 
                                            (cons (LISP-SPEC::|!list| nil) nil) 
                                            "foo.log"))) 
                                      (if succ 
                                          (SPECCALC::extendMorphismWithAnswer 
                                           morph 
                                           pV11) 
                                          morph)))) 
                                 (error 
                                  "Nonexhaustive match failure in extendMorphism")))))))))))))


(defun SPECCALC::evaluateExtendMorph-1 (term) 
  (SPECCALC::monadBind 
   #'SPECCALC::getCurrentURI-1 
   #'(lambda (uri) 
      (SPECCALC::monadSeq 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          ";;; Extending Morphisms for " 
          (SPECCALC::uriToString-1 uri)) 
         "
")) 
       (SPECCALC::monadBind 
        (SPECCALC::evaluateTermInfo-1 term) 
        #'(lambda (x) 
           (let ((dep_URIs (svref x 2))
                 (time_stamp (svref x 1))
                 (value (svref x 0))) 
             (SPECCALC::monadBind 
              (SPECCALC::pathToRelativeURI "/Library/Base") 
              #'(lambda (base_URI) 
                 (SPECCALC::monadBind 
                  (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                           base_URI) 
                  #'(lambda (x1) 
                     (let ((pV6 (svref x1 0))) 
                       (block 
                        nil 
                        (if (eq (car pV6) :|Spec|) 
                            (return 
                             (block 
                              nil 
                              (if (eq (car value) :|Morph|) 
                                  (return 
                                   (SPECCALC::monadBind 
                                    (SPECCALC::|!return| 
                                     (SPECCALC::extendMorphism 
                                      (cdr value) 
                                      (cdr pV6))) 
                                    #'(lambda (newMorph) 
                                       (SPECCALC::|!return| 
                                        (vector 
                                         (cons 
                                          :|Morph| 
                                          (vector 
                                           (svref newMorph 0) 
                                           (svref newMorph 1) 
                                           (svref newMorph 2) 
                                           (svref newMorph 3))) 
                                         time_stamp 
                                         dep_URIs)))))) 
                              (return 
                               (SPECCALC::raise 
                                (cons 
                                 :|Unsupported| 
                                 (cons 
                                  (SPECCALC::positionOf-1 term) 
                                  "Can only extend Morphisms"))))))) 
                        (error 
                         "Nonexhaustive match failure in evaluateExtendMorph"))))))))))))))


(defun SPECCALC::getURI-1 (term) 
  (let ((pV3 (SPECCALC::valueOf-1 term))) 
    (block 
     nil 
     (if (eq (car pV3) :|URI|) 
         (return 
          (SPECCALC::monadBind 
           (funcall (SPECCALC::evaluateReturnURI (SPECCALC::positionOf-1 term)) 
                    (cdr pV3)) 
           #'(lambda (x) (SPECCALC::|!return| (cdr x)))))) 
     (return #'SPECCALC::getCurrentURI-1))))

(defun SPECCALC::ppJSpecToFile (spc file preamble) 
  (let ((p (JAVA::ppCompUnit-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
      (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble)))))

(defun SPECCALC::toJavaFileEnv (spc file preamble) 
  (progn (STRING-SPEC::writeLine (STRING-SPEC::^ "Writing Java file " file)) 
         (let ((spc (JGEN::specToJava-1 spc))) 
           (SPECCALC::ppJSpecToFile spc file preamble))))

(defun SPECCALC::toJavaFile (spc file preamble) 
  (SPECCALC::toJavaFileEnv spc file preamble))

(defun SPECCALC::evaluateJavaGen (pV11 pV12 pV13) 
  (block 
   nil 
   (let ((pV14 (svref pV11 0))) 
     (if (eq (car pV14) :|Spec|) 
         (let ((pV17 (cdr pV14))) 
           (return 
            (SPECCALC::monadBind 
             (SPECCALC::getURI-1 pV12) 
             #'(lambda (cURI) 
                (SPECCALC::monadBind 
                 (SPECCALC::URItoJavaFile cURI pV13) 
                 #'(lambda (javaFileName) 
                    (SPECCALC::monadBind 
                     (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                              (cons 
                               :|SpecPath_Relative| 
                               (cons 
                                '(:|None|) 
                                (cons "Library" (cons "Base" nil))))) 
                     #'(lambda (x) 
                        (let ((pV7 (svref x 0))) 
                          (block 
                           nil 
                           (if (eq (car pV7) :|Spec|) 
                               (return 
                                (progn (IO-SPEC::ensureDirectoriesExist 
                                        javaFileName) 
                                       (progn (SPECCALC::toJavaFile 
                                               (subtractSpec-1-1 pV17 (cdr pV7)) 
                                               javaFileName 
                                               nil) 
                                              (SPECCALC::monadSeq 
                                               (SPECCALC::|!print| 
                                                "Translated to Java") 
                                               (SPECCALC::|!return| pV11)))))) 
                           (error 
                            "Nonexhaustive match failure in evaluateJavaGen"))))))))))))) 
   (error "Nonexhaustive match failure in evaluateJavaGen")))

(defun SPECTOLISP::genNNames (n) 
  (LIST-SPEC::tabulate 
   n 
   #'(lambda (i) (STRING-SPEC::^ "x" (NAT-SPEC::toString i)))))

(defun SPECTOLISP::countOccurrence2 (x |!count| terms) 
  (block 
   nil 
   (if (null terms) 
       (return |!count|) 
       (if (consp terms) 
           (let ((pV31 (cdr terms))
                 (pV30 (car terms))) 
             (return 
              (block 
               nil 
               (if (eq (car pV30) :|Apply|) 
                   (let ((pV11 (cdr pV30))) 
                     (return 
                      (SPECTOLISP::countOccurrence2 
                       x 
                       |!count| 
                       (cons (car pV11) (LIST-SPEC::|!++| (cdr pV11) pV31))))) 
                   (if (eq (car pV30) :|Lambda|) 
                       (let ((pV10 (cdr pV30))) 
                         (return 
                          (if (cl:or 
                               (LIST-SPEC::|!member| x (svref pV10 0)) 
                               ( =  
                                (SPECTOLISP::countOccurrence2 
                                 x 
                                 0 
                                 (cons (svref pV10 2) nil)) 
                                0)) 
                              (SPECTOLISP::countOccurrence2 x |!count| pV31) 
                              2))) 
                       (if (eq (car pV30) :|Letrec|) 
                           (let ((pV9 (cdr pV30))) 
                             (let ((pV22 (svref pV9 2))) 
                               (return 
                                (if (cl:or 
                                     (LIST-SPEC::|!member| x (svref pV9 0)) 
                                     ( =  
                                      (SPECTOLISP::countOccurrence2 
                                       x 
                                       0 
                                       (cons pV22 nil)) 
                                      0)) 
                                    (SPECTOLISP::countOccurrence2 
                                     x 
                                     |!count| 
                                     (LIST-SPEC::|!cons| 
                                      pV22 
                                      (LIST-SPEC::|!++| (svref pV9 1) pV31))) 
                                    2)))) 
                           (if (eq (car pV30) :|Let|) 
                               (let ((pV8 (cdr pV30))) 
                                 (return 
                                  (SPECTOLISP::countOccurrence2 
                                   x 
                                   |!count| 
                                   (LIST-SPEC::|!cons| 
                                    (svref pV8 2) 
                                    (LIST-SPEC::|!++| (svref pV8 1) pV31))))) 
                               (if (eq (car pV30) :|If|) 
                                   (let ((pV7 (cdr pV30))) 
                                     (return 
                                      (SPECTOLISP::countOccurrence2 
                                       x 
                                       |!count| 
                                       (LIST-SPEC::|!++| 
                                        (cons 
                                         (svref pV7 0) 
                                         (cons 
                                          (svref pV7 1) 
                                          (cons (svref pV7 2) nil))) 
                                        pV31)))) 
                                   (if (eq (car pV30) :|IfThen|) 
                                       (let ((pV6 (cdr pV30))) 
                                         (return 
                                          (SPECTOLISP::countOccurrence2 
                                           x 
                                           |!count| 
                                           (LIST-SPEC::|!++| 
                                            (cons (car pV6) (cons (cdr pV6) nil)) 
                                            pV31)))) 
                                       (if (eq (car pV30) :|Seq|) 
                                           (return 
                                            (SPECTOLISP::countOccurrence2 
                                             x 
                                             |!count| 
                                             (LIST-SPEC::|!++| (cdr pV30) pV31))) 
                                           (if (eq (car pV30) :|Var|) 
                                               (return 
                                                (if (string=  x (cdr pV30)) 
                                                    (if (INTEGER-SPEC::|!>| 
                                                         |!count| 
                                                         0) 
                                                        2 
                                                        (SPECTOLISP::countOccurrence2 
                                                         x 
                                                         (INTEGER-SPEC::|!+| 
                                                          |!count| 
                                                          1) 
                                                         pV31)) 
                                                    (SPECTOLISP::countOccurrence2 
                                                     x 
                                                     |!count| 
                                                     pV31))))))))))) 
               (return (SPECTOLISP::countOccurrence2 x |!count| pV31))))))) 
   (error "Nonexhaustive match failure in countOccurrence2")))

(defun SPECTOLISP::pV? (var_name) 
  (let ((pV2 (STRING-SPEC::explode var_name))) 
    (block 
     nil 
     (if (consp pV2) 
         (let ((pV5 (cdr pV2))) 
           (if (eq #\p (car pV2)) 
               (if (consp pV5) 
                   (if (eq #\V (car pV5)) 
                       (return (LIST-SPEC::all-1-1 #'CHAR-SPEC::isNum (cdr pV5)))))))) 
     (return nil))))

(defun SPECTOLISP::pure (term) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (return t) 
       (if (eq (car term) :|Const|) 
           (return t) 
           (if (eq (car term) :|Op|) 
               (return t) 
               (if (eq (car term) :|Lambda|) 
                   (return t) 
                   (if (eq (car term) :|Apply|) 
                       (let ((pV7 (cdr term))) 
                         (let ((pV13 (cdr pV7))
                               (pV12 (car pV7))) 
                           (if (eq (car pV12) :|Op|) 
                               (let ((pV14 (cdr pV12))) 
                                 (if (string=  "cdr" pV14) 
                                     (return 
                                      (LIST-SPEC::all-1-1 
                                       #'SPECTOLISP::pure 
                                       pV13)) 
                                     (if (string=  "car" pV14) 
                                         (return 
                                          (LIST-SPEC::all-1-1 
                                           #'SPECTOLISP::pure 
                                           pV13)) 
                                         (if (string=  "svref" pV14) 
                                             (return 
                                              (LIST-SPEC::all-1-1 
                                               #'SPECTOLISP::pure 
                                               pV13)) 
                                             (if (string=  "vector" pV14) 
                                                 (return 
                                                  (LIST-SPEC::all-1-1 
                                                   #'SPECTOLISP::pure 
                                                   pV13)) 
                                                 (if (string=  "cons" pV14) 
                                                     (return 
                                                      (LIST-SPEC::all-1-1 
                                                       #'SPECTOLISP::pure 
                                                       pV13)))))))))))))))) 
   (return nil)))

(defun SPECTOLISP::simpleTerm (term) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (return t) 
       (if (eq (car term) :|Const|) 
           (return t) 
           (if (eq (car term) :|Op|) (return t)))) 
   (return nil)))

(defun SPECTOLISP::getNames (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV14 (cdr term))) 
         (return 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) 
              (LIST-SPEC::|!++| (SPECTOLISP::getNames (car x)) (cdr x))) 
           (SPECTOLISP::getNames (car pV14)) 
           (cdr pV14)))) 
       (if (eq (car term) :|Lambda|) 
           (let ((pV13 (cdr term))) 
             (return 
              (LIST-SPEC::|!++| 
               (svref pV13 0) 
               (SPECTOLISP::getNames (svref pV13 2))))) 
           (if (eq (car term) :|Op|) 
               (return (cons (cdr term) nil)) 
               (if (eq (car term) :|Var|) 
                   (return (cons (cdr term) nil)) 
                   (if (eq (car term) :|Const|) 
                       (return nil) 
                       (if (eq (car term) :|If|) 
                           (let ((pV9 (cdr term))) 
                             (return 
                              (LIST-SPEC::|!++| 
                               (LIST-SPEC::|!++| 
                                (SPECTOLISP::getNames (svref pV9 0)) 
                                (SPECTOLISP::getNames (svref pV9 1))) 
                               (SPECTOLISP::getNames (svref pV9 2))))) 
                           (if (eq (car term) :|IfThen|) 
                               (let ((pV8 (cdr term))) 
                                 (return 
                                  (LIST-SPEC::|!++| 
                                   (SPECTOLISP::getNames (car pV8)) 
                                   (SPECTOLISP::getNames (cdr pV8))))) 
                               (if (eq (car term) :|Let|) 
                                   (let ((pV7 (cdr term))) 
                                     (return 
                                      (LIST-SPEC::|!++| 
                                       (LIST-SPEC::|!++| 
                                        (svref pV7 0) 
                                        (LIST-SPEC::flatten 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'SPECTOLISP::getNames 
                                          (svref pV7 1)))) 
                                       (SPECTOLISP::getNames (svref pV7 2))))) 
                                   (if (eq (car term) :|Letrec|) 
                                       (let ((pV6 (cdr term))) 
                                         (return 
                                          (LIST-SPEC::|!++| 
                                           (LIST-SPEC::|!++| 
                                            (svref pV6 0) 
                                            (LIST-SPEC::flatten 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'SPECTOLISP::getNames 
                                              (svref pV6 1)))) 
                                           (SPECTOLISP::getNames (svref pV6 2))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (return 
                                            (LIST-SPEC::flatten 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'SPECTOLISP::getNames 
                                              (cdr term)))))))))))))) 
   (return (SYSTEM-SPEC::fail "Unexpected term in getNames"))))

(defun SPECTOLISP::newName (name names) 
  (labels 
    ((|!loop| (i) 
      (let ((n (STRING-SPEC::^ name (NAT-SPEC::toString i)))) 
        (if (LIST-SPEC::|!exists|-1-1 #'(lambda (m) (string=  n m)) names) 
            (|!loop| (INTEGER-SPEC::|!+| i 1)) 
            n)))) (|!loop| 1)))

(defun SPECTOLISP::rename (pV1 pV2) 
  (block 
   nil 
   (let ((pV5 (svref pV2 2))
         (pV4 (svref pV2 1))
         (pV3 (svref pV2 0))) 
     (return 
      (if (LIST-SPEC::|!exists|-1-1 #'(lambda (n) (string=  n pV1)) pV4) 
          (let ((n (SPECTOLISP::newName pV1 pV4))) 
            (let ((body 
                   (SPECTOLISP::|!substitute|-1-1 
                    (cons pV1 (LISTADT::mkLVar n)) 
                    pV5))) 
              (vector (LIST-SPEC::|!cons| n pV3) (LIST-SPEC::|!cons| n pV4) body))) 
          (vector (LIST-SPEC::|!cons| pV1 pV3) pV4 pV5)))) 
   (error "Nonexhaustive match failure in rename")))

(defun SPECTOLISP::rename-1 (x) (SPECTOLISP::rename (car x) (cdr x)))

(defun SPECTOLISP::|!substitute|-1 (x1) 
  #'(lambda (x2) (SPECTOLISP::|!substitute|-1-1 x1 x2)))

(defun SPECTOLISP::|!substitute| (x0 x1) 
  (SPECTOLISP::|!substitute|-1 (cons x0 x1)))

(defun SPECTOLISP::rename2 (pV1 pV2) 
  (block 
   nil 
   (let ((pV6 (svref pV2 3))
         (pV5 (svref pV2 2))
         (pV4 (svref pV2 1))
         (pV3 (svref pV2 0))) 
     (return 
      (if (LIST-SPEC::|!exists|-1-1 #'(lambda (n) (string=  n pV1)) pV5) 
          (let ((n (SPECTOLISP::newName pV1 pV5))) 
            (let ((body 
                   (SPECTOLISP::|!substitute|-1-1 
                    (cons pV1 (LISTADT::mkLVar n)) 
                    pV6))) 
              (let ((terms 
                     (LIST-SPEC::|!map|-1-1 
                      (SPECTOLISP::|!substitute| pV1 (LISTADT::mkLVar n)) 
                      pV4))) 
                (vector 
                 (LIST-SPEC::|!cons| n pV3) 
                 terms 
                 (LIST-SPEC::|!cons| n pV5) 
                 body)))) 
          (vector (LIST-SPEC::|!cons| pV1 pV3) pV4 pV5 pV6)))) 
   (error "Nonexhaustive match failure in rename2")))

(defun SPECTOLISP::rename2-1 (x) (SPECTOLISP::rename2 (car x) (cdr x)))

(defun SPECTOLISP::|!substitute|-1-1 (!x1 body) 
  (let ((arg (cdr !x1))
        (x (car !x1))) 
    (block 
     nil 
     (if (eq (car body) :|Apply|) 
         (let ((pV23 (cdr body))) 
           (return 
            (cons 
             :|Apply| 
             (cons 
              (SPECTOLISP::|!substitute|-1-1 (cons x arg) (car pV23)) 
              (LIST-SPEC::|!map|-1-1 
               (SPECTOLISP::|!substitute| x arg) 
               (cdr pV23)))))) 
         (if (eq (car body) :|Lambda|) 
             (let ((pV22 (cdr body))) 
               (let ((pV35 (svref pV22 0))
                     (pV36 (svref pV22 1))
                     (pV37 (svref pV22 2))) 
                 (return 
                  (if (LIST-SPEC::|!exists|-1-1 
                       #'(lambda (v) (string=  x v)) 
                       pV35) 
                      (LISTADT::mkLLambda pV35 pV36 pV37) 
                      (let ((names (SPECTOLISP::getNames arg))) 
                        (let ((pV1 
                               (LIST-SPEC::foldr-1-1-1 
                                #'SPECTOLISP::rename-1 
                                (vector nil names pV37) 
                                pV35))) 
                          (block 
                           nil 
                           (return 
                            (LISTADT::mkLLambda 
                             (svref pV1 0) 
                             pV36 
                             (SPECTOLISP::|!substitute|-1-1 
                              (cons x arg) 
                              (svref pV1 2)))) 
                           (error "Nonexhaustive match failure in substitute")))))))) 
             (if (eq (car body) :|Var|) 
                 (let ((pV21 (cdr body))) 
                   (return (if (string=  x pV21) arg (LISTADT::mkLVar pV21)))) 
                 (if (eq (car body) :|Let|) 
                     (let ((pV20 (cdr body))) 
                       (let ((pV32 (svref pV20 0))
                             (pV33 (svref pV20 1))
                             (pV34 (svref pV20 2))) 
                         (return 
                          (if (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (v) (string=  x v)) 
                               pV32) 
                              (LISTADT::mkLLet 
                               pV32 
                               (LIST-SPEC::|!map|-1-1 
                                (SPECTOLISP::|!substitute| x arg) 
                                pV33) 
                               pV34) 
                              (let ((terms 
                                     (LIST-SPEC::|!map|-1-1 
                                      (SPECTOLISP::|!substitute| x arg) 
                                      pV33))) 
                                (let ((names (SPECTOLISP::getNames arg))) 
                                  (let ((pV5 
                                         (LIST-SPEC::foldr-1-1-1 
                                          #'SPECTOLISP::rename-1 
                                          (vector nil names pV34) 
                                          pV32))) 
                                    (block 
                                     nil 
                                     (return 
                                      (LISTADT::mkLLet 
                                       (svref pV5 0) 
                                       terms 
                                       (SPECTOLISP::|!substitute|-1-1 
                                        (cons x arg) 
                                        (svref pV5 2)))) 
                                     (error 
                                      "Nonexhaustive match failure in substitute"))))))))) 
                     (if (eq (car body) :|Letrec|) 
                         (let ((pV19 (cdr body))) 
                           (let ((pV29 (svref pV19 0))
                                 (pV30 (svref pV19 1))
                                 (pV31 (svref pV19 2))) 
                             (return 
                              (if (LIST-SPEC::|!exists|-1-1 
                                   #'(lambda (v) (string=  x v)) 
                                   pV29) 
                                  (LISTADT::mkLLetRec pV29 pV30 pV31) 
                                  (let ((names (SPECTOLISP::getNames arg))) 
                                    (let ((terms 
                                           (LIST-SPEC::|!map|-1-1 
                                            (SPECTOLISP::|!substitute| x arg) 
                                            pV30))) 
                                      (let ((pV9 
                                             (LIST-SPEC::foldr-1-1-1 
                                              #'SPECTOLISP::rename2-1 
                                              (vector nil terms names pV31) 
                                              pV29))) 
                                        (block 
                                         nil 
                                         (return 
                                          (LISTADT::mkLLetRec 
                                           (svref pV9 0) 
                                           (svref pV9 1) 
                                           (SPECTOLISP::|!substitute|-1-1 
                                            (cons x arg) 
                                            (svref pV9 3)))) 
                                         (error 
                                          "Nonexhaustive match failure in substitute"))))))))) 
                         (if (eq (car body) :|If|) 
                             (let ((pV18 (cdr body))) 
                               (return 
                                (LISTADT::mkLIf 
                                 (SPECTOLISP::|!substitute|-1-1 
                                  (cons x arg) 
                                  (svref pV18 0)) 
                                 (SPECTOLISP::|!substitute|-1-1 
                                  (cons x arg) 
                                  (svref pV18 1)) 
                                 (SPECTOLISP::|!substitute|-1-1 
                                  (cons x arg) 
                                  (svref pV18 2))))) 
                             (if (eq (car body) :|IfThen|) 
                                 (let ((pV17 (cdr body))) 
                                   (return 
                                    (cons 
                                     :|IfThen| 
                                     (cons 
                                      (SPECTOLISP::|!substitute|-1-1 
                                       (cons x arg) 
                                       (car pV17)) 
                                      (SPECTOLISP::|!substitute|-1-1 
                                       (cons x arg) 
                                       (cdr pV17)))))) 
                                 (if (eq (car body) :|Seq|) 
                                     (return 
                                      (LISTADT::mkLSeq 
                                       (LIST-SPEC::|!map|-1-1 
                                        (SPECTOLISP::|!substitute| x arg) 
                                        (cdr body)))))))))))) 
     (return body))))

(defun SPECTOLISP::reduceTerm (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV24 (cdr term))) 
         (let ((pV40 (cdr pV24))
               (pV39 (car pV24))) 
           (progn (if (eq (car pV39) :|Lambda|) 
                      (let ((pV41 (cdr pV39))) 
                        (return 
                         (SPECTOLISP::reduceTerm 
                          (cons 
                           :|Let| 
                           (vector (svref pV41 0) pV40 (svref pV41 2))))))) 
                  (return 
                   (let ((term1 (SPECTOLISP::reduceTerm pV39))) 
                     (let ((terms 
                            (LIST-SPEC::|!map|-1-1 #'SPECTOLISP::reduceTerm pV40))) 
                       (LISTADT::mkLApply term1 terms))))))) 
       (if (eq (car term) :|Lambda|) 
           (let ((pV23 (cdr term))) 
             (let ((pV37 (svref pV23 1))
                   (pV36 (svref pV23 0))) 
               (return 
                (let ((reduced_body (SPECTOLISP::reduceTerm (svref pV23 2)))) 
                  (let ((unused_pv_vars 
                         (LIST-SPEC::foldr-1-1-1 
                          #'(lambda (x) 
                             (let ((unused_vars (cdr x))
                                   (var_name (car x))) 
                               (if (cl:and 
                                    (SPECTOLISP::pV? var_name) 
                                    ( =  
                                     (SPECTOLISP::countOccurrence2 
                                      var_name 
                                      0 
                                      (cons reduced_body nil)) 
                                     0)) 
                                   (LIST-SPEC::|!cons| var_name unused_vars) 
                                   unused_vars))) 
                          nil 
                          pV36))) 
                    (let ((augmented_decls 
                           (block 
                            nil 
                            (if (null unused_pv_vars) (return pV37)) 
                            (return 
                             (LIST-SPEC::|!cons| 
                              (cons :|Ignore| unused_pv_vars) 
                              pV37))))) 
                      (LISTADT::mkLLambda pV36 augmented_decls reduced_body))))))) 
           (if (eq (car term) :|Let|) 
               (let ((pV22 (cdr term))) 
                 (return 
                  (let ((body (SPECTOLISP::reduceTerm (svref pV22 2)))) 
                    (let ((args 
                           (LIST-SPEC::|!map|-1-1 
                            #'SPECTOLISP::reduceTerm 
                            (svref pV22 1)))) 
                      (let ((xArgs (LISTPAIR::zip (svref pV22 0) args))) 
                        (let ((terms (LIST-SPEC::|!cons| body args))) 
                          (let ((xNumArgs 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x) 
                                     (let ((arg (cdr x))
                                           (x1 (car x))) 
                                       (if (SPECTOLISP::simpleTerm arg) 
                                           (vector 
                                            x1 
                                            (SPECTOLISP::countOccurrence2 
                                             x1 
                                             0 
                                             args) 
                                            nil 
                                            arg) 
                                           (if (SPECTOLISP::pure arg) 
                                               (vector 
                                                x1 
                                                (SPECTOLISP::countOccurrence2 
                                                 x1 
                                                 0 
                                                 terms) 
                                                nil 
                                                arg) 
                                               (if (INTEGER-SPEC::|!>| 
                                                    (SPECTOLISP::countOccurrence2 
                                                     x1 
                                                     0 
                                                     terms) 
                                                    0) 
                                                   (vector x1 2 nil arg) 
                                                   (vector x1 2 t arg)))))) 
                                  xArgs))) 
                            (let ((pV13 
                                   (LIST-SPEC::foldr-1-1-1 
                                    #'(lambda (x) 
                                       (let ((pV5 (cdr x))
                                             (pV4 (car x))) 
                                         (block 
                                          nil 
                                          (let ((pV9 (svref pV4 3))
                                                (pV6 (svref pV4 0))) 
                                            (let ((pV12 (svref pV5 2))
                                                  (pV11 (svref pV5 1))
                                                  (pV10 (svref pV5 0))) 
                                              (return 
                                               (if (INTEGER-SPEC::|!<| 
                                                    (svref pV4 1) 
                                                    2) 
                                                   (vector 
                                                    pV10 
                                                    pV11 
                                                    (SPECTOLISP::|!substitute|-1-1 
                                                     (cons pV6 pV9) 
                                                     pV12)) 
                                                   (if (svref pV4 2) 
                                                       (vector 
                                                        pV10 
                                                        pV11 
                                                        (LISTADT::mkLSeq 
                                                         (cons 
                                                          pV9 
                                                          (cons pV12 nil)))) 
                                                       (vector 
                                                        (LIST-SPEC::|!cons| 
                                                         pV6 
                                                         pV10) 
                                                        (LIST-SPEC::|!cons| 
                                                         pV9 
                                                         pV11) 
                                                        pV12)))))) 
                                          (error 
                                           "Nonexhaustive match failure in reduceTerm")))) 
                                    (vector nil nil body) 
                                    xNumArgs))) 
                              (block 
                               nil 
                               (return 
                                (LISTADT::mkLLet 
                                 (LIST-SPEC::rev (svref pV13 0)) 
                                 (LIST-SPEC::rev (svref pV13 1)) 
                                 (svref pV13 2))) 
                               (error 
                                "Nonexhaustive match failure in reduceTerm")))))))))) 
               (if (eq (car term) :|Letrec|) 
                   (let ((pV21 (cdr term))) 
                     (return 
                      (LISTADT::mkLLetRec 
                       (svref pV21 0) 
                       (LIST-SPEC::|!map|-1-1 
                        #'SPECTOLISP::reduceTerm 
                        (svref pV21 1)) 
                       (SPECTOLISP::reduceTerm (svref pV21 2))))) 
                   (if (eq (car term) :|If|) 
                       (let ((pV20 (cdr term))) 
                         (return 
                          (LISTADT::mkLIf 
                           (SPECTOLISP::reduceTerm (svref pV20 0)) 
                           (SPECTOLISP::reduceTerm (svref pV20 1)) 
                           (SPECTOLISP::reduceTerm (svref pV20 2))))) 
                       (if (eq (car term) :|IfThen|) 
                           (let ((pV19 (cdr term))) 
                             (return 
                              (cons 
                               :|IfThen| 
                               (cons 
                                (SPECTOLISP::reduceTerm (car pV19)) 
                                (SPECTOLISP::reduceTerm (cdr pV19)))))) 
                           (if (eq (car term) :|Seq|) 
                               (return 
                                (LISTADT::mkLSeq 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'SPECTOLISP::reduceTerm 
                                  (cdr term))))))))))) 
   (return term)))

(defun SPECTOLISP::defAliasFn (name n) 
  (let ((vnames (SPECTOLISP::genNNames n))) 
    (SPECTOLISP::reduceTerm 
     (LISTADT::mkLLambda 
      vnames 
      nil 
      (LISTADT::mkLApply 
       (LISTADT::mkLOp name) 
       (LIST-SPEC::|!map|-1-1 #'LISTADT::mkLVar vnames))))))

(defun SPECTOLISP::defCurryByUncurry (name n) 
  (labels 
    ((auxRec (i args) 
      (if (INTEGER-SPEC::|!>| i n) 
          (LISTADT::mkLApply (LISTADT::mkLOp name) args) 
          (let ((vn (STRING-SPEC::^ "x" (NAT-SPEC::toString i)))) 
            (SPECTOLISP::reduceTerm 
             (LISTADT::mkLLambda 
              (cons vn nil) 
              nil 
              (auxRec 
               (INTEGER-SPEC::|!+| i 1) 
               (LIST-SPEC::|!++| args (cons (LISTADT::mkLVar vn) nil))))))))) 
    (auxRec 1 nil)))

(defun SPECTOLISP::mkLispTuple (valTms) 
  (block 
   nil 
   (if (null valTms) 
       (return (LISTADT::mkLBool nil)) 
       (if (consp valTms) 
           (let ((pV7 (cdr valTms))) 
             (if (consp pV7) 
                 (if (null (cdr pV7)) 
                     (return (LISTADT::mkLApply (LISTADT::mkLOp "cons") valTms))))))) 
   (return (LISTADT::mkLApply (LISTADT::mkLOp "vector") valTms))))

(defun SPECTOLISP::defNaryByUnary (name n) 
  (let ((vnames (SPECTOLISP::genNNames n))) 
    (SPECTOLISP::reduceTerm 
     (LISTADT::mkLLambda 
      vnames 
      nil 
      (LISTADT::mkLApply 
       (LISTADT::mkLOp name) 
       (cons 
        (SPECTOLISP::mkLispTuple 
         (LIST-SPEC::|!map|-1-1 #'LISTADT::mkLVar vnames)) 
        nil))))))

(defun SPECTOLISP::nTupleDerefs (n vr) 
  (if ( =  n 2) 
      (cons 
       (LISTADT::mkLApply (LISTADT::mkLOp "car") (cons vr nil)) 
       (cons (LISTADT::mkLApply (LISTADT::mkLOp "cdr") (cons vr nil)) nil)) 
      (LIST-SPEC::tabulate 
       n 
       #'(lambda (i) 
          (LISTADT::mkLApply 
           (LISTADT::mkLOp "svref") 
           (cons vr (cons (LISTADT::mkLNat i) nil)))))))

(defun SPECTOLISP::defUnaryByNary (name n) 
  (SPECTOLISP::reduceTerm 
   (LISTADT::mkLLambda 
    (cons (if ( =  n 0) "ignore" "x") nil) 
    (if ( =  n 0) (cons (cons :|Ignore| (cons "ignore" nil)) nil) nil) 
    (LISTADT::mkLApply 
     (LISTADT::mkLOp name) 
     (SPECTOLISP::nTupleDerefs n (LISTADT::mkLVar "x"))))))

(defun SPECTOLISP::defUncurryByUnary (name n) 
  (labels 
    ((auxRec (i args bod) 
      (if (INTEGER-SPEC::|!>| i n) 
          (SPECTOLISP::reduceTerm (LISTADT::mkLLambda args nil bod)) 
          (let ((vn (STRING-SPEC::^ "x" (NAT-SPEC::toString i)))) 
            (auxRec 
             (INTEGER-SPEC::|!+| i 1) 
             (LIST-SPEC::|!++| args (cons vn nil)) 
             (LISTADT::mkLApply bod (cons (LISTADT::mkLVar vn) nil))))))) 
    (auxRec 1 nil (LISTADT::mkLOp name))))

(defparameter SPECTOLISP::defaultSpecwarePackage "SW-USER")

(defun SPECTOLISP::initializeSpecId () 
  (progn (STATE::|:=| SPECTOLISP::userStrings STRINGSET::empty) 
         (STATE::|:=| SPECTOLISP::userUpper STRINGSET::empty)))

(defun SPECTOLISP::flattenFailWith (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV10 (cdr term))) 
         (let ((pV12 (svref pV10 1))
               (pV11 (svref pV10 0))) 
           (if (eq (car pV11) :|Fun|) 
               (let ((pV15 (svref (cdr pV11) 0))) 
                 (if (eq (car pV15) :|Op|) 
                     (let ((pV19 (car (cdr pV15)))) 
                       (if (eq (car pV19) :|Qualified|) 
                           (let ((pV21 (cdr pV19))) 
                             (if (string=  "TranslationBuiltIn" (car pV21)) 
                                 (if (string=  "failWith" (cdr pV21)) 
                                     (if (eq (car pV12) :|Record|) 
                                         (let ((pV25 (car (cdr pV12)))) 
                                           (if (consp pV25) 
                                               (let ((pV29 (cdr pV25))) 
                                                 (if (consp pV29) 
                                                     (if (null (cdr pV29)) 
                                                         (return 
                                                          (LIST-SPEC::|!++| 
                                                           (SPECTOLISP::flattenFailWith 
                                                            (cdr (car pV25))) 
                                                           (SPECTOLISP::flattenFailWith 
                                                            (cdr (car pV29)))))))))))))))))))))) 
   (return (cons term nil))))

(defun SPECTOLISP::lispBlock (sp dpn vars term) 
  (let ((terms (SPECTOLISP::flattenFailWith term))) 
    (let ((terms 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (term) (SPECTOLISP::blockAtom sp dpn vars term)) 
            terms))) (LISTADT::mkLSeq terms))))

(defun SPECTOLISP::patternName (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) (return (car (car (cdr pattern))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      "SpecToLisp.patternName " 
      (ANNSPECPRINTER::printPattern pattern))))))

(defun SPECTOLISP::blockAtom (sp dpn vars term) 
  (block 
   nil 
   (if (eq (car term) :|IfThenElse|) 
       (let ((pV29 (cdr term))) 
         (let ((pV53 (svref pV29 2))
               (pV52 (svref pV29 1))
               (pV51 (svref pV29 0))) 
           (progn (if (eq (car pV53) :|Fun|) 
                      (let ((pV56 (svref (cdr pV53) 0))) 
                        (if (eq (car pV56) :|Op|) 
                            (let ((pV60 (car (cdr pV56)))) 
                              (if (eq (car pV60) :|Qualified|) 
                                  (let ((pV62 (cdr pV60))) 
                                    (if (string=  
                                         "TranslationBuiltIn" 
                                         (car pV62)) 
                                        (if (string=  "mkBreak" (cdr pV62)) 
                                            (return 
                                             (cons 
                                              :|IfThen| 
                                              (cons 
                                               (SPECTOLISP::mkLTerm 
                                                sp 
                                                dpn 
                                                vars 
                                                pV51) 
                                               (SPECTOLISP::blockAtom 
                                                sp 
                                                dpn 
                                                vars 
                                                pV52)))))))))))) 
                  (return 
                   (cons 
                    :|If| 
                    (vector 
                     (SPECTOLISP::mkLTerm sp dpn vars pV51) 
                     (SPECTOLISP::blockAtom sp dpn vars pV52) 
                     (SPECTOLISP::blockAtom sp dpn vars pV53))))))) 
       (if (eq (car term) :|Let|) 
           (let ((pV28 (cdr term))) 
             (return 
              (let ((pV7 (LISTPAIR::unzip (svref pV28 0)))) 
                (block 
                 nil 
                 (return 
                  (let ((names 
                         (LIST-SPEC::|!map|-1-1 
                          #'SPECTOLISP::patternName 
                          (car pV7)))) 
                    (let ((names 
                           (LIST-SPEC::|!map|-1-1 #'SPECTOLISP::specId names))) 
                      (LISTADT::mkLLet 
                       names 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (|!t|) (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                        (cdr pV7)) 
                       (SPECTOLISP::blockAtom 
                        sp 
                        dpn 
                        (STRINGSET::addList vars names) 
                        (svref pV28 1)))))) 
                 (error "Nonexhaustive match failure in blockAtom"))))) 
           (if (eq (car term) :|Apply|) 
               (let ((pV27 (cdr term))) 
                 (let ((pV31 (svref pV27 1))
                       (pV30 (svref pV27 0))) 
                   (if (eq (car pV30) :|Fun|) 
                       (let ((pV34 (svref (cdr pV30) 0))) 
                         (if (eq (car pV34) :|Op|) 
                             (let ((pV38 (car (cdr pV34)))) 
                               (if (eq (car pV38) :|Qualified|) 
                                   (let ((pV40 (cdr pV38))) 
                                     (let ((pV42 (cdr pV40))) 
                                       (if (string=  
                                            "TranslationBuiltIn" 
                                            (car pV40)) 
                                           (if (string=  "mkSuccess" pV42) 
                                               (return 
                                                (LISTADT::mkLApply 
                                                 (LISTADT::mkLOp "return") 
                                                 (cons 
                                                  (SPECTOLISP::mkLTerm 
                                                   sp 
                                                   dpn 
                                                   vars 
                                                   pV31) 
                                                  nil))) 
                                               (if (string=  "mkFail" pV42) 
                                                   (if (eq (car pV31) :|Fun|) 
                                                       (let ((pV44 
                                                              (svref 
                                                               (cdr pV31) 
                                                               0))) 
                                                         (if (eq 
                                                              (car pV44) 
                                                              :|String|) 
                                                             (return 
                                                              (LISTADT::mkLApply 
                                                               (LISTADT::mkLOp 
                                                                "error") 
                                                               (cons 
                                                                (LISTADT::mkLString 
                                                                 (cdr pV44)) 
                                                                nil)))))) 
                                                   (if (string=  "failWith" pV42) 
                                                       (return 
                                                        (SPECTOLISP::lispBlock 
                                                         sp 
                                                         dpn 
                                                         vars 
                                                         term)))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ "Unexpected atom " (ANNSPECPRINTER::printTerm term))))))

(defun SPECTOLISP::mkLPackageId (id) 
  (if (string=  id METASLANG::UnQualified) 
      SPECTOLISP::defaultSpecwarePackage 
      (let ((id (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase id))) 
        (if (SPECTOLISP::isLispString id) (STRING-SPEC::^ id "-SPEC") id))))

(defun SPECTOLISP::printPackageId (id defPkgNm) 
  (block 
   nil 
   (if (eq (car id) :|Qualified|) 
       (let ((pV2 (cdr id))) 
         (let ((pV4 (cdr pV2))
               (pV3 (car pV2))) 
           (progn (if (string=  "System" pV3) 
                      (if (string=  "time" pV4) (return "time"))) 
                  (return 
                   (let ((pkg (SPECTOLISP::mkLPackageId pV3))) 
                     (if (string=  pkg defPkgNm) 
                         (SPECTOLISP::specId pV4) 
                         (STRING-SPEC::^ 
                          (STRING-SPEC::^ pkg "::") 
                          (SPECTOLISP::specId pV4))))))))) 
   (error "Nonexhaustive match failure in printPackageId")))

(defun SPECTOLISP::duplicateString (n s) 
  (block 
   nil 
   (if ( =  0 n) (return "")) 
   (return 
    (STRING-SPEC::^ s (SPECTOLISP::duplicateString (INTEGER-SPEC::|!-| n 1) s)))))


(defun SPECTOLISP::unCurryName (name n) 
  (STRING-SPEC::^ name (SPECTOLISP::duplicateString n "-1")))

(defun SPECTOLISP::fullCurriedApplication (sp dpn vars term) 
  (labels 
    ((aux (term i args) 
      (block 
       nil 
       (if (eq (car term) :|Fun|) 
           (let ((pV7 (cdr term))) 
             (let ((pV11 (svref pV7 0))) 
               (if (eq (car pV11) :|Op|) 
                   (return 
                    (if (cl:and 
                         (INTEGER-SPEC::|!>| i 1) 
                         ( =  i (SPECTOLISP::curryShapeNum sp (svref pV7 1)))) 
                        (cons 
                         :|Some| 
                         (LISTADT::mkLApply 
                          (LISTADT::mkLOp 
                           (SPECTOLISP::unCurryName 
                            (SPECTOLISP::printPackageId (car (cdr pV11)) dpn) 
                            i)) 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (|!t|) 
                              (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                           args))) 
                        '(:|None|)))))) 
           (if (eq (car term) :|Apply|) 
               (let ((pV6 (cdr term))) 
                 (return 
                  (aux 
                   (svref pV6 0) 
                   (INTEGER-SPEC::|!+| i 1) 
                   (LIST-SPEC::|!cons| (svref pV6 1) args)))))) 
       (return '(:|None|))))) (aux term 0 nil)))

(defun SPECENVIRONMENT::arrow (sp srt) 
  (let ((pV3 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|Arrow|) 
         (let ((pV4 (cdr pV3))) (return (cons (svref pV4 0) (svref pV4 1))))) 
     (return (SYSTEM-SPEC::fail "Could not get function space sort")))))

(defun SPECENVIRONMENT::domain (sp srt) 
  (let ((pV2 (SPECENVIRONMENT::arrow sp srt))) 
    (block 
     nil 
     (return (car pV2)) 
     (error "Nonexhaustive match failure in domain"))))

(defun SPECENVIRONMENT::range (sp srt) 
  (let ((pV2 (SPECENVIRONMENT::arrow sp srt))) 
    (block nil (return (cdr pV2)) (error "Nonexhaustive match failure in range"))))


(defparameter SPECTOLISP::compareSymbols (LISTADT::mkLOp "eq"))

(defun SPECTOLISP::isConsDataType (sp srt) 
  (labels 
    ((isTwoTuple (srt) 
      (let ((pV5 (SPECENVIRONMENT::stripSubsorts sp srt))) 
        (block 
         nil 
         (if (eq (car pV5) :|Product|) 
             (let ((pV7 (car (cdr pV5)))) 
               (if (consp pV7) 
                   (let ((pV11 (cdr pV7))) 
                     (if (consp pV11) (if (null (cdr pV11)) (return t))))))) 
         (return nil))))) 
    (let ((pV20 (SPECENVIRONMENT::stripSubsorts sp srt))) 
      (block 
       nil 
       (if (eq (car pV20) :|CoProduct|) 
           (let ((pV22 (car (cdr pV20)))) 
             (if (consp pV22) 
                 (let ((pV26 (cdr pV22))
                       (pV25 (car pV22))) 
                   (let ((pV28 (cdr pV25))
                         (pV27 (car pV25))) 
                     (progn (if (string=  "None" pV27) 
                                (if (eq (car pV28) :|None|) 
                                    (if (consp pV26) 
                                        (let ((pV42 (car pV26))) 
                                          (if (string=  "Some" (car pV42)) 
                                              (if (eq (car (cdr pV42)) :|Some|) 
                                                  (if (null (cdr pV26)) 
                                                      (return '(:|None|))))))))) 
                            (if (eq (car pV28) :|None|) 
                                (if (consp pV26) 
                                    (let ((pV36 (car pV26))) 
                                      (let ((pV39 (cdr pV36))) 
                                        (if (eq (car pV39) :|Some|) 
                                            (if (null (cdr pV26)) 
                                                (return 
                                                 (if (isTwoTuple (cdr pV39)) 
                                                     (cons 
                                                      :|Some| 
                                                      (cons pV27 (car pV36))) 
                                                     '(:|None|)))))))) 
                                (if (eq (car pV28) :|Some|) 
                                    (if (consp pV26) 
                                        (let ((pV31 (car pV26))) 
                                          (if (eq (car (cdr pV31)) :|None|) 
                                              (if (null (cdr pV26)) 
                                                  (return 
                                                   (if (isTwoTuple (cdr pV28)) 
                                                       (cons 
                                                        :|Some| 
                                                        (cons (car pV31) pV27)) 
                                                       '(:|None|))))))))))))))) 
       (return '(:|None|))))))

(defun SPECTOLISP::hasConsDomain (sp id srt) 
  (let ((pV8 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV8) :|Arrow|) 
         (return 
          (let ((pV3 (SPECTOLISP::isConsDataType sp (svref (cdr pV8) 0)))) 
            (block 
             nil 
             (if (eq (car pV3) :|Some|) 
                 (return 
                  (cons 
                   :|Some| 
                   (if (string=  id (car (cdr pV3))) "null" "consp"))) 
                 (if (eq (car pV3) :|None|) (return '(:|None|)))) 
             (error "Nonexhaustive match failure in hasConsDomain"))))) 
     (return '(:|None|)))))

(defun SPECTOLISP::isConsIdentifier (sp id srt) 
  (let ((pV1 (SPECTOLISP::isConsDataType sp srt))) 
    (block 
     nil 
     (if (eq (car pV1) :|Some|) 
         (return 
          (cons :|Some| (if (string=  id (car (cdr pV1))) "null" "consp"))) 
         (if (eq (car pV1) :|None|) (return '(:|None|)))) 
     (error "Nonexhaustive match failure in isConsIdentifier"))))

(defun SPECTOLISP::isPairProjection (sp srt id) 
  (let ((pV22 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV22) :|Arrow|) 
         (return 
          (let ((pV7 (SPECENVIRONMENT::unfoldBase sp (svref (cdr pV22) 0)))) 
            (block 
             nil 
             (if (eq (car pV7) :|Product|) 
                 (let ((pV9 (car (cdr pV7)))) 
                   (if (consp pV9) 
                       (let ((pV13 (cdr pV9))) 
                         (if (consp pV13) 
                             (if (null (cdr pV13)) 
                                 (return 
                                  (if (string=  (car (car pV9)) id) 
                                      (cons :|Some| "car") 
                                      (cons :|Some| "cdr"))))))))) 
             (return '(:|None|)))))) 
     (return '(:|None|)))))

(defun SPECTOLISP::unaryName (nm) (STRING-SPEC::^ nm "-1"))

(defun SPECTOLISP::mkLApplyArity (id arity vars args) 
  (let ((rator 
         (if (STRINGSET::|!member| vars id) 
             (LISTADT::mkLVar id) 
             (block 
              nil 
              (if (eq (car arity) :|Some|) 
                  (return 
                   (if ( =  (LIST-SPEC::|!length| args) 1) 
                       (LISTADT::mkLOp (SPECTOLISP::unaryName id)) 
                       (LISTADT::mkLOp id)))) 
              (return (LISTADT::mkLOp id)))))) (LISTADT::mkLApply rator args)))

(defun SPECTOLISP::mkLEqualityOp (sp srt) 
  (let ((pV39 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV39) :|Arrow|) 
         (return 
          (let ((pV26 (SPECENVIRONMENT::unfoldBase sp (svref (cdr pV39) 0)))) 
            (block 
             nil 
             (if (eq (car pV26) :|Product|) 
                 (let ((pV28 (car (cdr pV26)))) 
                   (if (consp pV28) 
                       (let ((pV32 (cdr pV28))) 
                         (let ((pV34 (cdr (car pV28)))) 
                           (if (consp pV32) 
                               (if (null (cdr pV32)) 
                                   (return 
                                    (if (METASLANG::natSort? pV34) 
                                        " = " 
                                        (let ((pV17 
                                               (SPECENVIRONMENT::stripSubsorts 
                                                sp 
                                                pV34))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV17) :|Base|) 
                                               (let ((pV19 (svref (cdr pV17) 0))) 
                                                 (if (eq (car pV19) :|Qualified|) 
                                                     (let ((pV22 (cdr pV19))) 
                                                       (let ((pV24 (cdr pV22))
                                                             (pV23 (car pV22))) 
                                                         (if (string=  
                                                              "Boolean" 
                                                              pV23) 
                                                             (if (string=  
                                                                  "Boolean" 
                                                                  pV24) 
                                                                 (return "eq")) 
                                                             (if (string=  
                                                                  "Nat" 
                                                                  pV23) 
                                                                 (if (string=  
                                                                      "Nat" 
                                                                      pV24) 
                                                                     (return 
                                                                      " = ")) 
                                                                 (if (string=  
                                                                      "Integer" 
                                                                      pV23) 
                                                                     (if (string=  
                                                                          "Integer" 
                                                                          pV24) 
                                                                         (return 
                                                                          " = ")) 
                                                                     (if (string=  
                                                                          "String" 
                                                                          pV23) 
                                                                         (if (string=  
                                                                              "String" 
                                                                              pV24) 
                                                                             (return 
                                                                              "string= ")) 
                                                                         (if (string=  
                                                                              "Char" 
                                                                              pV23) 
                                                                             (if (string=  
                                                                                  "Char" 
                                                                                  pV24) 
                                                                                 (return 
                                                                                  "eq")))))))))))) 
                                           (return 
                                            "slang-built-in::slang-term-equals")))))))))))) 
             (return "slang-built-in::slang-term-equals"))))) 
     (return "slang-built-in::slang-term-equals"))))

(defun SPECTOLISP::mkLTermList (sp dpn vars term) 
  (block 
   nil 
   (if (eq (car term) :|Record|) 
       (return 
        (LIST-SPEC::|!map|-1-1 
         #'(lambda (x) (SPECTOLISP::mkLTerm sp dpn vars (cdr x))) 
         (car (cdr term))))) 
   (return (cons (SPECTOLISP::mkLTerm sp dpn vars term) nil))))

(defun SPECTOLISP::mkLUnaryFnRef (id arity vars) 
  (if (STRINGSET::|!member| vars id) 
      (LISTADT::mkLVar id) 
      (block 
       nil 
       (if (eq (car arity) :|Some|) 
           (return (LISTADT::mkLOp (SPECTOLISP::unaryName id)))) 
       (return (LISTADT::mkLOp id)))))

(defun SPECTOLISP::opArity (sp idf srt) 
  (let ((pV1 (ARITYNORMALIZE::sortArity sp srt))) 
    (block 
     nil 
     (if (eq (car pV1) :|None|) (return '(:|None|))) 
     (return (if (ARITYNORMALIZE::polymorphicDomainOp? sp idf) '(:|None|) pV1)))))


(defun SPECTOLISP::ith (n id ids) 
  (block 
   nil 
   (if (null ids) 
       (return (SYSTEM-SPEC::fail (STRING-SPEC::|!++| "No such index " id))) 
       (if (consp ids) 
           (return 
            (if (string=  id (car (car ids))) 
                n 
                (SPECTOLISP::ith (INTEGER-SPEC::|!+| n 1) id (cdr ids)))))) 
   (error "Nonexhaustive match failure in ith")))

(defun SPECTOLISP::projectionIndex (sp id srt) 
  (let ((pV2 (SPECENVIRONMENT::arrow sp srt))) 
    (block 
     nil 
     (return 
      (let ((row (SPECENVIRONMENT::product sp (car pV2)))) 
        (SPECTOLISP::ith 0 id row))) 
     (error "Nonexhaustive match failure in projectionIndex"))))

(defun SPECTOLISP::mkLTermOp (sp dpn vars termOp optArgs) 
  (let ((pV130 (svref termOp 1))
        (pV129 (svref termOp 0))) 
    (block 
     nil 
     (if (eq (car pV129) :|Project|) 
         (let ((pV140 (cdr pV129))) 
           (return 
            (let ((pV2 (SPECTOLISP::isPairProjection sp pV130 pV140))) 
              (block 
               nil 
               (if (eq (car pV2) :|Some|) 
                   (let ((pV4 (cdr pV2))) 
                     (if (eq (car optArgs) :|None|) 
                         (return 
                          (LISTADT::mkLLambda 
                           (cons "!x" nil) 
                           nil 
                           (LISTADT::mkLApply 
                            (LISTADT::mkLOp pV4) 
                            (cons (LISTADT::mkLVar "!x") nil)))) 
                         (if (eq (car optArgs) :|Some|) 
                             (return 
                              (LISTADT::mkLApply 
                               (LISTADT::mkLOp pV4) 
                               (cons 
                                (SPECTOLISP::mkLTerm sp dpn vars (cdr optArgs)) 
                                nil)))))) 
                   (if (eq (car pV2) :|None|) 
                       (if (eq (car optArgs) :|Some|) 
                           (return 
                            (let ((id 
                                   (SPECTOLISP::projectionIndex sp pV140 pV130))) 
                              (LISTADT::mkLApply 
                               (LISTADT::mkLOp "svref") 
                               (cons 
                                (SPECTOLISP::mkLTerm sp dpn vars (cdr optArgs)) 
                                (cons (LISTADT::mkLNat id) nil))))) 
                           (if (eq (car optArgs) :|None|) 
                               (return 
                                (let ((id 
                                       (SPECTOLISP::projectionIndex 
                                        sp 
                                        pV140 
                                        pV130))) 
                                  (LISTADT::mkLLambda 
                                   (cons "!x" nil) 
                                   nil 
                                   (LISTADT::mkLApply 
                                    (LISTADT::mkLOp "svref") 
                                    (cons 
                                     (LISTADT::mkLVar "!x") 
                                     (cons (LISTADT::mkLNat id) nil)))))))))) 
               (error "Nonexhaustive match failure in mkLTermOp"))))) 
         (if (eq (car pV129) :|Equals|) 
             (return 
              (let ((oper (LISTADT::mkLOp (SPECTOLISP::mkLEqualityOp sp pV130)))) 
                (block 
                 nil 
                 (if (eq (car optArgs) :|None|) 
                     (return oper) 
                     (if (eq (car optArgs) :|Some|) 
                         (return 
                          (LISTADT::mkLApply 
                           oper 
                           (SPECTOLISP::mkLTermList sp dpn vars (cdr optArgs)))))) 
                 (error "Nonexhaustive match failure in mkLTermOp")))) 
             (if (eq (car pV129) :|Select|) 
                 (return 
                  (let ((pV11 (SPECTOLISP::hasConsDomain sp (cdr pV129) pV130))) 
                    (block 
                     nil 
                     (if (eq (car pV11) :|Some|) 
                         (if (eq (car optArgs) :|None|) 
                             (return 
                              (LISTADT::mkLLambda 
                               (cons "!x" nil) 
                               nil 
                               (LISTADT::mkLVar "!x"))) 
                             (if (eq (car optArgs) :|Some|) 
                                 (return 
                                  (SPECTOLISP::mkLTerm sp dpn vars (cdr optArgs))))) 
                         (if (eq (car pV11) :|None|) 
                             (if (eq (car optArgs) :|None|) 
                                 (return (LISTADT::mkLOp "cdr")) 
                                 (if (eq (car optArgs) :|Some|) 
                                     (return 
                                      (LISTADT::mkLApply 
                                       (LISTADT::mkLOp "cdr") 
                                       (cons 
                                        (SPECTOLISP::mkLTerm 
                                         sp 
                                         dpn 
                                         vars 
                                         (cdr optArgs)) 
                                        nil))))))) 
                     (error "Nonexhaustive match failure in mkLTermOp")))) 
                 (if (eq (car pV129) :|Embedded|) 
                     (let ((pV138 (cdr pV129))) 
                       (return 
                        (let ((dom (SPECENVIRONMENT::domain sp pV130))) 
                          (let ((pV17 
                                 (SPECTOLISP::isConsIdentifier sp pV138 dom))) 
                            (block 
                             nil 
                             (if (eq (car pV17) :|Some|) 
                                 (let ((pV19 (cdr pV17))) 
                                   (if (eq (car optArgs) :|None|) 
                                       (return 
                                        (LISTADT::mkLLambda 
                                         (cons "!x" nil) 
                                         nil 
                                         (LISTADT::mkLApply 
                                          (LISTADT::mkLOp pV19) 
                                          (cons (LISTADT::mkLVar "!x") nil)))) 
                                       (if (eq (car optArgs) :|Some|) 
                                           (return 
                                            (LISTADT::mkLApply 
                                             (LISTADT::mkLOp pV19) 
                                             (cons 
                                              (SPECTOLISP::mkLTerm 
                                               sp 
                                               dpn 
                                               vars 
                                               (cdr optArgs)) 
                                              nil)))))) 
                                 (if (eq (car pV17) :|None|) 
                                     (if (eq (car optArgs) :|None|) 
                                         (return 
                                          (LISTADT::mkLLambda 
                                           (cons "!x" nil) 
                                           nil 
                                           (LISTADT::mkLApply 
                                            SPECTOLISP::compareSymbols 
                                            (cons 
                                             (LISTADT::mkLApply 
                                              (LISTADT::mkLOp "car") 
                                              (cons (LISTADT::mkLVar "!x") nil)) 
                                             (cons 
                                              (LISTADT::mkLIntern pV138) 
                                              nil))))) 
                                         (if (eq (car optArgs) :|Some|) 
                                             (return 
                                              (LISTADT::mkLApply 
                                               SPECTOLISP::compareSymbols 
                                               (cons 
                                                (LISTADT::mkLApply 
                                                 (LISTADT::mkLOp "car") 
                                                 (cons 
                                                  (SPECTOLISP::mkLTerm 
                                                   sp 
                                                   dpn 
                                                   vars 
                                                   (cdr optArgs)) 
                                                  nil)) 
                                                (cons 
                                                 (LISTADT::mkLIntern pV138) 
                                                 nil)))))))) 
                             (error "Nonexhaustive match failure in mkLTermOp")))))) 
                     (if (eq (car pV129) :|Nat|) 
                         (return (LISTADT::mkLInt (cdr pV129))) 
                         (if (eq (car pV129) :|String|) 
                             (return (LISTADT::mkLString (cdr pV129))) 
                             (if (eq (car pV129) :|Bool|) 
                                 (return (LISTADT::mkLBool (cdr pV129))) 
                                 (if (eq (car pV129) :|Char|) 
                                     (return (LISTADT::mkLChar (cdr pV129))) 
                                     (if (eq (car pV129) :|Op|) 
                                         (let ((pV143 (car (cdr pV129)))) 
                                           (progn (if (eq 
                                                       (car pV143) 
                                                       :|Qualified|) 
                                                      (let ((pV151 (cdr pV143))) 
                                                        (if (string=  
                                                             "Boolean" 
                                                             (car pV151)) 
                                                            (if (string=  
                                                                 "&" 
                                                                 (cdr pV151)) 
                                                                (return 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        optArgs) 
                                                                       :|Some|) 
                                                                      (let ((pV32 
                                                                             (cdr 
                                                                              optArgs))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV32) 
                                                                             :|Record|) 
                                                                            (let ((pV34 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV32)))) 
                                                                              (if (consp 
                                                                                   pV34) 
                                                                                  (let ((pV38 
                                                                                         (cdr 
                                                                                          pV34))) 
                                                                                    (if (consp 
                                                                                         pV38) 
                                                                                        (if (null 
                                                                                             (cdr 
                                                                                              pV38)) 
                                                                                            (return 
                                                                                             (LISTADT::mkLApply 
                                                                                              (LISTADT::mkLOp 
                                                                                               "cl:and") 
                                                                                              (cons 
                                                                                               (SPECTOLISP::mkLTerm 
                                                                                                sp 
                                                                                                dpn 
                                                                                                vars 
                                                                                                (cdr 
                                                                                                 (car 
                                                                                                  pV34))) 
                                                                                               (cons 
                                                                                                (SPECTOLISP::mkLTerm 
                                                                                                 sp 
                                                                                                 dpn 
                                                                                                 vars 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV38))) 
                                                                                                nil))))))))))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            optArgs) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (LISTADT::mkLOp 
                                                                            (SPECTOLISP::printPackageId 
                                                                             pV143 
                                                                             dpn))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in mkLTermOp"))))))) 
                                                  (if (eq 
                                                       (car pV143) 
                                                       :|Qualified|) 
                                                      (let ((pV148 (cdr pV143))) 
                                                        (if (string=  
                                                             "Boolean" 
                                                             (car pV148)) 
                                                            (if (string=  
                                                                 "or" 
                                                                 (cdr pV148)) 
                                                                (return 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        optArgs) 
                                                                       :|Some|) 
                                                                      (let ((pV52 
                                                                             (cdr 
                                                                              optArgs))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV52) 
                                                                             :|Record|) 
                                                                            (let ((pV54 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV52)))) 
                                                                              (if (consp 
                                                                                   pV54) 
                                                                                  (let ((pV58 
                                                                                         (cdr 
                                                                                          pV54))) 
                                                                                    (if (consp 
                                                                                         pV58) 
                                                                                        (if (null 
                                                                                             (cdr 
                                                                                              pV58)) 
                                                                                            (return 
                                                                                             (LISTADT::mkLApply 
                                                                                              (LISTADT::mkLOp 
                                                                                               "cl:or") 
                                                                                              (cons 
                                                                                               (SPECTOLISP::mkLTerm 
                                                                                                sp 
                                                                                                dpn 
                                                                                                vars 
                                                                                                (cdr 
                                                                                                 (car 
                                                                                                  pV54))) 
                                                                                               (cons 
                                                                                                (SPECTOLISP::mkLTerm 
                                                                                                 sp 
                                                                                                 dpn 
                                                                                                 vars 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV58))) 
                                                                                                nil))))))))))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            optArgs) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (LISTADT::mkLOp 
                                                                            (SPECTOLISP::printPackageId 
                                                                             pV143 
                                                                             dpn))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in mkLTermOp"))))))) 
                                                  (if (eq 
                                                       (car pV143) 
                                                       :|Qualified|) 
                                                      (let ((pV145 (cdr pV143))) 
                                                        (if (string=  
                                                             "Boolean" 
                                                             (car pV145)) 
                                                            (if (string=  
                                                                 " =>" 
                                                                 (cdr pV145)) 
                                                                (return 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        optArgs) 
                                                                       :|Some|) 
                                                                      (let ((pV72 
                                                                             (cdr 
                                                                              optArgs))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV72) 
                                                                             :|Record|) 
                                                                            (let ((pV74 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV72)))) 
                                                                              (if (consp 
                                                                                   pV74) 
                                                                                  (let ((pV78 
                                                                                         (cdr 
                                                                                          pV74))) 
                                                                                    (if (consp 
                                                                                         pV78) 
                                                                                        (if (null 
                                                                                             (cdr 
                                                                                              pV78)) 
                                                                                            (return 
                                                                                             (LISTADT::mkLApply 
                                                                                              (LISTADT::mkLOp 
                                                                                               "cl:or") 
                                                                                              (cons 
                                                                                               (LISTADT::mkLApply 
                                                                                                (LISTADT::mkLOp 
                                                                                                 "cl:not") 
                                                                                                (cons 
                                                                                                 (SPECTOLISP::mkLTerm 
                                                                                                  sp 
                                                                                                  dpn 
                                                                                                  vars 
                                                                                                  (cdr 
                                                                                                   (car 
                                                                                                    pV74))) 
                                                                                                 nil)) 
                                                                                               (cons 
                                                                                                (SPECTOLISP::mkLTerm 
                                                                                                 sp 
                                                                                                 dpn 
                                                                                                 vars 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV78))) 
                                                                                                nil))))))))))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            optArgs) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (LISTADT::mkLOp 
                                                                            (SPECTOLISP::printPackageId 
                                                                             pV143 
                                                                             dpn))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in mkLTermOp"))))))) 
                                                  (return 
                                                   (let ((pid 
                                                          (SPECTOLISP::printPackageId 
                                                           pV143 
                                                           dpn))) 
                                                     (let ((arity 
                                                            (SPECTOLISP::opArity 
                                                             sp 
                                                             pV143 
                                                             pV130))) 
                                                       (block 
                                                        nil 
                                                        (if (eq 
                                                             (car optArgs) 
                                                             :|None|) 
                                                            (return 
                                                             (if (SPECTOLISP::functionSort? 
                                                                  sp 
                                                                  pV130) 
                                                                 (SPECTOLISP::mkLUnaryFnRef 
                                                                  pid 
                                                                  arity 
                                                                  vars) 
                                                                 (cons 
                                                                  :|Const| 
                                                                  (cons 
                                                                   :|Parameter| 
                                                                   pid)))) 
                                                            (if (eq 
                                                                 (car optArgs) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (SPECTOLISP::mkLApplyArity 
                                                                  pid 
                                                                  arity 
                                                                  vars 
                                                                  (SPECTOLISP::mkLTermList 
                                                                   sp 
                                                                   dpn 
                                                                   vars 
                                                                   (cdr optArgs)))))) 
                                                        (error 
                                                         "Nonexhaustive match failure in mkLTermOp"))))))) 
                                         (if (eq (car pV129) :|Embed|) 
                                             (let ((pV132 (cdr pV129))) 
                                               (let ((pV142 (cdr pV132))
                                                     (pV141 (car pV132))) 
                                                 (if (eq t pV142) 
                                                     (return 
                                                      (let ((rng 
                                                             (SPECENVIRONMENT::range 
                                                              sp 
                                                              pV130))) 
                                                        (let ((pV96 
                                                               (SPECTOLISP::isConsDataType 
                                                                sp 
                                                                rng))) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car pV96) 
                                                                :|Some|) 
                                                               (return 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car 
                                                                       optArgs) 
                                                                      :|None|) 
                                                                     (return 
                                                                      (LISTADT::mkLLambda 
                                                                       (cons 
                                                                        "!x" 
                                                                        nil) 
                                                                       nil 
                                                                       (LISTADT::mkLVar 
                                                                        "!x"))) 
                                                                     (if (eq 
                                                                          (car 
                                                                           optArgs) 
                                                                          :|Some|) 
                                                                         (return 
                                                                          (SPECTOLISP::mkLTerm 
                                                                           sp 
                                                                           dpn 
                                                                           vars 
                                                                           (cdr 
                                                                            optArgs))))) 
                                                                 (error 
                                                                  "Nonexhaustive match failure in mkLTermOp"))) 
                                                               (if (eq 
                                                                    (car pV96) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (let ((id 
                                                                           (LISTADT::mkLIntern 
                                                                            pV141))) 
                                                                      (block 
                                                                       nil 
                                                                       (if (eq 
                                                                            (car 
                                                                             optArgs) 
                                                                            :|None|) 
                                                                           (return 
                                                                            (LISTADT::mkLLambda 
                                                                             (cons 
                                                                              "!x" 
                                                                              nil) 
                                                                             nil 
                                                                             (LISTADT::mkLApply 
                                                                              (LISTADT::mkLOp 
                                                                               "cons") 
                                                                              (cons 
                                                                               id 
                                                                               (cons 
                                                                                (LISTADT::mkLVar 
                                                                                 "!x") 
                                                                                nil))))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 optArgs) 
                                                                                :|Some|) 
                                                                               (return 
                                                                                (LISTADT::mkLApply 
                                                                                 (LISTADT::mkLOp 
                                                                                  "cons") 
                                                                                 (cons 
                                                                                  id 
                                                                                  (cons 
                                                                                   (SPECTOLISP::mkLTerm 
                                                                                    sp 
                                                                                    dpn 
                                                                                    vars 
                                                                                    (cdr 
                                                                                     optArgs)) 
                                                                                   nil)))))) 
                                                                       (error 
                                                                        "Nonexhaustive match failure in mkLTermOp")))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in mkLTermOp"))))) 
                                                     (if (eq nil pV142) 
                                                         (return 
                                                          (let ((pV100 
                                                                 (SPECTOLISP::isConsDataType 
                                                                  sp 
                                                                  pV130))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV100) 
                                                                  :|Some|) 
                                                                 (return 
                                                                  (LISTADT::mkLBool 
                                                                   nil)) 
                                                                 (if (eq 
                                                                      (car pV100) 
                                                                      :|None|) 
                                                                     (return 
                                                                      (LISTADT::mkLApply 
                                                                       (LISTADT::mkLOp 
                                                                        "list") 
                                                                       (cons 
                                                                        (LISTADT::mkLIntern 
                                                                         pV141) 
                                                                        nil))))) 
                                                             (error 
                                                              "Nonexhaustive match failure in mkLTermOp")))))))) 
                                             (if (eq (car pV129) :|Quotient|) 
                                                 (return 
                                                  (let ((dom 
                                                         (SPECENVIRONMENT::range 
                                                          sp 
                                                          pV130))) 
                                                    (let ((pV107 
                                                           (SPECENVIRONMENT::unfoldBase 
                                                            sp 
                                                            dom))) 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV107) 
                                                            :|Quotient|) 
                                                           (return 
                                                            (let ((equiv 
                                                                   (SPECTOLISP::mkLTerm 
                                                                    sp 
                                                                    dpn 
                                                                    vars 
                                                                    (svref 
                                                                     (cdr pV107) 
                                                                     1)))) 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car optArgs) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (LISTADT::mkLApply 
                                                                     (LISTADT::mkLOp 
                                                                      "slang-built-in::quotient") 
                                                                     (cons 
                                                                      equiv 
                                                                      nil))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         optArgs) 
                                                                        :|Some|) 
                                                                       (return 
                                                                        (LISTADT::mkLApply 
                                                                         (LISTADT::mkLApply 
                                                                          (LISTADT::mkLOp 
                                                                           "slang-built-in::quotient") 
                                                                          (cons 
                                                                           equiv 
                                                                           nil)) 
                                                                         (cons 
                                                                          (SPECTOLISP::mkLTerm 
                                                                           sp 
                                                                           dpn 
                                                                           vars 
                                                                           (cdr 
                                                                            optArgs)) 
                                                                          nil))))) 
                                                               (error 
                                                                "Nonexhaustive match failure in mkLTermOp"))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in mkLTermOp"))))) 
                                                 (if (eq (car pV129) :|Choose|) 
                                                     (return 
                                                      (let ((srt1 
                                                             (SPECENVIRONMENT::range 
                                                              sp 
                                                              pV130))) 
                                                        (let ((dom 
                                                               (SPECENVIRONMENT::domain 
                                                                sp 
                                                                srt1))) 
                                                          (let ((pV117 
                                                                 (SPECENVIRONMENT::unfoldBase 
                                                                  sp 
                                                                  dom))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV117) 
                                                                  :|Quotient|) 
                                                                 (return 
                                                                  (let ((equiv 
                                                                         (SPECTOLISP::mkLTerm 
                                                                          sp 
                                                                          dpn 
                                                                          vars 
                                                                          (svref 
                                                                           (cdr 
                                                                            pV117) 
                                                                           1)))) 
                                                                    (block 
                                                                     nil 
                                                                     (if (eq 
                                                                          (car 
                                                                           optArgs) 
                                                                          :|None|) 
                                                                         (return 
                                                                          (LISTADT::mkLApply 
                                                                           (LISTADT::mkLOp 
                                                                            "slang-built-in::choose") 
                                                                           (cons 
                                                                            equiv 
                                                                            nil))) 
                                                                         (if (eq 
                                                                              (car 
                                                                               optArgs) 
                                                                              :|Some|) 
                                                                             (return 
                                                                              (LISTADT::mkLApply 
                                                                               (LISTADT::mkLApply 
                                                                                (LISTADT::mkLOp 
                                                                                 "slang-built-in::choose") 
                                                                                (cons 
                                                                                 equiv 
                                                                                 nil)) 
                                                                               (cons 
                                                                                (SPECTOLISP::mkLTerm 
                                                                                 sp 
                                                                                 dpn 
                                                                                 vars 
                                                                                 (cdr 
                                                                                  optArgs)) 
                                                                                nil))))) 
                                                                     (error 
                                                                      "Nonexhaustive match failure in mkLTermOp"))))) 
                                                             (error 
                                                              "Nonexhaustive match failure in mkLTermOp")))))) 
                                                     (if (eq 
                                                          (car pV129) 
                                                          :|Restrict|) 
                                                         (return 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car optArgs) 
                                                                :|None|) 
                                                               (return 
                                                                (LISTADT::mkLLambda 
                                                                 (cons "!x" nil) 
                                                                 nil 
                                                                 (LISTADT::mkLVar 
                                                                  "!x"))) 
                                                               (if (eq 
                                                                    (car optArgs) 
                                                                    :|Some|) 
                                                                   (return 
                                                                    (SPECTOLISP::mkLTerm 
                                                                     sp 
                                                                     dpn 
                                                                     vars 
                                                                     (cdr 
                                                                      optArgs))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in mkLTermOp"))) 
                                                         (if (eq 
                                                              (car pV129) 
                                                              :|Relax|) 
                                                             (return 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car optArgs) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (LISTADT::mkLLambda 
                                                                     (cons 
                                                                      "!x" 
                                                                      nil) 
                                                                     nil 
                                                                     (LISTADT::mkLVar 
                                                                      "!x"))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         optArgs) 
                                                                        :|Some|) 
                                                                       (return 
                                                                        (SPECTOLISP::mkLTerm 
                                                                         sp 
                                                                         dpn 
                                                                         vars 
                                                                         (cdr 
                                                                          optArgs))))) 
                                                               (error 
                                                                "Nonexhaustive match failure in mkLTermOp"))))))))))))))))) 
     (return (SYSTEM-SPEC::fail "Unexpected termOp")))))

(defun SPECTOLISP::patternNames (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) 
       (return (cons (car (car (cdr pattern))) nil)) 
       (if (eq (car pattern) :|RecordPat|) 
           (return 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (x) (SPECTOLISP::patternName (cdr x))) 
             (car (cdr pattern)))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      "SpecToLisp.patternNames " 
      (ANNSPECPRINTER::printPattern pattern))))))

(defun STRINGSET::difference (x0 x) (SPLAYSET::difference x0 x))

(defun SPECTOLISP::mkLTerm (sp dpn vars term) 
  (let ((pV134 (SPECTOLISP::fullCurriedApplication sp dpn vars term))) 
    (block 
     nil 
     (if (eq (car pV134) :|Some|) (return (cdr pV134))) 
     (return 
      (block 
       nil 
       (if (eq (car term) :|Fun|) 
           (return (SPECTOLISP::mkLTermOp sp dpn vars (cdr term) '(:|None|))) 
           (if (eq (car term) :|Var|) 
               (return 
                (let ((id (SPECTOLISP::specId (car (car (cdr term)))))) 
                  (if (STRINGSET::|!member| vars id) 
                      (cons :|Var| id) 
                      (cons :|Op| id)))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV68 (cdr term))) 
                     (return 
                      (let ((pV4 (LISTPAIR::unzip (svref pV68 0)))) 
                        (block 
                         nil 
                         (return 
                          (let ((names 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'SPECTOLISP::patternName 
                                  (car pV4)))) 
                            (let ((names 
                                   (LIST-SPEC::|!map|-1-1 
                                    #'SPECTOLISP::specId 
                                    names))) 
                              (LISTADT::mkLLet 
                               names 
                               (LIST-SPEC::|!map|-1-1 
                                #'(lambda (|!t|) 
                                   (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                                (cdr pV4)) 
                               (SPECTOLISP::mkLTerm 
                                sp 
                                dpn 
                                (STRINGSET::addList vars names) 
                                (svref pV68 1)))))) 
                         (error "Nonexhaustive match failure in mkLTerm"))))) 
                   (if (eq (car term) :|LetRec|) 
                       (let ((pV67 (cdr term))) 
                         (let ((pV125 (svref pV67 1))
                               (pV124 (svref pV67 0))) 
                           (return 
                            (labels 
                              ((unfold (decls names terms) 
                                (block 
                                 nil 
                                 (if (null decls) 
                                     (return (cons names terms)) 
                                     (if (consp decls) 
                                         (let ((pV10 (car decls))) 
                                           (return 
                                            (unfold 
                                             (cdr decls) 
                                             (LIST-SPEC::|!cons| 
                                              (car pV10) 
                                              names) 
                                             (LIST-SPEC::|!cons| 
                                              (cdr pV10) 
                                              terms)))))) 
                                 (error "Nonexhaustive match failure in mkLTerm")))) 
                              (let ((pV15 (unfold pV124 nil nil))) 
                                (block 
                                 nil 
                                 (return 
                                  (let ((names 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) 
                                             (SPECTOLISP::specId (car x))) 
                                          (car pV15)))) 
                                    (let ((vars 
                                           (STRINGSET::difference 
                                            vars 
                                            (STRINGSET::fromList names)))) 
                                      (LISTADT::mkLLetRec 
                                       names 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'(lambda (|!t|) 
                                           (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                                        (cdr pV15)) 
                                       (SPECTOLISP::mkLTerm sp dpn vars pV125))))) 
                                 (error "Nonexhaustive match failure in mkLTerm"))))))) 
                       (if (eq (car term) :|Apply|) 
                           (let ((pV66 (cdr term))) 
                             (let ((pV89 (svref pV66 2))
                                   (pV88 (svref pV66 1))
                                   (pV87 (svref pV66 0))) 
                               (progn (if (eq (car pV88) :|Apply|) 
                                          (let ((pV116 (cdr pV88))) 
                                            (let ((pV118 (svref pV116 1))
                                                  (pV117 (svref pV116 0))) 
                                              (if (eq (car pV117) :|Fun|) 
                                                  (let ((pV121 
                                                         (svref (cdr pV117) 0))) 
                                                    (if (eq 
                                                         (car pV121) 
                                                         :|Restrict|) 
                                                        (return 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          vars 
                                                          (cons 
                                                           :|Apply| 
                                                           (vector 
                                                            pV87 
                                                            pV118 
                                                            pV89)))) 
                                                        (if (eq 
                                                             (car pV121) 
                                                             :|Relax|) 
                                                            (return 
                                                             (SPECTOLISP::mkLTerm 
                                                              sp 
                                                              dpn 
                                                              vars 
                                                              (cons 
                                                               :|Apply| 
                                                               (vector 
                                                                pV87 
                                                                pV118 
                                                                pV89))))))))))) 
                                      (if (eq (car pV87) :|Fun|) 
                                          (let ((pV94 (svref (cdr pV87) 0))) 
                                            (if (eq (car pV94) :|Op|) 
                                                (let ((pV98 (car (cdr pV94)))) 
                                                  (if (eq 
                                                       (car pV98) 
                                                       :|Qualified|) 
                                                      (let ((pV100 (cdr pV98))) 
                                                        (let ((pV102 (cdr pV100))) 
                                                          (if (string=  
                                                               "TranslationBuiltIn" 
                                                               (car pV100)) 
                                                              (if (string=  
                                                                   "block" 
                                                                   pV102) 
                                                                  (return 
                                                                   (let ((terms 
                                                                          (SPECTOLISP::flattenFailWith 
                                                                           pV88))) 
                                                                     (let ((terms 
                                                                            (LIST-SPEC::|!map|-1-1 
                                                                             #'(lambda (term1) 
                                                                                (SPECTOLISP::blockAtom 
                                                                                 sp 
                                                                                 dpn 
                                                                                 vars 
                                                                                 term1)) 
                                                                             terms))) 
                                                                       (LISTADT::mkLApply 
                                                                        (LISTADT::mkLOp 
                                                                         "block") 
                                                                        (LIST-SPEC::|!cons| 
                                                                         (cons 
                                                                          :|Const| 
                                                                          (cons 
                                                                           :|Boolean| 
                                                                           nil)) 
                                                                         terms))))) 
                                                                  (if (string=  
                                                                       "mkTuple" 
                                                                       pV102) 
                                                                      (return 
                                                                       (SPECTOLISP::mkLTerm 
                                                                        sp 
                                                                        dpn 
                                                                        vars 
                                                                        pV88)) 
                                                                      (if (string=  
                                                                           "mkApply" 
                                                                           pV102) 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV88) 
                                                                               :|Record|) 
                                                                              (let ((pV104 
                                                                                     (car 
                                                                                      (cdr 
                                                                                       pV88)))) 
                                                                                (if (consp 
                                                                                     pV104) 
                                                                                    (let ((pV108 
                                                                                           (cdr 
                                                                                            pV104))) 
                                                                                      (if (consp 
                                                                                           pV108) 
                                                                                          (if (null 
                                                                                               (cdr 
                                                                                                pV108)) 
                                                                                              (return 
                                                                                               (LISTADT::mkLApply 
                                                                                                (LISTADT::mkLOp 
                                                                                                 "apply") 
                                                                                                (cons 
                                                                                                 (SPECTOLISP::mkLTerm 
                                                                                                  sp 
                                                                                                  dpn 
                                                                                                  vars 
                                                                                                  (cdr 
                                                                                                   (car 
                                                                                                    pV104))) 
                                                                                                 (cons 
                                                                                                  (SPECTOLISP::mkLTerm 
                                                                                                   sp 
                                                                                                   dpn 
                                                                                                   vars 
                                                                                                   (cdr 
                                                                                                    (car 
                                                                                                     pV108))) 
                                                                                                  nil))))))))))))))))))))) 
                                      (if (eq (car pV88) :|Record|) 
                                          (return 
                                           (block 
                                            nil 
                                            (if (eq (car pV87) :|Fun|) 
                                                (return 
                                                 (SPECTOLISP::mkLTermOp 
                                                  sp 
                                                  dpn 
                                                  vars 
                                                  (cdr pV87) 
                                                  (cons :|Some| pV88)))) 
                                            (return 
                                             (let ((terms 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'(lambda (x) 
                                                        (SPECTOLISP::mkLTerm 
                                                         sp 
                                                         dpn 
                                                         vars 
                                                         (cdr x))) 
                                                     (car (cdr pV88))))) 
                                               (LISTADT::mkLApply 
                                                (SPECTOLISP::mkLTerm 
                                                 sp 
                                                 dpn 
                                                 vars 
                                                 pV87) 
                                                terms)))))) 
                                      (return 
                                       (block 
                                        nil 
                                        (if (eq (car pV87) :|Fun|) 
                                            (return 
                                             (SPECTOLISP::mkLTermOp 
                                              sp 
                                              dpn 
                                              vars 
                                              (cdr pV87) 
                                              (cons :|Some| pV88))) 
                                            (if (eq (car pV87) :|Var|) 
                                                (return 
                                                 (let ((id 
                                                        (SPECTOLISP::specId 
                                                         (car (car (cdr pV87)))))) 
                                                   (if (STRINGSET::|!member| 
                                                        vars 
                                                        id) 
                                                       (LISTADT::mkLApply 
                                                        (SPECTOLISP::mkLTerm 
                                                         sp 
                                                         dpn 
                                                         vars 
                                                         pV87) 
                                                        (cons 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          vars 
                                                          pV88) 
                                                         nil)) 
                                                       (LISTADT::mkLApply 
                                                        (LISTADT::mkLOp id) 
                                                        (cons 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          vars 
                                                          pV88) 
                                                         nil))))))) 
                                        (return 
                                         (LISTADT::mkLApply 
                                          (SPECTOLISP::mkLTerm sp dpn vars pV87) 
                                          (cons 
                                           (SPECTOLISP::mkLTerm sp dpn vars pV88) 
                                           nil)))))))) 
                           (if (eq (car term) :|Record|) 
                               (return 
                                (SPECTOLISP::mkLispTuple 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x) 
                                     (SPECTOLISP::mkLTerm sp dpn vars (cdr x))) 
                                  (car (cdr term))))) 
                               (if (eq (car term) :|IfThenElse|) 
                                   (let ((pV64 (cdr term))) 
                                     (return 
                                      (LISTADT::mkLIf 
                                       (SPECTOLISP::mkLTerm 
                                        sp 
                                        dpn 
                                        vars 
                                        (svref pV64 0)) 
                                       (SPECTOLISP::mkLTerm 
                                        sp 
                                        dpn 
                                        vars 
                                        (svref pV64 1)) 
                                       (SPECTOLISP::mkLTerm 
                                        sp 
                                        dpn 
                                        vars 
                                        (svref pV64 2))))) 
                                   (if (eq (car term) :|Lambda|) 
                                       (let ((pV73 (car (cdr term)))) 
                                         (if (consp pV73) 
                                             (let ((pV76 (car pV73))) 
                                               (if (null (cdr pV73)) 
                                                   (return 
                                                    (let ((names 
                                                           (SPECTOLISP::patternNames 
                                                            (svref pV76 0)))) 
                                                      (let ((names 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'SPECTOLISP::specId 
                                                              names))) 
                                                        (LISTADT::mkLLambda 
                                                         names 
                                                         nil 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          (STRINGSET::addList 
                                                           vars 
                                                           names) 
                                                          (svref pV76 2)))))))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (return 
                                            (LISTADT::mkLSeq 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'(lambda (|!t|) 
                                                 (SPECTOLISP::mkLTerm 
                                                  sp 
                                                  dpn 
                                                  vars 
                                                  |!t|)) 
                                              (car (cdr term)))))))))))))) 
       (return 
        (SYSTEM-SPEC::fail 
         (STRING-SPEC::^ "Unexpected term " (ANNSPECPRINTER::printTerm term)))))))))


(defun SPECTOLISP::lispTerm (sp dpn term) 
  (SPECTOLISP::reduceTerm (SPECTOLISP::mkLTerm sp dpn STRINGSET::empty term)))

(defun SPECTOLISP::renameDef? (term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (let ((pV4 (cdr term))) 
         (let ((pV7 (svref pV4 2))
               (pV5 (svref pV4 0))) 
           (if (consp pV5) 
               (if (null (cdr pV5)) 
                   (if (eq (car pV7) :|Apply|) 
                       (let ((pV11 (cdr pV7))) 
                         (let ((pV13 (cdr pV11))
                               (pV12 (car pV11))) 
                           (if (eq (car pV12) :|Op|) 
                               (if (consp pV13) 
                                   (let ((pV16 (car pV13))) 
                                     (if (eq (car pV16) :|Var|) 
                                         (if (null (cdr pV13)) 
                                             (return 
                                              (if (string=  (car pV5) (cdr pV16)) 
                                                  (cons :|Some| (cdr pV12)) 
                                                  '(:|None|)))))))))))))))) 
   (return '(:|None|))))

(defun SPECTOLISP::unCurryDef (term n) 
  (labels 
    ((auxUnCurryDef (term i params let_binds) 
      (if (INTEGER-SPEC::|!>| i n) 
          (cons 
           :|Some| 
           (SPECTOLISP::reduceTerm 
            (LISTADT::mkLLambda 
             params 
             nil 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x) 
                 (let ((pV1 (car x))) 
                   (block 
                    nil 
                    (return (LISTADT::mkLLet (car pV1) (cdr pV1) (cdr x))) 
                    (error "Nonexhaustive match failure in unCurryDef")))) 
              term 
              let_binds)))) 
          (block 
           nil 
           (if (eq (car term) :|Lambda|) 
               (let ((pV15 (cdr term))) 
                 (let ((pV21 (svref pV15 2))
                       (pV19 (svref pV15 0))) 
                   (return 
                    (block 
                     nil 
                     (if (consp pV19) 
                         (if (null (cdr pV19)) 
                             (return 
                              (auxUnCurryDef 
                               pV21 
                               (INTEGER-SPEC::|!+| i 1) 
                               (LIST-SPEC::|!++| params pV19) 
                               let_binds)))) 
                     (return 
                      (let ((newParam 
                             (STRING-SPEC::^ "!x" (NAT-SPEC::toString i)))) 
                        (auxUnCurryDef 
                         pV21 
                         (INTEGER-SPEC::|!+| i 1) 
                         (LIST-SPEC::|!++| params (cons newParam nil)) 
                         (LIST-SPEC::|!++| 
                          (cons 
                           (cons 
                            pV19 
                            (SPECTOLISP::nTupleDerefs 
                             (LIST-SPEC::|!length| pV19) 
                             (LISTADT::mkLVar newParam))) 
                           nil) 
                          let_binds)))))))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV14 (cdr term))) 
                     (return 
                      (auxUnCurryDef 
                       (svref pV14 2) 
                       i 
                       params 
                       (LIST-SPEC::|!++| 
                        (cons (cons (svref pV14 0) (svref pV14 1)) nil) 
                        let_binds)))))) 
           (return '(:|None|)))))) (auxUnCurryDef term 1 nil nil)))

(defun SPECTOLISP::|!lisp|-1 (spc) 
  (progn (SPECTOLISP::initializeSpecId) 
         (let ((packages 
                (LIST-SPEC::|!map|-1-1 
                 #'SPECTOLISP::mkLPackageId 
                 (qualifiers (svref spc 1))))) 
           (let ((pV63 
                  (block 
                   nil 
                   (if (consp packages) 
                       (return (cons (car packages) (cdr packages))) 
                       (if (null packages) 
                           (return (cons SPECTOLISP::defaultSpecwarePackage nil)))) 
                   (error "Nonexhaustive match failure in lisp")))) 
             (block 
              nil 
              (let ((pV65 (cdr pV63))
                    (pV64 (car pV63))) 
                (return 
                 (labels 
                   ((mkLOpDef (qname name decl defs) 
                     (let ((pV54 (svref decl 3))) 
                       (block 
                        nil 
                        (let ((pV56 (cdr (svref decl 2)))) 
                          (if (consp pV54) 
                              (return 
                               (let ((term 
                                      (SPECTOLISP::lispTerm 
                                       spc 
                                       pV64 
                                       (cdr (car pV54))))) 
                                 (let ((name 
                                        (SPECTOLISP::printPackageId 
                                         (cons :|Qualified| (cons qname name)) 
                                         pV64))) 
                                   (if (SPECTOLISP::functionSort? spc pV56) 
                                       (LIST-SPEC::|!++| 
                                        (let ((pV43 
                                               (ARITYNORMALIZE::sortArity 
                                                spc 
                                                pV56))
                                              (pV42 
                                               (SPECTOLISP::curryShapeNum 
                                                spc 
                                                pV56))) 
                                          (block 
                                           nil 
                                           (if ( =  1 pV42) 
                                               (if (eq (car pV43) :|None|) 
                                                   (return 
                                                    (block 
                                                     nil 
                                                     (if (eq 
                                                          (car term) 
                                                          :|Lambda|) 
                                                         (return 
                                                          (cons 
                                                           (cons name term) 
                                                           nil))) 
                                                     (return 
                                                      (cons 
                                                       (cons 
                                                        name 
                                                        (LISTADT::mkLLambda 
                                                         (cons "!x" nil) 
                                                         nil 
                                                         (LISTADT::mkLApply 
                                                          term 
                                                          (cons 
                                                           (LISTADT::mkLVar "!x") 
                                                           nil)))) 
                                                       nil)))) 
                                                   (if (eq (car pV43) :|Some|) 
                                                       (let ((pV49 
                                                              (cdr (cdr pV43)))) 
                                                         (return 
                                                          (let ((uName 
                                                                 (SPECTOLISP::unaryName 
                                                                  name))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car term) 
                                                                  :|Lambda|) 
                                                                 (return 
                                                                  (let ((n 
                                                                         (LIST-SPEC::|!length| 
                                                                          (svref 
                                                                           (cdr 
                                                                            term) 
                                                                           0)))) 
                                                                    (cons 
                                                                     (cons 
                                                                      name 
                                                                      (if ( =  
                                                                           n 
                                                                           pV49) 
                                                                          term 
                                                                          (SPECTOLISP::defNaryByUnary 
                                                                           uName 
                                                                           pV49))) 
                                                                     (cons 
                                                                      (cons 
                                                                       uName 
                                                                       (if ( =  
                                                                            n 
                                                                            pV49) 
                                                                           (SPECTOLISP::defUnaryByNary 
                                                                            name 
                                                                            n) 
                                                                           term)) 
                                                                      nil))))) 
                                                             (return 
                                                              (cons 
                                                               (cons 
                                                                name 
                                                                (SPECTOLISP::defNaryByUnary 
                                                                 uName 
                                                                 pV49)) 
                                                               (cons 
                                                                (cons 
                                                                 uName 
                                                                 (LISTADT::mkLLambda 
                                                                  (cons "!x" nil) 
                                                                  nil 
                                                                  (LISTADT::mkLApply 
                                                                   term 
                                                                   (cons 
                                                                    (LISTADT::mkLVar 
                                                                     "!x") 
                                                                    nil)))) 
                                                                nil)))))))))) 
                                           (if (eq (car pV43) :|None|) 
                                               (return 
                                                (let ((ucName 
                                                       (SPECTOLISP::unCurryName 
                                                        name 
                                                        pV42))) 
                                                  (let ((pV28 
                                                         (SPECTOLISP::unCurryDef 
                                                          term 
                                                          pV42))) 
                                                    (block 
                                                     nil 
                                                     (if (eq (car pV28) :|Some|) 
                                                         (return 
                                                          (cons 
                                                           (cons 
                                                            name 
                                                            (SPECTOLISP::defCurryByUncurry 
                                                             ucName 
                                                             pV42)) 
                                                           (cons 
                                                            (cons 
                                                             ucName 
                                                             (cdr pV28)) 
                                                            nil)))) 
                                                     (return 
                                                      (cons 
                                                       (cons name term) 
                                                       (cons 
                                                        (cons 
                                                         ucName 
                                                         (let ((pV26 
                                                                (SPECTOLISP::renameDef? 
                                                                 term))) 
                                                           (block 
                                                            nil 
                                                            (if (eq 
                                                                 (car pV26) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (SPECTOLISP::defAliasFn 
                                                                  (SPECTOLISP::unCurryName 
                                                                   (cdr pV26) 
                                                                   pV42) 
                                                                  pV42))) 
                                                            (return 
                                                             (SPECTOLISP::defUncurryByUnary 
                                                              name 
                                                              pV42))))) 
                                                        nil))))))) 
                                               (if (eq (car pV43) :|Some|) 
                                                   (let ((pV46 (cdr (cdr pV43)))) 
                                                     (return 
                                                      (let ((ucName 
                                                             (SPECTOLISP::unCurryName 
                                                              name 
                                                              pV42))) 
                                                        (let ((uName 
                                                               (SPECTOLISP::unaryName 
                                                                name))) 
                                                          (let ((pV40 
                                                                 (SPECTOLISP::unCurryDef 
                                                                  term 
                                                                  pV42))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV40) 
                                                                  :|Some|) 
                                                                 (return 
                                                                  (cons 
                                                                   (cons 
                                                                    name 
                                                                    (SPECTOLISP::defNaryByUnary 
                                                                     uName 
                                                                     pV46)) 
                                                                   (cons 
                                                                    (cons 
                                                                     uName 
                                                                     (SPECTOLISP::defCurryByUncurry 
                                                                      ucName 
                                                                      pV42)) 
                                                                    (cons 
                                                                     (cons 
                                                                      ucName 
                                                                      (cdr pV40)) 
                                                                     nil))))) 
                                                             (return 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car term) 
                                                                    :|Lambda|) 
                                                                   (return 
                                                                    (let ((n 
                                                                           (LIST-SPEC::|!length| 
                                                                            (svref 
                                                                             (cdr 
                                                                              term) 
                                                                             0)))) 
                                                                      (cons 
                                                                       (cons 
                                                                        name 
                                                                        (if ( =  
                                                                             n 
                                                                             pV46) 
                                                                            term 
                                                                            (SPECTOLISP::defNaryByUnary 
                                                                             uName 
                                                                             pV46))) 
                                                                       (cons 
                                                                        (cons 
                                                                         uName 
                                                                         (if ( =  
                                                                              n 
                                                                              pV46) 
                                                                             (SPECTOLISP::defUnaryByNary 
                                                                              name 
                                                                              n) 
                                                                             term)) 
                                                                        (cons 
                                                                         (cons 
                                                                          ucName 
                                                                          (SPECTOLISP::defUncurryByUnary 
                                                                           uName 
                                                                           pV42)) 
                                                                         nil)))))) 
                                                               (return 
                                                                (cons 
                                                                 (cons 
                                                                  name 
                                                                  (SPECTOLISP::defNaryByUnary 
                                                                   uName 
                                                                   pV46)) 
                                                                 (cons 
                                                                  (cons 
                                                                   uName 
                                                                   (LISTADT::mkLLambda 
                                                                    (cons 
                                                                     "!x" 
                                                                     nil) 
                                                                    nil 
                                                                    (LISTADT::mkLApply 
                                                                     term 
                                                                     (cons 
                                                                      (LISTADT::mkLVar 
                                                                       "!x") 
                                                                      nil)))) 
                                                                  (cons 
                                                                   (cons 
                                                                    ucName 
                                                                    (SPECTOLISP::defUncurryByUnary 
                                                                     uName 
                                                                     pV42)) 
                                                                   nil)))))))))))))) 
                                           (error 
                                            "Nonexhaustive match failure in lisp"))) 
                                        defs) 
                                       (LIST-SPEC::|!cons| (cons name term) defs))))))) 
                        (return defs))))) 
                   (let ((defs 
                          (foldriAQualifierMap-1-1-1 
                           #'(lambda (x) 
                              (mkLOpDef 
                               (svref x 0) 
                               (svref x 1) 
                               (svref x 2) 
                               (svref x 3))) 
                           nil 
                           (svref spc 1)))) 
                     (vector 
                      nil 
                      pV65 
                      pV64 
                      defs 
                      (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) defs)))))) 
              (error "Nonexhaustive match failure in lisp"))))))

(defun SPECTOLISP::toLispEnv-1 (spc) 
  (let ((spc (PATTERNMATCH::translateMatch-1 spc))) 
    (let ((spc (ARITYNORMALIZE::arityNormalize-1 spc))) 
      (let ((spc (SPECTOLISP::|!lisp|-1 spc))) spc))))

(defun SPECTOLISP::toLispFileEnv (spc file preamble) 
  (let ((spc (SPECTOLISP::toLispEnv-1 spc))) 
    (LISTADT::ppSpecToFile spc file preamble)))

(defun SPECTOLISP::toLispFile (spc file preamble) 
  (SPECTOLISP::toLispFileEnv spc file preamble))

(defun SPECCALC::evaluateLispCompile (pV8 pV9 pV10) 
  (block 
   nil 
   (return 
    (let ((pV6 (SPECCALC::coerceToSpec (svref pV8 0)))) 
      (block 
       nil 
       (if (eq (car pV6) :|Spec|) 
           (let ((pV7 (cdr pV6))) 
             (return 
              (SPECCALC::monadBind 
               (SPECCALC::getURI-1 pV9) 
               #'(lambda (cURI) 
                  (SPECCALC::monadBind 
                   (SPECCALC::URItoLispFile cURI pV10) 
                   #'(lambda (lispFileName) 
                      (SPECCALC::monadSeq 
                       (SPECCALC::|!print| 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          ";;; Generating lisp file " 
                          lispFileName) 
                         "
")) 
                       (progn (IO-SPEC::ensureDirectoriesExist lispFileName) 
                              (progn (SPECTOLISP::toLispFile 
                                      pV7 
                                      lispFileName 
                                      nil) 
                                     (SPECCALC::|!return| pV8))))))))))) 
       (return 
        (SPECCALC::raise 
         (cons 
          :|TypeCheck| 
          (cons 
           (SPECCALC::positionOf-1 pV9) 
           "attempting to generate code from an object that is not a specification"))))))) 
   (error "Nonexhaustive match failure in evaluateLispCompile")))

(defun SPECTOLISP::localDefsToLispFile (pV8 pV9 pV10) 
  (block 
   nil 
   (let ((pV17 (svref (svref pV8 0) 2))) 
     (return 
      (let ((spc 
             (setOps 
              pV8 
              (mapiAQualifierMap-1-1 
               #'(lambda (x) 
                  (let ((pV3 (svref x 2))) 
                    (block 
                     nil 
                     (return 
                      (if (memberQualifiedId (svref x 0) (svref x 1) pV17) 
                          pV3 
                          (vector (svref pV3 0) (svref pV3 1) (svref pV3 2) nil))) 
                     (error "Nonexhaustive match failure in localDefsToLispFile")))) 
               (svref pV8 1))))) (SPECTOLISP::toLispFile spc pV9 pV10)))) 
   (error "Nonexhaustive match failure in localDefsToLispFile")))

(defun SPECCALC::evaluateLispCompileLocal (pV8 pV9 pV10) 
  (block 
   nil 
   (return 
    (let ((pV6 (SPECCALC::coerceToSpec (svref pV8 0)))) 
      (block 
       nil 
       (if (eq (car pV6) :|Spec|) 
           (let ((pV7 (cdr pV6))) 
             (return 
              (SPECCALC::monadBind 
               (SPECCALC::getURI-1 pV9) 
               #'(lambda (cURI) 
                  (SPECCALC::monadBind 
                   (SPECCALC::URItoLispFile cURI pV10) 
                   #'(lambda (lispFileName) 
                      (SPECCALC::monadSeq 
                       (SPECCALC::|!print| 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          ";;; Generating lisp file " 
                          lispFileName) 
                         "
")) 
                       (progn (IO-SPEC::ensureDirectoriesExist lispFileName) 
                              (progn (SPECTOLISP::localDefsToLispFile 
                                      pV7 
                                      lispFileName 
                                      nil) 
                                     (SPECCALC::|!return| pV8))))))))))) 
       (return 
        (SPECCALC::raise 
         (cons 
          :|TypeCheck| 
          (cons 
           (SPECCALC::positionOf-1 pV9) 
           "attempting to generate code from an object that is not a specification"))))))) 
   (error "Nonexhaustive match failure in evaluateLispCompileLocal")))

(defun SPECCALC::evaluateOtherGenerate-1 (args) 
  #'(lambda (valueInfo) 
     #'(lambda (pos) 
        (SPECCALC::monadBind 
         #'SPECCALC::getCurrentURI-1 
         #'(lambda (uri) 
            (SPECCALC::raise 
             (cons 
              :|TypeCheck| 
              (cons 
               pos 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 "Unexpected OtherTerm at " 
                 (SPECCALC::uriToString-1 uri)) 
                "
")))))))))

(defun SPECCALC::evaluateOtherGenerate (x0 x1 x2) 
  (SPECCALC::evaluateOtherGenerate-1 (vector x0 x1 x2)))

(defun SPECCALC::ppLispCell (|!t|) 
  (PRETTYPRINT::|!string| (SYSTEM-SPEC::toString |!t|)))

(defun SPECCALC::ppSpec-1 (s) 
  (PRETTYPRINT::prettysAll 
   (LIST-SPEC::|!++| 
    (LIST-SPEC::|!++| 
     (LIST-SPEC::|!++| 
      (LISTADT::section 
       (STRING-SPEC::^ ";;; Snark spec: " (svref s 1)) 
       (cons 
        (PRETTYPRINT::|!string| 
         (STRING-SPEC::^ (STRING-SPEC::^ "(in-package \"" "SNARK") "\")")) 
        nil)) 
      (LISTADT::section 
       ";;; Sorts" 
       (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppLispCell (svref s 3)))) 
     (LISTADT::section 
      ";;; Ops" 
      (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppLispCell (svref s 2)))) 
    (LISTADT::section 
     ";;; Assertions" 
     (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppLispCell (svref s 0))))))

(defun SPECCALC::ppSpecToFile (spc file preamble) 
  (let ((p (SPECCALC::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
      (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble)))))

(defun SPECCALC::snarkName-1 (spc) 
  (let ((packages 
         (LIST-SPEC::|!map|-1-1 
          #'SPECTOLISP::mkLPackageId 
          (qualifiers (svref spc 1))))) 
    (let ((pV5 
           (block 
            nil 
            (if (consp packages) 
                (return (cons (car packages) (cdr packages))) 
                (if (null packages) 
                    (return (cons SPECTOLISP::defaultSpecwarePackage nil)))) 
            (error "Nonexhaustive match failure in snarkName")))) 
      (block 
       nil 
       (return (car pV5)) 
       (error "Nonexhaustive match failure in snarkName")))))

(defun SPECCALC::snarkProperties-1 (spc) 
  (let ((snarkProperties 
         (LIST-SPEC::|!map|-1-1 
          #'(lambda (prop) 
             (SPECCALC::snarkProperty SPECCALC::newContext spc prop)) 
          (svref spc 2)))) snarkProperties))

(defun SPECCALC::snarkSpec-1 (spc) 
  (vector 
   (SPECCALC::snarkProperties-1 spc) 
   (SPECCALC::snarkName-1 spc) 
   (SPECCALC::snarkOpDecls-1 spc) 
   (SPECCALC::snarkSorts-1 spc)))

(defun SPECCALC::toSnarkEnv-1 (spc) 
  (let ((spc (SPECCALC::snarkSpec-1 spc))) spc))

(defun SPECCALC::toSnarkFileEnv (spc file preamble) 
  (progn (STRING-SPEC::writeLine (STRING-SPEC::^ "Writing Snark file " file)) 
         (let ((spc (SPECCALC::toSnarkEnv-1 spc))) 
           (SPECCALC::ppSpecToFile spc file preamble))))

(defun SPECCALC::toSnarkFile (spc file preamble) 
  (SPECCALC::toSnarkFileEnv spc file preamble))

(defun SPECCALC::evaluateSnarkGen (pV11 pV12 pV13) 
  (block 
   nil 
   (let ((pV14 (svref pV11 0))) 
     (if (eq (car pV14) :|Spec|) 
         (let ((pV17 (cdr pV14))) 
           (return 
            (SPECCALC::monadBind 
             (SPECCALC::getURI-1 pV12) 
             #'(lambda (cURI) 
                (SPECCALC::monadBind 
                 (SPECCALC::URItoSnarkFile cURI pV13) 
                 #'(lambda (snarkFileName) 
                    (SPECCALC::monadBind 
                     (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                              (cons 
                               :|SpecPath_Relative| 
                               (cons 
                                '(:|None|) 
                                (cons "Library" (cons "Base" nil))))) 
                     #'(lambda (x) 
                        (let ((pV7 (svref x 0))) 
                          (block 
                           nil 
                           (if (eq (car pV7) :|Spec|) 
                               (return 
                                (progn (IO-SPEC::ensureDirectoriesExist 
                                        snarkFileName) 
                                       (progn (SPECCALC::toSnarkFile 
                                               (subtractSpec-1-1 pV17 (cdr pV7)) 
                                               snarkFileName 
                                               nil) 
                                              (SPECCALC::monadSeq 
                                               (SPECCALC::|!print| 
                                                "Translated to Snark") 
                                               (SPECCALC::|!return| pV11)))))) 
                           (error 
                            "Nonexhaustive match failure in evaluateSnarkGen"))))))))))))) 
   (error "Nonexhaustive match failure in evaluateSnarkGen")))

(defun SPECCALC::evaluateGenerate (pV13 pV14 pV15) 
  (block 
   nil 
   (return 
    #'(lambda (pos) 
       (SPECCALC::monadBind 
        (SPECCALC::evaluateTermInfo-1 pV14) 
        #'(lambda (x) 
           (let ((depURIs (svref x 2))
                 (timeStamp (svref x 1))
                 (value (svref x 0))) 
             (SPECCALC::monadBind 
              (SPECCALC::pathToRelativeURI "/Library/Base") 
              #'(lambda (baseURI) 
                 (SPECCALC::monadBind 
                  (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                           baseURI) 
                  #'(lambda (x1) 
                     (let ((pV9 (svref x1 0))) 
                       (block 
                        nil 
                        (if (eq (car pV9) :|Spec|) 
                            (let ((pV12 (cdr pV9))) 
                              (return 
                               (SPECCALC::monadBind 
                                (SPECCALC::|!return| 
                                 (SPECCALC::coerceToSpec value)) 
                                #'(lambda (cValue) 
                                   (block 
                                    nil 
                                    (if (eq (car cValue) :|Spec|) 
                                        (return 
                                         (block 
                                          nil 
                                          (if (string=  "lisp" pV13) 
                                              (return 
                                               (SPECCALC::evaluateLispCompile 
                                                (vector cValue timeStamp depURIs) 
                                                pV14 
                                                pV15)) 
                                              (if (string=  "lisp_local" pV13) 
                                                  (return 
                                                   (SPECCALC::evaluateLispCompileLocal 
                                                    (vector 
                                                     cValue 
                                                     timeStamp 
                                                     depURIs) 
                                                    pV14 
                                                    pV15)) 
                                                  (if (string=  "snark" pV13) 
                                                      (return 
                                                       (SPECCALC::evaluateSnarkGen 
                                                        (vector 
                                                         cValue 
                                                         timeStamp 
                                                         depURIs) 
                                                        pV14 
                                                        pV15)) 
                                                      (if (string=  "spec" pV13) 
                                                          (return 
                                                           (SPECCALC::monadSeq 
                                                            (SPECCALC::|!print| 
                                                             (SPECCALC::showValue 
                                                              cValue)) 
                                                            (SPECCALC::|!return| 
                                                             (vector 
                                                              cValue 
                                                              timeStamp 
                                                              depURIs)))) 
                                                          (if (string=  "c" pV13) 
                                                              (return 
                                                               (progn (CGEN::specToC-1 
                                                                       (subtractSpec-1-1 
                                                                        (cdr 
                                                                         cValue) 
                                                                        pV12)) 
                                                                      (SPECCALC::|!return| 
                                                                       (vector 
                                                                        cValue 
                                                                        timeStamp 
                                                                        depURIs)))) 
                                                              (if (string=  
                                                                   "java" 
                                                                   pV13) 
                                                                  (return 
                                                                   (SPECCALC::evaluateJavaGen 
                                                                    (vector 
                                                                     cValue 
                                                                     timeStamp 
                                                                     depURIs) 
                                                                    pV14 
                                                                    pV15)))))))) 
                                          (return 
                                           (SPECCALC::raise 
                                            (cons 
                                             :|Unsupported| 
                                             (cons 
                                              (SPECCALC::positionOf-1 pV14) 
                                              (STRING-SPEC::^ 
                                               (STRING-SPEC::^ 
                                                "no generation for language " 
                                                pV13) 
                                               " yet"))))))) 
                                        (if (eq (car cValue) :|Other|) 
                                            (return 
                                             (funcall (funcall (SPECCALC::evaluateOtherGenerate 
                                                                pV13 
                                                                pV14 
                                                                pV15) 
                                                               (vector 
                                                                (cdr cValue) 
                                                                timeStamp 
                                                                depURIs)) 
                                                      pos)))) 
                                    (return 
                                     (SPECCALC::raise 
                                      (cons 
                                       :|TypeCheck| 
                                       (cons 
                                        pos 
                                        "attempting to generate code from an object that is not a specification")))))))))) 
                        (error "Nonexhaustive match failure in evaluateGenerate")))))))))))) 
   (error "Nonexhaustive match failure in evaluateGenerate")))

(defun SPECCALC::evaluateGenerate-1 (x) 
  (SPECCALC::evaluateGenerate (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::evaluateLocalDecls (decls) 
  (labels 
    ((evaluateLocalDecl (name term) 
      (SPECCALC::monadBind 
       (SPECCALC::evaluateTermInfo-1 term) 
       #'(lambda (valueInfo) 
          (SPECCALC::monadSeq 
           (funcall (SPECCALC::bindInLocalContext 
                     (cons :|URI_Relative| (cons '(:|None|) (cons name nil)))) 
                    valueInfo) 
           (SPECCALC::|!return| nil)))))) 
    (funcall (funcall (SPECCALC::foldM 
                       #'(lambda (pV1) 
                          (declare (ignore pV1)) 
                          #'(lambda (decl) 
                             (evaluateLocalDecl (car decl) (cdr decl))))) 
                      nil) 
             decls)))

(defun SPECCALC::evaluateLet (decls) 
  #'(lambda (term) 
     (SPECCALC::monadBind 
      #'SPECCALC::getLocalContext-1 
      #'(lambda (context) 
         (SPECCALC::monadSeq 
          (SPECCALC::evaluateLocalDecls decls) 
          (SPECCALC::monadBind 
           (SPECCALC::evaluateTermInfo-1 term) 
           #'(lambda (valueInfo) 
              (SPECCALC::monadSeq 
               (SPECCALC::setLocalContext context) 
               (SPECCALC::|!return| valueInfo)))))))))

(defun SPECCALC::findUnitIdforUnit (val globalContext) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (result) 
      #'(lambda (uri) 
         #'(lambda (x) 
            (block 
             nil 
             (if (eq (car result) :|Some|) 
                 (return result) 
                 (if (eq (car result) :|None|) 
                     (return 
                      (if (slang-built-in::slang-term-equals val (svref x 0)) 
                          (cons :|Some| (cons (car uri) (cdr uri))) 
                          '(:|None|))))) 
             (error "Nonexhaustive match failure in findUnitIdforUnit"))))) 
   '(:|None|) 
   globalContext))

(defun SPECCALC::translateTerm (tm sortMap opMap) 
  (labels 
    ((translateTerm (trm) 
      (block 
       nil 
       (if (eq (car trm) :|Fun|) 
           (let ((pV12 (cdr trm))) 
             (let ((pV13 (svref pV12 0))) 
               (if (eq (car pV13) :|Op|) 
                   (let ((pV16 (cdr pV13))) 
                     (return 
                      (cons 
                       :|Fun| 
                       (vector 
                        (cons 
                         :|Op| 
                         (cons (funcall (findName opMap) (car pV16)) (cdr pV16))) 
                        (svref pV12 1) 
                        (svref pV12 2))))))))) 
       (return trm)))
     (translateSort (srt) 
      (block 
       nil 
       (if (eq (car srt) :|Base|) 
           (let ((pV6 (cdr srt))) 
             (return 
              (cons 
               :|Base| 
               (vector 
                (funcall (findName sortMap) (svref pV6 0)) 
                (svref pV6 1) 
                (svref pV6 2)))))) 
       (return srt)))
     (findName (m) 
      #'(lambda (|!QId|) 
         (let ((pV2 (POLYMAP::evalPartial-1-1 m |!QId|))) 
           (block 
            nil 
            (if (eq (car pV2) :|Some|) (return (cdr pV2))) 
            (return |!QId|)))))) 
    (METASLANG::mapTerm-1-1 
     (vector #'translateTerm #'translateSort #'FUNCTIONS::id) 
     tm)))

(defun SPECCALC::morphismObligations (pV9 pV10) 
  (block 
   nil 
   (let ((pV14 (svref pV9 3))
         (pV13 (svref pV9 2))
         (pV11 (svref pV9 0))) 
     (return 
      (let ((translated_dom_axioms 
             (LIST-SPEC::mapPartial-1-1 
              #'(lambda (prop) 
                 (block 
                  nil 
                  (if (eq (car (svref prop 0)) :|Axiom|) 
                      (return 
                       (cons 
                        :|Some| 
                        (vector 
                         '(:|Conjecture|) 
                         (svref prop 1) 
                         (svref prop 2) 
                         (SPECCALC::translateTerm (svref prop 3) pV14 pV13))))) 
                  (return '(:|None|)))) 
              (svref (svref pV9 1) 2)))) 
        (let ((import_of_cod 
               (vector 
                (cons 
                 :|Some| 
                 (vector 
                  (svref pV11 0) 
                  (svref pV11 1) 
                  (svref pV11 2) 
                  (svref pV11 3))) 
                (let ((pV7 
                       (SPECCALC::findUnitIdforUnit 
                        (cons 
                         :|Spec| 
                         (vector 
                          (svref pV11 0) 
                          (svref pV11 1) 
                          (svref pV11 2) 
                          (svref pV11 3))) 
                        pV10))) 
                  (block 
                   nil 
                   (if (eq (car pV7) :|Some|) 
                       (return 
                        (cons (cons (SPECCALC::showURI-1 (cdr pV7)) pV11) nil))) 
                   (return nil))) 
                emptyOpNames 
                emptySortNames))) 
          (let ((ob_spc 
                 (vector 
                  import_of_cod 
                  (svref pV11 1) 
                  (LIST-SPEC::|!++| (svref pV11 2) translated_dom_axioms) 
                  (svref pV11 3)))) ob_spc))))) 
   (error "Nonexhaustive match failure in morphismObligations")))

(defun TYPEOBLIGATIONS::??-1 (x) x)

(defun TYPEOBLIGATIONS::?? (x0 x1) (TYPEOBLIGATIONS::??-1 (cons x0 x1)))

(defparameter STANDARDSPEC::unaryBoolSort 
  (STANDARDSPEC::mkArrow STANDARDSPEC::boolSort STANDARDSPEC::boolSort))

(defparameter STANDARDSPEC::notOp 
  (STANDARDSPEC::mkOp 
   (cons :|Qualified| (cons "Boolean" "~")) 
   STANDARDSPEC::unaryBoolSort))

(defun STANDARDSPEC::mkNot (trm) 
  (STANDARDSPEC::mkApply STANDARDSPEC::notOp trm))

(defparameter STANDARDSPEC::binaryBoolSort 
  (STANDARDSPEC::mkArrow 
   (STANDARDSPEC::mkProduct 
    (cons STANDARDSPEC::boolSort (cons STANDARDSPEC::boolSort nil))) 
   STANDARDSPEC::boolSort))

(defun STANDARDSPEC::mkInfixOp (qid fixity srt) 
  (STANDARDSPEC::mkFun (cons :|Op| (cons qid fixity)) srt))

(defparameter STANDARDSPEC::impliesOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "=>")) 
   (cons '(:|Right|) 13) 
   STANDARDSPEC::binaryBoolSort))

(defun STANDARDSPEC::mkImplies (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::impliesOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))

(defun UTILITIES::isPatBound (v pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV19 (cdr pat))) 
         (return 
          (cl:or 
           (UTILITIES::isPatBound v (svref pV19 0)) 
           (UTILITIES::isPatBound v (svref pV19 1))))) 
       (if (eq (car pat) :|EmbedPat|) 
           (let ((pV31 (svref (cdr pat) 1))) 
             (if (eq (car pV31) :|Some|) 
                 (return (UTILITIES::isPatBound v (cdr pV31))))) 
           (if (eq (car pat) :|VarPat|) 
               (return (slang-built-in::slang-term-equals v (car (cdr pat)))) 
               (if (eq (car pat) :|RecordPat|) 
                   (return 
                    (LIST-SPEC::|!exists|-1-1 
                     #'(lambda (x) (UTILITIES::isPatBound v (cdr x))) 
                     (car (cdr pat)))) 
                   (if (eq (car pat) :|RelaxPat|) 
                       (return (UTILITIES::isPatBound v (svref (cdr pat) 0))) 
                       (if (eq (car pat) :|QuotientPat|) 
                           (return (UTILITIES::isPatBound v (svref (cdr pat) 0))))))))) 
   (return nil)))

(defun UTILITIES::isFree (v term) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (return (slang-built-in::slang-term-equals v (car (cdr term)))) 
       (if (eq (car term) :|Apply|) 
           (let ((pV23 (cdr term))) 
             (return 
              (cl:or 
               (UTILITIES::isFree v (svref pV23 0)) 
               (UTILITIES::isFree v (svref pV23 1))))) 
           (if (eq (car term) :|Record|) 
               (return 
                (LIST-SPEC::|!exists|-1-1 
                 #'(lambda (x) (UTILITIES::isFree v (cdr x))) 
                 (car (cdr term)))) 
               (if (eq (car term) :|Fun|) 
                   (return nil) 
                   (if (eq (car term) :|Lambda|) 
                       (return 
                        (LIST-SPEC::|!exists|-1-1 
                         #'(lambda (x) 
                            (cl:and 
                             (BOOLEAN-SPEC::~ 
                              (UTILITIES::isPatBound v (svref x 0))) 
                             (cl:or 
                              (UTILITIES::isFree v (svref x 1)) 
                              (UTILITIES::isFree v (svref x 2))))) 
                         (car (cdr term)))) 
                       (if (eq (car term) :|Let|) 
                           (let ((pV19 (cdr term))) 
                             (let ((pV36 (svref pV19 0))) 
                               (return 
                                (cl:or 
                                 (LIST-SPEC::|!exists|-1-1 
                                  #'(lambda (x) (UTILITIES::isFree v (cdr x))) 
                                  pV36) 
                                 (cl:and 
                                  (LIST-SPEC::all-1-1 
                                   #'(lambda (x) 
                                      (BOOLEAN-SPEC::~ 
                                       (UTILITIES::isPatBound v (car x)))) 
                                   pV36) 
                                  (UTILITIES::isFree v (svref pV19 1))))))) 
                           (if (eq (car term) :|LetRec|) 
                               (let ((pV18 (cdr term))) 
                                 (let ((pV33 (svref pV18 0))) 
                                   (return 
                                    (cl:and 
                                     (LIST-SPEC::all-1-1 
                                      #'(lambda (x) 
                                         (BOOLEAN-SPEC::~ 
                                          (slang-built-in::slang-term-equals 
                                           v 
                                           (car x)))) 
                                      pV33) 
                                     (cl:or 
                                      (LIST-SPEC::|!exists|-1-1 
                                       #'(lambda (x) 
                                          (UTILITIES::isFree v (cdr x))) 
                                       pV33) 
                                      (UTILITIES::isFree v (svref pV18 1))))))) 
                               (if (eq (car term) :|Bind|) 
                                   (let ((pV17 (cdr term))) 
                                     (return 
                                      (cl:and 
                                       (LIST-SPEC::all-1-1 
                                        #'(lambda (w) 
                                           (BOOLEAN-SPEC::~ 
                                            (slang-built-in::slang-term-equals 
                                             v 
                                             w))) 
                                        (svref pV17 1)) 
                                       (UTILITIES::isFree v (svref pV17 2))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV16 (cdr term))) 
                                         (return 
                                          (cl:or 
                                           (UTILITIES::isFree v (svref pV16 0)) 
                                           (cl:or 
                                            (UTILITIES::isFree v (svref pV16 1)) 
                                            (UTILITIES::isFree v (svref pV16 2))))))))))))))) 
   (error "Nonexhaustive match failure in isFree")))

(defun TYPEOBLIGATIONS::makeVerificationCondition (pV14 pV15) 
  (block 
   nil 
   (let ((pV19 (svref pV14 3))
         (pV17 (svref pV14 1))
         (pV16 (svref pV14 0))) 
     (return 
      (labels 
        ((insert (decl formula) 
          (block 
           nil 
           (if (eq (car decl) :|Var|) 
               (let ((pV8 (cdr decl))) 
                 (return 
                  (if (UTILITIES::isFree pV8 formula) 
                      (STANDARDSPEC::mkBind '(:|Forall|) (cons pV8 nil) formula) 
                      formula))) 
               (if (eq (car decl) :|Cond|) 
                   (let ((pV7 (cdr decl))) 
                     (progn (if (eq (car pV7) :|Fun|) 
                                (let ((pV10 (svref (cdr pV7) 0))) 
                                  (if (eq (car pV10) :|Bool|) 
                                      (if (eq t (cdr pV10)) (return formula))))) 
                            (return (STANDARDSPEC::mkImplies pV7 formula)))) 
                   (if (eq (car decl) :|Let|) 
                       (return 
                        (cons 
                         :|Let| 
                         (vector (cdr decl) formula POSITION-SPEC::noPos))) 
                       (if (eq (car decl) :|LetRec|) 
                           (return 
                            (cons 
                             :|LetRec| 
                             (vector (cdr decl) formula POSITION-SPEC::noPos))))))) 
           (error "Nonexhaustive match failure in makeVerificationCondition")))) 
        (let ((term 
               (LIST-SPEC::foldl-1-1-1 
                #'(lambda (x) (insert (car x) (cdr x))) 
                pV15 
                pV16))) (vector pV19 pV17 term))))) 
   (error "Nonexhaustive match failure in makeVerificationCondition")))

(defun TYPEOBLIGATIONS::addCondition (tcc gamma term) 
  (LIST-SPEC::|!cons| 
   (TYPEOBLIGATIONS::makeVerificationCondition gamma term) 
   tcc))

(defun TYPEOBLIGATIONS::assertCond (pV1 pV2) 
  (block 
   nil 
   (return 
    (vector 
     (LIST-SPEC::|!cons| (cons :|Cond| pV1) (svref pV2 0)) 
     (svref pV2 1) 
     (svref pV2 2) 
     (svref pV2 3) 
     (svref pV2 4))) 
   (error "Nonexhaustive match failure in assertCond")))

(defun TYPEOBLIGATIONS::freshName (pV3 pV4) 
  (block 
   nil 
   (return (let ((name (STRINGUTILITIES::freshName pV4 (svref pV3 4)))) name)) 
   (error "Nonexhaustive match failure in freshName")))

(defun TYPEOBLIGATIONS::getSpec (pV1 pV2 e pV3 pV4) 
  (declare (ignore pV1 pV2 pV3 pV4)) 
  e)

(defun TYPEOBLIGATIONS::getSpec-1 (x) 
  (TYPEOBLIGATIONS::getSpec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPEOBLIGATIONS::mkLetOrApply (fntm arg) 
  (block 
   nil 
   (if (eq (car fntm) :|Lambda|) 
       (let ((pV14 (car (cdr fntm)))) 
         (if (consp pV14) 
             (let ((pV17 (car pV14))) 
               (let ((pV20 (svref pV17 1))
                     (pV19 (svref pV17 0))) 
                 (if (eq (car pV19) :|VarPat|) 
                     (let ((pV23 (car (cdr pV19)))) 
                       (if (eq (car pV20) :|Fun|) 
                           (let ((pV26 (svref (cdr pV20) 0))) 
                             (if (eq (car pV26) :|Bool|) 
                                 (if (eq t (cdr pV26)) 
                                     (if (null (cdr pV14)) 
                                         (return 
                                          (METASLANG::mapTerm-1-1 
                                           (vector 
                                            #'(lambda (tm) 
                                               (block 
                                                nil 
                                                (if (eq (car tm) :|Var|) 
                                                    (return 
                                                     (if (slang-built-in::slang-term-equals 
                                                          (car (cdr tm)) 
                                                          pV23) 
                                                         arg 
                                                         tm))) 
                                                (return tm))) 
                                            #'FUNCTIONS::id 
                                            #'FUNCTIONS::id) 
                                           (svref pV17 2))))))))))))))) 
   (return (cons :|Apply| (vector fntm arg POSITION-SPEC::noPos)))))

(defun TYPEOBLIGATIONS::assertSubtypeCond (term srt gamma) 
  (block 
   nil 
   (if (eq (car srt) :|Subsort|) 
       (let ((pV10 (cdr srt))) 
         (return 
          (block 
           nil 
           (return 
            (TYPEOBLIGATIONS::assertSubtypeCond 
             term 
             (svref pV10 0) 
             (vector 
              (LIST-SPEC::|!cons| 
               (cons :|Cond| (TYPEOBLIGATIONS::mkLetOrApply (svref pV10 1) term)) 
               (svref gamma 0)) 
              (svref gamma 1) 
              (svref gamma 2) 
              (svref gamma 3) 
              (svref gamma 4)))) 
           (error "Nonexhaustive match failure in assertSubtypeCond"))))) 
   (return gamma)))

(defun TYPEOBLIGATIONS::insert (pV1 pV2) 
  (block 
   nil 
   (let ((pV4 (cdr pV1))
         (pV3 (car pV1))) 
     (return 
      (let ((ds (LIST-SPEC::|!cons| (cons :|Var| (cons pV3 pV4)) (svref pV2 0)))) 
        (let ((gamma 
               (vector 
                ds 
                (svref pV2 1) 
                (svref pV2 2) 
                (svref pV2 3) 
                (svref pV2 4)))) 
          (let ((gamma 
                 (TYPEOBLIGATIONS::assertSubtypeCond 
                  (cons :|Var| (cons (cons pV3 pV4) POSITION-SPEC::noPos)) 
                  pV4 
                  gamma))) gamma))))) 
   (error "Nonexhaustive match failure in insert")))

(defun TYPEOBLIGATIONS::unfoldBase (pV5 pV6) 
  (block 
   nil 
   (return (SPECENVIRONMENT::unfoldBase (svref pV5 2) pV6)) 
   (error "Nonexhaustive match failure in unfoldBase")))

(defun TYPEOBLIGATIONS::returnPatternRec (pairs gamma |!M| tau sigma) 
  (if (cl:or 
       (slang-built-in::slang-term-equals tau sigma) 
       (LIST-SPEC::|!exists|-1-1 
        #'(lambda (p) (slang-built-in::slang-term-equals p (cons tau sigma))) 
        pairs)) 
      (cons gamma |!M|) 
      (let ((pairs (LIST-SPEC::|!cons| (cons tau sigma) pairs))) 
        (let ((tau1 (TYPEOBLIGATIONS::unfoldBase gamma tau))) 
          (let ((sigma1 (TYPEOBLIGATIONS::unfoldBase gamma sigma))) 
            (if (slang-built-in::slang-term-equals tau1 sigma1) 
                (cons gamma |!M|) 
                (block 
                 nil 
                 (if (eq (car tau1) :|Subsort|) 
                     (let ((pV11 (cdr tau1))) 
                       (return 
                        (let ((gamma 
                               (TYPEOBLIGATIONS::assertCond 
                                (TYPEOBLIGATIONS::mkLetOrApply 
                                 (svref pV11 1) 
                                 |!M|) 
                                gamma))) 
                          (TYPEOBLIGATIONS::returnPatternRec 
                           pairs 
                           gamma 
                           |!M| 
                           (svref pV11 0) 
                           sigma1))))) 
                 (return 
                  (block 
                   nil 
                   (if (eq (car sigma1) :|Subsort|) 
                       (let ((pV6 (cdr sigma1))) 
                         (return 
                          (let ((gamma 
                                 (TYPEOBLIGATIONS::assertCond 
                                  (TYPEOBLIGATIONS::mkLetOrApply 
                                   (svref pV6 1) 
                                   |!M|) 
                                  gamma))) 
                            (TYPEOBLIGATIONS::returnPatternRec 
                             pairs 
                             gamma 
                             |!M| 
                             tau1 
                             (svref pV6 0)))))) 
                   (return (cons gamma |!M|)))))))))))

(defun TYPEOBLIGATIONS::returnPattern (gamma |!t| tau1 tau2) 
  (TYPEOBLIGATIONS::returnPatternRec nil gamma |!t| tau1 tau2))

(defun TYPEOBLIGATIONS::bindPattern (gamma pat tau) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV64 (cdr pat))) 
         (return 
          (let ((pV5 (TYPEOBLIGATIONS::bindPattern gamma (svref pV64 0) tau))) 
            (block 
             nil 
             (let ((pV7 (cdr pV5))) 
               (return 
                (let ((pV2 
                       (TYPEOBLIGATIONS::bindPattern 
                        (car pV5) 
                        (svref pV64 1) 
                        tau))) 
                  (block 
                   nil 
                   (return 
                    (let ((gamma 
                           (TYPEOBLIGATIONS::assertCond 
                            (STANDARDSPEC::mkEquality tau pV7 (cdr pV2)) 
                            (car pV2)))) (cons gamma pV7))) 
                   (error "Nonexhaustive match failure in bindPattern"))))) 
             (error "Nonexhaustive match failure in bindPattern"))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV88 (car (cdr pat)))) 
             (return 
              (let ((gamma1 (TYPEOBLIGATIONS::insert pV88 gamma))) 
                (TYPEOBLIGATIONS::returnPattern 
                 gamma1 
                 (cons :|Var| (cons pV88 POSITION-SPEC::noPos)) 
                 (cdr pV88) 
                 tau)))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV62 (cdr pat))) 
                 (let ((pV85 (svref pV62 2))
                       (pV84 (svref pV62 1))
                       (pV83 (svref pV62 0))) 
                   (if (eq (car pV84) :|Some|) 
                       (let ((pV87 (cdr pV84))) 
                         (return 
                          (let ((tau1 (METASLANG::patternSort pV87))) 
                            (let ((pV11 
                                   (TYPEOBLIGATIONS::bindPattern gamma pV87 tau1))) 
                              (block 
                               nil 
                               (return 
                                (TYPEOBLIGATIONS::returnPattern 
                                 (car pV11) 
                                 (cons 
                                  :|Apply| 
                                  (vector 
                                   (cons 
                                    :|Fun| 
                                    (vector 
                                     (cons :|Embed| (cons pV83 t)) 
                                     (cons 
                                      :|Arrow| 
                                      (vector tau1 pV85 POSITION-SPEC::noPos)) 
                                     POSITION-SPEC::noPos)) 
                                   (cdr pV11) 
                                   POSITION-SPEC::noPos)) 
                                 pV85 
                                 tau)) 
                               (error 
                                "Nonexhaustive match failure in bindPattern")))))) 
                       (if (eq (car pV84) :|None|) 
                           (return 
                            (TYPEOBLIGATIONS::returnPattern 
                             gamma 
                             (cons 
                              :|Fun| 
                              (vector 
                               (cons :|Embed| (cons pV83 nil)) 
                               pV85 
                               POSITION-SPEC::noPos)) 
                             pV85 
                             tau)))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (return 
                    (let ((fs 
                           (SPECENVIRONMENT::product 
                            (TYPEOBLIGATIONS::getSpec-1 gamma) 
                            tau))) 
                      (let ((fields (LISTPAIR::zip fs (car (cdr pat))))) 
                        (let ((pV30 
                               (LIST-SPEC::foldr-1-1-1 
                                #'(lambda (x) 
                                   (let ((pV21 (cdr x))
                                         (pV20 (car x))) 
                                     (block 
                                      nil 
                                      (let ((pV23 (cdr pV20))) 
                                        (return 
                                         (let ((pV17 
                                                (TYPEOBLIGATIONS::bindPattern 
                                                 (car pV21) 
                                                 (cdr pV23) 
                                                 (cdr (car pV20))))) 
                                           (block 
                                            nil 
                                            (return 
                                             (cons 
                                              (car pV17) 
                                              (LIST-SPEC::|!cons| 
                                               (cons (car pV23) (cdr pV17)) 
                                               (cdr pV21)))) 
                                            (error 
                                             "Nonexhaustive match failure in bindPattern"))))) 
                                      (error 
                                       "Nonexhaustive match failure in bindPattern")))) 
                                (cons gamma nil) 
                                fields))) 
                          (block 
                           nil 
                           (return 
                            (TYPEOBLIGATIONS::returnPattern 
                             (car pV30) 
                             (cons 
                              :|Record| 
                              (cons (cdr pV30) POSITION-SPEC::noPos)) 
                             (METASLANG::patternSort pat) 
                             tau)) 
                           (error "Nonexhaustive match failure in bindPattern")))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (return 
                        (let ((v (TYPEOBLIGATIONS::freshName gamma "v"))) 
                          (let ((v (cons v (car (cdr pat))))) 
                            (let ((gamma1 (TYPEOBLIGATIONS::insert v gamma))) 
                              (cons 
                               gamma1 
                               (cons :|Var| (cons v POSITION-SPEC::noPos))))))) 
                       (if (eq (car pat) :|StringPat|) 
                           (return 
                            (TYPEOBLIGATIONS::returnPattern 
                             gamma 
                             (cons 
                              :|Fun| 
                              (vector 
                               (cons :|String| (car (cdr pat))) 
                               STANDARDSPEC::stringSort 
                               POSITION-SPEC::noPos)) 
                             STANDARDSPEC::stringSort 
                             tau)) 
                           (if (eq (car pat) :|BoolPat|) 
                               (return 
                                (TYPEOBLIGATIONS::returnPattern 
                                 gamma 
                                 (cons 
                                  :|Fun| 
                                  (vector 
                                   (cons :|Bool| (car (cdr pat))) 
                                   STANDARDSPEC::boolSort 
                                   POSITION-SPEC::noPos)) 
                                 STANDARDSPEC::boolSort 
                                 tau)) 
                               (if (eq (car pat) :|CharPat|) 
                                   (return 
                                    (TYPEOBLIGATIONS::returnPattern 
                                     gamma 
                                     (cons 
                                      :|Fun| 
                                      (vector 
                                       (cons :|Char| (car (cdr pat))) 
                                       STANDARDSPEC::charSort 
                                       POSITION-SPEC::noPos)) 
                                     STANDARDSPEC::charSort 
                                     tau)) 
                                   (if (eq (car pat) :|NatPat|) 
                                       (return 
                                        (TYPEOBLIGATIONS::returnPattern 
                                         gamma 
                                         (cons 
                                          :|Fun| 
                                          (vector 
                                           (cons :|Nat| (car (cdr pat))) 
                                           STANDARDSPEC::natSort 
                                           POSITION-SPEC::noPos)) 
                                         STANDARDSPEC::natSort 
                                         tau)) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (let ((pV55 (cdr pat))) 
                                             (return 
                                              (let ((tau1 
                                                     (cons 
                                                      :|Subsort| 
                                                      (vector 
                                                       tau 
                                                       (svref pV55 1) 
                                                       POSITION-SPEC::noPos)))) 
                                                (let ((pV39 
                                                       (TYPEOBLIGATIONS::bindPattern 
                                                        gamma 
                                                        (svref pV55 0) 
                                                        tau1))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (cons 
                                                     (car pV39) 
                                                     (cons 
                                                      :|Apply| 
                                                      (vector 
                                                       (cons 
                                                        :|Fun| 
                                                        (vector 
                                                         '(:|Relax|) 
                                                         (cons 
                                                          :|Arrow| 
                                                          (vector 
                                                           tau1 
                                                           tau 
                                                           POSITION-SPEC::noPos)) 
                                                         POSITION-SPEC::noPos)) 
                                                       (cdr pV39) 
                                                       POSITION-SPEC::noPos)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in bindPattern")))))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (return 
                                                (block 
                                                 nil 
                                                 (if (eq (car tau) :|Quotient|) 
                                                     (let ((pV50 
                                                            (svref (cdr tau) 0))) 
                                                       (return 
                                                        (let ((pV45 
                                                               (TYPEOBLIGATIONS::bindPattern 
                                                                gamma 
                                                                (svref 
                                                                 (cdr pat) 
                                                                 0) 
                                                                pV50))) 
                                                          (block 
                                                           nil 
                                                           (return 
                                                            (cons 
                                                             (car pV45) 
                                                             (cons 
                                                              :|Apply| 
                                                              (vector 
                                                               (cons 
                                                                :|Fun| 
                                                                (vector 
                                                                 '(:|Quotient|) 
                                                                 (cons 
                                                                  :|Arrow| 
                                                                  (vector 
                                                                   pV50 
                                                                   tau 
                                                                   POSITION-SPEC::noPos)) 
                                                                 POSITION-SPEC::noPos)) 
                                                               (cdr pV45) 
                                                               POSITION-SPEC::noPos)))) 
                                                           (error 
                                                            "Nonexhaustive match failure in bindPattern")))))) 
                                                 (error 
                                                  "Nonexhaustive match failure in bindPattern")))))))))))))) 
   (error "Nonexhaustive match failure in bindPattern")))

(defun TYPEOBLIGATIONS::checkRule-1-1 (!x1 x) 
  (let ((pV5 (car x))) 
    (block 
     nil 
     (let ((pV8 (svref pV5 1))) 
       (return 
        (let ((pV2 
               (TYPEOBLIGATIONS::bindPattern 
                (svref !x1 0) 
                (svref pV5 0) 
                (svref !x1 1)))) 
          (block 
           nil 
           (let ((pV3 (car pV2))) 
             (return 
              (let ((tcc 
                     (TYPEOBLIGATIONS::\|- 
                      (cons (cdr x) pV3) 
                      (TYPEOBLIGATIONS::?? pV8 STANDARDSPEC::boolSort)))) 
                (let ((gamma2 (TYPEOBLIGATIONS::assertCond pV8 pV3))) 
                  (let ((tcc 
                         (TYPEOBLIGATIONS::\|- 
                          (cons tcc gamma2) 
                          (TYPEOBLIGATIONS::?? (svref pV5 2) (svref !x1 2))))) 
                    tcc))))) 
           (error "Nonexhaustive match failure in checkRule"))))) 
     (error "Nonexhaustive match failure in checkRule"))))

(defun TYPEOBLIGATIONS::checkRule-1 (x1) 
  #'(lambda (x2) (TYPEOBLIGATIONS::checkRule-1-1 x1 x2)))

(defun TYPEOBLIGATIONS::checkRule (x0 x1 x2) 
  (TYPEOBLIGATIONS::checkRule-1 (vector x0 x1 x2)))

(defun TYPEOBLIGATIONS::insert-1 (x) (TYPEOBLIGATIONS::insert (car x) (cdr x)))

(defparameter STANDARDSPEC::andOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "&")) 
   (cons '(:|Right|) 15) 
   STANDARDSPEC::binaryBoolSort))

(defun STANDARDSPEC::mkAnd (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::andOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))

(defun UTILITIES::mkAnd (t1 t2) 
  (block 
   nil 
   (if (eq (car t1) :|Fun|) 
       (let ((pV22 (svref (cdr t1) 0))) 
         (if (eq (car pV22) :|Bool|) 
             (let ((pV25 (cdr pV22))) 
               (if (eq t pV25) (return t2) (if (eq nil pV25) (return t1))))))) 
   (if (eq (car t2) :|Fun|) 
       (let ((pV17 (svref (cdr t2) 0))) 
         (if (eq (car pV17) :|Bool|) 
             (let ((pV20 (cdr pV17))) 
               (if (eq t pV20) (return t1) (if (eq nil pV20) (return t2))))))) 
   (return (STANDARDSPEC::mkAnd t1 t2))))

(defparameter STANDARDSPEC::orOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "or")) 
   (cons '(:|Right|) 14) 
   STANDARDSPEC::binaryBoolSort))

(defun STANDARDSPEC::mkOr (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::orOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))

(defun UTILITIES::mkOr (t1 t2) 
  (block 
   nil 
   (if (eq (car t1) :|Fun|) 
       (let ((pV22 (svref (cdr t1) 0))) 
         (if (eq (car pV22) :|Bool|) 
             (let ((pV25 (cdr pV22))) 
               (if (eq t pV25) (return t1) (if (eq nil pV25) (return t2))))))) 
   (if (eq (car t2) :|Fun|) 
       (let ((pV17 (svref (cdr t2) 0))) 
         (if (eq (car pV17) :|Bool|) 
             (let ((pV20 (cdr pV17))) 
               (if (eq t pV20) (return t2) (if (eq nil pV20) (return t1))))))) 
   (return (STANDARDSPEC::mkOr t1 t2))))

(defun UTILITIES::mkIfThenElse (t1 t2 t3) 
  (block 
   nil 
   (if (eq (car t2) :|Fun|) 
       (let ((pV19 (svref (cdr t2) 0))) 
         (if (eq (car pV19) :|Bool|) 
             (let ((pV22 (cdr pV19))) 
               (if (eq t pV22) 
                   (return (UTILITIES::mkOr t1 t3)) 
                   (if (eq nil pV22) 
                       (return (UTILITIES::mkAnd (STANDARDSPEC::mkNot t1) t3)))))))) 
   (return 
    (block 
     nil 
     (if (eq (car t2) :|Fun|) 
         (let ((pV13 (svref (cdr t2) 0))) 
           (if (eq (car pV13) :|Bool|) 
               (let ((pV16 (cdr pV13))) 
                 (if (eq t pV16) 
                     (return (UTILITIES::mkOr (STANDARDSPEC::mkNot t1) t2)) 
                     (if (eq nil pV16) (return (UTILITIES::mkAnd t1 t2)))))))) 
     (return (cons :|IfThenElse| (vector t1 t2 t3 POSITION-SPEC::noPos)))))))

(defun TYPEOBLIGATIONS::simplifyMatch (trm) 
  (block 
   nil 
   (if (eq (car trm) :|IfThenElse|) 
       (let ((pV24 (cdr trm))) 
         (return 
          (let ((t2 (TYPEOBLIGATIONS::simplifyMatch (svref pV24 1)))) 
            (let ((t3 (TYPEOBLIGATIONS::simplifyMatch (svref pV24 2)))) 
              (UTILITIES::mkIfThenElse (svref pV24 0) t2 t3))))) 
       (if (eq (car trm) :|Apply|) 
           (let ((pV23 (cdr trm))) 
             (let ((pV29 (svref pV23 1))
                   (pV28 (svref pV23 0))) 
               (if (eq (car pV28) :|Fun|) 
                   (let ((pV32 (svref (cdr pV28) 0))) 
                     (if (eq (car pV32) :|Op|) 
                         (let ((pV36 (car (cdr pV32)))) 
                           (if (eq (car pV36) :|Qualified|) 
                               (let ((pV38 (cdr pV36))) 
                                 (if (string=  "TranslationBuiltIn" (car pV38)) 
                                     (if (string=  "failWith" (cdr pV38)) 
                                         (if (eq (car pV29) :|Record|) 
                                             (let ((pV42 (car (cdr pV29)))) 
                                               (if (consp pV42) 
                                                   (let ((pV46 (cdr pV42))) 
                                                     (if (consp pV46) 
                                                         (if (null (cdr pV46)) 
                                                             (return 
                                                              (let ((t1 
                                                                     (TYPEOBLIGATIONS::simplifyMatch 
                                                                      (cdr 
                                                                       (car pV42))))) 
                                                                (let ((t2 
                                                                       (TYPEOBLIGATIONS::simplifyMatch 
                                                                        (cdr 
                                                                         (car 
                                                                          pV46))))) 
                                                                  (UTILITIES::mkOr 
                                                                   t1 
                                                                   t2)))))))))))))))))))) 
           (if (eq (car trm) :|Let|) 
               (let ((pV22 (cdr trm))) 
                 (return 
                  (let ((trm1 (TYPEOBLIGATIONS::simplifyMatch (svref pV22 1)))) 
                    (block 
                     nil 
                     (if (eq (car trm1) :|Fun|) 
                         (if (eq (car (svref (cdr trm1) 0)) :|Bool|) 
                             (return trm1))) 
                     (return 
                      (cons 
                       :|Let| 
                       (vector (svref pV22 0) trm1 POSITION-SPEC::noPos)))))))))) 
   (return trm)))

(defun TYPEOBLIGATIONS::addFailure (pV5 pV6 pV7) 
  (block 
   nil 
   (return 
    (LIST-SPEC::|!cons| 
     (vector 
      (STRING-SPEC::^ (STRING-SPEC::^ (svref pV6 3) " :") pV7) 
      nil 
      (STANDARDSPEC::mkFalse)) 
     pV5)) 
   (error "Nonexhaustive match failure in addFailure")))

(defun TYPEOBLIGATIONS::subtypeRec (pairs tcc gamma |!M| tau sigma) 
  (if (cl:or 
       (slang-built-in::slang-term-equals tau sigma) 
       (LIST-SPEC::|!exists|-1-1 
        #'(lambda (p) (slang-built-in::slang-term-equals p (cons tau sigma))) 
        pairs)) 
      tcc 
      (let ((pairs (LIST-SPEC::|!cons| (cons tau sigma) pairs))) 
        (let ((tau1 (TYPEOBLIGATIONS::unfoldBase gamma tau))) 
          (let ((sigma1 (TYPEOBLIGATIONS::unfoldBase gamma sigma))) 
            (if (slang-built-in::slang-term-equals tau1 sigma1) 
                tcc 
                (block 
                 nil 
                 (if (eq (car tau1) :|Subsort|) 
                     (let ((pV88 (cdr tau1))) 
                       (return 
                        (let ((gamma 
                               (TYPEOBLIGATIONS::assertCond 
                                (TYPEOBLIGATIONS::mkLetOrApply 
                                 (svref pV88 1) 
                                 |!M|) 
                                gamma))) 
                          (TYPEOBLIGATIONS::subtypeRec 
                           pairs 
                           tcc 
                           gamma 
                           |!M| 
                           (svref pV88 0) 
                           sigma))))) 
                 (return 
                  (block 
                   nil 
                   (if (eq (car sigma1) :|Subsort|) 
                       (let ((pV83 (cdr sigma1))) 
                         (return 
                          (let ((tcc 
                                 (TYPEOBLIGATIONS::subtypeRec 
                                  pairs 
                                  tcc 
                                  gamma 
                                  |!M| 
                                  tau 
                                  (svref pV83 0)))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::addCondition 
                                    tcc 
                                    gamma 
                                    (TYPEOBLIGATIONS::mkLetOrApply 
                                     (svref pV83 1) 
                                     |!M|)))) tcc))))) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car tau1) :|Arrow|) 
                         (let ((pV45 (cdr tau1))) 
                           (if (eq (car sigma1) :|Arrow|) 
                               (let ((pV78 (cdr sigma1))) 
                                 (let ((pV79 (svref pV78 0))) 
                                   (return 
                                    (let ((x 
                                           (TYPEOBLIGATIONS::freshName gamma "x"))) 
                                      (let ((xVar 
                                             (cons 
                                              :|Var| 
                                              (cons 
                                               (cons x pV79) 
                                               POSITION-SPEC::noPos)))) 
                                        (let ((gamma1 
                                               (TYPEOBLIGATIONS::insert 
                                                (cons x pV79) 
                                                gamma))) 
                                          (let ((tcc 
                                                 (TYPEOBLIGATIONS::subtypeRec 
                                                  pairs 
                                                  tcc 
                                                  gamma1 
                                                  xVar 
                                                  pV79 
                                                  (svref pV45 0)))) 
                                            (let ((tcc 
                                                   (TYPEOBLIGATIONS::subtypeRec 
                                                    pairs 
                                                    tcc 
                                                    gamma1 
                                                    (TYPEOBLIGATIONS::mkLetOrApply 
                                                     |!M| 
                                                     xVar) 
                                                    (svref pV45 1) 
                                                    (svref pV78 1)))) tcc)))))))))) 
                         (if (eq (car tau1) :|Product|) 
                             (if (eq (car sigma1) :|Product|) 
                                 (return 
                                  (let ((tcc 
                                         (LISTPAIR::foldr-1-1-1 
                                          #'(lambda (x) 
                                             (let ((pV11 (svref x 1))) 
                                               (block 
                                                nil 
                                                (let ((pV14 (cdr (svref x 0)))) 
                                                  (return 
                                                   (TYPEOBLIGATIONS::subtypeRec 
                                                    pairs 
                                                    (svref x 2) 
                                                    gamma 
                                                    (cons 
                                                     :|Apply| 
                                                     (vector 
                                                      (cons 
                                                       :|Fun| 
                                                       (vector 
                                                        (cons 
                                                         :|Project| 
                                                         (car pV11)) 
                                                        (cons 
                                                         :|Arrow| 
                                                         (vector 
                                                          sigma1 
                                                          pV14 
                                                          POSITION-SPEC::noPos)) 
                                                        POSITION-SPEC::noPos)) 
                                                      |!M| 
                                                      POSITION-SPEC::noPos)) 
                                                    pV14 
                                                    (cdr pV11)))) 
                                                (error 
                                                 "Nonexhaustive match failure in subtypeRec")))) 
                                          tcc 
                                          (cons 
                                           (car (cdr tau1)) 
                                           (car (cdr sigma1)))))) tcc))) 
                             (if (eq (car tau1) :|CoProduct|) 
                                 (if (eq (car sigma1) :|CoProduct|) 
                                     (return 
                                      (let ((tcc 
                                             (LISTPAIR::foldr-1-1-1 
                                              #'(lambda (x) 
                                                 (let ((pV27 (svref x 2))
                                                       (pV26 (svref x 1))) 
                                                   (block 
                                                    nil 
                                                    (let ((pV29 
                                                           (cdr (svref x 0)))) 
                                                      (let ((pV31 (cdr pV26))
                                                            (pV30 (car pV26))) 
                                                        (return 
                                                         (block 
                                                          nil 
                                                          (if (eq 
                                                               (car pV29) 
                                                               :|Some|) 
                                                              (let ((pV23 
                                                                     (cdr pV29))) 
                                                                (if (eq 
                                                                     (car pV31) 
                                                                     :|Some|) 
                                                                    (return 
                                                                     (let ((gamma 
                                                                            (TYPEOBLIGATIONS::assertCond 
                                                                             (cons 
                                                                              :|Apply| 
                                                                              (vector 
                                                                               (cons 
                                                                                :|Fun| 
                                                                                (vector 
                                                                                 (cons 
                                                                                  :|Embedded| 
                                                                                  pV30) 
                                                                                 (cons 
                                                                                  :|Arrow| 
                                                                                  (vector 
                                                                                   sigma 
                                                                                   STANDARDSPEC::boolSort 
                                                                                   POSITION-SPEC::noPos)) 
                                                                                 POSITION-SPEC::noPos)) 
                                                                               |!M| 
                                                                               POSITION-SPEC::noPos)) 
                                                                             gamma))) 
                                                                       (TYPEOBLIGATIONS::subtypeRec 
                                                                        pairs 
                                                                        pV27 
                                                                        gamma 
                                                                        (cons 
                                                                         :|Apply| 
                                                                         (vector 
                                                                          (cons 
                                                                           :|Fun| 
                                                                           (vector 
                                                                            (cons 
                                                                             :|Select| 
                                                                             pV30) 
                                                                            (cons 
                                                                             :|Arrow| 
                                                                             (vector 
                                                                              sigma 
                                                                              pV23 
                                                                              POSITION-SPEC::noPos)) 
                                                                            POSITION-SPEC::noPos)) 
                                                                          |!M| 
                                                                          POSITION-SPEC::noPos)) 
                                                                        pV23 
                                                                        (cdr 
                                                                         pV31)))))) 
                                                              (if (eq 
                                                                   (car pV29) 
                                                                   :|None|) 
                                                                  (if (eq 
                                                                       (car pV31) 
                                                                       :|None|) 
                                                                      (return 
                                                                       pV27)))) 
                                                          (return 
                                                           (SYSTEM-SPEC::fail 
                                                            "CoProduct mismatch")))))) 
                                                    (error 
                                                     "Nonexhaustive match failure in subtypeRec")))) 
                                              tcc 
                                              (cons 
                                               (car (cdr tau1)) 
                                               (car (cdr sigma1)))))) tcc))) 
                                 (if (eq (car tau1) :|Quotient|) 
                                     (if (eq (car sigma1) :|Quotient|) 
                                         (return tcc)) 
                                     (if (eq (car tau1) :|TyVar|) 
                                         (if (eq (car sigma1) :|TyVar|) 
                                             (return tcc)) 
                                         (if (eq (car tau1) :|Base|) 
                                             (let ((pV40 (cdr tau1))) 
                                               (if (eq (car sigma1) :|Base|) 
                                                   (let ((pV49 (cdr sigma1))) 
                                                     (return 
                                                      (if (slang-built-in::slang-term-equals 
                                                           (svref pV40 0) 
                                                           (svref pV49 0)) 
                                                          (let ((tcc 
                                                                 (LISTPAIR::foldr-1-1-1 
                                                                  #'(lambda (x) 
                                                                     (let ((tcc 
                                                                            (svref 
                                                                             x 
                                                                             2))
                                                                           (s2 
                                                                            (svref 
                                                                             x 
                                                                             1))
                                                                           (s1 
                                                                            (svref 
                                                                             x 
                                                                             0))) 
                                                                       (let ((x1 
                                                                              (TYPEOBLIGATIONS::freshName 
                                                                               gamma 
                                                                               "x"))) 
                                                                         (let ((gamma1 
                                                                                (TYPEOBLIGATIONS::insert 
                                                                                 (cons 
                                                                                  x1 
                                                                                  s1) 
                                                                                 gamma))) 
                                                                           (let ((gamma2 
                                                                                  (TYPEOBLIGATIONS::insert 
                                                                                   (cons 
                                                                                    x1 
                                                                                    s2) 
                                                                                   gamma))) 
                                                                             (let ((tcc 
                                                                                    (TYPEOBLIGATIONS::subtypeRec 
                                                                                     pairs 
                                                                                     tcc 
                                                                                     gamma1 
                                                                                     (cons 
                                                                                      :|Var| 
                                                                                      (cons 
                                                                                       (cons 
                                                                                        x1 
                                                                                        s1) 
                                                                                       POSITION-SPEC::noPos)) 
                                                                                     s1 
                                                                                     s2))) 
                                                                               (let ((tcc 
                                                                                      (TYPEOBLIGATIONS::subtypeRec 
                                                                                       pairs 
                                                                                       tcc 
                                                                                       gamma2 
                                                                                       (cons 
                                                                                        :|Var| 
                                                                                        (cons 
                                                                                         (cons 
                                                                                          x1 
                                                                                          s2) 
                                                                                         POSITION-SPEC::noPos)) 
                                                                                       s2 
                                                                                       s1))) 
                                                                                 tcc))))))) 
                                                                  tcc 
                                                                  (cons 
                                                                   (svref pV40 1) 
                                                                   (svref pV49 1))))) 
                                                            tcc) 
                                                          (TYPEOBLIGATIONS::addFailure 
                                                           tcc 
                                                           gamma 
                                                           (STRING-SPEC::^ 
                                                            (STRING-SPEC::^ 
                                                             (ANNSPECPRINTER::printSort 
                                                              tau) 
                                                             " could not be made subsort of ") 
                                                            (ANNSPECPRINTER::printSort 
                                                             sigma)))))))))))))) 
                     (error "Nonexhaustive match failure in subtypeRec"))))))))))))


(defun TYPEOBLIGATIONS::|!<=| (tcc gamma |!M| tau sigma) 
  (TYPEOBLIGATIONS::subtypeRec nil tcc gamma |!M| tau sigma))

(defun TYPEOBLIGATIONS::\|- (pV95 pV96) 
  (block 
   nil 
   (let ((pV98 (cdr pV95))
         (pV97 (car pV95))) 
     (let ((pV100 (cdr pV96))
           (pV99 (car pV96))) 
       (return 
        (block 
         nil 
         (if (eq (car pV99) :|Apply|) 
             (let ((pV61 (cdr pV99))) 
               (let ((pV92 (svref pV61 0))) 
                 (return 
                  (let ((spc (TYPEOBLIGATIONS::getSpec-1 pV98))) 
                    (let ((sigma1 (SPECENVIRONMENT::inferType spc pV92))) 
                      (let ((tcc 
                             (TYPEOBLIGATIONS::\|- 
                              (cons pV97 pV98) 
                              (TYPEOBLIGATIONS::?? pV92 sigma1)))) 
                        (let ((tcc 
                               (TYPEOBLIGATIONS::\|- 
                                (cons tcc pV98) 
                                (TYPEOBLIGATIONS::?? 
                                 (svref pV61 1) 
                                 (SPECENVIRONMENT::domain spc sigma1))))) 
                          (let ((tau2 (SPECENVIRONMENT::range spc sigma1))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::|!<=| 
                                    tcc 
                                    pV98 
                                    pV99 
                                    tau2 
                                    pV100))) tcc))))))))) 
             (if (eq (car pV99) :|Record|) 
                 (let ((pV90 (car (cdr pV99)))) 
                   (return 
                    (let ((spc (TYPEOBLIGATIONS::getSpec-1 pV98))) 
                      (let ((types (SPECENVIRONMENT::product spc pV100))) 
                        (labels 
                          ((checkField (pV3 pV4 pV5) 
                            (block 
                             nil 
                             (return 
                              (TYPEOBLIGATIONS::\|- 
                               (cons pV5 pV98) 
                               (TYPEOBLIGATIONS::?? (cdr pV3) (cdr pV4)))) 
                             (error "Nonexhaustive match failure in |-")))) 
                          (let ((tcc 
                                 (LISTPAIR::foldr-1-1-1 
                                  #'(lambda (x) 
                                     (checkField 
                                      (svref x 0) 
                                      (svref x 1) 
                                      (svref x 2))) 
                                  pV97 
                                  (cons pV90 types)))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::|!<=| 
                                    tcc 
                                    pV98 
                                    pV99 
                                    (cons 
                                     :|Product| 
                                     (cons types POSITION-SPEC::noPos)) 
                                    pV100))) tcc))))))) 
                 (if (eq (car pV99) :|Bind|) 
                     (let ((pV59 (cdr pV99))) 
                       (return 
                        (let ((gamma 
                               (LIST-SPEC::foldr-1-1-1 
                                #'TYPEOBLIGATIONS::insert-1 
                                pV98 
                                (svref pV59 1)))) 
                          (let ((tcc 
                                 (TYPEOBLIGATIONS::\|- 
                                  (cons pV97 gamma) 
                                  (TYPEOBLIGATIONS::?? 
                                   (svref pV59 2) 
                                   STANDARDSPEC::boolSort)))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::|!<=| 
                                    tcc 
                                    gamma 
                                    pV99 
                                    STANDARDSPEC::boolSort 
                                    pV100))) tcc))))) 
                     (if (eq (car pV99) :|Let|) 
                         (return pV97) 
                         (if (eq (car pV99) :|LetRec|) 
                             (return pV97) 
                             (if (eq (car pV99) :|Var|) 
                                 (return 
                                  (let ((tcc 
                                         (TYPEOBLIGATIONS::|!<=| 
                                          pV97 
                                          pV98 
                                          pV99 
                                          (cdr (car (cdr pV99))) 
                                          pV100))) tcc)) 
                                 (if (eq (car pV99) :|Fun|) 
                                     (let ((pV55 (cdr pV99))) 
                                       (let ((pV73 (svref pV55 0))) 
                                         (return 
                                          (let ((tcc 
                                                 (TYPEOBLIGATIONS::|!<=| 
                                                  pV97 
                                                  pV98 
                                                  pV99 
                                                  (svref pV55 1) 
                                                  pV100))) 
                                            (block 
                                             nil 
                                             (if (eq (car pV73) :|Equals|) 
                                                 (return tcc) 
                                                 (if (eq (car pV73) :|Quotient|) 
                                                     (return tcc) 
                                                     (if (eq 
                                                          (car pV73) 
                                                          :|Choose|) 
                                                         (return tcc) 
                                                         (if (eq 
                                                              (car pV73) 
                                                              :|Restrict|) 
                                                             (return tcc) 
                                                             (if (eq 
                                                                  (car pV73) 
                                                                  :|Relax|) 
                                                                 (return tcc) 
                                                                 (if (eq 
                                                                      (car pV73) 
                                                                      :|Op|) 
                                                                     (return tcc) 
                                                                     (if (eq 
                                                                          (car 
                                                                           pV73) 
                                                                          :|Project|) 
                                                                         (return 
                                                                          tcc) 
                                                                         (if (eq 
                                                                              (car 
                                                                               pV73) 
                                                                              :|Embed|) 
                                                                             (return 
                                                                              tcc) 
                                                                             (if (eq 
                                                                                  (car 
                                                                                   pV73) 
                                                                                  :|Embedded|) 
                                                                                 (return 
                                                                                  tcc) 
                                                                                 (if (eq 
                                                                                      (car 
                                                                                       pV73) 
                                                                                      :|Select|) 
                                                                                     (return 
                                                                                      tcc) 
                                                                                     (if (eq 
                                                                                          (car 
                                                                                           pV73) 
                                                                                          :|Nat|) 
                                                                                         (return 
                                                                                          tcc) 
                                                                                         (if (eq 
                                                                                              (car 
                                                                                               pV73) 
                                                                                              :|Char|) 
                                                                                             (return 
                                                                                              tcc) 
                                                                                             (if (eq 
                                                                                                  (car 
                                                                                                   pV73) 
                                                                                                  :|String|) 
                                                                                                 (return 
                                                                                                  tcc) 
                                                                                                 (if (eq 
                                                                                                      (car 
                                                                                                       pV73) 
                                                                                                      :|Bool|) 
                                                                                                     (return 
                                                                                                      tcc))))))))))))))) 
                                             (error 
                                              "Nonexhaustive match failure in |-")))))) 
                                     (if (eq (car pV99) :|Lambda|) 
                                         (let ((pV71 (car (cdr pV99)))) 
                                           (return 
                                            (let ((dom 
                                                   (SPECENVIRONMENT::domain 
                                                    (TYPEOBLIGATIONS::getSpec-1 
                                                     pV98) 
                                                    pV100))) 
                                              (let ((rng 
                                                     (SPECENVIRONMENT::range 
                                                      (TYPEOBLIGATIONS::getSpec-1 
                                                       pV98) 
                                                      pV100))) 
                                                (let ((tcc 
                                                       (LIST-SPEC::foldr-1-1-1 
                                                        (TYPEOBLIGATIONS::checkRule 
                                                         pV98 
                                                         dom 
                                                         rng) 
                                                        pV97 
                                                        pV71))) 
                                                  (let ((rules 
                                                         (LIST-SPEC::|!map|-1-1 
                                                          #'(lambda (x) 
                                                             (vector 
                                                              (cons 
                                                               (svref x 0) 
                                                               nil) 
                                                              (svref x 1) 
                                                              (STANDARDSPEC::mkTrue))) 
                                                          pV71))) 
                                                    (let ((x 
                                                           (TYPEOBLIGATIONS::freshName 
                                                            pV98 
                                                            "x"))) 
                                                      (block 
                                                       nil 
                                                       (return 
                                                        (let ((context 
                                                               (vector 
                                                                (cons :|Ref| 0) 
                                                                (svref pV98 3) 
                                                                (svref pV98 2) 
                                                                '(:|None|)))) 
                                                          (let ((trm 
                                                                 (PATTERNMATCH::match 
                                                                  context 
                                                                  (cons 
                                                                   (cons 
                                                                    :|Var| 
                                                                    (cons 
                                                                     (cons x dom) 
                                                                     POSITION-SPEC::noPos)) 
                                                                   nil) 
                                                                  rules 
                                                                  (STANDARDSPEC::mkFalse) 
                                                                  (STANDARDSPEC::mkFalse)))) 
                                                            (let ((pV35 
                                                                   (TYPEOBLIGATIONS::simplifyMatch 
                                                                    trm))) 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car pV35) 
                                                                    :|Fun|) 
                                                                   (let ((pV37 
                                                                          (svref 
                                                                           (cdr 
                                                                            pV35) 
                                                                           0))) 
                                                                     (if (eq 
                                                                          (car 
                                                                           pV37) 
                                                                          :|Bool|) 
                                                                         (if (eq 
                                                                              t 
                                                                              (cdr 
                                                                               pV37)) 
                                                                             (return 
                                                                              tcc))))) 
                                                               (return 
                                                                (TYPEOBLIGATIONS::addCondition 
                                                                 tcc 
                                                                 pV98 
                                                                 (STANDARDSPEC::mkBind 
                                                                  '(:|Forall|) 
                                                                  (cons 
                                                                   (cons x dom) 
                                                                   nil) 
                                                                  pV35)))))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in |-"))))))))) 
                                         (if (eq (car pV99) :|IfThenElse|) 
                                             (let ((pV53 (cdr pV99))) 
                                               (let ((pV67 (svref pV53 0))) 
                                                 (return 
                                                  (let ((tcc1 
                                                         (TYPEOBLIGATIONS::\|- 
                                                          (cons pV97 pV98) 
                                                          (TYPEOBLIGATIONS::?? 
                                                           pV67 
                                                           STANDARDSPEC::boolSort)))) 
                                                    (let ((gamma1 
                                                           (TYPEOBLIGATIONS::assertCond 
                                                            pV67 
                                                            pV98))) 
                                                      (let ((tcc2 
                                                             (TYPEOBLIGATIONS::\|- 
                                                              (cons tcc1 gamma1) 
                                                              (TYPEOBLIGATIONS::?? 
                                                               (svref pV53 1) 
                                                               pV100)))) 
                                                        (let ((gamma2 
                                                               (TYPEOBLIGATIONS::assertCond 
                                                                (STANDARDSPEC::mkNot 
                                                                 pV67) 
                                                                pV98))) 
                                                          (let ((tcc3 
                                                                 (TYPEOBLIGATIONS::\|- 
                                                                  (cons 
                                                                   tcc2 
                                                                   gamma2) 
                                                                  (TYPEOBLIGATIONS::?? 
                                                                   (svref pV53 2) 
                                                                   pV100)))) 
                                                            tcc3)))))))) 
                                             (if (eq (car pV99) :|Seq|) 
                                                 (let ((pV62 (car (cdr pV99)))) 
                                                   (if (null pV62) 
                                                       (return pV97) 
                                                       (if (consp pV62) 
                                                           (let ((pV66 
                                                                  (cdr pV62))
                                                                 (pV65 
                                                                  (car pV62))) 
                                                             (progn (if (null 
                                                                         pV66) 
                                                                        (return 
                                                                         (TYPEOBLIGATIONS::\|- 
                                                                          (cons 
                                                                           pV97 
                                                                           pV98) 
                                                                          (cons 
                                                                           pV65 
                                                                           pV100)))) 
                                                                    (return 
                                                                     (let ((sigma 
                                                                            (SPECENVIRONMENT::inferType 
                                                                             (TYPEOBLIGATIONS::getSpec-1 
                                                                              pV98) 
                                                                             pV65))) 
                                                                       (let ((tcc 
                                                                              (TYPEOBLIGATIONS::\|- 
                                                                               (cons 
                                                                                pV97 
                                                                                pV98) 
                                                                               (TYPEOBLIGATIONS::?? 
                                                                                pV65 
                                                                                sigma)))) 
                                                                         (let ((tcc 
                                                                                (TYPEOBLIGATIONS::\|- 
                                                                                 (cons 
                                                                                  tcc 
                                                                                  pV98) 
                                                                                 (TYPEOBLIGATIONS::?? 
                                                                                  (cons 
                                                                                   :|Seq| 
                                                                                   (cons 
                                                                                    pV66 
                                                                                    POSITION-SPEC::noPos)) 
                                                                                  pV100)))) 
                                                                           tcc))))))))))))))))))) 
         (error "Nonexhaustive match failure in |-"))))) 
   (error "Nonexhaustive match failure in |-")))

(defun TYPEOBLIGATIONS::checkSpec-1 (spc) 
  (let ((localOps (svref (svref spc 0) 2))) 
    (let ((names 
           (STRINGSET::fromList 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (pV1) 
                (block 
                 nil 
                 (if (eq (car pV1) :|Qualified|) (return (cdr (cdr pV1)))) 
                 (error "Nonexhaustive match failure in checkSpec"))) 
             localOps)))) 
      (let ((gamma0 
             #'(lambda (tvs) #'(lambda (nm) (vector nil tvs spc nm names))))) 
        (let ((tcc 
               (STRINGMAP::foldriDouble-1-1-1 
                #'(lambda (x) 
                   (let ((pV12 (svref x 3))
                         (pV11 (svref x 2))
                         (pV10 (svref x 1))) 
                     (block 
                      nil 
                      (let ((pV15 (svref pV11 2))) 
                        (let ((pV18 (cdr pV15))
                              (pV17 (car pV15))) 
                          (return 
                           (if (LIST-SPEC::|!member| 
                                (cons :|Qualified| (cons (svref x 0) pV10)) 
                                localOps) 
                               (LIST-SPEC::foldl-1-1-1 
                                #'(lambda (x1) 
                                   (block 
                                    nil 
                                    (return 
                                     (TYPEOBLIGATIONS::\|- 
                                      (cons 
                                       (cdr x1) 
                                       (funcall (funcall gamma0 pV17) pV10)) 
                                      (TYPEOBLIGATIONS::?? (cdr (car x1)) pV18))) 
                                    (error 
                                     "Nonexhaustive match failure in checkSpec"))) 
                                pV12 
                                (svref pV11 3)) 
                               pV12)))) 
                      (error "Nonexhaustive match failure in checkSpec")))) 
                nil 
                (svref spc 1)))) tcc)))))

(defun TYPEOBLIGATIONS::makeTypeCheckObligationSpec (spc spcRef) 
  (let ((tcSpec (addImport (cons spcRef spc) emptySpec))) 
    (addConjectures (TYPEOBLIGATIONS::checkSpec-1 spc) tcSpec)))

(defun SPECCALC::specObligations (spc spcTerm) 
  (TYPEOBLIGATIONS::makeTypeCheckObligationSpec 
   spc 
   (SPECCALC::showTerm-1 spcTerm)))

(defun SPECCALC::evaluateObligations-1 (term) 
  (SPECCALC::monadBind 
   #'SPECCALC::getCurrentURI-1 
   #'(lambda (uri) 
      (SPECCALC::monadSeq 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          ";;; Processing obligations at " 
          (SPECCALC::uriToString-1 uri)) 
         "
")) 
       (SPECCALC::monadBind 
        (SPECCALC::evaluateTermInfo-1 term) 
        #'(lambda (x) 
           (let ((dep_URIs (svref x 2))
                 (time_stamp (svref x 1))
                 (value (svref x 0))) 
             (block 
              nil 
              (if (eq (car value) :|Spec|) 
                  (return 
                   (SPECCALC::monadBind 
                    (SPECCALC::|!return| 
                     (SPECCALC::specObligations (cdr value) term)) 
                    #'(lambda (ob_spec) 
                       (SPECCALC::monadBind 
                        (funcall (SPECCALC::complainIfAmbiguous-1 
                                  (SPECCALC::compressDefs-1 ob_spec)) 
                                 (SPECCALC::positionOf-1 term)) 
                        #'(lambda (compressed_spec) 
                           (SPECCALC::|!return| 
                            (vector 
                             (cons 
                              :|Spec| 
                              (vector 
                               (svref compressed_spec 0) 
                               (svref compressed_spec 1) 
                               (svref compressed_spec 2) 
                               (svref compressed_spec 3))) 
                             time_stamp 
                             dep_URIs))))))) 
                  (if (eq (car value) :|Morph|) 
                      (let ((pV3 (cdr value))) 
                        (return 
                         (SPECCALC::monadBind 
                          #'SPECCALC::getGlobalContext-1 
                          #'(lambda (globalContext) 
                             (SPECCALC::monadBind 
                              (SPECCALC::|!return| 
                               (SPECCALC::morphismObligations pV3 globalContext)) 
                              #'(lambda (ob_spec) 
                                 (SPECCALC::monadBind 
                                  (funcall (SPECCALC::complainIfAmbiguous-1 
                                            (SPECCALC::compressDefs-1 ob_spec)) 
                                           (SPECCALC::positionOf-1 term)) 
                                  #'(lambda (compressed_spec) 
                                     (SPECCALC::|!return| 
                                      (vector 
                                       (cons 
                                        :|Spec| 
                                        (vector 
                                         (svref compressed_spec 0) 
                                         (svref compressed_spec 1) 
                                         (svref compressed_spec 2) 
                                         (svref compressed_spec 3))) 
                                       time_stamp 
                                       dep_URIs)))))))))))) 
              (return 
               (SPECCALC::raise 
                (cons 
                 :|Unsupported| 
                 (cons 
                  (SPECCALC::positionOf-1 term) 
                  "Can create obligations for Specs and Morphisms only"))))))))))))


(defun SPECCALC::evaluateOther (args) 
  #'(lambda (pos) 
     (SPECCALC::monadBind 
      #'SPECCALC::getCurrentURI-1 
      #'(lambda (uri) 
         (SPECCALC::raise 
          (cons 
           :|TypeCheck| 
           (cons 
            pos 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              "Unexpected OtherTerm at " 
              (SPECCALC::uriToString-1 uri)) 
             "
"))))))))

(defun SPECCALC::evaluateOtherPrint (value) 
  #'(lambda (pos) 
     (SPECCALC::monadBind 
      #'SPECCALC::getCurrentURI-1 
      #'(lambda (uri) 
         (SPECCALC::raise 
          (cons 
           :|TypeCheck| 
           (cons 
            pos 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              "Unexpected OtherTerm at " 
              (SPECCALC::uriToString-1 uri)) 
             "
"))))))))

(defun SPECCALC::printSpec-1-1-1 (base_spec reverse_context spc) 
  (ANNSPECPRINTER::printSpec-1 (subtractSpec-1-1 spc base_spec)))

(defun SPECCALC::printColimit-1-1-1 (base_spec reverse_context col) 
  (SPECCALC::printSpec-1-1-1 
   base_spec 
   reverse_context 
   (CAT::apex-1 (CAT::cocone-1 col))))

(defun SPECCALC::ppMorphismMap (pV1 pV2 opMap sortMap) 
  (declare (ignore pV1 pV2)) 
  (labels 
    ((ppAbbrevMap (|!keyword|) 
      #'(lambda (|!map|) 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (lst) 
             #'(lambda (dom) 
                #'(lambda (cod) 
                   (cons 
                    (WADLERLINDIG::ppGroup 
                     (WADLERLINDIG::ppConcat 
                      (cons 
                       (WADLERLINDIG::ppString |!keyword|) 
                       (cons 
                        (SPECCALC::ppQualifiedId dom) 
                        (cons 
                         WADLERLINDIG::ppBreak 
                         (cons 
                          (WADLERLINDIG::ppString "+->") 
                          (cons 
                           WADLERLINDIG::ppBreak 
                           (cons (SPECCALC::ppQualifiedId cod) nil)))))))) 
                    lst)))) 
          nil 
          (abbrevMap |!map|))))
     (abbrevMap (|!map|) 
      (POLYMAP::foldMap-1-1-1 
       #'(lambda (newMap) 
          #'(lambda (d) 
             #'(lambda (c) 
                (if (slang-built-in::slang-term-equals d c) 
                    newMap 
                    (POLYMAP::update-1-1-1 newMap d c))))) 
       POLYMAP::emptyMap 
       |!map|))) 
    (WADLERLINDIG::ppGroup 
     (WADLERLINDIG::ppConcat 
      (let ((pV3 
             (LIST-SPEC::|!++| 
              (funcall (ppAbbrevMap "sort ") sortMap) 
              (funcall (ppAbbrevMap "op ") opMap)))) 
        (block 
         nil 
         (if (null pV3) 
             (return 
              (cons 
               WADLERLINDIG::ppBreak 
               (cons (WADLERLINDIG::ppString "{}") nil)))) 
         (return 
          (cons 
           WADLERLINDIG::ppBreak 
           (cons 
            (WADLERLINDIG::ppString "{") 
            (cons 
             (WADLERLINDIG::ppNest-1-1 
              1 
              (WADLERLINDIG::ppSep-1-1 
               (WADLERLINDIG::ppCons-1-1 
                (WADLERLINDIG::ppString ",") 
                WADLERLINDIG::ppBreak) 
               pV3)) 
             (cons (WADLERLINDIG::ppString "}") nil)))))))))))

(defun SPECCALC::ppMorphismMap-1 (x) 
  (SPECCALC::ppMorphismMap (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::relativeURI_ToString (rel_uri) 
  (block 
   nil 
   (if (eq (car rel_uri) :|URI_Relative|) 
       (let ((pV7 (cdr rel_uri))) 
         (let ((pV9 (cdr pV7))
               (pV8 (car pV7))) 
           (return 
            (let ((filename 
                   (block 
                    nil 
                    (if (null pV9) (return "")) 
                    (return 
                     (STRING-SPEC::concatList 
                      (LIST-SPEC::tl 
                       (LIST-SPEC::foldr-1-1-1 
                        #'(lambda (x) 
                           (LIST-SPEC::|!cons| 
                            "/" 
                            (LIST-SPEC::|!cons| (car x) (cdr x)))) 
                        nil 
                        pV9))))))) 
              (block 
               nil 
               (if (eq (car pV8) :|None|) 
                   (return filename) 
                   (if (eq (car pV8) :|Some|) 
                       (let ((pV4 (cdr pV8))) 
                         (return 
                          (if (string=  filename "") 
                              pV4 
                              (STRING-SPEC::^ (STRING-SPEC::^ filename "#") pV4)))))) 
               (error "Nonexhaustive match failure in relativeURI_ToString")))))) 
       (if (eq (car rel_uri) :|SpecPath_Relative|) 
           (return (SPECCALC::uriToString-1 (cdr rel_uri))))) 
   (error "Nonexhaustive match failure in relativeURI_ToString")))

(defun SPECCALC::ppMorphismX-1-1-1 (base_spec reverse_context sm) 
  (let ((dom_spec (SPECCALC::dom-1 sm))) 
    (let ((cod_spec (SPECCALC::cod-1 sm))) 
      (let ((str_1 
             (WADLERLINDIG::ppFormat 
              (WADLERLINDIG::ppGroup 
               (WADLERLINDIG::ppConcat 
                (cons 
                 (WADLERLINDIG::ppString "morphism") 
                 (cons 
                  (WADLERLINDIG::ppNest-1-1 
                   4 
                   (WADLERLINDIG::ppGroup 
                    (WADLERLINDIG::ppConcat 
                     (cons 
                      WADLERLINDIG::ppBreak 
                      (cons 
                       (WADLERLINDIG::ppString 
                        (let ((pV1 
                               (POLYMAP::evalPartial-1-1 
                                reverse_context 
                                (cons 
                                 :|Spec| 
                                 (vector 
                                  (svref dom_spec 0) 
                                  (svref dom_spec 1) 
                                  (svref dom_spec 2) 
                                  (svref dom_spec 3)))))) 
                          (block 
                           nil 
                           (if (eq (car pV1) :|Some|) 
                               (return 
                                (SPECCALC::relativeURI_ToString (cdr pV1))) 
                               (if (eq (car pV1) :|None|) 
                                   (return 
                                    (SPECCALC::printSpec-1-1-1 
                                     base_spec 
                                     reverse_context 
                                     dom_spec)))) 
                           (error "Nonexhaustive match failure in ppMorphismX")))) 
                       (cons 
                        WADLERLINDIG::ppBreak 
                        (cons 
                         (WADLERLINDIG::ppString "->") 
                         (cons 
                          WADLERLINDIG::ppBreak 
                          (cons 
                           (WADLERLINDIG::ppString 
                            (let ((pV3 
                                   (POLYMAP::evalPartial-1-1 
                                    reverse_context 
                                    (cons 
                                     :|Spec| 
                                     (vector 
                                      (svref cod_spec 0) 
                                      (svref cod_spec 1) 
                                      (svref cod_spec 2) 
                                      (svref cod_spec 3)))))) 
                              (block 
                               nil 
                               (if (eq (car pV3) :|Some|) 
                                   (return 
                                    (SPECCALC::relativeURI_ToString (cdr pV3))) 
                                   (if (eq (car pV3) :|None|) 
                                       (return 
                                        (SPECCALC::printSpec-1-1-1 
                                         base_spec 
                                         reverse_context 
                                         cod_spec)))) 
                               (error 
                                "Nonexhaustive match failure in ppMorphismX")))) 
                           nil))))))))) 
                  nil))))))) 
        (WADLERLINDIG::ppGroup 
         (WADLERLINDIG::ppConcat 
          (cons 
           (WADLERLINDIG::ppString str_1) 
           (cons (WADLERLINDIG::ppNest-1-1 4 (SPECCALC::ppMorphismMap-1 sm)) nil))))))))


(defun SPECCALC::printDiagram-1-1-1 (base_spec reverse_context dg) 
  (let ((shape (CAT::shape-1 dg))) 
    (let ((vertice_set (SKETCH::vertices-1 shape))) 
      (let ((edge_set (SKETCH::edges-1 shape))) 
        (let ((src_map (SKETCH::src-1 shape))) 
          (let ((target_map (SKETCH::target-1 shape))) 
            (let ((functor (CAT::functor-1 dg))) 
              (let ((vertex_map (FUNCTOR::vertexMap-1 functor))) 
                (let ((edge_map (FUNCTOR::edgeMap-1 functor))) 
                  (let ((linked_vertices 
                         (EDGE::fold-1-1-1 
                          #'(lambda (linked_vertices) 
                             #'(lambda (edge) 
                                (let ((src (SKETCH::|!eval|-1-1 src_map edge))) 
                                  (let ((tgt 
                                         (SKETCH::|!eval|-1-1 target_map edge))) 
                                    (cons src (cons tgt linked_vertices)))))) 
                          nil 
                          edge_set))) 
                    (let ((isolated_vertices 
                           (VERTEX::fold-1-1-1 
                            #'(lambda (isolated_vertices) 
                               #'(lambda (vertice) 
                                  (if (LIST-SPEC::|!member| 
                                       vertice 
                                       linked_vertices) 
                                      isolated_vertices 
                                      (cons vertice isolated_vertices)))) 
                            nil 
                            vertice_set))) 
                      (let ((pp_vertice_entries 
                             (LIST-SPEC::foldl-1-1-1 
                              #'(lambda (x) 
                                 (let ((vertex (car x))) 
                                   (cons 
                                    (WADLERLINDIG::ppGroup 
                                     (WADLERLINDIG::ppConcat 
                                      (cons 
                                       (VERTEX::ppElem vertex) 
                                       (cons 
                                        WADLERLINDIG::ppBreak 
                                        (cons 
                                         (WADLERLINDIG::ppString "+->") 
                                         (cons 
                                          WADLERLINDIG::ppBreak 
                                          (cons 
                                           (let ((spc 
                                                  (POLYMAP::|!eval|-1-1 
                                                   vertex_map 
                                                   vertex))) 
                                             (WADLERLINDIG::ppString 
                                              (let ((pV1 
                                                     (POLYMAP::evalPartial-1-1 
                                                      reverse_context 
                                                      (cons 
                                                       :|Spec| 
                                                       (vector 
                                                        (svref spc 0) 
                                                        (svref spc 1) 
                                                        (svref spc 2) 
                                                        (svref spc 3)))))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV1) :|Some|) 
                                                     (return 
                                                      (SPECCALC::relativeURI_ToString 
                                                       (cdr pV1))) 
                                                     (if (eq (car pV1) :|None|) 
                                                         (return 
                                                          (SPECCALC::printSpec-1-1-1 
                                                           base_spec 
                                                           reverse_context 
                                                           spc)))) 
                                                 (error 
                                                  "Nonexhaustive match failure in printDiagram"))))) 
                                           nil))))))) 
                                    (cdr x)))) 
                              nil 
                              isolated_vertices))) 
                        (let ((pp_edge_entries 
                               (EDGE::fold-1-1-1 
                                #'(lambda (pp_entries) 
                                   #'(lambda (edge) 
                                      (cons 
                                       (WADLERLINDIG::ppGroup 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (WADLERLINDIG::ppGroup 
                                           (WADLERLINDIG::ppConcat 
                                            (cons 
                                             (EDGE::ppElem edge) 
                                             (cons 
                                              WADLERLINDIG::ppBreak 
                                              (cons 
                                               (WADLERLINDIG::ppString ":") 
                                               (cons 
                                                WADLERLINDIG::ppBreak 
                                                (cons 
                                                 (VERTEX::ppElem 
                                                  (SKETCH::|!eval|-1-1 
                                                   src_map 
                                                   edge)) 
                                                 (cons 
                                                  WADLERLINDIG::ppBreak 
                                                  (cons 
                                                   (WADLERLINDIG::ppString "->") 
                                                   (cons 
                                                    WADLERLINDIG::ppBreak 
                                                    (cons 
                                                     (VERTEX::ppElem 
                                                      (SKETCH::|!eval|-1-1 
                                                       target_map 
                                                       edge)) 
                                                     nil))))))))))) 
                                          (cons 
                                           WADLERLINDIG::ppBreak 
                                           (cons 
                                            (WADLERLINDIG::ppString "+->") 
                                            (cons 
                                             WADLERLINDIG::ppBreak 
                                             (cons 
                                              (let ((sm 
                                                     (POLYMAP::|!eval|-1-1 
                                                      edge_map 
                                                      edge))) 
                                                (let ((pV3 
                                                       (POLYMAP::evalPartial-1-1 
                                                        reverse_context 
                                                        (cons 
                                                         :|Morph| 
                                                         (vector 
                                                          (svref sm 0) 
                                                          (svref sm 1) 
                                                          (svref sm 2) 
                                                          (svref sm 3)))))) 
                                                  (block 
                                                   nil 
                                                   (if (eq (car pV3) :|Some|) 
                                                       (return 
                                                        (WADLERLINDIG::ppString 
                                                         (SPECCALC::relativeURI_ToString 
                                                          (cdr pV3)))) 
                                                       (if (eq (car pV3) :|None|) 
                                                           (return 
                                                            (SPECCALC::ppMorphismX-1-1-1 
                                                             base_spec 
                                                             reverse_context 
                                                             sm)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in printDiagram")))) 
                                              nil))))))) 
                                       pp_entries))) 
                                nil 
                                edge_set))) 
                          (WADLERLINDIG::ppFormat 
                           (WADLERLINDIG::ppGroup 
                            (WADLERLINDIG::ppConcat 
                             (cons 
                              (WADLERLINDIG::ppString "diagram {") 
                              (cons 
                               (WADLERLINDIG::ppNest-1-1 
                                9 
                                (WADLERLINDIG::ppSep-1-1 
                                 (WADLERLINDIG::ppCons-1-1 
                                  (WADLERLINDIG::ppString ",") 
                                  WADLERLINDIG::ppBreak) 
                                 (LIST-SPEC::|!++| 
                                  pp_vertice_entries 
                                  pp_edge_entries))) 
                               (cons (WADLERLINDIG::ppString "}") nil)))))))))))))))))))


(defun SPECCALC::printMorphism-1-1-1 (base_spec reverse_context sm) 
  (WADLERLINDIG::ppFormat 
   (SPECCALC::ppMorphismX-1-1-1 base_spec reverse_context sm)))

(defun SPECCALC::relativizePath-1-1 (base target) 
  (labels 
    ((removeCommonPrefix (base target) 
      (block 
       nil 
       (if (null base) (return target)) 
       (if (null target) (return (addUpLinks base nil))) 
       (if (consp base) 
           (let ((pV10 (cdr base))) 
             (if (consp target) 
                 (return 
                  (if (string=  (car base) (car target)) 
                      (removeCommonPrefix pV10 (cdr target)) 
                      (addUpLinks pV10 target)))))) 
       (error "Nonexhaustive match failure in relativizePath")))
     (addUpLinks (base target) 
      (block 
       nil 
       (if (null base) 
           (return target) 
           (if (consp base) 
               (return (LIST-SPEC::|!cons| ".." (addUpLinks (cdr base) target))))) 
       (error "Nonexhaustive match failure in relativizePath")))) 
    (removeCommonPrefix base target)))

(defun SPECCALC::relativizeURI-1-1 (base target) 
  (cons 
   :|URI_Relative| 
   (cons (car target) (SPECCALC::relativizePath-1-1 (cdr base) (cdr target)))))

(defun SPECCALC::evaluatePrint-1 (term) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 term) 
   #'(lambda (x) 
      (let ((dep_URIs (svref x 2))
            (time_stamp (svref x 1))
            (value (svref x 0))) 
        (SPECCALC::monadBind 
         (SPECCALC::pathToRelativeURI "/Library/Base") 
         #'(lambda (base_URI) 
            (SPECCALC::monadBind 
             (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) base_URI) 
             #'(lambda (x1) 
                (let ((pV9 (svref x1 0))) 
                  (block 
                   nil 
                   (if (eq (car pV9) :|Spec|) 
                       (let ((pV12 (cdr pV9))) 
                         (return 
                          (SPECCALC::monadBind 
                           #'SPECCALC::getGlobalContext-1 
                           #'(lambda (global_context) 
                              (SPECCALC::monadBind 
                               #'SPECCALC::getCurrentURI-1 
                               #'(lambda (current_URI) 
                                  (SPECCALC::monadBind 
                                   (SPECCALC::|!return| 
                                    (LIST-SPEC::foldr-1-1-1 
                                     #'(lambda (x11) 
                                        (let ((uri (car x11))) 
                                          (POLYMAP::update-1-1-1 
                                           (cdr x11) 
                                           (svref 
                                            (POLYMAP::|!eval|-1-1 
                                             global_context 
                                             uri) 
                                            0) 
                                           (SPECCALC::relativizeURI-1-1 
                                            current_URI 
                                            uri)))) 
                                     POLYMAP::emptyMap 
                                     dep_URIs)) 
                                   #'(lambda (reverse_context) 
                                      (SPECCALC::monadSeq 
                                       (SPECCALC::|!print| "
") 
                                       (SPECCALC::monadSeq 
                                        (block 
                                         nil 
                                         (if (eq (car value) :|Spec|) 
                                             (return 
                                              (SPECCALC::|!print| 
                                               (SPECCALC::printSpec-1-1-1 
                                                pV12 
                                                reverse_context 
                                                (cdr value)))) 
                                             (if (eq (car value) :|Morph|) 
                                                 (return 
                                                  (SPECCALC::|!print| 
                                                   (SPECCALC::printMorphism-1-1-1 
                                                    pV12 
                                                    reverse_context 
                                                    (cdr value)))) 
                                                 (if (eq (car value) :|Diag|) 
                                                     (return 
                                                      (SPECCALC::|!print| 
                                                       (SPECCALC::printDiagram-1-1-1 
                                                        pV12 
                                                        reverse_context 
                                                        (cdr value)))) 
                                                     (if (eq 
                                                          (car value) 
                                                          :|Colimit|) 
                                                         (return 
                                                          (SPECCALC::|!print| 
                                                           (SPECCALC::printColimit-1-1-1 
                                                            pV12 
                                                            reverse_context 
                                                            (cdr value)))) 
                                                         (if (eq 
                                                              (car value) 
                                                              :|Other|) 
                                                             (return 
                                                              (funcall (SPECCALC::evaluateOtherPrint 
                                                                        (cdr 
                                                                         value)) 
                                                                       (SPECCALC::positionOf-1 
                                                                        term))) 
                                                             (if (eq 
                                                                  (car value) 
                                                                  :|InProcess|) 
                                                                 (return 
                                                                  (SPECCALC::|!print| 
                                                                   "No value!")))))))) 
                                         (error 
                                          "Nonexhaustive match failure in evaluatePrint")) 
                                        (SPECCALC::monadSeq 
                                         (SPECCALC::|!print| "
") 
                                         (SPECCALC::|!return| 
                                          (vector value time_stamp dep_URIs)))))))))))))) 
                   (error "Nonexhaustive match failure in evaluatePrint")))))))))))


(defun SPECCALC::makeSnarkProveEvalForm
 (prover_options 
  snarkSortDecl 
  snarkOpDecls 
  snarkBaseHypothesis 
  snarkHypothesis 
  snarkConjecture 
  snarkLogFileName) 
  (LISP-SPEC::|!list| 
   (cons 
    (LISP-SPEC::|!symbol| "CL-USER" "WITH-OPEN-FILE") 
    (cons 
     (LISP-SPEC::|!list| 
      (cons 
       (LISP-SPEC::|!symbol| "CL-USER" "LOGFILE") 
       (cons 
        (LISP-SPEC::|!string| snarkLogFileName) 
        (cons 
         (LISP-SPEC::|!symbol| "KEYWORD" "DIRECTION") 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "OUTPUT") 
          (cons 
           (LISP-SPEC::|!symbol| "KEYWORD" "IF-EXISTS") 
           (cons (LISP-SPEC::|!symbol| "KEYWORD" "SUPERSEDE") nil))))))) 
     (cons 
      (LISP-SPEC::|!++| 
       (LISP-SPEC::|!++| 
        (LISP-SPEC::|!++| 
         (LISP-SPEC::|!++| 
          (LISP-SPEC::|!++| 
           (LISP-SPEC::|!++| 
            (LISP-SPEC::|!++| 
             (LISP-SPEC::|!list| 
              (cons 
               (LISP-SPEC::|!symbol| "CL" "LET") 
               (cons 
                (LISP-SPEC::|!list| 
                 (cons 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| "CL-USER" "*ERROR-OUTPUT*") 
                    (cons (LISP-SPEC::|!symbol| "CL-USER" "LOGFILE") nil))) 
                  (cons 
                   (LISP-SPEC::|!list| 
                    (cons 
                     (LISP-SPEC::|!symbol| "CL-USER" "*STANDARD-OUTPUT*") 
                     (cons (LISP-SPEC::|!symbol| "CL-USER" "LOGFILE") nil))) 
                   nil))) 
                (cons 
                 (LISP-SPEC::|!list| 
                  (cons (LISP-SPEC::|!symbol| "SNARK" "INITIALIZE") nil)) 
                 (cons 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| "SNARK" "RUN-TIME-LIMIT") 
                    (cons (LISP-SPEC::|!nat| 60) nil))) 
                  (cons 
                   (LISP-SPEC::|!list| 
                    (cons 
                     (LISP-SPEC::|!symbol| "SNARK" "USE-LISP-TYPES-AS-SORTS") 
                     (cons (LISP-SPEC::bool t) nil))) 
                   (cons 
                    (LISP-SPEC::|!list| 
                     (cons 
                      (LISP-SPEC::|!symbol| "SNARK" "USE-CODE-FOR-NUMBERS") 
                      (cons (LISP-SPEC::bool t) nil))) 
                    (cons 
                     (LISP-SPEC::|!list| 
                      (cons 
                       (LISP-SPEC::|!symbol| "SNARK" "USE-RESOLUTION") 
                       (cons (LISP-SPEC::bool t) nil))) 
                     nil)))))))) 
             (LISP-SPEC::|!list| snarkSortDecl)) 
            (LISP-SPEC::|!list| snarkOpDecls)) 
           (LISP-SPEC::|!list| prover_options)) 
          (LISP-SPEC::|!list| snarkBaseHypothesis)) 
         (LISP-SPEC::|!list| SPECCALC::baseAxioms)) 
        (LISP-SPEC::|!list| snarkHypothesis)) 
       (LISP-SPEC::|!list| (cons snarkConjecture nil))) 
      nil)))))

(defun SPECCALC::snarkConjecture (pV1 pV2 pV3) 
  (block 
   nil 
   (return 
    (let ((snarkFmla 
           (SPECCALC::mkSnarkFmla 
            pV1 
            pV2 
            "SNARK" 
            STRINGSET::empty 
            nil 
            (svref pV3 3)))) 
      (LISP-SPEC::|!list| 
       (cons 
        SPECCALC::snark_prove 
        (cons 
         (LISP-SPEC::|!quote| snarkFmla) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "NAME") 
          (cons (LISP-SPEC::|!symbol| "KEYWORD" (svref pV3 1)) nil))))))) 
   (error "Nonexhaustive match failure in snarkConjecture")))

(defun SPECCALC::proveWithHypothesis
 (proof_name 
  claim 
  hypothesis 
  spc 
  spec_name 
  base_hypothesis 
  base_spc 
  prover_name 
  prover_options 
  snarkLogFileName) 
  (progn (if (BOOLEAN-SPEC::~ (string=  prover_name "Snark")) 
             (STRING-SPEC::writeLine 
              (STRING-SPEC::^ 
               prover_name 
               " is not supported; using Snark instead.")) 
             nil) 
         (block 
          nil 
          (let ((pV10 (svref claim 1))
                (pV9 (svref claim 0))) 
            (return 
             (labels 
               ((claimType (ct) 
                 (block 
                  nil 
                  (if (eq (car ct) :|Conjecture|) 
                      (return "Conjecture") 
                      (if (eq (car ct) :|Theorem|) 
                          (return "Theorem") 
                          (if (eq (car ct) :|Axiom|) (return "Axiom")))) 
                  (error "Nonexhaustive match failure in proveWithHypothesis")))) 
               (let ((claim_type (claimType pV9))) 
                 (let ((snarkSortDecls (SPECCALC::snarkSorts-1 spc))) 
                   (let ((snarkOpDecls (SPECCALC::snarkOpDecls-1 spc))) 
                     (let ((snarkBaseHypothesis 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (prop) 
                                (SPECCALC::snarkProperty 
                                 SPECCALC::newContext 
                                 base_spc 
                                 prop)) 
                             base_hypothesis))) 
                       (let ((snarkHypothesis 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (prop) 
                                  (SPECCALC::snarkProperty 
                                   SPECCALC::newContext 
                                   spc 
                                   prop)) 
                               hypothesis))) 
                         (let ((snarkConjecture 
                                (SPECCALC::snarkConjecture 
                                 SPECCALC::newContext 
                                 spc 
                                 claim))) 
                           (let ((snarkEvalForm 
                                  (SPECCALC::makeSnarkProveEvalForm 
                                   prover_options 
                                   snarkSortDecls 
                                   snarkOpDecls 
                                   snarkBaseHypothesis 
                                   snarkHypothesis 
                                   snarkConjecture 
                                   snarkLogFileName))) 
                             (progn (if SYSTEM-SPEC::specwareDebug? 
                                        (STRING-SPEC::writeLine 
                                         "Calling Snark by evaluating: ") 
                                        nil) 
                                    (progn (if SYSTEM-SPEC::specwareDebug? 
                                               (LISP-SPEC::|!PPRINT| 
                                                snarkEvalForm) 
                                               (LISP-SPEC::|!list| nil)) 
                                           (let ((result 
                                                  (LISP-SPEC::|!apply| 
                                                   (LISP-SPEC::|!symbol| 
                                                    "CL" 
                                                    "FUNCALL") 
                                                   (cons 
                                                    (LISP-SPEC::|!list| 
                                                     (cons 
                                                      (LISP-SPEC::|!symbol| 
                                                       "SNARK" 
                                                       "LAMBDA") 
                                                      (cons 
                                                       (LISP-SPEC::|!nil|) 
                                                       (cons snarkEvalForm nil)))) 
                                                    nil)))) 
                                             (let ((proved 
                                                    (string=  
                                                     ":PROOF-FOUND" 
                                                     (SYSTEM-SPEC::toString 
                                                      result)))) 
                                               (progn (SPECCALC::displayProofResult 
                                                       proof_name 
                                                       claim_type 
                                                       pV10 
                                                       spec_name 
                                                       proved 
                                                       snarkLogFileName) 
                                                      proved))))))))))))))) 
          (error "Nonexhaustive match failure in proveWithHypothesis"))))

(defun SPECCALC::proveInSpec
 (proof_name 
  claim_name 
  spc 
  spec_name 
  base_spc 
  prover_name 
  assertions 
  prover_options 
  snarkLogFileName 
  pos) 
  (SPECCALC::monadBind 
   (let ((findClaimInSpec 
          (LIST-SPEC::firstUpTo-1-1 
           #'(lambda (x) (string=  claim_name (svref x 1))) 
           (svref spc 2)))) 
     (block 
      nil 
      (if (eq (car findClaimInSpec) :|None|) 
          (return 
           (SPECCALC::raise 
            (cons :|Proof| (cons pos "Claim name is not in spec.")))) 
          (if (eq (car findClaimInSpec) :|Some|) 
              (let ((pV7 (cdr findClaimInSpec))) 
                (return 
                 (let ((actualHypothesis 
                        (SPECCALC::actualHypothesis (cdr pV7) assertions pos))) 
                   (if (block 
                        nil 
                        (if (eq (car assertions) :|All|) 
                            (return t) 
                            (if (eq (car assertions) :|Explicit|) 
                                (return 
                                 ( =  
                                  (LIST-SPEC::|!length| actualHypothesis) 
                                  (LIST-SPEC::|!length| (cdr assertions)))))) 
                        (error "Nonexhaustive match failure in proveInSpec")) 
                       (SPECCALC::|!return| 
                        (SPECCALC::proveWithHypothesis 
                         proof_name 
                         (car pV7) 
                         actualHypothesis 
                         spc 
                         spec_name 
                         (svref base_spc 2) 
                         base_spc 
                         prover_name 
                         prover_options 
                         snarkLogFileName)) 
                       (SPECCALC::raise 
                        (cons :|Proof| (cons pos "assertion not in spec."))))))))) 
      (error "Nonexhaustive match failure in proveInSpec"))) 
   #'(lambda (result) (SPECCALC::|!return| result))))

(defun SPECCALC::proverOptionsFromSpec (name spc spec_name) 
  (SPECCALC::monadBind 
   (SPECCALC::|!return| (STANDARDSPEC::findTheOp spc name)) 
   #'(lambda (options) 
      (SPECCALC::monadBind 
       (block 
        nil 
        (if (eq (car options) :|Some|) 
            (let ((pV14 (svref (cdr options) 3))) 
              (if (consp pV14) 
                  (if (null (cdr pV14)) 
                      (return (SPECCALC::|!return| (cdr (car pV14)))))))) 
        (return 
         (SPECCALC::raise 
          (cons 
           :|SyntaxError| 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             "Cannot find prover option definition, " 
             (METASLANG::printQualifiedId name)) 
            (block 
             nil 
             (if (eq (car spec_name) :|Some|) 
                 (return 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ ", in Spec, " (cdr spec_name)) 
                   "."))) 
             (return "."))))))) 
       #'(lambda (options_def) 
          (SPECCALC::monadBind 
           (block 
            nil 
            (if (eq (car options_def) :|Fun|) 
                (let ((pV25 (svref (cdr options_def) 0))) 
                  (if (eq (car pV25) :|String|) 
                      (return (SPECCALC::|!return| (cdr pV25)))))) 
            (return 
             (SPECCALC::raise 
              (cons 
               :|SyntaxError| 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 "Prover option definition, " 
                 (METASLANG::printQualifiedId name)) 
                ", is not a string."))))) 
           #'(lambda (options_string) 
              (SPECCALC::monadBind 
               (SPECCALC::|!return| 
                (PARSER4::READ_LIST_OF_S_EXPRESSIONS_FROM_STRING options_string)) 
               #'(lambda (possible_options) 
                  (SPECCALC::monadBind 
                   (block 
                    nil 
                    (if (eq (car possible_options) :|OptionString|) 
                        (return (SPECCALC::|!return| (cdr possible_options))) 
                        (if (eq (car possible_options) :|Error|) 
                            (let ((pV30 (cdr possible_options))) 
                              (return 
                               (SPECCALC::raise 
                                (cons 
                                 :|SyntaxError| 
                                 (STRING-SPEC::^ (car pV30) (cdr pV30)))))))) 
                    (error 
                     "Nonexhaustive match failure in proverOptionsFromSpec")) 
                   #'(lambda (prover_options) 
                      (SPECCALC::|!return| prover_options))))))))))))

(defun SPECCALC::evaluateProve
 (claim_name spec_term prover_name assertions possible_options) 
  #'(lambda (pos) 
     (SPECCALC::monadBind 
      #'SPECCALC::getCurrentURI-1 
      #'(lambda (uri) 
         (SPECCALC::monadSeq 
          (SPECCALC::|!print| 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             ";;; Processing prove at " 
             (SPECCALC::uriToString-1 uri)) 
            "
")) 
          (SPECCALC::monadBind 
           (SPECCALC::evaluateTermInfo-1 spec_term) 
           #'(lambda (x) 
              (let ((depURIs (svref x 2))
                    (timeStamp (svref x 1))
                    (value (svref x 0))) 
                (SPECCALC::monadBind 
                 (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                          (cons 
                           :|SpecPath_Relative| 
                           (cons '(:|None|) (cons "Library" (cons "Base" nil))))) 
                 #'(lambda (x1) 
                    (let ((pV19 (svref x1 0))) 
                      (block 
                       nil 
                       (if (eq (car pV19) :|Spec|) 
                           (let ((pV22 (cdr pV19))) 
                             (return 
                              (SPECCALC::monadBind 
                               (funcall (SPECCALC::evaluateURI 
                                         (cons :|Internal| "ProverBase")) 
                                        (cons 
                                         :|SpecPath_Relative| 
                                         (cons 
                                          '(:|None|) 
                                          (cons 
                                           "Library" 
                                           (cons "Base" (cons "ProverBase" nil)))))) 
                               #'(lambda (x11) 
                                  (let ((pV15 (svref x11 0))) 
                                    (block 
                                     nil 
                                     (if (eq (car pV15) :|Spec|) 
                                         (let ((pV18 (cdr pV15))) 
                                           (return 
                                            (SPECCALC::monadBind 
                                             #'SPECCALC::getCurrentURI-1 
                                             #'(lambda (|!URI|) 
                                                (SPECCALC::monadBind 
                                                 (SPECCALC::URItoSnarkLogFile-1 
                                                  |!URI|) 
                                                 #'(lambda (snarkLogFileName) 
                                                    (SPECCALC::monadBind 
                                                     (SPECCALC::|!return| 
                                                      (IO-SPEC::ensureDirectoriesExist 
                                                       snarkLogFileName)) 
                                                     #'(lambda (pV5) 
                                                        (declare (ignore pV5)) 
                                                        (SPECCALC::monadBind 
                                                         (SPECCALC::|!return| 
                                                          (SPECCALC::URItoProofName-1 
                                                           |!URI|)) 
                                                         #'(lambda (proof_name) 
                                                            (SPECCALC::monadBind 
                                                             (SPECCALC::|!return| 
                                                              (SPECCALC::SpecTermToSpecName-1 
                                                               spec_term)) 
                                                             #'(lambda (spec_name) 
                                                                (SPECCALC::monadBind 
                                                                 (let ((pV7 
                                                                        (SPECCALC::coerceToSpec 
                                                                         value))) 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          pV7) 
                                                                         :|Spec|) 
                                                                        (return 
                                                                         (SPECCALC::|!return| 
                                                                          (cdr 
                                                                           pV7)))) 
                                                                    (return 
                                                                     (SPECCALC::raise 
                                                                      (cons 
                                                                       :|Proof| 
                                                                       (cons 
                                                                        pos 
                                                                        "Argument to prove command is not coerceable to a spec.")))))) 
                                                                 #'(lambda (uspc) 
                                                                    (SPECCALC::monadBind 
                                                                     (block 
                                                                      nil 
                                                                      (if (eq 
                                                                           (car 
                                                                            possible_options) 
                                                                           :|OptionString|) 
                                                                          (return 
                                                                           (SPECCALC::|!return| 
                                                                            (cdr 
                                                                             possible_options))) 
                                                                          (if (eq 
                                                                               (car 
                                                                                possible_options) 
                                                                               :|OptionName|) 
                                                                              (return 
                                                                               (SPECCALC::proverOptionsFromSpec 
                                                                                (cdr 
                                                                                 possible_options) 
                                                                                uspc 
                                                                                spec_name)) 
                                                                              (if (eq 
                                                                                   (car 
                                                                                    possible_options) 
                                                                                   :|Error|) 
                                                                                  (let ((pV10 
                                                                                         (cdr 
                                                                                          possible_options))) 
                                                                                    (return 
                                                                                     (SPECCALC::raise 
                                                                                      (cons 
                                                                                       :|SyntaxError| 
                                                                                       (STRING-SPEC::^ 
                                                                                        (car 
                                                                                         pV10) 
                                                                                        (cdr 
                                                                                         pV10))))))))) 
                                                                      (error 
                                                                       "Nonexhaustive match failure in evaluateProve")) 
                                                                     #'(lambda (prover_options) 
                                                                        (SPECCALC::monadBind 
                                                                         (SPECCALC::proveInSpec 
                                                                          proof_name 
                                                                          claim_name 
                                                                          (subtractSpec-1-1 
                                                                           uspc 
                                                                           pV22) 
                                                                          spec_name 
                                                                          pV18 
                                                                          prover_name 
                                                                          assertions 
                                                                          prover_options 
                                                                          snarkLogFileName 
                                                                          pos) 
                                                                         #'(lambda (proved) 
                                                                            (SPECCALC::monadBind 
                                                                             (SPECCALC::|!return| 
                                                                              (cons 
                                                                               :|Proof| 
                                                                               (cons 
                                                                                (if proved 
                                                                                    '(:|Proved|) 
                                                                                    '(:|Unproved|)) 
                                                                                |!URI|))) 
                                                                             #'(lambda (result) 
                                                                                (SPECCALC::|!return| 
                                                                                 (vector 
                                                                                  result 
                                                                                  timeStamp 
                                                                                  depURIs))))))))))))))))))))))) 
                                     (error 
                                      "Nonexhaustive match failure in evaluateProve")))))))) 
                       (error "Nonexhaustive match failure in evaluateProve")))))))))))))


(defun SPECCALC::evaluateProve-1 (x) 
  (SPECCALC::evaluateProve 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun SPECCALC::qualifySpec-1 (spc) 
  #'(lambda (new_qualifier) 
     #'(lambda (|!position|) 
        (labels 
          ((convertSpec (sp) 
            (let ((pV35 
                   (mapSpec-1-1 
                    (vector #'translateOp #'translateSort #'translatePattern) 
                    sp))) 
              (block 
               nil 
               (let ((pV38 (svref pV35 2))
                     (pV37 (svref pV35 1))
                     (pV36 (svref pV35 0))) 
                 (let ((pV43 (svref pV36 3))
                       (pV42 (svref pV36 2))
                       (pV41 (svref pV36 1))
                       (pV40 (svref pV36 0))) 
                   (return 
                    (SPECCALC::monadBind 
                     (convertSortMap (svref pV35 3)) 
                     #'(lambda (newSorts) 
                        (SPECCALC::monadBind 
                         (convertOpMap pV37) 
                         #'(lambda (newOps) 
                            (SPECCALC::|!return| 
                             (vector 
                              (vector 
                               pV40 
                               pV41 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateQualifiedId 
                                pV42) 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateQualifiedId 
                                pV43)) 
                              newOps 
                              pV38 
                              newSorts))))))))) 
               (error "Nonexhaustive match failure in qualifySpec"))))
           (convertSortMap (sortMap) 
            (labels 
              ((qualifyStep (pV28 pV29 pV30 pV31) 
                (block 
                 nil 
                 (return 
                  (let ((newSortInfo 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'translateQualifiedId 
                           (svref pV30 0)) 
                          (svref pV30 1) 
                          (svref pV30 2)))) 
                    (let ((newQualifier 
                           (if (string=  pV28 METASLANG::UnQualified) 
                               new_qualifier 
                               pV28))) 
                      (let ((oldSortInfo 
                             (findAQualifierMap pV31 newQualifier pV29))) 
                        (SPECCALC::monadBind 
                         (funcall (funcall (SPECCALC::mergeSortInfo-1 
                                            newSortInfo) 
                                           oldSortInfo) 
                                  |!position|) 
                         #'(lambda (sortInfo) 
                            (SPECCALC::|!return| 
                             (insertAQualifierMap 
                              pV31 
                              newQualifier 
                              pV29 
                              sortInfo)))))))) 
                 (error "Nonexhaustive match failure in qualifySpec")))) 
              (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                 #'(lambda (x) 
                                    (qualifyStep 
                                     (svref x 0) 
                                     (svref x 1) 
                                     (svref x 2) 
                                     (svref x 3)))) 
                                emptyAQualifierMap) 
                       sortMap)))
           (convertOpMap (opMap) 
            (labels 
              ((qualifyStep (pV20 pV21 pV22 pV23) 
                (block 
                 nil 
                 (return 
                  (let ((newOpInfo 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'translateQualifiedId 
                           (svref pV22 0)) 
                          (svref pV22 1) 
                          (svref pV22 2) 
                          (svref pV22 3)))) 
                    (let ((newQualifier 
                           (if (string=  pV20 METASLANG::UnQualified) 
                               new_qualifier 
                               pV20))) 
                      (let ((oldOpInfo 
                             (findAQualifierMap pV23 newQualifier pV21))) 
                        (SPECCALC::monadBind 
                         (funcall (funcall (SPECCALC::mergeOpInfo-1 newOpInfo) 
                                           oldOpInfo) 
                                  |!position|) 
                         #'(lambda (|!opInfo|) 
                            (SPECCALC::|!return| 
                             (insertAQualifierMap 
                              pV23 
                              newQualifier 
                              pV21 
                              |!opInfo|)))))))) 
                 (error "Nonexhaustive match failure in qualifySpec")))) 
              (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                 #'(lambda (x) 
                                    (qualifyStep 
                                     (svref x 0) 
                                     (svref x 1) 
                                     (svref x 2) 
                                     (svref x 3)))) 
                                emptyAQualifierMap) 
                       opMap)))
           (translatePattern (pat) pat)
           (translateSort (sort_term) 
            (block 
             nil 
             (if (eq (car sort_term) :|Base|) 
                 (let ((pV16 (cdr sort_term))) 
                   (let ((pV17 (svref pV16 0))) 
                     (return 
                      (let ((new_qid (translateQualifiedId pV17))) 
                        (if (slang-built-in::slang-term-equals new_qid pV17) 
                            sort_term 
                            (cons 
                             :|Base| 
                             (vector new_qid (svref pV16 1) (svref pV16 2))))))))) 
             (return sort_term)))
           (translateOp (op_term) 
            (block 
             nil 
             (if (eq (car op_term) :|Fun|) 
                 (let ((pV7 (cdr op_term))) 
                   (let ((pV8 (svref pV7 0))) 
                     (if (eq (car pV8) :|Op|) 
                         (let ((pV11 (cdr pV8))) 
                           (let ((pV12 (car pV11))) 
                             (return 
                              (let ((new_qid (translateQualifiedId pV12))) 
                                (if (slang-built-in::slang-term-equals 
                                     new_qid 
                                     pV12) 
                                    op_term 
                                    (cons 
                                     :|Fun| 
                                     (vector 
                                      (cons :|Op| (cons new_qid (cdr pV11))) 
                                      (svref pV7 1) 
                                      (svref pV7 2)))))))))))) 
             (return op_term)))
           (translateQualifiedId (qid) 
            (block 
             nil 
             (if (eq (car qid) :|Qualified|) 
                 (let ((pV2 (cdr qid))) 
                   (return 
                    (if (string=  (car pV2) METASLANG::UnQualified) 
                        (cons :|Qualified| (cons new_qualifier (cdr pV2))) 
                        qid)))) 
             (error "Nonexhaustive match failure in qualifySpec")))) 
          (convertSpec spc)))))

(defun SPECCALC::evaluateQualify-1 (term) 
  #'(lambda (new_qualifier) 
     (SPECCALC::monadBind 
      (SPECCALC::evaluateTermInfo-1 term) 
      #'(lambda (x) 
         (let ((depURIs (svref x 2))
               (timeStamp (svref x 1))) 
           (let ((pV2 (SPECCALC::coerceToSpec (svref x 0)))) 
             (block 
              nil 
              (if (eq (car pV2) :|Spec|) 
                  (return 
                   (SPECCALC::monadBind 
                    (funcall (funcall (SPECCALC::qualifySpec-1 (cdr pV2)) 
                                      new_qualifier) 
                             (SPECCALC::positionOf-1 term)) 
                    #'(lambda (qualified_spec) 
                       (SPECCALC::monadBind 
                        (funcall (SPECCALC::complainIfAmbiguous-1 
                                  (SPECCALC::compressDefs-1 qualified_spec)) 
                                 (SPECCALC::positionOf-1 term)) 
                        #'(lambda (compressed_spec) 
                           (SPECCALC::|!return| 
                            (vector 
                             (cons 
                              :|Spec| 
                              (vector 
                               (svref compressed_spec 0) 
                               (svref compressed_spec 1) 
                               (svref compressed_spec 2) 
                               (svref compressed_spec 3))) 
                             timeStamp 
                             depURIs)))))))) 
              (return 
               (SPECCALC::raise 
                (cons 
                 :|TypeCheck| 
                 (cons 
                  (SPECCALC::positionOf-1 term) 
                  "qualifying a term that is not a specification")))))))))))

(defun SPECCALC::evaluateSpecElem-1 (spc) 
  #'(lambda (x) 
     (let ((|!position| (cdr x))
           (elem (car x))) 
       (block 
        nil 
        (if (eq (car elem) :|Import|) 
            (return (SPECCALC::|!return| spc)) 
            (if (eq (car elem) :|Sort|) 
                (let ((pV5 (cdr elem))) 
                  (let ((pV17 (cdr pV5))) 
                    (return 
                     (funcall (funcall (funcall (funcall (SPECCALC::addSort 
                                                          (car pV5)) 
                                                         (car pV17)) 
                                                (cdr pV17)) 
                                       spc) 
                              |!position|)))) 
                (if (eq (car elem) :|Op|) 
                    (let ((pV4 (cdr elem))) 
                      (let ((pV12 (cdr pV4))) 
                        (return 
                         (funcall (funcall (funcall (funcall (funcall (SPECCALC::addOp 
                                                                       (car pV4)) 
                                                                      (svref 
                                                                       pV12 
                                                                       0)) 
                                                             (svref pV12 1)) 
                                                    (svref pV12 2)) 
                                           spc) 
                                  |!position|)))) 
                    (if (eq (car elem) :|Claim|) 
                        (let ((pV3 (cdr elem))) 
                          (progn (let ((pV10 (svref pV3 3))
                                       (pV9 (svref pV3 2))
                                       (pV8 (svref pV3 1))
                                       (pV7 (svref pV3 0))) 
                                   (if (eq (car pV7) :|Axiom|) 
                                       (return 
                                        (SPECCALC::|!return| 
                                         (addAxiom (vector pV8 pV9 pV10) spc))) 
                                       (if (eq (car pV7) :|Theorem|) 
                                           (return 
                                            (SPECCALC::|!return| 
                                             (addTheorem 
                                              (vector pV8 pV9 pV10) 
                                              spc))) 
                                           (if (eq (car pV7) :|Conjecture|) 
                                               (return 
                                                (SPECCALC::|!return| 
                                                 (addConjecture 
                                                  (vector pV8 pV9 pV10) 
                                                  spc))))))) 
                                 (return 
                                  (SPECCALC::|!error| 
                                   "evaluateSpecElem: unsupported claim type")))))))) 
        (error "Nonexhaustive match failure in evaluateSpecElem")))))

(defun SPECTOPOSSPEC::convertOpInfoToPOpInfo-1 (info) info)

(defun SPECTOPOSSPEC::convertSortInfoToPSortInfo-1 (info) info)

(defun SPECCALC::mergeImport-1 (spec_term) 
  #'(lambda (imported_spec) 
     #'(lambda (spec_a) 
        #'(lambda (|!position|) 
           (labels 
             ((mergeSortStep 
               (imported_qualifier 
                imported_id 
                imported_sort_info 
                combined_psorts) 
               (let ((newPSortInfo 
                      (SPECTOPOSSPEC::convertSortInfoToPSortInfo-1 
                       imported_sort_info))) 
                 (let ((oldPSortInfo 
                        (findAQualifierMap 
                         combined_psorts 
                         imported_qualifier 
                         imported_id))) 
                   (SPECCALC::monadBind 
                    (funcall (funcall (SPECCALC::mergeSortInfo-1 newPSortInfo) 
                                      oldPSortInfo) 
                             |!position|) 
                    #'(lambda (mergedSorts) 
                       (SPECCALC::|!return| 
                        (insertAQualifierMap 
                         combined_psorts 
                         imported_qualifier 
                         imported_id 
                         mergedSorts)))))))) 
             (labels 
               ((mergeOpStep 
                 (imported_qualifier imported_id imported_op_info combined_pops) 
                 (let ((newPOpInfo 
                        (SPECTOPOSSPEC::convertOpInfoToPOpInfo-1 
                         imported_op_info))) 
                   (let ((oldPOpInfo 
                          (findAQualifierMap 
                           combined_pops 
                           imported_qualifier 
                           imported_id))) 
                     (SPECCALC::monadBind 
                      (funcall (funcall (SPECCALC::mergeOpInfo-1 newPOpInfo) 
                                        oldPOpInfo) 
                               |!position|) 
                      #'(lambda (mergedOps) 
                         (SPECCALC::|!return| 
                          (insertAQualifierMap 
                           combined_pops 
                           imported_qualifier 
                           imported_id 
                           mergedOps)))))))) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| 
                 (addImport 
                  (cons (SPECCALC::showTerm-1 spec_term) imported_spec) 
                  spec_a)) 
                #'(lambda (spec_b) 
                   (SPECCALC::monadBind 
                    (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                       #'(lambda (x) 
                                          (mergeSortStep 
                                           (svref x 0) 
                                           (svref x 1) 
                                           (svref x 2) 
                                           (svref x 3)))) 
                                      (svref spec_b 3)) 
                             (svref imported_spec 3)) 
                    #'(lambda (sorts_b) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| (setSorts spec_b sorts_b)) 
                        #'(lambda (spec_c) 
                           (SPECCALC::monadBind 
                            (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                               #'(lambda (x) 
                                                  (mergeOpStep 
                                                   (svref x 0) 
                                                   (svref x 1) 
                                                   (svref x 2) 
                                                   (svref x 3)))) 
                                              (svref spec_c 1)) 
                                     (svref imported_spec 1)) 
                            #'(lambda (ops_c) 
                               (SPECCALC::monadBind 
                                (SPECCALC::|!return| (setOps spec_c ops_c)) 
                                #'(lambda (spec_d) 
                                   (SPECCALC::monadBind 
                                    (SPECCALC::|!return| 
                                     (setProperties 
                                      spec_d 
                                      (LISTUTILITIES::listUnion 
                                       (svref spec_d 2) 
                                       (svref imported_spec 2)))) 
                                    #'(lambda (spec_e) 
                                       (SPECCALC::|!return| spec_e)))))))))))))))))))


(defun SPECCALC::evaluateSpecImport-1 (val) 
  (let ((cDepURIs (svref val 2))
        (cTS (svref val 1))
        (spc (svref val 0))) 
    #'(lambda (x) 
       (let ((|!position| (cdr x))
             (elem (car x))) 
         (block 
          nil 
          (if (eq (car elem) :|Import|) 
              (let ((pV6 (cdr elem))) 
                (return 
                 (SPECCALC::monadBind 
                  (SPECCALC::evaluateTermInfo-1 pV6) 
                  #'(lambda (x1) 
                     (let ((depURIs (svref x1 2))
                           (iTS (svref x1 1))) 
                       (let ((pV2 (SPECCALC::coerceToSpec (svref x1 0)))) 
                         (block 
                          nil 
                          (if (eq (car pV2) :|Spec|) 
                              (return 
                               (SPECCALC::monadBind 
                                (funcall (funcall (funcall (SPECCALC::mergeImport-1 
                                                            pV6) 
                                                           (cdr pV2)) 
                                                  spc) 
                                         |!position|) 
                                #'(lambda (newSpc) 
                                   (SPECCALC::|!return| 
                                    (vector 
                                     newSpc 
                                     (INTEGER-SPEC::|!max| cTS iTS) 
                                     (LISTUTILITIES::listUnion cDepURIs depURIs))))))) 
                          (return 
                           (SPECCALC::raise (cons :|Fail| "Import not a spec"))))))))))) 
          (return (SPECCALC::|!return| val)))))))

(defun SPECTOPOSSPEC::convertSpecToPosSpec-1 (spc) spc)

(defun SPECCALC::maybeAddBaseImport (spc initialSpec) 
  (if (BOOLEAN-SPEC::~ (slang-built-in::slang-term-equals spc initialSpec)) 
      (SPECCALC::|!return| spc) 
      (SPECCALC::monadBind 
       #'SPECCALC::getCurrentURI-1 
       #'(lambda (uri) 
          (if (SPECCALC::baseSpecURI?-1 uri) 
              (SPECCALC::|!return| spc) 
              (SPECCALC::monadBind 
               (funcall (SPECCALC::evaluateURI 
                         (cons :|Internal| "adding base import")) 
                        (cons 
                         :|SpecPath_Relative| 
                         (cons '(:|None|) (cons "Library" (cons "Base" nil))))) 
               #'(lambda (x) 
                  (let ((pV3 (svref x 0))) 
                    (block 
                     nil 
                     (if (eq (car pV3) :|Spec|) 
                         (return 
                          (SPECCALC::|!return| 
                           (SPECTOPOSSPEC::convertSpecToPosSpec-1 (cdr pV3))))) 
                     (error "Nonexhaustive match failure in maybeAddBaseImport"))))))))))


(defun SPECCALC::evaluateSpecElems-1 (initialSpec) 
  #'(lambda (specElems) 
     (SPECCALC::monadBind 
      (funcall (funcall (SPECCALC::foldM #'SPECCALC::evaluateSpecImport-1) 
                        (vector initialSpec 0 nil)) 
               specElems) 
      #'(lambda (x) 
         (let ((depURIs (svref x 2))
               (|!TS| (svref x 1))) 
           (SPECCALC::monadBind 
            (SPECCALC::maybeAddBaseImport (svref x 0) initialSpec) 
            #'(lambda (spcWithImports) 
               (SPECCALC::monadBind 
                (funcall (funcall (SPECCALC::foldM 
                                   #'SPECCALC::evaluateSpecElem-1) 
                                  spcWithImports) 
                         specElems) 
                #'(lambda (fullSpec) 
                   (SPECCALC::|!return| (vector fullSpec |!TS| depURIs)))))))))))


(defun SPECCALC::evaluateSpec (spec_elements) 
  #'(lambda (|!position|) 
     (SPECCALC::monadBind 
      #'SPECCALC::getCurrentURI-1 
      #'(lambda (uri) 
         (SPECCALC::monadSeq 
          (SPECCALC::|!print| 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             ";;; Processing spec at " 
             (SPECCALC::uriToString-1 uri)) 
            "
")) 
          (SPECCALC::monadBind 
           (funcall (SPECCALC::evaluateSpecElems-1 emptySpec) spec_elements) 
           #'(lambda (x) 
              (let ((depURIs (svref x 2))
                    (|!TS| (svref x 1))) 
                (SPECCALC::monadBind 
                 (SPECCALC::elaborateSpecM-1 (svref x 0)) 
                 #'(lambda (elaborated_spec) 
                    (SPECCALC::monadBind 
                     (funcall (SPECCALC::complainIfAmbiguous-1 
                               (SPECCALC::compressDefs-1 elaborated_spec)) 
                              |!position|) 
                     #'(lambda (compressed_spec) 
                        (SPECCALC::|!return| 
                         (vector 
                          (cons 
                           :|Spec| 
                           (vector 
                            (svref compressed_spec 0) 
                            (svref compressed_spec 1) 
                            (svref compressed_spec 2) 
                            (svref compressed_spec 3))) 
                          |!TS| 
                          depURIs))))))))))))))

(defun SPECCALC::evaluateOtherSpecMorph-1 (spc) 
  #'(lambda (morph) 
     #'(lambda (rules) 
        #'(lambda (pos) 
           (SPECCALC::monadBind 
            #'SPECCALC::getCurrentURI-1 
            #'(lambda (uri) 
               (SPECCALC::raise 
                (cons 
                 :|TypeCheck| 
                 (cons 
                  pos 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    "Unexpected OtherTerm at " 
                    (SPECCALC::uriToString-1 uri)) 
                   "
"))))))))))

(defun SPECCALC::evaluateOtherSpecMorph (x0 x1 x2) 
  (SPECCALC::evaluateOtherSpecMorph-1 (vector x0 x1 x2)))

(defun SPECCALC::makeResolvedMapping-1 (dom_spec) 
  #'(lambda (cod_spec) 
     #'(lambda (sm_rules) 
        (labels 
          ((insert (op_map sort_map) 
            #'(lambda (x) 
               (let ((|!position| (cdr x))
                     (sm_rule (car x))) 
                 (block 
                  nil 
                  (if (eq (car sm_rule) :|Sort|) 
                      (let ((pV122 (cdr sm_rule))) 
                        (let ((pV131 (car pV122))) 
                          (return 
                           (let ((pV45 
                                  (STANDARDSPEC::findAllSorts dom_spec pV131))) 
                             (block 
                              nil 
                              (if (consp pV45) 
                                  (let ((pV49 (svref (car pV45) 0))) 
                                    (if (consp pV49) 
                                        (let ((pV53 (car pV49))) 
                                          (if (eq (car pV53) :|Qualified|) 
                                              (let ((pV55 (cdr pV53))) 
                                                (let ((pV57 (cdr pV55))
                                                      (pV56 (car pV55))) 
                                                  (return 
                                                   (SPECCALC::monadSeq 
                                                    (funcall (SPECCALC::|!when| 
                                                              (cl:and 
                                                               (BOOLEAN-SPEC::~ 
                                                                (slang-built-in::slang-term-equals 
                                                                 (cdr pV45) 
                                                                 nil)) 
                                                               (BOOLEAN-SPEC::~ 
                                                                (string=  
                                                                 pV56 
                                                                 METASLANG::UnQualified)))) 
                                                             (SPECCALC::raise 
                                                              (cons 
                                                               :|MorphError| 
                                                               (cons 
                                                                |!position| 
                                                                (STRING-SPEC::^ 
                                                                 "Ambiguous source sort " 
                                                                 (METASLANG::printQualifiedId 
                                                                  pV131)))))) 
                                                    (let ((pV43 
                                                           (findAQualifierMap 
                                                            sort_map 
                                                            pV56 
                                                            pV57))) 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV43) 
                                                            :|None|) 
                                                           (return 
                                                            (SPECCALC::monadBind 
                                                             (funcall (findCodSort 
                                                                       |!position|) 
                                                                      (cdr pV122)) 
                                                             #'(lambda (cod_sort) 
                                                                (SPECCALC::|!return| 
                                                                 (cons 
                                                                  op_map 
                                                                  (insertAQualifierMap 
                                                                   sort_map 
                                                                   pV56 
                                                                   pV57 
                                                                   cod_sort))))))) 
                                                       (return 
                                                        (SPECCALC::raise 
                                                         (cons 
                                                          :|MorphError| 
                                                          (cons 
                                                           |!position| 
                                                           (STRING-SPEC::^ 
                                                            "Multiple rules for source sort " 
                                                            (METASLANG::printQualifiedId 
                                                             pV131))))))))))))))))) 
                              (return 
                               (SPECCALC::raise 
                                (cons 
                                 :|MorphError| 
                                 (cons 
                                  |!position| 
                                  (STRING-SPEC::^ 
                                   "Unrecognized source sort " 
                                   (METASLANG::printQualifiedId pV131))))))))))) 
                      (if (eq (car sm_rule) :|Op|) 
                          (let ((pV121 (cdr sm_rule))) 
                            (let ((pV127 (car (car pV121)))) 
                              (return 
                               (let ((pV65 
                                      (STANDARDSPEC::findAllOps dom_spec pV127))) 
                                 (block 
                                  nil 
                                  (if (consp pV65) 
                                      (let ((pV69 (svref (car pV65) 0))) 
                                        (if (consp pV69) 
                                            (let ((pV74 (car pV69))) 
                                              (if (eq (car pV74) :|Qualified|) 
                                                  (let ((pV76 (cdr pV74))) 
                                                    (let ((pV78 (cdr pV76))
                                                          (pV77 (car pV76))) 
                                                      (return 
                                                       (SPECCALC::monadSeq 
                                                        (funcall (SPECCALC::|!when| 
                                                                  (cl:and 
                                                                   (BOOLEAN-SPEC::~ 
                                                                    (slang-built-in::slang-term-equals 
                                                                     (cdr pV65) 
                                                                     nil)) 
                                                                   (BOOLEAN-SPEC::~ 
                                                                    (string=  
                                                                     pV77 
                                                                     METASLANG::UnQualified)))) 
                                                                 (SPECCALC::raise 
                                                                  (cons 
                                                                   :|MorphError| 
                                                                   (cons 
                                                                    |!position| 
                                                                    (STRING-SPEC::^ 
                                                                     "Ambiguous source op " 
                                                                     (METASLANG::printQualifiedId 
                                                                      pV127)))))) 
                                                        (let ((pV63 
                                                               (findAQualifierMap 
                                                                op_map 
                                                                pV77 
                                                                pV78))) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car pV63) 
                                                                :|None|) 
                                                               (return 
                                                                (SPECCALC::monadBind 
                                                                 (funcall (findCodOp 
                                                                           |!position|) 
                                                                          (car 
                                                                           (cdr 
                                                                            pV121))) 
                                                                 #'(lambda (cod_op) 
                                                                    (SPECCALC::|!return| 
                                                                     (cons 
                                                                      (insertAQualifierMap 
                                                                       op_map 
                                                                       pV77 
                                                                       pV78 
                                                                       cod_op) 
                                                                      sort_map)))))) 
                                                           (return 
                                                            (SPECCALC::raise 
                                                             (cons 
                                                              :|MorphError| 
                                                              (cons 
                                                               |!position| 
                                                               (STRING-SPEC::^ 
                                                                "Multiple rules for source op " 
                                                                (METASLANG::printQualifiedId 
                                                                 pV127))))))))))))))))) 
                                  (return 
                                   (SPECCALC::raise 
                                    (cons 
                                     :|MorphError| 
                                     (cons 
                                      |!position| 
                                      (STRING-SPEC::^ 
                                       "Unrecognized source op " 
                                       (METASLANG::printQualifiedId pV127))))))))))) 
                          (if (eq (car sm_rule) :|Ambiguous|) 
                              (let ((pV120 (cdr sm_rule))) 
                                (let ((pV124 (cdr pV120))
                                      (pV123 (car pV120))) 
                                  (return 
                                   (let ((dom_sorts 
                                          (STANDARDSPEC::findAllSorts 
                                           dom_spec 
                                           pV123))) 
                                     (let ((dom_ops 
                                            (STANDARDSPEC::findAllOps 
                                             dom_spec 
                                             pV123))) 
                                       (block 
                                        nil 
                                        (if (consp dom_sorts) 
                                            (let ((pV110 
                                                   (svref (car dom_sorts) 0))) 
                                              (if (consp pV110) 
                                                  (let ((pV114 (car pV110))) 
                                                    (if (eq 
                                                         (car pV114) 
                                                         :|Qualified|) 
                                                        (let ((pV116 (cdr pV114))) 
                                                          (let ((pV118 
                                                                 (cdr pV116))
                                                                (pV117 
                                                                 (car pV116))) 
                                                            (if (null dom_ops) 
                                                                (return 
                                                                 (SPECCALC::monadSeq 
                                                                  (funcall (SPECCALC::|!when| 
                                                                            (cl:and 
                                                                             (BOOLEAN-SPEC::~ 
                                                                              (slang-built-in::slang-term-equals 
                                                                               (cdr 
                                                                                dom_sorts) 
                                                                               nil)) 
                                                                             (BOOLEAN-SPEC::~ 
                                                                              (string=  
                                                                               pV117 
                                                                               METASLANG::UnQualified)))) 
                                                                           (SPECCALC::raise 
                                                                            (cons 
                                                                             :|MorphError| 
                                                                             (cons 
                                                                              |!position| 
                                                                              (STRING-SPEC::^ 
                                                                               "Ambiguous source sort " 
                                                                               (METASLANG::printQualifiedId 
                                                                                pV123)))))) 
                                                                  (let ((pV83 
                                                                         (findAQualifierMap 
                                                                          sort_map 
                                                                          pV117 
                                                                          pV118))) 
                                                                    (block 
                                                                     nil 
                                                                     (if (eq 
                                                                          (car 
                                                                           pV83) 
                                                                          :|None|) 
                                                                         (return 
                                                                          (SPECCALC::monadBind 
                                                                           (funcall (findCodSort 
                                                                                     |!position|) 
                                                                                    pV124) 
                                                                           #'(lambda (cod_sort) 
                                                                              (SPECCALC::|!return| 
                                                                               (cons 
                                                                                op_map 
                                                                                (insertAQualifierMap 
                                                                                 sort_map 
                                                                                 pV117 
                                                                                 pV118 
                                                                                 cod_sort))))))) 
                                                                     (return 
                                                                      (SPECCALC::raise 
                                                                       (cons 
                                                                        :|MorphError| 
                                                                        (cons 
                                                                         |!position| 
                                                                         (STRING-SPEC::^ 
                                                                          "Multiple rules for source sort " 
                                                                          (METASLANG::printQualifiedId 
                                                                           pV123))))))))))))))))) 
                                            (if (null dom_sorts) 
                                                (if (null dom_ops) 
                                                    (return 
                                                     (SPECCALC::raise 
                                                      (cons 
                                                       :|MorphError| 
                                                       (cons 
                                                        |!position| 
                                                        (STRING-SPEC::^ 
                                                         "Unrecognized source sort/op identifier " 
                                                         (METASLANG::printQualifiedId 
                                                          pV123)))))) 
                                                    (if (consp dom_ops) 
                                                        (let ((pV98 
                                                               (svref 
                                                                (car dom_ops) 
                                                                0))) 
                                                          (if (consp pV98) 
                                                              (let ((pV103 
                                                                     (car pV98))) 
                                                                (if (eq 
                                                                     (car pV103) 
                                                                     :|Qualified|) 
                                                                    (let ((pV105 
                                                                           (cdr 
                                                                            pV103))) 
                                                                      (let ((pV107 
                                                                             (cdr 
                                                                              pV105))
                                                                            (pV106 
                                                                             (car 
                                                                              pV105))) 
                                                                        (return 
                                                                         (SPECCALC::monadSeq 
                                                                          (funcall (SPECCALC::|!when| 
                                                                                    (cl:and 
                                                                                     (BOOLEAN-SPEC::~ 
                                                                                      (slang-built-in::slang-term-equals 
                                                                                       (cdr 
                                                                                        dom_ops) 
                                                                                       nil)) 
                                                                                     (BOOLEAN-SPEC::~ 
                                                                                      (string=  
                                                                                       pV106 
                                                                                       METASLANG::UnQualified)))) 
                                                                                   (SPECCALC::raise 
                                                                                    (cons 
                                                                                     :|MorphError| 
                                                                                     (cons 
                                                                                      |!position| 
                                                                                      (STRING-SPEC::^ 
                                                                                       "Ambiguous source op " 
                                                                                       (METASLANG::printQualifiedId 
                                                                                        pV123)))))) 
                                                                          (let ((pV89 
                                                                                 (findAQualifierMap 
                                                                                  op_map 
                                                                                  pV106 
                                                                                  pV107))) 
                                                                            (block 
                                                                             nil 
                                                                             (if (eq 
                                                                                  (car 
                                                                                   pV89) 
                                                                                  :|None|) 
                                                                                 (return 
                                                                                  (SPECCALC::monadBind 
                                                                                   (funcall (findCodOp 
                                                                                             |!position|) 
                                                                                            pV124) 
                                                                                   #'(lambda (cod_op) 
                                                                                      (SPECCALC::|!return| 
                                                                                       (cons 
                                                                                        (insertAQualifierMap 
                                                                                         op_map 
                                                                                         pV106 
                                                                                         pV107 
                                                                                         cod_op) 
                                                                                        sort_map)))))) 
                                                                             (return 
                                                                              (SPECCALC::raise 
                                                                               (cons 
                                                                                :|MorphError| 
                                                                                (cons 
                                                                                 |!position| 
                                                                                 (STRING-SPEC::^ 
                                                                                  "Multiple rules for source op " 
                                                                                  (METASLANG::printQualifiedId 
                                                                                   pV123)))))))))))))))))))) 
                                        (return 
                                         (SPECCALC::raise 
                                          (cons 
                                           :|MorphError| 
                                           (cons 
                                            |!position| 
                                            (STRING-SPEC::^ 
                                             "Ambiguous source sort/op identifier " 
                                             (METASLANG::printQualifiedId pV123)))))) 
                                        (error 
                                         "Nonexhaustive match failure in makeResolvedMapping")))))))))) 
                  (error "Nonexhaustive match failure in makeResolvedMapping")))))
           (findCodSort (|!position|) 
            #'(lambda (qid) 
               (let ((pV26 (STANDARDSPEC::findAllSorts cod_spec qid))) 
                 (block 
                  nil 
                  (if (consp pV26) 
                      (let ((pV30 (svref (car pV26) 0))) 
                        (if (consp pV30) 
                            (let ((pV34 (car pV30))) 
                              (if (eq (car pV34) :|Qualified|) 
                                  (return 
                                   (SPECCALC::monadSeq 
                                    (funcall (SPECCALC::|!when| 
                                              (cl:and 
                                               (BOOLEAN-SPEC::~ 
                                                (slang-built-in::slang-term-equals 
                                                 (cdr pV26) 
                                                 nil)) 
                                               (BOOLEAN-SPEC::~ 
                                                (string=  
                                                 (car (cdr pV34)) 
                                                 METASLANG::UnQualified)))) 
                                             (SPECCALC::raise 
                                              (cons 
                                               :|MorphError| 
                                               (cons 
                                                |!position| 
                                                (STRING-SPEC::^ 
                                                 "Ambiguous target sort " 
                                                 (METASLANG::printQualifiedId 
                                                  qid)))))) 
                                    (SPECCALC::|!return| pV34)))))))) 
                  (return 
                   (SPECCALC::raise 
                    (cons 
                     :|MorphError| 
                     (cons 
                      |!position| 
                      (STRING-SPEC::^ 
                       "Unrecognized target sort " 
                       (METASLANG::printQualifiedId qid))))))))))
           (findCodOp (|!position|) 
            #'(lambda (qid) 
               (let ((pV7 (STANDARDSPEC::findAllOps cod_spec qid))) 
                 (block 
                  nil 
                  (if (consp pV7) 
                      (let ((pV11 (svref (car pV7) 0))) 
                        (if (consp pV11) 
                            (let ((pV16 (car pV11))) 
                              (if (eq (car pV16) :|Qualified|) 
                                  (return 
                                   (SPECCALC::monadSeq 
                                    (funcall (SPECCALC::|!when| 
                                              (cl:and 
                                               (BOOLEAN-SPEC::~ 
                                                (slang-built-in::slang-term-equals 
                                                 (cdr pV7) 
                                                 nil)) 
                                               (BOOLEAN-SPEC::~ 
                                                (string=  
                                                 (car (cdr pV16)) 
                                                 METASLANG::UnQualified)))) 
                                             (SPECCALC::raise 
                                              (cons 
                                               :|MorphError| 
                                               (cons 
                                                |!position| 
                                                (STRING-SPEC::^ 
                                                 "Ambiguous target op " 
                                                 (METASLANG::printQualifiedId 
                                                  qid)))))) 
                                    (SPECCALC::|!return| pV16)))))))) 
                  (return 
                   (SPECCALC::raise 
                    (cons 
                     :|MorphError| 
                     (cons 
                      |!position| 
                      (STRING-SPEC::^ 
                       "Unrecognized target op " 
                       (METASLANG::printQualifiedId qid))))))))))) 
          (funcall (funcall (SPECCALC::foldM 
                             #'(lambda (x) (insert (car x) (cdr x)))) 
                            (cons emptyAQualifierMap emptyAQualifierMap)) 
                   sm_rules)))))

(defun SPECCALC::makeSpecMorphism-1 (domSpec) 
  #'(lambda (codSpec) 
     #'(lambda (rawMapping) 
        #'(lambda (|!position|) 
           (SPECCALC::monadBind 
            (funcall (funcall (SPECCALC::makeResolvedMapping-1 domSpec) codSpec) 
                     rawMapping) 
            #'(lambda (morph) 
               (funcall (funcall (funcall (SPECCALC::buildSpecMorphism-1 domSpec) 
                                          codSpec) 
                                 morph) 
                        |!position|)))))))

(defun SPECCALC::evaluateSpecMorph (domTerm codTerm morphRules) 
  (SPECCALC::monadBind 
   #'SPECCALC::getCurrentURI-1 
   #'(lambda (uri) 
      (SPECCALC::monadSeq 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          ";;; Processing spec morphism at " 
          (SPECCALC::uriToString-1 uri)) 
         "
")) 
       (SPECCALC::monadBind 
        (SPECCALC::evaluateTermInfo-1 domTerm) 
        #'(lambda (x) 
           (let ((domDepURIs (svref x 2))
                 (domTimeStamp (svref x 1))
                 (domValue (svref x 0))) 
             (SPECCALC::monadBind 
              (SPECCALC::evaluateTermInfo-1 codTerm) 
              #'(lambda (x1) 
                 (let ((codDepURIs (svref x1 2))
                       (codTimeStamp (svref x1 1))
                       (codValue (svref x1 0))) 
                   (SPECCALC::monadBind 
                    (SPECCALC::|!return| (SPECCALC::coerceToSpec domValue)) 
                    #'(lambda (coercedDomValue) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| (SPECCALC::coerceToSpec codValue)) 
                        #'(lambda (coercedCodValue) 
                           (block 
                            nil 
                            (if (eq (car coercedDomValue) :|Spec|) 
                                (if (eq (car coercedCodValue) :|Spec|) 
                                    (return 
                                     (SPECCALC::monadBind 
                                      (funcall (funcall (funcall (SPECCALC::makeSpecMorphism-1 
                                                                  (cdr 
                                                                   coercedDomValue)) 
                                                                 (cdr 
                                                                  coercedCodValue)) 
                                                        morphRules) 
                                               (SPECCALC::positionOf-1 domTerm)) 
                                      #'(lambda (morph) 
                                         (SPECCALC::|!return| 
                                          (vector 
                                           (cons 
                                            :|Morph| 
                                            (vector 
                                             (svref morph 0) 
                                             (svref morph 1) 
                                             (svref morph 2) 
                                             (svref morph 3))) 
                                           (INTEGER-SPEC::|!max| 
                                            domTimeStamp 
                                            codTimeStamp) 
                                           (LISTUTILITIES::listUnion 
                                            domDepURIs 
                                            codDepURIs))))))) 
                                (if (eq (car coercedDomValue) :|Other|) 
                                    (return 
                                     (funcall (funcall (funcall (SPECCALC::evaluateOtherSpecMorph 
                                                                 coercedDomValue 
                                                                 domTimeStamp 
                                                                 domDepURIs) 
                                                                (vector 
                                                                 coercedCodValue 
                                                                 codTimeStamp 
                                                                 codDepURIs)) 
                                                       morphRules) 
                                              (SPECCALC::positionOf-1 domTerm))))) 
                            (if (eq (car coercedCodValue) :|Other|) 
                                (return 
                                 (funcall (funcall (funcall (SPECCALC::evaluateOtherSpecMorph 
                                                             coercedDomValue 
                                                             domTimeStamp 
                                                             domDepURIs) 
                                                            (vector 
                                                             coercedCodValue 
                                                             codTimeStamp 
                                                             codDepURIs)) 
                                                   morphRules) 
                                          (SPECCALC::positionOf-1 codTerm)))) 
                            (if (eq (car coercedDomValue) :|Spec|) 
                                (return 
                                 (SPECCALC::raise 
                                  (cons 
                                   :|TypeCheck| 
                                   (cons 
                                    (SPECCALC::positionOf-1 domTerm) 
                                    "domain of spec morphism is not a spec"))))) 
                            (if (eq (car coercedCodValue) :|Spec|) 
                                (return 
                                 (SPECCALC::raise 
                                  (cons 
                                   :|TypeCheck| 
                                   (cons 
                                    (SPECCALC::positionOf-1 codTerm) 
                                    "codomain of spec morphism is not a spec"))))) 
                            (return 
                             (SPECCALC::raise 
                              (cons 
                               :|TypeCheck| 
                               (cons 
                                (SPECCALC::positionOf-1 domTerm) 
                                "domain and codomain of spec morphism are not specs")))) 
                            (error 
                             "Nonexhaustive match failure in evaluateSpecMorph"))))))))))))))))


(defun SPECCALC::evaluateSpecMorph-1 (x) 
  (SPECCALC::evaluateSpecMorph (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::evaluateOtherSubstitute-1 (morph) 
  #'(lambda (other) 
     #'(lambda (morphTerm) 
        #'(lambda (pos) 
           (SPECCALC::monadBind 
            #'SPECCALC::getCurrentURI-1 
            #'(lambda (uri) 
               (SPECCALC::raise 
                (cons 
                 :|TypeCheck| 
                 (cons 
                  pos 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    "Unexpected OtherTerm at " 
                    (SPECCALC::uriToString-1 uri)) 
                   "
"))))))))))

(defun SPECCALC::evaluateOtherSubstitute (x0 x1 x2) 
  (SPECCALC::evaluateOtherSubstitute-1 (vector x0 x1 x2)))

(defun SPECCALC::evaluateSubstitute (spec_tm morph_tm) 
  #'(lambda (term_pos) 
     (SPECCALC::monadBind 
      #'SPECCALC::getCurrentURI-1 
      #'(lambda (uri) 
         (SPECCALC::monadSeq 
          (SPECCALC::|!print| 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             ";;; Processing substitution at " 
             (SPECCALC::uriToString-1 uri)) 
            "
")) 
          (SPECCALC::monadBind 
           (SPECCALC::evaluateTermInfo-1 spec_tm) 
           #'(lambda (x) 
              (let ((spec_dep_URIs (svref x 2))
                    (spec_timestamp (svref x 1))
                    (spec_value (svref x 0))) 
                (SPECCALC::monadBind 
                 (SPECCALC::evaluateTermInfo-1 morph_tm) 
                 #'(lambda (x1) 
                    (let ((morph_dep_URIs (svref x1 2))
                          (morph_timestamp (svref x1 1))
                          (morph_value (svref x1 0))) 
                      (SPECCALC::monadBind 
                       (SPECCALC::|!return| (SPECCALC::coerceToSpec spec_value)) 
                       #'(lambda (coercedSpecValue) 
                          (block 
                           nil 
                           (if (eq (car coercedSpecValue) :|Spec|) 
                               (if (eq (car morph_value) :|Morph|) 
                                   (return 
                                    (let ((timeStamp 
                                           (INTEGER-SPEC::|!max| 
                                            spec_timestamp 
                                            morph_timestamp))) 
                                      (let ((dep_URIs 
                                             (LISTUTILITIES::listUnion 
                                              spec_dep_URIs 
                                              morph_dep_URIs))) 
                                        (SPECCALC::monadBind 
                                         (funcall (funcall (funcall (SPECCALC::attemptSubstitution-1 
                                                                     (cdr 
                                                                      coercedSpecValue)) 
                                                                    (cdr 
                                                                     morph_value)) 
                                                           morph_tm) 
                                                  term_pos) 
                                         #'(lambda (new_spec) 
                                            (SPECCALC::monadBind 
                                             (funcall (SPECCALC::complainIfAmbiguous-1 
                                                       (SPECCALC::compressDefs-1 
                                                        new_spec)) 
                                                      term_pos) 
                                             #'(lambda (compressed_spec) 
                                                (SPECCALC::|!return| 
                                                 (vector 
                                                  (cons 
                                                   :|Spec| 
                                                   (vector 
                                                    (svref compressed_spec 0) 
                                                    (svref compressed_spec 1) 
                                                    (svref compressed_spec 2) 
                                                    (svref compressed_spec 3))) 
                                                  timeStamp 
                                                  dep_URIs)))))))))) 
                               (if (eq (car coercedSpecValue) :|Other|) 
                                   (if (eq (car morph_value) :|Morph|) 
                                       (return 
                                        (funcall (funcall (funcall (SPECCALC::evaluateOtherSubstitute 
                                                                    coercedSpecValue 
                                                                    spec_timestamp 
                                                                    spec_dep_URIs) 
                                                                   (vector 
                                                                    morph_value 
                                                                    morph_timestamp 
                                                                    morph_dep_URIs)) 
                                                          morph_tm) 
                                                 term_pos))))) 
                           (if (eq (car morph_value) :|Morph|) 
                               (return 
                                (SPECCALC::raise 
                                 (cons 
                                  :|TypeCheck| 
                                  (cons 
                                   (SPECCALC::positionOf-1 spec_tm) 
                                   "substitution attempted on a non-spec"))))) 
                           (if (eq (car coercedSpecValue) :|Spec|) 
                               (return 
                                (SPECCALC::raise 
                                 (cons 
                                  :|TypeCheck| 
                                  (cons 
                                   (SPECCALC::positionOf-1 morph_tm) 
                                   "substitution is not a morphism"))))) 
                           (return 
                            (SPECCALC::raise 
                             (cons 
                              :|TypeCheck| 
                              (cons 
                               term_pos 
                               "substitution is not a morphism, and is attempted on a non-spec")))) 
                           (error 
                            "Nonexhaustive match failure in evaluateSubstitute")))))))))))))))


(defun SPECCALC::evaluateSubstitute-1 (x) 
  (SPECCALC::evaluateSubstitute (car x) (cdr x)))

(defun SPECCALC::evaluateTranslate-1 (term) 
  #'(lambda (translation) 
     (SPECCALC::monadBind 
      #'SPECCALC::getCurrentURI-1 
      #'(lambda (uri) 
         (SPECCALC::monadSeq 
          (SPECCALC::|!print| 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             ";;; Processing translation at " 
             (SPECCALC::uriToString-1 uri)) 
            "
")) 
          (SPECCALC::monadBind 
           (SPECCALC::evaluateTermInfo-1 term) 
           #'(lambda (x) 
              (let ((depURIs (svref x 2))
                    (timeStamp (svref x 1))) 
                (let ((pV2 (SPECCALC::coerceToSpec (svref x 0)))) 
                  (block 
                   nil 
                   (if (eq (car pV2) :|Spec|) 
                       (return 
                        (SPECCALC::monadBind 
                         (funcall (SPECCALC::translateSpec-1 (cdr pV2)) 
                                  translation) 
                         #'(lambda (spcTrans) 
                            (SPECCALC::|!return| 
                             (vector 
                              (cons 
                               :|Spec| 
                               (vector 
                                (svref spcTrans 0) 
                                (svref spcTrans 1) 
                                (svref spcTrans 2) 
                                (svref spcTrans 3))) 
                              timeStamp 
                              depURIs)))))) 
                   (return 
                    (SPECCALC::raise 
                     (cons 
                      :|TypeCheck| 
                      (cons 
                       (SPECCALC::positionOf-1 term) 
                       "translating a term that is not a specification"))))))))))))))


(defun SPECCALC::evaluateTermInfo-1 (term) 
  (let ((pos (SPECCALC::positionOf-1 term))) 
    (let ((pV1 (SPECCALC::valueOf-1 term))) 
      (block 
       nil 
       (if (eq (car pV1) :|Print|) 
           (return (SPECCALC::evaluatePrint-1 (cdr pV1))) 
           (if (eq (car pV1) :|URI|) 
               (return 
                (funcall (SPECCALC::evaluateURI (SPECCALC::positionOf-1 term)) 
                         (cdr pV1))) 
               (if (eq (car pV1) :|Spec|) 
                   (return (funcall (SPECCALC::evaluateSpec (cdr pV1)) pos)) 
                   (if (eq (car pV1) :|SpecMorph|) 
                       (return (SPECCALC::evaluateSpecMorph-1 (cdr pV1))) 
                       (if (eq (car pV1) :|ExtendMorph|) 
                           (return (SPECCALC::evaluateExtendMorph-1 (cdr pV1))) 
                           (if (eq (car pV1) :|Diag|) 
                               (return (SPECCALC::evaluateDiag (cdr pV1))) 
                               (if (eq (car pV1) :|Colimit|) 
                                   (return 
                                    (SPECCALC::evaluateColimit-1 (cdr pV1))) 
                                   (if (eq (car pV1) :|Subst|) 
                                       (return 
                                        (funcall (SPECCALC::evaluateSubstitute-1 
                                                  (cdr pV1)) 
                                                 pos)) 
                                       (if (eq (car pV1) :|DiagMorph|) 
                                           (return 
                                            (SPECCALC::evaluateDiagMorph-1 
                                             (cdr pV1))) 
                                           (if (eq (car pV1) :|Qualify|) 
                                               (let ((pV11 (cdr pV1))) 
                                                 (return 
                                                  (funcall (SPECCALC::evaluateQualify-1 
                                                            (car pV11)) 
                                                           (cdr pV11)))) 
                                               (if (eq (car pV1) :|Let|) 
                                                   (let ((pV10 (cdr pV1))) 
                                                     (return 
                                                      (funcall (SPECCALC::evaluateLet 
                                                                (car pV10)) 
                                                               (cdr pV10)))) 
                                                   (if (eq (car pV1) :|Where|) 
                                                       (let ((pV9 (cdr pV1))) 
                                                         (return 
                                                          (funcall (SPECCALC::evaluateLet 
                                                                    (car pV9)) 
                                                                   (cdr pV9)))) 
                                                       (if (eq (car pV1) :|Hide|) 
                                                           (return 
                                                            (SPECCALC::monadSeq 
                                                             (SPECCALC::|!print| 
                                                              "hide request ignored
") 
                                                             (SPECCALC::evaluateTermInfo-1 
                                                              (cdr (cdr pV1))))) 
                                                           (if (eq 
                                                                (car pV1) 
                                                                :|Export|) 
                                                               (return 
                                                                (SPECCALC::monadSeq 
                                                                 (SPECCALC::|!print| 
                                                                  "export request ignored
") 
                                                                 (SPECCALC::evaluateTermInfo-1 
                                                                  (cdr (cdr pV1))))) 
                                                               (if (eq 
                                                                    (car pV1) 
                                                                    :|Translate|) 
                                                                   (let ((pV6 
                                                                          (cdr 
                                                                           pV1))) 
                                                                     (return 
                                                                      (funcall (SPECCALC::evaluateTranslate-1 
                                                                                (car 
                                                                                 pV6)) 
                                                                               (cdr 
                                                                                pV6)))) 
                                                                   (if (eq 
                                                                        (car pV1) 
                                                                        :|Obligations|) 
                                                                       (return 
                                                                        (SPECCALC::evaluateObligations-1 
                                                                         (cdr 
                                                                          pV1))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV1) 
                                                                            :|Prove|) 
                                                                           (return 
                                                                            (funcall (SPECCALC::evaluateProve-1 
                                                                                      (cdr 
                                                                                       pV1)) 
                                                                                     pos)) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 pV1) 
                                                                                :|Generate|) 
                                                                               (return 
                                                                                (funcall (SPECCALC::evaluateGenerate-1 
                                                                                          (cdr 
                                                                                           pV1)) 
                                                                                         pos)) 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     pV1) 
                                                                                    :|Other|) 
                                                                                   (return 
                                                                                    (funcall (SPECCALC::evaluateOther 
                                                                                              (cdr 
                                                                                               pV1)) 
                                                                                             pos))))))))))))))))))))) 
       (error "Nonexhaustive match failure in evaluateTermInfo")))))

(defun SPECCALC::evaluateColimit-1 (term) 
  (SPECCALC::monadBind 
   #'SPECCALC::getCurrentURI-1 
   #'(lambda (uri) 
      (SPECCALC::monadSeq 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          ";;; Processing colimit at " 
          (SPECCALC::uriToString-1 uri)) 
         "
")) 
       (SPECCALC::monadBind 
        (SPECCALC::evaluateTermInfo-1 term) 
        #'(lambda (x) 
           (let ((value (svref x 0))) 
             (block 
              nil 
              (if (eq (car value) :|Diag|) 
                  (let ((pV3 (cdr value))) 
                    (return 
                     (let ((initial_cocone 
                            (CAT::colimit-1-1 
                             (FUNCTOR::cod-1 (CAT::functor-1 pV3)) 
                             pV3))) 
                       (SPECCALC::|!return| 
                        (vector 
                         (cons 
                          :|Colimit| 
                          (cons (car initial_cocone) (cdr initial_cocone))) 
                         (svref x 1) 
                         (svref x 2))))))) 
              (return 
               (SPECCALC::raise 
                (cons 
                 :|TypeCheck| 
                 (cons 
                  (SPECCALC::positionOf-1 term) 
                  "argument of colimit is not a diagram"))))))))))))

(defun SPECCALC::evaluateColimit (x0 x1) 
  (SPECCALC::evaluateColimit-1 (cons x0 x1)))

(defun SPECCALC::evaluateColimit-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateColimit-1 x1) x2))

(defun SPECCALC::evaluateDiag-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateDiag x1) x2))

(defun SPECCALC::evaluateDiagElem-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateDiagElem-1 x1) x2) x3))

(defun SPECCALC::evaluateDiagMorph-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateDiagMorph-1 x1) x2))

(defun SPECCALC::evaluateExtendMorph (x0 x1) 
  (SPECCALC::evaluateExtendMorph-1 (cons x0 x1)))

(defun SPECCALC::evaluateExtendMorph-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateExtendMorph-1 x1) x2))

(defun SPECCALC::evaluateGenerate-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateGenerate-1 x1) x2) x3))

(defun SPECCALC::evaluateGlobalDecls-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::evaluateGlobalDecls-1 x1) x2) x3) x4))

(defun SPECCALC::evaluateJavaGen-1 (x) 
  (SPECCALC::evaluateJavaGen (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::evaluateJavaGen-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateJavaGen-1 x1) x2))

(defun SPECCALC::evaluateLet-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateLet x1) x2) x3))

(defun SPECCALC::evaluateLispCompile-1 (x) 
  (SPECCALC::evaluateLispCompile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::evaluateLispCompile-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateLispCompile-1 x1) x2))

(defun SPECCALC::evaluateLispCompileLocal-1 (x) 
  (SPECCALC::evaluateLispCompileLocal (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::evaluateLispCompileLocal-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateLispCompileLocal-1 x1) x2))

(defun SPECCALC::evaluateLocalDecls-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateLocalDecls x1) x2))

(defun SPECCALC::evaluateObligations (x0 x1) 
  (SPECCALC::evaluateObligations-1 (cons x0 x1)))

(defun SPECCALC::evaluateObligations-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateObligations-1 x1) x2))

(defun SPECCALC::evaluateOther-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateOther x1) x2) x3))

(defun SPECCALC::evaluateOtherGenerate-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::evaluateOtherGenerate-1 x1) x2) x3) x4))

(defun SPECCALC::evaluateOtherPrint-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateOtherPrint x1) x2) x3))

(defun SPECCALC::evaluateOtherSpecMorph-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::evaluateOtherSpecMorph-1 x1) x2) 
                             x3) 
                    x4) 
           x5))

(defun SPECCALC::evaluateOtherSubstitute-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::evaluateOtherSubstitute-1 x1) 
                                      x2) 
                             x3) 
                    x4) 
           x5))

(defun SPECCALC::evaluatePrint (x0 x1) (SPECCALC::evaluatePrint-1 (cons x0 x1)))

(defun SPECCALC::evaluatePrint-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluatePrint-1 x1) x2))

(defun SPECCALC::evaluateProve-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateProve-1 x1) x2) x3))

(defun SPECCALC::evaluateQualify (x0 x1) 
  (SPECCALC::evaluateQualify-1 (cons x0 x1)))

(defun SPECCALC::evaluateQualify-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateQualify-1 x1) x2) x3))

(defun SPECCALC::evaluateReturnURI-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateReturnURI x1) x2) x3))

(defun SPECCALC::evaluateSnarkGen-1 (x) 
  (SPECCALC::evaluateSnarkGen (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::evaluateSnarkGen-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateSnarkGen-1 x1) x2))

(defun SPECCALC::evaluateSpec-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSpec x1) x2) x3))

(defun SPECCALC::evaluateSpecElem (x0 x1 x2 x3) 
  (SPECCALC::evaluateSpecElem-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::evaluateSpecElem-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSpecElem-1 x1) x2) x3))

(defun SPECCALC::evaluateSpecElems (x0 x1 x2 x3) 
  (SPECCALC::evaluateSpecElems-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::evaluateSpecElems-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSpecElems-1 x1) x2) x3))

(defun SPECCALC::evaluateSpecImport (x0 x1 x2) 
  (SPECCALC::evaluateSpecImport-1 (vector x0 x1 x2)))

(defun SPECCALC::evaluateSpecImport-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSpecImport-1 x1) x2) x3))

(defun SPECCALC::evaluateSpecMorph-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateSpecMorph-1 x1) x2))

(defun SPECCALC::evaluateSubstitute-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSubstitute-1 x1) x2) x3))

(defun SPECCALC::evaluateTerm-1 (term) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 term) 
   #'(lambda (x) (SPECCALC::|!return| (svref x 0)))))

(defun SPECCALC::evaluateTerm (x0 x1) (SPECCALC::evaluateTerm-1 (cons x0 x1)))

(defun SPECCALC::evaluateTerm-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateTerm-1 x1) x2))

(defun SPECCALC::evaluateTermInfo (x0 x1) 
  (SPECCALC::evaluateTermInfo-1 (cons x0 x1)))

(defun SPECCALC::evaluateTermInfo-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateTermInfo-1 x1) x2))

(defun SPECCALC::evaluateTranslate (x0 x1) 
  (SPECCALC::evaluateTranslate-1 (cons x0 x1)))

(defun SPECCALC::evaluateTranslate-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateTranslate-1 x1) x2) x3))

(defun SPECCALC::evaluateURI-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateURI x1) x2) x3))

(defun SPECCALC::explicateHiddenAxioms-1 (spc) 
  (labels 
    ((axiomFromOpDef (qname name decl defs) 
      (LIST-SPEC::|!++| defs (SPECCALC::axiomFromOpDefTop spc qname name decl)))) 
    (labels 
      ((mergeAxiomsByPos (oas nas) 
        (labels 
          ((cmpGt (pV9 pV10) 
            (block 
             nil 
             (return 
              (let ((old_pos (METASLANG::termAnn (svref pV9 3)))) 
                (let ((new_pos (METASLANG::termAnn (svref pV10 3)))) 
                  (let ((pV8 (POSITION-SPEC::compare old_pos new_pos))) 
                    (block 
                     nil 
                     (if (eq (car pV8) :|Greater|) (return nil)) 
                     (return t)))))) 
             (error "Nonexhaustive match failure in explicateHiddenAxioms")))) 
          (block 
           nil 
           (if (null oas) (return nas)) 
           (if (null nas) (return oas)) 
           (if (consp oas) 
               (let ((pV23 (cdr oas))
                     (pV22 (car oas))) 
                 (if (consp nas) 
                     (let ((pV26 (cdr nas))
                           (pV25 (car nas))) 
                       (return 
                        (if (cmpGt pV22 pV25) 
                            (cons pV25 (mergeAxiomsByPos (cons pV22 pV23) pV26)) 
                            (cons pV22 (mergeAxiomsByPos pV23 (cons pV25 pV26))))))))) 
           (error "Nonexhaustive match failure in explicateHiddenAxioms"))))) 
      (let ((newAxioms 
             (foldriAQualifierMap-1-1-1 
              #'(lambda (x) 
                 (axiomFromOpDef (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
              nil 
              (svref spc 1)))) 
        (let ((newProperties (mergeAxiomsByPos (svref spc 2) newAxioms))) 
          (setProperties spc newProperties))))))

(defun SPECCALC::explicateHiddenAxioms (x0 x1 x2 x3) 
  (SPECCALC::explicateHiddenAxioms-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::explicateHiddenAxiomsM-1 (spc) (SPECCALC::|!return| spc))

(defun SPECCALC::explicateHiddenAxiomsM (x0 x1 x2 x3) 
  (SPECCALC::explicateHiddenAxiomsM-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::explicateHiddenAxiomsM-1-1 (x1 x2) 
  (funcall (SPECCALC::explicateHiddenAxiomsM-1 x1) x2))

(defun SPECCALC::extendMorphism-1 (x) 
  (SPECCALC::extendMorphism (car x) (cdr x)))

(defun SPECCALC::extendMorphismWithAnswer-1 (x) 
  (SPECCALC::extendMorphismWithAnswer (car x) (cdr x)))

(defun SPECCALC::fileExistsAndReadable?-1-1 (x1 x2) 
  (funcall (SPECCALC::fileExistsAndReadable? x1) x2))

(defun SPECCALC::findBuiltInSort-1 (x) 
  (SPECCALC::findBuiltInSort (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::findDefiningURIforOp (opId spc uri depURIs globalContext rec?) 
  (labels 
    ((findLocalURI (opId) 
      (if (localOp? opId spc) 
          (cons (cons "Op" (SPECCALC::uriToFullPath-1 uri)) nil) 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) 
              (LIST-SPEC::|!++| 
               (SPECCALC::findDefiningURIforOpInContext 
                opId 
                (car x) 
                globalContext 
                t) 
               (cdr x))) 
           nil 
           depURIs)))) 
    (if rec? 
        (let ((pV7 (STANDARDSPEC::findTheOp spc opId))) 
          (block 
           nil 
           (if (eq (car pV7) :|Some|) 
               (return (findLocalURI opId)) 
               (if (eq (car pV7) :|None|) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car opId) :|Qualified|) 
                         (let ((pV4 (cdr opId))) 
                           (return 
                            (if (string=  (car pV4) METASLANG::UnQualified) 
                                nil 
                                (SPECCALC::findDefiningURIforOp 
                                 (cons 
                                  :|Qualified| 
                                  (cons METASLANG::UnQualified (cdr pV4))) 
                                 spc 
                                 uri 
                                 depURIs 
                                 globalContext 
                                 t))))) 
                     (return nil))))) 
           (error "Nonexhaustive match failure in findDefiningURIforOp"))) 
        (let ((pV22 (STANDARDSPEC::findAllOps spc opId))) 
          (block 
           nil 
           (if (null pV22) (return nil)) 
           (return 
            (LIST-SPEC::foldr-1-1-1 
             #'(lambda (x) 
                (block 
                 nil 
                 (let ((pV15 (svref (car x) 0))) 
                   (if (consp pV15) 
                       (return 
                        (LIST-SPEC::|!++| (findLocalURI (car pV15)) (cdr x))))) 
                 (error "Nonexhaustive match failure in findDefiningURIforOp"))) 
             nil 
             pV22)))))))

(defun SPECCALC::findDefiningURIforOpInContext (opId uri globalContext rec?) 
  (let ((pV2 (POLYMAP::evalPartial-1-1 globalContext uri))) 
    (block 
     nil 
     (if (eq (car pV2) :|None|) 
         (return nil) 
         (if (eq (car pV2) :|Some|) 
             (let ((pV3 (cdr pV2))) 
               (let ((pV4 (svref pV3 0))) 
                 (if (eq (car pV4) :|Spec|) 
                     (return 
                      (SPECCALC::findDefiningURIforOp 
                       opId 
                       (cdr pV4) 
                       uri 
                       (svref pV3 2) 
                       globalContext 
                       rec?))))))) 
     (error "Nonexhaustive match failure in findDefiningURIforOpInContext"))))

(defun SPECCALC::findDefiningURIforSort
 (sortId spc uri depURIs globalContext rec?) 
  (labels 
    ((findLocalURI (sortId) 
      (if (localSort? sortId spc) 
          (cons (cons "Sort" (SPECCALC::uriToFullPath-1 uri)) nil) 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) 
              (LIST-SPEC::|!++| 
               (SPECCALC::findDefiningURIforSortInContext 
                sortId 
                (car x) 
                globalContext 
                t) 
               (cdr x))) 
           nil 
           depURIs)))) 
    (if rec? 
        (let ((pV7 (STANDARDSPEC::findTheSort spc sortId))) 
          (block 
           nil 
           (if (eq (car pV7) :|Some|) 
               (return (findLocalURI sortId)) 
               (if (eq (car pV7) :|None|) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car sortId) :|Qualified|) 
                         (let ((pV4 (cdr sortId))) 
                           (return 
                            (if (string=  (car pV4) METASLANG::UnQualified) 
                                nil 
                                (SPECCALC::findDefiningURIforSort 
                                 (cons 
                                  :|Qualified| 
                                  (cons METASLANG::UnQualified (cdr pV4))) 
                                 spc 
                                 uri 
                                 depURIs 
                                 globalContext 
                                 t))))) 
                     (return nil))))) 
           (error "Nonexhaustive match failure in findDefiningURIforSort"))) 
        (let ((pV20 (STANDARDSPEC::findAllSorts spc sortId))) 
          (block 
           nil 
           (if (null pV20) (return nil)) 
           (return 
            (LIST-SPEC::foldr-1-1-1 
             #'(lambda (x) 
                (block 
                 nil 
                 (let ((pV14 (svref (car x) 0))) 
                   (if (consp pV14) 
                       (return 
                        (LIST-SPEC::|!++| (findLocalURI (car pV14)) (cdr x))))) 
                 (error "Nonexhaustive match failure in findDefiningURIforSort"))) 
             nil 
             pV20)))))))

(defun SPECCALC::findDefiningURIforSortInContext
 (sortId uri globalContext rec?) 
  (let ((pV2 (POLYMAP::evalPartial-1-1 globalContext uri))) 
    (block 
     nil 
     (if (eq (car pV2) :|None|) 
         (return nil) 
         (if (eq (car pV2) :|Some|) 
             (let ((pV3 (cdr pV2))) 
               (let ((pV4 (svref pV3 0))) 
                 (if (eq (car pV4) :|Spec|) 
                     (return 
                      (SPECCALC::findDefiningURIforSort 
                       sortId 
                       (cdr pV4) 
                       uri 
                       (svref pV3 2) 
                       globalContext 
                       rec?))))))) 
     (error "Nonexhaustive match failure in findDefiningURIforSortInContext"))))

(defun SPECCALC::searchForDefiningURIforOp (opId globalContext rec?) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (result) 
      #'(lambda (uri) 
         #'(lambda (x) 
            (let ((val (svref x 0))) 
              (block 
               nil 
               (if (consp result) 
                   (return result) 
                   (if (null result) 
                       (return 
                        (block 
                         nil 
                         (if (eq (car val) :|Spec|) 
                             (return 
                              (SPECCALC::findDefiningURIforOp 
                               opId 
                               (cdr val) 
                               uri 
                               (svref x 2) 
                               globalContext 
                               rec?))) 
                         (return nil))))) 
               (error "Nonexhaustive match failure in searchForDefiningURIforOp")))))) 
   nil 
   globalContext))

(defun SPECCALC::searchForDefiningURIforSort (sortId globalContext rec?) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (result) 
      #'(lambda (uri) 
         #'(lambda (x) 
            (let ((val (svref x 0))) 
              (block 
               nil 
               (if (consp result) 
                   (return result) 
                   (if (null result) 
                       (return 
                        (block 
                         nil 
                         (if (eq (car val) :|Spec|) 
                             (return 
                              (SPECCALC::findDefiningURIforSort 
                               sortId 
                               (cdr val) 
                               uri 
                               (svref x 2) 
                               globalContext 
                               rec?))) 
                         (return nil))))) 
               (error 
                "Nonexhaustive match failure in searchForDefiningURIforSort")))))) 
   nil 
   globalContext))

(defun SPECCALC::searchForDefiningURI (|!qId| globalContext) 
  (LISTUTILITIES::removeDuplicates 
   (LIST-SPEC::|!++| 
    (SPECCALC::searchForDefiningURIforOp |!qId| globalContext nil) 
    (SPECCALC::searchForDefiningURIforSort |!qId| globalContext nil))))

(defun SPECCALC::findDefiningURI (|!qId| uriStr globalContext) 
  (let ((uri (SPECCALC::pathStringToCanonicalURI uriStr))) 
    (let ((pV1 
           (LIST-SPEC::|!++| 
            (SPECCALC::findDefiningURIforOpInContext 
             |!qId| 
             uri 
             globalContext 
             nil) 
            (SPECCALC::findDefiningURIforSortInContext 
             |!qId| 
             uri 
             globalContext 
             nil)))) 
      (block 
       nil 
       (if (null pV1) 
           (return 
            (LISTUTILITIES::removeDuplicates 
             (SPECCALC::searchForDefiningURI |!qId| globalContext)))) 
       (return (LISTUTILITIES::removeDuplicates pV1))))))

(defun SPECCALC::findDefiningURI-1 (x) 
  (SPECCALC::findDefiningURI (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::findDefiningURIforOp-1 (x) 
  (SPECCALC::findDefiningURIforOp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun SPECCALC::findDefiningURIforOpInContext-1 (x) 
  (SPECCALC::findDefiningURIforOpInContext 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECCALC::findDefiningURIforSort-1 (x) 
  (SPECCALC::findDefiningURIforSort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun SPECCALC::findDefiningURIforSortInContext-1 (x) 
  (SPECCALC::findDefiningURIforSortInContext 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECCALC::findPBuiltInSort-1 (x) 
  (SPECCALC::findPBuiltInSort (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::findUnitIdforUnit-1 (x) 
  (SPECCALC::findUnitIdforUnit (car x) (cdr x)))

(defun SPECCALC::|!first|-1-1 (x1 x2) (funcall (SPECCALC::|!first| x1) x2))

(defun SPECCALC::foldDoubleMap-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::foldDoubleMap x1) x2) x3) x4))

(defun SPECCALC::foldM-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::foldM x1) x2) x3) x4))

(defun SPECCALC::foldMap-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::foldMap x1) x2) x3) x4))

(defun SPECCALC::foldMapAp-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::foldMapAp x1) x2) x3))

(defun SPECCALC::foldOverQualifierMap-1-1-1-1 (x0 x1 x2 x3) 
  (SPECCALC::foldDoubleMap-1-1-1-1 x0 x1 x2 x3))

(defun SPECCALC::functionSort? (sp srt) 
  (let ((pV5 (SPECENVIRONMENT::unfoldBase sp srt))) 
    (block 
     nil 
     (if (eq (car pV5) :|Arrow|) 
         (return t) 
         (if (eq (car pV5) :|Subsort|) 
             (return (SPECCALC::functionSort? sp (svref (cdr pV5) 0))))) 
     (return nil))))

(defun SPECCALC::functionSort?-1 (x) (SPECCALC::functionSort? (car x) (cdr x)))

(defun SPECCALC::garbageCollect-1-1 (full? state) 
  (progn (SYSTEM-SPEC::garbageCollect full?) (cons (cons :|Ok| nil) state)))

(defun SPECCALC::garbageCollect (x1) 
  #'(lambda (x2) (SPECCALC::garbageCollect-1-1 x1 x2)))

(defun SPECCALC::generateFileList (x0 x1) 
  (SPECCALC::generateFileList-1 (cons x0 x1)))

(defun SPECCALC::generateFileList-1-1 (x1 x2) 
  (funcall (SPECCALC::generateFileList-1 x1) x2))

(defun SPECCALC::generateURIList-1-1 (x1 x2) 
  (funcall (SPECCALC::generateURIList x1) x2))

(defun SPECCALC::getBaseSpec-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECCALC::getBaseSpec))

(defun SPECCALC::getCurrentURI (x0 x1 x2 x3) 
  (SPECCALC::getCurrentURI-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::getURI (x0 x1) (SPECCALC::getURI-1 (cons x0 x1)))

(defun SPECCALC::getURI-1-1 (x1 x2) (funcall (SPECCALC::getURI-1 x1) x2))

(defun SPECCALC::hackMemory-1-1 (pV1 state) 
  (declare (ignore pV1)) 
  (progn (SYSTEM-SPEC::hackMemory) (cons (cons :|Ok| nil) state)))

(defun SPECCALC::hackMemory-1 (x1) 
  #'(lambda (x2) (SPECCALC::hackMemory-1-1 x1 x2)))

(defun SPECCALC::hackMemory () (SPECCALC::hackMemory-1 nil))

(defun SPECCALC::inSameFile?-1 (x) (SPECCALC::inSameFile? (car x) (cdr x)))

(defun SPECCALC::|!last|-1-1 (x1 x2) (funcall (SPECCALC::|!last| x1) x2))

(defun SPECCALC::lastElem-1-1 (x1 x2) (funcall (SPECCALC::lastElem x1) x2))

(defun SPECCALC::loadFile (x0 x1) (SPECCALC::loadFile-1 (cons x0 x1)))

(defun SPECCALC::loadFile-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::loadFile-1 x1) x2) x3))

(defun SPECCALC::localHandler-1-1 (x1 x2) 
  (funcall (SPECCALC::localHandler x1) x2))

(defun SPECCALC::lookupInGlobalContext (x0 x1) 
  (SPECCALC::lookupInGlobalContext-1 (cons x0 x1)))

(defun SPECCALC::mFail-1-1 (str state) 
  (progn (SYSTEM-SPEC::fail str) 
         (cons (cons :|Exception| (cons :|Fail| str)) state)))

(defun SPECCALC::mFail (x1) #'(lambda (x2) (SPECCALC::mFail-1-1 x1 x2)))

(defun SPECCALC::makeMorphism-1 (x) 
  (SPECCALC::makeMorphism (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::makeResolvedMapping (x0 x1 x2 x3) 
  (SPECCALC::makeResolvedMapping-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::makeResolvedMapping-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::makeResolvedMapping-1 x1) x2) x3) x4))

(defun SPECCALC::makeSnarkAnsEvalForm-1 (x) 
  (SPECCALC::makeSnarkAnsEvalForm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun SPECCALC::makeSnarkProveEvalForm-1 (x) 
  (SPECCALC::makeSnarkProveEvalForm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun SPECCALC::makeSpecCocone-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::makeSpecCocone-1-1-1 x1 x2 x3))))

(defun SPECCALC::makeSpecCocone (x0 x1) 
  (SPECCALC::makeSpecCocone-1 (cons x0 x1)))

(defun SPECCALC::makeSpecInitialCocone-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::makeSpecInitialCocone-1-1-1 x1 x2 x3))))

(defun SPECCALC::makeSpecInitialCocone (x0 x1) 
  (SPECCALC::makeSpecInitialCocone-1 (cons x0 x1)))

(defun SPECCALC::makeSpecMorphism (x0 x1 x2 x3) 
  (SPECCALC::makeSpecMorphism-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::makeSpecMorphism-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::makeSpecMorphism-1 x1) x2) x3) 
                    x4) 
           x5))

(defun SPECCALC::makeTranslationMaps (x0 x1 x2 x3) 
  (SPECCALC::makeTranslationMaps-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::makeTranslationMaps-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::makeTranslationMaps-1 x1) x2) x3))

(defun SPECCALC::makeVertexToTranslateRulesMap-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) 
           (SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1 x1 x2 x3 x4)))))

(defun SPECCALC::makeVertexToTranslateRulesMap (x0 x1) 
  (SPECCALC::makeVertexToTranslateRulesMap-1 (cons x0 x1)))

(defun SPECCALC::mapM-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::mapM x1) x2) x3))

(defun SPECCALC::maybeAddBaseImport-1 (x) 
  (SPECCALC::maybeAddBaseImport (car x) (cdr x)))

(defun SPECCALC::maybeAddBaseImport-1-1 (x1 x2) 
  (funcall (SPECCALC::maybeAddBaseImport-1 x1) x2))

(defun SPECCALC::mergeImport (x0 x1) (SPECCALC::mergeImport-1 (cons x0 x1)))

(defun SPECCALC::mergeImport-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::mergeImport-1 x1) x2) x3) x4) 
           x5))

(defun SPECCALC::mergeOpInfo (x0 x1 x2 x3) 
  (SPECCALC::mergeOpInfo-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::mergeOpInfo-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::mergeOpInfo-1 x1) x2) x3) x4))

(defun SPECCALC::mergeSortInfo (x0 x1 x2) 
  (SPECCALC::mergeSortInfo-1 (vector x0 x1 x2)))

(defun SPECCALC::mergeSortInfo-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::mergeSortInfo-1 x1) x2) x3) x4))

(defun SPECCALC::mkDefEquality (srt qid trm) 
  (STANDARDSPEC::mkEquality srt (STANDARDSPEC::mkOp qid srt) trm))

(defun SPECCALC::mkDefEquality-1 (x) 
  (SPECCALC::mkDefEquality (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::mkExistential-1 (x) (SPECCALC::mkExistential (car x) (cdr x)))

(defun SPECCALC::mkNewSnarkTerm-1 (x) 
  (SPECCALC::mkNewSnarkTerm (car x) (cdr x)))

(defun SPECCALC::mkSnarkFmla-1 (x) 
  (SPECCALC::mkSnarkFmla 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun SPECCALC::mkSnarkFmlaApp-1 (x) 
  (SPECCALC::mkSnarkFmlaApp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun SPECCALC::mkSnarkName-1 (x) (SPECCALC::mkSnarkName (car x) (cdr x)))

(defun SPECCALC::mkSnarkTerm-1 (x) 
  (SPECCALC::mkSnarkTerm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun SPECCALC::mkSnarkTermApp-1 (x) 
  (SPECCALC::mkSnarkTermApp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun SPECCALC::mkUncurryEquality-1 (x) 
  (SPECCALC::mkUncurryEquality (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::mkUncurryEqualityRec-1 (x) 
  (SPECCALC::mkUncurryEqualityRec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun SPECCALC::monadSeq-1 (x) (SPECCALC::monadSeq (car x) (cdr x)))

(defun SPECCALC::monadSeq-1-1 (x1 x2) (funcall (SPECCALC::monadSeq-1 x1) x2))

(defun SPECCALC::morphismObligations-1 (x) 
  (SPECCALC::morphismObligations (car x) (cdr x)))

(defun SPECCALC::myppAOpInfo-1 (x) (SPECCALC::myppAOpInfo (car x) (cdr x)))

(defun SPECCALC::myppASortInfo-1 (x) (SPECCALC::myppASortInfo (car x) (cdr x)))

(defun SPECCALC::normalizeURI-1 (x) (SPECCALC::normalizeURI (car x) (cdr x)))

(defun SPECCALC::opMap (x0 x1 x2 x3) (SPECCALC::opMap-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::optSpecUnion-1-1 (x1 x2) 
  (funcall (SPECCALC::optSpecUnion x1) x2))

(defun SPECCALC::optTranslateSpec (x0 x1 x2 x3) 
  (SPECCALC::optTranslateSpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::optTranslateSpec-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::optTranslateSpec-1 x1) x2) x3))

(defun SPECCALC::pathToCanonicalURI-1-1 (x1 x2) 
  (funcall (SPECCALC::pathToCanonicalURI x1) x2))

(defun SPECCALC::pathToRelativeURI-1-1 (x1 x2) 
  (funcall (SPECCALC::pathToRelativeURI x1) x2))

(defun SPECCALC::ppAOpDecl-1 (x) 
  (SPECCALC::ppAOpDecl (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::ppAOpDefs-1 (x) (SPECCALC::ppAOpDefs (car x) (cdr x)))

(defun SPECCALC::ppAOpInfo (x0 x1 x2 x3) 
  (SPECCALC::ppAOpInfo-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::ppASortInfo (x0 x1 x2) 
  (SPECCALC::ppASortInfo-1 (vector x0 x1 x2)))

(defun SPECCALC::ppASpec (x0 x1 x2 x3) 
  (SPECCALC::ppASpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::ppASpecLocal-1 (spc) 
  (let ((properties (svref spc 2))
        (importInfo (svref spc 0))) 
    (block 
     nil 
     (let ((pV20 (svref importInfo 3))
           (pV19 (svref importInfo 2))) 
       (return 
        (let ((ppImports 
               (let ((ppNames 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (x1) 
                          (WADLERLINDIG::ppString 
                           (STRING-SPEC::^ "import " (car x1)))) 
                       (svref importInfo 1)))) 
                 (WADLERLINDIG::ppSep-1-1 WADLERLINDIG::ppNewline ppNames)))) 
          (labels 
            ((doSortInfo (sortInfo) 
              (WADLERLINDIG::ppConcat 
               (cons 
                (WADLERLINDIG::ppString "sort ") 
                (cons (SPECCALC::ppASortInfo-1 sortInfo) nil))))) 
            (labels 
              ((doOpInfo (|!opInfo|) 
                (WADLERLINDIG::ppConcat 
                 (cons 
                  (WADLERLINDIG::ppString "op ") 
                  (cons (SPECCALC::ppAOpInfo-1 |!opInfo|) nil))))) 
              (WADLERLINDIG::ppConcat 
               (cons 
                (WADLERLINDIG::ppString "spec {") 
                (cons 
                 (WADLERLINDIG::ppIndent 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    WADLERLINDIG::ppNewline 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      WADLERLINDIG::ppNewline 
                      (cons 
                       ppImports 
                       (cons 
                        (WADLERLINDIG::ppSep-1-1 
                         WADLERLINDIG::ppNewline 
                         (LIST-SPEC::|!map|-1-1 
                          #'doSortInfo 
                          (LIST-SPEC::filter-1-1 
                           #'(lambda (x1) 
                              (let ((pV2 (svref x1 0))) 
                                (block 
                                 nil 
                                 (if (consp pV2) 
                                     (return 
                                      (LIST-SPEC::|!member| (car pV2) pV20))) 
                                 (error 
                                  "Nonexhaustive match failure in ppASpecLocal")))) 
                           (sortInfosAsList-1 spc)))) 
                        (cons 
                         (WADLERLINDIG::ppSep-1-1 
                          WADLERLINDIG::ppNewline 
                          (LIST-SPEC::|!map|-1-1 
                           #'doOpInfo 
                           (LIST-SPEC::filter-1-1 
                            #'(lambda (x1) 
                               (let ((pV9 (svref x1 0))) 
                                 (block 
                                  nil 
                                  (if (consp pV9) 
                                      (return 
                                       (LIST-SPEC::|!member| (car pV9) pV19))) 
                                  (error 
                                   "Nonexhaustive match failure in ppASpecLocal")))) 
                            (opInfosAsList-1 spc)))) 
                         (cons 
                          (WADLERLINDIG::ppSep-1-1 
                           WADLERLINDIG::ppNewline 
                           (LIST-SPEC::|!map|-1-1 
                            #'SPECCALC::ppAProperty-1 
                            properties)) 
                          nil))))) 
                     nil)))) 
                 (cons (WADLERLINDIG::ppString "}") nil))))))))) 
     (error "Nonexhaustive match failure in ppASpecLocal"))))

(defun SPECCALC::ppASpecLocal (x0 x1 x2 x3) 
  (SPECCALC::ppASpecLocal-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::ppAVar (id srt) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString id) 
    (cons (WADLERLINDIG::ppString ":") (cons (SPECCALC::ppASort srt) nil)))))

(defun SPECCALC::ppAVar-1 (x) (SPECCALC::ppAVar (car x) (cdr x)))

(defun SPECCALC::ppJSpecToFile-1 (x) 
  (SPECCALC::ppJSpecToFile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::ppMorphismX-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::ppMorphismX-1-1-1 x1 x2 x3))))

(defun SPECCALC::ppMorphismX (x0 x1 x2 x3) 
  (SPECCALC::ppMorphismX-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::showQid-1-1 (qualifier id) 
  (if (string=  qualifier METASLANG::UnQualified) 
      id 
      (STRING-SPEC::^ (STRING-SPEC::^ qualifier ".") id)))

(defun SPECCALC::ppQid (pV1) 
  (block 
   nil 
   (if (eq (car pV1) :|Qualified|) 
       (let ((pV2 (cdr pV1))) 
         (return 
          (WADLERLINDIG::ppString (SPECCALC::showQid-1-1 (car pV2) (cdr pV2)))))) 
   (error "Nonexhaustive match failure in ppQid")))

(defun SPECCALC::ppSpec (x0 x1 x2 x3) (SPECCALC::ppSpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::ppSpecFile-1 (specFile) 
  (let ((term (car specFile))) 
    (block 
     nil 
     (if (eq (car term) :|Term|) 
         (return (SPECCALC::ppTerm-1 (cdr term))) 
         (if (eq (car term) :|Decls|) (return (SPECCALC::ppDecls (cdr term))))) 
     (error "Nonexhaustive match failure in ppSpecFile"))))

(defun SPECCALC::ppSpecFile (x0 x1) (SPECCALC::ppSpecFile-1 (cons x0 x1)))

(defun SPECCALC::ppSpecToFile-1 (x) 
  (SPECCALC::ppSpecToFile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::ppSpecToTerminal-1 (spc) 
  (let ((p (SPECCALC::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) (PRETTYPRINT::toTerminal |!t|))))


(defun SPECCALC::ppSpecToTerminal (x0 x1 x2 x3) 
  (SPECCALC::ppSpecToTerminal-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::ppSpecsToFile (specs file preamble) 
  (let ((ps (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppSpec-1 specs))) 
    (let ((p (PRETTYPRINT::prettysAll ps))) 
      (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
        (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble))))))

(defun SPECCALC::ppSpecsToFile-1 (x) 
  (SPECCALC::ppSpecsToFile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::ppTranslateExpr (translate_rules pV1) 
  (declare (ignore pV1)) 
  (labels 
    ((ppTranslateRule (rule pV2) 
      (declare (ignore pV2)) 
      (block 
       nil 
       (if (eq (car rule) :|Sort|) 
           (let ((pV8 (cdr rule))) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons 
                (SPECCALC::ppQid (svref pV8 0)) 
                (cons 
                 (WADLERLINDIG::ppString " -> ") 
                 (cons (SPECCALC::ppQid (svref pV8 1)) nil)))))) 
           (if (eq (car rule) :|Op|) 
               (let ((pV7 (cdr rule))) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (SPECCALC::ppQid (car (svref pV7 0))) 
                    (cons 
                     (WADLERLINDIG::ppString " -> ") 
                     (cons (SPECCALC::ppQid (car (svref pV7 1))) nil)))))) 
               (if (eq (car rule) :|Ambiguous|) 
                   (let ((pV6 (cdr rule))) 
                     (return 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (SPECCALC::ppQid (svref pV6 0)) 
                        (cons 
                         (WADLERLINDIG::ppString " -> ") 
                         (cons (SPECCALC::ppQid (svref pV6 1)) nil))))))))) 
       (error "Nonexhaustive match failure in ppTranslateExpr")))) 
    (WADLERLINDIG::ppConcat 
     (cons 
      (WADLERLINDIG::ppString "{") 
      (cons 
       (WADLERLINDIG::ppSep-1-1 
        (WADLERLINDIG::ppString ", ") 
        (LIST-SPEC::|!map|-1-1 
         #'(lambda (x) (ppTranslateRule (car x) (cdr x))) 
         translate_rules)) 
       (cons (WADLERLINDIG::ppString "}") nil))))))

(defun SPECCALC::ppTranslateExpr-1 (x) 
  (SPECCALC::ppTranslateExpr (car x) (cdr x)))

(defun SPECCALC::ppURI (x0 x1) (SPECCALC::ppURI-1 (cons x0 x1)))

(defun SPECCALC::ppVQid (pV1 pV2) 
  (block 
   nil 
   (if (eq (car pV2) :|Qualified|) 
       (let ((pV3 (cdr pV2))) 
         (return 
          (WADLERLINDIG::ppString 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ (STRING-SPEC::^ "[" (SPECCALC::vertexName pV1)) "]") 
            (SPECCALC::showQid-1-1 (car pV3) (cdr pV3))))))) 
   (error "Nonexhaustive match failure in ppVQid")))

(defun SPECCALC::ppVQid-1 (x) (SPECCALC::ppVQid (car x) (cdr x)))

(defun SPECCALC::ppVQidQuotientSet (qset) 
  (labels 
    ((ppClass (|!class|) 
      (WADLERLINDIG::ppConcat 
       (cons 
        (WADLERLINDIG::ppString "{  ") 
        (cons 
         (WADLERLINDIG::ppSep-1-1 
          (WADLERLINDIG::ppString ", ") 
          (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppVQid-1 |!class|)) 
         (cons (WADLERLINDIG::ppString "  }") nil)))))) 
    (WADLERLINDIG::ppConcat 
     (cons 
      (WADLERLINDIG::ppString "
") 
      (cons 
       (WADLERLINDIG::ppSep-1-1 
        (WADLERLINDIG::ppString "
") 
        (LIST-SPEC::|!map|-1-1 #'ppClass qset)) 
       (cons (WADLERLINDIG::ppString "

") nil))))))

(defun SPECCALC::ppValueInfo (value timeStamp depURIs) 
  (WADLERLINDIG::ppConcat 
   (LIST-SPEC::|!++| 
    (cons 
     (SPECCALC::ppValue value) 
     (cons (WADLERLINDIG::ppString (NAT-SPEC::toString timeStamp)) nil)) 
    (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppURI-1 depURIs))))

(defun SPECCALC::ppValueInfo-1 (x) 
  (SPECCALC::ppValueInfo (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::printColimit-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printColimit-1-1-1 x1 x2 x3))))

(defun SPECCALC::printColimit (x0 x1 x2 x3) 
  (SPECCALC::printColimit-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::printDiagram-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printDiagram-1-1-1 x1 x2 x3))))

(defun SPECCALC::printDiagram (x0 x1 x2 x3) 
  (SPECCALC::printDiagram-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::showGlobalContext-1 (state) 
  (cons 
   (cons 
    :|Ok| 
    (WADLERLINDIG::ppFormat 
     (POLYMAP::ppMap-1-1-1 
      #'(lambda (uri) (WADLERLINDIG::ppString (SPECCALC::showURI-1 uri))) 
      #'SPECCALC::ppValueInfo-1 
      (svref state 0)))) 
   state))

(defun SPECCALC::printGlobalContext (x2 x1 x0 x) 
  (SPECCALC::monadBind-1-1 
   (cons 
    #'SPECCALC::showGlobalContext-1 
    #'(lambda (str) 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ (STRING-SPEC::^ "global context: " str) "
")))) 
   (vector x2 x1 x0 x)))

(defun SPECCALC::printGlobalContext-1 (x) 
  (SPECCALC::printGlobalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))


(defun SPECCALC::showLocalContext-1 (state) 
  (cons 
   (cons 
    :|Ok| 
    (WADLERLINDIG::ppFormat 
     (POLYMAP::ppMap-1-1-1 
      #'SPECCALC::ppRelativeURI 
      #'SPECCALC::ppValueInfo-1 
      (svref state 1)))) 
   state))

(defun SPECCALC::printLocalContext (x2 x1 x0 x) 
  (SPECCALC::monadBind-1-1 
   (cons 
    #'SPECCALC::showLocalContext-1 
    #'(lambda (str) 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ (STRING-SPEC::^ "local context: " str) "
")))) 
   (vector x2 x1 x0 x)))

(defun SPECCALC::printLocalContext-1 (x) 
  (SPECCALC::printLocalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::printMorphism-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printMorphism-1-1-1 x1 x2 x3))))

(defun SPECCALC::printMorphism (x0 x1 x2 x3) 
  (SPECCALC::printMorphism-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::printSpec-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printSpec-1-1-1 x1 x2 x3))))

(defun SPECCALC::printSpec (x0 x1 x2 x3) 
  (SPECCALC::printSpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::productLength (sp srt) 
  (let ((pV1 (SPECENVIRONMENT::productOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV1) :|Some|) 
         (return (LIST-SPEC::|!length| (cdr pV1))) 
         (if (eq (car pV1) :|None|) (return 1))) 
     (error "Nonexhaustive match failure in productLength"))))

(defun SPECCALC::productLength-1 (x) (SPECCALC::productLength (car x) (cdr x)))

(defun SPECCALC::proveForAns-1 (x) 
  (SPECCALC::proveForAns 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))

(defun SPECCALC::proveInSpec-1 (x) 
  (SPECCALC::proveInSpec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6) 
   (svref x 7) 
   (svref x 8) 
   (svref x 9)))

(defun SPECCALC::proveInSpec-1-1 (x1 x2) 
  (funcall (SPECCALC::proveInSpec-1 x1) x2))

(defun SPECCALC::proveWithHypothesis-1 (x) 
  (SPECCALC::proveWithHypothesis 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6) 
   (svref x 7) 
   (svref x 8) 
   (svref x 9)))

(defun SPECCALC::proverOptionsFromSpec-1 (x) 
  (SPECCALC::proverOptionsFromSpec (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::proverOptionsFromSpec-1-1 (x1 x2) 
  (funcall (SPECCALC::proverOptionsFromSpec-1 x1) x2))

(defun SPECCALC::qualifySpec (x0 x1 x2 x3) 
  (SPECCALC::qualifySpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::qualifySpec-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::qualifySpec-1 x1) x2) x3) x4))

(defun SPECCALC::relativizePath (x1) 
  #'(lambda (x2) (SPECCALC::relativizePath-1-1 x1 x2)))

(defun SPECCALC::relativizeURI-1 (x1) 
  #'(lambda (x2) (SPECCALC::relativizeURI-1-1 x1 x2)))

(defun SPECCALC::relativizeURI (x0 x1) (SPECCALC::relativizeURI-1 (cons x0 x1)))

(defun SPECCALC::removeFromGlobalContext (x0 x1) 
  (SPECCALC::removeFromGlobalContext-1 (cons x0 x1)))

(defun SPECCALC::removeLast-1-1 (x1 x2) (funcall (SPECCALC::removeLast x1) x2))

(defun SPECCALC::removeLastElem-1-1 (x1 x2) 
  (funcall (SPECCALC::removeLastElem x1) x2))

(defun SPECCALC::reviseQId-1 (x) 
  (SPECCALC::reviseQId (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::searchContextForURI-1-1 (x1 x2) 
  (funcall (SPECCALC::searchContextForURI x1) x2))

(defun SPECCALC::searchFileSystemForURI-1 (x) 
  (SPECCALC::searchFileSystemForURI 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECCALC::searchFileSystemForURI-1-1 (x1 x2) 
  (funcall (SPECCALC::searchFileSystemForURI-1 x1) x2))

(defun SPECCALC::searchForDefiningURI-1 (x) 
  (SPECCALC::searchForDefiningURI (car x) (cdr x)))

(defun SPECCALC::searchForDefiningURIforOp-1 (x) 
  (SPECCALC::searchForDefiningURIforOp (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::searchForDefiningURIforSort-1 (x) 
  (SPECCALC::searchForDefiningURIforSort (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::setCurrentURI (x0 x1) (SPECCALC::setCurrentURI-1 (cons x0 x1)))

(defun SPECCALC::setValidatedURI (x0 x1) 
  (SPECCALC::setValidatedURI-1 (cons x0 x1)))

(defun SPECCALC::showGlobalContext (x0 x1 x2 x3) 
  (SPECCALC::showGlobalContext-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::showIdToQualifiers (id_to_qualifiers) 
  (STRING-SPEC::toScreen 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     "
Id => Qualifiers:

" 
     (WADLERLINDIG::ppFormat 
      (WADLERLINDIG::ppConcat 
       (POLYMAP::foldMap-1-1-1 
        #'(lambda (result) 
           #'(lambda (id) 
              #'(lambda (qualifiers) 
                 (LIST-SPEC::|!cons| 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString (STRING-SPEC::^ id " => ")) 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      (WADLERLINDIG::ppString ", ") 
                      (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString qualifiers)) 
                     (cons (WADLERLINDIG::ppString "
") nil)))) 
                  result)))) 
        nil 
        id_to_qualifiers)))) 
    "------------------------------------------
")))

(defun SPECCALC::showLocalContext (x0 x1 x2 x3) 
  (SPECCALC::showLocalContext-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::showQid (x1) #'(lambda (x2) (SPECCALC::showQid-1-1 x1 x2)))

(defun SPECCALC::showQidToClassIndices (qid_to_class_indices) 
  (STRING-SPEC::toScreen 
   (STRING-SPEC::^ 
    "
QualifiedId => <Number of Classes>:

" 
    (WADLERLINDIG::ppFormat 
     (WADLERLINDIG::ppConcat 
      (POLYMAP::foldMap-1-1-1 
       #'(lambda (result) 
          #'(lambda (qid) 
             #'(lambda (class_indices) 
                (LIST-SPEC::|!cons| 
                 (WADLERLINDIG::ppConcat 
                  (cons 
                   (SPECCALC::ppQid qid) 
                   (cons 
                    (WADLERLINDIG::ppString 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       " => " 
                       (NAT-SPEC::toString (LIST-SPEC::|!length| class_indices))) 
                      " classes
")) 
                    nil))) 
                 result)))) 
       nil 
       qid_to_class_indices))))))

(defun SPECCALC::showSpecFile-1 (specFile) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppSpecFile-1 specFile)))

(defun SPECCALC::showSpecFile (x0 x1) (SPECCALC::showSpecFile-1 (cons x0 x1)))

(defun SPECCALC::showTerm (x0 x1) (SPECCALC::showTerm-1 (cons x0 x1)))

(defun SPECCALC::showURI (x0 x1) (SPECCALC::showURI-1 (cons x0 x1)))

(defun SPECCALC::showVQidToQidAliasesMap (vqid_to_qid_and_aliases_map) 
  (STRING-SPEC::toScreen 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     "
VQid => QualifiedId * Aliases:

" 
     (WADLERLINDIG::ppFormat 
      (WADLERLINDIG::ppConcat 
       (POLYMAP::foldMap-1-1-1 
        #'(lambda (result) 
           #'(lambda (vqid) 
              #'(lambda (x) 
                 (LIST-SPEC::|!cons| 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (SPECCALC::ppVQid-1 vqid) 
                    (cons 
                     (WADLERLINDIG::ppString " => ") 
                     (cons 
                      (SPECCALC::ppQid (car x)) 
                      (cons 
                       (WADLERLINDIG::ppString " * ") 
                       (cons 
                        (WADLERLINDIG::ppSep-1-1 
                         (WADLERLINDIG::ppString ", ") 
                         (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppQid (cdr x))) 
                        (cons (WADLERLINDIG::ppString "
") nil))))))) 
                  result)))) 
        nil 
        vqid_to_qid_and_aliases_map)))) 
    "------------------------------------------
")))

(defun SPECCALC::showVQidMaps (map_info) 
  (progn (STRING-SPEC::toScreen "==========================================
") 
         (LIST-SPEC::app-1-1 
          #'(lambda (x) 
             (progn (STRING-SPEC::toScreen (STRING-SPEC::^ (car x) " rules:

")) 
                    (SPECCALC::showVQidToQidAliasesMap (cdr x)) 
                    (STRING-SPEC::toScreen "

"))) 
          map_info) 
         (STRING-SPEC::toScreen "==========================================
")))

(defun SPECCALC::showVQidQuotientSet (qset) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppVQidQuotientSet qset)))

(defun SPECCALC::showVQidQuotientSets (qsets_data) 
  (progn (STRING-SPEC::toScreen "------------------------------------------

") 
         (LIST-SPEC::app-1-1 
          #'(lambda (x) 
             (progn (STRING-SPEC::toScreen 
                     (STRING-SPEC::^ (car x) " quotients:
")) 
                    (STRING-SPEC::toScreen 
                     (SPECCALC::showVQidQuotientSet (cdr x))))) 
          qsets_data) 
         (STRING-SPEC::toScreen "------------------------------------------

")))


(defun SPECCALC::showVertexToTranslateExprMaps (vertex_to_sm_rules) 
  (progn (STRING-SPEC::toScreen "==========================================
") 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (|!ignore|) 
             #'(lambda (vertex) 
                #'(lambda (translate_expr) 
                   (progn (STRING-SPEC::toScreen 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ "Translation for " vertex) 
                            "

")) 
                          (STRING-SPEC::toScreen 
                           (WADLERLINDIG::ppFormat 
                            (SPECCALC::ppTranslateExpr-1 translate_expr))) 
                          (STRING-SPEC::toScreen "

"))))) 
          nil 
          vertex_to_sm_rules) 
         (STRING-SPEC::toScreen "==========================================
")))

(defun SPECCALC::snarkAnswer-1 (x) 
  (SPECCALC::snarkAnswer (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::snarkBaseSort-1 (x) 
  (SPECCALC::snarkBaseSort (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkBndVar-1 (x) 
  (SPECCALC::snarkBndVar (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkBndVars-1 (x) 
  (SPECCALC::snarkBndVars (svref x 0) (svref x 1) (svref x 2)))

(defparameter SPECCALC::snarkBuiltInOps SPECCALC::arithmeticFunctions)

(defun SPECCALC::snarkConjecture-1 (x) 
  (SPECCALC::snarkConjecture (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkFunctionCurryDecl-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECCALC::snarkFunctionCurryDecl))

(defun SPECCALC::snarkFunctionCurryNoArityDecl-1 (x) 
  (SPECCALC::snarkFunctionCurryNoArityDecl (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkFunctionDecl-1 (x) 
  (SPECCALC::snarkFunctionDecl (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkFunctionNoArityDecl-1 (x) 
  (SPECCALC::snarkFunctionNoArityDecl (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkFunctionNoCurryDecl-1 (x) 
  (SPECCALC::snarkFunctionNoCurryDecl 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECCALC::snarkName (x0 x1 x2 x3) 
  (SPECCALC::snarkName-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::snarkOpDecl-1 (x) 
  (SPECCALC::snarkOpDecl (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkOpDeclPartial-1 (x) 
  (SPECCALC::snarkOpDeclPartial (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkOpDecls (x0 x1 x2 x3) 
  (SPECCALC::snarkOpDecls-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::snarkPBaseSort-1 (x) 
  (SPECCALC::snarkPBaseSort (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkPPBaseSort (sp s rng?) 
  (let ((res 
         (block 
          nil 
          (if (eq (car s) :|Base|) 
              (let ((pV16 (svref (cdr s) 0))) 
                (if (eq (car pV16) :|Qualified|) 
                    (let ((pV19 (cdr pV16))) 
                      (let ((pV21 (cdr pV19))
                            (pV20 (car pV19))) 
                        (progn (if (string=  "Nat" pV20) 
                                   (if (string=  "Nat" pV21) 
                                       (return 
                                        (LISP-SPEC::|!symbol| "SNARK" "NATURAL"))) 
                                   (if (string=  "Integer" pV20) 
                                       (if (string=  "Integer" pV21) 
                                           (return 
                                            (LISP-SPEC::|!symbol| 
                                             "SNARK" 
                                             "INTEGER"))))) 
                               (return 
                                (if rng? 
                                    (LISP-SPEC::|!symbol| "SNARK" pV21) 
                                    (LISP-SPEC::|!symbol| "SNARK" pV21)))))))) 
              (if (eq (car s) :|Product|) 
                  (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
                  (if (eq (car s) :|Arrow|) 
                      (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
                      (if (eq (car s) :|TyVar|) 
                          (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")))))) 
          (error "Nonexhaustive match failure in snarkPPBaseSort")))) 
    (progn (if SYSTEM-SPEC::specwareDebug? 
               (STRING-SPEC::writeLine 
                (STRING-SPEC::^ "snarkPBaseSort: " (ANNSPECPRINTER::printSort s))) 
               nil) 
           (progn (if SYSTEM-SPEC::specwareDebug? 
                      (LISP-SPEC::|!PPRINT| res) 
                      (LISP-SPEC::|!list| nil)) 
                  res))))

(defun SPECCALC::snarkPPBaseSort-1 (x) 
  (SPECCALC::snarkPPBaseSort (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkPredicateDecl-1 (x) 
  (SPECCALC::snarkPredicateDecl (svref x 0) (svref x 1) (svref x 2) (svref x 3)))


(defun SPECCALC::snarkProperties (x0 x1 x2 x3) 
  (SPECCALC::snarkProperties-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::snarkProperty-1 (x) 
  (SPECCALC::snarkProperty (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::snarkSorts (x0 x1 x2 x3) 
  (SPECCALC::snarkSorts-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::snarkSpec (x0 x1 x2 x3) 
  (SPECCALC::snarkSpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::snarkVar (x0 x1) (SPECCALC::snarkVar-1 (cons x0 x1)))

(defun SPECCALC::sortMap (x0 x1 x2 x3) 
  (SPECCALC::sortMap-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::specCat-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECCALC::specCat))

(defun SPECCALC::specColimit (x0 x1) (SPECCALC::specColimit-1 (cons x0 x1)))

(defun SPECCALC::specObligations-1 (x) 
  (SPECCALC::specObligations (car x) (cdr x)))

(defun SPECCALC::splitAtChar (x1) 
  #'(lambda (x2) (SPECCALC::splitAtChar-1-1 x1 x2)))

(defun SPECCALC::splitStringAtChar (x1) 
  #'(lambda (x2) (SPECCALC::splitStringAtChar-1-1 x1 x2)))

(defun SPECCALC::substOpMap-1 (x) (SPECCALC::substOpMap (car x) (cdr x)))

(defun SPECCALC::takeWhile (x1) 
  #'(lambda (x2) (SPECCALC::takeWhile-1-1 x1 x2)))

(defun SPECCALC::termOpsInSpec-1 (x) (SPECCALC::termOpsInSpec (car x) (cdr x)))

(defun SPECCALC::termOpsInSpec?-1 (x) 
  (SPECCALC::termOpsInSpec? (car x) (cdr x)))

(defun SPECCALC::toJavaFile-1 (x) 
  (SPECCALC::toJavaFile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::toJavaFileEnv-1 (x) 
  (SPECCALC::toJavaFileEnv (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::toSnark-1 (spc) (SPECCALC::toSnarkEnv-1 spc))

(defun SPECCALC::toSnark (x0 x1 x2 x3) 
  (SPECCALC::toSnark-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::toSnarkEnv (x0 x1 x2 x3) 
  (SPECCALC::toSnarkEnv-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::toSnarkFile-1 (x) 
  (SPECCALC::toSnarkFile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::toSnarkFileEnv-1 (x) 
  (SPECCALC::toSnarkFileEnv (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::|!trace| (str) (SPECCALC::|!print| str))

(defun SPECCALC::|!trace|-1-1 (x0 x1) (SPECCALC::|!print|-1-1 x0 x1))

(defun SPECCALC::translateSpec (x0 x1 x2 x3) 
  (SPECCALC::translateSpec-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::translateSpec-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::translateSpec-1 x1) x2) x3))

(defun SPECCALC::translateTerm-1 (x) 
  (SPECCALC::translateTerm (svref x 0) (svref x 1) (svref x 2)))

(defun SPECCALC::unLambdaDef-1 (x) 
  (SPECCALC::unLambdaDef (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECCALC::upToDate?-1 (x) (SPECCALC::upToDate? (car x) (cdr x)))

(defun SPECCALC::uriToPath (pV1 path) 
  (declare (ignore pV1)) 
  (let ((path (SPECCALC::abbreviatedPath path))) 
    (let ((device? (SPECCALC::deviceString? (LIST-SPEC::hd path)))) 
      (let ((tildaPath? (string=  (LIST-SPEC::hd path) "~"))) 
        (let ((mainPath 
               (STRING-SPEC::concatList 
                (LIST-SPEC::foldr-1-1-1 
                 #'(lambda (x) 
                    (LIST-SPEC::|!cons| "/" (LIST-SPEC::|!cons| (car x) (cdr x)))) 
                 nil 
                 (if (cl:or tildaPath? device?) (LIST-SPEC::tl path) path))))) 
          (if tildaPath? 
              (STRING-SPEC::^ "~" mainPath) 
              (if device? 
                  (STRING-SPEC::^ (LIST-SPEC::hd path) mainPath) 
                  mainPath)))))))

(defun SPECCALC::uriToPath-1 (x) (SPECCALC::uriToPath (car x) (cdr x)))

(defun SPECCALC::validateCache (x0 x1) (SPECCALC::validateCache-1 (cons x0 x1)))

(defun SPECCALC::validateCache-1-1 (x1 x2) 
  (funcall (SPECCALC::validateCache-1 x1) x2))

(defun SPECCALC::validatedURI? (x0 x1) (SPECCALC::validatedURI?-1 (cons x0 x1)))

(defun SPECCALC::warnAboutMissingItems (x0 x1 x2 x3) 
  (SPECCALC::warnAboutMissingItems-1 (vector x0 x1 x2 x3)))

(defun SPECCALC::|!when|-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::|!when| x1) x2) x3))

(defun SPECENVIRONMENT::arrow-1 (x) (SPECENVIRONMENT::arrow (car x) (cdr x)))

(defun SPECENVIRONMENT::arrowOpt-1 (x) 
  (SPECENVIRONMENT::arrowOpt (car x) (cdr x)))

(defun SPECENVIRONMENT::coproduct (sp srt) 
  (let ((pV3 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|CoProduct|) (return (car (cdr pV3)))) 
     (return (SYSTEM-SPEC::fail "Could not extract co-product sort")))))

(defun SPECENVIRONMENT::coproduct-1 (x) 
  (SPECENVIRONMENT::coproduct (car x) (cdr x)))

(defun SPECENVIRONMENT::coproductOpt (sp srt) 
  (let ((pV3 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV3) :|CoProduct|) (return (cons :|Some| (car (cdr pV3))))) 
     (return '(:|None|)))))

(defun SPECENVIRONMENT::coproductOpt-1 (x) 
  (SPECENVIRONMENT::coproductOpt (car x) (cdr x)))

(defun SPECENVIRONMENT::domain-1 (x) (SPECENVIRONMENT::domain (car x) (cdr x)))

(defun SPECENVIRONMENT::getSortOfOp (spc qid opName) 
  (let ((pV1 (STRINGMAP::find2 (svref spc 1) qid opName))) 
    (block 
     nil 
     (if (eq (car pV1) :|None|) 
         (return 
          (progn (ANNSPECPRINTER::printSpecToTerminal-1 spc) 
                 (SYSTEM-SPEC::fail 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ (STRING-SPEC::^ "Operator " qid) ".") 
                    opName) 
                   " has not been declared")))) 
         (if (eq (car pV1) :|Some|) 
             (let ((pV5 (svref (cdr pV1) 2))) 
               (return (cons (car pV5) (cdr pV5)))))) 
     (error "Nonexhaustive match failure in getSortOfOp"))))

(defun SPECENVIRONMENT::getSortOfOp-1 (x) 
  (SPECENVIRONMENT::getSortOfOp (svref x 0) (svref x 1) (svref x 2)))

(defun SPECENVIRONMENT::inferType-1 (x) 
  (SPECENVIRONMENT::inferType (car x) (cdr x)))

(defun SPLAYMAP::foldliAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV2 (cdr sp))) 
               (let ((pV5 (svref pV2 2))) 
                 (return 
                  (SPLAYMAP::foldliAp-1-1 
                   abf 
                   (cons 
                    (svref pV2 1) 
                    (funcall abf 
                             (vector 
                              (car pV5) 
                              (cdr pV5) 
                              (SPLAYMAP::foldliAp-1-1 abf (cons (svref pV2 0) b))))))))))) 
     (error "Nonexhaustive match failure in foldliAp"))))

(defun SPLAYMAP::foldli-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldliAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldli")))

(defun STRINGMAP::foldli-1-1-1 (x0 x1 x2) (SPLAYMAP::foldli-1-1-1 x0 x1 x2))

(defun SPECENVIRONMENT::lookupSpec (env spcname) 
  (STRINGMAP::foldli-1-1-1 
   #'(lambda (x) 
      (let ((pV5 (svref x 2))
            (pV4 (svref x 1))) 
        (block 
         nil 
         (if (eq (car pV5) :|Some|) 
             (let ((pV6 (cdr pV5))) 
               (return 
                (cons 
                 :|Some| 
                 (vector (svref pV6 0) (svref pV6 1) (svref pV6 2) (svref pV6 3))))) 
             (if (eq (car pV5) :|None|) 
                 (return 
                  (if (string=  (svref x 0) spcname) 
                      (cons 
                       :|Some| 
                       (vector 
                        (svref pV4 0) 
                        (svref pV4 1) 
                        (svref pV4 2) 
                        (svref pV4 3))) 
                      '(:|None|))))) 
         (error "Nonexhaustive match failure in lookupSpec")))) 
   '(:|None|) 
   env))

(defun SPECENVIRONMENT::lookupSpec-1 (x) 
  (SPECENVIRONMENT::lookupSpec (car x) (cdr x)))

(defun SPECENVIRONMENT::mkProjectTerm-1 (x) 
  (SPECENVIRONMENT::mkProjectTerm (svref x 0) (svref x 1) (svref x 2)))

(defun SPECENVIRONMENT::mkRestrict-1 (x) 
  (SPECENVIRONMENT::mkRestrict (car x) (cdr x)))

(defun SPECENVIRONMENT::mkSelectTerm (sp id term) 
  (let ((srt (SPECENVIRONMENT::inferType sp term))) 
    (let ((fields (SPECENVIRONMENT::coproduct sp srt))) 
      (let ((pV3 
             (LIST-SPEC::|!find|-1-1 
              #'(lambda (x) (string=  id (car x))) 
              fields))) 
        (block 
         nil 
         (if (eq (car pV3) :|Some|) 
             (let ((pV6 (cdr (cdr pV3)))) 
               (if (eq (car pV6) :|Some|) 
                   (return 
                    (STANDARDSPEC::mkApply 
                     (cons 
                      :|Fun| 
                      (vector 
                       (cons :|Select| id) 
                       (STANDARDSPEC::mkArrow srt (cdr pV6)) 
                       POSITION-SPEC::noPos)) 
                     term))))) 
         (return (SYSTEM-SPEC::fail "Selection index not found in product")))))))


(defun SPECENVIRONMENT::mkSelectTerm-1 (x) 
  (SPECENVIRONMENT::mkSelectTerm (svref x 0) (svref x 1) (svref x 2)))

(defparameter SPECENVIRONMENT::primitiveSpecNames 
  (cons 
   "Nat" 
   (cons 
    "Integer" 
    (cons 
     "String" 
     (cons 
      "Char" 
      (cons 
       "Boolean" 
       (cons "General" (cons "List" (cons "TranslationBuiltIn" nil)))))))))

(defun SPECENVIRONMENT::product-1 (x) 
  (SPECENVIRONMENT::product (car x) (cdr x)))

(defun SPECENVIRONMENT::productOpt-1 (x) 
  (SPECENVIRONMENT::productOpt (car x) (cdr x)))

(defun SPECENVIRONMENT::range-1 (x) (SPECENVIRONMENT::range (car x) (cdr x)))

(defun SPECENVIRONMENT::rangeOpt-1 (x) 
  (SPECENVIRONMENT::rangeOpt (car x) (cdr x)))

(defun SPECENVIRONMENT::stripSubsorts-1 (x) 
  (SPECENVIRONMENT::stripSubsorts (car x) (cdr x)))

(defun SPECENVIRONMENT::substSort-1 (x) 
  (SPECENVIRONMENT::substSort (car x) (cdr x)))

(defun SPECENVIRONMENT::unfoldToArrow (sp srt) 
  (labels 
    ((unfoldRec (srt) 
      (let ((usrt (SPECENVIRONMENT::unfoldBase sp srt))) 
        (if (slang-built-in::slang-term-equals usrt srt) srt (unfoldRec usrt))))) 
    (let ((usrt (unfoldRec srt))) 
      (block nil (if (eq (car usrt) :|Arrow|) (return usrt)) (return srt)))))

(defun SPECENVIRONMENT::termSortEnv (sp term) 
  (let ((res 
         (block 
          nil 
          (if (eq (car term) :|Apply|) 
              (return 
               (let ((pV4 (SPECENVIRONMENT::termSortEnv sp (svref (cdr term) 0)))) 
                 (block 
                  nil 
                  (if (eq (car pV4) :|Arrow|) (return (svref (cdr pV4) 1))) 
                  (return 
                   (SYSTEM-SPEC::fail 
                    (STRING-SPEC::^ 
                     "Cannot extract sort of application " 
                     (SYSTEM-SPEC::toString term))))))) 
              (if (eq (car term) :|Bind|) 
                  (return STANDARDSPEC::boolSort) 
                  (if (eq (car term) :|Record|) 
                      (return 
                       (cons 
                        :|Product| 
                        (cons 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (x) 
                             (cons 
                              (car x) 
                              (SPECENVIRONMENT::termSortEnv sp (cdr x)))) 
                          (car (cdr term))) 
                         POSITION-SPEC::noPos))) 
                      (if (eq (car term) :|Let|) 
                          (return 
                           (SPECENVIRONMENT::termSortEnv sp (svref (cdr term) 1))) 
                          (if (eq (car term) :|LetRec|) 
                              (return 
                               (SPECENVIRONMENT::termSortEnv 
                                sp 
                                (svref (cdr term) 1))) 
                              (if (eq (car term) :|Var|) 
                                  (return 
                                   (SPECENVIRONMENT::unfoldToArrow 
                                    sp 
                                    (cdr (car (cdr term))))) 
                                  (if (eq (car term) :|Fun|) 
                                      (return 
                                       (SPECENVIRONMENT::unfoldToArrow 
                                        sp 
                                        (svref (cdr term) 1))) 
                                      (if (eq (car term) :|Lambda|) 
                                          (let ((pV40 (car (cdr term)))) 
                                            (if (consp pV40) 
                                                (let ((pV43 (car pV40))) 
                                                  (return 
                                                   (STANDARDSPEC::mkArrow 
                                                    (METASLANG::patternSort 
                                                     (svref pV43 0)) 
                                                    (SPECENVIRONMENT::termSortEnv 
                                                     sp 
                                                     (svref pV43 2))))) 
                                                (if (null pV40) 
                                                    (return 
                                                     (SYSTEM-SPEC::fail 
                                                      "Ill formed lambda abstraction"))))) 
                                          (if (eq (car term) :|IfThenElse|) 
                                              (return 
                                               (SPECENVIRONMENT::termSortEnv 
                                                sp 
                                                (svref (cdr term) 1))) 
                                              (if (eq (car term) :|Seq|) 
                                                  (return 
                                                   (STANDARDSPEC::mkProduct nil)))))))))))) 
          (return (SYSTEM-SPEC::fail "Non-exhaustive match"))))) res))

(defun SPECENVIRONMENT::termSortEnv-1 (x) 
  (SPECENVIRONMENT::termSortEnv (car x) (cdr x)))

(defun SPECENVIRONMENT::unfoldBase-1 (x) 
  (SPECENVIRONMENT::unfoldBase (car x) (cdr x)))

(defun SPECENVIRONMENT::unfoldBaseV-1 (x) 
  (SPECENVIRONMENT::unfoldBaseV (svref x 0) (svref x 1) (svref x 2)))

(defun SPECENVIRONMENT::unfoldStripSort1 (sp srt vsrts verbose) 
  (if (LIST-SPEC::|!member| srt vsrts) 
      srt 
      (block 
       nil 
       (if (eq (car srt) :|Arrow|) 
           (let ((pV14 (cdr srt))) 
             (return 
              (cons 
               :|Arrow| 
               (vector 
                (SPECENVIRONMENT::unfoldStripSort1 
                 sp 
                 (svref pV14 0) 
                 vsrts 
                 verbose) 
                (SPECENVIRONMENT::unfoldStripSort1 
                 sp 
                 (svref pV14 1) 
                 vsrts 
                 verbose) 
                (svref pV14 2))))) 
           (if (eq (car srt) :|Product|) 
               (let ((pV13 (cdr srt))) 
                 (return 
                  (cons 
                   :|Product| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (cons 
                         (car x) 
                         (SPECENVIRONMENT::unfoldStripSort1 
                          sp 
                          (cdr x) 
                          vsrts 
                          verbose))) 
                     (car pV13)) 
                    (cdr pV13))))) 
               (if (eq (car srt) :|CoProduct|) 
                   (let ((pV12 (cdr srt))) 
                     (return 
                      (cons 
                       :|CoProduct| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (let ((pV2 (cdr x))
                                  (pV1 (car x))) 
                              (block 
                               nil 
                               (if (eq (car pV2) :|None|) 
                                   (return (cons pV1 '(:|None|))) 
                                   (if (eq (car pV2) :|Some|) 
                                       (return 
                                        (cons 
                                         pV1 
                                         (cons 
                                          :|Some| 
                                          (SPECENVIRONMENT::unfoldStripSort1 
                                           sp 
                                           (cdr pV2) 
                                           vsrts 
                                           verbose)))))) 
                               (error 
                                "Nonexhaustive match failure in unfoldStripSort1")))) 
                         (car pV12)) 
                        (cdr pV12))))) 
                   (if (eq (car srt) :|Quotient|) 
                       (return 
                        (SPECENVIRONMENT::unfoldStripSort1 
                         sp 
                         (svref (cdr srt) 0) 
                         vsrts 
                         verbose)) 
                       (if (eq (car srt) :|Subsort|) 
                           (return 
                            (SPECENVIRONMENT::unfoldStripSort1 
                             sp 
                             (svref (cdr srt) 0) 
                             vsrts 
                             verbose)) 
                           (if (eq (car srt) :|Base|) 
                               (let ((pV9 (cdr srt))) 
                                 (return 
                                  (let ((srts 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (s) 
                                             (SPECENVIRONMENT::unfoldStripSort1 
                                              sp 
                                              s 
                                              vsrts 
                                              verbose)) 
                                          (svref pV9 1)))) 
                                    (let ((srt0 
                                           (cons 
                                            :|Base| 
                                            (vector 
                                             (svref pV9 0) 
                                             srts 
                                             (svref pV9 2))))) 
                                      (let ((srt1 
                                             (SPECENVIRONMENT::unfoldBaseV 
                                              sp 
                                              srt0 
                                              verbose))) 
                                        (if (slang-built-in::slang-term-equals 
                                             srt1 
                                             srt0) 
                                            srt1 
                                            (SPECENVIRONMENT::unfoldStripSort1 
                                             sp 
                                             srt1 
                                             (LIST-SPEC::|!cons| srt0 vsrts) 
                                             verbose))))))) 
                               (if (eq (car srt) :|TyVar|) (return srt)))))))) 
       (error "Nonexhaustive match failure in unfoldStripSort1"))))

(defun SPECENVIRONMENT::unfoldStripSort (spc srt verbose) 
  (SPECENVIRONMENT::unfoldStripSort1 spc srt nil verbose))

(defun SPECENVIRONMENT::unfoldStripSort-1 (x) 
  (SPECENVIRONMENT::unfoldStripSort (svref x 0) (svref x 1) (svref x 2)))

(defun SPECENVIRONMENT::unfoldStripSort1-1 (x) 
  (SPECENVIRONMENT::unfoldStripSort1 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECENVIRONMENT::unfoldToArrow-1 (x) 
  (SPECENVIRONMENT::unfoldToArrow (car x) (cdr x)))

(defun SPECTOLISP::blockAtom-1 (x) 
  (SPECTOLISP::blockAtom (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECTOLISP::countOccurrence2-1 (x) 
  (SPECTOLISP::countOccurrence2 (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::curryShapeNum-1 (x) 
  (SPECTOLISP::curryShapeNum (car x) (cdr x)))

(defun SPECTOLISP::defAliasFn-1 (x) (SPECTOLISP::defAliasFn (car x) (cdr x)))

(defun SPECTOLISP::defCurryByUncurry-1 (x) 
  (SPECTOLISP::defCurryByUncurry (car x) (cdr x)))

(defun SPECTOLISP::defNaryByUnary-1 (x) 
  (SPECTOLISP::defNaryByUnary (car x) (cdr x)))

(defun SPECTOLISP::defUnaryByNary-1 (x) 
  (SPECTOLISP::defUnaryByNary (car x) (cdr x)))

(defun SPECTOLISP::defUncurryByUnary-1 (x) 
  (SPECTOLISP::defUncurryByUnary (car x) (cdr x)))

(defun SPECTOLISP::duplicateString-1 (x) 
  (SPECTOLISP::duplicateString (car x) (cdr x)))

(defun SPECTOLISP::fullCurriedApplication-1 (x) 
  (SPECTOLISP::fullCurriedApplication 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun SPECTOLISP::functionSort?-1 (x) 
  (SPECTOLISP::functionSort? (car x) (cdr x)))

(defun SPECTOLISP::hasConsDomain-1 (x) 
  (SPECTOLISP::hasConsDomain (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::hasConsEmbed (sp srt) 
  (let ((pV7 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7) :|Arrow|) 
         (return 
          (let ((pV4 (SPECTOLISP::isConsDataType sp (svref (cdr pV7) 1)))) 
            (block 
             nil 
             (if (eq (car pV4) :|Some|) 
                 (return t) 
                 (if (eq (car pV4) :|None|) (return nil))) 
             (error "Nonexhaustive match failure in hasConsEmbed"))))) 
     (return nil))))

(defun SPECTOLISP::hasConsEmbed-1 (x) 
  (SPECTOLISP::hasConsEmbed (car x) (cdr x)))

(defun SPECTOLISP::initializeSpecId-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECTOLISP::initializeSpecId))

(defun SPECTOLISP::isConsDataType-1 (x) 
  (SPECTOLISP::isConsDataType (car x) (cdr x)))

(defun SPECTOLISP::isConsIdentifier-1 (x) 
  (SPECTOLISP::isConsIdentifier (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::isPairProjection-1 (x) 
  (SPECTOLISP::isPairProjection (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::ith-1 (x) 
  (SPECTOLISP::ith (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::|!lisp| (x0 x1 x2 x3) 
  (SPECTOLISP::|!lisp|-1 (vector x0 x1 x2 x3)))

(defun SPECTOLISP::lispBlock-1 (x) 
  (SPECTOLISP::lispBlock (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECTOLISP::lispTerm-1 (x) 
  (SPECTOLISP::lispTerm (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::localDefsToLispFile-1 (x) 
  (SPECTOLISP::localDefsToLispFile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::lookupSpecId-1 (x) 
  (SPECTOLISP::lookupSpecId (car x) (cdr x)))

(defun SPECTOLISP::mkLApplyArity-1 (x) 
  (SPECTOLISP::mkLApplyArity (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECTOLISP::mkLEqualityOp-1 (x) 
  (SPECTOLISP::mkLEqualityOp (car x) (cdr x)))

(defun SPECTOLISP::mkLTerm-1 (x) 
  (SPECTOLISP::mkLTerm (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECTOLISP::mkLTermList-1 (x) 
  (SPECTOLISP::mkLTermList (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECTOLISP::mkLTermOp-1 (x) 
  (SPECTOLISP::mkLTermOp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun SPECTOLISP::mkLUnaryFnRef-1 (x) 
  (SPECTOLISP::mkLUnaryFnRef (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::nTupleDerefs-1 (x) 
  (SPECTOLISP::nTupleDerefs (car x) (cdr x)))

(defun SPECTOLISP::newName-1 (x) (SPECTOLISP::newName (car x) (cdr x)))

(defun SPECTOLISP::opArity-1 (x) 
  (SPECTOLISP::opArity (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::printPackageId-1 (x) 
  (SPECTOLISP::printPackageId (car x) (cdr x)))

(defun SPECTOLISP::projectionIndex-1 (x) 
  (SPECTOLISP::projectionIndex (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::toLisp-1 (spc) (SPECTOLISP::toLispEnv-1 spc))

(defun SPECTOLISP::toLisp (x0 x1 x2 x3) 
  (SPECTOLISP::toLisp-1 (vector x0 x1 x2 x3)))

(defun SPECTOLISP::toLispEnv (x0 x1 x2 x3) 
  (SPECTOLISP::toLispEnv-1 (vector x0 x1 x2 x3)))

(defun SPECTOLISP::toLispFile-1 (x) 
  (SPECTOLISP::toLispFile (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::toLispFileEnv-1 (x) 
  (SPECTOLISP::toLispFileEnv (svref x 0) (svref x 1) (svref x 2)))

(defun SPECTOLISP::toLispText-1 (spc) 
  (let ((lSpc (SPECTOLISP::toLispEnv-1 spc))) 
    (let ((p (LISTADT::ppSpec-1 lSpc))) (PRETTYPRINT::|!format| 80 p))))

(defun SPECTOLISP::toLispText (x0 x1 x2 x3) 
  (SPECTOLISP::toLispText-1 (vector x0 x1 x2 x3)))

(defun SPECTOLISP::unCurryDef-1 (x) (SPECTOLISP::unCurryDef (car x) (cdr x)))

(defun SPECTOLISP::unCurryName-1 (x) (SPECTOLISP::unCurryName (car x) (cdr x)))

(defun SPECTOPOSSPEC::convertFunToPFun (f) 
  (block 
   nil 
   (if (eq (car f) :|Equals|) 
       (return '(:|Equals|)) 
       (if (eq (car f) :|Op|) 
           (let ((pV11 (cdr f))) 
             (return (cons :|Op| (cons (car pV11) (cdr pV11))))) 
           (if (eq (car f) :|Project|) 
               (return (cons :|Project| (cdr f))) 
               (if (eq (car f) :|Embed|) 
                   (let ((pV9 (cdr f))) 
                     (return (cons :|Embed| (cons (car pV9) (cdr pV9))))) 
                   (if (eq (car f) :|Embedded|) 
                       (return (cons :|Embedded| (cdr f))) 
                       (if (eq (car f) :|Nat|) 
                           (return (cons :|Nat| (cdr f))) 
                           (if (eq (car f) :|Char|) 
                               (return (cons :|Char| (cdr f))) 
                               (if (eq (car f) :|String|) 
                                   (return (cons :|String| (cdr f))) 
                                   (if (eq (car f) :|Bool|) 
                                       (return (cons :|Bool| (cdr f))) 
                                       (if (eq (car f) :|Quotient|) 
                                           (return '(:|Quotient|)) 
                                           (if (eq (car f) :|Choose|) 
                                               (return '(:|Choose|)) 
                                               (if (eq (car f) :|Restrict|) 
                                                   (return '(:|Restrict|)) 
                                                   (if (eq (car f) :|Relax|) 
                                                       (return '(:|Relax|)) 
                                                       (if (eq 
                                                            (car f) 
                                                            :|OneName|) 
                                                           (let ((pV3 (cdr f))) 
                                                             (return 
                                                              (cons 
                                                               :|OneName| 
                                                               (cons 
                                                                (car pV3) 
                                                                (cdr pV3))))) 
                                                           (if (eq 
                                                                (car f) 
                                                                :|TwoNames|) 
                                                               (let ((pV2 
                                                                      (cdr f))) 
                                                                 (return 
                                                                  (cons 
                                                                   :|TwoNames| 
                                                                   (vector 
                                                                    (svref pV2 0) 
                                                                    (svref pV2 1) 
                                                                    (svref pV2 2)))))))))))))))))))) 
   (error "Nonexhaustive match failure in convertFunToPFun")))

(defun SPECTOPOSSPEC::convertOpInfoToPOpInfo (x0 x1 x2 x3) 
  (SPECTOPOSSPEC::convertOpInfoToPOpInfo-1 (vector x0 x1 x2 x3)))

(defun SPECTOPOSSPEC::convertVarToPVar (n s) 
  (cons n (SPECTOPOSSPEC::convertSortToPSort s)))

(defun SPECTOPOSSPEC::convertVarToPVar-1 (x) 
  (SPECTOPOSSPEC::convertVarToPVar (car x) (cdr x)))

(defun SPECTOPOSSPEC::convertVarsToPVars (vars) 
  (LIST-SPEC::|!map|-1-1 #'SPECTOPOSSPEC::convertVarToPVar-1 vars))

(defun SPECTOPOSSPEC::convertTermToPTerm (term) 
  (let ((pos (cons :|Internal| "converted from linked term"))) 
    (block 
     nil 
     (if (eq (car term) :|Apply|) 
         (let ((pV21 (cdr term))) 
           (return 
            (cons 
             :|ApplyN| 
             (cons 
              (cons 
               (SPECTOPOSSPEC::convertTermToPTerm (svref pV21 0)) 
               (cons (SPECTOPOSSPEC::convertTermToPTerm (svref pV21 1)) nil)) 
              pos)))) 
         (if (eq (car term) :|Record|) 
             (return 
              (cons 
               :|Record| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (SPECTOPOSSPEC::convertTermToPTerm (cdr x)))) 
                 (car (cdr term))) 
                pos))) 
             (if (eq (car term) :|Bind|) 
                 (let ((pV19 (cdr term))) 
                   (return 
                    (cons 
                     :|Bind| 
                     (vector 
                      (svref pV19 0) 
                      (SPECTOPOSSPEC::convertVarsToPVars (svref pV19 1)) 
                      (SPECTOPOSSPEC::convertTermToPTerm (svref pV19 2)) 
                      pos)))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV18 (cdr term))) 
                       (return 
                        (cons 
                         :|Let| 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x) 
                              (cons 
                               (SPECTOPOSSPEC::convertPatternToPPattern (car x)) 
                               (SPECTOPOSSPEC::convertTermToPTerm (cdr x)))) 
                           (svref pV18 0)) 
                          (SPECTOPOSSPEC::convertTermToPTerm (svref pV18 1)) 
                          pos)))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV17 (cdr term))) 
                           (return 
                            (cons 
                             :|LetRec| 
                             (vector 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x) 
                                  (cons 
                                   (SPECTOPOSSPEC::convertVarToPVar-1 (car x)) 
                                   (SPECTOPOSSPEC::convertTermToPTerm (cdr x)))) 
                               (svref pV17 0)) 
                              (SPECTOPOSSPEC::convertTermToPTerm (svref pV17 1)) 
                              pos)))) 
                         (if (eq (car term) :|Var|) 
                             (let ((pV33 (car (cdr term)))) 
                               (return 
                                (cons 
                                 :|Var| 
                                 (cons 
                                  (cons 
                                   (car pV33) 
                                   (SPECTOPOSSPEC::convertSortToPSort (cdr pV33))) 
                                  pos)))) 
                             (if (eq (car term) :|Fun|) 
                                 (let ((pV15 (cdr term))) 
                                   (return 
                                    (let ((srt 
                                           (SPECTOPOSSPEC::convertSortToPSort 
                                            (svref pV15 1)))) 
                                      (cons 
                                       :|Fun| 
                                       (vector 
                                        (SPECTOPOSSPEC::convertFunToPFun 
                                         (svref pV15 0)) 
                                        srt 
                                        pos))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (return 
                                      (cons 
                                       :|Lambda| 
                                       (cons 
                                        (LIST-SPEC::|!map|-1-1 
                                         #'(lambda (x) 
                                            (vector 
                                             (SPECTOPOSSPEC::convertPatternToPPattern 
                                              (svref x 0)) 
                                             (SPECTOPOSSPEC::convertTermToPTerm 
                                              (svref x 1)) 
                                             (SPECTOPOSSPEC::convertTermToPTerm 
                                              (svref x 2)))) 
                                         (car (cdr term))) 
                                        pos))) 
                                     (if (eq (car term) :|IfThenElse|) 
                                         (let ((pV13 (cdr term))) 
                                           (return 
                                            (cons 
                                             :|IfThenElse| 
                                             (vector 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV13 0)) 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV13 1)) 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV13 2)) 
                                              pos)))) 
                                         (if (eq (car term) :|Seq|) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'SPECTOPOSSPEC::convertTermToPTerm 
                                                 (car (cdr term))) 
                                                pos))))))))))))) 
     (error "Nonexhaustive match failure in convertTermToPTerm"))))

(defun SPECTOPOSSPEC::convertSortToPSort (s) 
  (let ((pos (cons :|Internal| "converted from linked sort"))) 
    (block 
     nil 
     (if (eq (car s) :|Arrow|) 
         (let ((pV17 (cdr s))) 
           (return 
            (cons 
             :|Arrow| 
             (vector 
              (SPECTOPOSSPEC::convertSortToPSort (svref pV17 0)) 
              (SPECTOPOSSPEC::convertSortToPSort (svref pV17 1)) 
              pos)))) 
         (if (eq (car s) :|Product|) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (SPECTOPOSSPEC::convertSortToPSort (cdr x)))) 
                 (car (cdr s))) 
                pos))) 
             (if (eq (car s) :|CoProduct|) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((s1 (cdr x))) 
                          (cons 
                           (car x) 
                           (block 
                            nil 
                            (if (eq (car s1) :|None|) 
                                (return '(:|None|)) 
                                (if (eq (car s1) :|Some|) 
                                    (return 
                                     (cons 
                                      :|Some| 
                                      (SPECTOPOSSPEC::convertSortToPSort 
                                       (cdr s1)))))) 
                            (error 
                             "Nonexhaustive match failure in convertSortToPSort"))))) 
                     (car (cdr s))) 
                    pos))) 
                 (if (eq (car s) :|Quotient|) 
                     (let ((pV14 (cdr s))) 
                       (return 
                        (cons 
                         :|Quotient| 
                         (vector 
                          (SPECTOPOSSPEC::convertSortToPSort (svref pV14 0)) 
                          (SPECTOPOSSPEC::convertTermToPTerm (svref pV14 1)) 
                          pos)))) 
                     (if (eq (car s) :|Subsort|) 
                         (let ((pV13 (cdr s))) 
                           (return 
                            (cons 
                             :|Subsort| 
                             (vector 
                              (SPECTOPOSSPEC::convertSortToPSort (svref pV13 0)) 
                              (SPECTOPOSSPEC::convertTermToPTerm (svref pV13 1)) 
                              pos)))) 
                         (if (eq (car s) :|Base|) 
                             (let ((pV12 (cdr s))) 
                               (return 
                                (cons 
                                 :|Base| 
                                 (vector 
                                  (svref pV12 0) 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'SPECTOPOSSPEC::convertSortToPSort 
                                   (svref pV12 1)) 
                                  pos)))) 
                             (if (eq (car s) :|TyVar|) 
                                 (return 
                                  (cons :|TyVar| (cons (car (cdr s)) pos)))))))))) 
     (error "Nonexhaustive match failure in convertSortToPSort"))))

(defun SPECTOPOSSPEC::convertPatternToPPattern (p) 
  (let ((pos (cons :|Internal| "converted from linked pattern"))) 
    (block 
     nil 
     (if (eq (car p) :|StringPat|) 
         (return (cons :|StringPat| (cons (car (cdr p)) pos))) 
         (if (eq (car p) :|BoolPat|) 
             (return (cons :|BoolPat| (cons (car (cdr p)) pos))) 
             (if (eq (car p) :|CharPat|) 
                 (return (cons :|CharPat| (cons (car (cdr p)) pos))) 
                 (if (eq (car p) :|NatPat|) 
                     (return (cons :|NatPat| (cons (car (cdr p)) pos))) 
                     (if (eq (car p) :|VarPat|) 
                         (return 
                          (cons 
                           :|VarPat| 
                           (cons 
                            (SPECTOPOSSPEC::convertVarToPVar-1 (car (cdr p))) 
                            pos))) 
                         (if (eq (car p) :|WildPat|) 
                             (return 
                              (cons 
                               :|WildPat| 
                               (cons 
                                (SPECTOPOSSPEC::convertSortToPSort (car (cdr p))) 
                                pos))) 
                             (if (eq (car p) :|AliasPat|) 
                                 (let ((pV19 (cdr p))) 
                                   (return 
                                    (cons 
                                     :|AliasPat| 
                                     (vector 
                                      (SPECTOPOSSPEC::convertPatternToPPattern 
                                       (svref pV19 0)) 
                                      (SPECTOPOSSPEC::convertPatternToPPattern 
                                       (svref pV19 1)) 
                                      pos)))) 
                                 (if (eq (car p) :|RelaxPat|) 
                                     (let ((pV18 (cdr p))) 
                                       (return 
                                        (cons 
                                         :|RelaxPat| 
                                         (vector 
                                          (SPECTOPOSSPEC::convertPatternToPPattern 
                                           (svref pV18 0)) 
                                          (SPECTOPOSSPEC::convertTermToPTerm 
                                           (svref pV18 1)) 
                                          pos)))) 
                                     (if (eq (car p) :|QuotientPat|) 
                                         (let ((pV17 (cdr p))) 
                                           (return 
                                            (cons 
                                             :|QuotientPat| 
                                             (vector 
                                              (SPECTOPOSSPEC::convertPatternToPPattern 
                                               (svref pV17 0)) 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV17 1)) 
                                              pos)))) 
                                         (if (eq (car p) :|RecordPat|) 
                                             (return 
                                              (cons 
                                               :|RecordPat| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (x) 
                                                    (cons 
                                                     (car x) 
                                                     (SPECTOPOSSPEC::convertPatternToPPattern 
                                                      (cdr x)))) 
                                                 (car (cdr p))) 
                                                pos))) 
                                             (if (eq (car p) :|EmbedPat|) 
                                                 (let ((pV15 (cdr p))) 
                                                   (let ((pV27 (svref pV15 1))) 
                                                     (return 
                                                      (cons 
                                                       :|EmbedPat| 
                                                       (vector 
                                                        (svref pV15 0) 
                                                        (block 
                                                         nil 
                                                         (if (eq 
                                                              (car pV27) 
                                                              :|None|) 
                                                             (return '(:|None|)) 
                                                             (if (eq 
                                                                  (car pV27) 
                                                                  :|Some|) 
                                                                 (return 
                                                                  (cons 
                                                                   :|Some| 
                                                                   (SPECTOPOSSPEC::convertPatternToPPattern 
                                                                    (cdr pV27)))))) 
                                                         (error 
                                                          "Nonexhaustive match failure in convertPatternToPPattern")) 
                                                        (SPECTOPOSSPEC::convertSortToPSort 
                                                         (svref pV15 2)) 
                                                        pos)))))))))))))))) 
     (error "Nonexhaustive match failure in convertPatternToPPattern"))))

(defun SPECTOPOSSPEC::convertSortInfoToPSortInfo (x0 x1 x2) 
  (SPECTOPOSSPEC::convertSortInfoToPSortInfo-1 (vector x0 x1 x2)))

(defun SPECTOPOSSPEC::convertSpecToPosSpec (x0 x1 x2 x3) 
  (SPECTOPOSSPEC::convertSpecToPosSpec-1 (vector x0 x1 x2 x3)))

(defun SPECUNION::opsUnion-1-1 (x1 x2) (funcall (SPECUNION::opsUnion x1) x2))

(defun SPECUNION::propertiesUnion-1-1 (x1 x2) 
  (funcall (SPECUNION::propertiesUnion x1) x2))

(defun SPECUNION::sortsUnion-1-1 (x1 x2) 
  (funcall (SPECUNION::sortsUnion x1) x2))

(defun SPECUNION::specUnion-1-1 (x1 x2) (funcall (SPECUNION::specUnion x1) x2))

(defun SPECUNION::unionOpMaps-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECUNION::unionOpMaps x1) x2) x3))

(defun SPECUNION::unionSortMaps-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECUNION::unionSortMaps x1) x2) x3))

(defun SPECWARE::maybeAddSuffix-1-1 (path suffix) 
  (if (LIST-SPEC::|!member| #\. (STRING-SPEC::explode path)) 
      path 
      (STRING-SPEC::^ path suffix)))

(defun SPECWARE::removeSWsuffix (path) 
  (let ((pV2 (LIST-SPEC::rev (STRING-SPEC::explode path)))) 
    (block 
     nil 
     (if (consp pV2) 
         (let ((pV5 (cdr pV2))) 
           (if (eq #\w (car pV2)) 
               (if (consp pV5) 
                   (let ((pV8 (cdr pV5))) 
                     (if (eq #\s (car pV5)) 
                         (if (consp pV8) 
                             (if (eq #\. (car pV8)) 
                                 (return 
                                  (STRING-SPEC::implode 
                                   (LIST-SPEC::rev (cdr pV8)))))))))))) 
     (return path))))

(defun SPECWARE::evaluateJavaGen_fromLisp (path targetFile) 
  (let ((target 
         (block 
          nil 
          (if (eq (car targetFile) :|None|) 
              (return '(:|None|)) 
              (if (eq (car targetFile) :|Some|) 
                  (return 
                   (cons 
                    :|Some| 
                    (SPECWARE::maybeAddSuffix-1-1 (cdr targetFile) ".java"))))) 
          (error "Nonexhaustive match failure in evaluateJavaGen_fromLisp")))) 
    (let ((run 
           (SPECCALC::monadSeq 
            #'SPECWARE::restoreSavedSpecwareState-1 
            (SPECCALC::monadBind 
             (SPECCALC::pathToCanonicalURI ".") 
             #'(lambda (currentURI) 
                (SPECCALC::monadSeq 
                 (SPECCALC::setCurrentURI-1 currentURI) 
                 (SPECCALC::monadBind 
                  (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                  #'(lambda (path_body) 
                     (SPECCALC::monadBind 
                      (SPECCALC::pathToRelativeURI path_body) 
                      #'(lambda (uri) 
                         (SPECCALC::monadBind 
                          (SPECCALC::|!return| 
                           (cons 
                            :|String| 
                            (vector 
                             path 
                             POSITION-SPEC::startLineColumnByte 
                             (POSITION-SPEC::endLineColumnByte path_body)))) 
                          #'(lambda (|!position|) 
                             (SPECCALC::monadBind 
                              (funcall (SPECCALC::evaluateURI |!position|) uri) 
                              #'(lambda (spcInfo) 
                                 (SPECCALC::monadSeq 
                                  (SPECCALC::evaluateJavaGen 
                                   spcInfo 
                                   (cons (cons :|URI| uri) |!position|) 
                                   target) 
                                  (SPECCALC::monadSeq 
                                   #'SPECWARE::saveSpecwareState-1 
                                   (SPECCALC::|!return| t))))))))))))))))) 
      (let ((x 
             (SPECCALC::|!catch|-1-1-1 
              run 
              #'SPECWARE::toplevelHandler 
              SPECWARE::ignoredState))) 
        (let ((pV6 (car x))) 
          (block 
           nil 
           (if (eq (car pV6) :|Ok|) 
               (return (cdr pV6)) 
               (if (eq (car pV6) :|Exception|) 
                   (return 
                    (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
           (error "Nonexhaustive match failure in evaluateJavaGen_fromLisp")))))))


(defun SPECWARE::evaluateJavaGen_fromLisp-1 (x) 
  (SPECWARE::evaluateJavaGen_fromLisp (car x) (cdr x)))

(defun SPECWARE::evaluateLispCompileLocal_fromLisp (path targetFile) 
  (let ((target 
         (block 
          nil 
          (if (eq (car targetFile) :|None|) 
              (return '(:|None|)) 
              (if (eq (car targetFile) :|Some|) 
                  (return 
                   (cons 
                    :|Some| 
                    (SPECWARE::maybeAddSuffix-1-1 (cdr targetFile) ".lisp"))))) 
          (error 
           "Nonexhaustive match failure in evaluateLispCompileLocal_fromLisp")))) 
    (let ((run 
           (SPECCALC::monadSeq 
            #'SPECWARE::restoreSavedSpecwareState-1 
            (SPECCALC::monadBind 
             (SPECCALC::pathToCanonicalURI ".") 
             #'(lambda (currentURI) 
                (SPECCALC::monadSeq 
                 (SPECCALC::setCurrentURI-1 currentURI) 
                 (SPECCALC::monadBind 
                  (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                  #'(lambda (path_body) 
                     (SPECCALC::monadBind 
                      (SPECCALC::pathToRelativeURI path_body) 
                      #'(lambda (uri) 
                         (SPECCALC::monadBind 
                          (SPECCALC::|!return| 
                           (cons 
                            :|String| 
                            (vector 
                             path 
                             POSITION-SPEC::startLineColumnByte 
                             (POSITION-SPEC::endLineColumnByte path_body)))) 
                          #'(lambda (|!position|) 
                             (SPECCALC::monadBind 
                              (funcall (SPECCALC::evaluateURI |!position|) uri) 
                              #'(lambda (spcInfo) 
                                 (SPECCALC::monadSeq 
                                  (SPECCALC::evaluateLispCompileLocal 
                                   spcInfo 
                                   (cons (cons :|URI| uri) |!position|) 
                                   target) 
                                  (SPECCALC::monadSeq 
                                   #'SPECWARE::saveSpecwareState-1 
                                   (SPECCALC::|!return| t))))))))))))))))) 
      (let ((x 
             (SPECCALC::|!catch|-1-1-1 
              run 
              #'SPECWARE::toplevelHandler 
              SPECWARE::ignoredState))) 
        (let ((pV6 (car x))) 
          (block 
           nil 
           (if (eq (car pV6) :|Ok|) 
               (return (cdr pV6)) 
               (if (eq (car pV6) :|Exception|) 
                   (return 
                    (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
           (error 
            "Nonexhaustive match failure in evaluateLispCompileLocal_fromLisp")))))))


(defun SPECWARE::evaluateLispCompileLocal_fromLisp-1 (x) 
  (SPECWARE::evaluateLispCompileLocal_fromLisp (car x) (cdr x)))

(defun SPECWARE::evaluateLispCompile_fromLisp (path targetFile) 
  (let ((target 
         (block 
          nil 
          (if (eq (car targetFile) :|None|) 
              (return '(:|None|)) 
              (if (eq (car targetFile) :|Some|) 
                  (return 
                   (cons 
                    :|Some| 
                    (SPECWARE::maybeAddSuffix-1-1 (cdr targetFile) ".lisp"))))) 
          (error "Nonexhaustive match failure in evaluateLispCompile_fromLisp")))) 
    (let ((run 
           (SPECCALC::monadSeq 
            #'SPECWARE::restoreSavedSpecwareState-1 
            (SPECCALC::monadBind 
             (SPECCALC::pathToCanonicalURI ".") 
             #'(lambda (currentURI) 
                (SPECCALC::monadSeq 
                 (SPECCALC::setCurrentURI-1 currentURI) 
                 (SPECCALC::monadBind 
                  (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                  #'(lambda (path_body) 
                     (SPECCALC::monadBind 
                      (SPECCALC::pathToRelativeURI path_body) 
                      #'(lambda (uri) 
                         (SPECCALC::monadBind 
                          (SPECCALC::|!return| 
                           (cons 
                            :|String| 
                            (vector 
                             path 
                             POSITION-SPEC::startLineColumnByte 
                             (POSITION-SPEC::endLineColumnByte path_body)))) 
                          #'(lambda (|!position|) 
                             (SPECCALC::monadBind 
                              (funcall (SPECCALC::evaluateURI |!position|) uri) 
                              #'(lambda (spcInfo) 
                                 (SPECCALC::monadSeq 
                                  (SPECCALC::evaluateLispCompile 
                                   spcInfo 
                                   (cons (cons :|URI| uri) |!position|) 
                                   target) 
                                  (SPECCALC::monadSeq 
                                   #'SPECWARE::saveSpecwareState-1 
                                   (SPECCALC::|!return| t))))))))))))))))) 
      (let ((x 
             (SPECCALC::|!catch|-1-1-1 
              run 
              #'SPECWARE::toplevelHandler 
              SPECWARE::ignoredState))) 
        (let ((pV6 (car x))) 
          (block 
           nil 
           (if (eq (car pV6) :|Ok|) 
               (return (cdr pV6)) 
               (if (eq (car pV6) :|Exception|) 
                   (return 
                    (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
           (error "Nonexhaustive match failure in evaluateLispCompile_fromLisp")))))))


(defun SPECWARE::evaluateLispCompile_fromLisp-1 (x) 
  (SPECWARE::evaluateLispCompile_fromLisp (car x) (cdr x)))

(defun SPECWARE::evaluatePrint_fromLisp (path) 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToCanonicalURI ".") 
           #'(lambda (currentURI) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 currentURI) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                #'(lambda (path_body) 
                   (SPECCALC::monadBind 
                    (SPECCALC::pathToRelativeURI path_body) 
                    #'(lambda (uri) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| 
                         (cons 
                          :|String| 
                          (vector 
                           path 
                           POSITION-SPEC::startLineColumnByte 
                           (POSITION-SPEC::endLineColumnByte path_body)))) 
                        #'(lambda (|!position|) 
                           (SPECCALC::monadSeq 
                            (SPECCALC::evaluatePrint 
                             (cons :|URI| uri) 
                             |!position|) 
                            (SPECCALC::monadSeq 
                             #'SPECWARE::saveSpecwareState-1 
                             (SPECCALC::|!return| t))))))))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECWARE::ignoredState))) 
      (let ((pV4 (car x))) 
        (block 
         nil 
         (if (eq (car pV4) :|Ok|) 
             (return (cdr pV4)) 
             (if (eq (car pV4) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in evaluatePrint_fromLisp"))))))

(defun SPECWARE::fileNameHandler (unitId) 
  #'(lambda (except) 
     (block 
      nil 
      (if (eq (car except) :|URINotFound|) 
          (return 
           (if (slang-built-in::slang-term-equals (cdr (cdr except)) unitId) 
               (SPECCALC::|!return| nil) 
               (SPECCALC::raise except)))) 
      (return (SPECCALC::raise except)))))

(defun SPECWARE::reportErrorAtPosToJava (pos msg) 
  (block 
   nil 
   (if (eq (car pos) :|File|) 
       (let ((pV3 (cdr pos))) 
         (let ((pV5 (svref pV3 1))) 
           (return 
            (SPECWARE::reportErrorToJava 
             (svref pV3 0) 
             (svref pV5 0) 
             (svref pV5 1) 
             msg))))) 
   (return (SPECWARE::reportErrorToJava "" 0 0 msg))))

(defun SPECWARE::reportTypeErrorsToJava (errs) 
  (LIST-SPEC::app-1-1 
   #'(lambda (x) (SPECWARE::reportErrorAtPosToJava (cdr x) (car x))) 
   errs))

(defun SPECWARE::reportExceptionToJava (except) 
  (block 
   nil 
   (if (eq (car except) :|Unsupported|) 
       (let ((pV11 (cdr except))) 
         (return 
          (SPECWARE::reportErrorAtPosToJava 
           (car pV11) 
           (STRING-SPEC::^ "Unsupported operation: " (cdr pV11))))) 
       (if (eq (car except) :|URINotFound|) 
           (let ((pV10 (cdr except))) 
             (return 
              (SPECWARE::reportErrorAtPosToJava 
               (car pV10) 
               (STRING-SPEC::^ 
                "Unknown unit " 
                (SPECCALC::showRelativeURI (cdr pV10)))))) 
           (if (eq (car except) :|FileNotFound|) 
               (let ((pV9 (cdr except))) 
                 (return 
                  (SPECWARE::reportErrorAtPosToJava 
                   (car pV9) 
                   (STRING-SPEC::^ 
                    "Unknown unit " 
                    (SPECCALC::showRelativeURI (cdr pV9)))))) 
               (if (eq (car except) :|SpecError|) 
                   (let ((pV8 (cdr except))) 
                     (return 
                      (SPECWARE::reportErrorAtPosToJava 
                       (car pV8) 
                       (STRING-SPEC::^ "Error in specification: " (cdr pV8))))) 
                   (if (eq (car except) :|MorphError|) 
                       (let ((pV7 (cdr except))) 
                         (return 
                          (SPECWARE::reportErrorAtPosToJava 
                           (car pV7) 
                           (STRING-SPEC::^ "Error in morphism: " (cdr pV7))))) 
                       (if (eq (car except) :|DiagError|) 
                           (let ((pV6 (cdr except))) 
                             (return 
                              (SPECWARE::reportErrorAtPosToJava 
                               (car pV6) 
                               (STRING-SPEC::^ "Diagram error: " (cdr pV6))))) 
                           (if (eq (car except) :|TypeCheck|) 
                               (let ((pV5 (cdr except))) 
                                 (return 
                                  (SPECWARE::reportErrorAtPosToJava 
                                   (car pV5) 
                                   (STRING-SPEC::^ "Type error: " (cdr pV5))))) 
                               (if (eq (car except) :|Proof|) 
                                   (let ((pV4 (cdr except))) 
                                     (return 
                                      (SPECWARE::reportErrorAtPosToJava 
                                       (car pV4) 
                                       (STRING-SPEC::^ "Proof error: " (cdr pV4))))) 
                                   (if (eq (car except) :|TypeCheckErrors|) 
                                       (return 
                                        (SPECWARE::reportTypeErrorsToJava 
                                         (cdr except)))))))))))) 
   (return 
    (SPECWARE::reportErrorToJava "" 0 0 (SPECWARE::printException except)))))

(defun SPECWARE::toplevelHandlerForJava (except) 
  (SPECCALC::monadSeq 
   #'SPECCALC::cleanupGlobalContext-1 
   (SPECCALC::monadSeq 
    #'SPECWARE::saveSpecwareState-1 
    (SPECCALC::monadSeq 
     (SPECCALC::|!return| (SPECWARE::reportExceptionToJava except)) 
     (SPECCALC::|!return| nil)))))

(defun SPECWARE::evaluateURI_fromJava (path) 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToCanonicalURI ".") 
           #'(lambda (currentURI) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 currentURI) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                #'(lambda (path_body) 
                   (SPECCALC::monadBind 
                    (SPECCALC::pathToRelativeURI path_body) 
                    #'(lambda (uri) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| 
                         (cons 
                          :|String| 
                          (vector 
                           path 
                           POSITION-SPEC::startLineColumnByte 
                           (POSITION-SPEC::endLineColumnByte path_body)))) 
                        #'(lambda (|!position|) 
                           (SPECCALC::monadSeq 
                            (funcall (SPECCALC::|!catch| 
                                      (SPECCALC::monadSeq 
                                       (funcall (SPECCALC::evaluateURI 
                                                 |!position|) 
                                                uri) 
                                       (SPECCALC::|!return| nil))) 
                                     (SPECWARE::fileNameHandler uri)) 
                            (SPECCALC::monadSeq 
                             #'SPECWARE::saveSpecwareState-1 
                             (SPECCALC::|!return| t))))))))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandlerForJava 
            SPECWARE::ignoredState))) 
      (let ((pV4 (car x))) 
        (block 
         nil 
         (if (eq (car pV4) :|Ok|) 
             (return (cdr pV4)) 
             (if (eq (car pV4) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in evaluateURI_fromJava"))))))

(defun SPECWARE::evaluateURI_fromLisp (path) 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToCanonicalURI ".") 
           #'(lambda (currentURI) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 currentURI) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                #'(lambda (path_body) 
                   (SPECCALC::monadBind 
                    (SPECCALC::pathToRelativeURI path_body) 
                    #'(lambda (uri) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| 
                         (cons 
                          :|String| 
                          (vector 
                           path 
                           POSITION-SPEC::startLineColumnByte 
                           (POSITION-SPEC::endLineColumnByte path_body)))) 
                        #'(lambda (|!position|) 
                           (SPECCALC::monadSeq 
                            (funcall (SPECCALC::|!catch| 
                                      (SPECCALC::monadSeq 
                                       (funcall (SPECCALC::evaluateURI 
                                                 |!position|) 
                                                uri) 
                                       (SPECCALC::|!return| nil))) 
                                     (SPECWARE::fileNameHandler uri)) 
                            (SPECCALC::monadSeq 
                             #'SPECWARE::saveSpecwareState-1 
                             (SPECCALC::|!return| t))))))))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECWARE::ignoredState))) 
      (let ((pV4 (car x))) 
        (block 
         nil 
         (if (eq (car pV4) :|Ok|) 
             (return (cdr pV4)) 
             (if (eq (car pV4) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in evaluateURI_fromLisp"))))))

(defun SPECWARE::evaluateUnitId (path) 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToCanonicalURI ".") 
           #'(lambda (currentURI) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 currentURI) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                #'(lambda (path_body) 
                   (SPECCALC::monadBind 
                    (SPECCALC::pathToRelativeURI path_body) 
                    #'(lambda (uri) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| 
                         (cons 
                          :|String| 
                          (vector 
                           path 
                           POSITION-SPEC::startLineColumnByte 
                           (POSITION-SPEC::endLineColumnByte path_body)))) 
                        #'(lambda (|!position|) 
                           (SPECCALC::monadBind 
                            (funcall (SPECCALC::evaluateURI |!position|) uri) 
                            #'(lambda (x) 
                               (SPECCALC::monadSeq 
                                #'SPECWARE::saveSpecwareState-1 
                                (SPECCALC::|!return| (svref x 0))))))))))))))))) 
    (let ((x (funcall run SPECWARE::ignoredState))) 
      (let ((pV6 (car x))) 
        (block 
         nil 
         (if (eq (car pV6) :|Ok|) 
             (return (cons :|Some| (cdr pV6))) 
             (if (eq (car pV6) :|Exception|) 
                 (return 
                  (progn (SYSTEM-SPEC::|!warn| "evaluateUnitId failed") 
                         '(:|None|))))) 
         (error "Nonexhaustive match failure in evaluateUnitId"))))))

(defun SPECWARE::fileNameHandler-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECWARE::fileNameHandler x1) x2) x3))

(defparameter SPECWARE::initializeSavedSpecwareState 
  (let ((x (SPECWARE::saveSpecwareState-1 SPECCALC::initialSpecwareState))) 
    (let ((pV4 (car x))) 
      (block 
       nil 
       (if (eq (car pV4) :|Ok|) 
           (return (STRING-SPEC::toScreen "Initializing Specware state ...")) 
           (if (eq (car pV4) :|Exception|) 
               (return (SYSTEM-SPEC::fail "initializeSavedSpecwareState failed")))) 
       (error "Nonexhaustive match failure in initializeSavedSpecwareState")))))

(defun SPECWARE::listLoadedUnits () 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           #'SPECCALC::getGlobalContext-1 
           #'(lambda (globalContext) 
              (SPECCALC::monadBind 
               (SPECCALC::|!return| 
                (POLYMAP::foldMap-1-1-1 
                 #'(lambda (lst) 
                    #'(lambda (dom) 
                       #'(lambda (pV1) (declare (ignore pV1)) 
                                       (cons dom lst)))) 
                 nil 
                 globalContext)) 
               #'(lambda (uriList) 
                  (SPECCALC::monadSeq 
                   (SPECCALC::|!print| 
                    (WADLERLINDIG::ppFormat 
                     (WADLERLINDIG::ppSep-1-1 
                      WADLERLINDIG::ppNewline 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (uri) 
                          (WADLERLINDIG::ppString (SPECCALC::uriToString-1 uri))) 
                       uriList)))) 
                   (SPECCALC::monadSeq 
                    #'SPECWARE::saveSpecwareState-1 
                    (SPECCALC::|!return| t)))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECWARE::ignoredState))) 
      (let ((pV5 (car x))) 
        (block 
         nil 
         (if (eq (car pV5) :|Ok|) 
             (return (cdr pV5)) 
             (if (eq (car pV5) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in listLoadedUnits"))))))

(defun SPECWARE::listLoadedUnits-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECWARE::listLoadedUnits))

(defun SPECWARE::maybeAddSuffix (x1) 
  #'(lambda (x2) (SPECWARE::maybeAddSuffix-1-1 x1 x2)))

(defun SPECWARE::reportErrorAtPosToJava-1 (x) 
  (SPECWARE::reportErrorAtPosToJava (car x) (cdr x)))

(defun SPECWARE::toplevelLoop (x2 x1 x0 x) 
  (SPECCALC::|!return|-1-1 t (vector x2 x1 x0 x)))

(defun SPECWARE::toplevelLoop-1 (x) 
  (SPECWARE::toplevelLoop (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun SPECWARE::runSpecware () 
  (let ((x 
         (SPECCALC::|!catch|-1-1-1 
          #'SPECWARE::toplevelLoop-1 
          #'SPECWARE::toplevelHandler 
          SPECCALC::initialSpecwareState))) 
    (let ((pV4 (car x))) 
      (block 
       nil 
       (if (eq (car pV4) :|Ok|) 
           (return 
            (SYSTEM-SPEC::fail "Specware toplevel loop terminated unexpectedly")) 
           (if (eq (car pV4) :|Exception|) 
               (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
       (error "Nonexhaustive match failure in runSpecware")))))

(defun SPECWARE::runSpecware-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECWARE::runSpecware))

(defun SPECWARE::runSpecwareURI (path) 
  (let ((run 
         (SPECCALC::monadBind 
          (SPECCALC::pathToCanonicalURI ".") 
          #'(lambda (currentURI) 
             (SPECCALC::monadSeq 
              (SPECCALC::setCurrentURI-1 currentURI) 
              (SPECCALC::monadBind 
               (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
               #'(lambda (path_body) 
                  (SPECCALC::monadBind 
                   (SPECCALC::pathToRelativeURI path_body) 
                   #'(lambda (uri) 
                      (SPECCALC::monadBind 
                       (SPECCALC::|!return| 
                        (cons 
                         :|String| 
                         (vector 
                          path 
                          POSITION-SPEC::startLineColumnByte 
                          (POSITION-SPEC::endLineColumnByte path_body)))) 
                       #'(lambda (|!position|) 
                          (SPECCALC::monadSeq 
                           (funcall (SPECCALC::evaluateURI |!position|) uri) 
                           (SPECCALC::|!return| t))))))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECCALC::initialSpecwareState))) 
      (let ((pV4 (car x))) 
        (block 
         nil 
         (if (eq (car pV4) :|Ok|) 
             (return (cdr pV4)) 
             (if (eq (car pV4) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in runSpecwareURI"))))))

(defun SPECWARE::toplevelHandler-1-1 (x1 x2) 
  (funcall (SPECWARE::toplevelHandler x1) x2))

(defun SPECWARE::toplevelHandlerForJava-1-1 (x1 x2) 
  (funcall (SPECWARE::toplevelHandlerForJava x1) x2))

(defun SPLAYMAP::all-1-1 (p? m) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (cl:and (svref x 2) (funcall p? (cons (svref x 0) (svref x 1))))) 
   t 
   m))

(defun SPLAYMAP::all (x1) #'(lambda (x2) (SPLAYMAP::all-1-1 x1 x2)))

(defun SPLAYMAP::ap (x1) #'(lambda (x2) (SPLAYMAP::ap-1-1 x1 x2)))

(defun SPLAYMAP::api (x1) #'(lambda (x2) (SPLAYMAP::api-1-1 x1 x2)))

(defun SPLAYMAP::app (x1) #'(lambda (x2) (SPLAYMAP::app-1-1 x1 x2)))

(defun SPLAYMAP::|!apply| (x1) 
  #'(lambda (x2) (SPLAYMAP::|!apply|-1-1 x1 x2)))

(defun SPLAYMAP::applyi (x1) #'(lambda (x2) (SPLAYMAP::applyi-1-1 x1 x2)))

(defun SPLAYMAP::compOf (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return (cdr |!map|)) 
       (if (eq (car |!map|) :|MAP|) (return (svref (cdr |!map|) 0)))) 
   (error "Nonexhaustive match failure in compOf")))

(defun SPLAYMAP::compOf-1-1 (x1 x2) (funcall (SPLAYMAP::compOf x1) x2))

(defun SPLAYMAP::left (sp |!rest|) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return |!rest|) 
       (if (eq (car sp) :|SplayObj|) 
           (return 
            (SPLAYMAP::left (svref (cdr sp) 0) (LIST-SPEC::|!cons| sp |!rest|))))) 
   (error "Nonexhaustive match failure in left")))

(defun SPLAYMAP::next (splays) 
  (block 
   nil 
   (if (consp splays) 
       (let ((pV4 (car splays))) 
         (if (eq (car pV4) :|SplayObj|) 
             (return 
              (cons pV4 (SPLAYMAP::left (svref (cdr pV4) 1) (cdr splays))))))) 
   (return (cons '(:|SplayNil|) nil))))

(defun SPLAYMAP::compare-1-1 (cmpRng x) 
  (let ((map1 (car x))
        (map2 (cdr x))) 
    (block 
     nil 
     (if (eq (car map1) :|EMPTY|) 
         (progn (if (eq (car map2) :|EMPTY|) (return '(:|Equal|))) 
                (return '(:|Less|)))) 
     (if (eq (car map2) :|EMPTY|) (return '(:|Greater|))) 
     (if (eq (car map1) :|MAP|) 
         (let ((pV45 (cdr map1))) 
           (let ((pV46 (svref pV45 0))
                 (pV48 (svref pV45 2))) 
             (if (eq (car map2) :|MAP|) 
                 (let ((pV52 (svref (cdr map2) 2))) 
                   (return 
                    (labels 
                      ((cmp (t1 t2) 
                        (let ((pV19 (SPLAYMAP::next t1))
                              (pV20 (SPLAYMAP::next t2))) 
                          (block 
                           nil 
                           (if (eq (car (car pV19)) :|SplayNil|) 
                               (progn (if (eq (car (car pV20)) :|SplayNil|) 
                                          (return '(:|Equal|))) 
                                      (return '(:|Less|)))) 
                           (if (eq (car (car pV20)) :|SplayNil|) 
                               (return '(:|Greater|))) 
                           (let ((pV21 (car pV19))) 
                             (if (eq (car pV21) :|SplayObj|) 
                                 (let ((pV26 (svref (cdr pV21) 2))) 
                                   (let ((pV29 (car pV20))) 
                                     (if (eq (car pV29) :|SplayObj|) 
                                         (let ((pV34 (svref (cdr pV29) 2))) 
                                           (return 
                                            (let ((pV18 
                                                   (funcall pV46 
                                                            (cons 
                                                             (car pV26) 
                                                             (car pV34))))) 
                                              (block 
                                               nil 
                                               (if (eq (car pV18) :|Equal|) 
                                                   (return 
                                                    (let ((pV17 
                                                           (funcall cmpRng 
                                                                    (cons 
                                                                     (cdr pV26) 
                                                                     (cdr pV34))))) 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV17) 
                                                            :|Equal|) 
                                                           (return 
                                                            (cmp 
                                                             (cdr pV19) 
                                                             (cdr pV20)))) 
                                                       (return pV17))))) 
                                               (return pV18)))))))))) 
                           (error "Nonexhaustive match failure in compare"))))) 
                      (cmp 
                       (SPLAYMAP::left (STATE::|!!| pV48) nil) 
                       (SPLAYMAP::left (STATE::|!!| pV52) nil))))))))) 
     (error "Nonexhaustive match failure in compare"))))

(defun SPLAYMAP::compare (x1) #'(lambda (x2) (SPLAYMAP::compare-1-1 x1 x2)))

(defun SPLAYMAP::compose-1 (x) (SPLAYMAP::compose (car x) (cdr x)))

(defun SPLAYMAP::|!exists|-1-1 (p? m) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (cl:or (svref x 2) (funcall p? (cons (svref x 0) (svref x 1))))) 
   nil 
   m))

(defun SPLAYMAP::|!exists| (x1) 
  #'(lambda (x2) (SPLAYMAP::|!exists|-1-1 x1 x2)))

(defun SPLAYMAP::filter-1-1 (predFn m) 
  (labels 
    ((f (key item m) (if (funcall predFn item) (SPLAYMAP::insert m key item) m))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (f (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))

(defun SPLAYMAP::filter (x1) #'(lambda (x2) (SPLAYMAP::filter-1-1 x1 x2)))

(defun SPLAYMAP::filteri-1-1 (predFn m) 
  (labels 
    ((f (key item m) 
      (if (funcall predFn (cons key item)) (SPLAYMAP::insert m key item) m))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (f (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))

(defun SPLAYMAP::filteri (x1) #'(lambda (x2) (SPLAYMAP::filteri-1-1 x1 x2)))

(defun SPLAYMAP::|!find|-1 (x) (SPLAYMAP::|!find| (car x) (cdr x)))

(defun SPLAYMAP::findR-1 (x) 
  (SPLAYMAP::findR (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYMAP::foldlAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV2 (cdr sp))) 
               (return 
                (SPLAYMAP::foldlAp-1-1 
                 abf 
                 (cons 
                  (svref pV2 1) 
                  (funcall abf 
                           (cons 
                            (cdr (svref pV2 2)) 
                            (SPLAYMAP::foldlAp-1-1 abf (cons (svref pV2 0) b)))))))))) 
     (error "Nonexhaustive match failure in foldlAp"))))

(defun SPLAYMAP::foldl-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldlAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldl")))

(defun SPLAYMAP::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldl-1-1-1 x1 x2 x3))))

(defun SPLAYMAP::foldlAp (x1) #'(lambda (x2) (SPLAYMAP::foldlAp-1-1 x1 x2)))

(defun SPLAYMAP::foldli (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldli-1-1-1 x1 x2 x3))))

(defun SPLAYMAP::foldliAp (x1) 
  #'(lambda (x2) (SPLAYMAP::foldliAp-1-1 x1 x2)))

(defun SPLAYMAP::foldrAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV2 (cdr sp))) 
               (return 
                (SPLAYMAP::foldrAp-1-1 
                 abf 
                 (cons 
                  (svref pV2 0) 
                  (funcall abf 
                           (cons 
                            (cdr (svref pV2 2)) 
                            (SPLAYMAP::foldrAp-1-1 abf (cons (svref pV2 1) b)))))))))) 
     (error "Nonexhaustive match failure in foldrAp"))))

(defun SPLAYMAP::foldr-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldrAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldr")))

(defun SPLAYMAP::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldr-1-1-1 x1 x2 x3))))

(defun SPLAYMAP::foldrAp (x1) #'(lambda (x2) (SPLAYMAP::foldrAp-1-1 x1 x2)))

(defun SPLAYMAP::foldriAp (x1) 
  #'(lambda (x2) (SPLAYMAP::foldriAp-1-1 x1 x2)))

(defun SPLAYMAP::fromList-1-1 (comp l) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (let ((pV1 (car x))) 
        (block 
         nil 
         (return (SPLAYMAP::insert (cdr x) (car pV1) (cdr pV1))) 
         (error "Nonexhaustive match failure in fromList")))) 
   (SPLAYMAP::empty comp) 
   l))

(defun SPLAYMAP::fromList (x1) 
  #'(lambda (x2) (SPLAYMAP::fromList-1-1 x1 x2)))

(defun SPLAYMAP::inDomain-1 (x) (SPLAYMAP::inDomain (car x) (cdr x)))

(defun SPLAYMAP::insert-1 (x) 
  (SPLAYMAP::insert (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYMAP::intersectWith-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((intersect (f) 
        #'(lambda (x1) 
           (let ((|!m1| (car x1))
                 (|!m2| (cdr x1))) 
             (labels 
               ((ins (key x11 m) 
                 (let ((pV1 (SPLAYMAP::|!find| |!m2| key))) 
                   (block 
                    nil 
                    (if (eq (car pV1) :|None|) 
                        (return m) 
                        (if (eq (car pV1) :|Some|) 
                            (return 
                             (SPLAYMAP::insert 
                              m 
                              key 
                              (funcall f (cons x11 (cdr pV1))))))) 
                    (error "Nonexhaustive match failure in intersectWith"))))) 
               (SPLAYMAP::foldli-1-1-1 
                #'(lambda (x11) (ins (svref x11 0) (svref x11 1) (svref x11 2))) 
                (SPLAYMAP::empty (SPLAYMAP::compOf |!m1|)) 
                |!m1|)))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (funcall (intersect f) (cons |!m1| |!m2|)) 
          (funcall (intersect 
                    #'(lambda (x1) (funcall f (cons (cdr x1) (car x1))))) 
                   (cons |!m2| |!m1|))))))

(defun SPLAYMAP::intersectWith (x1) 
  #'(lambda (x2) (SPLAYMAP::intersectWith-1-1 x1 x2)))

(defun SPLAYMAP::intersectWithi-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((intersect (f) 
        #'(lambda (x1) 
           (let ((|!m1| (car x1))
                 (|!m2| (cdr x1))) 
             (labels 
               ((ins (key x11 m) 
                 (let ((pV1 (SPLAYMAP::|!find| |!m2| key))) 
                   (block 
                    nil 
                    (if (eq (car pV1) :|None|) 
                        (return m) 
                        (if (eq (car pV1) :|Some|) 
                            (return 
                             (SPLAYMAP::insert 
                              m 
                              key 
                              (funcall f (vector key x11 (cdr pV1))))))) 
                    (error "Nonexhaustive match failure in intersectWithi"))))) 
               (SPLAYMAP::foldli-1-1-1 
                #'(lambda (x11) (ins (svref x11 0) (svref x11 1) (svref x11 2))) 
                (SPLAYMAP::empty (SPLAYMAP::compOf |!m1|)) 
                |!m1|)))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (funcall (intersect f) (cons |!m1| |!m2|)) 
          (funcall (intersect 
                    #'(lambda (x1) 
                       (funcall f 
                                (vector (svref x1 0) (svref x1 2) (svref x1 1))))) 
                   (cons |!m2| |!m1|))))))

(defun SPLAYMAP::intersectWithi (x1) 
  #'(lambda (x2) (SPLAYMAP::intersectWithi-1-1 x1 x2)))

(defun SPLAYMAP::left-1 (x) (SPLAYMAP::left (car x) (cdr x)))

(defun SPLAYMAP::listItemsf-1 (x) 
  (SPLAYMAP::listItemsf (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYMAP::listItemsi (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::listItemsf 
             #'(lambda (v) v) 
             (STATE::|!!| (svref (cdr |!map|) 2)) 
             nil)))) 
   (error "Nonexhaustive match failure in listItemsi")))

(defun SPLAYMAP::mapPartial-1-1 (f m) 
  (labels 
    ((g (key item m) 
      (let ((pV1 (funcall f item))) 
        (block 
         nil 
         (if (eq (car pV1) :|None|) 
             (return m) 
             (if (eq (car pV1) :|Some|) 
                 (return (SPLAYMAP::insert m key (cdr pV1))))) 
         (error "Nonexhaustive match failure in mapPartial"))))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (g (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))

(defun SPLAYMAP::mapPartial (x1) 
  #'(lambda (x2) (SPLAYMAP::mapPartial-1-1 x1 x2)))

(defun SPLAYMAP::mapPartiali-1-1 (f m) 
  (labels 
    ((g (key item m) 
      (let ((pV1 (funcall f (cons key item)))) 
        (block 
         nil 
         (if (eq (car pV1) :|None|) 
             (return m) 
             (if (eq (car pV1) :|Some|) 
                 (return (SPLAYMAP::insert m key (cdr pV1))))) 
         (error "Nonexhaustive match failure in mapPartiali"))))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (g (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))

(defun SPLAYMAP::mapPartiali (x1) 
  #'(lambda (x2) (SPLAYMAP::mapPartiali-1-1 x1 x2)))

(defun SPLAYMAP::|!remove| (|!map| key) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return |!map|) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV14 (cdr |!map|))) 
             (let ((pV18 (svref pV14 2))
                   (pV17 (svref pV14 1))
                   (pV16 (svref pV14 0))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        #'(lambda (x) (funcall pV16 (cons (car x) key))) 
                        (STATE::|!!| pV18)))) 
                  (let ((pV5 (cdr x))) 
                    (block 
                     nil 
                     (if (eq (car (car x)) :|Equal|) 
                         (if (eq (car pV5) :|SplayObj|) 
                             (let ((pV6 (cdr pV5))) 
                               (return 
                                (if ( =  pV17 1) 
                                    (cons :|EMPTY| pV16) 
                                    (cons 
                                     :|MAP| 
                                     (vector 
                                      pV16 
                                      (INTEGER-SPEC::|!-| pV17 1) 
                                      (cons 
                                       :|Ref| 
                                       (SPLAYTREE::join 
                                        (svref pV6 0) 
                                        (svref pV6 1)))))))))) 
                     (return (progn (STATE::|:=| pV18 pV5) |!map|)) 
                     (error "Nonexhaustive match failure in remove"))))))))) 
   (error "Nonexhaustive match failure in remove")))

(defun SPLAYMAP::|!remove|-1 (x) (SPLAYMAP::|!remove| (car x) (cdr x)))

(defun SPLAYMAP::subset? (|!m1| |!m2|) 
  (SPLAYMAP::all-1-1 
   #'(lambda (x) 
      (let ((pV1 (SPLAYMAP::|!find| |!m2| (car x)))) 
        (block 
         nil 
         (if (eq (car pV1) :|None|) 
             (return nil) 
             (if (eq (car pV1) :|Some|) 
                 (return (slang-built-in::slang-term-equals (cdr x) (cdr pV1))))) 
         (error "Nonexhaustive match failure in subset?")))) 
   |!m1|))

(defun SPLAYMAP::subset?-1 (x) (SPLAYMAP::subset? (car x) (cdr x)))

(defun SPLAYMAP::toList (x) (SPLAYMAP::listItemsi x))

(defun SPLAYMAP::unionWith-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((ins (f) 
        #'(lambda (x1) 
           (let ((key (svref x1 0))
                 (x11 (svref x1 1))
                 (m (svref x1 2))) 
             (let ((pV1 (SPLAYMAP::|!find| m key))) 
               (block 
                nil 
                (if (eq (car pV1) :|None|) 
                    (return (SPLAYMAP::insert m key x11)) 
                    (if (eq (car pV1) :|Some|) 
                        (return 
                         (SPLAYMAP::insert 
                          m 
                          key 
                          (funcall f (cons x11 (cdr pV1))))))) 
                (error "Nonexhaustive match failure in unionWith"))))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (SPLAYMAP::foldli-1-1-1 
           (ins #'(lambda (x1) (funcall f (cons (cdr x1) (car x1))))) 
           |!m1| 
           |!m2|) 
          (SPLAYMAP::foldli-1-1-1 (ins f) |!m2| |!m1|)))))

(defun SPLAYMAP::unionWith (x1) 
  #'(lambda (x2) (SPLAYMAP::unionWith-1-1 x1 x2)))

(defun SPLAYMAP::unionWithi-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((ins (f) 
        #'(lambda (x1) 
           (let ((key (svref x1 0))
                 (x11 (svref x1 1))
                 (m (svref x1 2))) 
             (let ((pV1 (SPLAYMAP::|!find| m key))) 
               (block 
                nil 
                (if (eq (car pV1) :|None|) 
                    (return (SPLAYMAP::insert m key x11)) 
                    (if (eq (car pV1) :|Some|) 
                        (return 
                         (SPLAYMAP::insert 
                          m 
                          key 
                          (funcall f (vector key x11 (cdr pV1))))))) 
                (error "Nonexhaustive match failure in unionWithi"))))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (SPLAYMAP::foldli-1-1-1 
           (ins 
            #'(lambda (x1) 
               (funcall f (vector (svref x1 0) (svref x1 2) (svref x1 1))))) 
           |!m1| 
           |!m2|) 
          (SPLAYMAP::foldli-1-1-1 (ins f) |!m2| |!m1|)))))

(defun SPLAYMAP::unionWithi (x1) 
  #'(lambda (x2) (SPLAYMAP::unionWithi-1-1 x1 x2)))

(defun SPLAYSET::add-1 (x) (SPLAYSET::add (car x) (cdr x)))

(defun SPLAYSET::addList-1 (x) (SPLAYSET::addList (car x) (cdr x)))

(defun SPLAYSET::add_ (s x) (SPLAYSET::add x s))

(defun SPLAYSET::add_-1 (x) (SPLAYSET::add_ (car x) (cdr x)))

(defun SPLAYSET::appSplay (x1) 
  #'(lambda (x2) (SPLAYSET::appSplay-1-1 x1 x2)))

(defun SPLAYSET::left (sp |!rest|) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) (return |!rest|)) 
   (if (eq (car sp) :|SplayObj|) 
       (return 
        (SPLAYSET::left (svref (cdr sp) 0) (LIST-SPEC::|!cons| sp |!rest|)))) 
   (error "Nonexhaustive match failure in left")))

(defun SPLAYSET::next (splays) 
  (block 
   nil 
   (if (consp splays) 
       (let ((pV4 (car splays))) 
         (if (eq (car pV4) :|SplayObj|) 
             (return 
              (cons pV4 (SPLAYSET::left (svref (cdr pV4) 1) (cdr splays))))))) 
   (return (cons '(:|SplayNil|) nil))))

(defun SPLAYSET::cmp (comp t1 t2) 
  (let ((pV9 (SPLAYSET::next t2))
        (pV8 (SPLAYSET::next t1))) 
    (block 
     nil 
     (if (eq (car (car pV8)) :|SplayNil|) 
         (progn (if (eq (car (car pV9)) :|SplayNil|) (return '(:|Equal|))) 
                (return '(:|Less|)))) 
     (if (eq (car (car pV9)) :|SplayNil|) (return '(:|Greater|))) 
     (let ((pV10 (car pV8))) 
       (if (eq (car pV10) :|SplayObj|) 
           (let ((pV13 (car pV9))) 
             (if (eq (car pV13) :|SplayObj|) 
                 (return 
                  (let ((pV7 
                         (funcall comp 
                                  (cons 
                                   (svref (cdr pV10) 2) 
                                   (svref (cdr pV13) 2))))) 
                    (block 
                     nil 
                     (if (eq (car pV7) :|Equal|) 
                         (return (SPLAYSET::cmp comp (cdr pV8) (cdr pV9)))) 
                     (return pV7)))))))) 
     (error "Nonexhaustive match failure in cmp"))))

(defun SPLAYSET::cmp-1 (x) (SPLAYSET::cmp (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYSET::compOf (|!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return (cdr |!set|)) 
       (if (eq (car |!set|) :|SET|) (return (svref (cdr |!set|) 0)))) 
   (error "Nonexhaustive match failure in compOf")))

(defun SPLAYSET::compOf-1-1 (x1 x2) (funcall (SPLAYSET::compOf x1) x2))

(defun SPLAYSET::compare (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) 
       (progn (if (eq (car set2) :|EMPTY|) (return '(:|Equal|))) 
              (return '(:|Less|)))) 
   (if (eq (car set2) :|EMPTY|) (return '(:|Greater|))) 
   (if (eq (car set1) :|SET|) 
       (let ((pV9 (cdr set1))) 
         (if (eq (car set2) :|SET|) 
             (return 
              (SPLAYSET::cmp 
               (svref pV9 0) 
               (SPLAYSET::left (STATE::|!!| (svref pV9 2)) nil) 
               (SPLAYSET::left (STATE::|!!| (svref (cdr set2) 2)) nil)))))) 
   (error "Nonexhaustive match failure in compare")))

(defun SPLAYSET::compare-1 (x) (SPLAYSET::compare (car x) (cdr x)))

(defun SPLAYSET::|!count|-1 (x) (SPLAYSET::|!count| (car x) (cdr x)))

(defun SPLAYSET::|!delete|-1 (x) (SPLAYSET::|!delete| (car x) (cdr x)))

(defun SPLAYSET::diffSplay-1 (x) 
  (SPLAYSET::diffSplay (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYSET::difference-1 (x) (SPLAYSET::difference (car x) (cdr x)))

(defun SPLAYSET::|!equal|-1 (x) (SPLAYSET::|!equal| (car x) (cdr x)))

(defun SPLAYSET::existsSplay (x1) 
  #'(lambda (x2) (SPLAYSET::existsSplay-1-1 x1 x2)))

(defun SPLAYSET::filterSplay (x1) 
  #'(lambda (x2) (SPLAYSET::filterSplay-1-1 x1 x2)))

(defun SPLAYSET::findSplay (x1) 
  #'(lambda (x2) (SPLAYSET::findSplay-1-1 x1 x2)))

(defun SPLAYSET::foldlSplay (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldlSplay-1-1-1 x1 x2 x3))))

(defun SPLAYSET::foldrSplay (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldrSplay-1-1-1 x1 x2 x3))))

(defun SPLAYSET::|!intersection|-1 (x) 
  (SPLAYSET::|!intersection| (car x) (cdr x)))

(defun SPLAYSET::intersectionSplay-1 (x) 
  (SPLAYSET::intersectionSplay (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYSET::isSubset (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|SET|) 
       (let ((pV7 (cdr set1))) 
         (if (eq (car set2) :|SET|) 
             (let ((pV11 (cdr set2))) 
               (return 
                (cl:and 
                 (INTEGER-SPEC::|!<=| (svref pV7 1) (svref pV11 1)) 
                 (SPLAYSET::treeIn 
                  (svref pV7 0) 
                  (STATE::|!!| (svref pV7 2)) 
                  (STATE::|!!| (svref pV11 2)))))))) 
       (if (eq (car set1) :|EMPTY|) (return t))) 
   (return nil)))

(defun SPLAYSET::isSubset-1 (x) (SPLAYSET::isSubset (car x) (cdr x)))

(defun SPLAYSET::left-1 (x) (SPLAYSET::left (car x) (cdr x)))

(defun SPLAYSET::listItemsApp-1 (x) (SPLAYSET::listItemsApp (car x) (cdr x)))

(defun SPLAYSET::mapf-1 (x) 
  (SPLAYSET::mapf (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYSET::|!member|-1 (x) (SPLAYSET::|!member| (car x) (cdr x)))

(defun SPLAYSET::memberT-1 (x) 
  (SPLAYSET::memberT (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYSET::singleton-1 (x) (SPLAYSET::singleton (car x) (cdr x)))

(defun SPLAYSET::split-1 (x) 
  (SPLAYSET::split (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYSET::treeIn-1 (x) 
  (SPLAYSET::treeIn (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYSET::|!union|-1 (x) (SPLAYSET::|!union| (car x) (cdr x)))

(defun SPLAYSET::unionSplay-1 (x) 
  (SPLAYSET::unionSplay (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYTREE::adj (x1) #'(lambda (x2) (SPLAYTREE::adj-1-1 x1 x2)))

(defun SPLAYTREE::join-1 (x) (SPLAYTREE::join (car x) (cdr x)))

(defun SPLAYTREE::mkSplayObj-1 (x) 
  (SPLAYTREE::mkSplayObj (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYTREE::splay-1 (x) (SPLAYTREE::splay (car x) (cdr x)))

(defparameter SPLAYTREE::splayEmpty '(:|SplayNil|))

(defun SPLAYTREE::splayJoin (x0 x) (SPLAYTREE::join x0 x))

(defun SPLAYTREE::splayJoin-1 (x) (SPLAYTREE::splayJoin (car x) (cdr x)))

(defun SPLAYTREE::splayNode (a l r) (cons :|SplayObj| (vector l r a)))

(defun SPLAYTREE::splayNode-1 (x) 
  (SPLAYTREE::splayNode (svref x 0) (svref x 1) (svref x 2)))

(defun SPLAYTREE::splaySingleton (a) 
  (SPLAYTREE::splayNode a SPLAYTREE::splayEmpty SPLAYTREE::splayEmpty))

(defun STANDARDSPEC::findAllOps-1 (x) 
  (STANDARDSPEC::findAllOps (car x) (cdr x)))

(defun STANDARDSPEC::findAllSorts-1 (x) 
  (STANDARDSPEC::findAllSorts (car x) (cdr x)))

(defun STANDARDSPEC::findTheOp-1 (x) (STANDARDSPEC::findTheOp (car x) (cdr x)))

(defun STANDARDSPEC::findTheSort-1 (x) 
  (STANDARDSPEC::findTheSort (car x) (cdr x)))

(defparameter STANDARDSPEC::iffOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "<=>")) 
   (cons '(:|Right|) 12) 
   STANDARDSPEC::binaryBoolSort))

(defun STANDARDSPEC::mkAnd-1 (x) (STANDARDSPEC::mkAnd (car x) (cdr x)))

(defun STANDARDSPEC::mkAppl-1 (x) (STANDARDSPEC::mkAppl (car x) (cdr x)))

(defun STANDARDSPEC::mkApplication-1 (x) 
  (STANDARDSPEC::mkApplication (car x) (cdr x)))

(defun STANDARDSPEC::mkApply-1 (x) (STANDARDSPEC::mkApply (car x) (cdr x)))

(defun STANDARDSPEC::mkArrow-1 (x) (STANDARDSPEC::mkArrow (car x) (cdr x)))

(defun STANDARDSPEC::mkBase-1 (x) (STANDARDSPEC::mkBase (car x) (cdr x)))

(defun STANDARDSPEC::mkBind-1 (x) 
  (STANDARDSPEC::mkBind (svref x 0) (svref x 1) (svref x 2)))

(defun STANDARDSPEC::mkBoolPat (b) 
  (cons :|BoolPat| (cons b POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkCharPat (c) 
  (cons :|CharPat| (cons c POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkChoose (srt equiv) 
  (STANDARDSPEC::mkFun 
   '(:|Choose|) 
   (STANDARDSPEC::mkArrow (STANDARDSPEC::mkQuotientSort srt equiv) srt)))

(defun STANDARDSPEC::mkChoice (term equiv srt) 
  (STANDARDSPEC::mkApply (STANDARDSPEC::mkChoose srt equiv) term))

(defun STANDARDSPEC::mkChoice-1 (x) 
  (STANDARDSPEC::mkChoice (svref x 0) (svref x 1) (svref x 2)))

(defun STANDARDSPEC::mkChoose-1 (x) (STANDARDSPEC::mkChoose (car x) (cdr x)))

(defun STANDARDSPEC::mkChooseFun-1 (x) 
  (STANDARDSPEC::mkChooseFun (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun STANDARDSPEC::mkCoProduct (fields) 
  (cons :|CoProduct| (cons fields POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkConj (cjs) 
  (block 
   nil 
   (if (null cjs) 
       (return (STANDARDSPEC::mkTrue)) 
       (if (consp cjs) 
           (let ((pV4 (cdr cjs))
                 (pV3 (car cjs))) 
             (progn (if (null pV4) (return pV3)) 
                    (return (STANDARDSPEC::mkAnd pV3 (STANDARDSPEC::mkConj pV4))))))) 
   (error "Nonexhaustive match failure in mkConj")))

(defun STANDARDSPEC::mkEmbed0 (id srt) 
  (STANDARDSPEC::mkFun (cons :|Embed| (cons id nil)) srt))

(defun STANDARDSPEC::mkEmbed0-1 (x) (STANDARDSPEC::mkEmbed0 (car x) (cdr x)))

(defun STANDARDSPEC::mkEmbed1 (id srt) 
  (STANDARDSPEC::mkFun (cons :|Embed| (cons id t)) srt))

(defun STANDARDSPEC::mkEmbed1-1 (x) (STANDARDSPEC::mkEmbed1 (car x) (cdr x)))

(defun STANDARDSPEC::mkEmbedded-1 (x) 
  (STANDARDSPEC::mkEmbedded (car x) (cdr x)))

(defun STANDARDSPEC::mkEquality-1 (x) 
  (STANDARDSPEC::mkEquality (svref x 0) (svref x 1) (svref x 2)))

(defun STANDARDSPEC::mkFalse-1 (ignore) 
  (declare (ignore ignore)) 
  (STANDARDSPEC::mkFalse))

(defun STANDARDSPEC::mkFun-1 (x) (STANDARDSPEC::mkFun (car x) (cdr x)))

(defun STANDARDSPEC::mkIfThenElse-1 (x) 
  (STANDARDSPEC::mkIfThenElse (svref x 0) (svref x 1) (svref x 2)))

(defun STANDARDSPEC::mkIff (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::iffOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))

(defun STANDARDSPEC::mkIff-1 (x) (STANDARDSPEC::mkIff (car x) (cdr x)))

(defun STANDARDSPEC::mkImplies-1 (x) (STANDARDSPEC::mkImplies (car x) (cdr x)))

(defun STANDARDSPEC::mkInfixOp-1 (x) 
  (STANDARDSPEC::mkInfixOp (svref x 0) (svref x 1) (svref x 2)))

(defun STANDARDSPEC::mkLambda-1 (x) (STANDARDSPEC::mkLambda (car x) (cdr x)))

(defun STANDARDSPEC::mkLet-1 (x) (STANDARDSPEC::mkLet (car x) (cdr x)))

(defun STANDARDSPEC::mkLetRec-1 (x) (STANDARDSPEC::mkLetRec (car x) (cdr x)))

(defun STANDARDSPEC::mkNatPat (n) 
  (cons :|NatPat| (cons n POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkOp-1 (x) (STANDARDSPEC::mkOp (car x) (cdr x)))

(defun STANDARDSPEC::mkOr-1 (x) (STANDARDSPEC::mkOr (car x) (cdr x)))

(defun STANDARDSPEC::mkOrs (cjs) 
  (block 
   nil 
   (if (null cjs) 
       (return (STANDARDSPEC::mkTrue)) 
       (if (consp cjs) 
           (let ((pV4 (cdr cjs))
                 (pV3 (car cjs))) 
             (progn (if (null pV4) (return pV3)) 
                    (return (STANDARDSPEC::mkOr pV3 (STANDARDSPEC::mkOrs pV4))))))) 
   (error "Nonexhaustive match failure in mkOrs")))

(defun STANDARDSPEC::mkProject (id super sub) 
  (STANDARDSPEC::mkFun (cons :|Project| id) (STANDARDSPEC::mkArrow super sub)))

(defun STANDARDSPEC::mkProject-1 (x) 
  (STANDARDSPEC::mkProject (svref x 0) (svref x 1) (svref x 2)))

(defun STANDARDSPEC::mkProjection (id term) 
  (let ((super_sort (METASLANG::termSort term))) 
    (block 
     nil 
     (if (eq (car super_sort) :|Product|) 
         (return 
          (let ((pV4 
                 (LIST-SPEC::|!find|-1-1 
                  #'(lambda (x) (string=  id (car x))) 
                  (car (cdr super_sort))))) 
            (block 
             nil 
             (if (eq (car pV4) :|Some|) 
                 (return 
                  (STANDARDSPEC::mkApply 
                   (STANDARDSPEC::mkProject id super_sort (cdr (cdr pV4))) 
                   term))) 
             (return (SYSTEM-SPEC::fail "Projection index not found in product")))))) 
     (return (SYSTEM-SPEC::fail "Product sort expected for mkProjectTerm")))))

(defun STANDARDSPEC::mkProjection-1 (x) 
  (STANDARDSPEC::mkProjection (car x) (cdr x)))

(defun STANDARDSPEC::mkQuotientSort-1 (x) 
  (STANDARDSPEC::mkQuotientSort (car x) (cdr x)))

(defun STANDARDSPEC::mkRelax-1 (x) (STANDARDSPEC::mkRelax (car x) (cdr x)))

(defun STANDARDSPEC::mkRestrict-1 (x) 
  (STANDARDSPEC::mkRestrict (car x) (cdr x)))

(defun STANDARDSPEC::mkRestriction-1 (x) 
  (STANDARDSPEC::mkRestriction (car x) (cdr x)))

(defun STANDARDSPEC::mkSelect (id super field) 
  (STANDARDSPEC::mkFun (cons :|Project| id) (STANDARDSPEC::mkArrow super field)))


(defun STANDARDSPEC::mkSelect-1 (x) 
  (STANDARDSPEC::mkSelect (svref x 0) (svref x 1) (svref x 2)))

(defun STANDARDSPEC::mkSelection (id term) 
  (let ((srt (METASLANG::termSort term))) 
    (block 
     nil 
     (if (eq (car srt) :|CoProduct|) 
         (return 
          (let ((pV4 
                 (LIST-SPEC::|!find|-1-1 
                  #'(lambda (x) (string=  id (car x))) 
                  (car (cdr srt))))) 
            (block 
             nil 
             (if (eq (car pV4) :|Some|) 
                 (let ((pV7 (cdr (cdr pV4)))) 
                   (if (eq (car pV7) :|Some|) 
                       (return 
                        (STANDARDSPEC::mkApply 
                         (STANDARDSPEC::mkSelect id srt (cdr pV7)) 
                         term))))) 
             (return (SYSTEM-SPEC::fail "Selection index not found in product")))))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        "CoProduct sort expected for mkSelectTerm " 
        (SYSTEM-SPEC::toString srt)))))))

(defun STANDARDSPEC::mkSelection-1 (x) 
  (STANDARDSPEC::mkSelection (car x) (cdr x)))

(defun STANDARDSPEC::mkStringPat (s) 
  (cons :|StringPat| (cons s POSITION-SPEC::noPos)))

(defun STANDARDSPEC::mkSubsort-1 (x) (STANDARDSPEC::mkSubsort (car x) (cdr x)))

(defun STANDARDSPEC::mkTrue-1 (ignore) 
  (declare (ignore ignore)) 
  (STANDARDSPEC::mkTrue))

(defun STANDARDSPEC::mkWildPat (s) 
  (cons :|WildPat| (cons s POSITION-SPEC::noPos)))

(defun STANDARDSPEC::negateTerm (tm) 
  (block 
   nil 
   (if (eq (car tm) :|Apply|) 
       (let ((pV7 (cdr tm))) 
         (let ((pV8 (svref pV7 0))) 
           (if (eq (car pV8) :|Fun|) 
               (let ((pV12 (svref (cdr pV8) 0))) 
                 (if (eq (car pV12) :|Op|) 
                     (let ((pV16 (car (cdr pV12)))) 
                       (if (eq (car pV16) :|Qualified|) 
                           (let ((pV18 (cdr pV16))) 
                             (if (string=  "Boolean" (car pV18)) 
                                 (if (string=  "~" (cdr pV18)) 
                                     (return (svref pV7 1))))))))))))) 
   (return (STANDARDSPEC::mkApply STANDARDSPEC::notOp tm))))

(defun STANDARDSPEC::wildFindUnQualified-1 (x) 
  (STANDARDSPEC::wildFindUnQualified (car x) (cdr x)))

(defun STRINGMAP::app (x) (SPLAYMAP::app x))

(defun STRINGMAP::appi (x) (SPLAYMAP::appi x))

(defun STRINGMAP::appi-1-1 (x0 x1) (SPLAYMAP::appi-1-1 x0 x1))

(defun STRINGMAP::appiDouble-1-1 (f m) 
  (STRINGMAP::appi-1-1 
   #'(lambda (x) 
      (let ((x1 (car x))) 
        (STRINGMAP::appi-1-1 
         #'(lambda (x01) (funcall f (vector x1 (car x01) (cdr x01)))) 
         (cdr x)))) 
   m))

(defun STRINGMAP::appiDouble (x1) 
  #'(lambda (x2) (STRINGMAP::appiDouble-1-1 x1 x2)))

(defun STRINGMAP::compose (x0 x) (SPLAYMAP::compose x0 x))

(defun STRINGMAP::compose-1 (x) (STRINGMAP::compose (car x) (cdr x)))

(defun STRINGMAP::filter (x) (SPLAYMAP::filter x))

(defun STRINGMAP::filter-1-1 (x0 x1) (SPLAYMAP::filter-1-1 x0 x1))

(defun STRINGMAP::|!find|-1 (x) (STRINGMAP::|!find| (car x) (cdr x)))

(defun STRINGMAP::find2-1 (x) 
  (STRINGMAP::find2 (svref x 0) (svref x 1) (svref x 2)))

(defun STRINGMAP::foldli (x) (SPLAYMAP::foldli x))

(defun STRINGMAP::foldri (x) (SPLAYMAP::foldri x))

(defun STRINGMAP::fromList (x) 
  (SPLAYMAP::fromList-1-1 #'STRING-SPEC::compare-1 x))

(defun STRINGMAP::inDomain (x0 x) (SPLAYMAP::inDomain x0 x))

(defun STRINGMAP::inDomain-1 (x) (STRINGMAP::inDomain (car x) (cdr x)))

(defun STRINGMAP::insert-1 (x) 
  (STRINGMAP::insert (svref x 0) (svref x 1) (svref x 2)))

(defun STRINGMAP::insert2-1 (x) 
  (STRINGMAP::insert2 (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun STRINGMAP::intersectWith (x) (SPLAYMAP::intersectWith x))

(defun STRINGMAP::intersectWith-1-1 (x0 x1) (SPLAYMAP::intersectWith-1-1 x0 x1))

(defun STRINGMAP::listItems (x) (SPLAYMAP::listItems x))

(defun STRINGMAP::listItemsi (x) (SPLAYMAP::listItemsi x))

(defun STRINGMAP::|!map| (x) (SPLAYMAP::|!map| x))

(defun STRINGMAP::mapPartial (x) (SPLAYMAP::mapPartial x))

(defun STRINGMAP::mapPartial-1-1 (x0 x1) (SPLAYMAP::mapPartial-1-1 x0 x1))

(defun STRINGMAP::mapPartiali (x) (SPLAYMAP::mapPartiali x))

(defun STRINGMAP::mapPartiali-1-1 (x0 x1) (SPLAYMAP::mapPartiali-1-1 x0 x1))

(defun STRINGMAP::mapi (x) (SPLAYMAP::mapi x))

(defun STRINGMAP::numItems (x) (SPLAYMAP::numItems x))

(defun STRINGMAP::|!remove| (x0 x) (SPLAYMAP::|!remove| x0 x))

(defun STRINGMAP::|!remove|-1 (x) (STRINGMAP::|!remove| (car x) (cdr x)))

(defun STRINGMAP::subset? (x0 x) (SPLAYMAP::subset? x0 x))

(defun STRINGMAP::subset?-1 (x) (STRINGMAP::subset? (car x) (cdr x)))

(defun STRINGMAP::toList (x) (SPLAYMAP::toList x))

(defun STRINGMAP::unionWith-1-1 (x0 x1) (SPLAYMAP::unionWith-1-1 x0 x1))

(defun STRINGMAP::union2With-1-1 (f x) 
  (STRINGMAP::foldri-1-1-1 
   #'(lambda (x1) 
      (let ((x11 (svref x1 0))
            (sm2 (svref x1 1))
            (resm (svref x1 2))) 
        (let ((pV1 (STRINGMAP::|!find| resm x11))) 
          (block 
           nil 
           (if (eq (car pV1) :|None|) 
               (return (STRINGMAP::insert resm x11 sm2)) 
               (if (eq (car pV1) :|Some|) 
                   (return 
                    (STRINGMAP::insert 
                     resm 
                     x11 
                     (STRINGMAP::unionWith-1-1 f (cons (cdr pV1) sm2)))))) 
           (error "Nonexhaustive match failure in union2With"))))) 
   (car x) 
   (cdr x)))

(defun STRINGMAP::union2With (x1) 
  #'(lambda (x2) (STRINGMAP::union2With-1-1 x1 x2)))

(defun STRINGMAP::unionWith (x) (SPLAYMAP::unionWith x))

(defun STRINGSET::add-1 (x) (STRINGSET::add (car x) (cdr x)))

(defun STRINGSET::addList-1 (x) (STRINGSET::addList (car x) (cdr x)))

(defun STRINGSET::app (x) (SPLAYSET::app x))

(defun STRINGSET::app-1-1 (x0 x1) (SPLAYSET::app-1-1 x0 x1))

(defun STRINGSET::difference-1 (x) (STRINGSET::difference (car x) (cdr x)))

(defun STRINGSET::|!intersection| (x0 x) (SPLAYSET::|!intersection| x0 x))

(defun STRINGSET::|!intersection|-1 (x) 
  (STRINGSET::|!intersection| (car x) (cdr x)))

(defun STRINGSET::isEmpty (x) (SPLAYSET::isEmpty x))

(defun STRINGSET::|!map| (x) (SPLAYSET::|!map| x))

(defun STRINGSET::|!map|-1-1 (x0 x1) (SPLAYSET::|!map|-1-1 x0 x1))

(defun STRINGSET::|!member|-1 (x) (STRINGSET::|!member| (car x) (cdr x)))

(defun STRINGSET::toList (x) (SPLAYSET::listItems x))

(defun STRINGSET::|!union| (x0 x) (SPLAYSET::|!union| x0 x))

(defun STRINGSET::|!union|-1 (x) (STRINGSET::|!union| (car x) (cdr x)))

(defun STRINGUTILITIES::freshName-1 (x) 
  (STRINGUTILITIES::freshName (car x) (cdr x)))

(defun STRINGUTILITIES::tokens (x1) 
  #'(lambda (x2) (STRINGUTILITIES::tokens-1-1 x1 x2)))

(defun TOPSORT::dfs-1 (x) (TOPSORT::dfs (svref x 0) (svref x 1) (svref x 2)))

(defun TOPSORT::inorderL-1 (x) (TOPSORT::inorderL (car x) (cdr x)))

(defun TOPSORT::topSort-1 (x) 
  (TOPSORT::topSort (svref x 0) (svref x 1) (svref x 2)))

(defun TYPECHECKER::adjustEqualitySort-1 (x) 
  (TYPECHECKER::adjustEqualitySort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun TYPECHECKER::aux_elaborateTerm-1 (x) 
  (TYPECHECKER::aux_elaborateTerm (svref x 0) (svref x 1) (svref x 2)))

(defun TYPECHECKER::checkDifferent-1 (x) 
  (TYPECHECKER::checkDifferent (car x) (cdr x)))

(defun TYPECHECKER::checkSort-1 (x) (TYPECHECKER::checkSort (car x) (cdr x)))

(defun TYPECHECKER::checkSortScheme-1 (x) 
  (TYPECHECKER::checkSortScheme (car x) (cdr x)))

(defun TYPECHECKER::consistentInfixPTerms-1 (x) 
  (TYPECHECKER::consistentInfixPTerms (car x) (cdr x)))

(defun TYPECHECKER::elaborateCheckSortForTerm-1 (x) 
  (TYPECHECKER::elaborateCheckSortForTerm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun TYPECHECKER::elaboratePattern-1 (x) 
  (TYPECHECKER::elaboratePattern (svref x 0) (svref x 1) (svref x 2)))

(defun TYPECHECKER::elaboratePosSpec-1 (x) 
  (TYPECHECKER::elaboratePosSpec (car x) (cdr x)))

(defun TYPECHECKER::elaborateSort-1 (x) 
  (TYPECHECKER::elaborateSort (svref x 0) (svref x 1) (svref x 2)))

(defun TYPECHECKER::elaborateSortForTerm-1 (x) 
  (TYPECHECKER::elaborateSortForTerm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun TYPECHECKER::elaborateTerm-1 (x) 
  (TYPECHECKER::elaborateTerm (svref x 0) (svref x 1) (svref x 2)))

(defun TYPECHECKER::isArrowCoProduct-1 (x) 
  (TYPECHECKER::isArrowCoProduct (car x) (cdr x)))

(defun TYPECHECKER::isCoproduct-1 (x) 
  (TYPECHECKER::isCoproduct (car x) (cdr x)))

(defun TYPECHECKER::lookupEmbedId-1 (x) 
  (TYPECHECKER::lookupEmbedId (svref x 0) (svref x 1) (svref x 2)))

(defun TYPECHECKER::mkEmbed0-1 (x) 
  (TYPECHECKER::mkEmbed0 (svref x 0) (svref x 1) (svref x 2)))

(defun TYPECHECKER::mkEmbed1-1 (x) 
  (TYPECHECKER::mkEmbed1 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPECHECKER::mkProject-1 (x) 
  (TYPECHECKER::mkProject (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun TYPECHECKER::pass2Error-1 (x) 
  (TYPECHECKER::pass2Error (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun TYPECHECKER::selectTermWithConsistentSort-1 (x) 
  (TYPECHECKER::selectTermWithConsistentSort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPECHECKER::undeclared-1 (x) 
  (TYPECHECKER::undeclared 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPECHECKER::undeclared2-1 (x) 
  (TYPECHECKER::undeclared2 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun TYPECHECKER::undeclaredResolving-1 (x) 
  (TYPECHECKER::undeclaredResolving 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPECHECKER::uniqueConstr-1 (x) 
  (TYPECHECKER::uniqueConstr (svref x 0) (svref x 1) (svref x 2) (svref x 3)))

(defun TYPEOBLIGATIONS::|!<=|-1 (x) 
  (TYPEOBLIGATIONS::|!<=| 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPEOBLIGATIONS::addCondition-1 (x) 
  (TYPEOBLIGATIONS::addCondition (svref x 0) (svref x 1) (svref x 2)))

(defun TYPEOBLIGATIONS::addFailure-1 (x) 
  (TYPEOBLIGATIONS::addFailure (svref x 0) (svref x 1) (svref x 2)))

(defun TYPEOBLIGATIONS::assertCond-1 (x) 
  (TYPEOBLIGATIONS::assertCond (car x) (cdr x)))

(defun TYPEOBLIGATIONS::assertSubtypeCond-1 (x) 
  (TYPEOBLIGATIONS::assertSubtypeCond (svref x 0) (svref x 1) (svref x 2)))

(defun TYPEOBLIGATIONS::bindPattern-1 (x) 
  (TYPEOBLIGATIONS::bindPattern (svref x 0) (svref x 1) (svref x 2)))

(defun TYPEOBLIGATIONS::checkSpec (x0 x1 x2 x3) 
  (TYPEOBLIGATIONS::checkSpec-1 (vector x0 x1 x2 x3)))

(defun TYPEOBLIGATIONS::freshName-1 (x) 
  (TYPEOBLIGATIONS::freshName (car x) (cdr x)))

(defun TYPEOBLIGATIONS::insertLet (pV1 pV2) 
  (block 
   nil 
   (return 
    (vector 
     (LIST-SPEC::|!cons| (cons :|Let| pV1) (svref pV2 0)) 
     (svref pV2 1) 
     (svref pV2 2) 
     (svref pV2 3) 
     (svref pV2 4))) 
   (error "Nonexhaustive match failure in insertLet")))

(defun TYPEOBLIGATIONS::insertLet-1 (x) 
  (TYPEOBLIGATIONS::insertLet (car x) (cdr x)))

(defun TYPEOBLIGATIONS::insertLetRec (pV7 pV8) 
  (block 
   nil 
   (return 
    (vector 
     (LIST-SPEC::|!cons| (cons :|LetRec| pV7) (svref pV8 0)) 
     (svref pV8 1) 
     (svref pV8 2) 
     (svref pV8 3) 
     (STRINGSET::addList 
      (svref pV8 4) 
      (LIST-SPEC::|!map|-1-1 
       #'(lambda (x) 
          (block 
           nil 
           (return (car (car x))) 
           (error "Nonexhaustive match failure in insertLetRec"))) 
       pV7)))) 
   (error "Nonexhaustive match failure in insertLetRec")))

(defun TYPEOBLIGATIONS::insertLetRec-1 (x) 
  (TYPEOBLIGATIONS::insertLetRec (car x) (cdr x)))

(defun TYPEOBLIGATIONS::makeTypeCheckObligationSpec-1 (x) 
  (TYPEOBLIGATIONS::makeTypeCheckObligationSpec (car x) (cdr x)))

(defun TYPEOBLIGATIONS::makeVerificationCondition-1 (x) 
  (TYPEOBLIGATIONS::makeVerificationCondition (car x) (cdr x)))

(defun TYPEOBLIGATIONS::mkLetOrApply-1 (x) 
  (TYPEOBLIGATIONS::mkLetOrApply (car x) (cdr x)))

(defun TYPEOBLIGATIONS::printDecl (d) 
  (block 
   nil 
   (if (eq (car d) :|Var|) 
       (let ((pV5 (cdr d))) 
         (return 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ (car pV5) ":") 
           (ANNSPECPRINTER::printSort (cdr pV5))))) 
       (if (eq (car d) :|Cond|) 
           (return 
            (STRING-SPEC::^ "assert " (ANNSPECPRINTER::printTerm (cdr d)))) 
           (if (eq (car d) :|LetRec|) 
               (return 
                (ANNSPECPRINTER::printTerm 
                 (cons 
                  :|LetRec| 
                  (vector 
                   (cdr d) 
                   (cons :|Record| (cons nil POSITION-SPEC::noPos)) 
                   POSITION-SPEC::noPos)))) 
               (if (eq (car d) :|Let|) 
                   (return 
                    (ANNSPECPRINTER::printTerm 
                     (cons 
                      :|Let| 
                      (vector 
                       (cdr d) 
                       (cons :|Record| (cons nil POSITION-SPEC::noPos)) 
                       POSITION-SPEC::noPos)))))))) 
   (error "Nonexhaustive match failure in printDecl")))

(defun TYPEOBLIGATIONS::printGamma (decls pV1 pV2 pV3 pV4) 
  (declare (ignore pV1 pV2 pV3 pV4)) 
  (progn (LIST-SPEC::app-1-1 
          #'(lambda (decl) 
             (progn (STRING-SPEC::toScreen (TYPEOBLIGATIONS::printDecl decl)) 
                    (STRING-SPEC::toScreen "; "))) 
          (LIST-SPEC::rev decls)) 
         (progn (STRING-SPEC::writeLine "") nil)))

(defun TYPEOBLIGATIONS::printGamma-1 (x) 
  (TYPEOBLIGATIONS::printGamma 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPEOBLIGATIONS::returnPattern-1 (x) 
  (TYPEOBLIGATIONS::returnPattern 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun TYPEOBLIGATIONS::returnPatternRec-1 (x) 
  (TYPEOBLIGATIONS::returnPatternRec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defun TYPEOBLIGATIONS::subtypeRec-1 (x) 
  (TYPEOBLIGATIONS::subtypeRec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun TYPEOBLIGATIONS::unfoldBase-1 (x) 
  (TYPEOBLIGATIONS::unfoldBase (car x) (cdr x)))

(defun TYPEOBLIGATIONS::\|--1 (x) (TYPEOBLIGATIONS::\|- (car x) (cdr x)))

(defun UTILITIES::addConstrsEnv-1 (x) 
  (UTILITIES::addConstrsEnv (car x) (cdr x)))

(defun UTILITIES::addVariable-1 (x) 
  (UTILITIES::addVariable (svref x 0) (svref x 1) (svref x 2)))

(defparameter UTILITIES::baseSpec 
  (vector 
   emptyImportInfo 
   emptyAQualifierMap 
   STANDARDSPEC::emptyProperties 
   emptyAQualifierMap))

(defun UTILITIES::initPrimitiveSpec-1-1-1 (qualifier id tyvars) 
  (vector 
   emptyImportInfo 
   emptyAQualifierMap 
   STANDARDSPEC::emptyProperties 
   (insertAQualifierMap 
    emptyAQualifierMap 
    qualifier 
    id 
    (vector (cons (cons :|Qualified| (cons qualifier id)) nil) tyvars nil))))

(defparameter UTILITIES::boolSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Boolean" "Boolean" nil))

(defparameter UTILITIES::cgeninfohead ";;;CGEN-INFO ")

(defparameter UTILITIES::charSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Char" "Char" nil))

(defun UTILITIES::checkErrors (x0 x1 x2 x3 x4 x5 x6) 
  (UTILITIES::checkErrors-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun UTILITIES::computeConstrMap (x0 x1 x2 x3) 
  (UTILITIES::computeConstrMap-1 (vector x0 x1 x2 x3)))

(defun UTILITIES::consistentSorts?-1 (x) 
  (UTILITIES::consistentSorts? (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::convertConjecturesToAxioms-1 (spc) 
  (setProperties 
   spc 
   (LIST-SPEC::|!map|-1-1 
    #'(lambda (x) 
       (let ((ty (svref x 0))) 
         (vector 
          (block 
           nil 
           (if (eq (car ty) :|Conjecture|) (return '(:|Axiom|))) 
           (return ty)) 
          (svref x 1) 
          (svref x 2) 
          (svref x 3)))) 
    (svref spc 2))))

(defun UTILITIES::convertConjecturesToAxioms (x0 x1 x2 x3) 
  (UTILITIES::convertConjecturesToAxioms-1 (vector x0 x1 x2 x3)))

(defun UTILITIES::deleteVar (v sub sub2) 
  (block 
   nil 
   (if (null sub) 
       (return sub2) 
       (if (consp sub) 
           (let ((pV4 (cdr sub))
                 (pV3 (car sub))) 
             (let ((pV5 (car pV3))) 
               (return 
                (if (slang-built-in::slang-term-equals v pV5) 
                    (LIST-SPEC::|!++| pV4 sub2) 
                    (UTILITIES::deleteVar 
                     v 
                     pV4 
                     (LIST-SPEC::|!cons| (cons pV5 (cdr pV3)) sub2)))))))) 
   (error "Nonexhaustive match failure in deleteVar")))

(defun UTILITIES::deleteVar-1 (x) 
  (UTILITIES::deleteVar (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::deleteVars-1 (x) (UTILITIES::deleteVars (car x) (cdr x)))

(defun UTILITIES::filterWithIndex-1-1 (p l) 
  (labels 
    ((fRec (n l) 
      (block 
       nil 
       (if (null l) 
           (return nil) 
           (if (consp l) 
               (let ((pV3 (car l))
                     (pV4 (cdr l))) 
                 (return 
                  (if (funcall p (cons n pV3)) 
                      (LIST-SPEC::|!cons| 
                       pV3 
                       (fRec (INTEGER-SPEC::|!+| n 1) pV4)) 
                      (fRec (INTEGER-SPEC::|!+| n 1) pV4)))))) 
       (error "Nonexhaustive match failure in filterWithIndex")))) (fRec 0 l)))

(defun UTILITIES::disableProperties (indices spc) 
  (if (INTEGERSET::isEmpty indices) 
      spc 
      (let ((idx (cons :|Ref| 0))) 
        (let ((revised_ops 
               (STRINGMAP::|!map|-1-1 
                #'(lambda (m) 
                   (STRINGMAP::|!map|-1-1 
                    #'(lambda (x) 
                       (let ((srt (svref x 2))
                             (fixity (svref x 1))
                             (op_names (svref x 0))) 
                         (progn (STATE::|:=| 
                                 idx 
                                 (INTEGER-SPEC::|!-| (STATE::|!!| idx) 1)) 
                                (if (INTEGERSET::|!member| 
                                     indices 
                                     (STATE::|!!| idx)) 
                                    (vector op_names fixity srt nil) 
                                    (vector op_names fixity srt (svref x 3)))))) 
                    m)) 
                (svref spc 1)))) 
          (vector 
           (svref spc 0) 
           revised_ops 
           (UTILITIES::filterWithIndex-1-1 
            #'(lambda (x) 
               (BOOLEAN-SPEC::~ (INTEGERSET::|!member| indices (car x)))) 
            (svref spc 2)) 
           (svref spc 3))))))

(defun UTILITIES::disableProperties-1 (x) 
  (UTILITIES::disableProperties (car x) (cdr x)))

(defun UTILITIES::|!error|-1 (x) 
  (UTILITIES::|!error| (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::externalopshfile (specname) 
  (STRING-SPEC::^ specname "_extops.h"))

(defun UTILITIES::extractAssignment (variables arguments) 
  (block 
   nil 
   (if (eq (car variables) :|Var|) 
       (let ((pV27 (cdr variables))) 
         (progn (let ((pV33 (car pV27))) 
                  (if (eq (car arguments) :|Var|) 
                      (return 
                       (if (slang-built-in::slang-term-equals 
                            pV33 
                            (car (cdr arguments))) 
                           nil 
                           (cons 
                            (cons 
                             (cons :|VarPat| (cons pV33 (cdr pV27))) 
                             arguments) 
                            nil))))) 
                (return 
                 (cons 
                  (cons (cons :|VarPat| (cons (car pV27) (cdr pV27))) arguments) 
                  nil)))) 
       (if (eq (car variables) :|Record|) 
           (if (eq (car arguments) :|Record|) 
               (return 
                (LISTPAIR::foldr-1-1-1 
                 #'(lambda (x) 
                    (let ((pV16 (svref x 2))) 
                      (block 
                       nil 
                       (let ((pV18 (cdr (svref x 0)))) 
                         (if (eq (car pV18) :|Var|) 
                             (let ((pV20 (car (cdr pV18)))) 
                               (let ((pV23 (cdr (svref x 1)))) 
                                 (return 
                                  (block 
                                   nil 
                                   (if (eq (car pV23) :|Var|) 
                                       (return 
                                        (if (slang-built-in::slang-term-equals 
                                             pV20 
                                             (car (cdr pV23))) 
                                            pV16 
                                            (LIST-SPEC::|!cons| 
                                             (cons 
                                              (STANDARDSPEC::mkVarPat-1 pV20) 
                                              pV23) 
                                             pV16)))) 
                                   (return 
                                    (LIST-SPEC::|!cons| 
                                     (cons (STANDARDSPEC::mkVarPat-1 pV20) pV23) 
                                     pV16)))))))) 
                       (error "Nonexhaustive match failure in extractAssignment")))) 
                 nil 
                 (cons (car (cdr variables)) (car (cdr arguments)))))))) 
   (error "Nonexhaustive match failure in extractAssignment")))

(defun UTILITIES::extractAssignment-1 (x) 
  (UTILITIES::extractAssignment (car x) (cdr x)))

(defun UTILITIES::filterWithIndex (x1) 
  #'(lambda (x2) (UTILITIES::filterWithIndex-1-1 x1 x2)))

(defun UTILITIES::findTheOp2-1 (x) 
  (UTILITIES::findTheOp2 (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::findTheSort2 (env qualifier id) 
  (findAQualifierMap (svref (svref env 5) 3) qualifier id))

(defun UTILITIES::findTheSort2-1 (x) 
  (UTILITIES::findTheSort2 (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::findVarOrOps-1 (x) 
  (UTILITIES::findVarOrOps (svref x 0) (svref x 1) (svref x 2)))

(defparameter UTILITIES::generalSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "General" "General" (cons "a" nil)))

(defun UTILITIES::initPrimitiveSpec (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (UTILITIES::initPrimitiveSpec-1-1-1 x1 x2 x3))))

(defun UTILITIES::initialEnv-1 (x) (UTILITIES::initialEnv (car x) (cdr x)))

(defun UTILITIES::initializeMetaTyVar-1 (ignore) 
  (declare (ignore ignore)) 
  (UTILITIES::initializeMetaTyVar))

(defun UTILITIES::instantiateScheme-1 (x) 
  (UTILITIES::instantiateScheme 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))

(defparameter UTILITIES::intSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Integer" "Integer" nil))

(defun UTILITIES::isFree-1 (x) (UTILITIES::isFree (car x) (cdr x)))

(defun UTILITIES::isPatBound-1 (x) (UTILITIES::isPatBound (car x) (cdr x)))

(defun UTILITIES::letRecToLetTermFun (fun) fun)

(defun UTILITIES::letRecToLetTermVar (id srt) 
  (cons id (UTILITIES::letRecToLetTermSort srt)))

(defun UTILITIES::letRecToLetTermVar-1 (x) 
  (UTILITIES::letRecToLetTermVar (car x) (cdr x)))

(defun UTILITIES::letRecToLetTermPattern (pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV11 (cdr pat))) 
         (return 
          (cons 
           :|AliasPat| 
           (vector 
            (UTILITIES::letRecToLetTermPattern (svref pV11 0)) 
            (UTILITIES::letRecToLetTermPattern (svref pV11 1)) 
            (svref pV11 2))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV10 (cdr pat))) 
             (return 
              (cons 
               :|VarPat| 
               (cons (UTILITIES::letRecToLetTermVar-1 (car pV10)) (cdr pV10))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV9 (cdr pat))) 
                 (let ((pV23 (svref pV9 1))) 
                   (return 
                    (cons 
                     :|EmbedPat| 
                     (vector 
                      (svref pV9 0) 
                      (block 
                       nil 
                       (if (eq (car pV23) :|None|) 
                           (return '(:|None|)) 
                           (if (eq (car pV23) :|Some|) 
                               (return 
                                (cons 
                                 :|Some| 
                                 (UTILITIES::letRecToLetTermPattern (cdr pV23)))))) 
                       (error 
                        "Nonexhaustive match failure in letRecToLetTermPattern")) 
                      (UTILITIES::letRecToLetTermSort (svref pV9 2)) 
                      (svref pV9 3)))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (let ((pV8 (cdr pat))) 
                     (return 
                      (cons 
                       :|RecordPat| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (UTILITIES::letRecToLetTermPattern (cdr x)))) 
                         (car pV8)) 
                        (cdr pV8))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (let ((pV7 (cdr pat))) 
                         (return 
                          (cons 
                           :|WildPat| 
                           (cons 
                            (UTILITIES::letRecToLetTermSort (car pV7)) 
                            (cdr pV7))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV6 (cdr pat))) 
                             (return 
                              (cons 
                               :|RelaxPat| 
                               (vector 
                                (UTILITIES::letRecToLetTermPattern (svref pV6 0)) 
                                (UTILITIES::letRecToLetTermTerm (svref pV6 1)) 
                                (svref pV6 2))))) 
                           (if (eq (car pat) :|QuotientPat|) 
                               (let ((pV5 (cdr pat))) 
                                 (return 
                                  (cons 
                                   :|QuotientPat| 
                                   (vector 
                                    (UTILITIES::letRecToLetTermPattern 
                                     (svref pV5 0)) 
                                    (UTILITIES::letRecToLetTermTerm 
                                     (svref pV5 1)) 
                                    (svref pV5 2)))))))))))) 
   (return pat)))

(defun UTILITIES::letRecToLetTermTerm (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV18 (cdr term))) 
         (return 
          (cons 
           :|Apply| 
           (vector 
            (UTILITIES::letRecToLetTermTerm (svref pV18 0)) 
            (UTILITIES::letRecToLetTermTerm (svref pV18 1)) 
            (svref pV18 2))))) 
       (if (eq (car term) :|Record|) 
           (let ((pV17 (cdr term))) 
             (return 
              (cons 
               :|Record| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::letRecToLetTermTerm (cdr x)))) 
                 (car pV17)) 
                (cdr pV17))))) 
           (if (eq (car term) :|Bind|) 
               (let ((pV16 (cdr term))) 
                 (return 
                  (cons 
                   :|Bind| 
                   (vector 
                    (svref pV16 0) 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (v) (UTILITIES::letRecToLetTermVar-1 v)) 
                     (svref pV16 1)) 
                    (UTILITIES::letRecToLetTermTerm (svref pV16 2)) 
                    (svref pV16 3))))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV15 (cdr term))) 
                     (return 
                      (cons 
                       :|Let| 
                       (vector 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (UTILITIES::letRecToLetTermPattern (car x)) 
                             (UTILITIES::letRecToLetTermTerm (cdr x)))) 
                         (svref pV15 0)) 
                        (UTILITIES::letRecToLetTermTerm (svref pV15 1)) 
                        (svref pV15 2))))) 
                   (if (eq (car term) :|LetRec|) 
                       (let ((pV14 (cdr term))) 
                         (let ((pV34 (svref pV14 2))) 
                           (return 
                            (let ((vts 
                                   (LIST-SPEC::|!map|-1-1 
                                    #'(lambda (x) 
                                       (cons 
                                        (UTILITIES::letRecToLetTermVar-1 (car x)) 
                                        (UTILITIES::letRecToLetTermTerm (cdr x)))) 
                                    (svref pV14 0)))) 
                              (let ((|!t| 
                                     (UTILITIES::letRecToLetTermTerm 
                                      (svref pV14 1)))) 
                                (let ((pts 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'(lambda (x) 
                                           (cons 
                                            (cons 
                                             :|VarPat| 
                                             (cons (car x) POSITION-SPEC::noPos)) 
                                            (cdr x))) 
                                        vts))) 
                                  (let ((dummyterm (STANDARDSPEC::mkTrue))) 
                                    (let ((dummypts 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) 
                                               (let ((|!t| (cdr x))
                                                     (pat (car x))) 
                                                 (block 
                                                  nil 
                                                  (if (eq (car |!t|) :|Lambda|) 
                                                      (let ((pV4 (cdr |!t|))) 
                                                        (return 
                                                         (let ((newmatch 
                                                                (LIST-SPEC::|!map|-1-1 
                                                                 #'(lambda (x1) 
                                                                    (vector 
                                                                     (svref x1 0) 
                                                                     (svref x1 1) 
                                                                     dummyterm)) 
                                                                 (car pV4)))) 
                                                           (cons 
                                                            pat 
                                                            (cons 
                                                             :|Lambda| 
                                                             (cons 
                                                              newmatch 
                                                              (cdr pV4)))))))) 
                                                  (return (cons pat dummyterm))))) 
                                            pts))) 
                                      (cons 
                                       :|Let| 
                                       (vector 
                                        dummypts 
                                        (cons 
                                         :|Let| 
                                         (vector 
                                          pts 
                                          (cons :|Let| (vector pts |!t| pV34)) 
                                          pV34)) 
                                        pV34)))))))))) 
                       (if (eq (car term) :|Var|) 
                           (let ((pV13 (cdr term))) 
                             (return 
                              (cons 
                               :|Var| 
                               (cons 
                                (UTILITIES::letRecToLetTermVar-1 (car pV13)) 
                                (cdr pV13))))) 
                           (if (eq (car term) :|Fun|) 
                               (let ((pV12 (cdr term))) 
                                 (return 
                                  (cons 
                                   :|Fun| 
                                   (vector 
                                    (UTILITIES::letRecToLetTermFun 
                                     (svref pV12 0)) 
                                    (UTILITIES::letRecToLetTermSort 
                                     (svref pV12 1)) 
                                    (svref pV12 2))))) 
                               (if (eq (car term) :|Lambda|) 
                                   (let ((pV11 (cdr term))) 
                                     (return 
                                      (cons 
                                       :|Lambda| 
                                       (cons 
                                        (LIST-SPEC::|!map|-1-1 
                                         #'(lambda (x) 
                                            (vector 
                                             (UTILITIES::letRecToLetTermPattern 
                                              (svref x 0)) 
                                             (UTILITIES::letRecToLetTermTerm 
                                              (svref x 1)) 
                                             (UTILITIES::letRecToLetTermTerm 
                                              (svref x 2)))) 
                                         (car pV11)) 
                                        (cdr pV11))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV10 (cdr term))) 
                                         (return 
                                          (cons 
                                           :|IfThenElse| 
                                           (vector 
                                            (UTILITIES::letRecToLetTermTerm 
                                             (svref pV10 0)) 
                                            (UTILITIES::letRecToLetTermTerm 
                                             (svref pV10 1)) 
                                            (UTILITIES::letRecToLetTermTerm 
                                             (svref pV10 2)) 
                                            (svref pV10 3))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (let ((pV9 (cdr term))) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (|!t|) 
                                                    (UTILITIES::letRecToLetTermTerm 
                                                     |!t|)) 
                                                 (car pV9)) 
                                                (cdr pV9))))))))))))))) 
   (return term)))

(defun UTILITIES::letRecToLetTermSort (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV10 (cdr srt))) 
         (return 
          (cons 
           :|Arrow| 
           (vector 
            (UTILITIES::letRecToLetTermSort (svref pV10 0)) 
            (UTILITIES::letRecToLetTermSort (svref pV10 1)) 
            (svref pV10 2))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV9 (cdr srt))) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::letRecToLetTermSort (cdr x)))) 
                 (car pV9)) 
                (cdr pV9))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV8 (cdr srt))) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((optsrt (cdr x))) 
                          (cons 
                           (car x) 
                           (block 
                            nil 
                            (if (eq (car optsrt) :|Some|) 
                                (return 
                                 (cons 
                                  :|Some| 
                                  (UTILITIES::letRecToLetTermSort (cdr optsrt)))) 
                                (if (eq (car optsrt) :|None|) 
                                    (return '(:|None|)))) 
                            (error 
                             "Nonexhaustive match failure in letRecToLetTermSort"))))) 
                     (car pV8)) 
                    (cdr pV8))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV7 (cdr srt))) 
                     (return 
                      (cons 
                       :|Quotient| 
                       (vector 
                        (UTILITIES::letRecToLetTermSort (svref pV7 0)) 
                        (UTILITIES::letRecToLetTermTerm (svref pV7 1)) 
                        (svref pV7 2))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV6 (cdr srt))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector 
                            (UTILITIES::letRecToLetTermSort (svref pV6 0)) 
                            (UTILITIES::letRecToLetTermTerm (svref pV6 1)) 
                            (svref pV6 2))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV5 (cdr srt))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector 
                                (svref pV5 0) 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (s) 
                                    (UTILITIES::letRecToLetTermSort s)) 
                                 (svref pV5 1)) 
                                (svref pV5 2))))))))))) 
   (return srt)))

(defun UTILITIES::letRecToLetTermOpInfo (pV1 pV2 pV3 pV4) 
  (block 
   nil 
   (return 
    (vector 
     pV1 
     pV2 
     (cons (car pV3) (UTILITIES::letRecToLetTermSort (cdr pV3))) 
     (LIST-SPEC::|!map|-1-1 
      #'(lambda (x) (cons (car x) (UTILITIES::letRecToLetTermTerm (cdr x)))) 
      pV4))) 
   (error "Nonexhaustive match failure in letRecToLetTermOpInfo")))

(defun UTILITIES::letRecToLetTermOpInfo-1 (x) 
  (UTILITIES::letRecToLetTermOpInfo 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))

(defun UTILITIES::letRecToLetTermSortInfo (sort_names tyvars defs) 
  (vector 
   sort_names 
   tyvars 
   (LIST-SPEC::|!map|-1-1 
    #'(lambda (x) (cons (car x) (UTILITIES::letRecToLetTermSort (cdr x)))) 
    defs)))

(defun UTILITIES::letRecToLetTermSortInfo-1 (x) 
  (UTILITIES::letRecToLetTermSortInfo (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::letRecToLetTermSpec-1 (spc) 
  (vector 
   (svref spc 0) 
   (STRINGMAP::mapDouble-1-1 #'UTILITIES::letRecToLetTermOpInfo-1 (svref spc 1)) 
   (svref spc 2) 
   (STRINGMAP::mapDouble-1-1 
    #'UTILITIES::letRecToLetTermSortInfo-1 
    (svref spc 3))))

(defun UTILITIES::letRecToLetTermSpec (x0 x1 x2 x3) 
  (UTILITIES::letRecToLetTermSpec-1 (vector x0 x1 x2 x3)))

(defun UTILITIES::linkMetaTyVar (x1) 
  #'(lambda (x2) (UTILITIES::linkMetaTyVar-1-1 x1 x2)))

(defparameter UTILITIES::listSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "List" "List" (cons "a" nil)))

(defun UTILITIES::lookup (desired_key? association_list) 
  (block 
   nil 
   (if (null association_list) 
       (return '(:|None|)) 
       (if (consp association_list) 
           (let ((pV3 (car association_list))) 
             (return 
              (if (funcall desired_key? (car pV3)) 
                  (cons :|Some| (cdr pV3)) 
                  (UTILITIES::lookup desired_key? (cdr association_list))))))) 
   (error "Nonexhaustive match failure in lookup")))

(defun UTILITIES::lookup-1 (x) (UTILITIES::lookup (car x) (cdr x)))

(defun UTILITIES::mkAnd-1 (x) (UTILITIES::mkAnd (car x) (cdr x)))

(defun UTILITIES::mkIfThenElse-1 (x) 
  (UTILITIES::mkIfThenElse (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::mkOr-1 (x) (UTILITIES::mkOr (car x) (cdr x)))

(defun UTILITIES::modifyNamesFun (pV1 mOp fun) 
  (declare (ignore pV1)) 
  (block 
   nil 
   (if (eq (car fun) :|Op|) 
       (let ((pV4 (cdr fun))) 
         (return (cons :|Op| (cons (funcall mOp (car pV4)) (cdr pV4)))))) 
   (return fun)))

(defun UTILITIES::modifyNamesFun-1 (x) 
  (UTILITIES::modifyNamesFun (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::modifyNamesVar (pV1 pV2 pV3) 
  (block 
   nil 
   (return (cons (car pV3) (UTILITIES::modifyNamesSort pV1 pV2 (cdr pV3)))) 
   (error "Nonexhaustive match failure in modifyNamesVar")))

(defun UTILITIES::modifyNamesPattern (mSrt mOp pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV11 (cdr pat))) 
         (return 
          (cons 
           :|AliasPat| 
           (vector 
            (UTILITIES::modifyNamesPattern mSrt mOp (svref pV11 0)) 
            (UTILITIES::modifyNamesPattern mSrt mOp (svref pV11 1)) 
            (svref pV11 2))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV10 (cdr pat))) 
             (return 
              (cons 
               :|VarPat| 
               (cons (UTILITIES::modifyNamesVar mSrt mOp (car pV10)) (cdr pV10))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV9 (cdr pat))) 
                 (let ((pV23 (svref pV9 1))) 
                   (return 
                    (cons 
                     :|EmbedPat| 
                     (vector 
                      (svref pV9 0) 
                      (block 
                       nil 
                       (if (eq (car pV23) :|None|) 
                           (return '(:|None|)) 
                           (if (eq (car pV23) :|Some|) 
                               (return 
                                (cons 
                                 :|Some| 
                                 (UTILITIES::modifyNamesPattern 
                                  mSrt 
                                  mOp 
                                  (cdr pV23)))))) 
                       (error 
                        "Nonexhaustive match failure in modifyNamesPattern")) 
                      (UTILITIES::modifyNamesSort mSrt mOp (svref pV9 2)) 
                      (svref pV9 3)))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (let ((pV8 (cdr pat))) 
                     (return 
                      (cons 
                       :|RecordPat| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (UTILITIES::modifyNamesPattern mSrt mOp (cdr x)))) 
                         (car pV8)) 
                        (cdr pV8))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (let ((pV7 (cdr pat))) 
                         (return 
                          (cons 
                           :|WildPat| 
                           (cons 
                            (UTILITIES::modifyNamesSort mSrt mOp (car pV7)) 
                            (cdr pV7))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV6 (cdr pat))) 
                             (return 
                              (cons 
                               :|RelaxPat| 
                               (vector 
                                (UTILITIES::modifyNamesPattern 
                                 mSrt 
                                 mOp 
                                 (svref pV6 0)) 
                                (UTILITIES::modifyNamesTerm 
                                 mSrt 
                                 mOp 
                                 (svref pV6 1)) 
                                (svref pV6 2))))) 
                           (if (eq (car pat) :|QuotientPat|) 
                               (let ((pV5 (cdr pat))) 
                                 (return 
                                  (cons 
                                   :|QuotientPat| 
                                   (vector 
                                    (UTILITIES::modifyNamesPattern 
                                     mSrt 
                                     mOp 
                                     (svref pV5 0)) 
                                    (UTILITIES::modifyNamesTerm 
                                     mSrt 
                                     mOp 
                                     (svref pV5 1)) 
                                    (svref pV5 2)))))))))))) 
   (return pat)))

(defun UTILITIES::modifyNamesTerm (mSrt mOp term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV12 (cdr term))) 
         (return 
          (cons 
           :|Apply| 
           (vector 
            (UTILITIES::modifyNamesTerm mSrt mOp (svref pV12 0)) 
            (UTILITIES::modifyNamesTerm mSrt mOp (svref pV12 1)) 
            (svref pV12 2))))) 
       (if (eq (car term) :|Record|) 
           (let ((pV11 (cdr term))) 
             (return 
              (cons 
               :|Record| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::modifyNamesTerm mSrt mOp (cdr x)))) 
                 (car pV11)) 
                (cdr pV11))))) 
           (if (eq (car term) :|Bind|) 
               (let ((pV10 (cdr term))) 
                 (return 
                  (cons 
                   :|Bind| 
                   (vector 
                    (svref pV10 0) 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (v) (UTILITIES::modifyNamesVar mSrt mOp v)) 
                     (svref pV10 1)) 
                    (UTILITIES::modifyNamesTerm mSrt mOp (svref pV10 2)) 
                    (svref pV10 3))))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV9 (cdr term))) 
                     (return 
                      (cons 
                       :|Let| 
                       (vector 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (UTILITIES::modifyNamesPattern mSrt mOp (car x)) 
                             (UTILITIES::modifyNamesTerm mSrt mOp (cdr x)))) 
                         (svref pV9 0)) 
                        (UTILITIES::modifyNamesTerm mSrt mOp (svref pV9 1)) 
                        (svref pV9 2))))) 
                   (if (eq (car term) :|LetRec|) 
                       (let ((pV8 (cdr term))) 
                         (return 
                          (cons 
                           :|LetRec| 
                           (vector 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (UTILITIES::modifyNamesVar mSrt mOp (car x)) 
                                 (UTILITIES::modifyNamesTerm mSrt mOp (cdr x)))) 
                             (svref pV8 0)) 
                            (UTILITIES::modifyNamesTerm mSrt mOp (svref pV8 1)) 
                            (svref pV8 2))))) 
                       (if (eq (car term) :|Var|) 
                           (let ((pV7 (cdr term))) 
                             (return 
                              (cons 
                               :|Var| 
                               (cons 
                                (UTILITIES::modifyNamesVar mSrt mOp (car pV7)) 
                                (cdr pV7))))) 
                           (if (eq (car term) :|Fun|) 
                               (let ((pV6 (cdr term))) 
                                 (return 
                                  (cons 
                                   :|Fun| 
                                   (vector 
                                    (UTILITIES::modifyNamesFun 
                                     mSrt 
                                     mOp 
                                     (svref pV6 0)) 
                                    (UTILITIES::modifyNamesSort 
                                     mSrt 
                                     mOp 
                                     (svref pV6 1)) 
                                    (svref pV6 2))))) 
                               (if (eq (car term) :|Lambda|) 
                                   (let ((pV5 (cdr term))) 
                                     (return 
                                      (cons 
                                       :|Lambda| 
                                       (cons 
                                        (LIST-SPEC::|!map|-1-1 
                                         #'(lambda (x) 
                                            (vector 
                                             (UTILITIES::modifyNamesPattern 
                                              mSrt 
                                              mOp 
                                              (svref x 0)) 
                                             (UTILITIES::modifyNamesTerm 
                                              mSrt 
                                              mOp 
                                              (svref x 1)) 
                                             (UTILITIES::modifyNamesTerm 
                                              mSrt 
                                              mOp 
                                              (svref x 2)))) 
                                         (car pV5)) 
                                        (cdr pV5))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV4 (cdr term))) 
                                         (return 
                                          (cons 
                                           :|IfThenElse| 
                                           (vector 
                                            (UTILITIES::modifyNamesTerm 
                                             mSrt 
                                             mOp 
                                             (svref pV4 0)) 
                                            (UTILITIES::modifyNamesTerm 
                                             mSrt 
                                             mOp 
                                             (svref pV4 1)) 
                                            (UTILITIES::modifyNamesTerm 
                                             mSrt 
                                             mOp 
                                             (svref pV4 2)) 
                                            (svref pV4 3))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (let ((pV3 (cdr term))) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (|!t|) 
                                                    (UTILITIES::modifyNamesTerm 
                                                     mSrt 
                                                     mOp 
                                                     |!t|)) 
                                                 (car pV3)) 
                                                (cdr pV3))))))))))))))) 
   (return term)))

(defun UTILITIES::modifyNamesSort (mSrt mOp srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV10 (cdr srt))) 
         (return 
          (cons 
           :|Arrow| 
           (vector 
            (UTILITIES::modifyNamesSort mSrt mOp (svref pV10 0)) 
            (UTILITIES::modifyNamesSort mSrt mOp (svref pV10 1)) 
            (svref pV10 2))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV9 (cdr srt))) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::modifyNamesSort mSrt mOp (cdr x)))) 
                 (car pV9)) 
                (cdr pV9))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV8 (cdr srt))) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((optsrt (cdr x))) 
                          (cons 
                           (car x) 
                           (block 
                            nil 
                            (if (eq (car optsrt) :|Some|) 
                                (return 
                                 (cons 
                                  :|Some| 
                                  (UTILITIES::modifyNamesSort 
                                   mSrt 
                                   mOp 
                                   (cdr optsrt)))) 
                                (if (eq (car optsrt) :|None|) 
                                    (return '(:|None|)))) 
                            (error 
                             "Nonexhaustive match failure in modifyNamesSort"))))) 
                     (car pV8)) 
                    (cdr pV8))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV7 (cdr srt))) 
                     (return 
                      (cons 
                       :|Quotient| 
                       (vector 
                        (UTILITIES::modifyNamesSort mSrt mOp (svref pV7 0)) 
                        (UTILITIES::modifyNamesTerm mSrt mOp (svref pV7 1)) 
                        (svref pV7 2))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV6 (cdr srt))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector 
                            (UTILITIES::modifyNamesSort mSrt mOp (svref pV6 0)) 
                            (UTILITIES::modifyNamesTerm mSrt mOp (svref pV6 1)) 
                            (svref pV6 2))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV5 (cdr srt))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector 
                                (funcall mSrt (svref pV5 0)) 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (s) 
                                    (UTILITIES::modifyNamesSort mSrt mOp s)) 
                                 (svref pV5 1)) 
                                (svref pV5 2))))))))))) 
   (return srt)))

(defun UTILITIES::modifyNamesOpInfo (pV1 pV2 pV3) 
  (block 
   nil 
   (let ((pV6 (svref pV3 2))) 
     (return 
      (vector 
       (LIST-SPEC::rev 
        (LIST-SPEC::foldl-1-1-1 
         #'(lambda (x) (LIST-SPEC::|!cons| (funcall pV2 (car x)) (cdr x))) 
         LIST-SPEC::|!nil| 
         (svref pV3 0))) 
       (svref pV3 1) 
       (cons (car pV6) (UTILITIES::modifyNamesSort pV1 pV2 (cdr pV6))) 
       (LIST-SPEC::|!map|-1-1 
        #'(lambda (x) 
           (cons (car x) (UTILITIES::modifyNamesTerm pV1 pV2 (cdr x)))) 
        (svref pV3 3))))) 
   (error "Nonexhaustive match failure in modifyNamesOpInfo")))

(defun UTILITIES::modifyNamesOpInfo-1 (x) 
  (UTILITIES::modifyNamesOpInfo (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::modifyNamesPattern-1 (x) 
  (UTILITIES::modifyNamesPattern (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::modifyNamesSort-1 (x) 
  (UTILITIES::modifyNamesSort (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::modifyNamesSortInfo (pV1 pV2 pV3) 
  (block 
   nil 
   (return 
    (vector 
     (LIST-SPEC::rev 
      (LIST-SPEC::foldl-1-1-1 
       #'(lambda (x) (LIST-SPEC::|!cons| (funcall pV1 (car x)) (cdr x))) 
       LIST-SPEC::|!nil| 
       (svref pV3 0))) 
     (svref pV3 1) 
     (LIST-SPEC::|!map|-1-1 
      #'(lambda (x) (cons (car x) (UTILITIES::modifyNamesSort pV1 pV2 (cdr x)))) 
      (svref pV3 2)))) 
   (error "Nonexhaustive match failure in modifyNamesSortInfo")))

(defun UTILITIES::modifyNamesSortInfo-1 (x) 
  (UTILITIES::modifyNamesSortInfo (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::modifyNamesTerm-1 (x) 
  (UTILITIES::modifyNamesTerm (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::modifyNamesVar-1 (x) 
  (UTILITIES::modifyNamesVar (svref x 0) (svref x 1) (svref x 2)))

(defparameter UTILITIES::natSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Nat" "Nat" nil))

(defun UTILITIES::occurs-1 (x) (UTILITIES::occurs (car x) (cdr x)))

(defun UTILITIES::occursT-1 (x) (UTILITIES::occursT (car x) (cdr x)))

(defun UTILITIES::patternVars (p) 
  (labels 
    ((loopP (p vs) 
      (block 
       nil 
       (if (eq (car p) :|VarPat|) 
           (return (LIST-SPEC::|!cons| (car (cdr p)) vs)) 
           (if (eq (car p) :|RecordPat|) 
               (return 
                (LIST-SPEC::foldr-1-1-1 
                 #'(lambda (x) 
                    (block 
                     nil 
                     (return (loopP (cdr (car x)) (cdr x))) 
                     (error "Nonexhaustive match failure in patternVars"))) 
                 vs 
                 (car (cdr p)))) 
               (if (eq (car p) :|EmbedPat|) 
                   (let ((pV37 (svref (cdr p) 1))) 
                     (if (eq (car pV37) :|None|) 
                         (return vs) 
                         (if (eq (car pV37) :|Some|) 
                             (return (loopP (cdr pV37) vs))))) 
                   (if (eq (car p) :|QuotientPat|) 
                       (return (loopP (svref (cdr p) 0) vs)) 
                       (if (eq (car p) :|RelaxPat|) 
                           (return (loopP (svref (cdr p) 0) vs)) 
                           (if (eq (car p) :|AliasPat|) 
                               (let ((pV21 (cdr p))) 
                                 (return 
                                  (loopP 
                                   (svref pV21 0) 
                                   (loopP (svref pV21 1) vs)))))))))) 
       (return vs)))) (loopP p nil)))

(defun UTILITIES::removeDefinitions-1 (spc) 
  (vector 
   (svref spc 0) 
   (STRINGMAP::|!map|-1-1 
    #'(lambda (m) 
       (STRINGMAP::|!map|-1-1 
        #'(lambda (x) (vector (svref x 0) (svref x 1) (svref x 2) nil)) 
        m)) 
    (svref spc 1)) 
   STANDARDSPEC::emptyProperties 
   (svref spc 3)))

(defun UTILITIES::removeDefinitions (x0 x1 x2 x3) 
  (UTILITIES::removeDefinitions-1 (vector x0 x1 x2 x3)))

(defun UTILITIES::repBoundVar (pV1 pV2 pV3) 
  (block 
   nil 
   (let ((pV5 (cdr pV1))
         (pV4 (car pV1))) 
     (return 
      (if (STRINGSET::|!member| pV3 pV4) 
          (let ((id2 (STRINGUTILITIES::freshName pV4 pV3))) 
            (let ((sub2 
                   (LIST-SPEC::|!cons| 
                    (cons 
                     (STANDARDSPEC::mkVar pV4 pV5) 
                     (STANDARDSPEC::mkVar id2 pV5)) 
                    pV2))) (vector (cons id2 pV5) sub2 pV3))) 
          (vector (cons pV4 pV5) pV2 pV3)))) 
   (error "Nonexhaustive match failure in repBoundVar")))

(defun UTILITIES::repBoundVar-1 (x) 
  (UTILITIES::repBoundVar (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::repBoundVars (vars sub freeNames) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (let ((pV6 (cdr x))) 
        (block 
         nil 
         (return 
          (let ((pV1 
                 (UTILITIES::repBoundVar (car x) (svref pV6 1) (svref pV6 2)))) 
            (block 
             nil 
             (return 
              (vector 
               (LIST-SPEC::|!cons| (svref pV1 0) (svref pV6 0)) 
               (svref pV1 1) 
               (svref pV1 2))) 
             (error "Nonexhaustive match failure in repBoundVars")))) 
         (error "Nonexhaustive match failure in repBoundVars")))) 
   (vector nil sub freeNames) 
   vars))

(defun UTILITIES::repBoundVars-1 (x) 
  (UTILITIES::repBoundVars (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::repPattern (pat sub freeNames) 
  (block 
   nil 
   (if (eq (car pat) :|VarPat|) 
       (let ((pV48 (cdr pat))) 
         (return 
          (let ((pV1 (UTILITIES::repBoundVar (car pV48) sub freeNames))) 
            (block 
             nil 
             (return 
              (vector 
               (cons :|VarPat| (cons (svref pV1 0) (cdr pV48))) 
               (svref pV1 1) 
               (svref pV1 2))) 
             (error "Nonexhaustive match failure in repPattern"))))) 
       (if (eq (car pat) :|RecordPat|) 
           (let ((pV47 (cdr pat))) 
             (return 
              (let ((pV16 
                     (LIST-SPEC::foldr-1-1-1 
                      #'(lambda (x) 
                         (let ((pV10 (cdr x))
                               (pV9 (car x))) 
                           (block 
                            nil 
                            (return 
                             (let ((pV5 
                                    (UTILITIES::repPattern 
                                     (cdr pV9) 
                                     (svref pV10 1) 
                                     (svref pV10 2)))) 
                               (block 
                                nil 
                                (return 
                                 (vector 
                                  (LIST-SPEC::|!cons| 
                                   (cons (car pV9) (svref pV5 0)) 
                                   (svref pV10 0)) 
                                  (svref pV5 1) 
                                  (svref pV5 2))) 
                                (error 
                                 "Nonexhaustive match failure in repPattern")))) 
                            (error "Nonexhaustive match failure in repPattern")))) 
                      (vector nil sub freeNames) 
                      (car pV47)))) 
                (block 
                 nil 
                 (return 
                  (vector 
                   (cons :|RecordPat| (cons (svref pV16 0) (cdr pV47))) 
                   (svref pV16 1) 
                   (svref pV16 2))) 
                 (error "Nonexhaustive match failure in repPattern"))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV46 (cdr pat))) 
                 (let ((pV59 (svref pV46 1))) 
                   (if (eq (car pV59) :|Some|) 
                       (return 
                        (let ((pV20 
                               (UTILITIES::repPattern (cdr pV59) sub freeNames))) 
                          (block 
                           nil 
                           (return 
                            (vector 
                             (cons 
                              :|EmbedPat| 
                              (vector 
                               (svref pV46 0) 
                               (cons :|Some| (svref pV20 0)) 
                               (svref pV46 2) 
                               (svref pV46 3))) 
                             (svref pV20 1) 
                             (svref pV20 2))) 
                           (error "Nonexhaustive match failure in repPattern")))) 
                       (if (eq (car pV59) :|None|) 
                           (return (vector pat sub freeNames)))))) 
               (if (eq (car pat) :|AliasPat|) 
                   (let ((pV45 (cdr pat))) 
                     (return 
                      (let ((pV29 
                             (UTILITIES::repPattern (svref pV45 0) sub freeNames))) 
                        (block 
                         nil 
                         (return 
                          (let ((pV25 
                                 (UTILITIES::repPattern 
                                  (svref pV45 1) 
                                  (svref pV29 1) 
                                  (svref pV29 2)))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|AliasPat| 
                                (vector 
                                 (svref pV29 0) 
                                 (svref pV25 0) 
                                 (svref pV45 2))) 
                               (svref pV25 1) 
                               (svref pV25 2))) 
                             (error "Nonexhaustive match failure in repPattern")))) 
                         (error "Nonexhaustive match failure in repPattern"))))) 
                   (if (eq (car pat) :|QuotientPat|) 
                       (let ((pV44 (cdr pat))) 
                         (return 
                          (let ((pV33 
                                 (UTILITIES::repPattern 
                                  (svref pV44 0) 
                                  sub 
                                  freeNames))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|QuotientPat| 
                                (vector 
                                 (svref pV33 0) 
                                 (svref pV44 1) 
                                 (svref pV44 2))) 
                               (svref pV33 1) 
                               (svref pV33 2))) 
                             (error "Nonexhaustive match failure in repPattern"))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV43 (cdr pat))) 
                             (return 
                              (let ((pV37 
                                     (UTILITIES::repPattern 
                                      (svref pV43 0) 
                                      sub 
                                      freeNames))) 
                                (block 
                                 nil 
                                 (return 
                                  (vector 
                                   (cons 
                                    :|RelaxPat| 
                                    (vector 
                                     (svref pV37 0) 
                                     (svref pV43 1) 
                                     (svref pV43 2))) 
                                   (svref pV37 1) 
                                   (svref pV37 2))) 
                                 (error 
                                  "Nonexhaustive match failure in repPattern"))))))))))) 
   (return (vector pat sub freeNames))))

(defun UTILITIES::repPattern-1 (x) 
  (UTILITIES::repPattern (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::replace2 (|!M| sub freeNames) 
  (labels 
    ((repLet (pV57 pV58) 
      (block 
       nil 
       (return 
        (let ((pV53 
               (UTILITIES::repPattern (car pV57) (svref pV58 2) (svref pV58 1)))) 
          (block 
           nil 
           (return 
            (vector 
             (LIST-SPEC::|!cons| (cons (svref pV53 0) (cdr pV57)) (svref pV58 0)) 
             (svref pV53 2) 
             (svref pV53 1))) 
           (error "Nonexhaustive match failure in replace2")))) 
       (error "Nonexhaustive match failure in replace2")))
     (repRule (pat |!cond| term) 
      (let ((pV49 (UTILITIES::repPattern pat sub freeNames))) 
        (block 
         nil 
         (let ((pV52 (svref pV49 2))
               (pV51 (svref pV49 1))
               (pV50 (svref pV49 0))) 
           (return 
            (if (LIST-SPEC::|!null| pV51) 
                (vector pV50 |!cond| term) 
                (vector 
                 pV50 
                 (UTILITIES::replace2 |!cond| pV51 pV52) 
                 (UTILITIES::replace2 term pV51 pV52))))) 
         (error "Nonexhaustive match failure in replace2"))))
     (rep (|!M|) 
      (let ((pV47 
             (UTILITIES::lookup 
              #'(lambda (|!N|) (slang-built-in::slang-term-equals |!N| |!M|)) 
              sub))) 
        (block 
         nil 
         (if (eq (car pV47) :|Some|) 
             (return (cdr pV47)) 
             (if (eq (car pV47) :|None|) 
                 (return 
                  (block 
                   nil 
                   (if (eq (car |!M|) :|Apply|) 
                       (let ((pV23 (cdr |!M|))) 
                         (return 
                          (cons 
                           :|Apply| 
                           (vector 
                            (rep (svref pV23 0)) 
                            (rep (svref pV23 1)) 
                            (svref pV23 2))))) 
                       (if (eq (car |!M|) :|Record|) 
                           (let ((pV22 (cdr |!M|))) 
                             (return 
                              (cons 
                               :|Record| 
                               (cons 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (x) (cons (car x) (rep (cdr x)))) 
                                 (car pV22)) 
                                (cdr pV22))))) 
                           (if (eq (car |!M|) :|Let|) 
                               (let ((pV21 (cdr |!M|))) 
                                 (return 
                                  (let ((decls 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) 
                                             (cons (car x) (rep (cdr x)))) 
                                          (svref pV21 0)))) 
                                    (let ((pV1 
                                           (LIST-SPEC::foldr-1-1-1 
                                            #'(lambda (x) 
                                               (repLet (car x) (cdr x))) 
                                            (vector nil freeNames sub) 
                                            decls))) 
                                      (block 
                                       nil 
                                       (return 
                                        (cons 
                                         :|Let| 
                                         (vector 
                                          (svref pV1 0) 
                                          (UTILITIES::replace2 
                                           (svref pV21 1) 
                                           (svref pV1 2) 
                                           (svref pV1 1)) 
                                          (svref pV21 2)))) 
                                       (error 
                                        "Nonexhaustive match failure in replace2")))))) 
                               (if (eq (car |!M|) :|LetRec|) 
                                   (let ((pV20 (cdr |!M|))) 
                                     (let ((pV36 (svref pV20 0))) 
                                       (return 
                                        (let ((pV7 
                                               (UTILITIES::repBoundVars 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (x) (car x)) 
                                                 pV36) 
                                                sub 
                                                freeNames))) 
                                          (block 
                                           nil 
                                           (let ((pV10 (svref pV7 2))
                                                 (pV9 (svref pV7 1))) 
                                             (return 
                                              (let ((terms 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (UTILITIES::replace2 
                                                          (cdr x) 
                                                          pV9 
                                                          pV10)) 
                                                      pV36))) 
                                                (let ((decls 
                                                       (LISTPAIR::zip 
                                                        (svref pV7 0) 
                                                        terms))) 
                                                  (cons 
                                                   :|LetRec| 
                                                   (vector 
                                                    decls 
                                                    (UTILITIES::replace2 
                                                     (svref pV20 1) 
                                                     pV9 
                                                     pV10) 
                                                    (svref pV20 2))))))) 
                                           (error 
                                            "Nonexhaustive match failure in replace2")))))) 
                                   (if (eq (car |!M|) :|Lambda|) 
                                       (let ((pV19 (cdr |!M|))) 
                                         (return 
                                          (cons 
                                           :|Lambda| 
                                           (cons 
                                            (LIST-SPEC::|!map|-1-1 
                                             #'(lambda (x) 
                                                (repRule 
                                                 (svref x 0) 
                                                 (svref x 1) 
                                                 (svref x 2))) 
                                             (car pV19)) 
                                            (cdr pV19))))) 
                                       (if (eq (car |!M|) :|Bind|) 
                                           (let ((pV18 (cdr |!M|))) 
                                             (return 
                                              (let ((pV11 
                                                     (UTILITIES::repBoundVars 
                                                      (svref pV18 1) 
                                                      sub 
                                                      freeNames))) 
                                                (block 
                                                 nil 
                                                 (return 
                                                  (cons 
                                                   :|Bind| 
                                                   (vector 
                                                    (svref pV18 0) 
                                                    (svref pV11 0) 
                                                    (UTILITIES::replace2 
                                                     (svref pV18 2) 
                                                     (svref pV11 1) 
                                                     (svref pV11 2)) 
                                                    (svref pV18 3)))) 
                                                 (error 
                                                  "Nonexhaustive match failure in replace2"))))) 
                                           (if (eq (car |!M|) :|Seq|) 
                                               (let ((pV17 (cdr |!M|))) 
                                                 (return 
                                                  (cons 
                                                   :|Seq| 
                                                   (cons 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'rep 
                                                     (car pV17)) 
                                                    (cdr pV17))))) 
                                               (if (eq (car |!M|) :|IfThenElse|) 
                                                   (let ((pV16 (cdr |!M|))) 
                                                     (return 
                                                      (cons 
                                                       :|IfThenElse| 
                                                       (vector 
                                                        (rep (svref pV16 0)) 
                                                        (rep (svref pV16 1)) 
                                                        (rep (svref pV16 2)) 
                                                        (svref pV16 3))))))))))))) 
                   (return |!M|))))) 
         (error "Nonexhaustive match failure in replace2"))))) (rep |!M|)))

(defun UTILITIES::|!replace| (|!M| sub) 
  (if (LIST-SPEC::|!null| sub) 
      |!M| 
      (let ((freeNames 
             (LIST-SPEC::foldr-1-1-1 
              #'(lambda (x) 
                 (block 
                  nil 
                  (return 
                   (STRINGSET::|!union| 
                    (STRINGSET::fromList 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x1) (car x1)) 
                      (UTILITIES::freeVars (cdr (car x))))) 
                    (cdr x))) 
                  (error "Nonexhaustive match failure in replace"))) 
              STRINGSET::empty 
              sub))) (UTILITIES::replace2 |!M| sub freeNames))))

(defun UTILITIES::|!replace|-1 (x) (UTILITIES::|!replace| (car x) (cdr x)))

(defun UTILITIES::replace2-1 (x) 
  (UTILITIES::replace2 (svref x 0) (svref x 1) (svref x 2)))

(defparameter UTILITIES::report_unimplemented_for_cgen nil)

(defun UTILITIES::sameCPSort?-1 (x) (UTILITIES::sameCPSort? (car x) (cdr x)))

(defun UTILITIES::specEqual? (s1 s2) 
  (cl:and 
   (slang-built-in::slang-term-equals (svref s1 2) (svref s2 2)) 
   (cl:and 
    (slang-built-in::slang-term-equals 
     (STRINGMAP::toList (svref s1 3)) 
     (STRINGMAP::toList (svref s2 3))) 
    (slang-built-in::slang-term-equals 
     (STRINGMAP::toList (svref s1 1)) 
     (STRINGMAP::toList (svref s2 1))))))

(defun UTILITIES::specEqual?-1 (x) (UTILITIES::specEqual? (car x) (cdr x)))

(defparameter UTILITIES::stringSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "String" "String" nil))

(defun UTILITIES::subspec? (s1 s2) 
  (cl:and 
   (LISTUTILITIES::subset? (svref s1 2) (svref s2 2)) 
   (cl:and 
    (STRINGMAP::subset? (svref s1 3) (svref s2 3)) 
    (STRINGMAP::subset? (svref s1 1) (svref s2 1)))))

(defun UTILITIES::subspec?-1 (x) (UTILITIES::subspec? (car x) (cdr x)))

(defun UTILITIES::substBoundVar (pV1 pV2 pV3) 
  (block 
   nil 
   (let ((pV5 (cdr pV1))
         (pV4 (car pV1))) 
     (return 
      (if (STRINGSET::|!member| pV3 pV4) 
          (let ((id2 (STRINGUTILITIES::freshName pV4 pV3))) 
            (let ((sub2 
                   (LIST-SPEC::|!cons| 
                    (cons (cons pV4 pV5) (STANDARDSPEC::mkVar id2 pV5)) 
                    pV2))) (vector (cons id2 pV5) sub2 pV3))) 
          (vector 
           (cons pV4 pV5) 
           (UTILITIES::deleteVar (cons pV4 pV5) pV2 nil) 
           pV3)))) 
   (error "Nonexhaustive match failure in substBoundVar")))

(defun UTILITIES::substBoundVar-1 (x) 
  (UTILITIES::substBoundVar (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::substBoundVars (vars sub freeNames) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (let ((pV6 (cdr x))) 
        (block 
         nil 
         (return 
          (let ((pV1 
                 (UTILITIES::substBoundVar (car x) (svref pV6 1) (svref pV6 2)))) 
            (block 
             nil 
             (return 
              (vector 
               (LIST-SPEC::|!cons| (svref pV1 0) (svref pV6 0)) 
               (svref pV1 1) 
               (svref pV1 2))) 
             (error "Nonexhaustive match failure in substBoundVars")))) 
         (error "Nonexhaustive match failure in substBoundVars")))) 
   (vector nil sub freeNames) 
   vars))

(defun UTILITIES::substBoundVars-1 (x) 
  (UTILITIES::substBoundVars (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::substPattern (pat sub freeNames) 
  (block 
   nil 
   (if (eq (car pat) :|VarPat|) 
       (let ((pV48 (cdr pat))) 
         (return 
          (let ((pV1 (UTILITIES::substBoundVar (car pV48) sub freeNames))) 
            (block 
             nil 
             (return 
              (vector 
               (cons :|VarPat| (cons (svref pV1 0) (cdr pV48))) 
               (svref pV1 1) 
               (svref pV1 2))) 
             (error "Nonexhaustive match failure in substPattern"))))) 
       (if (eq (car pat) :|RecordPat|) 
           (let ((pV47 (cdr pat))) 
             (return 
              (let ((pV16 
                     (LIST-SPEC::foldr-1-1-1 
                      #'(lambda (x) 
                         (let ((pV10 (cdr x))
                               (pV9 (car x))) 
                           (block 
                            nil 
                            (return 
                             (let ((pV5 
                                    (UTILITIES::substPattern 
                                     (cdr pV9) 
                                     (svref pV10 1) 
                                     (svref pV10 2)))) 
                               (block 
                                nil 
                                (return 
                                 (vector 
                                  (LIST-SPEC::|!cons| 
                                   (cons (car pV9) (svref pV5 0)) 
                                   (svref pV10 0)) 
                                  (svref pV5 1) 
                                  (svref pV5 2))) 
                                (error 
                                 "Nonexhaustive match failure in substPattern")))) 
                            (error "Nonexhaustive match failure in substPattern")))) 
                      (vector nil sub freeNames) 
                      (car pV47)))) 
                (block 
                 nil 
                 (return 
                  (vector 
                   (cons :|RecordPat| (cons (svref pV16 0) (cdr pV47))) 
                   (svref pV16 1) 
                   (svref pV16 2))) 
                 (error "Nonexhaustive match failure in substPattern"))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV46 (cdr pat))) 
                 (let ((pV59 (svref pV46 1))) 
                   (if (eq (car pV59) :|Some|) 
                       (return 
                        (let ((pV20 
                               (UTILITIES::substPattern (cdr pV59) sub freeNames))) 
                          (block 
                           nil 
                           (return 
                            (vector 
                             (cons 
                              :|EmbedPat| 
                              (vector 
                               (svref pV46 0) 
                               (cons :|Some| (svref pV20 0)) 
                               (svref pV46 2) 
                               (svref pV46 3))) 
                             (svref pV20 1) 
                             (svref pV20 2))) 
                           (error "Nonexhaustive match failure in substPattern")))) 
                       (if (eq (car pV59) :|None|) 
                           (return (vector pat sub freeNames)))))) 
               (if (eq (car pat) :|AliasPat|) 
                   (let ((pV45 (cdr pat))) 
                     (return 
                      (let ((pV29 
                             (UTILITIES::substPattern 
                              (svref pV45 0) 
                              sub 
                              freeNames))) 
                        (block 
                         nil 
                         (return 
                          (let ((pV25 
                                 (UTILITIES::substPattern 
                                  (svref pV45 1) 
                                  (svref pV29 1) 
                                  (svref pV29 2)))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|AliasPat| 
                                (vector 
                                 (svref pV29 0) 
                                 (svref pV25 0) 
                                 (svref pV45 2))) 
                               (svref pV25 1) 
                               (svref pV25 2))) 
                             (error 
                              "Nonexhaustive match failure in substPattern")))) 
                         (error "Nonexhaustive match failure in substPattern"))))) 
                   (if (eq (car pat) :|QuotientPat|) 
                       (let ((pV44 (cdr pat))) 
                         (return 
                          (let ((pV33 
                                 (UTILITIES::substPattern 
                                  (svref pV44 0) 
                                  sub 
                                  freeNames))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|QuotientPat| 
                                (vector 
                                 (svref pV33 0) 
                                 (svref pV44 1) 
                                 (svref pV44 2))) 
                               (svref pV33 1) 
                               (svref pV33 2))) 
                             (error 
                              "Nonexhaustive match failure in substPattern"))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV43 (cdr pat))) 
                             (return 
                              (let ((pV37 
                                     (UTILITIES::substPattern 
                                      (svref pV43 0) 
                                      sub 
                                      freeNames))) 
                                (block 
                                 nil 
                                 (return 
                                  (vector 
                                   (cons 
                                    :|RelaxPat| 
                                    (vector 
                                     (svref pV37 0) 
                                     (svref pV43 1) 
                                     (svref pV43 2))) 
                                   (svref pV37 1) 
                                   (svref pV37 2))) 
                                 (error 
                                  "Nonexhaustive match failure in substPattern"))))))))))) 
   (return (vector pat sub freeNames))))

(defun UTILITIES::substPattern-1 (x) 
  (UTILITIES::substPattern (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::substitute2 (|!M| sub freeNames) 
  (labels 
    ((substLet (pV67 pV68) 
      (block 
       nil 
       (return 
        (let ((pV63 
               (UTILITIES::substPattern (car pV67) (svref pV68 2) (svref pV68 1)))) 
          (block 
           nil 
           (return 
            (vector 
             (LIST-SPEC::|!cons| (cons (svref pV63 0) (cdr pV67)) (svref pV68 0)) 
             (svref pV63 2) 
             (svref pV63 1))) 
           (error "Nonexhaustive match failure in substitute2")))) 
       (error "Nonexhaustive match failure in substitute2")))
     (substRule (pat |!cond| term) 
      (let ((pV59 (UTILITIES::substPattern pat sub freeNames))) 
        (block 
         nil 
         (let ((pV62 (svref pV59 2))
               (pV61 (svref pV59 1))
               (pV60 (svref pV59 0))) 
           (return 
            (if (LIST-SPEC::|!null| pV61) 
                (vector pV60 |!cond| term) 
                (vector 
                 pV60 
                 (UTILITIES::substitute2 |!cond| pV61 pV62) 
                 (UTILITIES::substitute2 term pV61 pV62))))) 
         (error "Nonexhaustive match failure in substitute2"))))
     (|!subst| (|!M|) 
      (block 
       nil 
       (if (eq (car |!M|) :|Var|) 
           (let ((pV57 (car (car (cdr |!M|))))) 
             (return 
              (let ((pV3 
                     (UTILITIES::lookup 
                      #'(lambda (x) (string=  pV57 (car x))) 
                      sub))) 
                (block 
                 nil 
                 (if (eq (car pV3) :|None|) 
                     (return |!M|) 
                     (if (eq (car pV3) :|Some|) (return (cdr pV3)))) 
                 (error "Nonexhaustive match failure in substitute2"))))) 
           (if (eq (car |!M|) :|Apply|) 
               (let ((pV30 (cdr |!M|))) 
                 (return 
                  (cons 
                   :|Apply| 
                   (vector 
                    (|!subst| (svref pV30 0)) 
                    (|!subst| (svref pV30 1)) 
                    (svref pV30 2))))) 
               (if (eq (car |!M|) :|Record|) 
                   (let ((pV29 (cdr |!M|))) 
                     (return 
                      (cons 
                       :|Record| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) (cons (car x) (|!subst| (cdr x)))) 
                         (car pV29)) 
                        (cdr pV29))))) 
                   (if (eq (car |!M|) :|Fun|) 
                       (return |!M|) 
                       (if (eq (car |!M|) :|Lambda|) 
                           (let ((pV27 (cdr |!M|))) 
                             (return 
                              (cons 
                               :|Lambda| 
                               (cons 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (x) 
                                    (substRule 
                                     (svref x 0) 
                                     (svref x 1) 
                                     (svref x 2))) 
                                 (car pV27)) 
                                (cdr pV27))))) 
                           (if (eq (car |!M|) :|Let|) 
                               (let ((pV26 (cdr |!M|))) 
                                 (return 
                                  (let ((decls 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) 
                                             (cons (car x) (|!subst| (cdr x)))) 
                                          (svref pV26 0)))) 
                                    (let ((pV7 
                                           (LIST-SPEC::foldr-1-1-1 
                                            #'(lambda (x) 
                                               (substLet (car x) (cdr x))) 
                                            (vector nil freeNames sub) 
                                            decls))) 
                                      (block 
                                       nil 
                                       (return 
                                        (cons 
                                         :|Let| 
                                         (vector 
                                          (svref pV7 0) 
                                          (UTILITIES::substitute2 
                                           (svref pV26 1) 
                                           (svref pV7 2) 
                                           (svref pV7 1)) 
                                          (svref pV26 2)))) 
                                       (error 
                                        "Nonexhaustive match failure in substitute2")))))) 
                               (if (eq (car |!M|) :|LetRec|) 
                                   (let ((pV25 (cdr |!M|))) 
                                     (let ((pV42 (svref pV25 0))) 
                                       (return 
                                        (let ((pV13 
                                               (UTILITIES::substBoundVars 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (x) (car x)) 
                                                 pV42) 
                                                sub 
                                                freeNames))) 
                                          (block 
                                           nil 
                                           (let ((pV16 (svref pV13 2))
                                                 (pV15 (svref pV13 1))) 
                                             (return 
                                              (let ((terms 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (UTILITIES::substitute2 
                                                          (cdr x) 
                                                          pV15 
                                                          pV16)) 
                                                      pV42))) 
                                                (let ((decls 
                                                       (LISTPAIR::zip 
                                                        (svref pV13 0) 
                                                        terms))) 
                                                  (cons 
                                                   :|LetRec| 
                                                   (vector 
                                                    decls 
                                                    (UTILITIES::substitute2 
                                                     (svref pV25 1) 
                                                     pV15 
                                                     pV16) 
                                                    (svref pV25 2))))))) 
                                           (error 
                                            "Nonexhaustive match failure in substitute2")))))) 
                                   (if (eq (car |!M|) :|Bind|) 
                                       (let ((pV24 (cdr |!M|))) 
                                         (return 
                                          (let ((pV17 
                                                 (UTILITIES::substBoundVars 
                                                  (svref pV24 1) 
                                                  sub 
                                                  freeNames))) 
                                            (block 
                                             nil 
                                             (return 
                                              (cons 
                                               :|Bind| 
                                               (vector 
                                                (svref pV24 0) 
                                                (svref pV17 0) 
                                                (UTILITIES::substitute2 
                                                 (svref pV24 2) 
                                                 (svref pV17 1) 
                                                 (svref pV17 2)) 
                                                (svref pV24 3)))) 
                                             (error 
                                              "Nonexhaustive match failure in substitute2"))))) 
                                       (if (eq (car |!M|) :|IfThenElse|) 
                                           (let ((pV23 (cdr |!M|))) 
                                             (return 
                                              (cons 
                                               :|IfThenElse| 
                                               (vector 
                                                (|!subst| (svref pV23 0)) 
                                                (|!subst| (svref pV23 1)) 
                                                (|!subst| (svref pV23 2)) 
                                                (svref pV23 3))))) 
                                           (if (eq (car |!M|) :|Seq|) 
                                               (let ((pV22 (cdr |!M|))) 
                                                 (return 
                                                  (cons 
                                                   :|Seq| 
                                                   (cons 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'|!subst| 
                                                     (car pV22)) 
                                                    (cdr pV22))))))))))))))) 
       (error "Nonexhaustive match failure in substitute2")))) 
    (let ((M1 (|!subst| |!M|))) M1)))

(defun UTILITIES::|!substitute| (|!M| sub) 
  (if (LIST-SPEC::|!null| sub) 
      |!M| 
      (let ((freeNames 
             (LIST-SPEC::foldr-1-1-1 
              #'(lambda (x) 
                 (block 
                  nil 
                  (return 
                   (STRINGSET::|!union| 
                    (STRINGSET::fromList 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x1) (car x1)) 
                      (UTILITIES::freeVars (cdr (car x))))) 
                    (cdr x))) 
                  (error "Nonexhaustive match failure in substitute"))) 
              STRINGSET::empty 
              sub))) (UTILITIES::substitute2 |!M| sub freeNames))))

(defun UTILITIES::|!substitute|-1 (x) 
  (UTILITIES::|!substitute| (car x) (cdr x)))

(defun UTILITIES::substitute2-1 (x) 
  (UTILITIES::substitute2 (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::substituteType2 (srt |!S| freeNames) 
  (labels 
    ((|!subst| (s) 
      (block 
       nil 
       (if (eq (car s) :|Base|) 
           (let ((pV8 (cdr s))) 
             (return 
              (cons 
               :|Base| 
               (vector 
                (svref pV8 0) 
                (LIST-SPEC::|!map|-1-1 #'|!subst| (svref pV8 1)) 
                (svref pV8 2))))) 
           (if (eq (car s) :|Arrow|) 
               (let ((pV7 (cdr s))) 
                 (return 
                  (cons 
                   :|Arrow| 
                   (vector 
                    (|!subst| (svref pV7 0)) 
                    (|!subst| (svref pV7 1)) 
                    (svref pV7 2))))) 
               (if (eq (car s) :|Product|) 
                   (let ((pV6 (cdr s))) 
                     (return 
                      (cons 
                       :|Product| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) (cons (car x) (|!subst| (cdr x)))) 
                         (car pV6)) 
                        (cdr pV6))))) 
                   (if (eq (car s) :|CoProduct|) 
                       (let ((pV5 (cdr s))) 
                         (return 
                          (cons 
                           :|CoProduct| 
                           (cons 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (car x) 
                                 (OPTION::mapOption-1-1 #'|!subst| (cdr x)))) 
                             (car pV5)) 
                            (cdr pV5))))) 
                       (if (eq (car s) :|Subsort|) 
                           (let ((pV4 (cdr s))) 
                             (return 
                              (cons 
                               :|Subsort| 
                               (vector 
                                (|!subst| (svref pV4 0)) 
                                (UTILITIES::substitute2 
                                 (svref pV4 1) 
                                 |!S| 
                                 freeNames) 
                                (svref pV4 2))))) 
                           (if (eq (car s) :|Quotient|) 
                               (let ((pV3 (cdr s))) 
                                 (return 
                                  (cons 
                                   :|Quotient| 
                                   (vector 
                                    (|!subst| (svref pV3 0)) 
                                    (UTILITIES::substitute2 
                                     (svref pV3 1) 
                                     |!S| 
                                     freeNames) 
                                    (svref pV3 2))))) 
                               (if (eq (car s) :|TyVar|) 
                                   (let ((pV2 (cdr s))) 
                                     (return 
                                      (cons :|TyVar| (cons (car pV2) (cdr pV2)))))))))))) 
       (error "Nonexhaustive match failure in substituteType2")))) 
    (|!subst| srt)))

(defun UTILITIES::substituteType (srt |!S|) 
  (let ((freeNames 
         (LIST-SPEC::foldr-1-1-1 
          #'(lambda (x) 
             (block 
              nil 
              (return 
               (STRINGSET::|!union| 
                (STRINGSET::fromList 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x1) (car x1)) 
                  (UTILITIES::freeVars (cdr (car x))))) 
                (cdr x))) 
              (error "Nonexhaustive match failure in substituteType"))) 
          STRINGSET::empty 
          |!S|))) (UTILITIES::substituteType2 srt |!S| freeNames)))

(defun UTILITIES::substituteType-1 (x) 
  (UTILITIES::substituteType (car x) (cdr x)))

(defun UTILITIES::substituteType2-1 (x) 
  (UTILITIES::substituteType2 (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::unfoldPSort-1 (x) (UTILITIES::unfoldPSort (car x) (cdr x)))

(defun UTILITIES::unfoldPSortRec-1 (x) 
  (UTILITIES::unfoldPSortRec (svref x 0) (svref x 1) (svref x 2)))

(defun UTILITIES::unifyL-1 (x) 
  (UTILITIES::unifyL 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))

(defun UTILITIES::unifySorts-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (UTILITIES::unifySorts-1-1-1 x1 x2 x3))))

(defun UTILITIES::unifySorts (x0 x1 x2 x3 x4 x5 x6) 
  (UTILITIES::unifySorts-1 (vector x0 x1 x2 x3 x4 x5 x6)))

(defun UTILITIES::unlinkMetaTyVar (tv) 
  (let ((x (STATE::|!!| tv))) 
    (let ((pV3 (svref x 0))) 
      (block 
       nil 
       (if (eq (car pV3) :|Some|) 
           (let ((pV6 (cdr pV3))) 
             (if (eq (car pV6) :|MetaTyVar|) 
                 (return (UTILITIES::unlinkMetaTyVar (car (cdr pV6))))))) 
       (return tv)))))

(defun UTILITIES::unlinkRec (srt) 
  (METASLANG::mapSort-1-1 
   (vector 
    #'(lambda (x) x) 
    #'(lambda (s) (UTILITIES::unlinkPSort s)) 
    #'(lambda (x) x)) 
   srt))

(defun VERTEX::|!delete| (x) (POLYSET::|!delete| x))

(defun VERTEX::|!delete|-1-1 (x0 x1) (POLYSET::|!delete|-1-1 x0 x1))

(defun VERTEX::empty? (x) (POLYSET::empty? x))

(defun VERTEX::fold (x) (POLYSET::fold x))

(defun VERTEX::insert (x) (POLYSET::insert x))

(defun VERTEX::|!map| (x) (POLYSET::|!map| x))

(defun VERTEX::|!map|-1-1 (x0 x1) (POLYSET::|!map|-1-1 x0 x1))

(defun VERTEX::member? (x) (POLYSET::member? x))

(defun VERTEX::singleton (x) (POLYSET::singleton x))

(defun VERTEX::toList (x) (POLYSET::toList x))

(defun VERTEX::|!union| (x) (POLYSET::|!union| x))

(defun VERTEX::|!union|-1-1 (x0 x1) (POLYSET::|!union|-1-1 x0 x1))

(defun WADLERLINDIG::breakWith (s) (cons :|DocBreak| s))

(defun WADLERLINDIG::ppAppend (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppAppend-1-1 x1 x2)))

(defun WADLERLINDIG::ppBest (x1) 
  #'(lambda (x2) #'(lambda (x3) (WADLERLINDIG::ppBest-1-1-1 x1 x2 x3))))

(defun WADLERLINDIG::ppCons (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppCons-1-1 x1 x2)))

(defun WADLERLINDIG::ppFits (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppFits-1-1 x1 x2)))

(defun WADLERLINDIG::ppFormatWidth (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppFormatWidth-1-1 x1 x2)))

(defun WADLERLINDIG::ppNest (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppNest-1-1 x1 x2)))

(defun WADLERLINDIG::ppSep (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppSep-1-1 x1 x2)))
