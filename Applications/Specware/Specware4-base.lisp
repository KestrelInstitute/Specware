
;;; Lisp spec

(defpackage "ANNSPECPRINTER")
(defpackage "ANNTERMPRINTER")
(defpackage "ARITYNORMALIZE")
(defpackage "BOOLEAN-SPEC")
(defpackage "CGEN")
(defpackage "CAT")
(defpackage "CHAR-SPEC")
(defpackage "COMPARE")
(defpackage "EDGE")
(defpackage "FUNCTIONS")
(defpackage "FUNCTOR")
(defpackage "HASHTABLE")
(defpackage "IO-SPEC")
(defpackage "INFIX")
(defpackage "INTEGER-SPEC")
(defpackage "INTEGERSET")
(defpackage "LISP-SPEC")
(defpackage "LISP-SPEC")
(defpackage "LIST-SPEC")
(defpackage "LISTADT")
(defpackage "LISTPAIR")
(defpackage "LISTUTILITIES")
(defpackage "MFSET")
(defpackage "MERGESORT")
(defpackage "METASLANG")
(defpackage "NAT-SPEC")
(defpackage "NATMAP")
(defpackage "NATTRANS")
(defpackage "OPTION")
(defpackage "PATTERNMATCH")
(defpackage "POLYMAP")
(defpackage "POLYSET")
(defpackage "POSSPEC")
(defpackage "POSSPECTOSPEC")
(defpackage "POSITION-SPEC")
(defpackage "PRETTYPRINT")
(defpackage "SKETCH")
(defpackage "SPECCALC")
(defpackage "SPECENVIRONMENT")
(defpackage "SPECTOLISP")
(defpackage "SPECTOPOSSPEC")
(defpackage "SPECUNION")
(defpackage "SPECWARE")
(defpackage "SPLAYMAP")
(defpackage "SPLAYSET")
(defpackage "SPLAYTREE")
(defpackage "STANDARDSPEC")
(defpackage "STATE")
(defpackage "STRING-SPEC")
(defpackage "STRINGMAP")
(defpackage "STRINGSET")
(defpackage "STRINGUTILITIES")
(defpackage "SYSTEM-SPEC")
(defpackage "TOPSORT")
(defpackage "TYPECHECKER")
(defpackage "TYPEOBLIGATIONS")
(defpackage "UTILITIES")
(defpackage "VERTEX")
(defpackage "WADLERLINDIG")
(defpackage "ANNSPEC")
(in-package "ANNSPEC")

;;; Definitions

(defun LIST-SPEC::|!cons| (a l) (cons a l))
                                           
(defun setProperties (spc new_properties) 
  (vector (svref spc 0) (svref spc 1) new_properties (svref spc 3)))
                                                                    
(defun addProperty (new_property spc) 
  (setProperties spc (LIST-SPEC::|!cons| new_property (svref spc 2))))
                                                                      
(defun addAxiom (pV1 pV2) 
  (block 
   nil 
   (return 
    (addProperty 
     (vector '(:|Axiom|) (svref pV1 0) (svref pV1 1) (svref pV1 2)) 
     pV2)) 
   (error "Nonexhaustive match failure in addAxiom")))
                                                      
(defun addAxiom-1 (x) (addAxiom (car x) (cdr x)))
                                                 
(defun addConjecture (pV6 pV7) 
  (block 
   nil 
   (return 
    (addProperty 
     (vector '(:|Conjecture|) (svref pV6 0) (svref pV6 1) (svref pV6 2)) 
     pV7)) 
   (error "Nonexhaustive match failure in addConjecture")))
                                                           
(defun addConjecture-1 (x) (addConjecture (car x) (cdr x)))
                                                           
(defun LIST-SPEC::foldr-1-1-1 (f base s) 
  (block 
   nil 
   (if (null s) 
       (return base) 
       (if (consp s) 
           (return 
            (funcall f (cons (car s) (LIST-SPEC::foldr-1-1-1 f base (cdr s))))))) 
   (error "Nonexhaustive match failure in foldr")))
                                                   
(defun addConjectures (conjectures spc) 
  (LIST-SPEC::foldr-1-1-1 #'addConjecture-1 spc conjectures))
                                                             
(defun addConjectures-1 (x) (addConjectures (car x) (cdr x)))
                                                             
(defun LIST-SPEC::concat (s1 s2) 
  (block 
   nil 
   (if (null s1) 
       (return s2) 
       (if (consp s1) (return (cons (car s1) (LIST-SPEC::concat (cdr s1) s2))))) 
   (error "Nonexhaustive match failure in concat")))
                                                    
(defun LIST-SPEC::|!++| (s1 s2) (LIST-SPEC::concat s1 s2))
                                                          
(defun setImports (pV143 pV144) 
  (block 
   nil 
   (let ((pV145 (svref pV143 0))) 
     (return 
      (vector 
       (vector (svref pV145 0) pV144 (svref pV145 2) (svref pV145 3)) 
       (svref pV143 1) 
       (svref pV143 2) 
       (svref pV143 3)))) 
   (error "Nonexhaustive match failure in setImports")))
                                                        
(defun addImport (pV11 pV12) 
  (block 
   nil 
   (return 
    (setImports 
     pV12 
     (LIST-SPEC::|!cons| (cons (car pV11) (cdr pV11)) (svref (svref pV12 0) 1)))) 
   (error "Nonexhaustive match failure in addImport")))
                                                       
(defun SPLAYMAP::foldriAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV8689 (cdr sp))) 
               (let ((pV8692 (svref pV8689 2))) 
                 (return 
                  (SPLAYMAP::foldriAp-1-1 
                   abf 
                   (cons 
                    (svref pV8689 0) 
                    (funcall abf 
                             (vector 
                              (car pV8692) 
                              (cdr pV8692) 
                              (SPLAYMAP::foldriAp-1-1 
                               abf 
                               (cons (svref pV8689 1) b))))))))))) 
     (error "Nonexhaustive match failure in foldriAp"))))
                                                         
(defun SPLAYMAP::foldri-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldriAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldri")))
                                                    
(defun SPLAYMAP::foldriDouble-1-1-1 (f ob omap) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (let ((key1 (svref x 0))) 
        (SPLAYMAP::foldri-1-1-1 
         #'(lambda (x1) 
            (funcall f (vector key1 (svref x1 0) (svref x1 1) (svref x1 2)))) 
         (svref x 2) 
         (svref x 1)))) 
   ob 
   omap))
         
(defun STRINGMAP::foldriDouble-1-1-1 (x0 x1 x2) 
  (SPLAYMAP::foldriDouble-1-1-1 x0 x1 x2))
                                          
(defun foldriAQualifierMap-1-1-1 (x0 x1 x2) 
  (STRINGMAP::foldriDouble-1-1-1 x0 x1 x2))
                                           
(defun SPLAYMAP::empty (x) (cons :|EMPTY| x))
                                             
(defun STRING-SPEC::compare (n m) 
  (if (STRING-SPEC::lt n m) 
      '(:|Less|) 
      (if (string=  n m) '(:|Equal|) '(:|Greater|))))
                                                     
(defun STRING-SPEC::compare-1 (x) (STRING-SPEC::compare (car x) (cdr x)))
                                                                         
(defparameter STRINGMAP::empty (SPLAYMAP::empty #'STRING-SPEC::compare-1))
                                                                          
(defun SPLAYTREE::mkSplayObj (x1 x0 x) (cons :|SplayObj| (vector x1 x0 x)))
                                                                           
(defun SPLAYTREE::adj-1-1 (compf sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return (vector '(:|No|) '(:|SplayNil|) '(:|SplayNil|))) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV9271 (cdr sp))) 
             (let ((pV9272 (svref pV9271 0))
                   (pV9273 (svref pV9271 1))
                   (pV9274 (svref pV9271 2))) 
               (return 
                (let ((pV9269 (funcall compf pV9274))) 
                  (block 
                   nil 
                   (if (eq (car pV9269) :|Equal|) 
                       (return (vector (cons :|Eq| pV9274) pV9272 pV9273)) 
                       (if (eq (car pV9269) :|Greater|) 
                           (return 
                            (block 
                             nil 
                             (if (eq (car pV9272) :|SplayNil|) 
                                 (return 
                                  (vector 
                                   (cons :|Gt| pV9274) 
                                   '(:|SplayNil|) 
                                   pV9273)) 
                                 (if (eq (car pV9272) :|SplayObj|) 
                                     (let ((pV9245 (cdr pV9272))) 
                                       (let ((pV9246 (svref pV9245 0))
                                             (pV9247 (svref pV9245 1))
                                             (pV9248 (svref pV9245 2))) 
                                         (return 
                                          (let ((pV9243 (funcall compf pV9248))) 
                                            (block 
                                             nil 
                                             (if (eq (car pV9243) :|Equal|) 
                                                 (return 
                                                  (vector 
                                                   (cons :|Eq| pV9248) 
                                                   pV9246 
                                                   (cons 
                                                    :|SplayObj| 
                                                    (vector pV9247 pV9273 pV9274)))) 
                                                 (if (eq (car pV9243) :|Greater|) 
                                                     (return 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV9246) 
                                                            :|SplayNil|) 
                                                           (return 
                                                            (vector 
                                                             (cons :|Gt| pV9248) 
                                                             pV9246 
                                                             (cons 
                                                              :|SplayObj| 
                                                              (vector 
                                                               pV9247 
                                                               pV9273 
                                                               pV9274))))) 
                                                       (return 
                                                        (let ((pV9231 
                                                               (SPLAYTREE::adj-1-1 
                                                                compf 
                                                                pV9246))) 
                                                          (block 
                                                           nil 
                                                           (return 
                                                            (let ((rchild 
                                                                   (SPLAYTREE::mkSplayObj 
                                                                    pV9247 
                                                                    pV9273 
                                                                    pV9274))) 
                                                              (vector 
                                                               (svref pV9231 0) 
                                                               (svref pV9231 1) 
                                                               (cons 
                                                                :|SplayObj| 
                                                                (vector 
                                                                 (svref pV9231 2) 
                                                                 rchild 
                                                                 pV9248))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in adj")))))))) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV9247) :|SplayNil|) 
                                                   (return 
                                                    (vector 
                                                     (cons :|Lt| pV9248) 
                                                     pV9246 
                                                     (cons 
                                                      :|SplayObj| 
                                                      (vector 
                                                       pV9247 
                                                       pV9273 
                                                       pV9274))))) 
                                               (return 
                                                (let ((pV9238 
                                                       (SPLAYTREE::adj-1-1 
                                                        compf 
                                                        pV9247))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (let ((rchild 
                                                           (SPLAYTREE::mkSplayObj 
                                                            (svref pV9238 2) 
                                                            pV9273 
                                                            pV9274))) 
                                                      (let ((lchild 
                                                             (SPLAYTREE::mkSplayObj 
                                                              pV9246 
                                                              (svref pV9238 1) 
                                                              pV9248))) 
                                                        (vector 
                                                         (svref pV9238 0) 
                                                         lchild 
                                                         rchild)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in adj"))))))))))))) 
                             (error "Nonexhaustive match failure in adj"))))) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car pV9273) :|SplayNil|) 
                         (return 
                          (vector (cons :|Lt| pV9274) pV9272 '(:|SplayNil|))) 
                         (if (eq (car pV9273) :|SplayObj|) 
                             (let ((pV9265 (cdr pV9273))) 
                               (let ((pV9266 (svref pV9265 0))
                                     (pV9267 (svref pV9265 1))
                                     (pV9268 (svref pV9265 2))) 
                                 (return 
                                  (let ((pV9263 (funcall compf pV9268))) 
                                    (block 
                                     nil 
                                     (if (eq (car pV9263) :|Equal|) 
                                         (return 
                                          (vector 
                                           (cons :|Eq| pV9268) 
                                           (cons 
                                            :|SplayObj| 
                                            (vector pV9272 pV9266 pV9274)) 
                                           pV9267)) 
                                         (if (eq (car pV9263) :|Less|) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV9267) :|SplayNil|) 
                                                   (return 
                                                    (vector 
                                                     (cons :|Lt| pV9268) 
                                                     (cons 
                                                      :|SplayObj| 
                                                      (vector 
                                                       pV9272 
                                                       pV9266 
                                                       pV9274)) 
                                                     pV9267))) 
                                               (return 
                                                (let ((pV9251 
                                                       (SPLAYTREE::adj-1-1 
                                                        compf 
                                                        pV9267))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (let ((lchild 
                                                           (SPLAYTREE::mkSplayObj 
                                                            pV9272 
                                                            pV9266 
                                                            pV9274))) 
                                                      (vector 
                                                       (svref pV9251 0) 
                                                       (cons 
                                                        :|SplayObj| 
                                                        (vector 
                                                         lchild 
                                                         (svref pV9251 1) 
                                                         pV9268)) 
                                                       (svref pV9251 2)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in adj")))))))) 
                                     (return 
                                      (block 
                                       nil 
                                       (if (eq (car pV9266) :|SplayNil|) 
                                           (return 
                                            (vector 
                                             (cons :|Gt| pV9268) 
                                             (cons 
                                              :|SplayObj| 
                                              (vector pV9272 pV9266 pV9274)) 
                                             pV9267))) 
                                       (return 
                                        (let ((pV9258 
                                               (SPLAYTREE::adj-1-1 compf pV9266))) 
                                          (block 
                                           nil 
                                           (return 
                                            (let ((rchild 
                                                   (SPLAYTREE::mkSplayObj 
                                                    (svref pV9258 2) 
                                                    pV9267 
                                                    pV9268))) 
                                              (let ((lchild 
                                                     (SPLAYTREE::mkSplayObj 
                                                      pV9272 
                                                      (svref pV9258 1) 
                                                      pV9274))) 
                                                (vector 
                                                 (svref pV9258 0) 
                                                 lchild 
                                                 rchild)))) 
                                           (error 
                                            "Nonexhaustive match failure in adj"))))))))))))) 
                     (error "Nonexhaustive match failure in adj")))))))))) 
   (error "Nonexhaustive match failure in adj")))
                                                 
(defun SPLAYTREE::splay (compf root) 
  (let ((x (SPLAYTREE::adj-1-1 compf root))) 
    (let ((pV9295 (svref x 2))
          (pV9294 (svref x 1))
          (pV9293 (svref x 0))) 
      (block 
       nil 
       (if (eq (car pV9293) :|No|) 
           (return (cons '(:|Greater|) '(:|SplayNil|))) 
           (if (eq (car pV9293) :|Eq|) 
               (return 
                (cons 
                 '(:|Equal|) 
                 (cons :|SplayObj| (vector pV9294 pV9295 (cdr pV9293))))) 
               (if (eq (car pV9293) :|Lt|) 
                   (return 
                    (cons 
                     '(:|Less|) 
                     (cons :|SplayObj| (vector pV9294 pV9295 (cdr pV9293))))) 
                   (if (eq (car pV9293) :|Gt|) 
                       (return 
                        (cons 
                         '(:|Greater|) 
                         (cons :|SplayObj| (vector pV9294 pV9295 (cdr pV9293))))))))) 
       (error "Nonexhaustive match failure in splay")))))
                                                         
(defun SPLAYMAP::insert (|!map| key v) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return 
        (cons 
         :|MAP| 
         (vector 
          (cdr |!map|) 
          1 
          (cons 
           :|Ref| 
           (cons :|SplayObj| (vector '(:|SplayNil|) '(:|SplayNil|) (cons key v))))))) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV8719 (cdr |!map|))) 
             (let ((pV8722 (svref pV8719 1))
                   (pV8721 (svref pV8719 0))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        #'(lambda (x) (funcall pV8721 (cons (car x) key))) 
                        (STATE::|!!| (svref pV8719 2))))) 
                  (let ((pV8704 (cdr x))
                        (pV8703 (car x))) 
                    (block 
                     nil 
                     (if (eq (car pV8703) :|Equal|) 
                         (if (eq (car pV8704) :|SplayObj|) 
                             (let ((pV8713 (cdr pV8704))) 
                               (return 
                                (cons 
                                 :|MAP| 
                                 (vector 
                                  pV8721 
                                  pV8722 
                                  (cons 
                                   :|Ref| 
                                   (cons 
                                    :|SplayObj| 
                                    (vector 
                                     (svref pV8713 0) 
                                     (svref pV8713 1) 
                                     (cons key v))))))))) 
                         (if (eq (car pV8703) :|Less|) 
                             (if (eq (car pV8704) :|SplayObj|) 
                                 (let ((pV8709 (cdr pV8704))) 
                                   (return 
                                    (cons 
                                     :|MAP| 
                                     (vector 
                                      pV8721 
                                      (INTEGER-SPEC::|!+| pV8722 1) 
                                      (cons 
                                       :|Ref| 
                                       (cons 
                                        :|SplayObj| 
                                        (vector 
                                         (cons 
                                          :|SplayObj| 
                                          (vector 
                                           (svref pV8709 0) 
                                           '(:|SplayNil|) 
                                           (svref pV8709 2))) 
                                         (svref pV8709 1) 
                                         (cons key v))))))))) 
                             (if (eq (car pV8703) :|Greater|) 
                                 (if (eq (car pV8704) :|SplayObj|) 
                                     (let ((pV8705 (cdr pV8704))) 
                                       (return 
                                        (cons 
                                         :|MAP| 
                                         (vector 
                                          pV8721 
                                          (INTEGER-SPEC::|!+| pV8722 1) 
                                          (cons 
                                           :|Ref| 
                                           (cons 
                                            :|SplayObj| 
                                            (vector 
                                             (svref pV8705 0) 
                                             (cons 
                                              :|SplayObj| 
                                              (vector 
                                               '(:|SplayNil|) 
                                               (svref pV8705 1) 
                                               (svref pV8705 2))) 
                                             (cons key v)))))))))))) 
                     (if (eq (car pV8704) :|SplayNil|) 
                         (return (SYSTEM-SPEC::fail "SplayMap.insert SplayNil"))) 
                     (error "Nonexhaustive match failure in insert"))))))))) 
   (error "Nonexhaustive match failure in insert")))
                                                    
(defun STRINGMAP::insert (x1 x0 x) (SPLAYMAP::insert x1 x0 x))
                                                              
(defun SPLAYMAP::findR (sTree key comp) 
  (block 
   nil 
   (if (eq (car sTree) :|SplayNil|) 
       (return '(:|None|)) 
       (if (eq (car sTree) :|SplayObj|) 
           (let ((pV8633 (cdr sTree))) 
             (let ((pV8636 (svref pV8633 2))) 
               (return 
                (let ((pV8631 (funcall comp (cons key (car pV8636))))) 
                  (block 
                   nil 
                   (if (eq (car pV8631) :|Equal|) 
                       (return (cons :|Some| (cdr pV8636))) 
                       (if (eq (car pV8631) :|Less|) 
                           (return (SPLAYMAP::findR (svref pV8633 0) key comp)))) 
                   (return (SPLAYMAP::findR (svref pV8633 1) key comp))))))))) 
   (error "Nonexhaustive match failure in findR")))
                                                   
(defun SPLAYMAP::|!find| (|!map| key) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return '(:|None|)) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV8625 (cdr |!map|))) 
             (return 
              (SPLAYMAP::findR 
               (STATE::|!!| (svref pV8625 2)) 
               key 
               (svref pV8625 0)))))) 
   (error "Nonexhaustive match failure in find")))
                                                  
(defun STRINGMAP::|!find| (x0 x) (SPLAYMAP::|!find| x0 x))
                                                          
(defun STRINGMAP::insert2 (m x y v) 
  (STRINGMAP::insert 
   m 
   x 
   (STRINGMAP::insert 
    (let ((pV9396 (STRINGMAP::|!find| m x))) 
      (block 
       nil 
       (if (eq (car pV9396) :|Some|) (return (cdr pV9396))) 
       (return STRINGMAP::empty))) 
    y 
    v)))
        
(defun insertAQualifierMap (x2 x1 x0 x) (STRINGMAP::insert2 x2 x1 x0 x))
                                                                        
(defun setOps (spc new_ops) 
  (vector (svref spc 0) new_ops (svref spc 2) (svref spc 3)))
                                                             
(defun setSorts (spc new_sorts) 
  (vector (svref spc 0) (svref spc 1) (svref spc 2) new_sorts))
                                                               
(defun addDisjointImport (spc imported_spec) 
  (labels 
    ((mergeOpStep 
      (imported_qualifier imported_id imported_op_info combined_pops) 
      (insertAQualifierMap 
       combined_pops 
       imported_qualifier 
       imported_id 
       imported_op_info))
     (mergeSortStep 
      (imported_qualifier imported_id imported_sort_info combined_psorts) 
      (insertAQualifierMap 
       combined_psorts 
       imported_qualifier 
       imported_id 
       imported_sort_info))) 
    (let ((spc (addImport (cons "" imported_spec) spc))) 
      (let ((newSorts 
             (foldriAQualifierMap-1-1-1 
              #'(lambda (x) 
                 (mergeSortStep (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
              (svref spc 3) 
              (svref imported_spec 3)))) 
        (let ((spc (setSorts spc newSorts))) 
          (let ((newOps 
                 (foldriAQualifierMap-1-1-1 
                  #'(lambda (x) 
                     (mergeOpStep 
                      (svref x 0) 
                      (svref x 1) 
                      (svref x 2) 
                      (svref x 3))) 
                  (svref spc 1) 
                  (svref imported_spec 1)))) 
            (let ((spc (setOps spc newOps))) 
              (setProperties 
               spc 
               (LIST-SPEC::|!++| (svref spc 2) (svref imported_spec 2))))))))))
                                                                               
(defun addDisjointImport-1 (x) (addDisjointImport (car x) (cdr x)))
                                                                   
(defun addImport-1 (x) (addImport (car x) (cdr x)))
                                                   
(defun addToNames (name nameSet) (LIST-SPEC::|!cons| name nameSet))
                                                                   
(defun LIST-SPEC::|!member| (a l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (return 
            (if (slang-built-in::slang-term-equals a (car l)) 
                t 
                (LIST-SPEC::|!member| a (cdr l)))))) 
   (error "Nonexhaustive match failure in member")))
                                                    
(defun memberNames (n nms) (LIST-SPEC::|!member| n nms))
                                                        
(defun addLocalOpName (pV15 pV16) 
  (block 
   nil 
   (let ((pV17 (svref pV15 0))) 
     (let ((pV23 (svref pV17 2))) 
       (return 
        (if (memberNames pV16 pV23) 
            pV15 
            (vector 
             (vector 
              (svref pV17 0) 
              (svref pV17 1) 
              (addToNames pV16 pV23) 
              (svref pV17 3)) 
             (svref pV15 1) 
             (svref pV15 2) 
             (svref pV15 3)))))) 
   (error "Nonexhaustive match failure in addLocalOpName")))
                                                            
(defun addLocalOpName-1 (x) (addLocalOpName (car x) (cdr x)))
                                                             
(defun addLocalSortName (pV25 pV26) 
  (block 
   nil 
   (let ((pV27 (svref pV25 0))) 
     (let ((pV34 (svref pV27 3))) 
       (return 
        (if (memberNames pV26 pV34) 
            pV25 
            (vector 
             (vector 
              (svref pV27 0) 
              (svref pV27 1) 
              (svref pV27 2) 
              (addToNames pV26 pV34)) 
             (svref pV25 1) 
             (svref pV25 2) 
             (svref pV25 3)))))) 
   (error "Nonexhaustive match failure in addLocalSortName")))
                                                              
(defun addLocalSortName-1 (x) (addLocalSortName (car x) (cdr x)))
                                                                 
(defun addProperty-1 (x) (addProperty (car x) (cdr x)))
                                                       
(defun addTheorem (pV35 pV36) 
  (block 
   nil 
   (return 
    (addProperty 
     (vector '(:|Theorem|) (svref pV35 0) (svref pV35 1) (svref pV35 2)) 
     pV36)) 
   (error "Nonexhaustive match failure in addTheorem")))
                                                        
(defun addTheorem-1 (x) (addTheorem (car x) (cdr x)))
                                                     
(defun addTheoremLast (pV40 pV41) 
  (block 
   nil 
   (return 
    (setProperties 
     pV41 
     (LIST-SPEC::|!++| 
      (svref pV41 2) 
      (cons 
       (vector '(:|Theorem|) (svref pV40 0) (svref pV40 1) (svref pV40 2)) 
       nil)))) 
   (error "Nonexhaustive match failure in addTheoremLast")))
                                                            
(defun addTheoremLast-1 (x) (addTheoremLast (car x) (cdr x)))
                                                             
(defun addTheorems (theorems spc) 
  (LIST-SPEC::foldr-1-1-1 #'addTheorem-1 spc theorems))
                                                       
(defun addTheorems-1 (x) (addTheorems (car x) (cdr x)))
                                                       
(defun addToNames-1 (x) (addToNames (car x) (cdr x)))
                                                     
(defun SPLAYMAP::|!apply|-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8546 (cdr sp))) 
             (return 
              (progn (SPLAYMAP::|!apply|-1-1 af (svref pV8546 0)) 
                     (funcall af (cdr (svref pV8546 2))) 
                     (SPLAYMAP::|!apply|-1-1 af (svref pV8546 1))))))) 
   (error "Nonexhaustive match failure in apply")))
                                                   
(defun SPLAYMAP::app-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::|!apply|-1-1 af (STATE::|!!| (svref (cdr |!map|) 2)))))) 
   (error "Nonexhaustive match failure in app")))
                                                 
(defun STRINGMAP::app-1-1 (x0 x1) (SPLAYMAP::app-1-1 x0 x1))
                                                            
(defun STRINGMAP::appDouble-1-1 (f m) 
  (STRINGMAP::app-1-1 #'(lambda (sm) (STRINGMAP::app-1-1 f sm)) m))
                                                                   
(defun STRINGMAP::appDouble (x1) 
  #'(lambda (x2) (STRINGMAP::appDouble-1-1 x1 x2)))
                                                   
(defun appAQualifierMap (x) (STRINGMAP::appDouble x))
                                                     
(defun appAQualifierMap-1-1 (x0 x1) (STRINGMAP::appDouble-1-1 x0 x1))
                                                                     
(defun LIST-SPEC::app-1-1 (f s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return (progn (funcall f (car s)) (LIST-SPEC::app-1-1 f (cdr s)))))) 
   (error "Nonexhaustive match failure in app")))
                                                 
(defun METASLANG::appSortOpt-1-1 (tsp_apps opt_sort) 
  (block 
   nil 
   (if (eq (car opt_sort) :|None|) 
       (return nil) 
       (if (eq (car opt_sort) :|Some|) 
           (return (METASLANG::appSort-1-1 tsp_apps (cdr opt_sort))))) 
   (error "Nonexhaustive match failure in appSortOpt")))
                                                        
(defun METASLANG::appPattern-1-1 (tsp_apps pat) 
  (let ((pattern_app (svref tsp_apps 2))) 
    (labels 
      ((appRec (pat) (progn (appP tsp_apps pat) (funcall pattern_app pat)))
       (appP (tsp_apps1 pat) 
        (block 
         nil 
         (if (eq (car pat) :|AliasPat|) 
             (let ((pV2467 (cdr pat))) 
               (return 
                (progn (appRec (svref pV2467 0)) (appRec (svref pV2467 1))))) 
             (if (eq (car pat) :|EmbedPat|) 
                 (let ((pV2466 (cdr pat))) 
                   (let ((pV2483 (svref pV2466 1))
                         (pV2484 (svref pV2466 2))) 
                     (if (eq (car pV2483) :|Some|) 
                         (return 
                          (progn (appRec (cdr pV2483)) 
                                 (METASLANG::appSort-1-1 tsp_apps1 pV2484))) 
                         (if (eq (car pV2483) :|None|) 
                             (return (METASLANG::appSort-1-1 tsp_apps1 pV2484)))))) 
                 (if (eq (car pat) :|RelaxPat|) 
                     (let ((pV2465 (cdr pat))) 
                       (return 
                        (progn (appRec (svref pV2465 0)) 
                               (METASLANG::appTerm-1-1 
                                tsp_apps1 
                                (svref pV2465 1))))) 
                     (if (eq (car pat) :|QuotientPat|) 
                         (let ((pV2464 (cdr pat))) 
                           (return 
                            (progn (appRec (svref pV2464 0)) 
                                   (METASLANG::appTerm-1-1 
                                    tsp_apps1 
                                    (svref pV2464 1))))) 
                         (if (eq (car pat) :|VarPat|) 
                             (return 
                              (METASLANG::appSort-1-1 
                               tsp_apps1 
                               (cdr (car (cdr pat))))) 
                             (if (eq (car pat) :|WildPat|) 
                                 (return 
                                  (METASLANG::appSort-1-1 
                                   tsp_apps1 
                                   (car (cdr pat)))) 
                                 (if (eq (car pat) :|RecordPat|) 
                                     (return 
                                      (LIST-SPEC::app-1-1 
                                       #'(lambda (x1) (appRec (cdr x1))) 
                                       (car (cdr pat))))))))))) 
         (return nil)))) (appRec pat))))
                                        
(defun METASLANG::appTerm-1-1 (tsp_apps term) 
  (let ((term_app (svref tsp_apps 0))) 
    (labels 
      ((appRec (term) (progn (appT tsp_apps term) (funcall term_app term)))
       (appT (tsp_apps1 term) 
        (block 
         nil 
         (if (eq (car term) :|Fun|) 
             (return (METASLANG::appSort-1-1 tsp_apps1 (svref (cdr term) 1))) 
             (if (eq (car term) :|Var|) 
                 (return 
                  (METASLANG::appSort-1-1 tsp_apps1 (cdr (car (cdr term))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV2550 (cdr term))) 
                       (return 
                        (progn (LIST-SPEC::app-1-1 
                                #'(lambda (x1) 
                                   (progn (METASLANG::appPattern-1-1 
                                           tsp_apps1 
                                           (car x1)) 
                                          (appRec (cdr x1)))) 
                                (svref pV2550 0)) 
                               (appRec (svref pV2550 1))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV2549 (cdr term))) 
                           (return 
                            (progn (LIST-SPEC::app-1-1 
                                    #'(lambda (x1) (appRec (cdr x1))) 
                                    (svref pV2549 0)) 
                                   (appRec (svref pV2549 1))))) 
                         (if (eq (car term) :|Record|) 
                             (return 
                              (LIST-SPEC::app-1-1 
                               #'(lambda (x1) (appRec (cdr x1))) 
                               (car (cdr term)))) 
                             (if (eq (car term) :|IfThenElse|) 
                                 (let ((pV2547 (cdr term))) 
                                   (return 
                                    (progn (appRec (svref pV2547 0)) 
                                           (appRec (svref pV2547 1)) 
                                           (appRec (svref pV2547 2))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (return 
                                      (LIST-SPEC::app-1-1 
                                       #'(lambda (x1) 
                                          (progn (METASLANG::appPattern-1-1 
                                                  tsp_apps1 
                                                  (svref x1 0)) 
                                                 (appRec (svref x1 1)) 
                                                 (appRec (svref x1 2)))) 
                                       (car (cdr term)))) 
                                     (if (eq (car term) :|Bind|) 
                                         (let ((pV2545 (cdr term))) 
                                           (return 
                                            (progn (LIST-SPEC::app-1-1 
                                                    #'(lambda (x1) 
                                                       (METASLANG::appSort-1-1 
                                                        tsp_apps1 
                                                        (cdr x1))) 
                                                    (svref pV2545 1)) 
                                                   (appRec (svref pV2545 2))))) 
                                         (if (eq (car term) :|Apply|) 
                                             (let ((pV2544 (cdr term))) 
                                               (return 
                                                (progn (appRec (svref pV2544 0)) 
                                                       (appRec (svref pV2544 1))))) 
                                             (if (eq (car term) :|Seq|) 
                                                 (return 
                                                  (LIST-SPEC::app-1-1 
                                                   #'appRec 
                                                   (car (cdr term)))) 
                                                 (if (eq (car term) :|ApplyN|) 
                                                     (return 
                                                      (LIST-SPEC::app-1-1 
                                                       #'appRec 
                                                       (car (cdr term)))) 
                                                     (if (eq 
                                                          (car term) 
                                                          :|SortedTerm|) 
                                                         (let ((pV2541 
                                                                (cdr term))) 
                                                           (return 
                                                            (progn (appRec 
                                                                    (svref 
                                                                     pV2541 
                                                                     0)) 
                                                                   (METASLANG::appSort-1-1 
                                                                    tsp_apps1 
                                                                    (svref 
                                                                     pV2541 
                                                                     1))))))))))))))))) 
         (error "Nonexhaustive match failure in appTerm")))) (appRec term))))
                                                                             
(defun METASLANG::appSort-1-1 (tsp_apps srt) 
  (let ((srt_app (svref tsp_apps 1))) 
    (labels 
      ((appRec (srt) (progn (appS tsp_apps srt) (funcall srt_app srt)))
       (appS (tsp_apps1 srt) 
        (block 
         nil 
         (if (eq (car srt) :|CoProduct|) 
             (return 
              (LIST-SPEC::app-1-1 
               #'(lambda (x1) (METASLANG::appSortOpt-1-1 tsp_apps1 (cdr x1))) 
               (car (cdr srt)))) 
             (if (eq (car srt) :|Product|) 
                 (return 
                  (LIST-SPEC::app-1-1 
                   #'(lambda (x1) (appRec (cdr x1))) 
                   (car (cdr srt)))) 
                 (if (eq (car srt) :|Arrow|) 
                     (let ((pV2504 (cdr srt))) 
                       (return 
                        (progn (appRec (svref pV2504 0)) 
                               (appRec (svref pV2504 1))))) 
                     (if (eq (car srt) :|Quotient|) 
                         (let ((pV2503 (cdr srt))) 
                           (return 
                            (progn (appRec (svref pV2503 0)) 
                                   (METASLANG::appTerm-1-1 
                                    tsp_apps1 
                                    (svref pV2503 1))))) 
                         (if (eq (car srt) :|Subsort|) 
                             (let ((pV2502 (cdr srt))) 
                               (return 
                                (progn (appRec (svref pV2502 0)) 
                                       (METASLANG::appTerm-1-1 
                                        tsp_apps1 
                                        (svref pV2502 1))))) 
                             (if (eq (car srt) :|Base|) 
                                 (let ((pV2508 (svref (cdr srt) 1))) 
                                   (progn (return 
                                           (LIST-SPEC::app-1-1 #'appRec pV2508)) 
                                          (return 
                                           (LIST-SPEC::app-1-1 #'appRec pV2508)))))))))) 
         (return nil)))) (appRec srt))))
                                        
(defun METASLANG::appSort-1 (x1) 
  #'(lambda (x2) (METASLANG::appSort-1-1 x1 x2)))
                                                 
(defun METASLANG::appSortOpt-1 (x1) 
  #'(lambda (x2) (METASLANG::appSortOpt-1-1 x1 x2)))
                                                    
(defun METASLANG::appTerm-1 (x1) 
  #'(lambda (x2) (METASLANG::appTerm-1-1 x1 x2)))
                                                 
(defun METASLANG::appTermOpt-1-1 (tsp_apps opt_term) 
  (block 
   nil 
   (if (eq (car opt_term) :|None|) 
       (return nil) 
       (if (eq (car opt_term) :|Some|) 
           (return (METASLANG::appTerm-1-1 tsp_apps (cdr opt_term))))) 
   (error "Nonexhaustive match failure in appTermOpt")))
                                                        
(defun METASLANG::appTermOpt-1 (x1) 
  #'(lambda (x2) (METASLANG::appTermOpt-1-1 x1 x2)))
                                                    
(defun appSpec-1-1 (tsp spc) 
  (let ((|!appt| (METASLANG::appTerm-1 tsp))) 
    (let ((appto (METASLANG::appTermOpt-1 tsp))) 
      (let ((|!apps| (METASLANG::appSort-1 tsp))) 
        (let ((appso (METASLANG::appSortOpt-1 tsp))) 
          (progn (appAQualifierMap-1-1 
                  #'(lambda (x) 
                     (block 
                      nil 
                      (return 
                       (progn (funcall |!apps| (cdr (svref x 2))) 
                              (funcall appto (svref x 3)))) 
                      (error "Nonexhaustive match failure in appSpec"))) 
                  (svref spc 1)) 
                 (appAQualifierMap-1-1 
                  #'(lambda (x) (funcall appso (svref x 2))) 
                  (svref spc 3)) 
                 (LIST-SPEC::app-1-1 
                  #'(lambda (x) (funcall |!appt| (svref x 3))) 
                  (svref spc 2))))))))
                                      
(defun appSpec-1 (x1) #'(lambda (x2) (appSpec-1-1 x1 x2)))
                                                          
(defun appSpec (x0 x1 x2) (appSpec-1 (vector x0 x1 x2)))
                                                        
(defparameter emptyAQualifierMap STRINGMAP::empty)
                                                  
(defparameter emptyAOpMap emptyAQualifierMap)
                                             
(defparameter emptyAProperties nil)
                                   
(defparameter emptyASortMap emptyAQualifierMap)
                                               
(defparameter emptyImports nil)
                               
(defparameter emptyOpNames nil)
                               
(defparameter emptySortNames nil)
                                 
(defparameter emptyImportInfo 
  (vector '(:|None|) emptyImports emptyOpNames emptySortNames))
                                                               
(defparameter emptySpec 
  (vector emptyImportInfo emptyAOpMap emptyAProperties emptyASortMap))
                                                                      
(defun METASLANG::equalOpt? (x y eqFn) 
  (block 
   nil 
   (if (eq (car x) :|None|) 
       (if (eq (car y) :|None|) (return t)) 
       (if (eq (car x) :|Some|) 
           (if (eq (car y) :|Some|) 
               (return (funcall eqFn (cons (cdr x) (cdr y))))))) 
   (return nil)))
                 
(defun METASLANG::equalFun? (f1 f2) 
  (block 
   nil 
   (if (eq (car f1) :|PQuotient|) 
       (if (eq (car f2) :|PQuotient|) 
           (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
       (if (eq (car f1) :|PChoose|) 
           (if (eq (car f2) :|PChoose|) 
               (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
           (if (eq (car f1) :|PRestrict|) 
               (if (eq (car f2) :|PRestrict|) 
                   (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
               (if (eq (car f1) :|PRelax|) 
                   (if (eq (car f2) :|PRelax|) 
                       (return (METASLANG::equalTerm? (cdr f1) (cdr f2)))) 
                   (if (eq (car f1) :|Equals|) 
                       (if (eq (car f2) :|Equals|) (return t)) 
                       (if (eq (car f1) :|Quotient|) 
                           (if (eq (car f2) :|Quotient|) (return t)) 
                           (if (eq (car f1) :|Choose|) 
                               (if (eq (car f2) :|Choose|) (return t)) 
                               (if (eq (car f1) :|Restrict|) 
                                   (if (eq (car f2) :|Restrict|) (return t)) 
                                   (if (eq (car f1) :|Relax|) 
                                       (if (eq (car f2) :|Relax|) (return t)) 
                                       (if (eq (car f1) :|Op|) 
                                           (if (eq (car f2) :|Op|) 
                                               (return 
                                                (slang-built-in::slang-term-equals 
                                                 (cdr f1) 
                                                 (cdr f2)))) 
                                           (if (eq (car f1) :|Project|) 
                                               (if (eq (car f2) :|Project|) 
                                                   (return 
                                                    (string=  (cdr f1) (cdr f2)))) 
                                               (if (eq (car f1) :|Embed|) 
                                                   (if (eq (car f2) :|Embed|) 
                                                       (return 
                                                        (slang-built-in::slang-term-equals 
                                                         (cdr f1) 
                                                         (cdr f2)))) 
                                                   (if (eq (car f1) :|Embedded|) 
                                                       (if (eq 
                                                            (car f2) 
                                                            :|Embedded|) 
                                                           (return 
                                                            (string=  
                                                             (cdr f1) 
                                                             (cdr f2)))) 
                                                       (if (eq (car f1) :|Nat|) 
                                                           (if (eq 
                                                                (car f2) 
                                                                :|Nat|) 
                                                               (return 
                                                                ( =  
                                                                 (cdr f1) 
                                                                 (cdr f2)))) 
                                                           (if (eq 
                                                                (car f1) 
                                                                :|Char|) 
                                                               (if (eq 
                                                                    (car f2) 
                                                                    :|Char|) 
                                                                   (return 
                                                                    (eq 
                                                                     (cdr f1) 
                                                                     (cdr f2)))) 
                                                               (if (eq 
                                                                    (car f1) 
                                                                    :|String|) 
                                                                   (if (eq 
                                                                        (car f2) 
                                                                        :|String|) 
                                                                       (return 
                                                                        (string=  
                                                                         (cdr f1) 
                                                                         (cdr f2)))) 
                                                                   (if (eq 
                                                                        (car f1) 
                                                                        :|Bool|) 
                                                                       (if (eq 
                                                                            (car 
                                                                             f2) 
                                                                            :|Bool|) 
                                                                           (return 
                                                                            (eq 
                                                                             (cdr 
                                                                              f1) 
                                                                             (cdr 
                                                                              f2)))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             f1) 
                                                                            :|OneName|) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 f2) 
                                                                                :|OneName|) 
                                                                               (return 
                                                                                (slang-built-in::slang-term-equals 
                                                                                 (cdr 
                                                                                  f1) 
                                                                                 (cdr 
                                                                                  f2)))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 f1) 
                                                                                :|TwoNames|) 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     f2) 
                                                                                    :|TwoNames|) 
                                                                                   (return 
                                                                                    (slang-built-in::slang-term-equals 
                                                                                     (cdr 
                                                                                      f1) 
                                                                                     (cdr 
                                                                                      f2))))))))))))))))))))))) 
   (return nil)))
                 
(defun LIST-SPEC::|!length| (s) 
  (block 
   nil 
   (if (null s) 
       (return 0) 
       (if (consp s) 
           (return (INTEGER-SPEC::|!+| 1 (LIST-SPEC::|!length| (cdr s)))))) 
   (error "Nonexhaustive match failure in length")))
                                                    
(defun METASLANG::equalList? (x y eqFn) 
  (lisp::and 
   ( =  (LIST-SPEC::|!length| x) (LIST-SPEC::|!length| y)) 
   (block 
    nil 
    (if (null x) 
        (if (null y) (return t)) 
        (if (consp x) 
            (if (consp y) 
                (return 
                 (lisp::and 
                  (funcall eqFn (cons (car x) (car y))) 
                  (METASLANG::equalList? (cdr x) (cdr y) eqFn)))))) 
    (return nil))))
                   
(defun METASLANG::equalPattern?-1 (x) 
  (METASLANG::equalPattern? (car x) (cdr x)))
                                             
(defun METASLANG::equalSort?-1 (x) (METASLANG::equalSort? (car x) (cdr x)))
                                                                           
(defun METASLANG::equalSort? (s1 s2) 
  (block 
   nil 
   (if (eq (car s1) :|Arrow|) 
       (let ((pV2839 (cdr s1))) 
         (if (eq (car s2) :|Arrow|) 
             (let ((pV2884 (cdr s2))) 
               (return 
                (lisp::and 
                 (METASLANG::equalSort? (svref pV2839 0) (svref pV2884 0)) 
                 (METASLANG::equalSort? (svref pV2839 1) (svref pV2884 1))))))) 
       (if (eq (car s1) :|Product|) 
           (if (eq (car s2) :|Product|) 
               (return 
                (METASLANG::equalList? 
                 (car (cdr s1)) 
                 (car (cdr s2)) 
                 #'(lambda (x) 
                    (let ((pV2767 (cdr x))
                          (pV2766 (car x))) 
                      (block 
                       nil 
                       (return 
                        (lisp::and 
                         (string=  (car pV2766) (car pV2767)) 
                         (METASLANG::equalSort? (cdr pV2766) (cdr pV2767)))) 
                       (error "Nonexhaustive match failure in equalSort?"))))))) 
           (if (eq (car s1) :|CoProduct|) 
               (if (eq (car s2) :|CoProduct|) 
                   (return 
                    (METASLANG::equalList? 
                     (car (cdr s1)) 
                     (car (cdr s2)) 
                     #'(lambda (x) 
                        (let ((pV2775 (cdr x))
                              (pV2774 (car x))) 
                          (block 
                           nil 
                           (return 
                            (lisp::and 
                             (string=  (car pV2774) (car pV2775)) 
                             (METASLANG::equalOpt? 
                              (cdr pV2774) 
                              (cdr pV2775) 
                              #'METASLANG::equalSort?-1))) 
                           (error "Nonexhaustive match failure in equalSort?"))))))) 
               (if (eq (car s1) :|Quotient|) 
                   (let ((pV2836 (cdr s1))) 
                     (if (eq (car s2) :|Quotient|) 
                         (let ((pV2867 (cdr s2))) 
                           (return 
                            (lisp::and 
                             (METASLANG::equalSort? 
                              (svref pV2836 0) 
                              (svref pV2867 0)) 
                             (METASLANG::equalTerm? 
                              (svref pV2836 1) 
                              (svref pV2867 1))))))) 
                   (if (eq (car s1) :|Subsort|) 
                       (let ((pV2835 (cdr s1))) 
                         (if (eq (car s2) :|Subsort|) 
                             (let ((pV2860 (cdr s2))) 
                               (return 
                                (lisp::and 
                                 (METASLANG::equalSort? 
                                  (svref pV2835 0) 
                                  (svref pV2860 0)) 
                                 (METASLANG::equalTerm? 
                                  (svref pV2835 1) 
                                  (svref pV2860 1))))))) 
                       (if (eq (car s1) :|Base|) 
                           (let ((pV2834 (cdr s1))) 
                             (let ((pV2851 (svref pV2834 1))
                                   (pV2850 (svref pV2834 0))) 
                               (if (eq (car s2) :|Base|) 
                                   (let ((pV2853 (cdr s2))) 
                                     (let ((pV2855 (svref pV2853 1))
                                           (pV2854 (svref pV2853 0))) 
                                       (progn (return 
                                               (lisp::and 
                                                (slang-built-in::slang-term-equals 
                                                 pV2850 
                                                 pV2854) 
                                                (METASLANG::equalList? 
                                                 pV2851 
                                                 pV2855 
                                                 #'METASLANG::equalSort?-1))) 
                                              (return 
                                               (lisp::and 
                                                (slang-built-in::slang-term-equals 
                                                 pV2850 
                                                 pV2854) 
                                                (METASLANG::equalList? 
                                                 pV2851 
                                                 pV2855 
                                                 #'METASLANG::equalSort?-1))))))))) 
                           (if (eq (car s1) :|TyVar|) 
                               (if (eq (car s2) :|TyVar|) 
                                   (return 
                                    (string=  (car (cdr s1)) (car (cdr s2))))) 
                               (if (eq (car s1) :|MetaTyVar|) 
                                   (let ((pV2840 (car (cdr s1)))) 
                                     (progn (if (eq (car s2) :|MetaTyVar|) 
                                                (return 
                                                 (let ((pV2804 
                                                        (STATE::|!!| pV2840))) 
                                                   (block 
                                                    nil 
                                                    (let ((pV2805 
                                                           (svref pV2804 0))) 
                                                      (return 
                                                       (let ((pV2800 
                                                              (STATE::|!!| 
                                                               (car (cdr s2))))) 
                                                         (block 
                                                          nil 
                                                          (let ((pV2801 
                                                                 (svref pV2800 0))) 
                                                            (return 
                                                             (lisp::or 
                                                              ( =  
                                                               (svref pV2804 2) 
                                                               (svref pV2800 2)) 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car pV2805) 
                                                                    :|Some|) 
                                                                   (let ((pV2798 
                                                                          (cdr 
                                                                           pV2805))) 
                                                                     (progn (if (eq 
                                                                                 (car 
                                                                                  pV2801) 
                                                                                 :|Some|) 
                                                                                (return 
                                                                                 (METASLANG::equalSort? 
                                                                                  pV2798 
                                                                                  (cdr 
                                                                                   pV2801)))) 
                                                                            (return 
                                                                             (METASLANG::equalSort? 
                                                                              pV2798 
                                                                              s2))))) 
                                                               (if (eq 
                                                                    (car pV2801) 
                                                                    :|Some|) 
                                                                   (return 
                                                                    (METASLANG::equalSort? 
                                                                     s1 
                                                                     (cdr pV2801)))) 
                                                               (return nil))))) 
                                                          (error 
                                                           "Nonexhaustive match failure in equalSort?"))))) 
                                                    (error 
                                                     "Nonexhaustive match failure in equalSort?"))))) 
                                            (return 
                                             (let ((pV2813 (STATE::|!!| pV2840))) 
                                               (block 
                                                nil 
                                                (let ((pV2814 (svref pV2813 0))) 
                                                  (return 
                                                   (block 
                                                    nil 
                                                    (if (eq (car pV2814) :|Some|) 
                                                        (return 
                                                         (METASLANG::equalSort? 
                                                          (cdr pV2814) 
                                                          s2))) 
                                                    (return nil)))) 
                                                (error 
                                                 "Nonexhaustive match failure in equalSort?")))))))))))))) 
   (if (eq (car s2) :|MetaTyVar|) 
       (return 
        (let ((pV2822 (STATE::|!!| (car (cdr s2))))) 
          (block 
           nil 
           (let ((pV2823 (svref pV2822 0))) 
             (return 
              (block 
               nil 
               (if (eq (car pV2823) :|Some|) 
                   (return (METASLANG::equalSort? s1 (cdr pV2823)))) 
               (return nil)))) 
           (error "Nonexhaustive match failure in equalSort?"))))) 
   (return nil)))
                 
(defun METASLANG::equalVar? (pV3031 pV3032) 
  (block 
   nil 
   (return 
    (lisp::and 
     (string=  (car pV3031) (car pV3032)) 
     (METASLANG::equalSort? (cdr pV3031) (cdr pV3032)))) 
   (error "Nonexhaustive match failure in equalVar?")))
                                                       
(defun METASLANG::equalPattern? (p1 p2) 
  (block 
   nil 
   (if (eq (car p1) :|AliasPat|) 
       (let ((pV2689 (cdr p1))) 
         (if (eq (car p2) :|AliasPat|) 
             (let ((pV2758 (cdr p2))) 
               (return 
                (lisp::and 
                 (METASLANG::equalPattern? (svref pV2689 0) (svref pV2758 0)) 
                 (METASLANG::equalPattern? (svref pV2689 1) (svref pV2758 1))))))) 
       (if (eq (car p1) :|VarPat|) 
           (if (eq (car p2) :|VarPat|) 
               (return (METASLANG::equalVar? (car (cdr p1)) (car (cdr p2))))) 
           (if (eq (car p1) :|EmbedPat|) 
               (let ((pV2687 (cdr p1))) 
                 (if (eq (car p2) :|EmbedPat|) 
                     (let ((pV2745 (cdr p2))) 
                       (return 
                        (lisp::and 
                         (string=  (svref pV2687 0) (svref pV2745 0)) 
                         (lisp::and 
                          (METASLANG::equalSort? 
                           (svref pV2687 2) 
                           (svref pV2745 2)) 
                          (METASLANG::equalOpt? 
                           (svref pV2687 1) 
                           (svref pV2745 1) 
                           #'METASLANG::equalPattern?-1))))))) 
               (if (eq (car p1) :|RecordPat|) 
                   (if (eq (car p2) :|RecordPat|) 
                       (return 
                        (METASLANG::equalList? 
                         (car (cdr p1)) 
                         (car (cdr p2)) 
                         #'(lambda (x) 
                            (let ((pV2654 (cdr x))
                                  (pV2653 (car x))) 
                              (block 
                               nil 
                               (return 
                                (lisp::and 
                                 (string=  (car pV2653) (car pV2654)) 
                                 (METASLANG::equalPattern? 
                                  (cdr pV2653) 
                                  (cdr pV2654)))) 
                               (error 
                                "Nonexhaustive match failure in equalPattern?"))))))) 
                   (if (eq (car p1) :|WildPat|) 
                       (if (eq (car p2) :|WildPat|) 
                           (return 
                            (METASLANG::equalSort? (car (cdr p1)) (car (cdr p2))))) 
                       (if (eq (car p1) :|StringPat|) 
                           (if (eq (car p2) :|StringPat|) 
                               (return (string=  (car (cdr p1)) (car (cdr p2))))) 
                           (if (eq (car p1) :|BoolPat|) 
                               (if (eq (car p2) :|BoolPat|) 
                                   (return (eq (car (cdr p1)) (car (cdr p2))))) 
                               (if (eq (car p1) :|CharPat|) 
                                   (if (eq (car p2) :|CharPat|) 
                                       (return 
                                        (eq (car (cdr p1)) (car (cdr p2))))) 
                                   (if (eq (car p1) :|NatPat|) 
                                       (if (eq (car p2) :|NatPat|) 
                                           (return 
                                            ( =  (car (cdr p1)) (car (cdr p2))))) 
                                       (if (eq (car p1) :|RelaxPat|) 
                                           (let ((pV2680 (cdr p1))) 
                                             (if (eq (car p2) :|RelaxPat|) 
                                                 (let ((pV2707 (cdr p2))) 
                                                   (return 
                                                    (lisp::and 
                                                     (METASLANG::equalPattern? 
                                                      (svref pV2680 0) 
                                                      (svref pV2707 0)) 
                                                     (METASLANG::equalTerm? 
                                                      (svref pV2680 1) 
                                                      (svref pV2707 1))))))) 
                                           (if (eq (car p1) :|QuotientPat|) 
                                               (let ((pV2679 (cdr p1))) 
                                                 (if (eq (car p2) :|QuotientPat|) 
                                                     (let ((pV2700 (cdr p2))) 
                                                       (return 
                                                        (lisp::and 
                                                         (METASLANG::equalPattern? 
                                                          (svref pV2679 0) 
                                                          (svref pV2700 0)) 
                                                         (METASLANG::equalTerm? 
                                                          (svref pV2679 1) 
                                                          (svref pV2700 1))))))) 
                                               (if (eq (car p1) :|SortedPat|) 
                                                   (let ((pV2678 (cdr p1))) 
                                                     (if (eq 
                                                          (car p2) 
                                                          :|SortedPat|) 
                                                         (let ((pV2693 (cdr p2))) 
                                                           (return 
                                                            (lisp::and 
                                                             (METASLANG::equalPattern? 
                                                              (svref pV2678 0) 
                                                              (svref pV2693 0)) 
                                                             (METASLANG::equalSort? 
                                                              (svref pV2678 1) 
                                                              (svref pV2693 1))))))))))))))))))) 
   (return nil)))
                 
(defun METASLANG::equalVar?-1 (x) (METASLANG::equalVar? (car x) (cdr x)))
                                                                         
(defun METASLANG::equalTerm? (t1 t2) 
  (block 
   nil 
   (if (eq (car t1) :|Apply|) 
       (let ((pV2952 (cdr t1))) 
         (if (eq (car t2) :|Apply|) 
             (let ((pV3027 (cdr t2))) 
               (return 
                (lisp::and 
                 (METASLANG::equalTerm? (svref pV2952 0) (svref pV3027 0)) 
                 (METASLANG::equalTerm? (svref pV2952 1) (svref pV3027 1))))))) 
       (if (eq (car t1) :|ApplyN|) 
           (if (eq (car t2) :|ApplyN|) 
               (return 
                (METASLANG::equalList? 
                 (car (cdr t1)) 
                 (car (cdr t2)) 
                 #'METASLANG::equalTerm?-1))) 
           (if (eq (car t1) :|Record|) 
               (if (eq (car t2) :|Record|) 
                   (return 
                    (METASLANG::equalList? 
                     (car (cdr t1)) 
                     (car (cdr t2)) 
                     #'(lambda (x) 
                        (let ((pV2895 (cdr x))
                              (pV2894 (car x))) 
                          (block 
                           nil 
                           (return 
                            (lisp::and 
                             (string=  (car pV2894) (car pV2895)) 
                             (METASLANG::equalTerm? (cdr pV2894) (cdr pV2895)))) 
                           (error "Nonexhaustive match failure in equalTerm?"))))))) 
               (if (eq (car t1) :|Bind|) 
                   (let ((pV2949 (cdr t1))) 
                     (if (eq (car t2) :|Bind|) 
                         (let ((pV3009 (cdr t2))) 
                           (return 
                            (lisp::and 
                             (slang-built-in::slang-term-equals 
                              (svref pV2949 0) 
                              (svref pV3009 0)) 
                             (lisp::and 
                              (METASLANG::equalList? 
                               (svref pV2949 1) 
                               (svref pV3009 1) 
                               #'METASLANG::equalVar?-1) 
                              (METASLANG::equalTerm? 
                               (svref pV2949 2) 
                               (svref pV3009 2)))))))) 
                   (if (eq (car t1) :|Let|) 
                       (let ((pV2948 (cdr t1))) 
                         (if (eq (car t2) :|Let|) 
                             (let ((pV3001 (cdr t2))) 
                               (return 
                                (lisp::and 
                                 (METASLANG::equalTerm? 
                                  (svref pV2948 1) 
                                  (svref pV3001 1)) 
                                 (METASLANG::equalList? 
                                  (svref pV2948 0) 
                                  (svref pV3001 0) 
                                  #'(lambda (x) 
                                     (let ((pV2905 (cdr x))
                                           (pV2904 (car x))) 
                                       (block 
                                        nil 
                                        (return 
                                         (lisp::and 
                                          (METASLANG::equalPattern? 
                                           (car pV2904) 
                                           (car pV2905)) 
                                          (METASLANG::equalTerm? 
                                           (cdr pV2904) 
                                           (cdr pV2905)))) 
                                        (error 
                                         "Nonexhaustive match failure in equalTerm?")))))))))) 
                       (if (eq (car t1) :|LetRec|) 
                           (let ((pV2947 (cdr t1))) 
                             (if (eq (car t2) :|LetRec|) 
                                 (let ((pV2994 (cdr t2))) 
                                   (return 
                                    (lisp::and 
                                     (METASLANG::equalTerm? 
                                      (svref pV2947 1) 
                                      (svref pV2994 1)) 
                                     (METASLANG::equalList? 
                                      (svref pV2947 0) 
                                      (svref pV2994 0) 
                                      #'(lambda (x) 
                                         (let ((pV2913 (cdr x))
                                               (pV2912 (car x))) 
                                           (block 
                                            nil 
                                            (return 
                                             (lisp::and 
                                              (METASLANG::equalVar? 
                                               (car pV2912) 
                                               (car pV2913)) 
                                              (METASLANG::equalTerm? 
                                               (cdr pV2912) 
                                               (cdr pV2913)))) 
                                            (error 
                                             "Nonexhaustive match failure in equalTerm?")))))))))) 
                           (if (eq (car t1) :|Var|) 
                               (if (eq (car t2) :|Var|) 
                                   (return 
                                    (METASLANG::equalVar? 
                                     (car (cdr t1)) 
                                     (car (cdr t2))))) 
                               (if (eq (car t1) :|Fun|) 
                                   (let ((pV2945 (cdr t1))) 
                                     (if (eq (car t2) :|Fun|) 
                                         (let ((pV2982 (cdr t2))) 
                                           (return 
                                            (lisp::and 
                                             (METASLANG::equalFun? 
                                              (svref pV2945 0) 
                                              (svref pV2982 0)) 
                                             (METASLANG::equalSort? 
                                              (svref pV2945 1) 
                                              (svref pV2982 1))))))) 
                                   (if (eq (car t1) :|Lambda|) 
                                       (if (eq (car t2) :|Lambda|) 
                                           (return 
                                            (METASLANG::equalList? 
                                             (car (cdr t1)) 
                                             (car (cdr t2)) 
                                             #'(lambda (x) 
                                                (let ((pV2925 (cdr x))
                                                      (pV2924 (car x))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (lisp::and 
                                                     (METASLANG::equalPattern? 
                                                      (svref pV2924 0) 
                                                      (svref pV2925 0)) 
                                                     (lisp::and 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV2924 1) 
                                                       (svref pV2925 1)) 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV2924 2) 
                                                       (svref pV2925 2))))) 
                                                   (error 
                                                    "Nonexhaustive match failure in equalTerm?"))))))) 
                                       (if (eq (car t1) :|IfThenElse|) 
                                           (let ((pV2943 (cdr t1))) 
                                             (if (eq (car t2) :|IfThenElse|) 
                                                 (let ((pV2969 (cdr t2))) 
                                                   (return 
                                                    (lisp::and 
                                                     (METASLANG::equalTerm? 
                                                      (svref pV2943 0) 
                                                      (svref pV2969 0)) 
                                                     (lisp::and 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV2943 1) 
                                                       (svref pV2969 1)) 
                                                      (METASLANG::equalTerm? 
                                                       (svref pV2943 2) 
                                                       (svref pV2969 2)))))))) 
                                           (if (eq (car t1) :|Seq|) 
                                               (if (eq (car t2) :|Seq|) 
                                                   (return 
                                                    (METASLANG::equalList? 
                                                     (car (cdr t1)) 
                                                     (car (cdr t2)) 
                                                     #'METASLANG::equalTerm?-1))) 
                                               (if (eq (car t1) :|SortedTerm|) 
                                                   (let ((pV2941 (cdr t1))) 
                                                     (if (eq 
                                                          (car t2) 
                                                          :|SortedTerm|) 
                                                         (let ((pV2956 (cdr t2))) 
                                                           (return 
                                                            (lisp::and 
                                                             (METASLANG::equalTerm? 
                                                              (svref pV2941 0) 
                                                              (svref pV2956 0)) 
                                                             (METASLANG::equalSort? 
                                                              (svref pV2941 1) 
                                                              (svref pV2956 1))))))))))))))))))) 
   (return nil)))
                 
(defun METASLANG::equalTerm?-1 (x) (METASLANG::equalTerm? (car x) (cdr x)))
                                                                           
(defun equalSortScheme? (pV70 pV71) 
  (block 
   nil 
   (return 
    (lisp::and 
     (slang-built-in::slang-term-equals (car pV70) (car pV71)) 
     (METASLANG::equalSort? (cdr pV70) (cdr pV71)))) 
   (error "Nonexhaustive match failure in equalSortScheme?")))
                                                              
(defun equalOpInfo? (pV52 pV53) 
  (block 
   nil 
   (return 
    (lisp::and 
     (slang-built-in::slang-term-equals (svref pV52 0) (svref pV53 0)) 
     (lisp::and 
      (slang-built-in::slang-term-equals (svref pV52 1) (svref pV53 1)) 
      (lisp::and 
       (equalSortScheme? (svref pV52 2) (svref pV53 2)) 
       (METASLANG::equalOpt? 
        (svref pV52 3) 
        (svref pV53 3) 
        #'METASLANG::equalTerm?-1))))) 
   (error "Nonexhaustive match failure in equalOpInfo?")))
                                                          
(defun equalOpInfo?-1 (x) (equalOpInfo? (car x) (cdr x)))
                                                         
(defun equalSortInfo? (pV62 pV63) 
  (block 
   nil 
   (return 
    (lisp::and 
     (slang-built-in::slang-term-equals (svref pV62 0) (svref pV63 0)) 
     (lisp::and 
      (slang-built-in::slang-term-equals (svref pV62 1) (svref pV63 1)) 
      (METASLANG::equalOpt? 
       (svref pV62 2) 
       (svref pV63 2) 
       #'METASLANG::equalSort?-1)))) 
   (error "Nonexhaustive match failure in equalSortInfo?")))
                                                            
(defun equalSortInfo?-1 (x) (equalSortInfo? (car x) (cdr x)))
                                                             
(defun equalSortScheme?-1 (x) (equalSortScheme? (car x) (cdr x)))
                                                                 
(defun STRINGMAP::find2 (m x y) 
  (let ((pV9393 (STRINGMAP::|!find| m x))) 
    (block 
     nil 
     (if (eq (car pV9393) :|None|) 
         (return '(:|None|)) 
         (if (eq (car pV9393) :|Some|) 
             (return (STRINGMAP::|!find| (cdr pV9393) y)))) 
     (error "Nonexhaustive match failure in find2"))))
                                                      
(defun findAQualifierMap (x1 x0 x) (STRINGMAP::find2 x1 x0 x))
                                                              
(defun findAQualifierMap-1 (x) 
  (findAQualifierMap (svref x 0) (svref x 1) (svref x 2)))
                                                          
(defun SPLAYMAP::foldriDouble (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldriDouble-1-1-1 x1 x2 x3))))
                                                                          
(defun STRINGMAP::foldriDouble (x) (SPLAYMAP::foldriDouble x))
                                                              
(defun foldriAQualifierMap (x) (STRINGMAP::foldriDouble x))
                                                           
(defun insertAQualifierMap-1 (x) 
  (insertAQualifierMap (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                        
(defun LIST-SPEC::|!exists|-1-1 (p s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return 
            (if (funcall p (car s)) t (LIST-SPEC::|!exists|-1-1 p (cdr s)))))) 
   (error "Nonexhaustive match failure in exists")))
                                                    
(defun memberQualifiedId (qualifier id qids) 
  (LIST-SPEC::|!exists|-1-1 
   #'(lambda (pV115) 
      (block 
       nil 
       (if (eq (car pV115) :|Qualified|) 
           (let ((pV116 (cdr pV115))) 
             (return 
              (lisp::and 
               (string=  (car pV116) qualifier) 
               (string=  (cdr pV116) id))))) 
       (error "Nonexhaustive match failure in memberQualifiedId"))) 
   qids))
         
(defun localOp? (pV76 pV77) 
  (block 
   nil 
   (if (eq (car pV76) :|Qualified|) 
       (let ((pV78 (cdr pV76))) 
         (return 
          (memberQualifiedId (car pV78) (cdr pV78) (svref (svref pV77 0) 2))))) 
   (error "Nonexhaustive match failure in localOp?")))
                                                      
(defun localOp?-1 (x) (localOp? (car x) (cdr x)))
                                                 
(defun localSort? (pV89 pV90) 
  (block 
   nil 
   (if (eq (car pV89) :|Qualified|) 
       (let ((pV91 (cdr pV89))) 
         (return 
          (memberQualifiedId (car pV91) (cdr pV91) (svref (svref pV90 0) 3))))) 
   (error "Nonexhaustive match failure in localSort?")))
                                                        
(defun localSort?-1 (x) (localSort? (car x) (cdr x)))
                                                     
(defun SPLAYMAP::ap-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|SplayNil|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8516 (cdr sp))) 
             (let ((pV8519 (svref pV8516 2))) 
               (return 
                (let ((left (SPLAYMAP::ap-1-1 af (svref pV8516 0)))) 
                  (let ((value (cons (car pV8519) (funcall af (cdr pV8519))))) 
                    (cons 
                     :|SplayObj| 
                     (vector left (SPLAYMAP::ap-1-1 af (svref pV8516 1)) value))))))))) 
   (error "Nonexhaustive match failure in ap")))
                                                
(defun SPLAYMAP::|!map|-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return (cons :|EMPTY| (cdr |!map|))) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV8762 (cdr |!map|))) 
             (return 
              (cons 
               :|MAP| 
               (vector 
                (svref pV8762 0) 
                (svref pV8762 1) 
                (cons 
                 :|Ref| 
                 (SPLAYMAP::ap-1-1 af (STATE::|!!| (svref pV8762 2)))))))))) 
   (error "Nonexhaustive match failure in map")))
                                                 
(defun STRINGMAP::|!map|-1-1 (x0 x1) (SPLAYMAP::|!map|-1-1 x0 x1))
                                                                  
(defun STRINGMAP::mapDouble-1-1 (f m) 
  (STRINGMAP::|!map|-1-1 #'(lambda (sm) (STRINGMAP::|!map|-1-1 f sm)) m))
                                                                         
(defun STRINGMAP::mapDouble (x1) 
  #'(lambda (x2) (STRINGMAP::mapDouble-1-1 x1 x2)))
                                                   
(defun mapAQualifierMap (x) (STRINGMAP::mapDouble x))
                                                     
(defun mapAQualifierMap-1-1 (x0 x1) (STRINGMAP::mapDouble-1-1 x0 x1))
                                                                     
(defun mapDiff-1-1 (xMap yMap) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((qual (svref x 0))
            (id (svref x 1))
            (newMap (svref x 3))) 
        (let ((pV103 (findAQualifierMap yMap qual id))) 
          (block 
           nil 
           (if (eq (car pV103) :|None|) 
               (return (insertAQualifierMap newMap qual id (svref x 2))) 
               (if (eq (car pV103) :|Some|) (return newMap))) 
           (error "Nonexhaustive match failure in mapDiff"))))) 
   emptyAQualifierMap 
   xMap))
         
(defun mapDiff (x1) #'(lambda (x2) (mapDiff-1-1 x1 x2)))
                                                        
(defun LIST-SPEC::|!map|-1-1 (f s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return (cons (funcall f (car s)) (LIST-SPEC::|!map|-1-1 f (cdr s)))))) 
   (error "Nonexhaustive match failure in map")))
                                                 
(defun METASLANG::mapPattern-1-1 (tsp_maps pattern) 
  (let ((pattern_map (svref tsp_maps 2))) 
    (labels 
      ((mapRec (pattern) (funcall pattern_map (mapP tsp_maps pattern)))
       (mapP (tsp_maps1 pattern) 
        (block 
         nil 
         (if (eq (car pattern) :|AliasPat|) 
             (let ((pV3107 (cdr pattern))) 
               (let ((pV3130 (svref pV3107 0))
                     (pV3131 (svref pV3107 1))) 
                 (return 
                  (let ((newP1 (mapRec pV3130))) 
                    (let ((newP2 (mapRec pV3131))) 
                      (if (lisp::and 
                           (slang-built-in::slang-term-equals newP1 pV3130) 
                           (slang-built-in::slang-term-equals newP2 pV3131)) 
                          pattern 
                          (cons 
                           :|AliasPat| 
                           (vector newP1 newP2 (svref pV3107 2))))))))) 
             (if (eq (car pattern) :|EmbedPat|) 
                 (let ((pV3106 (cdr pattern))) 
                   (let ((pV3125 (svref pV3106 0))
                         (pV3126 (svref pV3106 1))
                         (pV3127 (svref pV3106 2))
                         (pV3128 (svref pV3106 3))) 
                     (if (eq (car pV3126) :|Some|) 
                         (let ((pV3129 (cdr pV3126))) 
                           (return 
                            (let ((newPat (mapRec pV3129))) 
                              (let ((newSrt 
                                     (METASLANG::mapSort-1-1 tsp_maps1 pV3127))) 
                                (if (lisp::and 
                                     (slang-built-in::slang-term-equals 
                                      newPat 
                                      pV3129) 
                                     (slang-built-in::slang-term-equals 
                                      newSrt 
                                      pV3127)) 
                                    pattern 
                                    (cons 
                                     :|EmbedPat| 
                                     (vector 
                                      pV3125 
                                      (cons :|Some| newPat) 
                                      newSrt 
                                      pV3128))))))) 
                         (if (eq (car pV3126) :|None|) 
                             (return 
                              (let ((newSrt 
                                     (METASLANG::mapSort-1-1 tsp_maps1 pV3127))) 
                                (if (slang-built-in::slang-term-equals 
                                     newSrt 
                                     pV3127) 
                                    pattern 
                                    (cons 
                                     :|EmbedPat| 
                                     (vector pV3125 '(:|None|) newSrt pV3128))))))))) 
                 (if (eq (car pattern) :|RelaxPat|) 
                     (let ((pV3105 (cdr pattern))) 
                       (let ((pV3122 (svref pV3105 0))
                             (pV3123 (svref pV3105 1))) 
                         (return 
                          (let ((newPat (mapRec pV3122))) 
                            (let ((newTrm 
                                   (METASLANG::mapTerm-1-1 tsp_maps1 pV3123))) 
                              (if (lisp::and 
                                   (slang-built-in::slang-term-equals 
                                    newPat 
                                    pV3122) 
                                   (slang-built-in::slang-term-equals 
                                    newTrm 
                                    pV3123)) 
                                  pattern 
                                  (cons 
                                   :|RelaxPat| 
                                   (vector newPat newTrm (svref pV3105 2))))))))) 
                     (if (eq (car pattern) :|QuotientPat|) 
                         (let ((pV3104 (cdr pattern))) 
                           (let ((pV3119 (svref pV3104 0))
                                 (pV3120 (svref pV3104 1))) 
                             (return 
                              (let ((newPat (mapRec pV3119))) 
                                (let ((newTrm 
                                       (METASLANG::mapTerm-1-1 tsp_maps1 pV3120))) 
                                  (if (lisp::and 
                                       (slang-built-in::slang-term-equals 
                                        newPat 
                                        pV3119) 
                                       (slang-built-in::slang-term-equals 
                                        newTrm 
                                        pV3120)) 
                                      pattern 
                                      (cons 
                                       :|QuotientPat| 
                                       (vector newPat newTrm (svref pV3104 2))))))))) 
                         (if (eq (car pattern) :|VarPat|) 
                             (let ((pV3103 (cdr pattern))) 
                               (let ((pV3115 (car pV3103))) 
                                 (let ((pV3118 (cdr pV3115))) 
                                   (return 
                                    (let ((newSrt 
                                           (METASLANG::mapSort-1-1 
                                            tsp_maps1 
                                            pV3118))) 
                                      (if (slang-built-in::slang-term-equals 
                                           newSrt 
                                           pV3118) 
                                          pattern 
                                          (cons 
                                           :|VarPat| 
                                           (cons 
                                            (cons (car pV3115) newSrt) 
                                            (cdr pV3103))))))))) 
                             (if (eq (car pattern) :|WildPat|) 
                                 (let ((pV3102 (cdr pattern))) 
                                   (let ((pV3113 (car pV3102))) 
                                     (return 
                                      (let ((newSrt 
                                             (METASLANG::mapSort-1-1 
                                              tsp_maps1 
                                              pV3113))) 
                                        (if (slang-built-in::slang-term-equals 
                                             newSrt 
                                             pV3113) 
                                            pattern 
                                            (cons 
                                             :|WildPat| 
                                             (cons newSrt (cdr pV3102)))))))) 
                                 (if (eq (car pattern) :|RecordPat|) 
                                     (let ((pV3101 (cdr pattern))) 
                                       (let ((pV3111 (car pV3101))) 
                                         (return 
                                          (let ((newFields 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'(lambda (x1) 
                                                     (cons 
                                                      (car x1) 
                                                      (mapRec (cdr x1)))) 
                                                  pV3111))) 
                                            (if (slang-built-in::slang-term-equals 
                                                 newFields 
                                                 pV3111) 
                                                pattern 
                                                (cons 
                                                 :|RecordPat| 
                                                 (cons newFields (cdr pV3101)))))))) 
                                     (if (eq (car pattern) :|SortedPat|) 
                                         (let ((pV3100 (cdr pattern))) 
                                           (let ((pV3108 (svref pV3100 0))
                                                 (pV3109 (svref pV3100 1))) 
                                             (return 
                                              (let ((newPat (mapRec pV3108))) 
                                                (let ((newSrt 
                                                       (METASLANG::mapSort-1-1 
                                                        tsp_maps1 
                                                        pV3109))) 
                                                  (if (lisp::and 
                                                       (slang-built-in::slang-term-equals 
                                                        newPat 
                                                        pV3108) 
                                                       (slang-built-in::slang-term-equals 
                                                        newSrt 
                                                        pV3109)) 
                                                      pattern 
                                                      (cons 
                                                       :|SortedPat| 
                                                       (vector 
                                                        newPat 
                                                        newSrt 
                                                        (svref pV3100 2))))))))))))))))) 
         (return pattern)))) (mapRec pattern))))
                                                
(defun METASLANG::mapTerm-1-1 (tsp_maps term) 
  (let ((term_map (svref tsp_maps 0))) 
    (labels 
      ((mapRec (term) (funcall term_map (mapT tsp_maps term)))
       (mapT (tsp_maps1 term) 
        (block 
         nil 
         (if (eq (car term) :|Fun|) 
             (let ((pV3204 (cdr term))) 
               (let ((pV3238 (svref pV3204 1))) 
                 (return 
                  (let ((newSrt (METASLANG::mapSort-1-1 tsp_maps1 pV3238))) 
                    (if (slang-built-in::slang-term-equals pV3238 newSrt) 
                        term 
                        (cons 
                         :|Fun| 
                         (vector (svref pV3204 0) newSrt (svref pV3204 2)))))))) 
             (if (eq (car term) :|Var|) 
                 (let ((pV3203 (cdr term))) 
                   (let ((pV3233 (car pV3203))) 
                     (let ((pV3236 (cdr pV3233))) 
                       (return 
                        (let ((newSrt (METASLANG::mapSort-1-1 tsp_maps1 pV3236))) 
                          (if (slang-built-in::slang-term-equals pV3236 newSrt) 
                              term 
                              (cons 
                               :|Var| 
                               (cons (cons (car pV3233) newSrt) (cdr pV3203))))))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV3202 (cdr term))) 
                       (let ((pV3230 (svref pV3202 0))
                             (pV3231 (svref pV3202 1))) 
                         (return 
                          (let ((newDecls 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x1) 
                                     (cons 
                                      (METASLANG::mapPattern-1-1 
                                       tsp_maps1 
                                       (car x1)) 
                                      (mapRec (cdr x1)))) 
                                  pV3230))) 
                            (let ((newBdy (mapRec pV3231))) 
                              (if (lisp::and 
                                   (slang-built-in::slang-term-equals 
                                    pV3230 
                                    newDecls) 
                                   (slang-built-in::slang-term-equals 
                                    pV3231 
                                    newBdy)) 
                                  term 
                                  (cons 
                                   :|Let| 
                                   (vector newDecls newBdy (svref pV3202 2))))))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV3201 (cdr term))) 
                           (let ((pV3227 (svref pV3201 0))
                                 (pV3228 (svref pV3201 1))) 
                             (return 
                              (let ((newDecls 
                                     (LIST-SPEC::|!map|-1-1 
                                      #'(lambda (x1) 
                                         (let ((pV3188 (car x1))) 
                                           (block 
                                            nil 
                                            (return 
                                             (cons 
                                              (cons 
                                               (car pV3188) 
                                               (METASLANG::mapSort-1-1 
                                                tsp_maps1 
                                                (cdr pV3188))) 
                                              (mapRec (cdr x1)))) 
                                            (error 
                                             "Nonexhaustive match failure in mapTerm")))) 
                                      pV3227))) 
                                (let ((newBdy (mapRec pV3228))) 
                                  (if (lisp::and 
                                       (slang-built-in::slang-term-equals 
                                        pV3227 
                                        newDecls) 
                                       (slang-built-in::slang-term-equals 
                                        pV3228 
                                        newBdy)) 
                                      term 
                                      (cons 
                                       :|LetRec| 
                                       (vector newDecls newBdy (svref pV3201 2))))))))) 
                         (if (eq (car term) :|Record|) 
                             (let ((pV3200 (cdr term))) 
                               (let ((pV3225 (car pV3200))) 
                                 (return 
                                  (let ((newRow 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x1) 
                                             (cons (car x1) (mapRec (cdr x1)))) 
                                          pV3225))) 
                                    (if (slang-built-in::slang-term-equals 
                                         pV3225 
                                         newRow) 
                                        term 
                                        (cons 
                                         :|Record| 
                                         (cons newRow (cdr pV3200)))))))) 
                             (if (eq (car term) :|IfThenElse|) 
                                 (let ((pV3199 (cdr term))) 
                                   (let ((pV3221 (svref pV3199 0))
                                         (pV3222 (svref pV3199 1))
                                         (pV3223 (svref pV3199 2))) 
                                     (return 
                                      (let ((newT1 (mapRec pV3221))) 
                                        (let ((newT2 (mapRec pV3222))) 
                                          (let ((newT3 (mapRec pV3223))) 
                                            (if (lisp::and 
                                                 (slang-built-in::slang-term-equals 
                                                  newT1 
                                                  pV3221) 
                                                 (lisp::and 
                                                  (slang-built-in::slang-term-equals 
                                                   newT2 
                                                   pV3222) 
                                                  (slang-built-in::slang-term-equals 
                                                   newT3 
                                                   pV3223))) 
                                                term 
                                                (cons 
                                                 :|IfThenElse| 
                                                 (vector 
                                                  newT1 
                                                  newT2 
                                                  newT3 
                                                  (svref pV3199 3)))))))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (let ((pV3198 (cdr term))) 
                                       (let ((pV3219 (car pV3198))) 
                                         (return 
                                          (let ((|!newMatch| 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'(lambda (x1) 
                                                     (vector 
                                                      (METASLANG::mapPattern-1-1 
                                                       tsp_maps1 
                                                       (svref x1 0)) 
                                                      (mapRec (svref x1 1)) 
                                                      (mapRec (svref x1 2)))) 
                                                  pV3219))) 
                                            (if (slang-built-in::slang-term-equals 
                                                 pV3219 
                                                 |!newMatch|) 
                                                term 
                                                (cons 
                                                 :|Lambda| 
                                                 (cons |!newMatch| (cdr pV3198)))))))) 
                                     (if (eq (car term) :|Bind|) 
                                         (let ((pV3197 (cdr term))) 
                                           (let ((pV3216 (svref pV3197 1))
                                                 (pV3217 (svref pV3197 2))) 
                                             (return 
                                              (let ((newVars 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x1) 
                                                         (cons 
                                                          (car x1) 
                                                          (METASLANG::mapSort-1-1 
                                                           tsp_maps1 
                                                           (cdr x1)))) 
                                                      pV3216))) 
                                                (let ((newTrm (mapRec pV3217))) 
                                                  (if (lisp::and 
                                                       (slang-built-in::slang-term-equals 
                                                        pV3216 
                                                        newVars) 
                                                       (slang-built-in::slang-term-equals 
                                                        pV3217 
                                                        newTrm)) 
                                                      term 
                                                      (cons 
                                                       :|Bind| 
                                                       (vector 
                                                        (svref pV3197 0) 
                                                        newVars 
                                                        newTrm 
                                                        (svref pV3197 3))))))))) 
                                         (if (eq (car term) :|Apply|) 
                                             (let ((pV3196 (cdr term))) 
                                               (let ((pV3212 (svref pV3196 0))
                                                     (pV3213 (svref pV3196 1))) 
                                                 (return 
                                                  (let ((newT1 (mapRec pV3212))) 
                                                    (let ((newT2 (mapRec pV3213))) 
                                                      (if (lisp::and 
                                                           (slang-built-in::slang-term-equals 
                                                            newT1 
                                                            pV3212) 
                                                           (slang-built-in::slang-term-equals 
                                                            newT2 
                                                            pV3213)) 
                                                          term 
                                                          (cons 
                                                           :|Apply| 
                                                           (vector 
                                                            (mapRec newT1) 
                                                            (mapRec newT2) 
                                                            (svref pV3196 2))))))))) 
                                             (if (eq (car term) :|Seq|) 
                                                 (let ((pV3195 (cdr term))) 
                                                   (let ((pV3210 (car pV3195))) 
                                                     (return 
                                                      (let ((newTerms 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'mapRec 
                                                              pV3210))) 
                                                        (if (slang-built-in::slang-term-equals 
                                                             newTerms 
                                                             pV3210) 
                                                            term 
                                                            (cons 
                                                             :|Seq| 
                                                             (cons 
                                                              newTerms 
                                                              (cdr pV3195)))))))) 
                                                 (if (eq (car term) :|ApplyN|) 
                                                     (let ((pV3194 (cdr term))) 
                                                       (let ((pV3208 
                                                              (car pV3194))) 
                                                         (return 
                                                          (let ((newTerms 
                                                                 (LIST-SPEC::|!map|-1-1 
                                                                  #'mapRec 
                                                                  pV3208))) 
                                                            (if (slang-built-in::slang-term-equals 
                                                                 newTerms 
                                                                 pV3208) 
                                                                term 
                                                                (cons 
                                                                 :|ApplyN| 
                                                                 (cons 
                                                                  newTerms 
                                                                  (cdr pV3194)))))))) 
                                                     (if (eq 
                                                          (car term) 
                                                          :|SortedTerm|) 
                                                         (let ((pV3193 
                                                                (cdr term))) 
                                                           (let ((pV3205 
                                                                  (svref 
                                                                   pV3193 
                                                                   0))
                                                                 (pV3206 
                                                                  (svref 
                                                                   pV3193 
                                                                   1))) 
                                                             (return 
                                                              (let ((newTrm 
                                                                     (mapRec 
                                                                      pV3205))) 
                                                                (let ((newSrt 
                                                                       (METASLANG::mapSort-1-1 
                                                                        tsp_maps1 
                                                                        pV3206))) 
                                                                  (if (lisp::and 
                                                                       (slang-built-in::slang-term-equals 
                                                                        newTrm 
                                                                        pV3205) 
                                                                       (slang-built-in::slang-term-equals 
                                                                        pV3206 
                                                                        newSrt)) 
                                                                      term 
                                                                      (cons 
                                                                       :|SortedTerm| 
                                                                       (vector 
                                                                        newTrm 
                                                                        newSrt 
                                                                        (svref 
                                                                         pV3193 
                                                                         2))))))))))))))))))))) 
         (error "Nonexhaustive match failure in mapTerm")))) (mapRec term))))
                                                                             
(defun METASLANG::mapSort-1-1 (tsp_maps srt) 
  (let ((sort_map (svref tsp_maps 1))) 
    (labels 
      ((mapRec (tsp_maps1 sort_map srt) 
        (funcall sort_map (mapS tsp_maps1 sort_map srt)))
       (mapRecOpt (tsp_maps1 sort_map opt_sort) 
        (block 
         nil 
         (if (eq (car opt_sort) :|None|) 
             (return '(:|None|)) 
             (if (eq (car opt_sort) :|Some|) 
                 (return 
                  (cons :|Some| (mapRec tsp_maps1 sort_map (cdr opt_sort)))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapSRow (tsp_maps1 sort_map row) 
        (block 
         nil 
         (if (null row) 
             (return nil) 
             (if (consp row) 
                 (let ((pV3180 (car row))) 
                   (return 
                    (LIST-SPEC::|!cons| 
                     (cons (car pV3180) (mapRec tsp_maps1 sort_map (cdr pV3180))) 
                     (mapSRow tsp_maps1 sort_map (cdr row))))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapSRowOpt (tsp_maps1 sort_map row) 
        (block 
         nil 
         (if (null row) 
             (return nil) 
             (if (consp row) 
                 (let ((pV3174 (car row))) 
                   (return 
                    (LIST-SPEC::|!cons| 
                     (cons 
                      (car pV3174) 
                      (mapRecOpt tsp_maps1 sort_map (cdr pV3174))) 
                     (mapSRowOpt tsp_maps1 sort_map (cdr row))))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapSLst (tsp_maps1 sort_map srts) 
        (block 
         nil 
         (if (null srts) 
             (return nil) 
             (if (consp srts) 
                 (return 
                  (LIST-SPEC::|!cons| 
                   (mapRec tsp_maps1 sort_map (car srts)) 
                   (mapSLst tsp_maps1 sort_map (cdr srts)))))) 
         (error "Nonexhaustive match failure in mapSort")))
       (mapS (tsp_maps1 sort_map srt) 
        (block 
         nil 
         (if (eq (car srt) :|CoProduct|) 
             (let ((pV3149 (cdr srt))) 
               (let ((pV3166 (car pV3149))) 
                 (return 
                  (let ((newRow (mapSRowOpt tsp_maps1 sort_map pV3166))) 
                    (if (slang-built-in::slang-term-equals newRow pV3166) 
                        srt 
                        (cons :|CoProduct| (cons newRow (cdr pV3149)))))))) 
             (if (eq (car srt) :|Product|) 
                 (let ((pV3148 (cdr srt))) 
                   (let ((pV3164 (car pV3148))) 
                     (return 
                      (let ((newRow (mapSRow tsp_maps1 sort_map pV3164))) 
                        (if (slang-built-in::slang-term-equals newRow pV3164) 
                            srt 
                            (cons :|Product| (cons newRow (cdr pV3148)))))))) 
                 (if (eq (car srt) :|Arrow|) 
                     (let ((pV3147 (cdr srt))) 
                       (let ((pV3161 (svref pV3147 0))
                             (pV3162 (svref pV3147 1))) 
                         (return 
                          (let ((newS1 (mapRec tsp_maps1 sort_map pV3161))) 
                            (let ((newS2 (mapRec tsp_maps1 sort_map pV3162))) 
                              (if (lisp::and 
                                   (slang-built-in::slang-term-equals 
                                    newS1 
                                    pV3161) 
                                   (slang-built-in::slang-term-equals 
                                    newS2 
                                    pV3162)) 
                                  srt 
                                  (cons 
                                   :|Arrow| 
                                   (vector newS1 newS2 (svref pV3147 2))))))))) 
                     (if (eq (car srt) :|Quotient|) 
                         (let ((pV3146 (cdr srt))) 
                           (let ((pV3158 (svref pV3146 0))
                                 (pV3159 (svref pV3146 1))) 
                             (return 
                              (let ((newSsrt (mapRec tsp_maps1 sort_map pV3158))) 
                                (let ((newTrm 
                                       (METASLANG::mapTerm-1-1 tsp_maps1 pV3159))) 
                                  (if (lisp::and 
                                       (slang-built-in::slang-term-equals 
                                        newSsrt 
                                        pV3158) 
                                       (slang-built-in::slang-term-equals 
                                        newTrm 
                                        pV3159)) 
                                      srt 
                                      (cons 
                                       :|Quotient| 
                                       (vector newSsrt newTrm (svref pV3146 2))))))))) 
                         (if (eq (car srt) :|Subsort|) 
                             (let ((pV3145 (cdr srt))) 
                               (let ((pV3155 (svref pV3145 0))
                                     (pV3156 (svref pV3145 1))) 
                                 (return 
                                  (let ((newSsrt 
                                         (mapRec tsp_maps1 sort_map pV3155))) 
                                    (let ((newTrm 
                                           (METASLANG::mapTerm-1-1 
                                            tsp_maps1 
                                            pV3156))) 
                                      (if (lisp::and 
                                           (slang-built-in::slang-term-equals 
                                            newSsrt 
                                            pV3155) 
                                           (slang-built-in::slang-term-equals 
                                            newTrm 
                                            pV3156)) 
                                          srt 
                                          (cons 
                                           :|Subsort| 
                                           (vector 
                                            newSsrt 
                                            newTrm 
                                            (svref pV3145 2))))))))) 
                             (if (eq (car srt) :|Base|) 
                                 (let ((pV3144 (cdr srt))) 
                                   (let ((pV3153 (svref pV3144 1))) 
                                     (return 
                                      (let ((newSrts 
                                             (mapSLst tsp_maps1 sort_map pV3153))) 
                                        (if (slang-built-in::slang-term-equals 
                                             newSrts 
                                             pV3153) 
                                            srt 
                                            (cons 
                                             :|Base| 
                                             (vector 
                                              (svref pV3144 0) 
                                              newSrts 
                                              (svref pV3144 2)))))))) 
                                 (if (eq (car srt) :|MetaTyVar|) 
                                     (let ((pV3143 (cdr srt))) 
                                       (return 
                                        (let ((pV3137 (STATE::|!!| (car pV3143)))) 
                                          (block 
                                           nil 
                                           (let ((pV3138 (svref pV3137 0))) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV3138) :|None|) 
                                                   (return srt) 
                                                   (if (eq (car pV3138) :|Some|) 
                                                       (let ((pV3136 
                                                              (cdr pV3138))) 
                                                         (return 
                                                          (let ((|!newssrt| 
                                                                 (mapRec 
                                                                  tsp_maps1 
                                                                  sort_map 
                                                                  pV3136))) 
                                                            (if (slang-built-in::slang-term-equals 
                                                                 |!newssrt| 
                                                                 pV3136) 
                                                                srt 
                                                                (cons 
                                                                 :|MetaTyVar| 
                                                                 (cons 
                                                                  (cons 
                                                                   :|Ref| 
                                                                   (vector 
                                                                    (cons 
                                                                     :|Some| 
                                                                     |!newssrt|) 
                                                                    (svref 
                                                                     pV3137 
                                                                     1) 
                                                                    (svref 
                                                                     pV3137 
                                                                     2))) 
                                                                  (cdr pV3143))))))))) 
                                               (error 
                                                "Nonexhaustive match failure in mapSort")))) 
                                           (error 
                                            "Nonexhaustive match failure in mapSort")))))))))))) 
         (return srt)))) (mapRec tsp_maps sort_map srt))))
                                                          
(defun mapSortOpt-1-1 (tsp_maps opt_sort) 
  (block 
   nil 
   (if (eq (car opt_sort) :|None|) 
       (return '(:|None|)) 
       (if (eq (car opt_sort) :|Some|) 
           (return 
            (cons :|Some| (METASLANG::mapSort-1-1 tsp_maps (cdr opt_sort)))))) 
   (error "Nonexhaustive match failure in mapSortOpt")))
                                                        
(defun mapSortOpt-1 (x1) #'(lambda (x2) (mapSortOpt-1-1 x1 x2)))
                                                                
(defun mapSortOpt (x0 x1 x2) (mapSortOpt-1 (vector x0 x1 x2)))
                                                              
(defun mapTermOpt-1-1 (tsp_maps opt_term) 
  (block 
   nil 
   (if (eq (car opt_term) :|None|) 
       (return '(:|None|)) 
       (if (eq (car opt_term) :|Some|) 
           (return 
            (cons :|Some| (METASLANG::mapTerm-1-1 tsp_maps (cdr opt_term)))))) 
   (error "Nonexhaustive match failure in mapTermOpt")))
                                                        
(defun mapSpec-1-1 (tsp_maps x) 
  (vector 
   (svref x 0) 
   (mapAQualifierMap-1-1 
    #'(lambda (x1) 
       (let ((pV109 (svref x1 2))) 
         (block 
          nil 
          (return 
           (vector 
            (svref x1 0) 
            (svref x1 1) 
            (cons (car pV109) (METASLANG::mapSort-1-1 tsp_maps (cdr pV109))) 
            (mapTermOpt-1-1 tsp_maps (svref x1 3)))) 
          (error "Nonexhaustive match failure in mapSpec")))) 
    (svref x 1)) 
   (LIST-SPEC::|!map|-1-1 
    #'(lambda (x1) 
       (vector 
        (svref x1 0) 
        (svref x1 1) 
        (svref x1 2) 
        (METASLANG::mapTerm-1-1 tsp_maps (svref x1 3)))) 
    (svref x 2)) 
   (mapAQualifierMap-1-1 
    #'(lambda (x1) 
       (vector (svref x1 0) (svref x1 1) (mapSortOpt-1-1 tsp_maps (svref x1 2)))) 
    (svref x 3))))
                  
(defun mapSpec-1 (x1) #'(lambda (x2) (mapSpec-1-1 x1 x2)))
                                                          
(defun mapSpec (x0 x1 x2) (mapSpec-1 (vector x0 x1 x2)))
                                                        
(defun mapTermOpt-1 (x1) #'(lambda (x2) (mapTermOpt-1-1 x1 x2)))
                                                                
(defun mapTermOpt (x0 x1 x2) (mapTermOpt-1 (vector x0 x1 x2)))
                                                              
(defun SPLAYMAP::api-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|SplayNil|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8524 (cdr sp))) 
             (let ((pV8527 (svref pV8524 2))) 
               (return 
                (let ((left (SPLAYMAP::api-1-1 af (svref pV8524 0)))) 
                  (let ((value (cons (car pV8527) (funcall af pV8527)))) 
                    (cons 
                     :|SplayObj| 
                     (vector left (SPLAYMAP::api-1-1 af (svref pV8524 1)) value))))))))) 
   (error "Nonexhaustive match failure in api")))
                                                 
(defun SPLAYMAP::mapi-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return (cons :|EMPTY| (cdr |!map|))) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV8772 (cdr |!map|))) 
             (return 
              (cons 
               :|MAP| 
               (vector 
                (svref pV8772 0) 
                (svref pV8772 1) 
                (cons 
                 :|Ref| 
                 (SPLAYMAP::api-1-1 af (STATE::|!!| (svref pV8772 2)))))))))) 
   (error "Nonexhaustive match failure in mapi")))
                                                  
(defun STRINGMAP::mapi-1-1 (x0 x1) (SPLAYMAP::mapi-1-1 x0 x1))
                                                              
(defun STRINGMAP::mapiDouble-1-1 (f m) 
  (STRINGMAP::mapi-1-1 
   #'(lambda (x) 
      (let ((x1 (car x))) 
        (STRINGMAP::mapi-1-1 
         #'(lambda (x01) (funcall f (vector x1 (car x01) (cdr x01)))) 
         (cdr x)))) 
   m))
      
(defun STRINGMAP::mapiDouble (x1) 
  #'(lambda (x2) (STRINGMAP::mapiDouble-1-1 x1 x2)))
                                                    
(defun mapiAQualifierMap (x) (STRINGMAP::mapiDouble x))
                                                       
(defun mapiAQualifierMap-1-1 (x0 x1) (STRINGMAP::mapiDouble-1-1 x0 x1))
                                                                       
(defun memberNames-1 (x) (memberNames (car x) (cdr x)))
                                                       
(defun memberQualifiedId-1 (x) 
  (memberQualifiedId (svref x 0) (svref x 1) (svref x 2)))
                                                          
(defun opInfosAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((new_list (svref x 3))
            (this_op_info (svref x 2))) 
        (if (LIST-SPEC::|!exists|-1-1 
             #'(lambda (old_info) (equalOpInfo? old_info this_op_info)) 
             new_list) 
            new_list 
            (LIST-SPEC::|!cons| this_op_info new_list)))) 
   nil 
   (svref spc 1)))
                  
(defun opInfosAsList (x0 x1 x2 x3) (opInfosAsList-1 (vector x0 x1 x2 x3)))
                                                                          
(defun opNames-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) (LIST-SPEC::concat (svref x 3) (cons (svref x 1) nil))) 
   nil 
   (svref spc 1)))
                  
(defun opNames (x0 x1 x2 x3) (opNames-1 (vector x0 x1 x2 x3)))
                                                              
(defun opsAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (LIST-SPEC::|!cons| 
       (vector (svref x 0) (svref x 1) (svref x 2)) 
       (svref x 3))) 
   nil 
   (svref spc 1)))
                  
(defun opsAsList (x0 x1 x2 x3) (opsAsList-1 (vector x0 x1 x2 x3)))
                                                                  
(defun STRINGMAP::foldri-1-1-1 (x0 x1 x2) (SPLAYMAP::foldri-1-1-1 x0 x1 x2))
                                                                            
(defun qualifiers (m) 
  (STRINGMAP::foldri-1-1-1 
   #'(lambda (x) (LIST-SPEC::|!cons| (svref x 0) (svref x 2))) 
   nil 
   m))
      
(defun setImportInfo (pV125 pV126) 
  (block 
   nil 
   (return (vector pV126 (svref pV125 1) (svref pV125 2) (svref pV125 3))) 
   (error "Nonexhaustive match failure in setImportInfo")))
                                                           
(defun setImportInfo-1 (x) (setImportInfo (car x) (cdr x)))
                                                           
(defun setImportedSpec (pV132 pV133) 
  (block 
   nil 
   (let ((pV134 (svref pV132 0))) 
     (return 
      (vector 
       (vector 
        (cons 
         :|Some| 
         (vector (svref pV133 0) (svref pV133 1) (svref pV133 2) (svref pV133 3))) 
        (svref pV134 1) 
        (svref pV134 2) 
        (svref pV134 3)) 
       (svref pV132 1) 
       (svref pV132 2) 
       (svref pV132 3)))) 
   (error "Nonexhaustive match failure in setImportedSpec")))
                                                             
(defun setImportedSpec-1 (x) (setImportedSpec (car x) (cdr x)))
                                                               
(defun setImports-1 (x) (setImports (car x) (cdr x)))
                                                     
(defun setLocalOps (pV154 pV155) 
  (block 
   nil 
   (let ((pV156 (svref pV154 0))) 
     (return 
      (vector 
       (vector (svref pV156 0) (svref pV156 1) pV155 (svref pV156 3)) 
       (svref pV154 1) 
       (svref pV154 2) 
       (svref pV154 3)))) 
   (error "Nonexhaustive match failure in setLocalOps")))
                                                         
(defun setLocalOps-1 (x) (setLocalOps (car x) (cdr x)))
                                                       
(defun setLocalSorts (pV165 pV166) 
  (block 
   nil 
   (let ((pV167 (svref pV165 0))) 
     (return 
      (vector 
       (vector (svref pV167 0) (svref pV167 1) (svref pV167 2) pV166) 
       (svref pV165 1) 
       (svref pV165 2) 
       (svref pV165 3)))) 
   (error "Nonexhaustive match failure in setLocalSorts")))
                                                           
(defun setLocalSorts-1 (x) (setLocalSorts (car x) (cdr x)))
                                                           
(defun setOps-1 (x) (setOps (car x) (cdr x)))
                                             
(defun setProperties-1 (x) (setProperties (car x) (cdr x)))
                                                           
(defun setSorts-1 (x) (setSorts (car x) (cdr x)))
                                                 
(defun sortInfosAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((new_list (svref x 3))
            (this_sort_info (svref x 2))) 
        (if (LIST-SPEC::|!exists|-1-1 
             #'(lambda (old_info) (equalSortInfo? old_info this_sort_info)) 
             new_list) 
            new_list 
            (LIST-SPEC::|!cons| this_sort_info new_list)))) 
   nil 
   (svref spc 3)))
                  
(defun sortInfosAsList (x0 x1 x2 x3) (sortInfosAsList-1 (vector x0 x1 x2 x3)))
                                                                              
(defun sortNames-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) (LIST-SPEC::concat (svref x 3) (cons (svref x 1) nil))) 
   nil 
   (svref spc 3)))
                  
(defun sortNames (x0 x1 x2 x3) (sortNames-1 (vector x0 x1 x2 x3)))
                                                                  
(defun sortsAsList-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (LIST-SPEC::|!cons| 
       (vector (svref x 0) (svref x 1) (svref x 2)) 
       (svref x 3))) 
   nil 
   (svref spc 3)))
                  
(defun sortsAsList (x0 x1 x2 x3) (sortsAsList-1 (vector x0 x1 x2 x3)))
                                                                      
(defun specOps-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (let ((pV185 (svref (svref x 2) 2))) 
         (return 
          (LIST-SPEC::|!cons| 
           (vector (svref x 0) (svref x 1) (car pV185) (cdr pV185)) 
           (svref x 3)))) 
       (error "Nonexhaustive match failure in specOps"))) 
   nil 
   (svref spc 1)))
                  
(defun specOps (x0 x1 x2 x3) (specOps-1 (vector x0 x1 x2 x3)))
                                                              
(defun specSorts-1 (spc) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (return 
        (LIST-SPEC::|!cons| 
         (vector (svref x 0) (svref x 1) (svref (svref x 2) 1)) 
         (svref x 3))) 
       (error "Nonexhaustive match failure in specSorts"))) 
   nil 
   (svref spc 3)))
                  
(defun specSorts (x0 x1 x2 x3) (specSorts-1 (vector x0 x1 x2 x3)))
                                                                  
(defun LIST-SPEC::foldl-1-1-1 (f base s) 
  (block 
   nil 
   (if (null s) 
       (return base) 
       (if (consp s) 
           (return 
            (LIST-SPEC::foldl-1-1-1 f (funcall f (cons (car s) base)) (cdr s))))) 
   (error "Nonexhaustive match failure in foldl")))
                                                   
(defun subtractSpec-1-1 (x y) 
  (vector 
   (svref x 0) 
   (mapDiff-1-1 (svref x 1) (svref y 1)) 
   (LIST-SPEC::foldl-1-1-1 
    #'(lambda (x0) 
       (let ((x (car x0))
             (l (cdr x0))) 
         (if (LIST-SPEC::|!member| x (svref y 2)) l (cons x l)))) 
    nil 
    (svref x 2)) 
   (mapDiff-1-1 (svref x 3) (svref y 3))))
                                          
(defun subtractSpec-1 (x1) #'(lambda (x2) (subtractSpec-1-1 x1 x2)))
                                                                    
(defun subtractSpec (x0 x1 x2 x3) (subtractSpec-1 (vector x0 x1 x2 x3)))
                                                                        
(defun INTEGER-SPEC::compare (n m) 
  (if (INTEGER-SPEC::|!<| n m) 
      '(:|Less|) 
      (if ( =  n m) '(:|Equal|) '(:|Greater|))))
                                                
(defun INTEGER-SPEC::compare-1 (x) (INTEGER-SPEC::compare (car x) (cdr x)))
                                                                           
(defun SPLAYSET::empty (comp) (cons :|EMPTY| comp))
                                                   
(defparameter INTEGERSET::empty (SPLAYSET::empty #'INTEGER-SPEC::compare-1))
                                                                            
(defparameter NATMAP::empty (SPLAYMAP::empty #'INTEGER-SPEC::compare-1))
                                                                        
(defun ANNSPECPRINTER::initialize (pp printSort?) 
  (vector 
   INTEGERSET::empty 
   (cons :|Ref| 0) 
   nil 
   (cons :|Ref| NATMAP::empty) 
   pp 
   printSort? 
   INTEGERSET::empty))
                      
(defun ANNSPECPRINTER::isShortTuple (i row) 
  (block 
   nil 
   (if (null row) 
       (return t) 
       (if (consp row) 
           (return 
            (lisp::and 
             (string=  (car (car row)) (NAT-SPEC::toString i)) 
             (ANNSPECPRINTER::isShortTuple (INTEGER-SPEC::|!+| i 1) (cdr row)))))) 
   (error "Nonexhaustive match failure in isShortTuple")))
                                                          
(defun ANNSPECPRINTER::markSubterm?-1 (c) (svref c 2))
                                                      
(defun ANNSPECPRINTER::isFiniteList (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV285 (svref (cdr term) 0))) 
         (if (eq (car pV285) :|Embed|) 
             (let ((pV288 (cdr pV285))) 
               (if (string=  "Nil" (car pV288)) 
                   (if (eq nil (cdr pV288)) (return (cons :|Some| nil))))))) 
       (if (eq (car term) :|Apply|) 
           (let ((pV226 (cdr term))) 
             (let ((pV263 (svref pV226 1))
                   (pV262 (svref pV226 0))) 
               (if (eq (car pV262) :|Fun|) 
                   (let ((pV266 (svref (cdr pV262) 0))) 
                     (if (eq (car pV266) :|Embed|) 
                         (let ((pV269 (cdr pV266))) 
                           (if (string=  "Cons" (car pV269)) 
                               (if (eq t (cdr pV269)) 
                                   (if (eq (car pV263) :|Record|) 
                                       (let ((pV273 (car (cdr pV263)))) 
                                         (if (consp pV273) 
                                             (let ((pV277 (cdr pV273))) 
                                               (if (consp pV277) 
                                                   (if (null (cdr pV277)) 
                                                       (return 
                                                        (let ((pV211 
                                                               (ANNSPECPRINTER::isFiniteList 
                                                                (cdr (car pV277))))) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car pV211) 
                                                                :|Some|) 
                                                               (return 
                                                                (cons 
                                                                 :|Some| 
                                                                 (LIST-SPEC::|!cons| 
                                                                  (cdr 
                                                                   (car pV273)) 
                                                                  (cdr pV211)))) 
                                                               (if (eq 
                                                                    (car pV211) 
                                                                    :|None|) 
                                                                   (return 
                                                                    '(:|None|)))) 
                                                           (error 
                                                            "Nonexhaustive match failure in isFiniteList")))))))))))))))))) 
           (if (eq (car term) :|ApplyN|) 
               (let ((pV228 (car (cdr term)))) 
                 (if (consp pV228) 
                     (let ((pV232 (cdr pV228))
                           (pV231 (car pV228))) 
                       (if (eq (car pV231) :|Fun|) 
                           (let ((pV234 (svref (cdr pV231) 0))) 
                             (if (eq (car pV234) :|Embed|) 
                                 (let ((pV237 (cdr pV234))) 
                                   (if (string=  "Cons" (car pV237)) 
                                       (if (eq t (cdr pV237)) 
                                           (if (consp pV232) 
                                               (let ((pV242 (cdr pV232))) 
                                                 (if (consp pV242) 
                                                     (let ((pV245 (cdr pV242))
                                                           (pV244 (car pV242))) 
                                                       (if (eq 
                                                            (car pV244) 
                                                            :|Record|) 
                                                           (let ((pV247 
                                                                  (car 
                                                                   (cdr pV244)))) 
                                                             (if (consp pV247) 
                                                                 (let ((pV251 
                                                                        (cdr 
                                                                         pV247))) 
                                                                   (if (consp 
                                                                        pV251) 
                                                                       (if (null 
                                                                            (cdr 
                                                                             pV251)) 
                                                                           (if (consp 
                                                                                pV245) 
                                                                               (if (null 
                                                                                    (cdr 
                                                                                     pV245)) 
                                                                                   (return 
                                                                                    (let ((pV221 
                                                                                           (ANNSPECPRINTER::isFiniteList 
                                                                                            (cdr 
                                                                                             (car 
                                                                                              pV251))))) 
                                                                                      (block 
                                                                                       nil 
                                                                                       (if (eq 
                                                                                            (car 
                                                                                             pV221) 
                                                                                            :|Some|) 
                                                                                           (return 
                                                                                            (cons 
                                                                                             :|Some| 
                                                                                             (LIST-SPEC::|!cons| 
                                                                                              (cdr 
                                                                                               (car 
                                                                                                pV247)) 
                                                                                              (cdr 
                                                                                               pV221)))) 
                                                                                           (if (eq 
                                                                                                (car 
                                                                                                 pV221) 
                                                                                                :|None|) 
                                                                                               (return 
                                                                                                '(:|None|)))) 
                                                                                       (error 
                                                                                        "Nonexhaustive match failure in isFiniteList")))))))))))))))))))))))))))) 
   (return '(:|None|))))
                        
(defun LISTUTILITIES::mapWithIndexRec (f ls i) 
  (block 
   nil 
   (if (null ls) 
       (return nil) 
       (if (consp ls) 
           (return 
            (LIST-SPEC::|!cons| 
             (funcall f (cons i (car ls))) 
             (LISTUTILITIES::mapWithIndexRec f (cdr ls) (INTEGER-SPEC::|!+| i 1)))))) 
   (error "Nonexhaustive match failure in mapWithIndexRec")))
                                                             
(defun LISTUTILITIES::mapWithIndex-1-1 (f l) 
  (LISTUTILITIES::mapWithIndexRec f l 0))
                                         
(defun PRETTYPRINT::blankLines (n text) 
  (if (INTEGER-SPEC::|!<=| n 0) 
      text 
      (cons (cons 0 nil) (PRETTYPRINT::blankLines (INTEGER-SPEC::|!-| n 1) text))))


(defun PRETTYPRINT::addBreak (indent |!newlines| text) 
  (cons (cons indent nil) (PRETTYPRINT::blankLines |!newlines| text)))
                                                                      
(defun PRETTYPRINT::lengthStrings (strings) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (return (INTEGER-SPEC::|!+| (cdr x) (car (car x)))) 
       (error "Nonexhaustive match failure in lengthStrings"))) 
   0 
   strings))
            
(defun PRETTYPRINT::lengthLast (|!t|) 
  (block 
   nil 
   (if (null |!t|) 
       (return 0) 
       (if (consp |!t|) 
           (let ((pV4759 (car |!t|))) 
             (return 
              (INTEGER-SPEC::|!+| 
               (car pV4759) 
               (PRETTYPRINT::lengthStrings (cdr pV4759))))))) 
   (error "Nonexhaustive match failure in lengthLast")))
                                                        
(defun PRETTYPRINT::fits? (columns width text) 
  (INTEGER-SPEC::|!<=| 
   (INTEGER-SPEC::|!+| (PRETTYPRINT::lengthLast text) width) 
   columns))
            
(defun PRETTYPRINT::formatPretty (columns p text) 
  (funcall (cdr p) (cons columns text)))
                                        
(defun PRETTYPRINT::formatLines (columns lines text |!break|) 
  (labels 
    ((formatRestLines (lines text) 
      (block 
       nil 
       (if (null lines) 
           (return text) 
           (if (consp lines) 
               (let ((pV4737 (car lines))) 
                 (return 
                  (formatRestLines 
                   (cdr lines) 
                   (funcall |!break| (vector (car pV4737) (cdr pV4737) text))))))) 
       (error "Nonexhaustive match failure in formatLines")))) 
    (block 
     nil 
     (if (null lines) 
         (return text) 
         (if (consp lines) 
             (return 
              (formatRestLines 
               (cdr lines) 
               (PRETTYPRINT::formatPretty columns (cdr (car lines)) text))))) 
     (error "Nonexhaustive match failure in formatLines"))))
                                                            
(defun PRETTYPRINT::pretty (width |!format|) (cons width |!format|))
                                                                    
(defun PRETTYPRINT::widthPretty-1 (p) (car p))
                                              
(defun PRETTYPRINT::widthLine (indent pretty) 
  (INTEGER-SPEC::|!+| indent (PRETTYPRINT::widthPretty-1 pretty)))
                                                                  
(defun PRETTYPRINT::widthLine-1 (x) (PRETTYPRINT::widthLine (car x) (cdr x)))
                                                                             
(defun PRETTYPRINT::widthLines (lines) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (INTEGER-SPEC::|!+| (PRETTYPRINT::widthLine-1 (car x)) (cdr x))) 
   0 
   lines))
          
(defun PRETTYPRINT::blockFill (|!newlines| lines) 
  (PRETTYPRINT::pretty 
   (PRETTYPRINT::widthLines lines) 
   #'(lambda (x) 
      (let ((text (cdr x))
            (columns (car x))) 
        (let ((start (PRETTYPRINT::lengthLast text))) 
          (PRETTYPRINT::formatLines 
           columns 
           lines 
           text 
           #'(lambda (x1) 
              (let ((text (svref x1 2))
                    (pretty (svref x1 1))) 
                (PRETTYPRINT::formatPretty 
                 columns 
                 pretty 
                 (if (PRETTYPRINT::fits? 
                      columns 
                      (PRETTYPRINT::widthPretty-1 pretty) 
                      text) 
                     text 
                     (PRETTYPRINT::addBreak 
                      (INTEGER-SPEC::|!+| start (svref x1 0)) 
                      |!newlines| 
                      text)))))))))))
                                     
(defun PRETTYPRINT::blockAll (|!newlines| lines) 
  (PRETTYPRINT::pretty 
   (PRETTYPRINT::widthLines lines) 
   #'(lambda (x) 
      (let ((text (cdr x))
            (columns (car x))) 
        (let ((start (PRETTYPRINT::lengthLast text))) 
          (PRETTYPRINT::formatLines 
           columns 
           lines 
           text 
           #'(lambda (x1) 
              (PRETTYPRINT::formatPretty 
               columns 
               (svref x1 1) 
               (PRETTYPRINT::addBreak 
                (INTEGER-SPEC::|!+| start (svref x1 0)) 
                |!newlines| 
                (svref x1 2))))))))))
                                     
(defun PRETTYPRINT::blockAll-1 (x) (PRETTYPRINT::blockAll (car x) (cdr x)))
                                                                           
(defun PRETTYPRINT::prettysBlock-1-1 (|!block| ps) 
  (funcall |!block| 
           (cons 0 (LIST-SPEC::|!map|-1-1 #'(lambda (p) (cons 0 p)) ps))))
                                                                          
(defun PRETTYPRINT::prettysAll (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockAll-1 ps))
                                                               
(defun PRETTYPRINT::blockNone (pV4728 lines) 
  (declare (ignore pV4728)) 
  (PRETTYPRINT::pretty 
   (PRETTYPRINT::widthLines lines) 
   #'(lambda (x) 
      (let ((columns (car x))) 
        (PRETTYPRINT::formatLines 
         columns 
         lines 
         (cdr x) 
         #'(lambda (x1) 
            (PRETTYPRINT::formatPretty columns (svref x1 1) (svref x1 2))))))))
                                                                               
(defun PRETTYPRINT::blockNone-1 (x) (PRETTYPRINT::blockNone (car x) (cdr x)))
                                                                             
(defun PRETTYPRINT::prettysNone (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockNone-1 ps))
                                                                
(defun PRETTYPRINT::extend (|!length| |!string| text) 
  (block 
   nil 
   (if (null text) 
       (return (cons (cons 0 (cons (cons |!length| |!string|) nil)) nil)) 
       (if (consp text) 
           (let ((pV4731 (car text))) 
             (return 
              (cons 
               (cons (car pV4731) (cons (cons |!length| |!string|) (cdr pV4731))) 
               (cdr text)))))) 
   (error "Nonexhaustive match failure in extend")))
                                                    
(defun PRETTYPRINT::lengthString (l s) 
  (PRETTYPRINT::pretty l #'(lambda (x) (PRETTYPRINT::extend l s (cdr x)))))
                                                                           
(defun PRETTYPRINT::|!string| (s) 
  (PRETTYPRINT::lengthString (STRING-SPEC::|!length| s) s))
                                                           
(defun ANNSPECPRINTER::printLambda (context path marker match) 
  (let ((pp (svref context 4))) 
    (labels 
      ((prRule (marker) 
        #'(lambda (x) 
           (let ((pV944 (cdr x))
                 (pV943 (car x))) 
             (block 
              nil 
              (let ((pV947 (svref pV944 2))
                    (pV946 (svref pV944 1))
                    (pV945 (svref pV944 0))) 
                (return 
                 (block 
                  nil 
                  (if (eq (car pV946) :|Fun|) 
                      (let ((pV939 (svref (cdr pV946) 0))) 
                        (if (eq (car pV939) :|Bool|) 
                            (if (eq t (cdr pV939)) 
                                (return 
                                 (PRETTYPRINT::blockFill 
                                  0 
                                  (cons 
                                   (cons 
                                    0 
                                    (PRETTYPRINT::prettysNone 
                                     (cons 
                                      marker 
                                      (cons 
                                       (ANNSPECPRINTER::ppPattern-1-1-1 
                                        context 
                                        (cons 
                                         (LIST-SPEC::|!++| 
                                          (cons 0 (cons pV943 nil)) 
                                          path) 
                                         t) 
                                        pV945) 
                                       (cons (svref pp 1) nil))))) 
                                   (cons 
                                    (cons 
                                     3 
                                     (ANNSPECPRINTER::ppTerm-1-1-1 
                                      context 
                                      (cons 
                                       (LIST-SPEC::|!++| 
                                        (cons 2 (cons pV943 nil)) 
                                        path) 
                                       '(:|Top|)) 
                                      pV947)) 
                                    nil)))))))) 
                  (return 
                   (PRETTYPRINT::blockFill 
                    0 
                    (cons 
                     (cons 
                      0 
                      (PRETTYPRINT::prettysNone 
                       (cons 
                        marker 
                        (cons 
                         (ANNSPECPRINTER::ppPattern-1-1-1 
                          context 
                          (cons 
                           (LIST-SPEC::|!++| (cons 0 (cons pV943 nil)) path) 
                           t) 
                          pV945) 
                         (cons 
                          (PRETTYPRINT::|!string| " ") 
                          (cons 
                           (svref pp 37) 
                           (cons 
                            (PRETTYPRINT::|!string| " ") 
                            (cons 
                             (ANNSPECPRINTER::ppTerm-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 (cons pV943 nil)) path) 
                               '(:|Top|)) 
                              pV946) 
                             (cons (svref pp 1) nil))))))))) 
                     (cons 
                      (cons 
                       3 
                       (ANNSPECPRINTER::ppTerm-1-1-1 
                        context 
                        (cons 
                         (LIST-SPEC::|!++| (cons 3 (cons pV943 nil)) path) 
                         '(:|Top|)) 
                        pV947)) 
                      nil))))))) 
              (error "Nonexhaustive match failure in printLambda")))))) 
      (PRETTYPRINT::prettysAll 
       (block 
        nil 
        (if (null match) 
            (return nil) 
            (if (consp match) 
                (return 
                 (LIST-SPEC::|!++| 
                  (cons (funcall (prRule marker) (cons 0 (car match))) nil) 
                  (LISTUTILITIES::mapWithIndex-1-1 
                   #'(lambda (x) 
                      (funcall (prRule (svref pp 3)) 
                               (cons (INTEGER-SPEC::|!+| (car x) 1) (cdr x)))) 
                   (cdr match)))))) 
        (error "Nonexhaustive match failure in printLambda"))))))
                                                                 
(defun METASLANG::mkABase (qid srts a) (cons :|Base| (vector qid srts a)))
                                                                          
(defun METASLANG::boolSort (a) 
  (METASLANG::mkABase (cons :|Qualified| (cons "Boolean" "Boolean")) nil a))
                                                                            
(defun METASLANG::mkTrueA (a) 
  (cons :|Fun| (vector (cons :|Bool| t) (METASLANG::boolSort a) a)))
                                                                    
(defun PRETTYPRINT::blockFill-1 (x) (PRETTYPRINT::blockFill (car x) (cdr x)))
                                                                             
(defun PRETTYPRINT::prettysFill (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockFill-1 ps))
                                                                
(defun ANNSPECPRINTER::printOp (context pp termOp srt a) 
  (block 
   nil 
   (if (eq (car termOp) :|Op|) 
       (return (funcall (svref pp 42) (car (cdr termOp)))) 
       (if (eq (car termOp) :|Bool|) 
           (return (funcall (svref pp 38) (BOOLEAN-SPEC::toString (cdr termOp)))) 
           (if (eq (car termOp) :|Nat|) 
               (return (funcall (svref pp 38) (NAT-SPEC::toString (cdr termOp)))) 
               (if (eq (car termOp) :|String|) 
                   (return 
                    (funcall (svref pp 38) 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ "\"" (cdr termOp)) 
                              "\""))) 
                   (if (eq (car termOp) :|Char|) 
                       (return 
                        (funcall (svref pp 38) 
                                 (STRING-SPEC::^ 
                                  "#" 
                                  (CHAR-SPEC::toString (cdr termOp))))) 
                       (if (eq (car termOp) :|Embed|) 
                           (return (funcall (svref pp 38) (car (cdr termOp)))) 
                           (if (eq (car termOp) :|Project|) 
                               (return 
                                (funcall (svref pp 38) 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ 
                                           "project(" 
                                           (cdr termOp)) 
                                          ")"))) 
                               (if (eq (car termOp) :|Embedded|) 
                                   (return 
                                    (funcall (svref pp 38) 
                                             (STRING-SPEC::^ 
                                              (STRING-SPEC::^ 
                                               "embed?(" 
                                               (cdr termOp)) 
                                              ")"))) 
                                   (if (eq (car termOp) :|Quotient|) 
                                       (return 
                                        (funcall (svref pp 38) "quotient")) 
                                       (if (eq (car termOp) :|Choose|) 
                                           (return 
                                            (funcall (svref pp 38) "choose")) 
                                           (if (eq (car termOp) :|PQuotient|) 
                                               (return 
                                                (funcall (svref pp 38) 
                                                         "quotient")) 
                                               (if (eq (car termOp) :|PChoose|) 
                                                   (return 
                                                    (funcall (svref pp 38) 
                                                             "choose")) 
                                                   (if (eq 
                                                        (car termOp) 
                                                        :|Equals|) 
                                                       (return (svref pp 13)) 
                                                       (if (eq 
                                                            (car termOp) 
                                                            :|OneName|) 
                                                           (return 
                                                            (funcall (svref 
                                                                      pp 
                                                                      38) 
                                                                     (car 
                                                                      (cdr 
                                                                       termOp)))) 
                                                           (if (eq 
                                                                (car termOp) 
                                                                :|TwoNames|) 
                                                               (let ((pV990 
                                                                      (cdr 
                                                                       termOp))) 
                                                                 (return 
                                                                  (funcall (svref 
                                                                            pp 
                                                                            38) 
                                                                           (STRING-SPEC::^ 
                                                                            (STRING-SPEC::^ 
                                                                             (svref 
                                                                              pV990 
                                                                              0) 
                                                                             ".") 
                                                                            (svref 
                                                                             pV990 
                                                                             1))))) 
                                                               (if (eq 
                                                                    (car termOp) 
                                                                    :|Relax|) 
                                                                   (return 
                                                                    (let ((p 
                                                                           (block 
                                                                            nil 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  srt) 
                                                                                 :|Arrow|) 
                                                                                (let ((pV965 
                                                                                       (svref 
                                                                                        (cdr 
                                                                                         srt) 
                                                                                        0))) 
                                                                                  (if (eq 
                                                                                       (car 
                                                                                        pV965) 
                                                                                       :|Subsort|) 
                                                                                      (return 
                                                                                       (svref 
                                                                                        (cdr 
                                                                                         pV965) 
                                                                                        1))))) 
                                                                            (return 
                                                                             (METASLANG::mkTrueA 
                                                                              a))))) 
                                                                      (PRETTYPRINT::prettysFill 
                                                                       (cons 
                                                                        (funcall (svref 
                                                                                  pp 
                                                                                  38) 
                                                                                 "relax") 
                                                                        (cons 
                                                                         (PRETTYPRINT::|!string| 
                                                                          "(") 
                                                                         (cons 
                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                           context 
                                                                           (cons 
                                                                            nil 
                                                                            '(:|Top|)) 
                                                                           p) 
                                                                          (cons 
                                                                           (PRETTYPRINT::|!string| 
                                                                            ")") 
                                                                           nil))))))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         termOp) 
                                                                        :|Restrict|) 
                                                                       (return 
                                                                        (let ((p 
                                                                               (block 
                                                                                nil 
                                                                                (if (eq 
                                                                                     (car 
                                                                                      srt) 
                                                                                     :|Arrow|) 
                                                                                    (let ((pV980 
                                                                                           (svref 
                                                                                            (cdr 
                                                                                             srt) 
                                                                                            1))) 
                                                                                      (if (eq 
                                                                                           (car 
                                                                                            pV980) 
                                                                                           :|Subsort|) 
                                                                                          (return 
                                                                                           (svref 
                                                                                            (cdr 
                                                                                             pV980) 
                                                                                            1))))) 
                                                                                (return 
                                                                                 (METASLANG::mkTrueA 
                                                                                  a))))) 
                                                                          (PRETTYPRINT::prettysFill 
                                                                           (cons 
                                                                            (funcall (svref 
                                                                                      pp 
                                                                                      38) 
                                                                                     "restrict") 
                                                                            (cons 
                                                                             (PRETTYPRINT::|!string| 
                                                                              "(") 
                                                                             (cons 
                                                                              (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                               context 
                                                                               (cons 
                                                                                nil 
                                                                                '(:|Top|)) 
                                                                               p) 
                                                                              (cons 
                                                                               (PRETTYPRINT::|!string| 
                                                                                ")") 
                                                                               nil))))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             termOp) 
                                                                            :|PRelax|) 
                                                                           (return 
                                                                            (PRETTYPRINT::prettysFill 
                                                                             (cons 
                                                                              (funcall (svref 
                                                                                        pp 
                                                                                        38) 
                                                                                       "relax") 
                                                                              (cons 
                                                                               (PRETTYPRINT::|!string| 
                                                                                "(") 
                                                                               (cons 
                                                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                 context 
                                                                                 (cons 
                                                                                  nil 
                                                                                  '(:|Top|)) 
                                                                                 (cdr 
                                                                                  termOp)) 
                                                                                (cons 
                                                                                 (PRETTYPRINT::|!string| 
                                                                                  ")") 
                                                                                 nil)))))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 termOp) 
                                                                                :|PRestrict|) 
                                                                               (return 
                                                                                (PRETTYPRINT::prettysFill 
                                                                                 (cons 
                                                                                  (funcall (svref 
                                                                                            pp 
                                                                                            38) 
                                                                                           "restrict") 
                                                                                  (cons 
                                                                                   (PRETTYPRINT::|!string| 
                                                                                    "(") 
                                                                                   (cons 
                                                                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                     context 
                                                                                     (cons 
                                                                                      nil 
                                                                                      '(:|Top|)) 
                                                                                     (cdr 
                                                                                      termOp)) 
                                                                                    (cons 
                                                                                     (PRETTYPRINT::|!string| 
                                                                                      ")") 
                                                                                     nil)))))) 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     termOp) 
                                                                                    :|Select|) 
                                                                                   (return 
                                                                                    (funcall (svref 
                                                                                              pp 
                                                                                              38) 
                                                                                             (STRING-SPEC::^ 
                                                                                              (STRING-SPEC::^ 
                                                                                               "select(" 
                                                                                               (cdr 
                                                                                                termOp)) 
                                                                                              ")"))))))))))))))))))))))) 
   (error "Nonexhaustive match failure in printOp")))
                                                     
(defun ANNSPECPRINTER::printSort?-1 (c) (svref c 5))
                                                    
(defun ANNSPECPRINTER::termFixity (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV1029 (svref (cdr term) 0))) 
         (return 
          (block 
           nil 
           (if (eq (car pV1029) :|Op|) 
               (return (cdr (cdr pV1029))) 
               (if (eq (car pV1029) :|Equals|) (return (cons '(:|Left|) 20)))) 
           (return nil))))) 
   (return nil)))
                 
(defun PRETTYPRINT::addSeparator-1-1 (sep ps) 
  (block 
   nil 
   (if (null ps) 
       (return nil) 
       (if (consp ps) 
           (let ((pV4715 (car ps))
                 (pV4716 (cdr ps))) 
             (progn (if (null pV4716) (return (cons pV4715 nil))) 
                    (return 
                     (LIST-SPEC::|!cons| 
                      (PRETTYPRINT::prettysNone (cons pV4715 (cons sep nil))) 
                      (PRETTYPRINT::addSeparator-1-1 sep pV4716))))))) 
   (error "Nonexhaustive match failure in addSeparator")))
                                                          
(defun PRETTYPRINT::blockLinear (|!newlines| lines) 
  (let ((width (PRETTYPRINT::widthLines lines))) 
    (PRETTYPRINT::pretty 
     width 
     #'(lambda (x) 
        (let ((text (cdr x))
              (columns (car x))) 
          (if (PRETTYPRINT::fits? columns width text) 
              (PRETTYPRINT::formatPretty 
               columns 
               (PRETTYPRINT::blockNone |!newlines| lines) 
               text) 
              (PRETTYPRINT::formatPretty 
               columns 
               (PRETTYPRINT::blockAll |!newlines| lines) 
               text)))))))
                          
(defun PRETTYPRINT::blockLinear-1 (x) 
  (PRETTYPRINT::blockLinear (car x) (cdr x)))
                                             
(defun PRETTYPRINT::prettysLinear (ps) 
  (PRETTYPRINT::prettysBlock-1-1 #'PRETTYPRINT::blockLinear-1 ps))
                                                                  
(defun ANNTERMPRINTER::ppListPath-1-1-1-1 (path f x ps) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (svref x 0) 
    (cons 
     (PRETTYPRINT::prettysLinear 
      (PRETTYPRINT::addSeparator-1-1 
       (svref x 1) 
       (LISTUTILITIES::mapWithIndex-1-1 
        #'(lambda (x1) 
           (funcall f (cons (LIST-SPEC::|!cons| (car x1) path) (cdr x1)))) 
        ps))) 
     (cons (svref x 2) nil)))))
                               
(defun PRETTYPRINT::prettys (ps) (PRETTYPRINT::prettysNone ps))
                                                               
(defun ANNSPECPRINTER::ppTerm1-1-1-1 (context x term) 
  (let ((path (car x))
        (parentTerm (cdr x))) 
    (let ((pp (svref context 4))) 
      (labels 
        ((prApply (t1 t2) 
          (block 
           nil 
           (if (eq (car t1) :|Lambda|) 
               (let ((pV726 (car (cdr t1)))) 
                 (if (consp pV726) 
                     (return 
                      (PRETTYPRINT::blockAll 
                       0 
                       (cons 
                        (cons 
                         0 
                         (PRETTYPRINT::prettysNone 
                          (cons 
                           (svref pp 22) 
                           (cons 
                            (svref pp 4) 
                            (cons 
                             (ANNSPECPRINTER::ppTerm-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 nil) path) 
                               '(:|Top|)) 
                              t2) 
                             nil))))) 
                        (cons 
                         (cons 
                          3 
                          (PRETTYPRINT::prettysNone 
                           (cons 
                            (ANNSPECPRINTER::printLambda 
                             context 
                             (LIST-SPEC::|!++| (cons 0 nil) path) 
                             (svref pp 26) 
                             pV726) 
                            (cons (svref pp 31) nil)))) 
                         nil)))))) 
               (if (eq (car t1) :|Fun|) 
                   (let ((pV715 (cdr t1))) 
                     (let ((pV717 (svref pV715 0))) 
                       (if (eq (car pV717) :|Project|) 
                           (let ((pV720 (cdr pV717))) 
                             (if (eq (car t2) :|Var|) 
                                 (let ((pV722 (car (cdr t2)))) 
                                   (let ((pV724 (car pV722))) 
                                     (return 
                                      (if (ANNSPECPRINTER::printSort?-1 context) 
                                          (PRETTYPRINT::prettysNone 
                                           (cons 
                                            (funcall (svref pp 38) pV724) 
                                            (cons 
                                             (PRETTYPRINT::|!string| ":") 
                                             (cons 
                                              (ANNSPECPRINTER::ppSort-1-1-1 
                                               context 
                                               (cons 
                                                (LIST-SPEC::|!++| 
                                                 (cons 0 (cons 1 nil)) 
                                                 path) 
                                                '(:|Top|)) 
                                               (cdr pV722)) 
                                              (cons 
                                               (PRETTYPRINT::|!string| ".") 
                                               (cons 
                                                (PRETTYPRINT::|!string| pV720) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| ":") 
                                                 (cons 
                                                  (ANNSPECPRINTER::ppSort-1-1-1 
                                                   context 
                                                   (cons 
                                                    (LIST-SPEC::|!++| 
                                                     (cons 0 (cons 0 nil)) 
                                                     path) 
                                                    '(:|Top|)) 
                                                   (svref pV715 1)) 
                                                  nil)))))))) 
                                          (PRETTYPRINT::prettysNone 
                                           (cons 
                                            (funcall (svref pp 38) pV724) 
                                            (cons 
                                             (PRETTYPRINT::|!string| ".") 
                                             (cons 
                                              (funcall (svref pp 38) pV720) 
                                              nil))))))))))))))) 
           (return 
            (PRETTYPRINT::blockFill 
             0 
             (cons 
              (cons 
               0 
               (ANNSPECPRINTER::ppTerm-1-1-1 
                context 
                (cons (LIST-SPEC::|!++| (cons 0 nil) path) '(:|Top|)) 
                t1)) 
              (cons 
               (cons 
                1 
                (PRETTYPRINT::blockNone 
                 0 
                 (block 
                  nil 
                  (if (eq (car t2) :|Record|) 
                      (return 
                       (if (ANNSPECPRINTER::isShortTuple 1 (car (cdr t2))) 
                           (cons 
                            (cons 
                             0 
                             (ANNSPECPRINTER::ppTerm1-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 nil) path) 
                               '(:|Top|)) 
                              t2)) 
                            nil) 
                           (cons 
                            (cons 
                             0 
                             (ANNSPECPRINTER::ppTerm-1-1-1 
                              context 
                              (cons 
                               (LIST-SPEC::|!++| (cons 1 nil) path) 
                               '(:|Top|)) 
                              t2)) 
                            nil))) 
                      (if (eq (car t2) :|Var|) 
                          (return 
                           (cons 
                            (cons 0 (PRETTYPRINT::|!string| " ")) 
                            (cons 
                             (cons 
                              0 
                              (ANNSPECPRINTER::ppTerm-1-1-1 
                               context 
                               (cons 
                                (LIST-SPEC::|!++| (cons 1 nil) path) 
                                '(:|Top|)) 
                               t2)) 
                             nil))))) 
                  (return 
                   (cons 
                    (cons 0 (svref pp 22)) 
                    (cons 
                     (cons 
                      0 
                      (ANNSPECPRINTER::ppTerm-1-1-1 
                       context 
                       (cons (LIST-SPEC::|!++| (cons 1 nil) path) '(:|Top|)) 
                       t2)) 
                     (cons (cons 0 (svref pp 31)) nil))))))) 
               nil))))))) 
        (let ((pV930 (ANNSPECPRINTER::isFiniteList term))) 
          (block 
           nil 
           (if (eq (car pV930) :|Some|) 
               (return 
                (ANNTERMPRINTER::ppListPath-1-1-1-1 
                 path 
                 #'(lambda (x1) 
                    (ANNSPECPRINTER::ppTerm-1-1-1 
                     context 
                     (cons (car x1) '(:|Top|)) 
                     (cdr x1))) 
                 (vector (svref pp 20) (svref pp 5) (svref pp 29)) 
                 (cdr pV930))) 
               (if (eq (car pV930) :|None|) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car term) :|Fun|) 
                         (let ((pV862 (cdr term))) 
                           (let ((pV927 (svref pV862 0))
                                 (pV928 (svref pV862 1))
                                 (pV929 (svref pV862 2))) 
                             (return 
                              (if (ANNSPECPRINTER::printSort?-1 context) 
                                  (PRETTYPRINT::blockFill 
                                   0 
                                   (cons 
                                    (cons 
                                     0 
                                     (ANNSPECPRINTER::printOp 
                                      context 
                                      pp 
                                      pV927 
                                      pV928 
                                      pV929)) 
                                    (cons 
                                     (cons 0 (PRETTYPRINT::|!string| " : ")) 
                                     (cons 
                                      (cons 
                                       0 
                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                        context 
                                        (cons 
                                         (LIST-SPEC::|!++| (cons 0 nil) path) 
                                         '(:|Top|)) 
                                        pV928)) 
                                      nil)))) 
                                  (ANNSPECPRINTER::printOp 
                                   context 
                                   pp 
                                   pV927 
                                   pV928 
                                   pV929))))) 
                         (if (eq (car term) :|Var|) 
                             (let ((pV923 (car (cdr term)))) 
                               (let ((pV925 (car pV923))) 
                                 (return 
                                  (if (ANNSPECPRINTER::printSort?-1 context) 
                                      (PRETTYPRINT::blockFill 
                                       0 
                                       (cons 
                                        (cons 0 (funcall (svref pp 38) pV925)) 
                                        (cons 
                                         (cons 0 (PRETTYPRINT::|!string| " : ")) 
                                         (cons 
                                          (cons 
                                           0 
                                           (ANNSPECPRINTER::ppSort-1-1-1 
                                            context 
                                            (cons 
                                             (LIST-SPEC::|!++| (cons 0 nil) path) 
                                             '(:|Top|)) 
                                            (cdr pV923))) 
                                          nil)))) 
                                      (funcall (svref pp 38) pV925))))) 
                             (if (eq (car term) :|Let|) 
                                 (let ((pV860 (cdr term))) 
                                   (let ((pV920 (svref pV860 0))
                                         (pV921 (svref pV860 1))) 
                                     (return 
                                      (labels 
                                        ((ppD 
                                          (index 
                                           separatorLength 
                                           separator 
                                           pat 
                                           trm) 
                                          (block 
                                           nil 
                                           (if (eq (car pat) :|VarPat|) 
                                               (if (eq (car trm) :|Lambda|) 
                                                   (let ((pV742 (car (cdr trm)))) 
                                                     (if (consp pV742) 
                                                         (let ((pV745 
                                                                (car pV742))) 
                                                           (let ((pV748 
                                                                  (svref pV745 1))) 
                                                             (if (eq 
                                                                  (car pV748) 
                                                                  :|Fun|) 
                                                                 (let ((pV751 
                                                                        (svref 
                                                                         (cdr 
                                                                          pV748) 
                                                                         0))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV751) 
                                                                        :|Bool|) 
                                                                       (if (eq 
                                                                            t 
                                                                            (cdr 
                                                                             pV751)) 
                                                                           (if (null 
                                                                                (cdr 
                                                                                 pV742)) 
                                                                               (return 
                                                                                (cons 
                                                                                 0 
                                                                                 (PRETTYPRINT::blockLinear 
                                                                                  0 
                                                                                  (cons 
                                                                                   (cons 
                                                                                    0 
                                                                                    (PRETTYPRINT::prettysNone 
                                                                                     (cons 
                                                                                      separator 
                                                                                      (cons 
                                                                                       (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                        context 
                                                                                        (cons 
                                                                                         (LIST-SPEC::|!++| 
                                                                                          (cons 
                                                                                           0 
                                                                                           (cons 
                                                                                            index 
                                                                                            nil)) 
                                                                                          path) 
                                                                                         nil) 
                                                                                        pat) 
                                                                                       (cons 
                                                                                        (PRETTYPRINT::|!string| 
                                                                                         " ") 
                                                                                        (cons 
                                                                                         (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                          context 
                                                                                          (cons 
                                                                                           (LIST-SPEC::|!++| 
                                                                                            (cons 
                                                                                             0 
                                                                                             (cons 
                                                                                              1 
                                                                                              (cons 
                                                                                               index 
                                                                                               nil))) 
                                                                                            path) 
                                                                                           nil) 
                                                                                          (svref 
                                                                                           pV745 
                                                                                           0)) 
                                                                                         (cons 
                                                                                          (PRETTYPRINT::|!string| 
                                                                                           " ") 
                                                                                          (cons 
                                                                                           (svref 
                                                                                            pp 
                                                                                            13) 
                                                                                           (cons 
                                                                                            (PRETTYPRINT::|!string| 
                                                                                             " ") 
                                                                                            nil))))))))) 
                                                                                   (cons 
                                                                                    (cons 
                                                                                     separatorLength 
                                                                                     (PRETTYPRINT::prettysNone 
                                                                                      (cons 
                                                                                       (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                        context 
                                                                                        (cons 
                                                                                         (LIST-SPEC::|!++| 
                                                                                          (cons 
                                                                                           2 
                                                                                           (cons 
                                                                                            1 
                                                                                            (cons 
                                                                                             index 
                                                                                             nil))) 
                                                                                          path) 
                                                                                         '(:|Top|)) 
                                                                                        (svref 
                                                                                         pV745 
                                                                                         2)) 
                                                                                       (cons 
                                                                                        (PRETTYPRINT::|!string| 
                                                                                         " ") 
                                                                                        nil)))) 
                                                                                    nil)))))))))))))))) 
                                           (return 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::blockLinear 
                                              0 
                                              (cons 
                                               (cons 
                                                0 
                                                (PRETTYPRINT::prettysNone 
                                                 (cons 
                                                  separator 
                                                  (cons 
                                                   (ANNSPECPRINTER::ppPattern-1-1-1 
                                                    context 
                                                    (cons 
                                                     (LIST-SPEC::|!++| 
                                                      (cons 0 (cons index nil)) 
                                                      path) 
                                                     t) 
                                                    pat) 
                                                   (cons 
                                                    (PRETTYPRINT::|!string| " ") 
                                                    (cons 
                                                     (svref pp 13) 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       " ") 
                                                      nil))))))) 
                                               (cons 
                                                (cons 
                                                 separatorLength 
                                                 (PRETTYPRINT::prettysNone 
                                                  (cons 
                                                   (ANNSPECPRINTER::ppTerm-1-1-1 
                                                    context 
                                                    (cons 
                                                     (LIST-SPEC::|!++| 
                                                      (cons 1 (cons index nil)) 
                                                      path) 
                                                     '(:|Top|)) 
                                                    trm) 
                                                   (cons 
                                                    (PRETTYPRINT::|!string| " ") 
                                                    nil)))) 
                                                nil)))))))) 
                                        (labels 
                                          ((ppDs (index l separator decls) 
                                            (block 
                                             nil 
                                             (if (null decls) 
                                                 (return nil) 
                                                 (if (consp decls) 
                                                     (let ((pV757 (car decls))) 
                                                       (return 
                                                        (LIST-SPEC::|!cons| 
                                                         (ppD 
                                                          index 
                                                          l 
                                                          separator 
                                                          (car pV757) 
                                                          (cdr pV757)) 
                                                         (ppDs 
                                                          (INTEGER-SPEC::|!+| 
                                                           index 
                                                           1) 
                                                          5 
                                                          (svref pp 0) 
                                                          (cdr decls))))))) 
                                             (error 
                                              "Nonexhaustive match failure in ppTerm1")))) 
                                          (PRETTYPRINT::blockAll 
                                           0 
                                           (cons 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::blockFill 
                                              0 
                                              (cons 
                                               (cons 
                                                0 
                                                (PRETTYPRINT::blockLinear 
                                                 0 
                                                 (ppDs 0 4 (svref pp 24) pV920))) 
                                               (cons (cons 0 (svref pp 18)) nil)))) 
                                            (cons 
                                             (cons 
                                              0 
                                              (ANNSPECPRINTER::ppTerm-1-1-1 
                                               context 
                                               (cons 
                                                (LIST-SPEC::|!++| 
                                                 (cons 
                                                  (LIST-SPEC::|!length| pV920) 
                                                  nil) 
                                                 path) 
                                                parentTerm) 
                                               pV921)) 
                                             nil)))))))) 
                                 (if (eq (car term) :|LetRec|) 
                                     (let ((pV859 (cdr term))) 
                                       (let ((pV917 (svref pV859 0))
                                             (pV918 (svref pV859 1))) 
                                         (return 
                                          (labels 
                                            ((ppD (pV782 pV783) 
                                              (block 
                                               nil 
                                               (let ((pV785 (cdr pV783))) 
                                                 (let ((pV786 (car (car pV783)))) 
                                                   (return 
                                                    (block 
                                                     nil 
                                                     (if (eq 
                                                          (car pV785) 
                                                          :|Lambda|) 
                                                         (let ((pV769 
                                                                (car (cdr pV785)))) 
                                                           (if (consp pV769) 
                                                               (let ((pV772 
                                                                      (car pV769))) 
                                                                 (let ((pV775 
                                                                        (svref 
                                                                         pV772 
                                                                         1))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV775) 
                                                                        :|Fun|) 
                                                                       (let ((pV778 
                                                                              (svref 
                                                                               (cdr 
                                                                                pV775) 
                                                                               0))) 
                                                                         (if (eq 
                                                                              (car 
                                                                               pV778) 
                                                                              :|Bool|) 
                                                                             (if (eq 
                                                                                  t 
                                                                                  (cdr 
                                                                                   pV778)) 
                                                                                 (if (null 
                                                                                      (cdr 
                                                                                       pV769)) 
                                                                                     (return 
                                                                                      (PRETTYPRINT::blockLinear 
                                                                                       0 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         0 
                                                                                         (PRETTYPRINT::prettysNone 
                                                                                          (cons 
                                                                                           (svref 
                                                                                            pp 
                                                                                            7) 
                                                                                           (cons 
                                                                                            (funcall (svref 
                                                                                                      pp 
                                                                                                      38) 
                                                                                                     pV786) 
                                                                                            (cons 
                                                                                             (PRETTYPRINT::|!string| 
                                                                                              " ") 
                                                                                             (cons 
                                                                                              (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                               context 
                                                                                               (cons 
                                                                                                (LIST-SPEC::|!++| 
                                                                                                 (cons 
                                                                                                  1 
                                                                                                  (cons 
                                                                                                   0 
                                                                                                   nil)) 
                                                                                                 pV782) 
                                                                                                nil) 
                                                                                               (svref 
                                                                                                pV772 
                                                                                                0)) 
                                                                                              (cons 
                                                                                               (svref 
                                                                                                pp 
                                                                                                13) 
                                                                                               nil))))))) 
                                                                                        (cons 
                                                                                         (cons 
                                                                                          4 
                                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                           context 
                                                                                           (cons 
                                                                                            (LIST-SPEC::|!++| 
                                                                                             (cons 
                                                                                              2 
                                                                                              (cons 
                                                                                               0 
                                                                                               nil)) 
                                                                                             pV782) 
                                                                                            '(:|Top|)) 
                                                                                           (svref 
                                                                                            pV772 
                                                                                            2))) 
                                                                                         nil)))))))))))))) 
                                                     (return 
                                                      (PRETTYPRINT::blockLinear 
                                                       0 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (PRETTYPRINT::prettysNone 
                                                          (cons 
                                                           (svref pp 7) 
                                                           (cons 
                                                            (funcall (svref 
                                                                      pp 
                                                                      38) 
                                                                     pV786) 
                                                            (cons 
                                                             (svref pp 13) 
                                                             nil))))) 
                                                        (cons 
                                                         (cons 
                                                          4 
                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                           context 
                                                           (cons pV782 '(:|Top|)) 
                                                           pV785)) 
                                                         nil)))))))) 
                                               (error 
                                                "Nonexhaustive match failure in ppTerm1")))) 
                                            (PRETTYPRINT::blockAll 
                                             0 
                                             (cons 
                                              (cons 
                                               0 
                                               (PRETTYPRINT::blockNone 
                                                0 
                                                (cons 
                                                 (cons 0 (svref pp 24)) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                    path 
                                                    #'(lambda (x1) 
                                                       (ppD (car x1) (cdr x1))) 
                                                    (vector 
                                                     (svref pp 10) 
                                                     (svref pp 10) 
                                                     (svref pp 18)) 
                                                    pV917)) 
                                                  nil)))) 
                                              (cons 
                                               (cons 
                                                0 
                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                 context 
                                                 (cons 
                                                  (LIST-SPEC::|!++| 
                                                   (cons 
                                                    (LIST-SPEC::|!length| pV917) 
                                                    nil) 
                                                   path) 
                                                  parentTerm) 
                                                 pV918)) 
                                               nil))))))) 
                                     (if (eq (car term) :|Record|) 
                                         (let ((pV915 (car (cdr term)))) 
                                           (return 
                                            (if (ANNSPECPRINTER::isShortTuple 
                                                 1 
                                                 pV915) 
                                                (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                 path 
                                                 #'(lambda (x1) 
                                                    (block 
                                                     nil 
                                                     (return 
                                                      (ANNSPECPRINTER::ppTerm-1-1-1 
                                                       context 
                                                       (cons (car x1) '(:|Top|)) 
                                                       (cdr (cdr x1)))) 
                                                     (error 
                                                      "Nonexhaustive match failure in ppTerm1"))) 
                                                 (vector 
                                                  (svref pp 22) 
                                                  (svref pp 5) 
                                                  (svref pp 31)) 
                                                 pV915) 
                                                (labels 
                                                  ((ppEntry (pV794 pV795) 
                                                    (block 
                                                     nil 
                                                     (return 
                                                      (PRETTYPRINT::blockLinear 
                                                       0 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (funcall (svref pp 38) 
                                                                  (car pV795))) 
                                                        (cons 
                                                         (cons 
                                                          0 
                                                          (PRETTYPRINT::|!string| 
                                                           " = ")) 
                                                         (cons 
                                                          (cons 
                                                           0 
                                                           (ANNSPECPRINTER::ppTerm-1-1-1 
                                                            context 
                                                            (cons 
                                                             pV794 
                                                             '(:|Top|)) 
                                                            (cdr pV795))) 
                                                          nil))))) 
                                                     (error 
                                                      "Nonexhaustive match failure in ppTerm1")))) 
                                                  (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                   path 
                                                   #'(lambda (x1) 
                                                      (ppEntry (car x1) (cdr x1))) 
                                                   (vector 
                                                    (svref pp 21) 
                                                    (PRETTYPRINT::|!string| ", ") 
                                                    (svref pp 30)) 
                                                   pV915))))) 
                                         (if (eq (car term) :|IfThenElse|) 
                                             (let ((pV857 (cdr term))) 
                                               (return 
                                                (PRETTYPRINT::blockLinear 
                                                 0 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (PRETTYPRINT::prettys 
                                                    (cons 
                                                     (svref pp 16) 
                                                     (cons 
                                                      (ANNSPECPRINTER::ppTerm-1-1-1 
                                                       context 
                                                       (cons 
                                                        (LIST-SPEC::|!++| 
                                                         (cons 0 nil) 
                                                         path) 
                                                        '(:|Top|)) 
                                                       (svref pV857 0)) 
                                                      nil)))) 
                                                  (cons 
                                                   (cons 
                                                    3 
                                                    (PRETTYPRINT::blockLinear 
                                                     0 
                                                     (cons 
                                                      (cons 0 (svref pp 34)) 
                                                      (cons 
                                                       (cons 
                                                        0 
                                                        (ANNSPECPRINTER::ppTerm-1-1-1 
                                                         context 
                                                         (cons 
                                                          (LIST-SPEC::|!++| 
                                                           (cons 1 nil) 
                                                           path) 
                                                          '(:|Top|)) 
                                                         (svref pV857 1))) 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (PRETTYPRINT::|!string| 
                                                          " ")) 
                                                        nil))))) 
                                                   (cons 
                                                    (cons 
                                                     0 
                                                     (PRETTYPRINT::blockFill 
                                                      0 
                                                      (cons 
                                                       (cons 0 (svref pp 9)) 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (ANNSPECPRINTER::ppTerm-1-1-1 
                                                          context 
                                                          (cons 
                                                           (LIST-SPEC::|!++| 
                                                            (cons 2 nil) 
                                                            path) 
                                                           '(:|Top|)) 
                                                          (svref pV857 2))) 
                                                        nil)))) 
                                                    nil)))))) 
                                             (if (eq (car term) :|Lambda|) 
                                                 (return 
                                                  (PRETTYPRINT::prettysNone 
                                                   (cons 
                                                    (svref pp 22) 
                                                    (cons 
                                                     (ANNSPECPRINTER::printLambda 
                                                      context 
                                                      path 
                                                      (svref pp 23) 
                                                      (car (cdr term))) 
                                                     (cons (svref pp 31) nil))))) 
                                                 (if (eq (car term) :|Bind|) 
                                                     (let ((pV855 (cdr term))) 
                                                       (let ((pV905 
                                                              (svref pV855 0))
                                                             (pV906 
                                                              (svref pV855 1))
                                                             (pV907 
                                                              (svref pV855 2))) 
                                                         (return 
                                                          (let ((b 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV905) 
                                                                       :|Forall|) 
                                                                      (return 
                                                                       (svref 
                                                                        pp 
                                                                        15)) 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV905) 
                                                                           :|Exists|) 
                                                                          (return 
                                                                           (svref 
                                                                            pp 
                                                                            14)))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in ppTerm1")))) 
                                                            (labels 
                                                              ((ppBound 
                                                                (pV802 pV803) 
                                                                (block 
                                                                 nil 
                                                                 (return 
                                                                  (PRETTYPRINT::prettys 
                                                                   (cons 
                                                                    (funcall (svref 
                                                                              pp 
                                                                              38) 
                                                                             (car 
                                                                              pV803)) 
                                                                    (cons 
                                                                     (PRETTYPRINT::|!string| 
                                                                      " : ") 
                                                                     (cons 
                                                                      (ANNSPECPRINTER::ppSort-1-1-1 
                                                                       context 
                                                                       (cons 
                                                                        (LIST-SPEC::|!++| 
                                                                         (cons 
                                                                          pV802 
                                                                          nil) 
                                                                         path) 
                                                                        '(:|Top|)) 
                                                                       (cdr 
                                                                        pV803)) 
                                                                      nil))))) 
                                                                 (error 
                                                                  "Nonexhaustive match failure in ppTerm1")))) 
                                                              (PRETTYPRINT::blockFill 
                                                               0 
                                                               (cons 
                                                                (cons 
                                                                 0 
                                                                 (PRETTYPRINT::prettysNone 
                                                                  (cons 
                                                                   b 
                                                                   (cons 
                                                                    (svref pp 22) 
                                                                    (cons 
                                                                     (PRETTYPRINT::prettysFill 
                                                                      (PRETTYPRINT::addSeparator-1-1 
                                                                       (PRETTYPRINT::|!string| 
                                                                        ", ") 
                                                                       (LISTUTILITIES::mapWithIndex-1-1 
                                                                        #'(lambda (x1) 
                                                                           (ppBound 
                                                                            (car 
                                                                             x1) 
                                                                            (cdr 
                                                                             x1))) 
                                                                        pV906))) 
                                                                     (cons 
                                                                      (svref 
                                                                       pp 
                                                                       31) 
                                                                      (cons 
                                                                       (PRETTYPRINT::|!string| 
                                                                        " ") 
                                                                       nil))))))) 
                                                                (cons 
                                                                 (cons 
                                                                  1 
                                                                  (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                   context 
                                                                   (cons 
                                                                    (LIST-SPEC::|!++| 
                                                                     (cons 
                                                                      (LIST-SPEC::|!length| 
                                                                       pV906) 
                                                                      nil) 
                                                                     path) 
                                                                    parentTerm) 
                                                                   pV907)) 
                                                                 nil)))))))) 
                                                     (if (eq (car term) :|Seq|) 
                                                         (return 
                                                          (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                           path 
                                                           #'(lambda (x1) 
                                                              (ANNSPECPRINTER::ppTerm-1-1-1 
                                                               context 
                                                               (cons 
                                                                (car x1) 
                                                                '(:|Top|)) 
                                                               (cdr x1))) 
                                                           (vector 
                                                            (svref pp 22) 
                                                            (PRETTYPRINT::|!string| 
                                                             ";") 
                                                            (svref pp 31)) 
                                                           (car (cdr term)))) 
                                                         (if (eq 
                                                              (car term) 
                                                              :|Apply|) 
                                                             (let ((pV853 
                                                                    (cdr term))) 
                                                               (let ((pV887 
                                                                      (svref 
                                                                       pV853 
                                                                       0))
                                                                     (pV888 
                                                                      (svref 
                                                                       pV853 
                                                                       1))) 
                                                                 (progn (if (eq 
                                                                             (car 
                                                                              pV888) 
                                                                             :|Record|) 
                                                                            (let ((pV891 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV888)))) 
                                                                              (if (consp 
                                                                                   pV891) 
                                                                                  (let ((pV895 
                                                                                         (cdr 
                                                                                          pV891))) 
                                                                                    (let ((pV897 
                                                                                           (cdr 
                                                                                            (car 
                                                                                             pV891)))) 
                                                                                      (if (consp 
                                                                                           pV895) 
                                                                                          (let ((pV902 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV895)))) 
                                                                                            (if (null 
                                                                                                 (cdr 
                                                                                                  pV895)) 
                                                                                                (return 
                                                                                                 (labels 
                                                                                                   ((prInfix 
                                                                                                     (f1 
                                                                                                      f2 
                                                                                                      l 
                                                                                                      t1 
                                                                                                      oper 
                                                                                                      t2 
                                                                                                      r) 
                                                                                                     (PRETTYPRINT::prettysFill 
                                                                                                      (cons 
                                                                                                       l 
                                                                                                       (cons 
                                                                                                        (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                         context 
                                                                                                         (cons 
                                                                                                          (LIST-SPEC::|!++| 
                                                                                                           (cons 
                                                                                                            0 
                                                                                                            (cons 
                                                                                                             1 
                                                                                                             nil)) 
                                                                                                           path) 
                                                                                                          f1) 
                                                                                                         t1) 
                                                                                                        (cons 
                                                                                                         (PRETTYPRINT::|!string| 
                                                                                                          " ") 
                                                                                                         (cons 
                                                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                           context 
                                                                                                           (cons 
                                                                                                            (LIST-SPEC::|!++| 
                                                                                                             (cons 
                                                                                                              0 
                                                                                                              nil) 
                                                                                                             path) 
                                                                                                            '(:|Top|)) 
                                                                                                           oper) 
                                                                                                          (cons 
                                                                                                           (PRETTYPRINT::|!string| 
                                                                                                            " ") 
                                                                                                           (cons 
                                                                                                            (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                             context 
                                                                                                             (cons 
                                                                                                              (LIST-SPEC::|!++| 
                                                                                                               (cons 
                                                                                                                1 
                                                                                                                (cons 
                                                                                                                 1 
                                                                                                                 nil)) 
                                                                                                               path) 
                                                                                                              f2) 
                                                                                                             t2) 
                                                                                                            (cons 
                                                                                                             r 
                                                                                                             nil)))))))))) 
                                                                                                   (let ((pV813 
                                                                                                          (ANNSPECPRINTER::termFixity 
                                                                                                           pV887))) 
                                                                                                     (block 
                                                                                                      nil 
                                                                                                      (if (null 
                                                                                                           pV813) 
                                                                                                          (return 
                                                                                                           (prApply 
                                                                                                            pV887 
                                                                                                            pV888))) 
                                                                                                      (if (eq 
                                                                                                           (car 
                                                                                                            parentTerm) 
                                                                                                           :|Nonfix|) 
                                                                                                          (if (consp 
                                                                                                               pV813) 
                                                                                                              (return 
                                                                                                               (prInfix 
                                                                                                                '(:|Nonfix|) 
                                                                                                                '(:|Nonfix|) 
                                                                                                                (svref 
                                                                                                                 pp 
                                                                                                                 22) 
                                                                                                                pV897 
                                                                                                                pV887 
                                                                                                                pV902 
                                                                                                                (svref 
                                                                                                                 pp 
                                                                                                                 31)))) 
                                                                                                          (if (eq 
                                                                                                               (car 
                                                                                                                parentTerm) 
                                                                                                               :|Top|) 
                                                                                                              (if (consp 
                                                                                                                   pV813) 
                                                                                                                  (return 
                                                                                                                   (prInfix 
                                                                                                                    '(:|Nonfix|) 
                                                                                                                    '(:|Nonfix|) 
                                                                                                                    (svref 
                                                                                                                     pp 
                                                                                                                     10) 
                                                                                                                    pV897 
                                                                                                                    pV887 
                                                                                                                    pV902 
                                                                                                                    (svref 
                                                                                                                     pp 
                                                                                                                     10)))) 
                                                                                                              (if (eq 
                                                                                                                   (car 
                                                                                                                    parentTerm) 
                                                                                                                   :|Infix|) 
                                                                                                                  (if (consp 
                                                                                                                       pV813) 
                                                                                                                      (return 
                                                                                                                       (prInfix 
                                                                                                                        '(:|Nonfix|) 
                                                                                                                        '(:|Nonfix|) 
                                                                                                                        (svref 
                                                                                                                         pp 
                                                                                                                         22) 
                                                                                                                        pV897 
                                                                                                                        pV887 
                                                                                                                        pV902 
                                                                                                                        (svref 
                                                                                                                         pp 
                                                                                                                         31))))))) 
                                                                                                      (error 
                                                                                                       "Nonexhaustive match failure in ppTerm1"))))))))))))) 
                                                                        (return 
                                                                         (prApply 
                                                                          pV887 
                                                                          pV888))))) 
                                                             (if (eq 
                                                                  (car term) 
                                                                  :|ApplyN|) 
                                                                 (let ((pV852 
                                                                        (cdr 
                                                                         term))) 
                                                                   (let ((pV866 
                                                                          (car 
                                                                           pV852))
                                                                         (pV867 
                                                                          (cdr 
                                                                           pV852))) 
                                                                     (if (consp 
                                                                          pV866) 
                                                                         (let ((pV869 
                                                                                (car 
                                                                                 pV866))
                                                                               (pV870 
                                                                                (cdr 
                                                                                 pV866))) 
                                                                           (if (null 
                                                                                pV870) 
                                                                               (return 
                                                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                 context 
                                                                                 (cons 
                                                                                  path 
                                                                                  parentTerm) 
                                                                                 pV869)) 
                                                                               (if (consp 
                                                                                    pV870) 
                                                                                   (let ((pV872 
                                                                                          (car 
                                                                                           pV870))
                                                                                         (pV873 
                                                                                          (cdr 
                                                                                           pV870))) 
                                                                                     (progn (if (eq 
                                                                                                 (car 
                                                                                                  pV872) 
                                                                                                 :|Record|) 
                                                                                                (let ((pV875 
                                                                                                       (car 
                                                                                                        (cdr 
                                                                                                         pV872)))) 
                                                                                                  (if (consp 
                                                                                                       pV875) 
                                                                                                      (let ((pV879 
                                                                                                             (cdr 
                                                                                                              pV875))) 
                                                                                                        (let ((pV881 
                                                                                                               (cdr 
                                                                                                                (car 
                                                                                                                 pV875)))) 
                                                                                                          (if (consp 
                                                                                                               pV879) 
                                                                                                              (let ((pV886 
                                                                                                                     (cdr 
                                                                                                                      (car 
                                                                                                                       pV879)))) 
                                                                                                                (if (null 
                                                                                                                     (cdr 
                                                                                                                      pV879)) 
                                                                                                                    (if (null 
                                                                                                                         pV873) 
                                                                                                                        (return 
                                                                                                                         (labels 
                                                                                                                           ((prInfix 
                                                                                                                             (f1 
                                                                                                                              f2 
                                                                                                                              l 
                                                                                                                              t1 
                                                                                                                              oper 
                                                                                                                              t2 
                                                                                                                              r) 
                                                                                                                             (PRETTYPRINT::prettysFill 
                                                                                                                              (cons 
                                                                                                                               l 
                                                                                                                               (cons 
                                                                                                                                (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                                                 context 
                                                                                                                                 (cons 
                                                                                                                                  (LIST-SPEC::|!++| 
                                                                                                                                   (cons 
                                                                                                                                    0 
                                                                                                                                    (cons 
                                                                                                                                     1 
                                                                                                                                     nil)) 
                                                                                                                                   path) 
                                                                                                                                  f1) 
                                                                                                                                 t1) 
                                                                                                                                (cons 
                                                                                                                                 (PRETTYPRINT::|!string| 
                                                                                                                                  " ") 
                                                                                                                                 (cons 
                                                                                                                                  (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                                                   context 
                                                                                                                                   (cons 
                                                                                                                                    (LIST-SPEC::|!++| 
                                                                                                                                     (cons 
                                                                                                                                      0 
                                                                                                                                      nil) 
                                                                                                                                     path) 
                                                                                                                                    '(:|Top|)) 
                                                                                                                                   oper) 
                                                                                                                                  (cons 
                                                                                                                                   (PRETTYPRINT::|!string| 
                                                                                                                                    " ") 
                                                                                                                                   (cons 
                                                                                                                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                                                                                     context 
                                                                                                                                     (cons 
                                                                                                                                      (LIST-SPEC::|!++| 
                                                                                                                                       (cons 
                                                                                                                                        1 
                                                                                                                                        (cons 
                                                                                                                                         1 
                                                                                                                                         nil)) 
                                                                                                                                       path) 
                                                                                                                                      f2) 
                                                                                                                                     t2) 
                                                                                                                                    (cons 
                                                                                                                                     r 
                                                                                                                                     nil)))))))))) 
                                                                                                                           (let ((pV834 
                                                                                                                                  (ANNSPECPRINTER::termFixity 
                                                                                                                                   pV869))) 
                                                                                                                             (block 
                                                                                                                              nil 
                                                                                                                              (if (null 
                                                                                                                                   pV834) 
                                                                                                                                  (return 
                                                                                                                                   (prApply 
                                                                                                                                    pV869 
                                                                                                                                    pV872))) 
                                                                                                                              (if (eq 
                                                                                                                                   (car 
                                                                                                                                    parentTerm) 
                                                                                                                                   :|Nonfix|) 
                                                                                                                                  (if (consp 
                                                                                                                                       pV834) 
                                                                                                                                      (return 
                                                                                                                                       (prInfix 
                                                                                                                                        '(:|Nonfix|) 
                                                                                                                                        '(:|Nonfix|) 
                                                                                                                                        (svref 
                                                                                                                                         pp 
                                                                                                                                         22) 
                                                                                                                                        pV881 
                                                                                                                                        pV869 
                                                                                                                                        pV886 
                                                                                                                                        (svref 
                                                                                                                                         pp 
                                                                                                                                         31)))) 
                                                                                                                                  (if (eq 
                                                                                                                                       (car 
                                                                                                                                        parentTerm) 
                                                                                                                                       :|Top|) 
                                                                                                                                      (if (consp 
                                                                                                                                           pV834) 
                                                                                                                                          (return 
                                                                                                                                           (prInfix 
                                                                                                                                            '(:|Nonfix|) 
                                                                                                                                            '(:|Nonfix|) 
                                                                                                                                            (svref 
                                                                                                                                             pp 
                                                                                                                                             10) 
                                                                                                                                            pV881 
                                                                                                                                            pV869 
                                                                                                                                            pV886 
                                                                                                                                            (svref 
                                                                                                                                             pp 
                                                                                                                                             10)))) 
                                                                                                                                      (if (eq 
                                                                                                                                           (car 
                                                                                                                                            parentTerm) 
                                                                                                                                           :|Infix|) 
                                                                                                                                          (if (consp 
                                                                                                                                               pV834) 
                                                                                                                                              (return 
                                                                                                                                               (prInfix 
                                                                                                                                                '(:|Nonfix|) 
                                                                                                                                                '(:|Nonfix|) 
                                                                                                                                                (svref 
                                                                                                                                                 pp 
                                                                                                                                                 22) 
                                                                                                                                                pV881 
                                                                                                                                                pV869 
                                                                                                                                                pV886 
                                                                                                                                                (svref 
                                                                                                                                                 pp 
                                                                                                                                                 31))))))) 
                                                                                                                              (error 
                                                                                                                               "Nonexhaustive match failure in ppTerm1")))))))))))))) 
                                                                                            (if (null 
                                                                                                 pV873) 
                                                                                                (return 
                                                                                                 (prApply 
                                                                                                  pV869 
                                                                                                  pV872))) 
                                                                                            (return 
                                                                                             (prApply 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 pV869 
                                                                                                 (cons 
                                                                                                  pV872 
                                                                                                  nil)) 
                                                                                                pV867)) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                pV873 
                                                                                                pV867)))))))))))) 
                                                                 (if (eq 
                                                                      (car term) 
                                                                      :|SortedTerm|) 
                                                                     (let ((pV851 
                                                                            (cdr 
                                                                             term))) 
                                                                       (return 
                                                                        (PRETTYPRINT::prettysNone 
                                                                         (cons 
                                                                          (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                           context 
                                                                           (cons 
                                                                            (LIST-SPEC::|!++| 
                                                                             (cons 
                                                                              0 
                                                                              nil) 
                                                                             path) 
                                                                            '(:|Top|)) 
                                                                           (svref 
                                                                            pV851 
                                                                            0)) 
                                                                          (cons 
                                                                           (PRETTYPRINT::|!string| 
                                                                            ":") 
                                                                           (cons 
                                                                            (PRETTYPRINT::|!string| 
                                                                             " ") 
                                                                            (cons 
                                                                             (ANNSPECPRINTER::ppSort-1-1-1 
                                                                              context 
                                                                              (cons 
                                                                               (LIST-SPEC::|!++| 
                                                                                (cons 
                                                                                 1 
                                                                                 nil) 
                                                                                path) 
                                                                               '(:|Top|)) 
                                                                              (svref 
                                                                               pV851 
                                                                               1)) 
                                                                             nil))))))))))))))))))) 
                     (return (SYSTEM-SPEC::fail "Uncovered case for term")))))) 
           (error "Nonexhaustive match failure in ppTerm1")))))))
                                                                 
(defun NATMAP::insert (x1 x0 x) (SPLAYMAP::insert x1 x0 x))
                                                           
(defun PRETTYPRINT::markPretty (uniqueId p) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::lengthString 0 "%(") 
    (cons 
     (PRETTYPRINT::lengthString 0 (NAT-SPEC::toString uniqueId)) 
     (cons p (cons (PRETTYPRINT::lengthString 0 "%)") nil))))))
                                                               
(defun ANNSPECPRINTER::ppTerm-1-1-1 (context x term) 
  (let ((path (car x))) 
    (let ((pretty 
           (ANNSPECPRINTER::ppTerm1-1-1-1 context (cons path (cdr x)) term))) 
      (if (ANNSPECPRINTER::markSubterm?-1 context) 
          (let ((num (STATE::|!!| (svref context 1)))) 
            (let ((table (STATE::|!!| (svref context 3)))) 
              (progn (STATE::|:=| 
                      (svref context 3) 
                      (NATMAP::insert table num path)) 
                     (STATE::|:=| (svref context 1) (INTEGER-SPEC::|!+| num 1)) 
                     (PRETTYPRINT::markPretty num pretty)))) 
          pretty))))
                    
(defun ANNSPECPRINTER::singletonPattern (pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (return nil) 
       (if (eq (car pat) :|RelaxPat|) 
           (return nil) 
           (if (eq (car pat) :|QuotientPat|) (return nil)))) 
   (return t)))
               
(defun ANNSPECPRINTER::|!enclose| (enclosed pretty) 
  (if enclosed 
      pretty 
      (PRETTYPRINT::prettysFill 
       (cons 
        (PRETTYPRINT::|!string| "(") 
        (cons pretty (cons (PRETTYPRINT::|!string| ")") nil))))))
                                                                 
(defun METASLANG::patternSort (pat) 
  (block 
   nil 
   (if (eq (car pat) :|WildPat|) 
       (return (car (cdr pat))) 
       (if (eq (car pat) :|AliasPat|) 
           (return (METASLANG::patternSort (svref (cdr pat) 0))) 
           (if (eq (car pat) :|VarPat|) 
               (return (cdr (car (cdr pat)))) 
               (if (eq (car pat) :|EmbedPat|) 
                   (return (svref (cdr pat) 2)) 
                   (if (eq (car pat) :|RecordPat|) 
                       (let ((pV3271 (cdr pat))) 
                         (return 
                          (cons 
                           :|Product| 
                           (cons 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons (car x) (METASLANG::patternSort (cdr x)))) 
                             (car pV3271)) 
                            (cdr pV3271))))) 
                       (if (eq (car pat) :|StringPat|) 
                           (return 
                            (METASLANG::mkABase 
                             (cons :|Qualified| (cons "String" "String")) 
                             nil 
                             (cdr (cdr pat)))) 
                           (if (eq (car pat) :|NatPat|) 
                               (return 
                                (METASLANG::mkABase 
                                 (cons :|Qualified| (cons "Nat" "Nat")) 
                                 nil 
                                 (cdr (cdr pat)))) 
                               (if (eq (car pat) :|BoolPat|) 
                                   (return 
                                    (METASLANG::mkABase 
                                     (cons 
                                      :|Qualified| 
                                      (cons "Boolean" "Boolean")) 
                                     nil 
                                     (cdr (cdr pat)))) 
                                   (if (eq (car pat) :|CharPat|) 
                                       (return 
                                        (METASLANG::mkABase 
                                         (cons :|Qualified| (cons "Char" "Char")) 
                                         nil 
                                         (cdr (cdr pat)))) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (let ((pV3266 (cdr pat))) 
                                             (return 
                                              (cons 
                                               :|Subsort| 
                                               (vector 
                                                (METASLANG::patternSort 
                                                 (svref pV3266 0)) 
                                                (svref pV3266 1) 
                                                (svref pV3266 2))))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (let ((pV3265 (cdr pat))) 
                                                 (return 
                                                  (cons 
                                                   :|Quotient| 
                                                   (vector 
                                                    (METASLANG::patternSort 
                                                     (svref pV3265 0)) 
                                                    (svref pV3265 1) 
                                                    (svref pV3265 2))))) 
                                               (if (eq (car pat) :|SortedPat|) 
                                                   (return (svref (cdr pat) 1)))))))))))))) 
   (error "Nonexhaustive match failure in patternSort")))
                                                         
(defun ANNSPECPRINTER::ppPattern-1-1-1 (context x pattern) 
  (let ((path (car x))
        (enclosed (cdr x))) 
    (let ((pp (svref context 4))) 
      (block 
       nil 
       (if (eq (car pattern) :|WildPat|) 
           (return (svref pp 36)) 
           (if (eq (car pattern) :|BoolPat|) 
               (return 
                (PRETTYPRINT::|!string| 
                 (BOOLEAN-SPEC::toString (car (cdr pattern))))) 
               (if (eq (car pattern) :|NatPat|) 
                   (return 
                    (PRETTYPRINT::|!string| 
                     (NAT-SPEC::toString (car (cdr pattern))))) 
                   (if (eq (car pattern) :|StringPat|) 
                       (return 
                        (funcall (svref pp 38) 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ "\"" (car (cdr pattern))) 
                                  "\""))) 
                       (if (eq (car pattern) :|CharPat|) 
                           (return 
                            (funcall (svref pp 38) 
                                     (STRING-SPEC::^ 
                                      "#" 
                                      (CHAR-SPEC::toString (car (cdr pattern)))))) 
                           (if (eq (car pattern) :|VarPat|) 
                               (let ((pV476 (car (cdr pattern)))) 
                                 (let ((pV478 (car pV476))) 
                                   (return 
                                    (if (ANNSPECPRINTER::printSort?-1 context) 
                                        (PRETTYPRINT::blockFill 
                                         0 
                                         (cons 
                                          (cons 0 (funcall (svref pp 38) pV478)) 
                                          (cons 
                                           (cons 
                                            0 
                                            (PRETTYPRINT::|!string| " : ")) 
                                           (cons 
                                            (cons 
                                             0 
                                             (ANNSPECPRINTER::ppSort-1-1-1 
                                              context 
                                              (cons 
                                               (LIST-SPEC::|!++| 
                                                (cons 0 nil) 
                                                path) 
                                               '(:|Top|)) 
                                              (cdr pV476))) 
                                            nil)))) 
                                        (funcall (svref pp 38) pV478))))) 
                               (if (eq (car pattern) :|RecordPat|) 
                                   (let ((pV474 (car (cdr pattern)))) 
                                     (return 
                                      (if (ANNSPECPRINTER::isShortTuple 1 pV474) 
                                          (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                           path 
                                           #'(lambda (x1) 
                                              (block 
                                               nil 
                                               (return 
                                                (ANNSPECPRINTER::ppPattern-1-1-1 
                                                 context 
                                                 (cons (car x1) t) 
                                                 (cdr (cdr x1)))) 
                                               (error 
                                                "Nonexhaustive match failure in ppPattern"))) 
                                           (vector 
                                            (svref pp 22) 
                                            (svref pp 5) 
                                            (svref pp 31)) 
                                           pV474) 
                                          (labels 
                                            ((ppEntry (pV393 pV394) 
                                              (block 
                                               nil 
                                               (let ((pV395 (car pV394))) 
                                                 (return 
                                                  (PRETTYPRINT::blockFill 
                                                   0 
                                                   (cons 
                                                    (cons 
                                                     0 
                                                     (PRETTYPRINT::prettysNone 
                                                      (cons 
                                                       (funcall (svref pp 38) 
                                                                pV395) 
                                                       (cons (svref pp 13) nil)))) 
                                                    (cons 
                                                     (cons 
                                                      (INTEGER-SPEC::|!+| 
                                                       2 
                                                       (STRING-SPEC::|!length| 
                                                        pV395)) 
                                                      (PRETTYPRINT::prettysFill 
                                                       (cons 
                                                        (ANNSPECPRINTER::ppPattern-1-1-1 
                                                         context 
                                                         (cons pV393 t) 
                                                         (cdr pV394)) 
                                                        nil))) 
                                                     nil))))) 
                                               (error 
                                                "Nonexhaustive match failure in ppPattern")))) 
                                            (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                             path 
                                             #'(lambda (x1) 
                                                (ppEntry (car x1) (cdr x1))) 
                                             (vector 
                                              (svref pp 21) 
                                              (svref pp 5) 
                                              (svref pp 30)) 
                                             pV474))))) 
                                   (if (eq (car pattern) :|EmbedPat|) 
                                       (let ((pV415 (cdr pattern))) 
                                         (let ((pV435 (svref pV415 0))
                                               (pV436 (svref pV415 1))
                                               (pV437 (svref pV415 2))) 
                                           (progn (if (string=  "Nil" pV435) 
                                                      (if (eq 
                                                           (car pV436) 
                                                           :|None|) 
                                                          (if (eq 
                                                               (car pV437) 
                                                               :|Base|) 
                                                              (let ((pV461 
                                                                     (cdr pV437))) 
                                                                (let ((pV462 
                                                                       (svref 
                                                                        pV461 
                                                                        0))
                                                                      (pV463 
                                                                       (svref 
                                                                        pV461 
                                                                        1))) 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV462) 
                                                                       :|Qualified|) 
                                                                      (let ((pV465 
                                                                             (cdr 
                                                                              pV462))) 
                                                                        (let ((pV467 
                                                                               (cdr 
                                                                                pV465))) 
                                                                          (progn (if (string=  
                                                                                      "List" 
                                                                                      (car 
                                                                                       pV465)) 
                                                                                     (if (string=  
                                                                                          "List" 
                                                                                          pV467) 
                                                                                         (if (consp 
                                                                                              pV463) 
                                                                                             (if (null 
                                                                                                  (cdr 
                                                                                                   pV463)) 
                                                                                                 (return 
                                                                                                  (PRETTYPRINT::|!string| 
                                                                                                   "[]")))))) 
                                                                                 (if (string=  
                                                                                      "List" 
                                                                                      pV467) 
                                                                                     (if (consp 
                                                                                          pV463) 
                                                                                         (if (null 
                                                                                              (cdr 
                                                                                               pV463)) 
                                                                                             (return 
                                                                                              (PRETTYPRINT::|!string| 
                                                                                               "[]")))))))))))))) 
                                                  (if (eq (car pV436) :|None|) 
                                                      (return 
                                                       (funcall (svref pp 38) 
                                                                pV435))) 
                                                  (if (string=  "Cons" pV435) 
                                                      (if (eq 
                                                           (car pV436) 
                                                           :|Some|) 
                                                          (let ((pV440 
                                                                 (cdr pV436))) 
                                                            (if (eq 
                                                                 (car pV440) 
                                                                 :|RecordPat|) 
                                                                (let ((pV442 
                                                                       (car 
                                                                        (cdr 
                                                                         pV440)))) 
                                                                  (if (consp 
                                                                       pV442) 
                                                                      (let ((pV445 
                                                                             (car 
                                                                              pV442))
                                                                            (pV446 
                                                                             (cdr 
                                                                              pV442))) 
                                                                        (if (string=  
                                                                             "1" 
                                                                             (car 
                                                                              pV445)) 
                                                                            (if (consp 
                                                                                 pV446) 
                                                                                (let ((pV450 
                                                                                       (car 
                                                                                        pV446))) 
                                                                                  (if (string=  
                                                                                       "2" 
                                                                                       (car 
                                                                                        pV450)) 
                                                                                      (if (null 
                                                                                           (cdr 
                                                                                            pV446)) 
                                                                                          (if (eq 
                                                                                               (car 
                                                                                                pV437) 
                                                                                               :|Base|) 
                                                                                              (let ((pV456 
                                                                                                     (svref 
                                                                                                      (cdr 
                                                                                                       pV437) 
                                                                                                      1))) 
                                                                                                (if (consp 
                                                                                                     pV456) 
                                                                                                    (if (null 
                                                                                                         (cdr 
                                                                                                          pV456)) 
                                                                                                        (return 
                                                                                                         (ANNSPECPRINTER::|!enclose| 
                                                                                                          enclosed 
                                                                                                          (PRETTYPRINT::prettysFill 
                                                                                                           (cons 
                                                                                                            (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                                             context 
                                                                                                             (cons 
                                                                                                              (LIST-SPEC::|!++| 
                                                                                                               (cons 
                                                                                                                0 
                                                                                                                nil) 
                                                                                                               path) 
                                                                                                              nil) 
                                                                                                             (cdr 
                                                                                                              pV445)) 
                                                                                                            (cons 
                                                                                                             (PRETTYPRINT::|!string| 
                                                                                                              " :: ") 
                                                                                                             (cons 
                                                                                                              (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                                               context 
                                                                                                               (cons 
                                                                                                                (LIST-SPEC::|!++| 
                                                                                                                 (cons 
                                                                                                                  1 
                                                                                                                  nil) 
                                                                                                                 path) 
                                                                                                                nil) 
                                                                                                               (cdr 
                                                                                                                pV450)) 
                                                                                                              nil)))))))))))))))))))))) 
                                                  (if (eq (car pV436) :|Some|) 
                                                      (let ((pV439 (cdr pV436))) 
                                                        (return 
                                                         (ANNSPECPRINTER::|!enclose| 
                                                          enclosed 
                                                          (PRETTYPRINT::prettysFill 
                                                           (LIST-SPEC::|!cons| 
                                                            (funcall (svref 
                                                                      pp 
                                                                      38) 
                                                                     pV435) 
                                                            (if (ANNSPECPRINTER::singletonPattern 
                                                                 pV439) 
                                                                (cons 
                                                                 (PRETTYPRINT::|!string| 
                                                                  " ") 
                                                                 (cons 
                                                                  (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                   context 
                                                                   (cons 
                                                                    (LIST-SPEC::|!++| 
                                                                     (cons 0 nil) 
                                                                     path) 
                                                                    nil) 
                                                                   pV439) 
                                                                  nil)) 
                                                                (cons 
                                                                 (svref pp 22) 
                                                                 (cons 
                                                                  (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                   context 
                                                                   (cons 
                                                                    (LIST-SPEC::|!++| 
                                                                     (cons 0 nil) 
                                                                     path) 
                                                                    t) 
                                                                   pV439) 
                                                                  (cons 
                                                                   (svref pp 31) 
                                                                   nil))))))))))))) 
                                       (if (eq (car pattern) :|SortedPat|) 
                                           (let ((pV414 (cdr pattern))) 
                                             (return 
                                              (ANNSPECPRINTER::|!enclose| 
                                               enclosed 
                                               (PRETTYPRINT::blockFill 
                                                0 
                                                (cons 
                                                 (cons 
                                                  0 
                                                  (ANNSPECPRINTER::ppPattern-1-1-1 
                                                   context 
                                                   (cons 
                                                    (LIST-SPEC::|!++| 
                                                     (cons 0 nil) 
                                                     path) 
                                                    nil) 
                                                   (svref pV414 0))) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (PRETTYPRINT::|!string| " : ")) 
                                                  (cons 
                                                   (cons 
                                                    0 
                                                    (ANNSPECPRINTER::ppSort-1-1-1 
                                                     context 
                                                     (cons 
                                                      (LIST-SPEC::|!++| 
                                                       (cons 1 nil) 
                                                       path) 
                                                      '(:|Top|)) 
                                                     (svref pV414 1))) 
                                                   nil))))))) 
                                           (if (eq (car pattern) :|AliasPat|) 
                                               (let ((pV413 (cdr pattern))) 
                                                 (return 
                                                  (ANNSPECPRINTER::|!enclose| 
                                                   enclosed 
                                                   (PRETTYPRINT::blockFill 
                                                    0 
                                                    (cons 
                                                     (cons 
                                                      0 
                                                      (ANNSPECPRINTER::ppPattern-1-1-1 
                                                       context 
                                                       (cons 
                                                        (LIST-SPEC::|!++| 
                                                         (cons 0 nil) 
                                                         path) 
                                                        nil) 
                                                       (svref pV413 0))) 
                                                     (cons 
                                                      (cons 
                                                       0 
                                                       (PRETTYPRINT::|!string| 
                                                        " as ")) 
                                                      (cons 
                                                       (cons 
                                                        0 
                                                        (ANNSPECPRINTER::ppPattern-1-1-1 
                                                         context 
                                                         (cons 
                                                          (LIST-SPEC::|!++| 
                                                           (cons 1 nil) 
                                                           path) 
                                                          nil) 
                                                         (svref pV413 1))) 
                                                       nil))))))) 
                                               (if (eq (car pattern) :|RelaxPat|) 
                                                   (let ((pV412 (cdr pattern))) 
                                                     (let ((pV426 
                                                            (svref pV412 0))) 
                                                       (return 
                                                        (progn (METASLANG::patternSort 
                                                                pV426) 
                                                               (ANNSPECPRINTER::|!enclose| 
                                                                enclosed 
                                                                (PRETTYPRINT::blockFill 
                                                                 0 
                                                                 (cons 
                                                                  (cons 
                                                                   0 
                                                                   (PRETTYPRINT::|!string| 
                                                                    "relax (")) 
                                                                  (cons 
                                                                   (cons 
                                                                    0 
                                                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                     context 
                                                                     (cons 
                                                                      (LIST-SPEC::|!++| 
                                                                       (cons 
                                                                        1 
                                                                        nil) 
                                                                       path) 
                                                                      '(:|Top|)) 
                                                                     (svref 
                                                                      pV412 
                                                                      1))) 
                                                                   (cons 
                                                                    (cons 
                                                                     0 
                                                                     (svref 
                                                                      pp 
                                                                      31)) 
                                                                    (cons 
                                                                     (cons 
                                                                      0 
                                                                      (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                       context 
                                                                       (cons 
                                                                        (LIST-SPEC::|!++| 
                                                                         (cons 
                                                                          0 
                                                                          nil) 
                                                                         path) 
                                                                        nil) 
                                                                       pV426)) 
                                                                     nil)))))))))) 
                                                   (if (eq 
                                                        (car pattern) 
                                                        :|QuotientPat|) 
                                                       (let ((pV411 
                                                              (cdr pattern))) 
                                                         (return 
                                                          (ANNSPECPRINTER::|!enclose| 
                                                           enclosed 
                                                           (PRETTYPRINT::blockFill 
                                                            0 
                                                            (cons 
                                                             (cons 
                                                              0 
                                                              (PRETTYPRINT::|!string| 
                                                               "quotient(")) 
                                                             (cons 
                                                              (cons 
                                                               0 
                                                               (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                context 
                                                                (cons 
                                                                 (LIST-SPEC::|!++| 
                                                                  (cons 1 nil) 
                                                                  path) 
                                                                 '(:|Top|)) 
                                                                (svref pV411 1))) 
                                                              (cons 
                                                               (cons 
                                                                0 
                                                                (PRETTYPRINT::|!string| 
                                                                 " ?)")) 
                                                               (cons 
                                                                (cons 
                                                                 0 
                                                                 (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                  context 
                                                                  (cons 
                                                                   (LIST-SPEC::|!++| 
                                                                    (cons 0 nil) 
                                                                    path) 
                                                                   nil) 
                                                                  (svref pV411 0))) 
                                                                nil)))))))))))))))))))) 
       (return (SYSTEM-SPEC::fail "Uncovered case for pattern"))))))
                                                                    
(defun ANNSPECPRINTER::ppSort-1-1-1 (context x srt) 
  (let ((path (car x))
        (parent (cdr x))) 
    (let ((pp (svref context 4))) 
      (block 
       nil 
       (if (eq (car srt) :|CoProduct|) 
           (let ((pV582 (car (cdr srt)))) 
             (return 
              (labels 
                ((ppEntry (pV500 pV501) 
                  (block 
                   nil 
                   (let ((pV502 (car pV501))
                         (pV503 (cdr pV501))) 
                     (return 
                      (block 
                       nil 
                       (if (eq (car pV503) :|Some|) 
                           (return 
                            (PRETTYPRINT::prettysNone 
                             (cons 
                              (svref pp 3) 
                              (cons 
                               (funcall (svref pp 38) pV502) 
                               (cons 
                                (PRETTYPRINT::|!string| " ") 
                                (cons 
                                 (ANNSPECPRINTER::ppSort-1-1-1 
                                  context 
                                  (cons pV500 '(:|CoProduct|)) 
                                  (cdr pV503)) 
                                 nil)))))) 
                           (if (eq (car pV503) :|None|) 
                               (return 
                                (PRETTYPRINT::prettysNone 
                                 (cons 
                                  (svref pp 3) 
                                  (cons (funcall (svref pp 38) pV502) nil)))))) 
                       (error "Nonexhaustive match failure in ppSort")))) 
                   (error "Nonexhaustive match failure in ppSort")))) 
                (progn (block 
                        nil 
                        (if (eq (car parent) :|Product|) 
                            (return (cons (svref pp 22) (svref pp 31))) 
                            (if (eq (car parent) :|CoProduct|) 
                                (return (cons (svref pp 22) (svref pp 31))))) 
                        (return (cons (svref pp 10) (svref pp 10)))) 
                       (block 
                        nil 
                        (return 
                         (ANNTERMPRINTER::ppListPath-1-1-1-1 
                          path 
                          #'(lambda (x1) (ppEntry (car x1) (cdr x1))) 
                          (vector (svref pp 10) (svref pp 10) (svref pp 10)) 
                          pV582)) 
                        (error "Nonexhaustive match failure in ppSort")))))) 
           (if (eq (car srt) :|Product|) 
               (let ((pV580 (car (cdr srt)))) 
                 (progn (if (null pV580) (return (PRETTYPRINT::|!string| "()"))) 
                        (return 
                         (if (ANNSPECPRINTER::isShortTuple 1 pV580) 
                             (let ((pV517 
                                    (block 
                                     nil 
                                     (if (eq (car parent) :|Product|) 
                                         (return 
                                          (cons (svref pp 22) (svref pp 31)))) 
                                     (return (cons (svref pp 10) (svref pp 10)))))) 
                               (block 
                                nil 
                                (return 
                                 (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                  path 
                                  #'(lambda (x1) 
                                     (block 
                                      nil 
                                      (return 
                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                        context 
                                        (cons (car x1) '(:|Product|)) 
                                        (cdr (cdr x1)))) 
                                      (error 
                                       "Nonexhaustive match failure in ppSort"))) 
                                  (vector (car pV517) (svref pp 28) (cdr pV517)) 
                                  pV580)) 
                                (error "Nonexhaustive match failure in ppSort"))) 
                             (labels 
                               ((ppEntry (pV520 pV521) 
                                 (block 
                                  nil 
                                  (return 
                                   (PRETTYPRINT::blockFill 
                                    0 
                                    (cons 
                                     (cons 0 (funcall (svref pp 38) (car pV521))) 
                                     (cons 
                                      (cons 0 (PRETTYPRINT::|!string| ":")) 
                                      (cons 
                                       (cons 
                                        0 
                                        (ANNSPECPRINTER::ppSort-1-1-1 
                                         context 
                                         (cons pV520 '(:|Top|)) 
                                         (cdr pV521))) 
                                       nil))))) 
                                  (error "Nonexhaustive match failure in ppSort")))) 
                               (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                path 
                                #'(lambda (x1) (ppEntry (car x1) (cdr x1))) 
                                (vector 
                                 (svref pp 21) 
                                 (PRETTYPRINT::|!string| ", ") 
                                 (svref pp 30)) 
                                pV580)))))) 
               (if (eq (car srt) :|Arrow|) 
                   (let ((pV547 (cdr srt))) 
                     (return 
                      (let ((pV527 
                             (block 
                              nil 
                              (if (eq (car parent) :|Product|) 
                                  (return (cons (svref pp 22) (svref pp 31))) 
                                  (if (eq (car parent) :|ArrowLeft|) 
                                      (return (cons (svref pp 22) (svref pp 31))))) 
                              (return (cons (svref pp 10) (svref pp 10)))))) 
                        (block 
                         nil 
                         (return 
                          (PRETTYPRINT::blockFill 
                           0 
                           (cons 
                            (cons 
                             0 
                             (PRETTYPRINT::prettysNone 
                              (cons 
                               (car pV527) 
                               (cons 
                                (ANNSPECPRINTER::ppSort-1-1-1 
                                 context 
                                 (cons 
                                  (LIST-SPEC::|!++| (cons 0 nil) path) 
                                  '(:|ArrowLeft|)) 
                                 (svref pV547 0)) 
                                (cons (svref pp 1) nil))))) 
                            (cons 
                             (cons 
                              3 
                              (PRETTYPRINT::prettysNone 
                               (cons 
                                (ANNSPECPRINTER::ppSort-1-1-1 
                                 context 
                                 (cons 
                                  (LIST-SPEC::|!++| (cons 1 nil) path) 
                                  '(:|ArrowRight|)) 
                                 (svref pV547 1)) 
                                (cons (cdr pV527) nil)))) 
                             nil)))) 
                         (error "Nonexhaustive match failure in ppSort"))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV546 (cdr srt))) 
                         (let ((pV560 (svref pV546 0))
                               (pV561 (svref pV546 1))) 
                           (progn (if (eq (car pV561) :|Lambda|) 
                                      (let ((pV564 (car (cdr pV561)))) 
                                        (if (consp pV564) 
                                            (let ((pV567 (car pV564))) 
                                              (let ((pV570 (svref pV567 1))) 
                                                (if (eq (car pV570) :|Fun|) 
                                                    (let ((pV573 
                                                           (svref (cdr pV570) 0))) 
                                                      (if (eq 
                                                           (car pV573) 
                                                           :|Bool|) 
                                                          (if (eq t (cdr pV573)) 
                                                              (if (null 
                                                                   (cdr pV564)) 
                                                                  (return 
                                                                   (PRETTYPRINT::blockFill 
                                                                    0 
                                                                    (cons 
                                                                     (cons 
                                                                      0 
                                                                      (svref 
                                                                       pp 
                                                                       21)) 
                                                                     (cons 
                                                                      (cons 
                                                                       0 
                                                                       (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                        context 
                                                                        (cons 
                                                                         (LIST-SPEC::|!++| 
                                                                          (cons 
                                                                           0 
                                                                           (cons 
                                                                            0 
                                                                            (cons 
                                                                             1 
                                                                             nil))) 
                                                                          path) 
                                                                         t) 
                                                                        (svref 
                                                                         pV567 
                                                                         0))) 
                                                                      (cons 
                                                                       (cons 
                                                                        0 
                                                                        (PRETTYPRINT::|!string| 
                                                                         " : ")) 
                                                                       (cons 
                                                                        (cons 
                                                                         0 
                                                                         (ANNSPECPRINTER::ppSort-1-1-1 
                                                                          context 
                                                                          (cons 
                                                                           (LIST-SPEC::|!++| 
                                                                            (cons 
                                                                             0 
                                                                             nil) 
                                                                            path) 
                                                                           '(:|Top|)) 
                                                                          pV560)) 
                                                                        (cons 
                                                                         (cons 
                                                                          0 
                                                                          (svref 
                                                                           pp 
                                                                           3)) 
                                                                         (cons 
                                                                          (cons 
                                                                           0 
                                                                           (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                            context 
                                                                            (cons 
                                                                             (LIST-SPEC::|!++| 
                                                                              (cons 
                                                                               2 
                                                                               (cons 
                                                                                0 
                                                                                (cons 
                                                                                 1 
                                                                                 nil))) 
                                                                              path) 
                                                                             '(:|Top|)) 
                                                                            (svref 
                                                                             pV567 
                                                                             2))) 
                                                                          (cons 
                                                                           (cons 
                                                                            0 
                                                                            (svref 
                                                                             pp 
                                                                             30)) 
                                                                           nil))))))))))))))))))) 
                                  (return 
                                   (PRETTYPRINT::blockFill 
                                    0 
                                    (cons 
                                     (cons 0 (svref pp 22)) 
                                     (cons 
                                      (cons 
                                       0 
                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                        context 
                                        (cons 
                                         (LIST-SPEC::|!++| (cons 0 nil) path) 
                                         '(:|Top|)) 
                                        pV560)) 
                                      (cons 
                                       (cons 0 (svref pp 3)) 
                                       (cons 
                                        (cons 
                                         0 
                                         (ANNSPECPRINTER::ppTerm-1-1-1 
                                          context 
                                          (cons 
                                           (LIST-SPEC::|!++| (cons 1 nil) path) 
                                           '(:|Top|)) 
                                          pV561)) 
                                        (cons (cons 0 (svref pp 31)) nil)))))))))) 
                       (if (eq (car srt) :|Quotient|) 
                           (let ((pV545 (cdr srt))) 
                             (return 
                              (PRETTYPRINT::blockFill 
                               0 
                               (cons 
                                (cons 0 (svref pp 22)) 
                                (cons 
                                 (cons 
                                  0 
                                  (ANNSPECPRINTER::ppSort-1-1-1 
                                   context 
                                   (cons 
                                    (LIST-SPEC::|!++| (cons 0 nil) path) 
                                    '(:|Top|)) 
                                   (svref pV545 0))) 
                                 (cons 
                                  (cons 0 (PRETTYPRINT::|!string| " / ")) 
                                  (cons 
                                   (cons 
                                    0 
                                    (ANNSPECPRINTER::ppTerm-1-1-1 
                                     context 
                                     (cons 
                                      (LIST-SPEC::|!++| (cons 1 nil) path) 
                                      '(:|Top|)) 
                                     (svref pV545 1))) 
                                   (cons (cons 0 (svref pp 31)) nil)))))))) 
                           (if (eq (car srt) :|Base|) 
                               (let ((pV544 (cdr srt))) 
                                 (let ((pV554 (svref pV544 0))
                                       (pV555 (svref pV544 1))) 
                                   (progn (if (null pV555) 
                                              (return 
                                               (funcall (svref pp 46) pV554))) 
                                          (return 
                                           (PRETTYPRINT::blockFill 
                                            0 
                                            (cons 
                                             (cons 
                                              0 
                                              (funcall (svref pp 46) pV554)) 
                                             (cons 
                                              (cons 
                                               0 
                                               (ANNTERMPRINTER::ppListPath-1-1-1-1 
                                                path 
                                                #'(lambda (x1) 
                                                   (ANNSPECPRINTER::ppSort-1-1-1 
                                                    context 
                                                    (cons (car x1) '(:|Top|)) 
                                                    (cdr x1))) 
                                                (vector 
                                                 (svref pp 22) 
                                                 (svref pp 5) 
                                                 (svref pp 31)) 
                                                pV555)) 
                                              nil))))))) 
                               (if (eq (car srt) :|TyVar|) 
                                   (return 
                                    (PRETTYPRINT::|!string| (car (cdr srt)))) 
                                   (if (eq (car srt) :|MetaTyVar|) 
                                       (return 
                                        (PRETTYPRINT::|!string| 
                                         (ANNSPECPRINTER::TyVarString 
                                          (car (cdr srt))))))))))))) 
       (return (PRETTYPRINT::|!string| "ignoring bad case for sort"))))))
                                                                         
(defparameter METASLANG::UnQualified "<unqualified>")
                                                     
(defun ANNTERMPRINTER::ppAsciiId (pV1051) 
  (block 
   nil 
   (if (eq (car pV1051) :|Qualified|) 
       (let ((pV1052 (cdr pV1051))) 
         (let ((pV1054 (cdr pV1052))
               (pV1053 (car pV1052))) 
           (return 
            (PRETTYPRINT::|!string| 
             (if (lisp::or 
                  (string=  pV1053 METASLANG::UnQualified) 
                  (lisp::or 
                   (string=  pV1053 "Nat") 
                   (lisp::or 
                    (string=  pV1053 "Boolean") 
                    (lisp::or 
                     (string=  pV1053 "String") 
                     (lisp::or 
                      (string=  pV1053 "Integer") 
                      (lisp::or 
                       (string=  pV1053 "General") 
                       (lisp::or 
                        (string=  pV1053 "Char") 
                        (string=  pV1053 "List")))))))) 
                 pV1054 
                 (STRING-SPEC::^ (STRING-SPEC::^ pV1053 ".") pV1054))))))) 
   (error "Nonexhaustive match failure in ppAsciiId")))
                                                       
(defparameter ANNTERMPRINTER::asciiPrinter 
  (vector 
   (PRETTYPRINT::|!string| " and ") 
   (PRETTYPRINT::|!string| " -> ") 
   (PRETTYPRINT::|!string| "axiom") 
   (PRETTYPRINT::|!string| " | ") 
   (PRETTYPRINT::|!string| "case ") 
   (PRETTYPRINT::|!string| ", ") 
   (PRETTYPRINT::|!string| "conjecture") 
   (PRETTYPRINT::|!string| "def ") 
   (PRETTYPRINT::|!string| "=") 
   (PRETTYPRINT::|!string| "else ") 
   (PRETTYPRINT::|!string| "") 
   (PRETTYPRINT::|!string| "end-module") 
   (PRETTYPRINT::|!string| "endspec") 
   (PRETTYPRINT::|!string| "=") 
   (PRETTYPRINT::|!string| "ex") 
   (PRETTYPRINT::|!string| "fa") 
   (PRETTYPRINT::|!string| "if ") 
   (PRETTYPRINT::|!string| "import ") 
   (PRETTYPRINT::|!string| "in ") 
   (PRETTYPRINT::|!string| "is") 
   (PRETTYPRINT::|!string| "[") 
   (PRETTYPRINT::|!string| "{") 
   (PRETTYPRINT::|!string| "(") 
   (PRETTYPRINT::|!string| "fn ") 
   (PRETTYPRINT::|!string| "let ") 
   (PRETTYPRINT::|!string| "module ") 
   (PRETTYPRINT::|!string| "of ") 
   (PRETTYPRINT::|!string| "op") 
   (PRETTYPRINT::|!string| " * ") 
   (PRETTYPRINT::|!string| "]") 
   (PRETTYPRINT::|!string| "}") 
   (PRETTYPRINT::|!string| ")") 
   (PRETTYPRINT::|!string| "sort") 
   (PRETTYPRINT::|!string| "spec ") 
   (PRETTYPRINT::|!string| " then ") 
   (PRETTYPRINT::|!string| "theorem") 
   (PRETTYPRINT::|!string| "_") 
   (PRETTYPRINT::|!string| "where") 
   #'PRETTYPRINT::|!string| 
   #'PRETTYPRINT::|!string| 
   #'PRETTYPRINT::|!string| 
   #'PRETTYPRINT::|!string| 
   #'ANNTERMPRINTER::ppAsciiId 
   #'ANNTERMPRINTER::ppAsciiId 
   #'ANNTERMPRINTER::ppAsciiId 
   #'PRETTYPRINT::|!string| 
   #'ANNTERMPRINTER::ppAsciiId))
                                
(defun PRETTYPRINT::blanks (n) 
  (block 
   nil 
   (if ( =  0 n) (return "")) 
   (return 
    (STRING-SPEC::concat " " (PRETTYPRINT::blanks (INTEGER-SPEC::|!-| n 1))))))
                                                                               
(defun PRETTYPRINT::newlineString () (CHAR-SPEC::toString (CHAR-SPEC::chr 10)))
                                                                               
(defun PRETTYPRINT::newlineAndBlanks (n) 
  (STRING-SPEC::^ (PRETTYPRINT::newlineString) (PRETTYPRINT::blanks n)))
                                                                        
(defun PRETTYPRINT::toStream (text cont base newlineAndBlanks) 
  (labels 
    ((|!loop| (text indent) 
      (block 
       nil 
       (if (null text) 
           (return 
            (funcall cont (cons (cons indent (PRETTYPRINT::blanks indent)) base))) 
           (if (consp text) 
               (let ((pV4835 (car text))) 
                 (return 
                  (let ((head (|!loop| (cdr text) (car pV4835)))) 
                    (let ((head (LIST-SPEC::foldr-1-1-1 cont head (cdr pV4835)))) 
                      (let ((head (funcall newlineAndBlanks (cons indent head)))) 
                        head))))))) 
       (error "Nonexhaustive match failure in toStream")))) 
    (block 
     nil 
     (if (null text) 
         (return base) 
         (if (consp text) 
             (let ((pV4841 (car text))) 
               (return 
                (let ((head (|!loop| (cdr text) (car pV4841)))) 
                  (let ((head (LIST-SPEC::foldr-1-1-1 cont head (cdr pV4841)))) 
                    head)))))) 
     (error "Nonexhaustive match failure in toStream"))))
                                                         
(defun PRETTYPRINT::toString (text) 
  (PRETTYPRINT::toStream 
   text 
   #'(lambda (x) 
      (block 
       nil 
       (return (STRING-SPEC::^ (cdr x) (cdr (car x)))) 
       (error "Nonexhaustive match failure in toString"))) 
   "" 
   #'(lambda (x) 
      (STRING-SPEC::^ (cdr x) (PRETTYPRINT::newlineAndBlanks (car x))))))
                                                                         
(defun PRETTYPRINT::emptyText () nil)
                                     
(defun PRETTYPRINT::|!format| (columns p) 
  (PRETTYPRINT::formatPretty columns p (PRETTYPRINT::emptyText)))
                                                                 
(defun ANNSPECPRINTER::printSort (srt) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSort-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     srt))))
            
(defun ANNSPECPRINTER::TyVarString (mtv) 
  (let ((pV198 (STATE::|!!| mtv))) 
    (block 
     nil 
     (let ((pV199 (svref pV198 0))) 
       (return 
        (block 
         nil 
         (if (eq (car pV199) :|None|) 
             (return 
              (STRING-SPEC::^ "mtv%" (NAT-SPEC::toString (svref pV198 2)))) 
             (if (eq (car pV199) :|Some|) 
                 (return (ANNSPECPRINTER::printSort (cdr pV199))))) 
         (error "Nonexhaustive match failure in TyVarString")))) 
     (error "Nonexhaustive match failure in TyVarString"))))
                                                            
(defun ANNSPECPRINTER::boolToNat (b) (if b 1 0))
                                                
(defparameter ANNSPECPRINTER::defIndex 2)
                                         
(defun ANNSPECPRINTER::|!enclose|-1 (x) 
  (ANNSPECPRINTER::|!enclose| (car x) (cdr x)))
                                               
(defun ANNSPECPRINTER::isBuiltIn? (spec_ref pV202) 
  (declare (ignore pV202)) 
  (lisp::or 
   (string=  spec_ref "String") 
   (lisp::or 
    (string=  spec_ref "Nat") 
    (lisp::or 
     (string=  spec_ref "Boolean") 
     (lisp::or 
      (string=  spec_ref "Char") 
      (lisp::or 
       (string=  spec_ref "Integer") 
       (lisp::or (string=  spec_ref "List") (string=  spec_ref "General"))))))))
                                                                                
(defun ANNSPECPRINTER::isBuiltIn?-1 (x) 
  (ANNSPECPRINTER::isBuiltIn? (car x) (cdr x)))
                                               
(defparameter ANNSPECPRINTER::opIndex 1)
                                        
(defun ANNTERMPRINTER::ppList-1-1-1 (f x ps) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (svref x 0) 
    (cons 
     (PRETTYPRINT::prettysLinear 
      (PRETTYPRINT::addSeparator-1-1 (svref x 1) (LIST-SPEC::|!map|-1-1 f ps))) 
     (cons (svref x 2) nil)))))
                               
(defun ANNSPECPRINTER::ppForallTyVars-1-1 (pp |!tyVars|) 
  (block 
   nil 
   (if (null |!tyVars|) (return (PRETTYPRINT::|!string| ""))) 
   (return 
    (ANNTERMPRINTER::ppList-1-1-1 
     #'PRETTYPRINT::|!string| 
     (vector 
      (PRETTYPRINT::prettysNone 
       (cons 
        (PRETTYPRINT::|!string| " ") 
        (cons (svref pp 15) (cons (svref pp 22) nil)))) 
      (svref pp 5) 
      (svref pp 31)) 
     |!tyVars|))))
                  
(defun BOOLEAN-SPEC::~ (x) (if x nil t))
                                        
(defun SPLAYSET::compf-1-1 (!x1 k_) (funcall (car !x1) (cons k_ (cdr !x1))))
                                                                            
(defun SPLAYSET::compf-1 (x1) #'(lambda (x2) (SPLAYSET::compf-1-1 x1 x2)))
                                                                          
(defun SPLAYSET::compf (x0 x1) (SPLAYSET::compf-1 (cons x0 x1)))
                                                                
(defun SPLAYSET::|!member| (|!set| key) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV9146 (cdr |!set|))) 
             (let ((pV9150 (svref pV9146 2))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        (SPLAYSET::compf (svref pV9146 0) key) 
                        (STATE::|!!| pV9150)))) 
                  (let ((pV9144 (cdr x))) 
                    (block 
                     nil 
                     (if (eq (car (car x)) :|Equal|) 
                         (return (progn (STATE::|:=| pV9150 pV9144) t))) 
                     (return (progn (STATE::|:=| pV9150 pV9144) nil)) 
                     (error "Nonexhaustive match failure in member"))))))))) 
   (error "Nonexhaustive match failure in member")))
                                                    
(defun INTEGERSET::|!member| (x0 x) (SPLAYSET::|!member| x0 x))
                                                               
(defun OPTION::some? (x) 
  (block 
   nil 
   (if (eq (car x) :|None|) (return nil) (if (eq (car x) :|Some|) (return t))) 
   (error "Nonexhaustive match failure in some?")))
                                                   
(defun PRETTYPRINT::printInt (i) (INTEGER-SPEC::toString i))
                                                            
(defun PRETTYPRINT::buttonPretty (enabled |!number| p sos?) 
  (let ((|!string| 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ (BOOLEAN-SPEC::toString enabled) ":") 
            (PRETTYPRINT::printInt |!number|)) 
           ":") 
          (BOOLEAN-SPEC::toString sos?)))) 
    (PRETTYPRINT::prettysNone 
     (cons 
      (PRETTYPRINT::lengthString 0 "%[") 
      (cons (PRETTYPRINT::lengthString 0 |!string|) (cons p nil))))))
                                                                     
(defun LIST-SPEC::@ (s1 s2) (LIST-SPEC::concat s1 s2))
                                                      
(defun PRETTYPRINT::markLines (uniqueId p) 
  (LIST-SPEC::@ 
   (LIST-SPEC::@ 
    (cons 
     (cons 0 (PRETTYPRINT::lengthString 0 "%(")) 
     (cons 
      (cons 0 (PRETTYPRINT::lengthString 0 (NAT-SPEC::toString uniqueId))) 
      nil)) 
    p) 
   (cons (cons 0 (PRETTYPRINT::lengthString 0 "%)")) nil)))
                                                           
(defun PRETTYPRINT::prettysBlockDelim-1-1-1 (prettysBlock x ps) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::|!string| (svref x 0)) 
    (cons 
     (funcall prettysBlock 
              (PRETTYPRINT::addSeparator-1-1 
               (PRETTYPRINT::|!string| (svref x 1)) 
               ps)) 
     (cons (PRETTYPRINT::|!string| (svref x 2)) nil)))))
                                                        
(defun PRETTYPRINT::prettysLinearDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysLinear delims ps))
                                                                                
(defun PRETTYPRINT::ppList-1-1-1 (f x ts) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector (svref x 0) (svref x 1) (svref x 2)) 
   (LIST-SPEC::|!map|-1-1 f ts)))
                                 
(defun ANNSPECPRINTER::ppOpDecl-1-1 (context x) 
  (let ((pV354 (svref x 2))
        (pV355 (svref x 3))) 
    (block 
     nil 
     (let ((pV356 (svref pV354 0))
           (pV357 (svref pV354 1))
           (pV358 (svref pV354 2))
           (pV359 (svref pV354 3))) 
       (if (consp pV356) 
           (let ((pV361 (car pV356))) 
             (if (eq (car pV361) :|Qualified|) 
                 (let ((pV363 (cdr pV361))) 
                   (let ((pV366 (car pV358))
                         (pV367 (cdr pV358))) 
                     (let ((pV368 (car pV355))
                           (pV369 (cdr pV355))) 
                       (return 
                        (if (BOOLEAN-SPEC::~ 
                             (lisp::and 
                              (string=  (svref x 0) (car pV363)) 
                              (string=  (svref x 1) (cdr pV363)))) 
                            (cons pV368 pV369) 
                            (let ((pp (svref context 4))) 
                              (labels 
                                ((ppOpName (qid) 
                                  (block 
                                   nil 
                                   (if (eq (car qid) :|Qualified|) 
                                       (let ((pV319 (cdr qid))) 
                                         (return 
                                          (if (string=  (car pV319) "") 
                                              (funcall (svref pp 41) (cdr pV319)) 
                                              (funcall (svref pp 42) qid))))) 
                                   (error 
                                    "Nonexhaustive match failure in ppOpDecl")))) 
                                (labels 
                                  ((ppOpNames () 
                                    (block 
                                     nil 
                                     (if (consp pV356) 
                                         (if (null (cdr pV356)) 
                                             (return (ppOpName (car pV356))))) 
                                     (return 
                                      (PRETTYPRINT::ppList-1-1-1 
                                       #'ppOpName 
                                       (vector "{" "," "}") 
                                       pV356))))) 
                                  (let ((index1 
                                         (INTEGER-SPEC::~ 
                                          (INTEGER-SPEC::|!+| pV368 1)))) 
                                    (let ((button1 
                                           (if (lisp::and 
                                                (ANNSPECPRINTER::markSubterm?-1 
                                                 context) 
                                                (OPTION::some? pV359)) 
                                               (PRETTYPRINT::buttonPretty 
                                                (BOOLEAN-SPEC::~ 
                                                 (INTEGERSET::|!member| 
                                                  (svref context 0) 
                                                  index1)) 
                                                index1 
                                                (PRETTYPRINT::|!string| " ") 
                                                nil) 
                                               (PRETTYPRINT::|!string| "")))) 
                                      (let ((button2 
                                             (if (lisp::and 
                                                  (ANNSPECPRINTER::markSubterm?-1 
                                                   context) 
                                                  (OPTION::some? pV359)) 
                                                 (PRETTYPRINT::buttonPretty 
                                                  (INTEGERSET::|!member| 
                                                   (svref context 6) 
                                                   index1) 
                                                  index1 
                                                  (PRETTYPRINT::|!string| " ") 
                                                  t) 
                                                 (PRETTYPRINT::|!string| "")))) 
                                        (cons 
                                         (INTEGER-SPEC::|!+| pV368 1) 
                                         (LIST-SPEC::|!cons| 
                                          (cons 
                                           1 
                                           (PRETTYPRINT::blockFill 
                                            0 
                                            (cons 
                                             (cons 0 (svref pp 27)) 
                                             (cons 
                                              (cons 
                                               0 
                                               (PRETTYPRINT::|!string| " ")) 
                                              (cons 
                                               (cons 0 (ppOpNames)) 
                                               (cons 
                                                (cons 
                                                 0 
                                                 (block 
                                                  nil 
                                                  (if (null pV357) 
                                                      (return 
                                                       (PRETTYPRINT::|!string| 
                                                        "")) 
                                                      (if (consp pV357) 
                                                          (let ((pV329 
                                                                 (car pV357))
                                                                (pV330 
                                                                 (cdr pV357))) 
                                                            (if (eq 
                                                                 (car pV329) 
                                                                 :|Left|) 
                                                                (return 
                                                                 (PRETTYPRINT::|!string| 
                                                                  (STRING-SPEC::^ 
                                                                   " infixl " 
                                                                   (NAT-SPEC::toString 
                                                                    pV330)))) 
                                                                (if (eq 
                                                                     (car pV329) 
                                                                     :|Right|) 
                                                                    (return 
                                                                     (PRETTYPRINT::|!string| 
                                                                      (STRING-SPEC::^ 
                                                                       " infixr " 
                                                                       (NAT-SPEC::toString 
                                                                        pV330))))))))) 
                                                  (error 
                                                   "Nonexhaustive match failure in ppOpDecl"))) 
                                                (cons 
                                                 (cons 
                                                  0 
                                                  (PRETTYPRINT::|!string| " :")) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (ANNSPECPRINTER::ppForallTyVars-1-1 
                                                    pp 
                                                    pV366)) 
                                                  (cons 
                                                   (cons 
                                                    0 
                                                    (PRETTYPRINT::|!string| " ")) 
                                                   (cons 
                                                    (cons 
                                                     3 
                                                     (ANNSPECPRINTER::ppSort-1-1-1 
                                                      context 
                                                      (cons 
                                                       (cons 
                                                        pV368 
                                                        (cons 
                                                         ANNSPECPRINTER::opIndex 
                                                         nil)) 
                                                       '(:|Top|)) 
                                                      pV367)) 
                                                    nil)))))))))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV359) :|None|) 
                                               (return pV369) 
                                               (if (eq (car pV359) :|Some|) 
                                                   (let ((pV351 (cdr pV359))) 
                                                     (return 
                                                      (labels 
                                                        ((ppDefn (path term) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car term) 
                                                                :|Lambda|) 
                                                               (let ((pV337 
                                                                      (car 
                                                                       (cdr term)))) 
                                                                 (if (consp 
                                                                      pV337) 
                                                                     (let ((pV340 
                                                                            (car 
                                                                             pV337))) 
                                                                       (let ((pV343 
                                                                              (svref 
                                                                               pV340 
                                                                               1))) 
                                                                         (if (eq 
                                                                              (car 
                                                                               pV343) 
                                                                              :|Fun|) 
                                                                             (let ((pV346 
                                                                                    (svref 
                                                                                     (cdr 
                                                                                      pV343) 
                                                                                     0))) 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     pV346) 
                                                                                    :|Bool|) 
                                                                                   (if (eq 
                                                                                        t 
                                                                                        (cdr 
                                                                                         pV346)) 
                                                                                       (if (null 
                                                                                            (cdr 
                                                                                             pV337)) 
                                                                                           (return 
                                                                                            (let ((pat 
                                                                                                   (ANNSPECPRINTER::ppPattern-1-1-1 
                                                                                                    context 
                                                                                                    (cons 
                                                                                                     (LIST-SPEC::|!++| 
                                                                                                      (cons 
                                                                                                       0 
                                                                                                       (cons 
                                                                                                        0 
                                                                                                        nil)) 
                                                                                                      path) 
                                                                                                     nil) 
                                                                                                    (svref 
                                                                                                     pV340 
                                                                                                     0)))) 
                                                                                              (let ((body 
                                                                                                     (ppDefn 
                                                                                                      (LIST-SPEC::|!++| 
                                                                                                       (cons 
                                                                                                        2 
                                                                                                        (cons 
                                                                                                         0 
                                                                                                         nil)) 
                                                                                                       path) 
                                                                                                      (svref 
                                                                                                       pV340 
                                                                                                       2)))) 
                                                                                                (let ((prettys 
                                                                                                       (LIST-SPEC::|!++| 
                                                                                                        (cons 
                                                                                                         (cons 
                                                                                                          0 
                                                                                                          pat) 
                                                                                                         (cons 
                                                                                                          (cons 
                                                                                                           0 
                                                                                                           (PRETTYPRINT::|!string| 
                                                                                                            " ")) 
                                                                                                          nil)) 
                                                                                                        body))) 
                                                                                                  (if (ANNSPECPRINTER::markSubterm?-1 
                                                                                                       context) 
                                                                                                      (let ((num 
                                                                                                             (STATE::|!!| 
                                                                                                              (svref 
                                                                                                               context 
                                                                                                               1)))) 
                                                                                                        (let ((table 
                                                                                                               (STATE::|!!| 
                                                                                                                (svref 
                                                                                                                 context 
                                                                                                                 3)))) 
                                                                                                          (progn (STATE::|:=| 
                                                                                                                  (svref 
                                                                                                                   context 
                                                                                                                   3) 
                                                                                                                  (NATMAP::insert 
                                                                                                                   table 
                                                                                                                   num 
                                                                                                                   path)) 
                                                                                                                 (STATE::|:=| 
                                                                                                                  (svref 
                                                                                                                   context 
                                                                                                                   1) 
                                                                                                                  (INTEGER-SPEC::|!+| 
                                                                                                                   num 
                                                                                                                   1)) 
                                                                                                                 (PRETTYPRINT::markLines 
                                                                                                                  num 
                                                                                                                  prettys)))) 
                                                                                                      prettys))))))))))))))) 
                                                           (return 
                                                            (let ((pretty 
                                                                   (ANNSPECPRINTER::ppTerm-1-1-1 
                                                                    context 
                                                                    (cons 
                                                                     path 
                                                                     '(:|Top|)) 
                                                                    term))) 
                                                              (let ((prettys 
                                                                     (cons 
                                                                      (cons 
                                                                       0 
                                                                       (svref 
                                                                        pp 
                                                                        8)) 
                                                                      (cons 
                                                                       (cons 
                                                                        0 
                                                                        (PRETTYPRINT::|!string| 
                                                                         " ")) 
                                                                       (cons 
                                                                        (cons 
                                                                         4 
                                                                         pretty) 
                                                                        nil))))) 
                                                                prettys)))))) 
                                                        (let ((prettys 
                                                               (ppDefn 
                                                                (cons 
                                                                 pV368 
                                                                 (cons 
                                                                  ANNSPECPRINTER::defIndex 
                                                                  nil)) 
                                                                pV351))) 
                                                          (LIST-SPEC::|!cons| 
                                                           (cons 
                                                            1 
                                                            (PRETTYPRINT::blockFill 
                                                             0 
                                                             (LIST-SPEC::|!++| 
                                                              (cons 
                                                               (cons 
                                                                0 
                                                                (PRETTYPRINT::blockFill 
                                                                 0 
                                                                 (cons 
                                                                  (cons 
                                                                   0 
                                                                   button1) 
                                                                  (cons 
                                                                   (cons 
                                                                    0 
                                                                    button2) 
                                                                   (cons 
                                                                    (cons 
                                                                     0 
                                                                     (svref pp 7)) 
                                                                    (cons 
                                                                     (if (ANNSPECPRINTER::printSort?-1 
                                                                          context) 
                                                                         (cons 
                                                                          0 
                                                                          (ANNSPECPRINTER::ppForallTyVars-1-1 
                                                                           pp 
                                                                           pV366)) 
                                                                         (cons 
                                                                          0 
                                                                          (PRETTYPRINT::|!string| 
                                                                           ""))) 
                                                                     (cons 
                                                                      (cons 
                                                                       0 
                                                                       (ppOpName 
                                                                        pV361)) 
                                                                      (cons 
                                                                       (cons 
                                                                        0 
                                                                        (PRETTYPRINT::|!string| 
                                                                         " ")) 
                                                                       nil)))))))) 
                                                               nil) 
                                                              prettys))) 
                                                           pV369))))))) 
                                           (error 
                                            "Nonexhaustive match failure in ppOpDecl"))))))))))))))))))) 
     (error "Nonexhaustive match failure in ppOpDecl"))))
                                                         
(defun ANNSPECPRINTER::ppOpDecl-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppOpDecl-1-1 x1 x2)))
                                                       
(defun ANNSPECPRINTER::ppOpDecls-1-1 (context ops) 
  (let ((pV370 
         (STRINGMAP::foldriDouble-1-1-1 
          (ANNSPECPRINTER::ppOpDecl-1 context) 
          (cons 0 nil) 
          ops))) 
    (block 
     nil 
     (return (cdr pV370)) 
     (error "Nonexhaustive match failure in ppOpDecls"))))
                                                          
(defparameter ANNSPECPRINTER::propertyIndex 3)
                                              
(defun LIST-SPEC::|!null| (l) (block nil (if (null l) (return t)) (return nil)))
                                                                                
(defun ANNSPECPRINTER::ppProperty-1-1 (context x) 
  (let ((pV491 (car x))
        (pV492 (cdr x))) 
    (block 
     nil 
     (let ((pV493 (svref pV492 0))
           (pV495 (svref pV492 2))) 
       (return 
        (let ((pp (svref context 4))) 
          (let ((button1 
                 (if (ANNSPECPRINTER::markSubterm?-1 context) 
                     (PRETTYPRINT::buttonPretty 
                      (BOOLEAN-SPEC::~ 
                       (INTEGERSET::|!member| (svref context 0) pV491)) 
                      pV491 
                      (PRETTYPRINT::|!string| " ") 
                      nil) 
                     (PRETTYPRINT::|!string| "")))) 
            (let ((button2 
                   (if (ANNSPECPRINTER::markSubterm?-1 context) 
                       (PRETTYPRINT::buttonPretty 
                        (INTEGERSET::|!member| (svref context 6) pV491) 
                        pV491 
                        (PRETTYPRINT::|!string| " ") 
                        t) 
                       (PRETTYPRINT::|!string| "")))) 
              (cons 
               1 
               (PRETTYPRINT::blockFill 
                0 
                (cons 
                 (cons 0 button1) 
                 (cons 
                  (cons 0 button2) 
                  (cons 
                   (cons 
                    0 
                    (block 
                     nil 
                     (if (eq (car pV493) :|Theorem|) 
                         (return (svref pp 35)) 
                         (if (eq (car pV493) :|Axiom|) 
                             (return (svref pp 2)) 
                             (if (eq (car pV493) :|Conjecture|) 
                                 (return (svref pp 6))))) 
                     (error "Nonexhaustive match failure in ppProperty"))) 
                   (cons 
                    (cons 
                     0 
                     (funcall (svref pp 40) (STRING-SPEC::^ " " (svref pV492 1)))) 
                    (cons 
                     (cons 0 (PRETTYPRINT::|!string| " ")) 
                     (cons 
                      (cons 0 (svref pp 19)) 
                      (cons 
                       (cons 
                        0 
                        (if (LIST-SPEC::|!null| pV495) 
                            (PRETTYPRINT::|!string| "") 
                            (PRETTYPRINT::|!string| " sort"))) 
                       (cons 
                        (cons 0 (ANNSPECPRINTER::ppForallTyVars-1-1 pp pV495)) 
                        (cons 
                         (cons 0 (PRETTYPRINT::|!string| " ")) 
                         (cons 
                          (cons 
                           3 
                           (ANNSPECPRINTER::ppTerm-1-1-1 
                            context 
                            (cons 
                             (cons 
                              pV491 
                              (cons ANNSPECPRINTER::propertyIndex nil)) 
                             '(:|Top|)) 
                            (svref pV492 3))) 
                          nil))))))))))))))))) 
     (error "Nonexhaustive match failure in ppProperty"))))
                                                           
(defun ANNSPECPRINTER::ppProperty-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppProperty-1-1 x1 x2)))
                                                         
(defun ANNSPECPRINTER::ppTyVars-1-1 (pp |!tyVars|) 
  (block 
   nil 
   (if (null |!tyVars|) (return (PRETTYPRINT::|!string| ""))) 
   (return 
    (ANNTERMPRINTER::ppList-1-1-1 
     #'PRETTYPRINT::|!string| 
     (vector (svref pp 22) (svref pp 5) (svref pp 31)) 
     |!tyVars|))))
                  
(defparameter ANNSPECPRINTER::sortIndex 0)
                                          
(defun ANNSPECPRINTER::ppSortDecl-1-1 (context x) 
  (let ((pV598 (svref x 2))
        (pV599 (svref x 3))) 
    (block 
     nil 
     (let ((pV600 (svref pV598 0))
           (pV601 (svref pV598 1))
           (pV602 (svref pV598 2))) 
       (if (consp pV600) 
           (let ((pV604 (car pV600))) 
             (if (eq (car pV604) :|Qualified|) 
                 (let ((pV606 (cdr pV604))) 
                   (let ((pV609 (car pV599))
                         (pV610 (cdr pV599))) 
                     (return 
                      (if (BOOLEAN-SPEC::~ 
                           (lisp::and 
                            (string=  (svref x 0) (car pV606)) 
                            (string=  (svref x 1) (cdr pV606)))) 
                          (cons pV609 pV610) 
                          (let ((pp (svref context 4))) 
                            (labels 
                              ((ppSortName (qid) 
                                (block 
                                 nil 
                                 (if (eq (car qid) :|Qualified|) 
                                     (let ((pV586 (cdr qid))) 
                                       (return 
                                        (if (string=  (car pV586) "") 
                                            (funcall (svref pp 45) (cdr pV586)) 
                                            (funcall (svref pp 46) qid))))) 
                                 (error 
                                  "Nonexhaustive match failure in ppSortDecl")))) 
                              (labels 
                                ((ppSortNames () 
                                  (block 
                                   nil 
                                   (if (consp pV600) 
                                       (if (null (cdr pV600)) 
                                           (return (ppSortName (car pV600))))) 
                                   (return 
                                    (PRETTYPRINT::ppList-1-1-1 
                                     #'ppSortName 
                                     (vector "{" "," "}") 
                                     pV600))))) 
                                (cons 
                                 (INTEGER-SPEC::|!+| pV609 1) 
                                 (LIST-SPEC::|!cons| 
                                  (block 
                                   nil 
                                   (if (eq (car pV602) :|None|) 
                                       (return 
                                        (cons 
                                         1 
                                         (PRETTYPRINT::blockFill 
                                          0 
                                          (cons 
                                           (cons 0 (svref pp 32)) 
                                           (cons 
                                            (cons 0 (PRETTYPRINT::|!string| " ")) 
                                            (cons 
                                             (cons 0 (ppSortNames)) 
                                             (cons 
                                              (cons 
                                               0 
                                               (ANNSPECPRINTER::ppTyVars-1-1 
                                                pp 
                                                pV601)) 
                                              nil))))))) 
                                       (if (eq (car pV602) :|Some|) 
                                           (return 
                                            (cons 
                                             1 
                                             (PRETTYPRINT::blockFill 
                                              0 
                                              (cons 
                                               (cons 0 (svref pp 32)) 
                                               (cons 
                                                (cons 
                                                 0 
                                                 (PRETTYPRINT::|!string| " ")) 
                                                (cons 
                                                 (cons 0 (ppSortNames)) 
                                                 (cons 
                                                  (cons 
                                                   0 
                                                   (ANNSPECPRINTER::ppTyVars-1-1 
                                                    pp 
                                                    pV601)) 
                                                  (cons 
                                                   (cons 
                                                    0 
                                                    (PRETTYPRINT::|!string| " ")) 
                                                   (cons 
                                                    (cons 0 (svref pp 8)) 
                                                    (cons 
                                                     (cons 
                                                      0 
                                                      (PRETTYPRINT::|!string| 
                                                       " ")) 
                                                     (cons 
                                                      (cons 
                                                       3 
                                                       (ANNSPECPRINTER::ppSort-1-1-1 
                                                        context 
                                                        (cons 
                                                         (cons 
                                                          pV609 
                                                          (cons 
                                                           ANNSPECPRINTER::sortIndex 
                                                           nil)) 
                                                         '(:|Top|)) 
                                                        (cdr pV602))) 
                                                      nil))))))))))))) 
                                   (error 
                                    "Nonexhaustive match failure in ppSortDecl")) 
                                  pV610))))))))))))) 
     (error "Nonexhaustive match failure in ppSortDecl"))))
                                                           
(defun ANNSPECPRINTER::ppSortDecl-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSortDecl-1-1 x1 x2)))
                                                         
(defun ANNSPECPRINTER::ppSortDecls-1-1 (context sorts) 
  (let ((pV611 
         (STRINGMAP::foldriDouble-1-1-1 
          (ANNSPECPRINTER::ppSortDecl-1 context) 
          (cons 0 nil) 
          sorts))) 
    (block 
     nil 
     (return (cdr pV611)) 
     (error "Nonexhaustive match failure in ppSortDecls"))))
                                                            
(defun LIST-SPEC::filter-1-1 (f l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV2041 (car l))
                 (pV2042 (cdr l))) 
             (return 
              (if (funcall f pV2041) 
                  (cons pV2041 (LIST-SPEC::filter-1-1 f pV2042)) 
                  (LIST-SPEC::filter-1-1 f pV2042)))))) 
   (error "Nonexhaustive match failure in filter")))
                                                    
(defun ANNSPECPRINTER::ppSpec-1-1 (context x) 
  (block 
   nil 
   (return 
    (let ((pp (svref context 4))) 
      (let ((imports 
             (LIST-SPEC::filter-1-1 
              #'(lambda (imp) 
                 (BOOLEAN-SPEC::~ (ANNSPECPRINTER::isBuiltIn?-1 imp))) 
              (svref (svref x 0) 1)))) 
        (PRETTYPRINT::blockAll 
         0 
         (LIST-SPEC::|!++| 
          (LIST-SPEC::|!++| 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (cons 
               (cons 
                0 
                (PRETTYPRINT::blockFill 
                 0 
                 (cons 
                  (cons 0 (svref pp 33)) 
                  (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
               nil) 
              (LIST-SPEC::|!map|-1-1 
               #'(lambda (x1) 
                  (cons 
                   1 
                   (PRETTYPRINT::prettysFill 
                    (cons 
                     (svref pp 17) 
                     (cons (PRETTYPRINT::|!string| (car x1)) nil))))) 
               imports)) 
             (ANNSPECPRINTER::ppSortDecls-1-1 context (svref x 3))) 
            (ANNSPECPRINTER::ppOpDecls-1-1 context (svref x 1))) 
           (LISTUTILITIES::mapWithIndex-1-1 
            (ANNSPECPRINTER::ppProperty-1 context) 
            (svref x 2))) 
          (cons 
           (cons 0 (svref pp 12)) 
           (cons (cons 0 (PRETTYPRINT::|!string| "")) nil))))))) 
   (error "Nonexhaustive match failure in ppSpec")))
                                                    
(defun ANNTERMPRINTER::htmlPrinter () 
  (let ((nameMap (cons :|Ref| STRINGMAP::empty))) 
    (let ((counter (cons :|Ref| 0))) 
      (labels 
        ((nameNumber (s) 
          (let ((pV1032 (STRINGMAP::|!find| (STATE::|!!| nameMap) s))) 
            (block 
             nil 
             (if (eq (car pV1032) :|None|) 
                 (return 
                  (let ((n (STATE::|!!| counter))) 
                    (let ((ns (NAT-SPEC::toString n))) 
                      (progn (STATE::|:=| 
                              nameMap 
                              (STRINGMAP::insert (STATE::|!!| nameMap) s ns)) 
                             (STATE::|:=| counter (INTEGER-SPEC::|!+| n 1)) 
                             ns)))) 
                 (if (eq (car pV1032) :|Some|) (return (cdr pV1032)))) 
             (error "Nonexhaustive match failure in htmlPrinter"))))) 
        (labels 
          ((ppQid (pV1036) 
            (block 
             nil 
             (if (eq (car pV1036) :|Qualified|) 
                 (let ((pV1037 (cdr pV1036))) 
                   (let ((pV1039 (cdr pV1037))
                         (pV1038 (car pV1037))) 
                     (return 
                      (if (string=  pV1038 METASLANG::UnQualified) 
                          (PRETTYPRINT::lengthString 
                           (STRING-SPEC::|!length| pV1039) 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ "<a href = #" (nameNumber pV1039)) 
                              ">") 
                             pV1039) 
                            "</a>")) 
                          (block 
                           nil 
                           (if (string=  "Nat" pV1038) 
                               (return (PRETTYPRINT::|!string| pV1039)) 
                               (if (string=  "Boolean" pV1038) 
                                   (return (PRETTYPRINT::|!string| pV1039)))) 
                           (return 
                            (PRETTYPRINT::prettysNone 
                             (cons 
                              (PRETTYPRINT::lengthString 
                               (STRING-SPEC::|!length| pV1038) 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ "<a href = " pV1038) 
                                  ".html>") 
                                 pV1038) 
                                "</a>")) 
                              (cons 
                               (PRETTYPRINT::|!string| ".") 
                               (cons (PRETTYPRINT::|!string| pV1039) nil))))))))))) 
             (error "Nonexhaustive match failure in htmlPrinter")))) 
          (labels 
            ((ppOp (s) 
              (PRETTYPRINT::lengthString 
               (STRING-SPEC::|!length| s) 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ "<a name = " (nameNumber s)) 
                  ">") 
                 s) 
                "</a>")))) 
            (vector 
             (PRETTYPRINT::lengthString 3 "<b> and </b>") 
             (PRETTYPRINT::lengthString 4 " -> ") 
             (PRETTYPRINT::lengthString 6 "<b>axiom </b>") 
             (PRETTYPRINT::lengthString 3 "<b> | </b>") 
             (PRETTYPRINT::lengthString 6 "<b>case </b>") 
             (PRETTYPRINT::|!string| ", ") 
             (PRETTYPRINT::lengthString 11 "<b>conjecture </b>") 
             (PRETTYPRINT::lengthString 3 "<b>def </b>") 
             (PRETTYPRINT::lengthString 2 "<b>=</b>") 
             (PRETTYPRINT::lengthString 5 "<b>else </b>") 
             (PRETTYPRINT::|!string| "") 
             (PRETTYPRINT::lengthString 9 "<b>end-module </b>") 
             (PRETTYPRINT::lengthString 7 "<b>endspec</b>") 
             (PRETTYPRINT::lengthString 2 "<b>=</b>") 
             (PRETTYPRINT::lengthString 2 "<b>ex</b>") 
             (PRETTYPRINT::lengthString 2 "<b>fa</b>") 
             (PRETTYPRINT::lengthString 3 "<b>if </b>") 
             (PRETTYPRINT::lengthString 7 "<b>import </b>") 
             (PRETTYPRINT::lengthString 2 "<b> in</b>") 
             (PRETTYPRINT::lengthString 11 "<b>is </b>") 
             (PRETTYPRINT::|!string| "[") 
             (PRETTYPRINT::lengthString 1 "<b>{</b>") 
             (PRETTYPRINT::|!string| "(") 
             (PRETTYPRINT::lengthString 3 "<b>fn</b> ") 
             (PRETTYPRINT::lengthString 3 "<b>let </b>") 
             (PRETTYPRINT::lengthString 7 "<b>module </b>") 
             (PRETTYPRINT::lengthString 2 "<b>of </b>") 
             (PRETTYPRINT::lengthString 2 "<b>op</b>") 
             (PRETTYPRINT::lengthString 3 "<b> * </b>") 
             (PRETTYPRINT::|!string| "]") 
             (PRETTYPRINT::lengthString 1 "<b>}</b>") 
             (PRETTYPRINT::|!string| ")") 
             (PRETTYPRINT::lengthString 4 "<b>sort</b>") 
             (PRETTYPRINT::lengthString 5 "<b>spec </b>") 
             (PRETTYPRINT::lengthString 6 "<b> then </b>") 
             (PRETTYPRINT::lengthString 8 "<b>theorem </b>") 
             (PRETTYPRINT::lengthString 1 "<b>_</b>") 
             (PRETTYPRINT::lengthString 4 "<b>where</b>") 
             #'PRETTYPRINT::|!string| 
             #'PRETTYPRINT::|!string| 
             #'PRETTYPRINT::|!string| 
             #'ppOp 
             #'ppQid 
             #'ppQid 
             #'ppQid 
             #'ppOp 
             #'ppQid)))))))
                           
(defun ANNSPECPRINTER::htmlSpecToPretty-1 (spc) 
  (let ((pSpec 
         (ANNSPECPRINTER::ppSpec-1-1 
          (ANNSPECPRINTER::initialize (ANNTERMPRINTER::htmlPrinter) nil) 
          spc))) 
    (PRETTYPRINT::prettysAll 
     (cons 
      (PRETTYPRINT::|!string| "<html><body BGCOLOR = \"#EEFFFA\"><pre>") 
      (cons pSpec (cons (PRETTYPRINT::|!string| "</pre></body></html>") nil))))))


(defun PRETTYPRINT::streamWriter (|!stream| |!string|) 
  (IO-SPEC::format1 |!stream| "~A" |!string|))
                                              
(defun PRETTYPRINT::toFileWithNewline (|!fileName| text newlineAndBlanks) 
  (IO-SPEC::withOpenFileForWrite 
   |!fileName| 
   #'(lambda (|!stream|) 
      (PRETTYPRINT::toStream 
       text 
       #'(lambda (x) 
          (block 
           nil 
           (return (PRETTYPRINT::streamWriter |!stream| (cdr (car x)))) 
           (error "Nonexhaustive match failure in toFileWithNewline"))) 
       nil 
       #'(lambda (x) 
          (block 
           nil 
           (return 
            (PRETTYPRINT::streamWriter 
             |!stream| 
             (funcall newlineAndBlanks (car x)))) 
           (error "Nonexhaustive match failure in toFileWithNewline")))))))
                                                                           
(defun PRETTYPRINT::toFile (|!fileName| text) 
  (PRETTYPRINT::toFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::newlineAndBlanks))
                                    
(defun ANNSPECPRINTER::htmlSpecToFile (|!fileName| spc) 
  (PRETTYPRINT::toFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::htmlSpecToPretty-1 spc))))
                                                                         
(defun ANNSPECPRINTER::htmlSpecToFile-1 (x) 
  (ANNSPECPRINTER::htmlSpecToFile (car x) (cdr x)))
                                                   
(defun ANNSPECPRINTER::htmlSpecToPretty (x0 x1 x2 x3) 
  (ANNSPECPRINTER::htmlSpecToPretty-1 (vector x0 x1 x2 x3)))
                                                            
(defun ANNSPECPRINTER::initialize-1 (x) 
  (ANNSPECPRINTER::initialize (car x) (cdr x)))
                                               
(defun ANNSPECPRINTER::initializeMark (pp indicesToDisable sosIndicesToEnable) 
  (vector 
   indicesToDisable 
   (cons :|Ref| 0) 
   t 
   (cons :|Ref| NATMAP::empty) 
   pp 
   nil 
   sosIndicesToEnable))
                       
(defun ANNSPECPRINTER::initializeMark-1 (x) 
  (ANNSPECPRINTER::initializeMark (svref x 0) (svref x 1) (svref x 2)))
                                                                       
(defun ANNSPECPRINTER::isShortTuple-1 (x) 
  (ANNSPECPRINTER::isShortTuple (car x) (cdr x)))
                                                 
(defun ANNSPECPRINTER::makeSpecListing-1 (pSpec) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::|!string| "\\specListing{")) 
    (cons (cons 0 pSpec) (cons (cons 0 (PRETTYPRINT::|!string| "}")) nil)))))
                                                                             
(defun ANNTERMPRINTER::latexString (s) 
  (if (CHAR-SPEC::isAlphaNum (STRING-SPEC::sub s 0)) 
      (PRETTYPRINT::|!string| s) 
      (let ((s 
             (STRING-SPEC::translate-1-1 
              #'(lambda (pV1044) 
                 (block 
                  nil 
                  (if (eq #\^ pV1044) 
                      (return "++") 
                      (if (eq #\# pV1044) 
                          (return "\\#") 
                          (if (eq #\_ pV1044) 
                              (return "\\_") 
                              (if (eq #\& pV1044) (return "\\&"))))) 
                  (return (CHAR-SPEC::toString pV1044)))) 
              s))) 
        (PRETTYPRINT::lengthString 
         (STRING-SPEC::|!length| s) 
         (STRING-SPEC::^ (STRING-SPEC::^ "\\mbox{{\\tt " s) "}}")))))
                                                                     
(defun ANNTERMPRINTER::latexBoolean (s) 
  (block 
   nil 
   (if (string=  "&" s) 
       (return (PRETTYPRINT::lengthString 1 "$\\&$")) 
       (if (string=  " =>" s) 
           (return (PRETTYPRINT::lengthString 1 "$\\Rightarrow$")) 
           (if (string=  "or" s) 
               (return (PRETTYPRINT::lengthString 2 "\\SWor\\ ")) 
               (if (string=  "<=>" s) 
                   (return (PRETTYPRINT::lengthString 2 "$\\Leftrightarrow$")) 
                   (if (string=  "~" s) 
                       (return (PRETTYPRINT::lengthString 1 "$\\neg$"))))))) 
   (return (PRETTYPRINT::|!string| s))))
                                        
(defun ANNTERMPRINTER::latexNat (s) 
  (block 
   nil 
   (if (string=  "*" s) 
       (return (PRETTYPRINT::lengthString 1 "$\\cdot$")) 
       (if (string=  ">" s) 
           (return (PRETTYPRINT::lengthString 1 "$>$")) 
           (if (string=  "<" s) 
               (return (PRETTYPRINT::lengthString 1 "$<$")) 
               (if (string=  ">= " s) 
                   (return (PRETTYPRINT::lengthString 1 "$\\geq$")) 
                   (if (string=  "<= " s) 
                       (return (PRETTYPRINT::lengthString 1 "$\\leq$"))))))) 
   (return (PRETTYPRINT::|!string| s))))
                                        
(defun ANNTERMPRINTER::latexInt (s) (ANNTERMPRINTER::latexNat s))
                                                                 
(defun ANNTERMPRINTER::ppLatexId (pV1057) 
  (block 
   nil 
   (if (eq (car pV1057) :|Qualified|) 
       (let ((pV1058 (cdr pV1057))) 
         (let ((pV1060 (cdr pV1058))
               (pV1059 (car pV1058))) 
           (return 
            (if (string=  pV1059 METASLANG::UnQualified) 
                (ANNTERMPRINTER::latexString pV1060) 
                (block 
                 nil 
                 (if (string=  "Nat" pV1059) 
                     (return (ANNTERMPRINTER::latexNat pV1060)) 
                     (if (string=  "Integer" pV1059) 
                         (return (ANNTERMPRINTER::latexInt pV1060)) 
                         (if (string=  "Boolean" pV1059) 
                             (return (ANNTERMPRINTER::latexBoolean pV1060))))) 
                 (return 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (PRETTYPRINT::|!string| (STRING-SPEC::^ pV1059 ".")) 
                    (cons (ANNTERMPRINTER::latexString pV1060) nil)))))))))) 
   (error "Nonexhaustive match failure in ppLatexId")))
                                                       
(defparameter ANNTERMPRINTER::latexPrinter 
  (vector 
   (PRETTYPRINT::lengthString 3 "\\ \\SWand\\ ") 
   (PRETTYPRINT::lengthString 3 " $\\rightarrow$ ") 
   (PRETTYPRINT::lengthString 6 "\\SWaxiom\\ ") 
   (PRETTYPRINT::lengthString 3 " {\\tt |} ") 
   (PRETTYPRINT::lengthString 6 "\\SWcase ") 
   (PRETTYPRINT::|!string| ", ") 
   (PRETTYPRINT::lengthString 8 "{\\bf conjecture}\\ ") 
   (PRETTYPRINT::lengthString 4 "\\SWdef ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 5 "\\SWelse ") 
   (PRETTYPRINT::|!string| "") 
   (PRETTYPRINT::lengthString 9 "{\\bf end-module}\\ ") 
   (PRETTYPRINT::lengthString 8 "\\SWendspec ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 1 "\\SWex ") 
   (PRETTYPRINT::lengthString 1 "\\SWfa ") 
   (PRETTYPRINT::lengthString 3 "\\SWif ") 
   (PRETTYPRINT::lengthString 7 "\\SWimport ") 
   (PRETTYPRINT::lengthString 3 "\\ {\\bf in}") 
   (PRETTYPRINT::lengthString 2 "{\\bf is}\\ ") 
   (PRETTYPRINT::|!string| "[") 
   (PRETTYPRINT::lengthString 1 "$\\{$") 
   (PRETTYPRINT::|!string| "(") 
   (PRETTYPRINT::lengthString 3 "$\\lambda$ ") 
   (PRETTYPRINT::lengthString 4 "\\SWlet\\ ") 
   (PRETTYPRINT::lengthString 7 "{\\bf module}\\ ") 
   (PRETTYPRINT::lengthString 3 "\\SWof ") 
   (PRETTYPRINT::lengthString 2 "\\SWop ") 
   (PRETTYPRINT::lengthString 3 " $\\times$ ") 
   (PRETTYPRINT::|!string| "]") 
   (PRETTYPRINT::lengthString 1 "$\\}$") 
   (PRETTYPRINT::|!string| ")") 
   (PRETTYPRINT::lengthString 4 "\\SWsort ") 
   (PRETTYPRINT::lengthString 5 "\\SWspec\\ ") 
   (PRETTYPRINT::lengthString 6 " \\SWthen ") 
   (PRETTYPRINT::lengthString 8 "\\SWtheorem\\ ") 
   (PRETTYPRINT::lengthString 1 "{\\tt \\_}") 
   (PRETTYPRINT::lengthString 4 "{\\bf where} ") 
   #'ANNTERMPRINTER::latexString 
   #'PRETTYPRINT::|!string| 
   #'(lambda (s) 
      (PRETTYPRINT::lengthString 
       (STRING-SPEC::|!length| s) 
       (STRING-SPEC::^ (STRING-SPEC::^ "{\\tt " s) "}"))) 
   #'ANNTERMPRINTER::latexString 
   #'ANNTERMPRINTER::ppLatexId 
   #'ANNTERMPRINTER::ppLatexId 
   #'ANNTERMPRINTER::ppLatexId 
   #'ANNTERMPRINTER::latexString 
   #'ANNTERMPRINTER::ppLatexId))
                                
(defun ANNSPECPRINTER::latexSpecToPretty-1 (spc) 
  (let ((pSpec 
         (ANNSPECPRINTER::ppSpec-1-1 
          (ANNSPECPRINTER::initialize ANNTERMPRINTER::latexPrinter nil) 
          spc))) (ANNSPECPRINTER::makeSpecListing-1 pSpec)))
                                                            
(defun PRETTYPRINT::latexBlanks (n) 
  (if ( =  n 0) 
      "" 
      (STRING-SPEC::^ 
       (STRING-SPEC::^ 
        "\\SWspace{" 
        (NAT-SPEC::toString (INTEGER-SPEC::|!*| 6 n))) 
       "}")))
             
(defun PRETTYPRINT::latexNewlineAndBlanks (n) 
  (STRING-SPEC::^ 
   (STRING-SPEC::^ "\\\\[0.3em]" (PRETTYPRINT::newlineString)) 
   (PRETTYPRINT::latexBlanks n)))
                                 
(defun PRETTYPRINT::toLatexString (text) 
  (PRETTYPRINT::toStream 
   text 
   #'(lambda (x) 
      (block 
       nil 
       (return (STRING-SPEC::^ (cdr x) (cdr (car x)))) 
       (error "Nonexhaustive match failure in toLatexString"))) 
   "" 
   #'(lambda (x) 
      (STRING-SPEC::^ (cdr x) (PRETTYPRINT::latexNewlineAndBlanks (car x))))))
                                                                              
(defun ANNSPECPRINTER::latexSpec-1 (spc) 
  (PRETTYPRINT::toLatexString 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::latexSpecToPretty-1 spc))))
                                                                          
(defun ANNSPECPRINTER::latexSpec (x0 x1 x2 x3) 
  (ANNSPECPRINTER::latexSpec-1 (vector x0 x1 x2 x3)))
                                                     
(defun PRETTYPRINT::toLatexFile (|!fileName| text) 
  (PRETTYPRINT::toFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::latexNewlineAndBlanks))
                                         
(defun ANNSPECPRINTER::latexSpecToFile (|!fileName| spc) 
  (PRETTYPRINT::toLatexFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::latexSpecToPretty-1 spc))))
                                                                          
(defun ANNSPECPRINTER::latexSpecToFile-1 (x) 
  (ANNSPECPRINTER::latexSpecToFile (car x) (cdr x)))
                                                    
(defun ANNSPECPRINTER::latexSpecToPretty (x0 x1 x2 x3) 
  (ANNSPECPRINTER::latexSpecToPretty-1 (vector x0 x1 x2 x3)))
                                                             
(defun ANNSPECPRINTER::makeSpecListing (x0 x1) 
  (ANNSPECPRINTER::makeSpecListing-1 (cons x0 x1)))
                                                   
(defun ANNSPECPRINTER::markSubterm? (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::markSubterm?-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                                 
(defun INTEGER-SPEC::|!>| (x y) (INTEGER-SPEC::|!<| y x))
                                                         
(defun ANNSPECPRINTER::positive? (n) (if (INTEGER-SPEC::|!>| n 0) 1 0))
                                                                       
(defun LIST-SPEC::rev2 (l r) 
  (block 
   nil 
   (if (null l) 
       (return r) 
       (if (consp l) (return (LIST-SPEC::rev2 (cdr l) (cons (car l) r))))) 
   (error "Nonexhaustive match failure in rev2")))
                                                  
(defun LIST-SPEC::rev (s) (LIST-SPEC::rev2 s nil))
                                                  
(defun ANNSPECPRINTER::pdfMenu-1 (spc) 
  (let ((sorts 
         (STRINGMAP::foldriDouble-1-1-1 
          #'(lambda (x) 
             (let ((id (svref x 1))
                   (qualifier (svref x 0))) 
               (LIST-SPEC::|!cons| 
                (PRETTYPRINT::prettysNone 
                 (cons 
                  (PRETTYPRINT::|!string| 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ "  \\pdfoutline goto name {" "???") 
                       ":Sort:") 
                      (if (string=  qualifier METASLANG::UnQualified) 
                          "" 
                          (STRING-SPEC::^ qualifier "."))) 
                     id) 
                    "} {")) 
                  (cons 
                   (PRETTYPRINT::|!string| 
                    (if (string=  qualifier METASLANG::UnQualified) 
                        "" 
                        (STRING-SPEC::^ qualifier "."))) 
                   (cons 
                    (PRETTYPRINT::|!string| id) 
                    (cons (PRETTYPRINT::|!string| "}") nil))))) 
                (svref x 3)))) 
          nil 
          (svref spc 3)))) 
    (let ((ops 
           (STRINGMAP::foldriDouble-1-1-1 
            #'(lambda (x) 
               (let ((id (svref x 1))
                     (qualifier (svref x 0))) 
                 (LIST-SPEC::|!cons| 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (PRETTYPRINT::|!string| 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ "  \\pdfoutline goto name {" "???") 
                         ":Op:") 
                        (if (string=  qualifier METASLANG::UnQualified) 
                            "" 
                            (STRING-SPEC::^ qualifier "."))) 
                       id) 
                      "} {")) 
                    (cons 
                     (PRETTYPRINT::|!string| 
                      (if (string=  qualifier METASLANG::UnQualified) 
                          "" 
                          (STRING-SPEC::^ qualifier "."))) 
                     (cons 
                      (PRETTYPRINT::|!string| id) 
                      (cons (PRETTYPRINT::|!string| "}") nil))))) 
                  (svref x 3)))) 
            nil 
            (svref spc 1)))) 
      (let ((pV308 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x) 
                 (let ((pV301 (cdr x))) 
                   (block 
                    nil 
                    (let ((pV306 (car pV301))) 
                      (return 
                       (cons 
                        (INTEGER-SPEC::|!+| pV306 1) 
                        (LIST-SPEC::|!cons| 
                         (PRETTYPRINT::|!string| 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              "  \\pdfoutline goto num " 
                              (NAT-SPEC::toString pV306)) 
                             "  {") 
                            (svref (car x) 1)) 
                           "}")) 
                         (cdr pV301))))) 
                    (error "Nonexhaustive match failure in pdfMenu")))) 
              (cons 1 nil) 
              (svref spc 2)))) 
        (block 
         nil 
         (return 
          (let ((properties (LIST-SPEC::rev (cdr pV308)))) 
            (let ((sortCount (LIST-SPEC::|!length| sorts))) 
              (let ((opCount (LIST-SPEC::|!length| ops))) 
                (let ((pCount (LIST-SPEC::|!length| properties))) 
                  (let ((menuCount 
                         (INTEGER-SPEC::|!+| 
                          (INTEGER-SPEC::|!+| 
                           (ANNSPECPRINTER::positive? sortCount) 
                           (ANNSPECPRINTER::positive? opCount)) 
                          (ANNSPECPRINTER::positive? pCount)))) 
                    (PRETTYPRINT::prettysAll 
                     (LIST-SPEC::|!++| 
                      (LIST-SPEC::|!++| 
                       (LIST-SPEC::|!++| 
                        (LIST-SPEC::|!++| 
                         (LIST-SPEC::|!++| 
                          (LIST-SPEC::|!++| 
                           (cons 
                            (PRETTYPRINT::|!string| 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   "\\pdfoutline goto name {Spec:" 
                                   "???") 
                                  "} count -") 
                                 (NAT-SPEC::toString menuCount)) 
                                "  {") 
                               "???") 
                              "}")) 
                            nil) 
                           (if (INTEGER-SPEC::|!>| sortCount 0) 
                               (cons 
                                (PRETTYPRINT::|!string| 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     "\\pdfoutline goto name {Spec:" 
                                     "???") 
                                    "} count -") 
                                   (NAT-SPEC::toString sortCount)) 
                                  " {Sorts}")) 
                                nil) 
                               nil)) 
                          sorts) 
                         (if (INTEGER-SPEC::|!>| opCount 0) 
                             (cons 
                              (PRETTYPRINT::|!string| 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   "\\pdfoutline goto name {Spec:" 
                                   "???") 
                                  "} count -") 
                                 (NAT-SPEC::toString opCount)) 
                                " {Ops}")) 
                              nil) 
                             nil)) 
                        ops) 
                       (if (INTEGER-SPEC::|!>| pCount 0) 
                           (cons 
                            (PRETTYPRINT::|!string| 
                             (STRING-SPEC::^ 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 "\\pdfoutline goto name {Spec:" 
                                 "???") 
                                "} count-") 
                               (NAT-SPEC::toString pCount)) 
                              " {Properties}")) 
                            nil) 
                           nil)) 
                      properties)))))))) 
         (error "Nonexhaustive match failure in pdfMenu"))))))
                                                              
(defun ANNSPECPRINTER::pdfMenu (x0 x1 x2 x3) 
  (ANNSPECPRINTER::pdfMenu-1 (vector x0 x1 x2 x3)))
                                                   
(defun ANNTERMPRINTER::pdfId-1-1 (!x1 pV1047) 
  (let ((nameSpace (cdr !x1))) 
    (block 
     nil 
     (if (eq (car pV1047) :|Qualified|) 
         (let ((pV1048 (cdr pV1047))) 
           (let ((pV1049 (car pV1048))
                 (pV1050 (cdr pV1048))) 
             (return 
              (if (string=  pV1049 METASLANG::UnQualified) 
                  (PRETTYPRINT::prettysNone 
                   (cons 
                    (PRETTYPRINT::lengthString 
                     0 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            "\\pdfannotlink goto name {" 
                            (car !x1)) 
                           ":") 
                          nameSpace) 
                         ":") 
                        pV1050) 
                       "}") 
                      (PRETTYPRINT::newlineString))) 
                    (cons 
                     (ANNTERMPRINTER::latexString pV1050) 
                     (cons (PRETTYPRINT::lengthString 0 "\\pdfendlink\\ ") nil)))) 
                  (block 
                   nil 
                   (if (string=  "Nat" pV1049) 
                       (return (ANNTERMPRINTER::latexNat pV1050)) 
                       (if (string=  "Integer" pV1049) 
                           (return (ANNTERMPRINTER::latexInt pV1050)) 
                           (if (string=  "Boolean" pV1049) 
                               (return (ANNTERMPRINTER::latexBoolean pV1050))))) 
                   (return 
                    (PRETTYPRINT::prettysNone 
                     (cons 
                      (PRETTYPRINT::lengthString 
                       0 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ "\\pdfannotlink goto name {" pV1049) 
                             ":") 
                            nameSpace) 
                           ":") 
                          pV1050) 
                         "}") 
                        (PRETTYPRINT::newlineString))) 
                      (cons 
                       (PRETTYPRINT::|!string| (STRING-SPEC::^ pV1049 ".")) 
                       (cons 
                        (ANNTERMPRINTER::latexString pV1050) 
                        (cons 
                         (PRETTYPRINT::lengthString 0 "\\pdfendlink\\ ") 
                         nil)))))))))))) 
     (error "Nonexhaustive match failure in pdfId"))))
                                                      
(defun ANNTERMPRINTER::pdfId-1 (x1) 
  #'(lambda (x2) (ANNTERMPRINTER::pdfId-1-1 x1 x2)))
                                                    
(defun ANNTERMPRINTER::pdfId (x0 x1) (ANNTERMPRINTER::pdfId-1 (cons x0 x1)))
                                                                            
(defun ANNTERMPRINTER::pdfIdDecl-1-1 (!x1 s) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::lengthString 
     0 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       (STRING-SPEC::^ 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ (STRING-SPEC::^ "\\pdfdest name {" (car !x1)) ":") 
          (cdr !x1)) 
         ":") 
        s) 
       "} fitbh%") 
      (PRETTYPRINT::newlineString))) 
    (cons (ANNTERMPRINTER::latexString s) nil))))
                                                 
(defun ANNTERMPRINTER::pdfIdDecl-1 (x1) 
  #'(lambda (x2) (ANNTERMPRINTER::pdfIdDecl-1-1 x1 x2)))
                                                        
(defun ANNTERMPRINTER::pdfIdDecl (x0 x1) 
  (ANNTERMPRINTER::pdfIdDecl-1 (cons x0 x1)))
                                             
(defun ANNTERMPRINTER::pdfPrinter (counter spc) 
  (vector 
   (PRETTYPRINT::lengthString 3 "\\ \\SWand\\ ") 
   (PRETTYPRINT::lengthString 3 " $\\rightarrow$ ") 
   (PRETTYPRINT::lengthString 6 "\\SWaxiom\\ ") 
   (PRETTYPRINT::lengthString 3 " {\\tt |} ") 
   (PRETTYPRINT::lengthString 6 "\\SWcase ") 
   (PRETTYPRINT::|!string| ", ") 
   (PRETTYPRINT::lengthString 11 "{\\bf conjecture}\\ ") 
   (PRETTYPRINT::lengthString 4 "\\SWdef ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 5 "\\SWelse ") 
   (PRETTYPRINT::|!string| "") 
   (PRETTYPRINT::lengthString 9 "{\\bf end-module}\\ ") 
   (PRETTYPRINT::lengthString 8 "\\SWendspec ") 
   (PRETTYPRINT::lengthString 3 "\\ = \\ ") 
   (PRETTYPRINT::lengthString 1 "\\SWex ") 
   (PRETTYPRINT::lengthString 1 "\\SWfa ") 
   (PRETTYPRINT::lengthString 3 "\\SWif ") 
   (PRETTYPRINT::lengthString 7 "\\SWimport ") 
   (PRETTYPRINT::lengthString 3 "\\ {\\bf in}") 
   (PRETTYPRINT::lengthString 2 "{\\bf is}\\ ") 
   (PRETTYPRINT::|!string| "[") 
   (PRETTYPRINT::lengthString 1 "$\\{$") 
   (PRETTYPRINT::|!string| "(") 
   (PRETTYPRINT::lengthString 3 "$\\lambda$ ") 
   (PRETTYPRINT::lengthString 4 "\\SWlet\\ ") 
   (PRETTYPRINT::lengthString 7 "{\\bf module}\\ ") 
   (PRETTYPRINT::lengthString 3 "\\SWof ") 
   (PRETTYPRINT::lengthString 2 "\\SWop ") 
   (PRETTYPRINT::lengthString 3 " $\\times$ ") 
   (PRETTYPRINT::|!string| "]") 
   (PRETTYPRINT::lengthString 1 "$\\}$") 
   (PRETTYPRINT::|!string| ")") 
   (PRETTYPRINT::lengthString 4 "\\SWsort ") 
   (PRETTYPRINT::lengthString 5 "\\SWspec\\ ") 
   (PRETTYPRINT::lengthString 6 " \\SWthen ") 
   (PRETTYPRINT::lengthString 8 "\\SWtheorem\\ ") 
   (PRETTYPRINT::lengthString 1 "{\\tt \\_}") 
   (PRETTYPRINT::lengthString 4 "{\\bf where} ") 
   #'ANNTERMPRINTER::latexString 
   #'PRETTYPRINT::|!string| 
   #'(lambda (s) 
      (progn (STATE::|:=| counter (INTEGER-SPEC::|!+| (STATE::|!!| counter) 1)) 
             (PRETTYPRINT::prettysNone 
              (cons 
               (PRETTYPRINT::lengthString 
                0 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   "\\pdfdest num " 
                   (NAT-SPEC::toString (STATE::|!!| counter))) 
                  " fitbh%") 
                 (PRETTYPRINT::newlineString))) 
               (cons 
                (PRETTYPRINT::lengthString 
                 (STRING-SPEC::|!length| s) 
                 (STRING-SPEC::^ (STRING-SPEC::^ "{\\tt " s) "}")) 
                nil))))) 
   (ANNTERMPRINTER::pdfIdDecl spc "Op") 
   (ANNTERMPRINTER::pdfId spc "Op") 
   (ANNTERMPRINTER::pdfId spc "Op") 
   (ANNTERMPRINTER::pdfId spc "Sort") 
   (ANNTERMPRINTER::pdfIdDecl spc "Sort") 
   (ANNTERMPRINTER::pdfId spc "Sort")))
                                       
(defun PRETTYPRINT::appendFileWithNewline (|!fileName| text newlineAndBlanks) 
  (labels 
    ((writeFun (|!stream|) 
      (PRETTYPRINT::toStream 
       text 
       #'(lambda (x) 
          (block 
           nil 
           (return (PRETTYPRINT::streamWriter |!stream| (cdr (car x)))) 
           (error "Nonexhaustive match failure in appendFileWithNewline"))) 
       nil 
       #'(lambda (x) 
          (block 
           nil 
           (return 
            (PRETTYPRINT::streamWriter 
             |!stream| 
             (funcall newlineAndBlanks (car x)))) 
           (error "Nonexhaustive match failure in appendFileWithNewline")))))) 
    (progn (IO-SPEC::withOpenFileForAppend |!fileName| #'writeFun) nil)))
                                                                         
(defun PRETTYPRINT::appendFile (|!fileName| text) 
  (PRETTYPRINT::appendFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::newlineAndBlanks))
                                    
(defun PRETTYPRINT::appendLatexFile (|!fileName| text) 
  (PRETTYPRINT::appendFileWithNewline 
   |!fileName| 
   text 
   #'PRETTYPRINT::latexNewlineAndBlanks))
                                         
(defun ANNSPECPRINTER::pdfOneSpecToFile (counter |!fileName| spc) 
  (let ((spc1 
         (ANNSPECPRINTER::ppSpec-1-1 
          (ANNSPECPRINTER::initialize 
           (ANNTERMPRINTER::pdfPrinter counter "???") 
           nil) 
          spc))) 
    (let ((menu (ANNSPECPRINTER::pdfMenu-1 spc))) 
      (progn (PRETTYPRINT::appendFile 
              |!fileName| 
              (PRETTYPRINT::|!format| 90 (PRETTYPRINT::|!string| "\\newpage"))) 
             (PRETTYPRINT::appendLatexFile 
              |!fileName| 
              (PRETTYPRINT::|!format| 
               90 
               (ANNSPECPRINTER::makeSpecListing-1 spc1))) 
             menu))))
                     
(defun ANNSPECPRINTER::pdfOneSpecToFile-1 (x) 
  (ANNSPECPRINTER::pdfOneSpecToFile (svref x 0) (svref x 1) (svref x 2)))
                                                                         
(defun ANNSPECPRINTER::pdfPostLudeToFile (|!fileName| menues) 
  (PRETTYPRINT::appendFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 
    90 
    (PRETTYPRINT::prettysAll 
     (LIST-SPEC::|!++| 
      (LIST-SPEC::|!++| 
       (cons (PRETTYPRINT::|!string| "\\pdfendthread") nil) 
       menues) 
      (cons 
       (PRETTYPRINT::|!string| "\\pdfcatalog{ /PageMode /UseOutlines }") 
       (cons (PRETTYPRINT::|!string| "\\end{document}") nil)))))))
                                                                  
(defun ANNSPECPRINTER::pdfPostLudeToFile-1 (x) 
  (ANNSPECPRINTER::pdfPostLudeToFile (car x) (cdr x)))
                                                      
(defun ANNSPECPRINTER::pdfPreludeToFile (|!fileName|) 
  (let ((sw2000 
         (let ((pV311 (SYSTEM-SPEC::getEnv "SPECWARE2000"))) 
           (block 
            nil 
            (if (eq (car pV311) :|None|) 
                (return "??SPECWARE2000??") 
                (if (eq (car pV311) :|Some|) (return (cdr pV311)))) 
            (error "Nonexhaustive match failure in pdfPreludeToFile"))))) 
    (PRETTYPRINT::toFile 
     |!fileName| 
     (PRETTYPRINT::|!format| 
      90 
      (PRETTYPRINT::prettysAll 
       (cons 
        (PRETTYPRINT::|!string| "\\documentclass{article}") 
        (cons 
         (PRETTYPRINT::|!string| 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ "\\input{" sw2000) 
           "/doc/pdf-sources/megamacros}")) 
         (cons 
          (PRETTYPRINT::|!string| "\\begin{document}") 
          (cons (PRETTYPRINT::|!string| "\\pdfthread num 1") nil)))))))))
                                                                         
(defun ANNSPECPRINTER::pdfSpecsToPretty (specs0) 
  (let ((counter (cons :|Ref| 0))) 
    (let ((specs 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (sp) 
               (ANNSPECPRINTER::ppSpec-1-1 
                (ANNSPECPRINTER::initialize 
                 (ANNTERMPRINTER::pdfPrinter counter "???") 
                 nil) 
                sp)) 
            specs0))) 
      (let ((menues (LIST-SPEC::|!map|-1-1 #'ANNSPECPRINTER::pdfMenu-1 specs0))) 
        (let ((sw2000 
               (let ((pV313 (SYSTEM-SPEC::getEnv "SPECWARE2000"))) 
                 (block 
                  nil 
                  (if (eq (car pV313) :|None|) 
                      (return "??SPECWARE2000??") 
                      (if (eq (car pV313) :|Some|) (return (cdr pV313)))) 
                  (error "Nonexhaustive match failure in pdfSpecsToPretty"))))) 
          (PRETTYPRINT::prettysAll 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (LIST-SPEC::|!++| 
               (cons 
                (PRETTYPRINT::|!string| "\\documentclass{article}") 
                (cons 
                 (PRETTYPRINT::|!string| 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ "\\input{" sw2000) 
                   "/doc/pdf-sources/megamacros}")) 
                 (cons 
                  (PRETTYPRINT::|!string| "\\begin{document}") 
                  (cons (PRETTYPRINT::|!string| "\\pdfthread num 1") nil)))) 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (s) 
                   (PRETTYPRINT::|!string| 
                    (PRETTYPRINT::toLatexString 
                     (PRETTYPRINT::|!format| 
                      90 
                      (ANNSPECPRINTER::makeSpecListing-1 s))))) 
                specs)) 
              (cons (PRETTYPRINT::|!string| "\\pdfendthread") nil)) 
             menues) 
            (cons 
             (PRETTYPRINT::|!string| "\\pdfcatalog{ /PageMode /UseOutlines }") 
             (cons (PRETTYPRINT::|!string| "\\end{document}") nil)))))))))
                                                                          
(defun ANNSPECPRINTER::pdfSpecsToFile (|!fileName| spcs) 
  (PRETTYPRINT::toFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::pdfSpecsToPretty spcs))))
                                                                        
(defun ANNSPECPRINTER::pdfSpecsToFile-1 (x) 
  (ANNSPECPRINTER::pdfSpecsToFile (car x) (cdr x)))
                                                   
(defun ANNSPECPRINTER::ppForallTyVars-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppForallTyVars-1-1 x1 x2)))
                                                             
(defun ANNSPECPRINTER::ppForallTyVars
 (x0 
  x1 
  x2 
  x3 
  x4 
  x5 
  x6 
  x7 
  x8 
  x9 
  x10 
  x11 
  x12 
  x13 
  x14 
  x15 
  x16 
  x17 
  x18 
  x19 
  x20 
  x21 
  x22 
  x23 
  x24 
  x25 
  x26 
  x27 
  x28 
  x29 
  x30 
  x31 
  x32 
  x33 
  x34 
  x35 
  x36 
  x37 
  x38 
  x39 
  x40 
  x41 
  x42 
  x43 
  x44 
  x45 
  x46) 
  (ANNSPECPRINTER::ppForallTyVars-1 
   (vector 
    x0 
    x1 
    x2 
    x3 
    x4 
    x5 
    x6 
    x7 
    x8 
    x9 
    x10 
    x11 
    x12 
    x13 
    x14 
    x15 
    x16 
    x17 
    x18 
    x19 
    x20 
    x21 
    x22 
    x23 
    x24 
    x25 
    x26 
    x27 
    x28 
    x29 
    x30 
    x31 
    x32 
    x33 
    x34 
    x35 
    x36 
    x37 
    x38 
    x39 
    x40 
    x41 
    x42 
    x43 
    x44 
    x45 
    x46)))
          
(defun ANNSPECPRINTER::ppOpDecl (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppOpDecl-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                             
(defun ANNSPECPRINTER::ppOpDecls-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppOpDecls-1-1 x1 x2)))
                                                        
(defun ANNSPECPRINTER::ppOpDecls (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppOpDecls-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                              
(defun ANNSPECPRINTER::ppPattern-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppPattern-1-1-1 x1 x2 x3))))
                                                                             
(defun ANNSPECPRINTER::ppPattern (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppPattern-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                              
(defun ANNSPECPRINTER::ppProperty (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppProperty-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                               
(defun ANNSPECPRINTER::ppSort-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppSort-1-1-1 x1 x2 x3))))
                                                                          
(defun ANNSPECPRINTER::ppSort (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSort-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                           
(defun ANNSPECPRINTER::ppSortDecl (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSortDecl-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                               
(defun ANNSPECPRINTER::ppSortDecls-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSortDecls-1-1 x1 x2)))
                                                          
(defun ANNSPECPRINTER::ppSortDecls (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSortDecls-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                                
(defun ANNSPECPRINTER::ppSortScheme-1-1-1 (context parent x) 
  (let ((pp2 (ANNSPECPRINTER::ppSort-1-1-1 context parent (cdr x)))) 
    (let ((pp1 (ANNSPECPRINTER::ppForallTyVars-1-1 (svref context 4) (car x)))) 
      (PRETTYPRINT::prettysNone (cons pp1 (cons pp2 nil))))))
                                                             
(defun ANNSPECPRINTER::ppSortScheme-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (ANNSPECPRINTER::ppSortScheme-1-1-1 x1 x2 x3))))
                                                                    
(defun ANNSPECPRINTER::ppSortScheme (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSortScheme-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                                 
(defun ANNSPECPRINTER::ppSpec-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSpec-1-1 x1 x2)))
                                                     
(defun ANNSPECPRINTER::ppSpec (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpec-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                           
(defun ANNSPECPRINTER::ppSpecAll-1-1 (context x) 
  (block 
   nil 
   (return 
    (let ((pp (svref context 4))) 
      (let ((imports 
             (LIST-SPEC::filter-1-1 
              #'(lambda (imp) 
                 (BOOLEAN-SPEC::~ (ANNSPECPRINTER::isBuiltIn?-1 imp))) 
              (svref (svref x 0) 1)))) 
        (let ((ppImports 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (x1) 
                   (cons 
                    2 
                    (PRETTYPRINT::blockFill 
                     0 
                     (cons 
                      (cons 0 (PRETTYPRINT::|!string| "import ")) 
                      (cons 
                       (cons 0 (PRETTYPRINT::|!string| (car x1))) 
                       (cons 
                        (cons 0 (PRETTYPRINT::|!string| " |-> ")) 
                        (cons 
                         (cons 
                          0 
                          (ANNSPECPRINTER::ppSpecAll-1-1 context (cdr x1))) 
                         nil))))))) 
                imports))) 
          (PRETTYPRINT::blockAll 
           0 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (LIST-SPEC::|!++| 
               (LIST-SPEC::|!++| 
                (cons 
                 (cons 
                  0 
                  (PRETTYPRINT::blockFill 
                   0 
                   (cons 
                    (cons 0 (svref pp 33)) 
                    (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
                 nil) 
                ppImports) 
               (ANNSPECPRINTER::ppSortDecls-1-1 context (svref x 3))) 
              (ANNSPECPRINTER::ppOpDecls-1-1 context (svref x 1))) 
             (LISTUTILITIES::mapWithIndex-1-1 
              (ANNSPECPRINTER::ppProperty-1 context) 
              (svref x 2))) 
            (cons 
             (cons 0 (svref pp 12)) 
             (cons (cons 0 (PRETTYPRINT::|!string| "")) nil)))))))) 
   (error "Nonexhaustive match failure in ppSpecAll")))
                                                       
(defun ANNSPECPRINTER::ppSpecAll-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSpecAll-1-1 x1 x2)))
                                                        
(defun ANNSPECPRINTER::ppSpecAll (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpecAll-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                              
(defun ANNSPECPRINTER::ppSpecHidingImportedStuff-1-1-1 (context base_spec x) 
  (let ((pV680 (svref x 1))
        (pV681 (svref x 2))
        (pV682 (svref x 3))) 
    (block 
     nil 
     (let ((pV684 (svref (svref x 0) 1))) 
       (return 
        (let ((pp (svref context 4))) 
          (let ((imported_sorts 
                 (cons 
                  (svref base_spec 3) 
                  (LIST-SPEC::|!map|-1-1 
                   #'(lambda (x1) (svref (cdr x1) 3)) 
                   pV684)))) 
            (let ((imported_ops 
                   (cons 
                    (svref base_spec 1) 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x1) (svref (cdr x1) 1)) 
                     pV684)))) 
              (let ((imported_props 
                     (cons 
                      (svref base_spec 2) 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (x1) (svref (cdr x1) 2)) 
                       pV684)))) 
                (labels 
                  ((imported_sort? (qualifier id) 
                    (LIST-SPEC::|!exists|-1-1 
                     #'(lambda (sorts) 
                        (let ((pV641 (findAQualifierMap sorts qualifier id))) 
                          (block 
                           nil 
                           (if (eq (car pV641) :|Some|) (return t)) 
                           (return nil)))) 
                     imported_sorts))) 
                  (labels 
                    ((imported_op? (qualifier id) 
                      (LIST-SPEC::|!exists|-1-1 
                       #'(lambda (ops) 
                          (let ((pV645 (findAQualifierMap ops qualifier id))) 
                            (block 
                             nil 
                             (if (eq (car pV645) :|Some|) (return t)) 
                             (return nil)))) 
                       imported_ops))) 
                    (labels 
                      ((imported_prop? (|!type| name pV647 pV648) 
                        (declare (ignore pV647 pV648)) 
                        (declare (ignore pV647 pV648)) 
                        (LIST-SPEC::|!exists|-1-1 
                         #'(lambda (imp_props) 
                            (LIST-SPEC::|!exists|-1-1 
                             #'(lambda (x1) 
                                (lisp::and 
                                 (slang-built-in::slang-term-equals 
                                  |!type| 
                                  (svref x1 0)) 
                                 (string=  name (svref x1 1)))) 
                             imp_props)) 
                         imported_props))) 
                      (PRETTYPRINT::blockAll 
                       0 
                       (LIST-SPEC::|!++| 
                        (LIST-SPEC::|!++| 
                         (LIST-SPEC::|!++| 
                          (LIST-SPEC::|!++| 
                           (LIST-SPEC::|!++| 
                            (cons 
                             (cons 
                              0 
                              (PRETTYPRINT::blockFill 
                               0 
                               (cons 
                                (cons 0 (svref pp 33)) 
                                (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
                             nil) 
                            (block 
                             nil 
                             (let ((pV670 (svref (svref base_spec 0) 1))) 
                               (return 
                                (let ((non_base_imports 
                                       (LIST-SPEC::filter-1-1 
                                        #'(lambda (x1) 
                                           (let ((imp_spec (cdr x1))) 
                                             (if (slang-built-in::slang-term-equals 
                                                  imp_spec 
                                                  base_spec) 
                                                 nil 
                                                 (LIST-SPEC::foldl-1-1-1 
                                                  #'(lambda (x11) 
                                                     (block 
                                                      nil 
                                                      (return 
                                                       (if (slang-built-in::slang-term-equals 
                                                            imp_spec 
                                                            (cdr (car x11))) 
                                                           nil 
                                                           (cdr x11))) 
                                                      (error 
                                                       "Nonexhaustive match failure in ppSpecHidingImportedStuff"))) 
                                                  t 
                                                  pV670)))) 
                                        pV684))) 
                                  (let ((pps 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x1) 
                                             (cons 
                                              1 
                                              (PRETTYPRINT::prettysFill 
                                               (cons 
                                                (svref pp 17) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| 
                                                  (car x1)) 
                                                 nil))))) 
                                          non_base_imports))) pps)))) 
                             (error 
                              "Nonexhaustive match failure in ppSpecHidingImportedStuff"))) 
                           (let ((pV673 
                                  (STRINGMAP::foldriDouble-1-1-1 
                                   #'(lambda (x1) 
                                      (let ((qualifier (svref x1 0))
                                            (id (svref x1 1))
                                            (index_and_pps (svref x1 3))) 
                                        (if (imported_sort? qualifier id) 
                                            index_and_pps 
                                            (ANNSPECPRINTER::ppSortDecl-1-1 
                                             context 
                                             (vector 
                                              qualifier 
                                              id 
                                              (svref x1 2) 
                                              index_and_pps))))) 
                                   (cons 0 nil) 
                                   pV682))) 
                             (block 
                              nil 
                              (return (cdr pV673)) 
                              (error 
                               "Nonexhaustive match failure in ppSpecHidingImportedStuff")))) 
                          (let ((pV676 
                                 (STRINGMAP::foldriDouble-1-1-1 
                                  #'(lambda (x1) 
                                     (let ((qualifier (svref x1 0))
                                           (id (svref x1 1))
                                           (index_and_pps (svref x1 3))) 
                                       (if (imported_op? qualifier id) 
                                           index_and_pps 
                                           (ANNSPECPRINTER::ppOpDecl-1-1 
                                            context 
                                            (vector 
                                             qualifier 
                                             id 
                                             (svref x1 2) 
                                             index_and_pps))))) 
                                  (cons 0 nil) 
                                  pV680))) 
                            (block 
                             nil 
                             (return (cdr pV676)) 
                             (error 
                              "Nonexhaustive match failure in ppSpecHidingImportedStuff")))) 
                         (let ((pps 
                                (LIST-SPEC::foldl-1-1-1 
                                 #'(lambda (x1) 
                                    (let ((prop (car x1))
                                          (pps (cdr x1))) 
                                      (if (imported_prop? 
                                           (svref prop 0) 
                                           (svref prop 1) 
                                           (svref prop 2) 
                                           (svref prop 3)) 
                                          pps 
                                          (cons 
                                           (ANNSPECPRINTER::ppProperty-1-1 
                                            context 
                                            (cons 0 prop)) 
                                           pps)))) 
                                 nil 
                                 pV681))) pps)) 
                        (cons 
                         (cons 0 (svref pp 12)) 
                         (cons (cons 0 (PRETTYPRINT::|!string| "")) nil))))))))))))) 
     (error "Nonexhaustive match failure in ppSpecHidingImportedStuff"))))
                                                                          
(defun ANNSPECPRINTER::ppSpecHidingImportedStuff-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (ANNSPECPRINTER::ppSpecHidingImportedStuff-1-1-1 x1 x2 x3))))


(defun ANNSPECPRINTER::ppSpecHidingImportedStuff (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpecHidingImportedStuff-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                                              
(defun ANNSPECPRINTER::ppSpecR-1-1 (context x) 
  (block 
   nil 
   (return 
    (let ((pp (svref context 4))) 
      (let ((imports 
             (LIST-SPEC::filter-1-1 
              #'(lambda (imp) 
                 (BOOLEAN-SPEC::~ (ANNSPECPRINTER::isBuiltIn?-1 imp))) 
              (svref (svref x 0) 1)))) 
        (PRETTYPRINT::blockAll 
         0 
         (LIST-SPEC::|!++| 
          (LIST-SPEC::|!++| 
           (LIST-SPEC::|!++| 
            (LIST-SPEC::|!++| 
             (LIST-SPEC::|!++| 
              (cons 
               (cons 
                0 
                (PRETTYPRINT::blockFill 
                 0 
                 (cons 
                  (cons 0 (svref pp 33)) 
                  (cons (cons 0 (PRETTYPRINT::|!string| " ")) nil)))) 
               nil) 
              (LIST-SPEC::|!map|-1-1 
               #'(lambda (x1) 
                  (cons 
                   1 
                   (PRETTYPRINT::prettysFill 
                    (cons 
                     (svref pp 17) 
                     (cons (PRETTYPRINT::|!string| (car x1)) nil))))) 
               imports)) 
             (ANNSPECPRINTER::ppSortDecls-1-1 context (svref x 3))) 
            (ANNSPECPRINTER::ppOpDecls-1-1 context (svref x 1))) 
           (LISTUTILITIES::mapWithIndex-1-1 
            (ANNSPECPRINTER::ppProperty-1 context) 
            (svref x 2))) 
          (cons 
           (cons 0 (svref pp 12)) 
           (cons (cons 0 (PRETTYPRINT::|!string| "")) nil))))))) 
   (error "Nonexhaustive match failure in ppSpecR")))
                                                     
(defun ANNSPECPRINTER::ppSpecR-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppSpecR-1-1 x1 x2)))
                                                      
(defun ANNSPECPRINTER::ppSpecR (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppSpecR-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                            
(defun ANNSPECPRINTER::ppTerm-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppTerm-1-1-1 x1 x2 x3))))
                                                                          
(defun ANNSPECPRINTER::ppTerm (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppTerm-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                           
(defun ANNSPECPRINTER::ppTerm1-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNSPECPRINTER::ppTerm1-1-1-1 x1 x2 x3))))
                                                                           
(defun ANNSPECPRINTER::ppTerm1 (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::ppTerm1-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                            
(defun ANNSPECPRINTER::ppTyVars-1 (x1) 
  #'(lambda (x2) (ANNSPECPRINTER::ppTyVars-1-1 x1 x2)))
                                                       
(defun ANNSPECPRINTER::ppTyVars
 (x0 
  x1 
  x2 
  x3 
  x4 
  x5 
  x6 
  x7 
  x8 
  x9 
  x10 
  x11 
  x12 
  x13 
  x14 
  x15 
  x16 
  x17 
  x18 
  x19 
  x20 
  x21 
  x22 
  x23 
  x24 
  x25 
  x26 
  x27 
  x28 
  x29 
  x30 
  x31 
  x32 
  x33 
  x34 
  x35 
  x36 
  x37 
  x38 
  x39 
  x40 
  x41 
  x42 
  x43 
  x44 
  x45 
  x46) 
  (ANNSPECPRINTER::ppTyVars-1 
   (vector 
    x0 
    x1 
    x2 
    x3 
    x4 
    x5 
    x6 
    x7 
    x8 
    x9 
    x10 
    x11 
    x12 
    x13 
    x14 
    x15 
    x16 
    x17 
    x18 
    x19 
    x20 
    x21 
    x22 
    x23 
    x24 
    x25 
    x26 
    x27 
    x28 
    x29 
    x30 
    x31 
    x32 
    x33 
    x34 
    x35 
    x36 
    x37 
    x38 
    x39 
    x40 
    x41 
    x42 
    x43 
    x44 
    x45 
    x46)))
          
(defun ANNSPECPRINTER::printLambda-1 (x) 
  (ANNSPECPRINTER::printLambda (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                                
(defun PRETTYPRINT::shift (id pos1 stack) 
  (LIST-SPEC::|!cons| (vector id pos1 0 nil nil) stack))
                                                        
(defun PRETTYPRINT::insertElem (pV4749 pV4750) 
  (block 
   nil 
   (return 
    (vector 
     (svref pV4750 0) 
     (svref pV4750 1) 
     (svref pV4750 2) 
     (svref pV4750 3) 
     (LIST-SPEC::|!cons| pV4749 (svref pV4750 4)))) 
   (error "Nonexhaustive match failure in insertElem")))
                                                        
(defun PRETTYPRINT::|!reduce| (pos2 stack) 
  (block 
   nil 
   (if (consp stack) 
       (let ((pV4786 (cdr stack))
             (pV4785 (car stack))) 
         (let ((pV4791 (svref pV4785 4))
               (pV4788 (svref pV4785 1))
               (pV4787 (svref pV4785 0))) 
           (if (consp pV4786) 
               (let ((pV4794 (cdr pV4786))
                     (pV4793 (car pV4786))) 
                 (return 
                  (let ((elem (vector pV4787 pV4788 pos2 t pV4791))) 
                    (block 
                     nil 
                     (return 
                      (if (BOOLEAN-SPEC::~ (svref pV4793 3)) 
                          (LIST-SPEC::|!cons| 
                           (PRETTYPRINT::insertElem elem pV4793) 
                           pV4794) 
                          (LIST-SPEC::|!cons| 
                           elem 
                           (LIST-SPEC::|!cons| pV4793 pV4794)))) 
                     (error "Nonexhaustive match failure in reduce"))))) 
               (if (null pV4786) 
                   (return (cons (vector pV4787 pV4788 pos2 t pV4791) nil))))))) 
   (return stack)))
                   
(defun PRETTYPRINT::toFileWithPathIndexing (|!fileName| text) 
  (labels 
    ((appendString (pV4804 pV4805 pV4806 pV4807) 
      (block 
       nil 
       (let ((pV4811 (svref pV4807 3))
             (pV4809 (svref pV4807 1))) 
         (return 
          (if (svref pV4807 2) 
              (if (svref pV4807 0) 
                  (vector nil pV4809 nil pV4811) 
                  (vector nil 0 nil (PRETTYPRINT::shift pV4806 pV4809 pV4811))) 
              (block 
               nil 
               (if (string=  "%(" pV4806) 
                   (return (vector nil pV4809 t pV4811)) 
                   (if (string=  "%)" pV4806) 
                       (return 
                        (vector nil 0 nil (PRETTYPRINT::|!reduce| pV4809 pV4811))) 
                       (if (string=  "%[" pV4806) 
                           (return (vector t pV4809 t pV4811))))) 
               (return 
                (progn (PRETTYPRINT::streamWriter pV4804 pV4806) 
                       (vector nil (INTEGER-SPEC::|!+| pV4809 pV4805) nil pV4811))))))) 
       (error "Nonexhaustive match failure in toFileWithPathIndexing")))) 
    (labels 
      ((writeFun (|!stream|) 
        (PRETTYPRINT::toStream 
         text 
         #'(lambda (x) 
            (let ((pV4812 (car x))) 
              (block 
               nil 
               (return 
                (appendString |!stream| (car pV4812) (cdr pV4812) (cdr x))) 
               (error "Nonexhaustive match failure in toFileWithPathIndexing")))) 
         (vector nil 0 nil nil) 
         #'(lambda (x) 
            (let ((pV4817 (cdr x))
                  (pV4816 (car x))) 
              (block 
               nil 
               (return 
                (progn (PRETTYPRINT::streamWriter 
                        |!stream| 
                        (PRETTYPRINT::newlineAndBlanks pV4816)) 
                       (vector 
                        (svref pV4817 0) 
                        (INTEGER-SPEC::|!+| 
                         (INTEGER-SPEC::|!+| (svref pV4817 1) pV4816) 
                         1) 
                        (svref pV4817 2) 
                        (svref pV4817 3)))) 
               (error "Nonexhaustive match failure in toFileWithPathIndexing"))))))) 
      (let ((pV4822 (IO-SPEC::withOpenFileForWrite |!fileName| #'writeFun))) 
        (block 
         nil 
         (return (svref pV4822 3)) 
         (error "Nonexhaustive match failure in toFileWithPathIndexing"))))))
                                                                             
(defun PRETTYPRINT::treeToString (id startPos endPos pV4901 subtrees) 
  (declare (ignore pV4901)) 
  (STRING-SPEC::^ 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       (STRING-SPEC::^ 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ (STRING-SPEC::^ "(" id) " ") 
         (NAT-SPEC::toString startPos)) 
        (PRETTYPRINT::treesToString subtrees)) 
       " ") 
      id) 
     " ") 
    (NAT-SPEC::toString endPos)) 
   ")"))
        
(defun PRETTYPRINT::treeToString-1 (x) 
  (PRETTYPRINT::treeToString 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun PRETTYPRINT::treesToString (trees) 
  (block 
   nil 
   (if (null trees) 
       (return "") 
       (if (consp trees) 
           (return 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ (PRETTYPRINT::treesToString (cdr trees)) " ") 
             (PRETTYPRINT::treeToString-1 (car trees)))))) 
   (error "Nonexhaustive match failure in treesToString")))
                                                           
(defun PRETTYPRINT::toPathFiles (|!fileName| pathFileName text) 
  (let ((trees (PRETTYPRINT::toFileWithPathIndexing |!fileName| text))) 
    (labels 
      ((writeFun (|!stream|) 
        (PRETTYPRINT::streamWriter 
         |!stream| 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           "(mspe-add-extents '(" 
           (PRETTYPRINT::treesToString trees)) 
          "))")))) 
      (progn (IO-SPEC::withOpenFileForWrite pathFileName #'writeFun) nil))))
                                                                            
(defun ANNSPECPRINTER::printMarkedSpecToFile
 (|!fileName| pathFileName indicesToDisable sosIndicesToEnable spc) 
  (let ((context 
         (ANNSPECPRINTER::initializeMark 
          ANNTERMPRINTER::asciiPrinter 
          indicesToDisable 
          sosIndicesToEnable))) 
    (let ((specToPretty (ANNSPECPRINTER::ppSpec-1 context))) 
      (progn (PRETTYPRINT::toPathFiles 
              |!fileName| 
              pathFileName 
              (PRETTYPRINT::|!format| 90 (funcall specToPretty spc))) 
             (STATE::|!!| (svref context 3))))))
                                                
(defun ANNSPECPRINTER::printMarkedSpecToFile-1 (x) 
  (ANNSPECPRINTER::printMarkedSpecToFile 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun STRINGUTILITIES::tokens-1-1 (p |!string|) 
  (let ((chars (STRING-SPEC::explode |!string|))) 
    (labels 
      ((consChars (chars strings) 
        (if (LIST-SPEC::|!null| chars) 
            strings 
            (LIST-SPEC::|!cons| 
             (STRING-SPEC::implode (LIST-SPEC::rev chars)) 
             strings)))) 
      (labels 
        ((|!loop| (chars chars_ strings) 
          (block 
           nil 
           (if (null chars) 
               (return (LIST-SPEC::rev (consChars chars_ strings))) 
               (if (consp chars) 
                   (let ((pV9402 (car chars))
                         (pV9403 (cdr chars))) 
                     (return 
                      (if (funcall p pV9402) 
                          (|!loop| pV9403 nil (consChars chars_ strings)) 
                          (|!loop| 
                           pV9403 
                           (LIST-SPEC::|!cons| pV9402 chars_) 
                           strings)))))) 
           (error "Nonexhaustive match failure in tokens")))) 
        (|!loop| chars nil nil)))))
                                   
(defun PRETTYPRINT::toStringWithPathIndexing (text) 
  (labels 
    ((appendString (pV4869 pV4870 pV4871) 
      (block 
       nil 
       (let ((pV4876 (svref pV4871 4))
             (pV4875 (svref pV4871 3))
             (pV4873 (svref pV4871 1))) 
         (return 
          (if (svref pV4871 2) 
              (if (svref pV4871 0) 
                  (let ((pV4856 
                         (STRINGUTILITIES::tokens-1-1 
                          #'(lambda (pV4851) 
                             (block 
                              nil 
                              (if (eq #\: pV4851) (return t)) 
                              (return nil))) 
                          pV4870))) 
                    (block 
                     nil 
                     (if (consp pV4856) 
                         (let ((pV4859 (cdr pV4856))) 
                           (if (consp pV4859) 
                               (let ((pV4862 (cdr pV4859))) 
                                 (if (consp pV4862) 
                                     (if (null (cdr pV4862)) 
                                         (return 
                                          (let ((enabled 
                                                 (block 
                                                  nil 
                                                  (if (string=  
                                                       "true" 
                                                       (car pV4856)) 
                                                      (return "t")) 
                                                  (return "nil")))) 
                                            (let ((sos? 
                                                   (block 
                                                    nil 
                                                    (if (string=  
                                                         "true" 
                                                         (car pV4862)) 
                                                        (return "t")) 
                                                    (return "nil")))) 
                                              (vector 
                                               nil 
                                               pV4873 
                                               nil 
                                               pV4875 
                                               (STRING-SPEC::^ 
                                                (STRING-SPEC::^ 
                                                 (STRING-SPEC::^ 
                                                  (STRING-SPEC::^ 
                                                   (STRING-SPEC::^ 
                                                    (STRING-SPEC::^ 
                                                     (STRING-SPEC::^ 
                                                      (STRING-SPEC::^ 
                                                       pV4876 
                                                       "\\\") (theorem-widget ") 
                                                      (car pV4859)) 
                                                     " ") 
                                                    enabled) 
                                                   " ") 
                                                  sos?) 
                                                 ")") 
                                                "(widget-insert \\\""))))))))))) 
                     (error 
                      "Nonexhaustive match failure in toStringWithPathIndexing"))) 
                  (vector 
                   nil 
                   0 
                   nil 
                   (PRETTYPRINT::shift pV4870 pV4873 pV4875) 
                   pV4876)) 
              (block 
               nil 
               (if (string=  "%(" pV4870) 
                   (return (vector nil pV4873 t pV4875 pV4876)) 
                   (if (string=  "%)" pV4870) 
                       (return 
                        (vector 
                         nil 
                         0 
                         nil 
                         (PRETTYPRINT::|!reduce| pV4873 pV4875) 
                         pV4876)) 
                       (if (string=  "%[" pV4870) 
                           (return 
                            (vector 
                             t 
                             (INTEGER-SPEC::|!+| pV4873 1) 
                             t 
                             pV4875 
                             pV4876))))) 
               (return 
                (vector 
                 nil 
                 (INTEGER-SPEC::|!+| pV4873 pV4869) 
                 nil 
                 pV4875 
                 (STRING-SPEC::^ 
                  pV4876 
                  (STRING-SPEC::translate-1-1 
                   #'(lambda (pV4867) 
                      (block 
                       nil 
                       (if (eq #\" pV4867) (return "\\\\\\\"")) 
                       (return (CHAR-SPEC::toString pV4867)))) 
                   pV4870)))))))) 
       (error "Nonexhaustive match failure in toStringWithPathIndexing")))) 
    (let ((pV4888 
           (PRETTYPRINT::toStream 
            text 
            #'(lambda (x) 
               (let ((pV4877 (car x))) 
                 (block 
                  nil 
                  (return (appendString (car pV4877) (cdr pV4877) (cdr x))) 
                  (error 
                   "Nonexhaustive match failure in toStringWithPathIndexing")))) 
            (vector nil 0 nil nil "") 
            #'(lambda (x) 
               (let ((pV4882 (cdr x))
                     (pV4881 (car x))) 
                 (block 
                  nil 
                  (return 
                   (vector 
                    (svref pV4882 0) 
                    (INTEGER-SPEC::|!+| 
                     (INTEGER-SPEC::|!+| (svref pV4882 1) pV4881) 
                     1) 
                    (svref pV4882 2) 
                    (svref pV4882 3) 
                    (STRING-SPEC::^ 
                     (svref pV4882 4) 
                     (PRETTYPRINT::newlineAndBlanks pV4881)))) 
                  (error 
                   "Nonexhaustive match failure in toStringWithPathIndexing"))))))) 
      (block 
       nil 
       (return 
        (let ((tree 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 "(mspe-add-extents '(" 
                 (PRETTYPRINT::treesToString (svref pV4888 3))) 
                "))"))) 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              "(insert-mouse-sensitive-spec \"(progn (let ((pt (point))) (widget-insert \\\"" 
              (svref pV4888 4)) 
             " \\\") (goto-char pt)) ") 
            tree) 
           ")\")"))) 
       (error "Nonexhaustive match failure in toStringWithPathIndexing")))))
                                                                            
(defun ANNSPECPRINTER::printMarkedSpecToString
 (indicesToDisable sosIndicesToEnable spc) 
  (let ((context 
         (ANNSPECPRINTER::initializeMark 
          ANNTERMPRINTER::asciiPrinter 
          indicesToDisable 
          sosIndicesToEnable))) 
    (let ((specToPretty (ANNSPECPRINTER::ppSpec-1 context))) 
      (let ((spcAndMarking 
             (PRETTYPRINT::toStringWithPathIndexing 
              (PRETTYPRINT::|!format| 90 (funcall specToPretty spc))))) 
        (cons spcAndMarking (STATE::|!!| (svref context 3)))))))
                                                                
(defun ANNSPECPRINTER::printMarkedSpecToString-1 (x) 
  (ANNSPECPRINTER::printMarkedSpecToString (svref x 0) (svref x 1) (svref x 2)))
                                                                                
(defun ANNSPECPRINTER::printOp-1 (x) 
  (ANNSPECPRINTER::printOp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun ANNSPECPRINTER::printPattern (pat) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppPattern-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil t) 
     pat))))
            
(defun ANNSPECPRINTER::printSort? (x0 x1 x2 x3 x4 x5 x6) 
  (ANNSPECPRINTER::printSort?-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                               
(defun ANNSPECPRINTER::printSortScheme-1 (scheme) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSortScheme-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     scheme))))
               
(defun ANNSPECPRINTER::printSortScheme (x0 x1) 
  (ANNSPECPRINTER::printSortScheme-1 (cons x0 x1)))
                                                   
(defun PRETTYPRINT::toTerminal (text) 
  (PRETTYPRINT::toStream 
   text 
   #'(lambda (x) 
      (block 
       nil 
       (return (STRING-SPEC::toScreen (cdr (car x)))) 
       (error "Nonexhaustive match failure in toTerminal"))) 
   nil 
   #'(lambda (x) 
      (block 
       nil 
       (return (STRING-SPEC::toScreen (PRETTYPRINT::newlineAndBlanks (car x)))) 
       (error "Nonexhaustive match failure in toTerminal")))))
                                                              
(defun ANNSPECPRINTER::printSortToTerminal (srt) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSort-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     srt))))
            
(defun ANNSPECPRINTER::specToPretty-1 (spc) 
  (ANNSPECPRINTER::ppSpecR-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   spc))
        
(defun ANNSPECPRINTER::printSpec-1 (spc) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 80 (ANNSPECPRINTER::specToPretty-1 spc))))
                                                                     
(defun ANNSPECPRINTER::printSpec (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpec-1 (vector x0 x1 x2 x3)))
                                                     
(defun ANNSPECPRINTER::printSpecToFile (|!fileName| spc) 
  (PRETTYPRINT::toFile 
   |!fileName| 
   (PRETTYPRINT::|!format| 90 (ANNSPECPRINTER::specToPretty-1 spc))))
                                                                     
(defun ANNSPECPRINTER::printSpecToFile-1 (x) 
  (ANNSPECPRINTER::printSpecToFile (car x) (cdr x)))
                                                    
(defun ANNSPECPRINTER::printSpecToTerminal-1 (spc) 
  (progn (PRETTYPRINT::toTerminal 
          (PRETTYPRINT::|!format| 80 (ANNSPECPRINTER::specToPretty-1 spc))) 
         (STRING-SPEC::writeLine "")))
                                      
(defun ANNSPECPRINTER::printSpecToTerminal (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpecToTerminal-1 (vector x0 x1 x2 x3)))
                                                               
(defun ANNSPECPRINTER::specToPrettyVerbose-1 (spc) 
  (ANNSPECPRINTER::ppSpecAll-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   spc))
        
(defun ANNSPECPRINTER::printSpecVerbose-1 (spc) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 80 (ANNSPECPRINTER::specToPrettyVerbose-1 spc))))
                                                                            
(defun ANNSPECPRINTER::printSpecVerbose (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpecVerbose-1 (vector x0 x1 x2 x3)))
                                                            
(defun ANNSPECPRINTER::printSpecWithSortsToTerminal-1 (spc) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSpec-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter t) 
     spc))))
            
(defun ANNSPECPRINTER::printSpecWithSortsToTerminal (x0 x1 x2 x3) 
  (ANNSPECPRINTER::printSpecWithSortsToTerminal-1 (vector x0 x1 x2 x3)))
                                                                        
(defun ANNSPECPRINTER::printTerm (term) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppTerm-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     term))))
             
(defun ANNSPECPRINTER::printTermToTerminal (term) 
  (PRETTYPRINT::toTerminal 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppTerm-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     (cons nil '(:|Top|)) 
     term))))
             
(defun ANNSPECPRINTER::printTermWithSorts (term) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppTerm-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter t) 
     (cons nil '(:|Top|)) 
     term))))
             
(defun ANNSPECPRINTER::specToPretty (x0 x1 x2 x3) 
  (ANNSPECPRINTER::specToPretty-1 (vector x0 x1 x2 x3)))
                                                        
(defun ANNSPECPRINTER::specToPrettyR-1 (spc) 
  (ANNSPECPRINTER::ppSpecR-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   spc))
        
(defun ANNSPECPRINTER::specToPrettyR (x0 x1 x2 x3) 
  (ANNSPECPRINTER::specToPrettyR-1 (vector x0 x1 x2 x3)))
                                                         
(defun ANNSPECPRINTER::specToPrettyVerbose (x0 x1 x2 x3) 
  (ANNSPECPRINTER::specToPrettyVerbose-1 (vector x0 x1 x2 x3)))
                                                               
(defun ANNSPECPRINTER::termToPretty (term) 
  (ANNSPECPRINTER::ppTerm-1-1-1 
   (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
   (cons nil '(:|Top|)) 
   term))
         
(defun ANNSPECPRINTER::toString (x) (PRETTYPRINT::toString x))
                                                              
(defun ANNTERMPRINTER::htmlPrinter-1 (ignore) 
  (declare (ignore ignore)) 
  (ANNTERMPRINTER::htmlPrinter))
                                
(defun ANNTERMPRINTER::pdfPrinter-1 (x) 
  (ANNTERMPRINTER::pdfPrinter (car x) (cdr x)))
                                               
(defun ANNTERMPRINTER::ppList (x1) 
  #'(lambda (x2) #'(lambda (x3) (ANNTERMPRINTER::ppList-1-1-1 x1 x2 x3))))
                                                                          
(defun ANNTERMPRINTER::ppListPath (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) (ANNTERMPRINTER::ppListPath-1-1-1-1 x1 x2 x3 x4)))))
                                                                           
(defun SPLAYSET::insert-1-1 (comp x) 
  (let ((pV9049 (car x))
        (pV9050 (cdr x))) 
    (block 
     nil 
     (let ((pV9051 (car pV9050))) 
       (return 
        (let ((x1 (SPLAYTREE::splay (SPLAYSET::compf comp pV9049) (cdr pV9050)))) 
          (let ((pV9035 (car x1))
                (pV9036 (cdr x1))) 
            (block 
             nil 
             (if (eq (car pV9035) :|Equal|) 
                 (if (eq (car pV9036) :|SplayObj|) 
                     (let ((pV9045 (cdr pV9036))) 
                       (return 
                        (cons 
                         pV9051 
                         (cons 
                          :|SplayObj| 
                          (vector (svref pV9045 0) (svref pV9045 1) pV9049)))))) 
                 (if (eq (car pV9035) :|Less|) 
                     (if (eq (car pV9036) :|SplayObj|) 
                         (let ((pV9041 (cdr pV9036))) 
                           (return 
                            (cons 
                             (INTEGER-SPEC::|!+| pV9051 1) 
                             (cons 
                              :|SplayObj| 
                              (vector 
                               (cons 
                                :|SplayObj| 
                                (vector 
                                 (svref pV9041 0) 
                                 '(:|SplayNil|) 
                                 (svref pV9041 2))) 
                               (svref pV9041 1) 
                               pV9049)))))) 
                     (if (eq (car pV9035) :|Greater|) 
                         (if (eq (car pV9036) :|SplayObj|) 
                             (let ((pV9037 (cdr pV9036))) 
                               (return 
                                (cons 
                                 (INTEGER-SPEC::|!+| pV9051 1) 
                                 (cons 
                                  :|SplayObj| 
                                  (vector 
                                   (svref pV9037 0) 
                                   (cons 
                                    :|SplayObj| 
                                    (vector 
                                     '(:|SplayNil|) 
                                     (svref pV9037 1) 
                                     (svref pV9037 2))) 
                                   pV9049))))))))) 
             (if (eq (car pV9036) :|SplayNil|) 
                 (return 
                  (cons 
                   1 
                   (cons 
                    :|SplayObj| 
                    (vector '(:|SplayNil|) '(:|SplayNil|) pV9049))))) 
             (error "Nonexhaustive match failure in insert")))))) 
     (error "Nonexhaustive match failure in insert"))))
                                                       
(defun SPLAYSET::singleton (comp v) 
  (cons 
   :|SET| 
   (vector 
    comp 
    1 
    (cons :|Ref| (cons :|SplayObj| (vector '(:|SplayNil|) '(:|SplayNil|) v))))))
                                                                                
(defun SPLAYSET::add (|!set| v) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return (SPLAYSET::singleton (cdr |!set|) v)) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV8818 (cdr |!set|))) 
             (let ((pV8820 (svref pV8818 0))) 
               (return 
                (let ((pV8814 
                       (SPLAYSET::insert-1-1 
                        pV8820 
                        (cons 
                         v 
                         (cons (svref pV8818 1) (STATE::|!!| (svref pV8818 2))))))) 
                  (block 
                   nil 
                   (return 
                    (cons 
                     :|SET| 
                     (vector pV8820 (car pV8814) (cons :|Ref| (cdr pV8814))))) 
                   (error "Nonexhaustive match failure in add")))))))) 
   (error "Nonexhaustive match failure in add")))
                                                 
(defun STRINGSET::add (x0 x) (SPLAYSET::add x0 x))
                                                  
(defun STRINGSET::|!member| (x0 x) (SPLAYSET::|!member| x0 x))
                                                              
(defun STRINGUTILITIES::freshName (name0 names) 
  (labels 
    ((|!loop| (counter name) 
      (if (STRINGSET::|!member| names name) 
          (|!loop| 
           (INTEGER-SPEC::|!+| counter 1) 
           (STRING-SPEC::^ name0 (NAT-SPEC::toString counter))) 
          name))) (|!loop| 0 name0)))
                                     
(defun ARITYNORMALIZE::freshName (name0 names) 
  (let ((name1 (STRINGUTILITIES::freshName name0 names))) 
    (cons name1 (STRINGSET::add names name1))))
                                               
(defun ARITYNORMALIZE::freshNames (name0 xs names) 
  (let ((pV1115 
         (LIST-SPEC::foldr-1-1-1 
          #'(lambda (x) 
             (let ((pV1112 (cdr x))) 
               (block 
                nil 
                (return 
                 (let ((pV1108 (ARITYNORMALIZE::freshName name0 (cdr pV1112)))) 
                   (block 
                    nil 
                    (return 
                     (cons 
                      (LIST-SPEC::|!cons| (car pV1108) (car pV1112)) 
                      (cdr pV1108))) 
                    (error "Nonexhaustive match failure in freshNames")))) 
                (error "Nonexhaustive match failure in freshNames")))) 
          (cons nil names) 
          xs))) 
    (block 
     nil 
     (return (cons (car pV1115) (cdr pV1115))) 
     (error "Nonexhaustive match failure in freshNames"))))
                                                           
(defun LISTPAIR::|!map|-1-1 (f x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (cons 
               (funcall f (cons (car l) (car r))) 
               (LISTPAIR::|!map|-1-1 f (cons (cdr l) (cdr r))))))) 
     (return nil))))
                    
(defparameter POSITION-SPEC::noPos (cons :|Internal| "no position"))
                                                                    
(defun LISTPAIR::zip (l r) 
  (block 
   nil 
   (if (consp l) 
       (if (consp r) 
           (return (cons (cons (car l) (car r)) (LISTPAIR::zip (cdr l) (cdr r)))))) 
   (return nil)))
                 
(defun SPECENVIRONMENT::substSort (|!S| srt) 
  (labels 
    ((|!find| (name |!S| a) 
      (block 
       nil 
       (if (null |!S|) 
           (return (cons :|TyVar| (cons name a))) 
           (if (consp |!S|) 
               (let ((pV7208 (car |!S|))) 
                 (return 
                  (if (string=  name (car pV7208)) 
                      (cdr pV7208) 
                      (|!find| name (cdr |!S|) a)))))) 
       (error "Nonexhaustive match failure in substSort")))) 
    (labels 
      ((substRec (srt) 
        (block 
         nil 
         (if (eq (car srt) :|Base|) 
             (let ((pV7221 (cdr srt))) 
               (return 
                (cons 
                 :|Base| 
                 (vector 
                  (svref pV7221 0) 
                  (LIST-SPEC::|!map|-1-1 #'substRec (svref pV7221 1)) 
                  (svref pV7221 2))))) 
             (if (eq (car srt) :|Arrow|) 
                 (let ((pV7220 (cdr srt))) 
                   (return 
                    (cons 
                     :|Arrow| 
                     (vector 
                      (substRec (svref pV7220 0)) 
                      (substRec (svref pV7220 1)) 
                      (svref pV7220 2))))) 
                 (if (eq (car srt) :|Product|) 
                     (let ((pV7219 (cdr srt))) 
                       (return 
                        (cons 
                         :|Product| 
                         (cons 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x) (cons (car x) (substRec (cdr x)))) 
                           (car pV7219)) 
                          (cdr pV7219))))) 
                     (if (eq (car srt) :|CoProduct|) 
                         (let ((pV7218 (cdr srt))) 
                           (return 
                            (cons 
                             :|CoProduct| 
                             (cons 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x) 
                                  (let ((sopt (cdr x))) 
                                    (cons 
                                     (car x) 
                                     (block 
                                      nil 
                                      (if (eq (car sopt) :|None|) 
                                          (return '(:|None|)) 
                                          (if (eq (car sopt) :|Some|) 
                                              (return 
                                               (cons 
                                                :|Some| 
                                                (substRec (cdr sopt)))))) 
                                      (error 
                                       "Nonexhaustive match failure in substSort"))))) 
                               (car pV7218)) 
                              (cdr pV7218))))) 
                         (if (eq (car srt) :|Quotient|) 
                             (let ((pV7217 (cdr srt))) 
                               (return 
                                (cons 
                                 :|Quotient| 
                                 (vector 
                                  (substRec (svref pV7217 0)) 
                                  (svref pV7217 1) 
                                  (svref pV7217 2))))) 
                             (if (eq (car srt) :|Subsort|) 
                                 (let ((pV7216 (cdr srt))) 
                                   (return 
                                    (cons 
                                     :|Subsort| 
                                     (vector 
                                      (substRec (svref pV7216 0)) 
                                      (svref pV7216 1) 
                                      (svref pV7216 2))))) 
                                 (if (eq (car srt) :|TyVar|) 
                                     (let ((pV7215 (cdr srt))) 
                                       (return 
                                        (|!find| (car pV7215) |!S| (cdr pV7215))))))))))) 
         (error "Nonexhaustive match failure in substSort")))) (substRec srt))))
                                                                                
(defun STANDARDSPEC::findTheSort (pV9318 pV9319) 
  (block 
   nil 
   (if (eq (car pV9319) :|Qualified|) 
       (let ((pV9320 (cdr pV9319))) 
         (return (findAQualifierMap (svref pV9318 3) (car pV9320) (cdr pV9320))))) 
   (error "Nonexhaustive match failure in findTheSort")))
                                                         
(defun SPECENVIRONMENT::unfoldBaseV (sp srt verbose) 
  (block 
   nil 
   (if (eq (car srt) :|Base|) 
       (let ((pV7316 (cdr srt))) 
         (return 
          (let ((pV7308 (STANDARDSPEC::findTheSort sp (svref pV7316 0)))) 
            (block 
             nil 
             (if (eq (car pV7308) :|None|) 
                 (return srt) 
                 (if (eq (car pV7308) :|Some|) 
                     (let ((pV7309 (cdr pV7308))) 
                       (let ((pV7312 (svref pV7309 2))) 
                         (if (eq (car pV7312) :|None|) 
                             (return srt) 
                             (if (eq (car pV7312) :|Some|) 
                                 (return 
                                  (let ((ssrt 
                                         (SPECENVIRONMENT::substSort 
                                          (LISTPAIR::zip 
                                           (svref pV7309 1) 
                                           (svref pV7316 1)) 
                                          (cdr pV7312)))) 
                                    (SPECENVIRONMENT::unfoldBaseV 
                                     sp 
                                     ssrt 
                                     verbose))))))))) 
             (error "Nonexhaustive match failure in unfoldBaseV")))))) 
   (return srt)))
                 
(defun SPECENVIRONMENT::unfoldBase (sp srt) 
  (SPECENVIRONMENT::unfoldBaseV sp srt t))
                                          
(defun SPECENVIRONMENT::stripSubsorts (sp srt) 
  (let ((pV7201 (SPECENVIRONMENT::unfoldBase sp srt))) 
    (block 
     nil 
     (if (eq (car pV7201) :|Subsort|) 
         (return (SPECENVIRONMENT::stripSubsorts sp (svref (cdr pV7201) 0)))) 
     (return pV7201))))
                       
(defun SPECENVIRONMENT::arrowOpt (sp srt) 
  (let ((pV7058 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7058) :|Arrow|) 
         (let ((pV7059 (cdr pV7058))) 
           (return (cons :|Some| (cons (svref pV7059 0) (svref pV7059 1)))))) 
     (return '(:|None|)))))
                           
(defun SPECENVIRONMENT::productOpt (sp srt) 
  (let ((pV7186 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7186) :|Product|) (return (cons :|Some| (car (cdr pV7186))))) 
     (return '(:|None|)))))
                           
(defun STANDARDSPEC::mkBase (qid srts) 
  (cons :|Base| (vector qid srts POSITION-SPEC::noPos)))
                                                        
(defparameter STANDARDSPEC::boolSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Boolean" "Boolean")) nil))
                                                                            
(defun STANDARDSPEC::mkFun (constant srt) 
  (cons :|Fun| (vector constant srt POSITION-SPEC::noPos)))
                                                           
(defun STANDARDSPEC::mkTrue () 
  (STANDARDSPEC::mkFun (cons :|Bool| t) STANDARDSPEC::boolSort))
                                                                
(defun ARITYNORMALIZE::etaExpand (sp usedNames srt term) 
  (let ((pV1103 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV1103) :|None|) 
         (return term) 
         (if (eq (car pV1103) :|Some|) 
             (let ((pV1105 (car (cdr pV1103)))) 
               (return 
                (let ((pV1101 (SPECENVIRONMENT::productOpt sp pV1105))) 
                  (block 
                   nil 
                   (if (eq (car pV1101) :|None|) 
                       (return 
                        (block 
                         nil 
                         (if (eq (car term) :|Lambda|) (return term)) 
                         (return 
                          (let ((pV1077 
                                 (ARITYNORMALIZE::freshName "x" usedNames))) 
                            (block 
                             nil 
                             (return 
                              (let ((x (cons (car pV1077) pV1105))) 
                                (cons 
                                 :|Lambda| 
                                 (cons 
                                  (cons 
                                   (vector 
                                    (cons 
                                     :|VarPat| 
                                     (cons x POSITION-SPEC::noPos)) 
                                    (STANDARDSPEC::mkTrue) 
                                    (cons 
                                     :|Apply| 
                                     (vector 
                                      term 
                                      (cons :|Var| (cons x POSITION-SPEC::noPos)) 
                                      POSITION-SPEC::noPos))) 
                                   nil) 
                                  POSITION-SPEC::noPos)))) 
                             (error "Nonexhaustive match failure in etaExpand")))))) 
                       (if (eq (car pV1101) :|Some|) 
                           (let ((pV1102 (cdr pV1101))) 
                             (return 
                              (block 
                               nil 
                               (if (eq (car term) :|Lambda|) 
                                   (let ((pV1096 (car (cdr term)))) 
                                     (if (consp pV1096) 
                                         (if (null (cdr pV1096)) (return term))))) 
                               (return 
                                (let ((pV1091 
                                       (ARITYNORMALIZE::freshNames 
                                        "x" 
                                        pV1102 
                                        usedNames))) 
                                  (block 
                                   nil 
                                   (return 
                                    (let ((vars 
                                           (LISTPAIR::|!map|-1-1 
                                            #'(lambda (x) 
                                               (let ((pV1088 (cdr x))) 
                                                 (block 
                                                  nil 
                                                  (return 
                                                   (cons 
                                                    (car pV1088) 
                                                    (cons (car x) (cdr pV1088)))) 
                                                  (error 
                                                   "Nonexhaustive match failure in etaExpand")))) 
                                            (cons (car pV1091) pV1102)))) 
                                      (let ((trm 
                                             (cons 
                                              :|Lambda| 
                                              (cons 
                                               (cons 
                                                (vector 
                                                 (cons 
                                                  :|RecordPat| 
                                                  (cons 
                                                   (LIST-SPEC::|!map|-1-1 
                                                    #'(lambda (x) 
                                                       (cons 
                                                        (car x) 
                                                        (cons 
                                                         :|VarPat| 
                                                         (cons 
                                                          (cdr x) 
                                                          POSITION-SPEC::noPos)))) 
                                                    vars) 
                                                   POSITION-SPEC::noPos)) 
                                                 (STANDARDSPEC::mkTrue) 
                                                 (cons 
                                                  :|Apply| 
                                                  (vector 
                                                   term 
                                                   (cons 
                                                    :|Record| 
                                                    (cons 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (cons 
                                                          (car x) 
                                                          (cons 
                                                           :|Var| 
                                                           (cons 
                                                            (cdr x) 
                                                            POSITION-SPEC::noPos)))) 
                                                      vars) 
                                                     POSITION-SPEC::noPos)) 
                                                   POSITION-SPEC::noPos))) 
                                                nil) 
                                               POSITION-SPEC::noPos)))) trm))) 
                                   (error 
                                    "Nonexhaustive match failure in etaExpand"))))))))) 
                   (error "Nonexhaustive match failure in etaExpand"))))))) 
     (error "Nonexhaustive match failure in etaExpand"))))
                                                          
(defun ARITYNORMALIZE::insertPattern (pV1134 pV1135) 
  (block 
   nil 
   (return 
    (block 
     nil 
     (if (eq (car pV1134) :|VarPat|) 
         (let ((pV1132 (car (car (cdr pV1134))))) 
           (return 
            (cons 
             (STRINGSET::add (car pV1135) pV1132) 
             (LIST-SPEC::|!cons| (cons pV1132 '(:|None|)) (cdr pV1135))))) 
         (if (eq (car pV1134) :|RecordPat|) 
             (return 
              (LIST-SPEC::foldr-1-1-1 
               #'(lambda (x) 
                  (block 
                   nil 
                   (return (ARITYNORMALIZE::insertPattern (cdr (car x)) (cdr x))) 
                   (error "Nonexhaustive match failure in insertPattern"))) 
               pV1135 
               (car (cdr pV1134)))))) 
     (error "Nonexhaustive match failure in insertPattern"))) 
   (error "Nonexhaustive match failure in insertPattern")))
                                                           
(defun STANDARDSPEC::mkApply (t1 t2) 
  (cons :|Apply| (vector t1 t2 POSITION-SPEC::noPos)))
                                                      
(defun STANDARDSPEC::mkArrow (s1 s2) 
  (cons :|Arrow| (vector s1 s2 POSITION-SPEC::noPos)))
                                                      
(defun STANDARDSPEC::mkLet (decls term) 
  (cons :|Let| (vector decls term POSITION-SPEC::noPos)))
                                                         
(defun STANDARDSPEC::mkRecord (fields) 
  (cons :|Record| (cons fields POSITION-SPEC::noPos)))
                                                      
(defun STANDARDSPEC::mkSubsort (srt pred) 
  (cons :|Subsort| (vector srt pred POSITION-SPEC::noPos)))
                                                           
(defun STANDARDSPEC::mkRelax (srt pred) 
  (STANDARDSPEC::mkFun 
   '(:|Relax|) 
   (STANDARDSPEC::mkArrow (STANDARDSPEC::mkSubsort srt pred) srt)))
                                                                   
(defun METASLANG::termSort (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (return 
        (let ((pV3544 (METASLANG::termSort (svref (cdr term) 0)))) 
          (block 
           nil 
           (if (eq (car pV3544) :|Arrow|) (return (svref (cdr pV3544) 1))) 
           (return 
            (SYSTEM-SPEC::fail 
             (STRING-SPEC::^ 
              "Cannot extract sort of application " 
              (SYSTEM-SPEC::toString term))))))) 
       (if (eq (car term) :|ApplyN|) 
           (let ((pV3626 (car (cdr term)))) 
             (if (consp pV3626) 
                 (let ((pV3630 (cdr pV3626))) 
                   (if (consp pV3630) 
                       (if (null (cdr pV3630)) 
                           (return 
                            (let ((pV3552 (METASLANG::termSort (car pV3626)))) 
                              (block 
                               nil 
                               (if (eq (car pV3552) :|Arrow|) 
                                   (return (svref (cdr pV3552) 1))) 
                               (return 
                                (SYSTEM-SPEC::fail 
                                 (STRING-SPEC::^ 
                                  "Cannot extract sort of application " 
                                  (SYSTEM-SPEC::toString term)))))))))))) 
           (if (eq (car term) :|Bind|) 
               (return 
                (METASLANG::mkABase 
                 (cons :|Qualified| (cons "Boolean" "Boolean")) 
                 nil 
                 (svref (cdr term) 3))) 
               (if (eq (car term) :|Record|) 
                   (let ((pV3586 (cdr term))) 
                     (return 
                      (cons 
                       :|Product| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons (car x) (METASLANG::termSort (cdr x)))) 
                         (car pV3586)) 
                        (cdr pV3586))))) 
                   (if (eq (car term) :|Let|) 
                       (return (METASLANG::termSort (svref (cdr term) 1))) 
                       (if (eq (car term) :|LetRec|) 
                           (return (METASLANG::termSort (svref (cdr term) 1))) 
                           (if (eq (car term) :|Var|) 
                               (return (cdr (car (cdr term)))) 
                               (if (eq (car term) :|Fun|) 
                                   (return (svref (cdr term) 1)) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (return 
                                        (METASLANG::termSort 
                                         (svref (cdr term) 1))) 
                                       (if (eq (car term) :|Seq|) 
                                           (return 
                                            (cons 
                                             :|Product| 
                                             (cons nil (cdr (cdr term))))) 
                                           (if (eq (car term) :|SortedTerm|) 
                                               (return (svref (cdr term) 1)) 
                                               (if (eq (car term) :|Lambda|) 
                                                   (let ((pV3578 (cdr term))) 
                                                     (let ((pV3590 (car pV3578))) 
                                                       (if (consp pV3590) 
                                                           (let ((pV3593 
                                                                  (car pV3590))) 
                                                             (return 
                                                              (cons 
                                                               :|Arrow| 
                                                               (vector 
                                                                (METASLANG::patternSort 
                                                                 (svref pV3593 0)) 
                                                                (METASLANG::termSort 
                                                                 (svref pV3593 2)) 
                                                                (cdr pV3578))))) 
                                                           (if (null pV3590) 
                                                               (return 
                                                                (SYSTEM-SPEC::fail 
                                                                 "Ill formed lambda abstraction")))))))))))))))))) 
   (return (SYSTEM-SPEC::fail "Non-exhaustive match in termSort"))))
                                                                    
(defun STANDARDSPEC::mkRestrict (srt pred) 
  (STANDARDSPEC::mkFun 
   '(:|Restrict|) 
   (STANDARDSPEC::mkArrow srt (STANDARDSPEC::mkSubsort srt pred))))
                                                                   
(defun STANDARDSPEC::mkRestriction (pred term) 
  (let ((srt (METASLANG::termSort term))) 
    (STANDARDSPEC::mkApply (STANDARDSPEC::mkRestrict srt pred) term)))
                                                                      
(defun STANDARDSPEC::mkVar-1 (v) (cons :|Var| (cons v POSITION-SPEC::noPos)))
                                                                             
(defun STANDARDSPEC::mkVar (x0 x1) (STANDARDSPEC::mkVar-1 (cons x0 x1)))
                                                                        
(defun STANDARDSPEC::mkVarPat-1 (v) 
  (cons :|VarPat| (cons v POSITION-SPEC::noPos)))
                                                 
(defun STANDARDSPEC::mkVarPat (x0 x1) (STANDARDSPEC::mkVarPat-1 (cons x0 x1)))
                                                                              
(defun ARITYNORMALIZE::mkArityApply (sp dom t1 t2 usedNames) 
  (labels 
    ((unfoldArgument (dom t2) 
      (let ((pV1204 (SPECENVIRONMENT::unfoldBase sp dom))) 
        (block 
         nil 
         (if (eq (car pV1204) :|Subsort|) 
             (let ((pV1206 (cdr pV1204))) 
               (let ((pV1210 (svref pV1206 1))
                     (pV1209 (svref pV1206 0))) 
                 (return 
                  (let ((relaxOp (STANDARDSPEC::mkRelax pV1209 pV1210))) 
                    (let ((t2 (STANDARDSPEC::mkApply relaxOp t2))) 
                      (let ((pV1184 (unfoldArgument pV1209 t2))) 
                        (block 
                         nil 
                         (return 
                          (let ((t2 
                                 (STANDARDSPEC::mkRestriction 
                                  pV1210 
                                  (car pV1184)))) (cons t2 (cdr pV1184)))) 
                         (error "Nonexhaustive match failure in mkArityApply")))))))) 
             (if (eq (car pV1204) :|Product|) 
                 (return 
                  (let ((pV1200 
                         (LIST-SPEC::foldr-1-1-1 
                          #'(lambda (x) 
                             (let ((pV1192 (cdr x))
                                   (pV1191 (car x))) 
                               (block 
                                nil 
                                (let ((pV1193 (car pV1191))) 
                                  (return 
                                   (let ((pV1188 
                                          (ARITYNORMALIZE::freshName 
                                           (STRING-SPEC::^ "v" pV1193) 
                                           (cdr pV1192)))) 
                                     (block 
                                      nil 
                                      (return 
                                       (cons 
                                        (LIST-SPEC::|!cons| 
                                         (vector 
                                          (car pV1188) 
                                          pV1193 
                                          (cdr pV1191)) 
                                         (car pV1192)) 
                                        (cdr pV1188))) 
                                      (error 
                                       "Nonexhaustive match failure in mkArityApply"))))) 
                                (error 
                                 "Nonexhaustive match failure in mkArityApply")))) 
                          (cons nil usedNames) 
                          (car (cdr pV1204))))) 
                    (block 
                     nil 
                     (return 
                      (let ((pV1197 (ARITYNORMALIZE::freshName "x" (cdr pV1200)))) 
                        (block 
                         nil 
                         (let ((pV1198 (car pV1197))) 
                           (return 
                            (let ((decl 
                                   (cons (STANDARDSPEC::mkVarPat pV1198 dom) t2))) 
                              (let ((v (STANDARDSPEC::mkVar pV1198 dom))) 
                                (let ((fields 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'(lambda (x0) 
                                           (let ((label (svref x0 1))) 
                                             (let ((trm 
                                                    (STANDARDSPEC::mkApply 
                                                     (cons 
                                                      :|Fun| 
                                                      (vector 
                                                       (cons :|Project| label) 
                                                       (STANDARDSPEC::mkArrow 
                                                        dom 
                                                        (svref x0 2)) 
                                                       POSITION-SPEC::noPos)) 
                                                     v))) (cons label trm)))) 
                                        (car pV1200)))) 
                                  (cons 
                                   (STANDARDSPEC::mkRecord fields) 
                                   (cons decl nil))))))) 
                         (error "Nonexhaustive match failure in mkArityApply")))) 
                     (error "Nonexhaustive match failure in mkArityApply")))))) 
         (return 
          (progn (STRING-SPEC::toScreen 
                  "Unexpected non-record argument to function ") 
                 (STRING-SPEC::toScreen 
                  (STRING-SPEC::^ (ANNSPECPRINTER::printTerm t2) " :  ")) 
                 (STRING-SPEC::writeLine (ANNSPECPRINTER::printSort dom)) 
                 (cons t2 nil))))))) 
    (let ((pV1212 (unfoldArgument dom t2))) 
      (block 
       nil 
       (return 
        (STANDARDSPEC::mkLet 
         (cdr pV1212) 
         (STANDARDSPEC::mkApply t1 (car pV1212)))) 
       (error "Nonexhaustive match failure in mkArityApply")))))
                                                                
(defun ARITYNORMALIZE::matchArity (match) 
  (labels 
    ((mA (match num) 
      (block 
       nil 
       (if (null match) 
           (return num) 
           (if (consp match) 
               (let ((pV1159 (cdr match))) 
                 (let ((pV1160 (svref (car match) 0))) 
                   (if (eq (car pV1160) :|RecordPat|) 
                       (return 
                        (if ( =  num (LIST-SPEC::|!length| (car (cdr pV1160)))) 
                            (mA pV1159 num) 
                            1)) 
                       (if (eq (car pV1160) :|WildPat|) (return (mA pV1159 num)))))))) 
       (return 1)))) 
    (block 
     nil 
     (if (null match) 
         (return 0) 
         (if (consp match) 
             (let ((pV1177 (svref (car match) 0))) 
               (if (eq (car pV1177) :|RecordPat|) 
                   (return 
                    (mA (cdr match) (LIST-SPEC::|!length| (car (cdr pV1177))))))))) 
     (return 1))))
                  
(defun ARITYNORMALIZE::sortArity (sp srt) 
  (labels 
    ((productLength (srt) 
      (let ((pV1361 (SPECENVIRONMENT::productOpt sp srt))) 
        (block 
         nil 
         (if (eq (car pV1361) :|Some|) 
             (return (LIST-SPEC::|!length| (cdr pV1361))) 
             (if (eq (car pV1361) :|None|) (return 1))) 
         (error "Nonexhaustive match failure in sortArity"))))) 
    (let ((pV1364 (SPECENVIRONMENT::arrowOpt sp srt))) 
      (block 
       nil 
       (if (eq (car pV1364) :|Some|) 
           (let ((pV1366 (car (cdr pV1364)))) 
             (return 
              (let ((len (productLength pV1366))) 
                (if (BOOLEAN-SPEC::~ ( =  len 1)) 
                    (cons :|Some| (cons pV1366 len)) 
                    '(:|None|)))))) 
       (return '(:|None|))))))
                              
(defun LIST-SPEC::|!find|-1-1 (p l) 
  (block 
   nil 
   (if (null l) 
       (return '(:|None|)) 
       (if (consp l) 
           (let ((pV2045 (car l))) 
             (return 
              (if (funcall p pV2045) 
                  (cons :|Some| pV2045) 
                  (LIST-SPEC::|!find|-1-1 p (cdr l))))))) 
   (error "Nonexhaustive match failure in find")))
                                                  
(defun ARITYNORMALIZE::termArity (sp gamma term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (return '(:|None|)) 
       (if (eq (car term) :|Var|) 
           (let ((pV1418 (car (car (cdr term))))) 
             (return 
              (let ((pV1371 
                     (LIST-SPEC::|!find|-1-1 
                      #'(lambda (x) (string=  pV1418 (car x))) 
                      gamma))) 
                (block 
                 nil 
                 (if (eq (car pV1371) :|Some|) 
                     (return (cdr (cdr pV1371))) 
                     (if (eq (car pV1371) :|None|) (return '(:|None|)))) 
                 (error "Nonexhaustive match failure in termArity"))))) 
           (if (eq (car term) :|Fun|) 
               (let ((pV1405 (cdr term))) 
                 (progn (let ((pV1411 (svref pV1405 1))
                              (pV1410 (svref pV1405 0))) 
                          (if (eq (car pV1410) :|Equals|) 
                              (return (ARITYNORMALIZE::sortArity sp pV1411)) 
                              (if (eq (car pV1410) :|Embed|) 
                                  (if (eq t (cdr (cdr pV1410))) 
                                      (return 
                                       (ARITYNORMALIZE::sortArity sp pV1411)))))) 
                        (return '(:|None|)))) 
               (if (eq (car term) :|Let|) 
                   (return '(:|None|)) 
                   (if (eq (car term) :|LetRec|) 
                       (return '(:|None|)) 
                       (if (eq (car term) :|Bind|) 
                           (return '(:|None|)) 
                           (if (eq (car term) :|Lambda|) 
                               (let ((pV1408 (car (cdr term)))) 
                                 (return 
                                  (let ((mArity 
                                         (ARITYNORMALIZE::matchArity pV1408))) 
                                    (if ( =  mArity 1) 
                                        '(:|None|) 
                                        (cons 
                                         :|Some| 
                                         (cons 
                                          (block 
                                           nil 
                                           (if (consp pV1408) 
                                               (return 
                                                (METASLANG::patternSort 
                                                 (svref (car pV1408) 0)))) 
                                           (return 
                                            (SYSTEM-SPEC::fail 
                                             "Unexpected empty match"))) 
                                          mArity)))))) 
                               (if (eq (car term) :|IfThenElse|) 
                                   (return '(:|None|)) 
                                   (if (eq (car term) :|Record|) 
                                       (return '(:|None|)) 
                                       (if (eq (car term) :|Seq|) 
                                           (return '(:|None|)))))))))))) 
   (return (SYSTEM-SPEC::fail "Unmatched term"))))
                                                  
(defun ARITYNORMALIZE::convertToArity1 (sp gamma usedNames term) 
  (let ((pV1070 (ARITYNORMALIZE::termArity sp gamma term))) 
    (block 
     nil 
     (if (eq (car pV1070) :|None|) 
         (return term) 
         (if (eq (car pV1070) :|Some|) 
             (let ((pV1072 (car (cdr pV1070)))) 
               (return 
                (let ((pV1067 (ARITYNORMALIZE::freshName "x" usedNames))) 
                  (block 
                   nil 
                   (return 
                    (let ((x (cons (car pV1067) pV1072))) 
                      (cons 
                       :|Lambda| 
                       (cons 
                        (cons 
                         (vector 
                          (cons :|VarPat| (cons x POSITION-SPEC::noPos)) 
                          (STANDARDSPEC::mkTrue) 
                          (ARITYNORMALIZE::mkArityApply 
                           sp 
                           pV1072 
                           term 
                           (STANDARDSPEC::mkVar-1 x) 
                           (cdr pV1067))) 
                         nil) 
                        POSITION-SPEC::noPos)))) 
                   (error "Nonexhaustive match failure in convertToArity1"))))))) 
     (error "Nonexhaustive match failure in convertToArity1"))))
                                                                
(defun ARITYNORMALIZE::insertVars (pV1144 pV1145) 
  (block 
   nil 
   (return 
    (LIST-SPEC::foldr-1-1-1 
     #'(lambda (x) 
        (let ((pV1139 (cdr x))) 
          (block 
           nil 
           (let ((pV1140 (car (car x)))) 
             (return 
              (cons 
               (STRINGSET::add (car pV1139) pV1140) 
               (LIST-SPEC::|!cons| (cons pV1140 '(:|None|)) (cdr pV1139))))) 
           (error "Nonexhaustive match failure in insertVars")))) 
     (cons (car pV1145) (cdr pV1145)) 
     pV1144)) 
   (error "Nonexhaustive match failure in insertVars")))
                                                        
(defun SPECENVIRONMENT::rangeOpt (sp srt) 
  (let ((pV7195 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV7195) :|None|) 
         (return '(:|None|)) 
         (if (eq (car pV7195) :|Some|) 
             (return (cons :|Some| (cdr (cdr pV7195)))))) 
     (error "Nonexhaustive match failure in rangeOpt"))))
                                                         
(defun SPECENVIRONMENT::inferType (sp tm) 
  (block 
   nil 
   (if (eq (car tm) :|Apply|) 
       (return 
        (let ((pV7088 
               (SPECENVIRONMENT::rangeOpt 
                sp 
                (SPECENVIRONMENT::inferType sp (svref (cdr tm) 0))))) 
          (block 
           nil 
           (if (eq (car pV7088) :|Some|) 
               (return (cdr pV7088)) 
               (if (eq (car pV7088) :|None|) 
                   (return 
                    (SYSTEM-SPEC::fail 
                     (STRING-SPEC::^ 
                      "Could not extract type for " 
                      (ANNSPECPRINTER::printTermWithSorts tm)))))) 
           (error "Nonexhaustive match failure in inferType")))) 
       (if (eq (car tm) :|Bind|) 
           (return STANDARDSPEC::boolSort) 
           (if (eq (car tm) :|Record|) 
               (let ((pV7117 (cdr tm))) 
                 (return 
                  (cons 
                   :|Product| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (cons (car x) (SPECENVIRONMENT::inferType sp (cdr x)))) 
                     (car pV7117)) 
                    (cdr pV7117))))) 
               (if (eq (car tm) :|Let|) 
                   (return (SPECENVIRONMENT::inferType sp (svref (cdr tm) 1))) 
                   (if (eq (car tm) :|LetRec|) 
                       (return 
                        (SPECENVIRONMENT::inferType sp (svref (cdr tm) 1))) 
                       (if (eq (car tm) :|Var|) 
                           (return (cdr (car (cdr tm)))) 
                           (if (eq (car tm) :|Fun|) 
                               (return (svref (cdr tm) 1)) 
                               (if (eq (car tm) :|Lambda|) 
                                   (let ((pV7129 (car (cdr tm)))) 
                                     (if (consp pV7129) 
                                         (let ((pV7132 (car pV7129))) 
                                           (return 
                                            (STANDARDSPEC::mkArrow 
                                             (METASLANG::patternSort 
                                              (svref pV7132 0)) 
                                             (SPECENVIRONMENT::inferType 
                                              sp 
                                              (svref pV7132 2))))) 
                                         (if (null pV7129) 
                                             (return 
                                              (SYSTEM-SPEC::fail 
                                               "inferType: Ill formed lambda abstraction"))))) 
                                   (if (eq (car tm) :|IfThenElse|) 
                                       (return 
                                        (SPECENVIRONMENT::inferType 
                                         sp 
                                         (svref (cdr tm) 1))) 
                                       (if (eq (car tm) :|Seq|) 
                                           (let ((pV7120 (car (cdr tm)))) 
                                             (if (null pV7120) 
                                                 (return 
                                                  (cons 
                                                   :|Product| 
                                                   (cons 
                                                    nil 
                                                    POSITION-SPEC::noPos))) 
                                                 (if (consp pV7120) 
                                                     (let ((pV7124 (cdr pV7120))) 
                                                       (progn (if (null pV7124) 
                                                                  (return 
                                                                   (SPECENVIRONMENT::inferType 
                                                                    sp 
                                                                    (car pV7120)))) 
                                                              (return 
                                                               (SPECENVIRONMENT::inferType 
                                                                sp 
                                                                (cons 
                                                                 :|Seq| 
                                                                 (cons 
                                                                  pV7124 
                                                                  POSITION-SPEC::noPos))))))))))))))))))) 
   (return (SYSTEM-SPEC::fail "inferType: Non-exhaustive match"))))
                                                                   
(defun STANDARDSPEC::mkOp (qid srt) 
  (STANDARDSPEC::mkFun (cons :|Op| (cons qid nil)) srt))
                                                        
(defun ARITYNORMALIZE::mkArityTuple (sp term) 
  (let ((srt (SPECENVIRONMENT::inferType sp term))) 
    (STANDARDSPEC::mkApply 
     (STANDARDSPEC::mkOp 
      (cons :|Qualified| (cons "TranslationBuiltIn" "mkTuple")) 
      (STANDARDSPEC::mkArrow srt srt)) 
     term)))
            
(defun ARITYNORMALIZE::polymorphicDomain? (sp srt) 
  (let ((pV1344 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV1344) :|Some|) 
         (if (eq (car (car (cdr pV1344))) :|TyVar|) (return t))) 
     (return nil))))
                    
(defun STANDARDSPEC::findTheOp (pV9313 pV9314) 
  (block 
   nil 
   (if (eq (car pV9314) :|Qualified|) 
       (let ((pV9315 (cdr pV9314))) 
         (return (findAQualifierMap (svref pV9313 1) (car pV9315) (cdr pV9315))))) 
   (error "Nonexhaustive match failure in findTheOp")))
                                                       
(defun ARITYNORMALIZE::polymorphicDomainOp? (spc idf) 
  (let ((pV1353 (STANDARDSPEC::findTheOp spc idf))) 
    (block 
     nil 
     (if (eq (car pV1353) :|Some|) 
         (return 
          (ARITYNORMALIZE::polymorphicDomain? spc (cdr (svref (cdr pV1353) 2)))) 
         (if (eq (car pV1353) :|None|) (return nil))) 
     (error "Nonexhaustive match failure in polymorphicDomainOp?"))))
                                                                     
(defun STANDARDSPEC::mkBind (b vars term) 
  (cons :|Bind| (vector b vars term POSITION-SPEC::noPos)))
                                                           
(defun STANDARDSPEC::mkLetRec (decls term) 
  (cons :|LetRec| (vector decls term POSITION-SPEC::noPos)))
                                                            
(defun ARITYNORMALIZE::normalizeArity (sp gamma usedNames term) 
  (labels 
    ((nonPolymorphicFun? (t1) 
      (block 
       nil 
       (if (eq (car t1) :|Fun|) 
           (let ((pV1240 (svref (cdr t1) 0))) 
             (if (eq (car pV1240) :|Op|) 
                 (return 
                  (BOOLEAN-SPEC::~ 
                   (ARITYNORMALIZE::polymorphicDomainOp? sp (car (cdr pV1240)))))))) 
       (return nil)))
     (normalizeRecordArguments (|!t|) 
      (block 
       nil 
       (if (eq (car |!t|) :|Record|) 
           (return 
            (let ((fields 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (x) 
                       (cons 
                        (car x) 
                        (ARITYNORMALIZE::normalizeArity 
                         sp 
                         gamma 
                         usedNames 
                         (cdr x)))) 
                    (car (cdr |!t|))))) 
              (cons (STANDARDSPEC::mkRecord fields) t))) 
           (if (eq (car |!t|) :|Apply|) 
               (let ((pV1223 (cdr |!t|))) 
                 (let ((pV1225 (svref pV1223 0))) 
                   (if (eq (car pV1225) :|Fun|) 
                       (if (eq (car (svref (cdr pV1225) 0)) :|Restrict|) 
                           (return 
                            (let ((pV1218 
                                   (normalizeRecordArguments (svref pV1223 1)))) 
                              (block 
                               nil 
                               (return 
                                (cons 
                                 (cons 
                                  :|Apply| 
                                  (vector pV1225 (car pV1218) (svref pV1223 2))) 
                                 (cdr pV1218))) 
                               (error 
                                "Nonexhaustive match failure in normalizeArity")))))))))) 
       (return 
        (let ((|!t|1 (ARITYNORMALIZE::normalizeArity sp gamma usedNames |!t|))) 
          (cons |!t|1 nil)))))) 
    (block 
     nil 
     (if (eq (car term) :|Apply|) 
         (let ((pV1311 (cdr term))) 
           (let ((pV1331 (svref pV1311 1))
                 (pV1330 (svref pV1311 0))) 
             (return 
              (if (nonPolymorphicFun? pV1330) 
                  (let ((pV1248 (normalizeRecordArguments pV1331))) 
                    (block 
                     nil 
                     (return (STANDARDSPEC::mkApply pV1330 (car pV1248))) 
                     (error "Nonexhaustive match failure in normalizeArity"))) 
                  (let ((pV1260 (ARITYNORMALIZE::termArity sp gamma pV1330))) 
                    (block 
                     nil 
                     (if (eq (car pV1260) :|None|) 
                         (return 
                          (STANDARDSPEC::mkApply 
                           (ARITYNORMALIZE::normalizeArity 
                            sp 
                            gamma 
                            usedNames 
                            pV1330) 
                           (ARITYNORMALIZE::normalizeArity 
                            sp 
                            gamma 
                            usedNames 
                            pV1331))) 
                         (if (eq (car pV1260) :|Some|) 
                             (return 
                              (let ((pV1257 (normalizeRecordArguments pV1331))) 
                                (block 
                                 nil 
                                 (let ((pV1258 (car pV1257))) 
                                   (return 
                                    (let ((t1 
                                           (block 
                                            nil 
                                            (if (eq (car pV1330) :|Var|) 
                                                (return pV1330) 
                                                (if (eq (car pV1330) :|Fun|) 
                                                    (return pV1330))) 
                                            (return 
                                             (ARITYNORMALIZE::normalizeArityTopLevel 
                                              sp 
                                              gamma 
                                              usedNames 
                                              pV1330))))) 
                                      (if (cdr pV1257) 
                                          (STANDARDSPEC::mkApply t1 pV1258) 
                                          (ARITYNORMALIZE::mkArityApply 
                                           sp 
                                           (car (cdr pV1260)) 
                                           t1 
                                           pV1258 
                                           usedNames))))) 
                                 (error 
                                  "Nonexhaustive match failure in normalizeArity")))))) 
                     (error "Nonexhaustive match failure in normalizeArity"))))))) 
         (if (eq (car term) :|Record|) 
             (return 
              (let ((fields 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x) 
                         (cons 
                          (car x) 
                          (ARITYNORMALIZE::normalizeArity 
                           sp 
                           gamma 
                           usedNames 
                           (cdr x)))) 
                      (car (cdr term))))) 
                (ARITYNORMALIZE::mkArityTuple sp (STANDARDSPEC::mkRecord fields)))) 
             (if (eq (car term) :|Bind|) 
                 (let ((pV1309 (cdr term))) 
                   (let ((pV1325 (svref pV1309 1))) 
                     (return 
                      (let ((pV1266 
                             (ARITYNORMALIZE::insertVars 
                              pV1325 
                              (cons usedNames gamma)))) 
                        (block 
                         nil 
                         (return 
                          (STANDARDSPEC::mkBind 
                           (svref pV1309 0) 
                           pV1325 
                           (ARITYNORMALIZE::normalizeArity 
                            sp 
                            (cdr pV1266) 
                            (car pV1266) 
                            (svref pV1309 2)))) 
                         (error "Nonexhaustive match failure in normalizeArity")))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV1308 (cdr term))) 
                       (return 
                        (let ((pV1280 
                               (LIST-SPEC::foldr-1-1-1 
                                #'(lambda (x) 
                                   (let ((pV1274 (cdr x))
                                         (pV1273 (car x))) 
                                     (block 
                                      nil 
                                      (let ((pV1275 (car pV1273))) 
                                        (let ((pV1279 (svref pV1274 2))
                                              (pV1278 (svref pV1274 1))) 
                                          (return 
                                           (let ((t2 
                                                  (ARITYNORMALIZE::normalizeArity 
                                                   sp 
                                                   pV1279 
                                                   pV1278 
                                                   (cdr pV1273)))) 
                                             (let ((pV1270 
                                                    (ARITYNORMALIZE::insertPattern 
                                                     pV1275 
                                                     (cons pV1278 pV1279)))) 
                                               (block 
                                                nil 
                                                (return 
                                                 (vector 
                                                  (LIST-SPEC::|!cons| 
                                                   (cons pV1275 t2) 
                                                   (svref pV1274 0)) 
                                                  (car pV1270) 
                                                  (cdr pV1270))) 
                                                (error 
                                                 "Nonexhaustive match failure in normalizeArity"))))))) 
                                      (error 
                                       "Nonexhaustive match failure in normalizeArity")))) 
                                (vector nil usedNames gamma) 
                                (svref pV1308 0)))) 
                          (block 
                           nil 
                           (return 
                            (let ((term1 
                                   (ARITYNORMALIZE::normalizeArity 
                                    sp 
                                    (svref pV1280 2) 
                                    (svref pV1280 1) 
                                    (svref pV1308 1)))) 
                              (STANDARDSPEC::mkLet (svref pV1280 0) term1))) 
                           (error 
                            "Nonexhaustive match failure in normalizeArity"))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV1307 (cdr term))) 
                           (let ((pV1318 (svref pV1307 0))) 
                             (return 
                              (let ((pV1295 
                                     (LIST-SPEC::foldr-1-1-1 
                                      #'(lambda (x) 
                                         (let ((pV1290 (cdr x))
                                               (pV1289 (car x))) 
                                           (block 
                                            nil 
                                            (let ((pV1294 (cdr pV1290))) 
                                              (return 
                                               (block 
                                                nil 
                                                (let ((pV1287 (car (car pV1289)))) 
                                                  (return 
                                                   (let ((usedNames 
                                                          (STRINGSET::add 
                                                           (car pV1290) 
                                                           pV1287))) 
                                                     (let ((gamma 
                                                            (LIST-SPEC::|!cons| 
                                                             (cons 
                                                              pV1287 
                                                              (ARITYNORMALIZE::termArity 
                                                               sp 
                                                               pV1294 
                                                               (cdr pV1289))) 
                                                             pV1294))) 
                                                       (cons usedNames gamma))))) 
                                                (error 
                                                 "Nonexhaustive match failure in normalizeArity")))) 
                                            (error 
                                             "Nonexhaustive match failure in normalizeArity")))) 
                                      (cons usedNames gamma) 
                                      pV1318))) 
                                (block 
                                 nil 
                                 (let ((pV1297 (cdr pV1295))
                                       (pV1296 (car pV1295))) 
                                   (return 
                                    (let ((decls 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) 
                                               (cons 
                                                (car x) 
                                                (ARITYNORMALIZE::normalizeArityTopLevel 
                                                 sp 
                                                 pV1297 
                                                 pV1296 
                                                 (cdr x)))) 
                                            pV1318))) 
                                      (let ((term1 
                                             (ARITYNORMALIZE::normalizeArity 
                                              sp 
                                              pV1297 
                                              pV1296 
                                              (svref pV1307 1)))) 
                                        (STANDARDSPEC::mkLetRec decls term1))))) 
                                 (error 
                                  "Nonexhaustive match failure in normalizeArity")))))) 
                         (if (eq (car term) :|IfThenElse|) 
                             (let ((pV1306 (cdr term))) 
                               (return 
                                (cons 
                                 :|IfThenElse| 
                                 (vector 
                                  (ARITYNORMALIZE::normalizeArity 
                                   sp 
                                   gamma 
                                   usedNames 
                                   (svref pV1306 0)) 
                                  (ARITYNORMALIZE::normalizeArity 
                                   sp 
                                   gamma 
                                   usedNames 
                                   (svref pV1306 1)) 
                                  (ARITYNORMALIZE::normalizeArity 
                                   sp 
                                   gamma 
                                   usedNames 
                                   (svref pV1306 2)) 
                                  (svref pV1306 3))))) 
                             (if (eq (car term) :|Seq|) 
                                 (let ((pV1305 (cdr term))) 
                                   (return 
                                    (cons 
                                     :|Seq| 
                                     (cons 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (trm) 
                                          (ARITYNORMALIZE::normalizeArity 
                                           sp 
                                           gamma 
                                           usedNames 
                                           trm)) 
                                       (car pV1305)) 
                                      (cdr pV1305))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (return 
                                      (let ((term1 
                                             (ARITYNORMALIZE::normalizeArityTopLevel 
                                              sp 
                                              gamma 
                                              usedNames 
                                              term))) 
                                        (ARITYNORMALIZE::convertToArity1 
                                         sp 
                                         gamma 
                                         usedNames 
                                         term1))) 
                                     (if (eq (car term) :|Var|) 
                                         (return 
                                          (ARITYNORMALIZE::convertToArity1 
                                           sp 
                                           gamma 
                                           usedNames 
                                           term)) 
                                         (if (eq (car term) :|Fun|) 
                                             (return 
                                              (ARITYNORMALIZE::convertToArity1 
                                               sp 
                                               gamma 
                                               usedNames 
                                               term)))))))))))) 
     (error "Nonexhaustive match failure in normalizeArity"))))
                                                               
(defun ARITYNORMALIZE::normalizeArityTopLevel (sp gamma usedNames term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (let ((pV1338 (cdr term))) 
         (return 
          (cons 
           :|Lambda| 
           (cons 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (x) 
                (let ((pat (svref x 0))) 
                  (let ((pV1333 
                         (ARITYNORMALIZE::insertPattern 
                          pat 
                          (cons usedNames gamma)))) 
                    (block 
                     nil 
                     (let ((pV1335 (cdr pV1333))
                           (pV1334 (car pV1333))) 
                       (return 
                        (vector 
                         pat 
                         (ARITYNORMALIZE::normalizeArity 
                          sp 
                          pV1335 
                          pV1334 
                          (svref x 1)) 
                         (ARITYNORMALIZE::normalizeArity 
                          sp 
                          pV1335 
                          pV1334 
                          (svref x 2))))) 
                     (error 
                      "Nonexhaustive match failure in normalizeArityTopLevel"))))) 
             (car pV1338)) 
            (cdr pV1338)))))) 
   (return (ARITYNORMALIZE::normalizeArity sp gamma usedNames term))))
                                                                      
(defun OPTION::mapOption-1-1 (f opt) 
  (block 
   nil 
   (if (eq (car opt) :|None|) 
       (return '(:|None|)) 
       (if (eq (car opt) :|Some|) (return (cons :|Some| (funcall f (cdr opt)))))) 
   (error "Nonexhaustive match failure in mapOption")))
                                                       
(defun SPLAYMAP::listItemsf (f sp l) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return l) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8750 (cdr sp))) 
             (return 
              (SPLAYMAP::listItemsf 
               f 
               (svref pV8750 0) 
               (LIST-SPEC::|!cons| 
                (funcall f (svref pV8750 2)) 
                (SPLAYMAP::listItemsf f (svref pV8750 1) l))))))) 
   (error "Nonexhaustive match failure in listItemsf")))
                                                        
(defun SPLAYMAP::listDomain (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::listItemsf 
             #'(lambda (x) (car x)) 
             (STATE::|!!| (svref (cdr |!map|) 2)) 
             nil)))) 
   (error "Nonexhaustive match failure in listDomain")))
                                                        
(defun STRINGMAP::listDomain (x) (SPLAYMAP::listDomain x))
                                                          
(defun SPLAYSET::insert (x1) #'(lambda (x2) (SPLAYSET::insert-1-1 x1 x2)))
                                                                          
(defun SPLAYSET::addList (|!set| l) 
  (block 
   nil 
   (if (null l) (return |!set|)) 
   (return 
    (let ((pV8833 
           (block 
            nil 
            (if (eq (car |!set|) :|SET|) 
                (let ((pV8826 (cdr |!set|))) 
                  (return 
                   (vector 
                    (svref pV8826 1) 
                    (STATE::|!!| (svref pV8826 2)) 
                    (svref pV8826 0)))) 
                (if (eq (car |!set|) :|EMPTY|) 
                    (return (vector 0 '(:|SplayNil|) (cdr |!set|))))) 
            (error "Nonexhaustive match failure in addList")))) 
      (block 
       nil 
       (let ((pV8836 (svref pV8833 2))) 
         (return 
          (let ((pV8830 
                 (LIST-SPEC::foldr-1-1-1 
                  (SPLAYSET::insert pV8836) 
                  (cons (svref pV8833 0) (svref pV8833 1)) 
                  l))) 
            (block 
             nil 
             (return 
              (cons 
               :|SET| 
               (vector pV8836 (car pV8830) (cons :|Ref| (cdr pV8830))))) 
             (error "Nonexhaustive match failure in addList"))))) 
       (error "Nonexhaustive match failure in addList"))))))
                                                            
(defparameter STRINGSET::empty (SPLAYSET::empty #'STRING-SPEC::compare-1))
                                                                          
(defun STRINGSET::fromList (ls) (SPLAYSET::addList STRINGSET::empty ls))
                                                                        
(defun ARITYNORMALIZE::arityNormalize-1 (spc) 
  (let ((usedNames (STRINGSET::fromList (STRINGMAP::listDomain (svref spc 1))))) 
    (setOps 
     spc 
     (mapAQualifierMap-1-1 
      #'(lambda (x) 
         (let ((pV1063 (svref x 2))) 
           (block 
            nil 
            (let ((pV1066 (cdr pV1063))) 
              (return 
               (let ((new_opt_def 
                      (OPTION::mapOption-1-1 
                       #'(lambda (term) 
                          (ARITYNORMALIZE::normalizeArityTopLevel 
                           spc 
                           nil 
                           usedNames 
                           (ARITYNORMALIZE::etaExpand spc usedNames pV1066 term))) 
                       (svref x 3)))) 
                 (vector 
                  (svref x 0) 
                  (svref x 1) 
                  (cons (car pV1063) pV1066) 
                  new_opt_def)))) 
            (error "Nonexhaustive match failure in arityNormalize")))) 
      (svref spc 1)))))
                       
(defun ARITYNORMALIZE::arityNormalize (x0 x1 x2 x3) 
  (ARITYNORMALIZE::arityNormalize-1 (vector x0 x1 x2 x3)))
                                                          
(defun ARITYNORMALIZE::convertToArity1-1 (x) 
  (ARITYNORMALIZE::convertToArity1 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun ARITYNORMALIZE::etaExpand-1 (x) 
  (ARITYNORMALIZE::etaExpand (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                              
(defun ARITYNORMALIZE::freshName-1 (x) 
  (ARITYNORMALIZE::freshName (car x) (cdr x)))
                                              
(defun ARITYNORMALIZE::freshNames-1 (x) 
  (ARITYNORMALIZE::freshNames (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun ARITYNORMALIZE::insertPattern-1 (x) 
  (ARITYNORMALIZE::insertPattern (car x) (cdr x)))
                                                  
(defun ARITYNORMALIZE::insertVars-1 (x) 
  (ARITYNORMALIZE::insertVars (car x) (cdr x)))
                                               
(defun ARITYNORMALIZE::mkArityApply-1 (x) 
  (ARITYNORMALIZE::mkArityApply 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun ARITYNORMALIZE::mkArityTuple-1 (x) 
  (ARITYNORMALIZE::mkArityTuple (car x) (cdr x)))
                                                 
(defun ARITYNORMALIZE::normalizeArity-1 (x) 
  (ARITYNORMALIZE::normalizeArity 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun ARITYNORMALIZE::normalizeArityTopLevel-1 (x) 
  (ARITYNORMALIZE::normalizeArityTopLevel 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun ARITYNORMALIZE::polymorphicDomain?-1 (x) 
  (ARITYNORMALIZE::polymorphicDomain? (car x) (cdr x)))
                                                       
(defun ARITYNORMALIZE::polymorphicDomainOp?-1 (x) 
  (ARITYNORMALIZE::polymorphicDomainOp? (car x) (cdr x)))
                                                         
(defun ARITYNORMALIZE::sortArity-1 (x) 
  (ARITYNORMALIZE::sortArity (car x) (cdr x)))
                                              
(defun ARITYNORMALIZE::termArity-1 (x) 
  (ARITYNORMALIZE::termArity (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun BOOLEAN-SPEC::& (x y) (if x y nil))
                                          
(defun BOOLEAN-SPEC::&-1 (x) (BOOLEAN-SPEC::& (car x) (cdr x)))
                                                               
(defun BOOLEAN-SPEC::<=> (x y) (if x y (BOOLEAN-SPEC::~ y)))
                                                            
(defun BOOLEAN-SPEC::<=>-1 (x) (BOOLEAN-SPEC::<=> (car x) (cdr x)))
                                                                   
(defun BOOLEAN-SPEC::=> (x y) (if x y t))
                                         
(defun BOOLEAN-SPEC::=>-1 (x) (BOOLEAN-SPEC::=> (car x) (cdr x)))
                                                                 
(defun BOOLEAN-SPEC::|!or| (x y) (if x t y))
                                            
(defun BOOLEAN-SPEC::|!or|-1 (x) (BOOLEAN-SPEC::|!or| (car x) (cdr x)))
                                                                       
(defun BOOLEAN-SPEC::show (b) (BOOLEAN-SPEC::toString b))
                                                         
(defun CGEN::addFuncDefn-1-1-1-1-1 (cSpec name params |!type| stmt) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (cons (vector name params |!type| stmt) (svref cSpec 4)) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (svref cSpec 7) 
   (svref cSpec 8) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (svref cSpec 11)))
                     
(defun CGEN::addFuncDefn-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) 
           #'(lambda (x5) (CGEN::addFuncDefn-1-1-1-1-1 x1 x2 x3 x4 x5))))))
                                                                           
(defun CGEN::addFuncDefn (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addFuncDefn-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                       
(defun CGEN::addStruct-1-1-1 (cSpec name fields) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (svref cSpec 4) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (cons (cons name fields) (svref cSpec 7)) 
   (cons (cons name (cons :|Struct| name)) (svref cSpec 8)) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (svref cSpec 11)))
                     
(defun CGEN::addStruct-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CGEN::addStruct-1-1-1 x1 x2 x3))))
                                                                   
(defun CGEN::addStruct (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addStruct-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                     
(defun CGEN::addTypeDefn-1-1-1 (cSpec name |!type|) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (svref cSpec 4) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (svref cSpec 7) 
   (cons (cons name |!type|) (svref cSpec 8)) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (svref cSpec 11)))
                     
(defun CGEN::addTypeDefn-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CGEN::addTypeDefn-1-1-1 x1 x2 x3))))
                                                                     
(defun CGEN::addTypeDefn (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addTypeDefn-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                       
(defun CGEN::addVarDecl-1-1-1 (cSpec name |!type|) 
  (vector 
   (svref cSpec 0) 
   (svref cSpec 1) 
   (svref cSpec 2) 
   (svref cSpec 3) 
   (svref cSpec 4) 
   (svref cSpec 5) 
   (svref cSpec 6) 
   (svref cSpec 7) 
   (svref cSpec 8) 
   (svref cSpec 9) 
   (svref cSpec 10) 
   (cons (cons name |!type|) (svref cSpec 11))))
                                                
(defun CGEN::addVarDecl-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CGEN::addVarDecl-1-1-1 x1 x2 x3))))
                                                                    
(defun CGEN::addVarDecl (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::addVarDecl-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                      
(defun CGEN::showQualifiedId (pV1761) 
  (block 
   nil 
   (if (eq (car pV1761) :|Qualified|) 
       (let ((pV1762 (cdr pV1761))) 
         (let ((pV1764 (cdr pV1762))
               (pV1763 (car pV1762))) 
           (return 
            (if (string=  pV1763 METASLANG::UnQualified) 
                pV1764 
                (STRING-SPEC::^ (STRING-SPEC::^ pV1763 "_") pV1764)))))) 
   (error "Nonexhaustive match failure in showQualifiedId")))
                                                             
(defun CGEN::baseSortToCType (pV1423) 
  (block 
   nil 
   (if (eq (car pV1423) :|Qualified|) 
       (let ((pV1424 (cdr pV1423))) 
         (let ((pV1426 (cdr pV1424))
               (pV1425 (car pV1424))) 
           (return 
            (if (string=  pV1425 METASLANG::UnQualified) 
                (cons :|Base| pV1426) 
                (block 
                 nil 
                 (if (string=  "Boolean" pV1425) 
                     (if (string=  "Boolean" pV1426) 
                         (return (cons :|Base| "bool"))) 
                     (if (string=  "Integer" pV1425) 
                         (if (string=  "Integer" pV1426) (return '(:|Int|))) 
                         (if (string=  "Nat" pV1425) 
                             (if (string=  "Nat" pV1426) 
                                 (return '(:|UnsignedInt|))) 
                             (if (string=  "String" pV1425) 
                                 (if (string=  "String" pV1426) 
                                     (return (cons :|Ptr| '(:|Char|)))) 
                                 (if (string=  "Char" pV1425) 
                                     (if (string=  "Char" pV1426) 
                                         (return '(:|Char|))) 
                                     (if (string=  "Double" pV1425) 
                                         (if (string=  "Double" pV1426) 
                                             (return '(:|Double|))))))))) 
                 (return 
                  (cons 
                   :|Base| 
                   (CGEN::showQualifiedId 
                    (cons :|Qualified| (cons pV1425 pV1426))))))))))) 
   (error "Nonexhaustive match failure in baseSortToCType")))
                                                             
(defun CGEN::fail (msg) (progn (STRING-SPEC::writeLine msg) msg))
                                                                 
(defun CGEN::binaryToString (b) 
  (block 
   nil 
   (if (eq (car b) :|Set|) 
       (return " = ") 
       (if (eq (car b) :|Add|) 
           (return " + ") 
           (if (eq (car b) :|Sub|) 
               (return " - ") 
               (if (eq (car b) :|Mul|) 
                   (return " * ") 
                   (if (eq (car b) :|Div|) 
                       (return " / ") 
                       (if (eq (car b) :|Mod|) 
                           (return " % ") 
                           (if (eq (car b) :|BitAnd|) 
                               (return " & ") 
                               (if (eq (car b) :|BitOr|) 
                                   (return " | ") 
                                   (if (eq (car b) :|BitXor|) 
                                       (return " ^ ") 
                                       (if (eq (car b) :|ShiftLeft|) 
                                           (return " << ") 
                                           (if (eq (car b) :|ShiftRight|) 
                                               (return " >> ") 
                                               (if (eq (car b) :|SetAdd|) 
                                                   (return " += ") 
                                                   (if (eq (car b) :|SetSub|) 
                                                       (return " -= ") 
                                                       (if (eq (car b) :|SetMul|) 
                                                           (return " *= ") 
                                                           (if (eq 
                                                                (car b) 
                                                                :|SetDiv|) 
                                                               (return " /= ") 
                                                               (if (eq 
                                                                    (car b) 
                                                                    :|SetMod|) 
                                                                   (return 
                                                                    " %= ") 
                                                                   (if (eq 
                                                                        (car b) 
                                                                        :|SetBitAnd|) 
                                                                       (return 
                                                                        " &= ") 
                                                                       (if (eq 
                                                                            (car 
                                                                             b) 
                                                                            :|SetBitOr|) 
                                                                           (return 
                                                                            " |= ") 
                                                                           (if (eq 
                                                                                (car 
                                                                                 b) 
                                                                                :|SetBitXor|) 
                                                                               (return 
                                                                                " ^= ") 
                                                                               (if (eq 
                                                                                    (car 
                                                                                     b) 
                                                                                    :|SetShiftLeft|) 
                                                                                   (return 
                                                                                    " <<= ") 
                                                                                   (if (eq 
                                                                                        (car 
                                                                                         b) 
                                                                                        :|SetShiftRight|) 
                                                                                       (return 
                                                                                        " >>= ") 
                                                                                       (if (eq 
                                                                                            (car 
                                                                                             b) 
                                                                                            :|LogAnd|) 
                                                                                           (return 
                                                                                            " && ") 
                                                                                           (if (eq 
                                                                                                (car 
                                                                                                 b) 
                                                                                                :|LogOr|) 
                                                                                               (return 
                                                                                                " || ") 
                                                                                               (if (eq 
                                                                                                    (car 
                                                                                                     b) 
                                                                                                    :|Eq|) 
                                                                                                   (return 
                                                                                                    " == ") 
                                                                                                   (if (eq 
                                                                                                        (car 
                                                                                                         b) 
                                                                                                        :|NotEq|) 
                                                                                                       (return 
                                                                                                        " != ") 
                                                                                                       (if (eq 
                                                                                                            (car 
                                                                                                             b) 
                                                                                                            :|Lt|) 
                                                                                                           (return 
                                                                                                            " < ") 
                                                                                                           (if (eq 
                                                                                                                (car 
                                                                                                                 b) 
                                                                                                                :|Gt|) 
                                                                                                               (return 
                                                                                                                " > ") 
                                                                                                               (if (eq 
                                                                                                                    (car 
                                                                                                                     b) 
                                                                                                                    :|Le|) 
                                                                                                                   (return 
                                                                                                                    " <= ") 
                                                                                                                   (if (eq 
                                                                                                                        (car 
                                                                                                                         b) 
                                                                                                                        :|Ge|) 
                                                                                                                       (return 
                                                                                                                        " >= ")))))))))))))))))))))))))))))) 
   (return (CGEN::fail "Unexpected binary"))))
                                              
(defun CGEN::derefSort-1-1 (spc srt) 
  (block 
   nil 
   (if (eq (car srt) :|Base|) 
       (return 
        (let ((pV1437 (STANDARDSPEC::findTheSort spc (svref (cdr srt) 0)))) 
          (block 
           nil 
           (if (eq (car pV1437) :|None|) 
               (return srt) 
               (if (eq (car pV1437) :|Some|) 
                   (let ((pV1441 (svref (cdr pV1437) 2))) 
                     (if (eq (car pV1441) :|None|) 
                         (return srt) 
                         (if (eq (car pV1441) :|Some|) 
                             (return (CGEN::derefSort-1-1 spc (cdr pV1441)))))))) 
           (error "Nonexhaustive match failure in derefSort"))))) 
   (return srt)))
                 
(defun CGEN::codSort-1-1 (spc srt) 
  (let ((pV1431 (CGEN::derefSort-1-1 spc srt))) 
    (block 
     nil 
     (if (eq (car pV1431) :|Arrow|) (return (svref (cdr pV1431) 1))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        (STRING-SPEC::^ "codSort: '" (ANNSPECPRINTER::printSort srt)) 
        "' is not a function type"))))))
                                        
(defun CGEN::codSort-1 (x1) #'(lambda (x2) (CGEN::codSort-1-1 x1 x2)))
                                                                      
(defun CGEN::codSort (x0 x1 x2 x3) (CGEN::codSort-1 (vector x0 x1 x2 x3)))
                                                                          
(defun CGEN::derefSort-1 (x1) #'(lambda (x2) (CGEN::derefSort-1-1 x1 x2)))
                                                                          
(defun CGEN::derefSort (x0 x1 x2 x3) (CGEN::derefSort-1 (vector x0 x1 x2 x3)))
                                                                              
(defparameter CGEN::emptyCSpec 
  (vector nil nil nil nil nil nil nil nil nil nil nil nil))
                                                           
(defun CGEN::findTypeDefn (x defns) 
  (LIST-SPEC::|!find|-1-1 #'(lambda (x0) (string=  x (car x0))) defns))
                                                                       
(defun LIST-SPEC::flatten (l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (return (LIST-SPEC::concat (car l) (LIST-SPEC::flatten (cdr l)))))) 
   (error "Nonexhaustive match failure in flatten")))
                                                     
(defun CGEN::namesInTypes (ts) 
  (LIST-SPEC::flatten (LIST-SPEC::|!map|-1-1 #'CGEN::namesInType ts)))
                                                                      
(defun CGEN::namesInType (|!t|) 
  (block 
   nil 
   (if (eq (car |!t|) :|Base|) 
       (return (cons (cdr |!t|) nil)) 
       (if (eq (car |!t|) :|Ptr|) 
           (return (CGEN::namesInType (cdr |!t|))) 
           (if (eq (car |!t|) :|Struct|) 
               (return nil) 
               (if (eq (car |!t|) :|Union|) 
                   (return nil) 
                   (if (eq (car |!t|) :|Fn|) 
                       (let ((pV1617 (cdr |!t|))) 
                         (return 
                          (LIST-SPEC::|!++| 
                           (CGEN::namesInType (cdr pV1617)) 
                           (CGEN::namesInTypes (car pV1617))))) 
                       (if (eq (car |!t|) :|Array|) 
                           (return (CGEN::namesInType (cdr |!t|))) 
                           (if (eq (car |!t|) :|Void|) 
                               (return nil) 
                               (if (eq (car |!t|) :|Char|) 
                                   (return nil) 
                                   (if (eq (car |!t|) :|Short|) 
                                       (return nil) 
                                       (if (eq (car |!t|) :|Int|) 
                                           (return nil) 
                                           (if (eq (car |!t|) :|Long|) 
                                               (return nil) 
                                               (if (eq 
                                                    (car |!t|) 
                                                    :|UnsignedChar|) 
                                                   (return nil) 
                                                   (if (eq 
                                                        (car |!t|) 
                                                        :|UnsignedShort|) 
                                                       (return nil) 
                                                       (if (eq 
                                                            (car |!t|) 
                                                            :|UnsignedInt|) 
                                                           (return nil) 
                                                           (if (eq 
                                                                (car |!t|) 
                                                                :|UnsignedLong|) 
                                                               (return nil) 
                                                               (if (eq 
                                                                    (car |!t|) 
                                                                    :|Float|) 
                                                                   (return nil) 
                                                                   (if (eq 
                                                                        (car 
                                                                         |!t|) 
                                                                        :|Double|) 
                                                                       (return 
                                                                        nil) 
                                                                       (if (eq 
                                                                            (car 
                                                                             |!t|) 
                                                                            :|LongDouble|) 
                                                                           (return 
                                                                            nil))))))))))))))))))) 
   (error "Nonexhaustive match failure in namesInType")))
                                                         
(defun CGEN::expand (name defns) 
  (let ((pV1450 (CGEN::findTypeDefn name defns))) 
    (block 
     nil 
     (if (eq (car pV1450) :|None|) 
         (return nil) 
         (if (eq (car pV1450) :|Some|) 
             (return (CGEN::namesInType (cdr (cdr pV1450)))))) 
     (error "Nonexhaustive match failure in expand"))))
                                                       
(defun CGEN::expand-1 (x) (CGEN::expand (car x) (cdr x)))
                                                         
(defun CGEN::failPretty (msg) 
  (progn (STRING-SPEC::writeLine msg) (PRETTYPRINT::|!string| msg)))
                                                                    
(defun CGEN::findTypeDefn-1 (x) (CGEN::findTypeDefn (car x) (cdr x)))
                                                                     
(defun CGEN::findTypeDefns (names defns) 
  (block 
   nil 
   (if (null names) 
       (return nil) 
       (if (consp names) 
           (let ((pV1462 (cdr names))) 
             (return 
              (let ((pV1457 (CGEN::findTypeDefn (car names) defns))) 
                (block 
                 nil 
                 (if (eq (car pV1457) :|None|) 
                     (return (CGEN::findTypeDefns pV1462 defns)) 
                     (if (eq (car pV1457) :|Some|) 
                         (return 
                          (LIST-SPEC::|!cons| 
                           (cdr pV1457) 
                           (CGEN::findTypeDefns pV1462 defns))))) 
                 (error "Nonexhaustive match failure in findTypeDefns"))))))) 
   (error "Nonexhaustive match failure in findTypeDefns")))
                                                           
(defun CGEN::findTypeDefns-1 (x) (CGEN::findTypeDefns (car x) (cdr x)))
                                                                       
(defun CGEN::removePrime (qid) 
  (block 
   nil 
   (if (eq (car qid) :|Qualified|) 
       (let ((pV1758 (cdr qid))) 
         (return 
          (let ((pV1753 (LIST-SPEC::rev (STRING-SPEC::explode (cdr pV1758))))) 
            (block 
             nil 
             (if (consp pV1753) 
                 (if (eq #\' (car pV1753)) 
                     (return 
                      (cons 
                       :|Qualified| 
                       (cons 
                        (car pV1758) 
                        (STRING-SPEC::implode (LIST-SPEC::rev (cdr pV1753)))))))) 
             (return qid)))))) 
   (error "Nonexhaustive match failure in removePrime")))
                                                         
(defun CGEN::sortToCType (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Subsort|) 
       (return (CGEN::sortToCType (svref (cdr srt) 0))) 
       (if (eq (car srt) :|Base|) 
           (let ((pV1789 (cdr srt))) 
             (let ((pV1795 (svref pV1789 1))
                   (pV1794 (svref pV1789 0))) 
               (progn (if (eq (car pV1794) :|Qualified|) 
                          (let ((pV1797 (cdr pV1794))) 
                            (let ((pV1799 (cdr pV1797))
                                  (pV1798 (car pV1797))) 
                              (if (string=  "Array" pV1798) 
                                  (if (string=  "Array" pV1799) 
                                      (if (consp pV1795) 
                                          (if (null (cdr pV1795)) 
                                              (return 
                                               (cons 
                                                :|Array| 
                                                (CGEN::sortToCType (car pV1795))))))) 
                                  (if (string=  "Store" pV1798) 
                                      (if (string=  "Ptr" pV1799) 
                                          (if (consp pV1795) 
                                              (if (null (cdr pV1795)) 
                                                  (return 
                                                   (cons 
                                                    :|Ptr| 
                                                    (CGEN::sortToCType 
                                                     (car pV1795)))))))))))) 
                      (if (null pV1795) (return (CGEN::baseSortToCType pV1794))) 
                      (return 
                       (progn (STRING-SPEC::writeLine 
                               (STRING-SPEC::^ 
                                "sortToCType: found instantiated base type: " 
                                (ANNSPECPRINTER::printSort srt))) 
                              '(:|Void|)))))) 
           (if (eq (car srt) :|Arrow|) 
               (let ((pV1788 (cdr srt))) 
                 (let ((pV1791 (svref pV1788 0))) 
                   (return 
                    (let ((domTypes 
                           (block 
                            nil 
                            (if (eq (car pV1791) :|Product|) 
                                (let ((pV1778 (car (cdr pV1791)))) 
                                  (if (consp pV1778) 
                                      (if (string=  "1" (car (car pV1778))) 
                                          (return 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) 
                                               (CGEN::sortToCType (cdr x))) 
                                            pV1778)))))) 
                            (return (cons (CGEN::sortToCType pV1791) nil))))) 
                      (cons 
                       :|Fn| 
                       (cons domTypes (CGEN::sortToCType (svref pV1788 1))))))))))) 
   (return 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             "sortToCType: unsupported type: " 
             (ANNSPECPRINTER::printSort srt))) 
           '(:|Void|)))))
                         
(defun CGEN::funToCExp-1-1 (fun srt) 
  (block 
   nil 
   (if (eq (car fun) :|Equals|) 
       (return (cons :|Binary| '(:|Eq|))) 
       (if (eq (car fun) :|Nat|) 
           (return (cons :|Const| (cons :|Int| (cons t (cdr fun))))) 
           (if (eq (car fun) :|Char|) 
               (return (cons :|Const| (cons :|Char| (cdr fun)))) 
               (if (eq (car fun) :|Bool|) 
                   (return 
                    (cons :|Const| (cons :|Int| (cons t (if (cdr fun) 1 0))))) 
                   (if (eq (car fun) :|String|) 
                       (return (cons :|Const| (cons :|String| (cdr fun)))) 
                       (if (eq (car fun) :|Op|) 
                           (let ((pV1508 (car (cdr fun)))) 
                             (progn (if (eq (car pV1508) :|Qualified|) 
                                        (let ((pV1510 (cdr pV1508))) 
                                          (let ((pV1511 (car pV1510))
                                                (pV1512 (cdr pV1510))) 
                                            (if (string=  "Store" pV1511) 
                                                (if (string=  "nilPtr" pV1512) 
                                                    (return 
                                                     (cons 
                                                      :|Var| 
                                                      (cons "NULL" '(:|Void|))))) 
                                                (if (string=  "Nat" pV1511) 
                                                    (if (string=  "+" pV1512) 
                                                        (return 
                                                         (cons 
                                                          :|Binary| 
                                                          '(:|Add|))) 
                                                        (if (string=  "*" pV1512) 
                                                            (return 
                                                             (cons 
                                                              :|Binary| 
                                                              '(:|Mul|))) 
                                                            (if (string=  
                                                                 "-" 
                                                                 pV1512) 
                                                                (return 
                                                                 (cons 
                                                                  :|Binary| 
                                                                  '(:|Sub|))) 
                                                                (if (string=  
                                                                     "<" 
                                                                     pV1512) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Binary| 
                                                                      '(:|Lt|))) 
                                                                    (if (string=  
                                                                         "<=" 
                                                                         pV1512) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|Le|))) 
                                                                        (if (string=  
                                                                             ">" 
                                                                             pV1512) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|Gt|))) 
                                                                            (if (string=  
                                                                                 ">=" 
                                                                                 pV1512) 
                                                                                (return 
                                                                                 (cons 
                                                                                  :|Binary| 
                                                                                  '(:|Ge|))) 
                                                                                (if (string=  
                                                                                     "div" 
                                                                                     pV1512) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Binary| 
                                                                                      '(:|Div|))) 
                                                                                    (if (string=  
                                                                                         "mod" 
                                                                                         pV1512) 
                                                                                        (return 
                                                                                         (cons 
                                                                                          :|Binary| 
                                                                                          '(:|Mod|)))))))))))) 
                                                    (if (string=  
                                                         "Integer" 
                                                         pV1511) 
                                                        (if (string=  "+" pV1512) 
                                                            (return 
                                                             (cons 
                                                              :|Binary| 
                                                              '(:|Add|))) 
                                                            (if (string=  
                                                                 "*" 
                                                                 pV1512) 
                                                                (return 
                                                                 (cons 
                                                                  :|Binary| 
                                                                  '(:|Mul|))) 
                                                                (if (string=  
                                                                     "-" 
                                                                     pV1512) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Binary| 
                                                                      '(:|Sub|))) 
                                                                    (if (string=  
                                                                         "div" 
                                                                         pV1512) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|Div|))) 
                                                                        (if (string=  
                                                                             "mod" 
                                                                             pV1512) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|Mod|))) 
                                                                            (if (string=  
                                                                                 "~" 
                                                                                 pV1512) 
                                                                                (return 
                                                                                 (cons 
                                                                                  :|Unary| 
                                                                                  '(:|Negate|))) 
                                                                                (if (string=  
                                                                                     "<" 
                                                                                     pV1512) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Binary| 
                                                                                      '(:|Lt|))) 
                                                                                    (if (string=  
                                                                                         "<=" 
                                                                                         pV1512) 
                                                                                        (return 
                                                                                         (cons 
                                                                                          :|Binary| 
                                                                                          '(:|Le|))) 
                                                                                        (if (string=  
                                                                                             ">" 
                                                                                             pV1512) 
                                                                                            (return 
                                                                                             (cons 
                                                                                              :|Binary| 
                                                                                              '(:|Gt|))) 
                                                                                            (if (string=  
                                                                                                 ">=" 
                                                                                                 pV1512) 
                                                                                                (return 
                                                                                                 (cons 
                                                                                                  :|Binary| 
                                                                                                  '(:|Ge|))))))))))))) 
                                                        (if (string=  
                                                             "Double" 
                                                             pV1511) 
                                                            (if (string=  
                                                                 "+" 
                                                                 pV1512) 
                                                                (return 
                                                                 (cons 
                                                                  :|Binary| 
                                                                  '(:|Add|))) 
                                                                (if (string=  
                                                                     "*" 
                                                                     pV1512) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Binary| 
                                                                      '(:|Mul|))) 
                                                                    (if (string=  
                                                                         "-" 
                                                                         pV1512) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|Sub|))) 
                                                                        (if (string=  
                                                                             "//" 
                                                                             pV1512) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|Div|))) 
                                                                            (if (string=  
                                                                                 "~" 
                                                                                 pV1512) 
                                                                                (return 
                                                                                 (cons 
                                                                                  :|Unary| 
                                                                                  '(:|Negate|))) 
                                                                                (if (string=  
                                                                                     "<" 
                                                                                     pV1512) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Binary| 
                                                                                      '(:|Lt|))) 
                                                                                    (if (string=  
                                                                                         "<=" 
                                                                                         pV1512) 
                                                                                        (return 
                                                                                         (cons 
                                                                                          :|Binary| 
                                                                                          '(:|Le|))) 
                                                                                        (if (string=  
                                                                                             ">" 
                                                                                             pV1512) 
                                                                                            (return 
                                                                                             (cons 
                                                                                              :|Binary| 
                                                                                              '(:|Gt|))) 
                                                                                            (if (string=  
                                                                                                 ">=" 
                                                                                                 pV1512) 
                                                                                                (return 
                                                                                                 (cons 
                                                                                                  :|Binary| 
                                                                                                  '(:|Ge|))) 
                                                                                                (if (string=  
                                                                                                     "pi" 
                                                                                                     pV1512) 
                                                                                                    (return 
                                                                                                     (cons 
                                                                                                      :|Var| 
                                                                                                      (cons 
                                                                                                       "M_PI" 
                                                                                                       '(:|Double|)))))))))))))) 
                                                            (if (string=  
                                                                 "Boolean" 
                                                                 pV1511) 
                                                                (if (string=  
                                                                     "~" 
                                                                     pV1512) 
                                                                    (return 
                                                                     (cons 
                                                                      :|Unary| 
                                                                      '(:|LogNot|))) 
                                                                    (if (string=  
                                                                         "&" 
                                                                         pV1512) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Binary| 
                                                                          '(:|LogAnd|))) 
                                                                        (if (string=  
                                                                             "or" 
                                                                             pV1512) 
                                                                            (return 
                                                                             (cons 
                                                                              :|Binary| 
                                                                              '(:|LogOr|)))))))))))))) 
                                    (return 
                                     (cons 
                                      :|Var| 
                                      (cons 
                                       (CGEN::showQualifiedId 
                                        (CGEN::removePrime pV1508)) 
                                       (CGEN::sortToCType srt)))))) 
                           (if (eq (car fun) :|Embed|) 
                               (return 
                                (progn (STRING-SPEC::writeLine 
                                        (STRING-SPEC::^ 
                                         "funToCExp: Ignoring constructor " 
                                         (car (cdr fun)))) 
                                       '(:|Nop|)))))))))) 
   (error "Nonexhaustive match failure in funToCExp")))
                                                       
(defun CGEN::funToCExp (x1) #'(lambda (x2) (CGEN::funToCExp-1-1 x1 x2)))
                                                                        
(defun CGEN::termToCExp (term) 
  (labels 
    ((applyArgsToCExps (args) 
      (block 
       nil 
       (if (eq (car args) :|Record|) 
           (return (recordFieldsToCExps (car (cdr args))))) 
       (return (cons (CGEN::termToCExp args) nil))))
     (recordFieldsToCExps (fields) 
      (block 
       nil 
       (if (null fields) 
           (return nil) 
           (if (consp fields) 
               (return 
                (cons 
                 (CGEN::termToCExp (cdr (car fields))) 
                 (recordFieldsToCExps (cdr fields)))))) 
       (error "Nonexhaustive match failure in termToCExp")))) 
    (block 
     nil 
     (if (eq (car term) :|Fun|) 
         (let ((pV1854 (cdr term))) 
           (return (CGEN::funToCExp-1-1 (svref pV1854 0) (svref pV1854 1)))) 
         (if (eq (car term) :|Var|) 
             (let ((pV1894 (car (cdr term)))) 
               (return 
                (cons 
                 :|Var| 
                 (cons (car pV1894) (CGEN::sortToCType (cdr pV1894)))))) 
             (if (eq (car term) :|IfThenElse|) 
                 (let ((pV1852 (cdr term))) 
                   (return 
                    (cons 
                     :|IfExp| 
                     (vector 
                      (CGEN::termToCExp (svref pV1852 0)) 
                      (CGEN::termToCExp (svref pV1852 1)) 
                      (CGEN::termToCExp (svref pV1852 2)))))) 
                 (if (eq (car term) :|Apply|) 
                     (let ((pV1851 (cdr term))) 
                       (let ((pV1856 (svref pV1851 1))
                             (pV1855 (svref pV1851 0))) 
                         (progn (if (eq (car pV1855) :|Apply|) 
                                    (let ((pV1859 (cdr pV1855))) 
                                      (let ((pV1871 (svref pV1859 1))
                                            (pV1870 (svref pV1859 0))) 
                                        (if (eq (car pV1870) :|Fun|) 
                                            (let ((pV1874 (svref (cdr pV1870) 0))) 
                                              (if (eq (car pV1874) :|Op|) 
                                                  (let ((pV1878 
                                                         (car (cdr pV1874)))) 
                                                    (if (eq 
                                                         (car pV1878) 
                                                         :|Qualified|) 
                                                        (let ((pV1880 
                                                               (cdr pV1878))) 
                                                          (let ((pV1882 
                                                                 (cdr pV1880))
                                                                (pV1881 
                                                                 (car pV1880))) 
                                                            (if (string=  
                                                                 "Array" 
                                                                 pV1881) 
                                                                (if (string=  
                                                                     "index" 
                                                                     pV1882) 
                                                                    (return 
                                                                     (let ((cArray 
                                                                            (CGEN::termToCExp 
                                                                             pV1871))) 
                                                                       (let ((cIndex 
                                                                              (CGEN::termToCExp 
                                                                               pV1856))) 
                                                                         (cons 
                                                                          :|ArrayRef| 
                                                                          (cons 
                                                                           cArray 
                                                                           cIndex)))))) 
                                                                (if (string=  
                                                                     "Struct" 
                                                                     pV1881) 
                                                                    (if (string=  
                                                                         "proj" 
                                                                         pV1882) 
                                                                        (progn (if (eq 
                                                                                    (car 
                                                                                     pV1871) 
                                                                                    :|Fun|) 
                                                                                   (let ((pV1884 
                                                                                          (svref 
                                                                                           (cdr 
                                                                                            pV1871) 
                                                                                           0))) 
                                                                                     (if (eq 
                                                                                          (car 
                                                                                           pV1884) 
                                                                                          :|Op|) 
                                                                                         (return 
                                                                                          (let ((cStruct 
                                                                                                 (CGEN::termToCExp 
                                                                                                  pV1856))) 
                                                                                            (cons 
                                                                                             :|StructRef| 
                                                                                             (cons 
                                                                                              cStruct 
                                                                                              (CGEN::showQualifiedId 
                                                                                               (CGEN::removePrime 
                                                                                                (car 
                                                                                                 (cdr 
                                                                                                  pV1884))))))))))) 
                                                                               (return 
                                                                                (let ((cProjFunc 
                                                                                       (CGEN::termToCExp 
                                                                                        pV1871))) 
                                                                                  (let ((cStruct 
                                                                                         (CGEN::termToCExp 
                                                                                          pV1856))) 
                                                                                    (cons 
                                                                                     :|Apply| 
                                                                                     (cons 
                                                                                      (cons 
                                                                                       :|Apply| 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         :|Unary| 
                                                                                         '(:|Contents|)) 
                                                                                        (cons 
                                                                                         cProjFunc 
                                                                                         nil))) 
                                                                                      (cons 
                                                                                       cStruct 
                                                                                       nil))))))))))))))))))) 
                                    (if (eq (car pV1855) :|Fun|) 
                                        (let ((pV1858 (cdr pV1855))) 
                                          (let ((pV1860 (svref pV1858 0))) 
                                            (progn (if (eq 
                                                        (car pV1860) 
                                                        :|Project|) 
                                                       (return 
                                                        (let ((cStruct 
                                                               (CGEN::termToCExp 
                                                                pV1856))) 
                                                          (cons 
                                                           :|StructRef| 
                                                           (cons 
                                                            cStruct 
                                                            (cdr pV1860))))) 
                                                       (if (eq 
                                                            (car pV1860) 
                                                            :|Op|) 
                                                           (let ((pV1865 
                                                                  (car 
                                                                   (cdr pV1860)))) 
                                                             (if (eq 
                                                                  (car pV1865) 
                                                                  :|Qualified|) 
                                                                 (let ((pV1867 
                                                                        (cdr 
                                                                         pV1865))) 
                                                                   (let ((pV1869 
                                                                          (cdr 
                                                                           pV1867))
                                                                         (pV1868 
                                                                          (car 
                                                                           pV1867))) 
                                                                     (if (string=  
                                                                          "Store" 
                                                                          pV1868) 
                                                                         (if (string=  
                                                                              "deref" 
                                                                              pV1869) 
                                                                             (return 
                                                                              (cons 
                                                                               :|Apply| 
                                                                               (cons 
                                                                                (cons 
                                                                                 :|Unary| 
                                                                                 '(:|Contents|)) 
                                                                                (cons 
                                                                                 (CGEN::termToCExp 
                                                                                  pV1856) 
                                                                                 nil))))) 
                                                                         (if (string=  
                                                                              "Double" 
                                                                              pV1868) 
                                                                             (if (string=  
                                                                                  "fromNat" 
                                                                                  pV1869) 
                                                                                 (return 
                                                                                  (CGEN::termToCExp 
                                                                                   pV1856)) 
                                                                                 (if (string=  
                                                                                      "sqrt" 
                                                                                      pV1869) 
                                                                                     (return 
                                                                                      (cons 
                                                                                       :|Apply| 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         :|Var| 
                                                                                         (cons 
                                                                                          "sqrt" 
                                                                                          (cons 
                                                                                           :|Fn| 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             '(:|Double|) 
                                                                                             nil) 
                                                                                            '(:|Double|))))) 
                                                                                        (cons 
                                                                                         (CGEN::termToCExp 
                                                                                          pV1856) 
                                                                                         nil)))) 
                                                                                     (if (string=  
                                                                                          "exp" 
                                                                                          pV1869) 
                                                                                         (return 
                                                                                          (cons 
                                                                                           :|Apply| 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             :|Var| 
                                                                                             (cons 
                                                                                              "exp" 
                                                                                              (cons 
                                                                                               :|Fn| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 '(:|Double|) 
                                                                                                 nil) 
                                                                                                '(:|Double|))))) 
                                                                                            (cons 
                                                                                             (CGEN::termToCExp 
                                                                                              pV1856) 
                                                                                             nil)))) 
                                                                                         (if (string=  
                                                                                              "abs" 
                                                                                              pV1869) 
                                                                                             (return 
                                                                                              (cons 
                                                                                               :|Apply| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 :|Var| 
                                                                                                 (cons 
                                                                                                  "fabs" 
                                                                                                  (cons 
                                                                                                   :|Fn| 
                                                                                                   (cons 
                                                                                                    (cons 
                                                                                                     '(:|Double|) 
                                                                                                     nil) 
                                                                                                    '(:|Double|))))) 
                                                                                                (cons 
                                                                                                 (CGEN::termToCExp 
                                                                                                  pV1856) 
                                                                                                 nil)))))))) 
                                                                             (if (string=  
                                                                                  "Functions" 
                                                                                  pV1868) 
                                                                                 (if (string=  
                                                                                      "id" 
                                                                                      pV1869) 
                                                                                     (return 
                                                                                      (CGEN::termToCExp 
                                                                                       pV1856)))))))))))) 
                                                   (return 
                                                    (let ((cFun 
                                                           (CGEN::funToCExp-1-1 
                                                            pV1860 
                                                            (svref pV1858 1)))) 
                                                      (let ((cArgs 
                                                             (applyArgsToCExps 
                                                              pV1856))) 
                                                        (block 
                                                         nil 
                                                         (if (eq 
                                                              (car cFun) 
                                                              :|Binary|) 
                                                             (return 
                                                              (if (BOOLEAN-SPEC::~ 
                                                                   ( =  
                                                                    (LIST-SPEC::|!length| 
                                                                     cArgs) 
                                                                    2)) 
                                                                  (SYSTEM-SPEC::fail 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     "trying to apply a binary operator to " 
                                                                     (NAT-SPEC::natToString 
                                                                      (LIST-SPEC::|!length| 
                                                                       cArgs))) 
                                                                    " arguments.")) 
                                                                  (cons 
                                                                   :|Apply| 
                                                                   (cons 
                                                                    cFun 
                                                                    cArgs)))) 
                                                             (if (eq 
                                                                  (car cFun) 
                                                                  :|Unary|) 
                                                                 (return 
                                                                  (if (BOOLEAN-SPEC::~ 
                                                                       ( =  
                                                                        (LIST-SPEC::|!length| 
                                                                         cArgs) 
                                                                        1)) 
                                                                      (SYSTEM-SPEC::fail 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         "trying to apply a unary operator to " 
                                                                         (NAT-SPEC::natToString 
                                                                          (LIST-SPEC::|!length| 
                                                                           cArgs))) 
                                                                        " arguments.")) 
                                                                      (cons 
                                                                       :|Apply| 
                                                                       (cons 
                                                                        cFun 
                                                                        cArgs)))))) 
                                                         (return 
                                                          (cons 
                                                           :|Apply| 
                                                           (cons cFun cArgs)))))))))))) 
                                (return 
                                 (let ((cFun (CGEN::termToCExp pV1855))) 
                                   (let ((cArgs (applyArgsToCExps pV1856))) 
                                     (cons :|Apply| (cons cFun cArgs)))))))))))) 
     (return 
      (progn (STRING-SPEC::writeLine 
              (STRING-SPEC::^ 
               "termToCExp: term is neither a constant nor an application: " 
               (ANNSPECPRINTER::printTerm term))) 
             '(:|Nop|))))))
                           
(defun CGEN::generateCFunctions-1-1 (cSpec spc) 
  (labels 
    ((doOp (pV1548 pV1549 pV1550 pV1551) 
      (block 
       nil 
       (let ((pV1555 (svref pV1550 3))) 
         (return 
          (block 
           nil 
           (if (eq (car pV1555) :|None|) 
               (return pV1551) 
               (if (eq (car pV1555) :|Some|) 
                   (return 
                    (funcall (funcall (funcall (toCFunc pV1551) 
                                               (CGEN::showQualifiedId 
                                                (cons 
                                                 :|Qualified| 
                                                 (cons pV1548 pV1549)))) 
                                      (cdr pV1555)) 
                             (cdr (svref pV1550 2)))))) 
           (error "Nonexhaustive match failure in generateCFunctions")))) 
       (error "Nonexhaustive match failure in generateCFunctions")))
     (toCFunc (cSpec) 
      #'(lambda (name) 
         #'(lambda (trm) 
            #'(lambda (srt) 
               (block 
                nil 
                (if (eq (car trm) :|Lambda|) 
                    (let ((pV1541 (car (cdr trm)))) 
                      (if (consp pV1541) 
                          (let ((pV1544 (car pV1541))) 
                            (if (null (cdr pV1541)) 
                                (return 
                                 (let ((pV1528 (svref pV1544 0))
                                       (pV1530 (svref pV1544 2))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV1528) :|VarPat|) 
                                        (let ((pV1535 (car (cdr pV1528)))) 
                                          (return 
                                           (CGEN::addFuncDefn-1-1-1-1-1 
                                            cSpec 
                                            name 
                                            (cons 
                                             (cons 
                                              (car pV1535) 
                                              (CGEN::sortToCType (cdr pV1535))) 
                                             nil) 
                                            (CGEN::sortToCType 
                                             (CGEN::codSort-1-1 spc srt)) 
                                            (cons 
                                             :|Return| 
                                             (CGEN::termToCExp pV1530))))) 
                                        (if (eq (car pV1528) :|RecordPat|) 
                                            (let ((pV1533 (car (cdr pV1528)))) 
                                              (return 
                                               (labels 
                                                 ((fieldToVarDecl (pV1518 pat) 
                                                   (declare (ignore pV1518)) 
                                                   (declare (ignore pV1518)) 
                                                   (block 
                                                    nil 
                                                    (if (eq (car pat) :|VarPat|) 
                                                        (let ((pV1523 
                                                               (car (cdr pat)))) 
                                                          (return 
                                                           (cons 
                                                            (car pV1523) 
                                                            (CGEN::sortToCType 
                                                             (cdr pV1523)))))) 
                                                    (return 
                                                     (SYSTEM-SPEC::fail 
                                                      "generateCFunctions: record field not a var pat"))))) 
                                                 (CGEN::addFuncDefn-1-1-1-1-1 
                                                  cSpec 
                                                  name 
                                                  (LIST-SPEC::|!map|-1-1 
                                                   #'(lambda (x1) 
                                                      (fieldToVarDecl 
                                                       (car x1) 
                                                       (cdr x1))) 
                                                   pV1533) 
                                                  (CGEN::sortToCType 
                                                   (CGEN::codSort-1-1 spc srt)) 
                                                  (cons 
                                                   :|Return| 
                                                   (CGEN::termToCExp pV1530)))))))) 
                                    (return 
                                     (SYSTEM-SPEC::fail 
                                      (STRING-SPEC::^ 
                                       (STRING-SPEC::^ 
                                        (STRING-SPEC::^ 
                                         (STRING-SPEC::^ 
                                          "generateCFunctions: operator " 
                                          name) 
                                         " is not a function: '") 
                                        (ANNSPECPRINTER::printTerm trm)) 
                                       "'"))))))))))) 
                (return 
                 (CGEN::addFuncDefn-1-1-1-1-1 
                  cSpec 
                  name 
                  nil 
                  (CGEN::sortToCType srt) 
                  (cons :|Return| (CGEN::termToCExp trm)))))))))) 
    (foldriAQualifierMap-1-1-1 
     #'(lambda (x) (doOp (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
     cSpec 
     (svref spc 1))))
                     
(defun CGEN::generateCFunctions-1 (x1) 
  #'(lambda (x2) (CGEN::generateCFunctions-1-1 x1 x2)))
                                                       
(defun CGEN::generateCFunctions (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::generateCFunctions-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                              
(defun CGEN::generateCTypes-1-1 (cSpec spc) 
  (labels 
    ((doSort (pV1593 pV1594 pV1595 pV1596) 
      (block 
       nil 
       (let ((pV1599 (svref pV1595 2))) 
         (return 
          (block 
           nil 
           (if (eq (car pV1599) :|None|) 
               (return pV1596) 
               (if (eq (car pV1599) :|Some|) 
                   (return 
                    (funcall (funcall (makeCType pV1596) 
                                      (CGEN::showQualifiedId 
                                       (cons :|Qualified| (cons pV1593 pV1594)))) 
                             (cdr pV1599))))) 
           (error "Nonexhaustive match failure in generateCTypes")))) 
       (error "Nonexhaustive match failure in generateCTypes")))
     (makeCType (cSpec) 
      #'(lambda (name) 
         #'(lambda (srt) 
            (block 
             nil 
             (if (eq (car srt) :|Arrow|) 
                 (return 
                  (CGEN::addTypeDefn-1-1-1 cSpec name (CGEN::sortToCType srt))) 
                 (if (eq (car srt) :|Subsort|) 
                     (return 
                      (funcall (funcall (makeCType cSpec) name) 
                               (svref (cdr srt) 0))) 
                     (if (eq (car srt) :|Product|) 
                         (return 
                          (CGEN::addStruct-1-1-1 
                           cSpec 
                           name 
                           (LIST-SPEC::|!map|-1-1 
                            #'(lambda (x) 
                               (cons (car x) (CGEN::sortToCType (cdr x)))) 
                            (car (cdr srt))))) 
                         (if (eq (car srt) :|Base|) 
                             (let ((pV1567 (cdr srt))) 
                               (let ((pV1571 (svref pV1567 0))
                                     (pV1572 (svref pV1567 1))) 
                                 (progn (if (null pV1572) 
                                            (return 
                                             (CGEN::addTypeDefn-1-1-1 
                                              cSpec 
                                              name 
                                              (CGEN::baseSortToCType pV1571)))) 
                                        (if (eq (car pV1571) :|Qualified|) 
                                            (let ((pV1574 (cdr pV1571))) 
                                              (let ((pV1575 (car pV1574))
                                                    (pV1576 (cdr pV1574))) 
                                                (if (string=  "Array" pV1575) 
                                                    (if (string=  "Array" pV1576) 
                                                        (if (consp pV1572) 
                                                            (if (null 
                                                                 (cdr pV1572)) 
                                                                (return 
                                                                 (CGEN::addTypeDefn-1-1-1 
                                                                  cSpec 
                                                                  name 
                                                                  (cons 
                                                                   :|Array| 
                                                                   (CGEN::sortToCType 
                                                                    (car pV1572)))))))) 
                                                    (if (string=  "Store" pV1575) 
                                                        (if (string=  
                                                             "Ptr" 
                                                             pV1576) 
                                                            (if (consp pV1572) 
                                                                (if (null 
                                                                     (cdr pV1572)) 
                                                                    (return 
                                                                     (CGEN::addTypeDefn-1-1-1 
                                                                      cSpec 
                                                                      name 
                                                                      (cons 
                                                                       :|Ptr| 
                                                                       (CGEN::sortToCType 
                                                                        (car 
                                                                         pV1572)))))))))))))))))))) 
             (return 
              (progn (STRING-SPEC::writeLine 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        "generateCTypes: unsupported sort: " 
                        (ANNSPECPRINTER::printSort srt)) 
                       "
")) 
                     cSpec))))))) 
    (CGEN::addTypeDefn-1-1-1 
     (foldriAQualifierMap-1-1-1 
      #'(lambda (x) (doSort (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
      cSpec 
      (svref spc 3)) 
     "bool" 
     '(:|Int|))))
                 
(defun CGEN::generateCTypes-1 (x1) 
  #'(lambda (x2) (CGEN::generateCTypes-1-1 x1 x2)))
                                                   
(defun CGEN::generateCTypes (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::generateCTypes-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                          
(defun CGEN::generateCVars-1-1 (cSpec spc) 
  (labels 
    ((doOp (pV1603 pV1604 pV1605 pV1606) 
      (block 
       nil 
       (let ((pV1610 (svref pV1605 3))) 
         (return 
          (block 
           nil 
           (if (eq (car pV1610) :|None|) 
               (return 
                (CGEN::addVarDecl-1-1-1 
                 pV1606 
                 (CGEN::showQualifiedId (cons :|Qualified| (cons pV1603 pV1604))) 
                 (CGEN::sortToCType (cdr (svref pV1605 2))))) 
               (if (eq (car pV1610) :|Some|) (return pV1606))) 
           (error "Nonexhaustive match failure in generateCVars")))) 
       (error "Nonexhaustive match failure in generateCVars")))) 
    (foldriAQualifierMap-1-1-1 
     #'(lambda (x) (doOp (svref x 0) (svref x 1) (svref x 2) (svref x 3))) 
     cSpec 
     (svref spc 1))))
                     
(defun CGEN::generateCVars-1 (x1) 
  #'(lambda (x2) (CGEN::generateCVars-1-1 x1 x2)))
                                                  
(defun CGEN::generateCVars (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::generateCVars-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                         
(defun CGEN::parens-1 (p) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (PRETTYPRINT::|!string| "(") 
    (cons p (cons (PRETTYPRINT::|!string| ")") nil)))))
                                                       
(defun CGEN::parens (x0 x1) (CGEN::parens-1 (cons x0 x1)))
                                                          
(defun CGEN::ppBaseType (s p) 
  (PRETTYPRINT::prettysNone (cons (PRETTYPRINT::|!string| s) (cons p nil))))
                                                                            
(defun PRETTYPRINT::emptyPretty () (PRETTYPRINT::|!string| ""))
                                                               
(defun CGEN::ppPlainType (|!t|) (CGEN::ppType |!t| (PRETTYPRINT::emptyPretty)))
                                                                               
(defun CGEN::ppPlainTypes (ts) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'CGEN::ppPlainType ts)))
                                                   
(defun CGEN::ppType (|!t| p) 
  (block 
   nil 
   (if (eq (car |!t|) :|Void|) 
       (return (CGEN::ppBaseType "void" p)) 
       (if (eq (car |!t|) :|Char|) 
           (return (CGEN::ppBaseType "char" p)) 
           (if (eq (car |!t|) :|ConstField|) 
               (return (CGEN::ppBaseType "ConstField" p)) 
               (if (eq (car |!t|) :|Short|) 
                   (return (CGEN::ppBaseType "short" p)) 
                   (if (eq (car |!t|) :|Int|) 
                       (return (CGEN::ppBaseType "int" p)) 
                       (if (eq (car |!t|) :|Long|) 
                           (return (CGEN::ppBaseType "long" p)) 
                           (if (eq (car |!t|) :|UnsignedChar|) 
                               (return (CGEN::ppBaseType "unsigned char" p)) 
                               (if (eq (car |!t|) :|UnsignedShort|) 
                                   (return (CGEN::ppBaseType "unsigned short" p)) 
                                   (if (eq (car |!t|) :|UnsignedInt|) 
                                       (return 
                                        (CGEN::ppBaseType "unsigned int" p)) 
                                       (if (eq (car |!t|) :|UnsignedLong|) 
                                           (return 
                                            (CGEN::ppBaseType "unsigned long" p)) 
                                           (if (eq (car |!t|) :|Float|) 
                                               (return 
                                                (CGEN::ppBaseType "float" p)) 
                                               (if (eq (car |!t|) :|Double|) 
                                                   (return 
                                                    (CGEN::ppBaseType "double" p)) 
                                                   (if (eq 
                                                        (car |!t|) 
                                                        :|LongDouble|) 
                                                       (return 
                                                        (CGEN::ppBaseType 
                                                         "long double" 
                                                         p)) 
                                                       (if (eq 
                                                            (car |!t|) 
                                                            :|Base|) 
                                                           (return 
                                                            (CGEN::ppBaseType 
                                                             (cdr |!t|) 
                                                             p)) 
                                                           (if (eq 
                                                                (car |!t|) 
                                                                :|Struct|) 
                                                               (return 
                                                                (PRETTYPRINT::prettysNone 
                                                                 (cons 
                                                                  (PRETTYPRINT::|!string| 
                                                                   "struct ") 
                                                                  (cons 
                                                                   (PRETTYPRINT::|!string| 
                                                                    (cdr |!t|)) 
                                                                   (cons p nil))))) 
                                                               (if (eq 
                                                                    (car |!t|) 
                                                                    :|Union|) 
                                                                   (return 
                                                                    (PRETTYPRINT::prettysNone 
                                                                     (cons 
                                                                      (PRETTYPRINT::|!string| 
                                                                       "union ") 
                                                                      (cons 
                                                                       (PRETTYPRINT::|!string| 
                                                                        (cdr 
                                                                         |!t|)) 
                                                                       (cons 
                                                                        p 
                                                                        nil))))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         |!t|) 
                                                                        :|Ptr|) 
                                                                       (return 
                                                                        (CGEN::ppType 
                                                                         (cdr 
                                                                          |!t|) 
                                                                         (PRETTYPRINT::prettysNone 
                                                                          (cons 
                                                                           (PRETTYPRINT::|!string| 
                                                                            "*") 
                                                                           (cons 
                                                                            p 
                                                                            (cons 
                                                                             (PRETTYPRINT::|!string| 
                                                                              "") 
                                                                             nil)))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             |!t|) 
                                                                            :|Array|) 
                                                                           (return 
                                                                            (CGEN::ppType 
                                                                             (cdr 
                                                                              |!t|) 
                                                                             (PRETTYPRINT::prettysNone 
                                                                              (cons 
                                                                               (PRETTYPRINT::|!string| 
                                                                                "(") 
                                                                               (cons 
                                                                                p 
                                                                                (cons 
                                                                                 (PRETTYPRINT::|!string| 
                                                                                  "[])") 
                                                                                 nil)))))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 |!t|) 
                                                                                :|Fn|) 
                                                                               (let ((pV1738 
                                                                                      (cdr 
                                                                                       |!t|))) 
                                                                                 (return 
                                                                                  (CGEN::ppType 
                                                                                   (cdr 
                                                                                    pV1738) 
                                                                                   (PRETTYPRINT::prettysNone 
                                                                                    (cons 
                                                                                     p 
                                                                                     (cons 
                                                                                      (CGEN::ppPlainTypes 
                                                                                       (car 
                                                                                        pV1738)) 
                                                                                      nil))))))))))))))))))))))))) 
   (return (CGEN::failPretty "Unexpected type to print "))))
                                                            
(defun PRETTYPRINT::strings (ss) 
  (PRETTYPRINT::prettysNone (LIST-SPEC::|!map|-1-1 #'PRETTYPRINT::|!string| ss)))


(defun CGEN::ppArg (s |!t|) 
  (CGEN::ppType |!t| (PRETTYPRINT::strings (cons " " (cons s nil)))))
                                                                     
(defun CGEN::ppArg-1 (x) (CGEN::ppArg (car x) (cdr x)))
                                                       
(defun CGEN::ppArgs (vds) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'CGEN::ppArg-1 vds)))
                                                
(defun CGEN::ppBinary (b) (PRETTYPRINT::|!string| (CGEN::binaryToString b)))
                                                                            
(defun CGEN::ppQuoteString (s) 
  (labels 
    ((ppQuoteCharList (clist) 
      (block 
       nil 
       (if (null clist) 
           (return nil) 
           (if (consp clist) 
               (let ((pV1714 (cdr clist))
                     (pV1713 (car clist))) 
                 (progn (if (eq #\" pV1713) 
                            (return 
                             (LIST-SPEC::concat 
                              (cons #\\ (cons #\" nil)) 
                              (ppQuoteCharList pV1714)))) 
                        (return 
                         (LIST-SPEC::|!cons| pV1713 (ppQuoteCharList pV1714))))))) 
       (error "Nonexhaustive match failure in ppQuoteString")))) 
    (STRING-SPEC::implode (ppQuoteCharList (STRING-SPEC::explode s)))))
                                                                       
(defun CGEN::ppConst (v) 
  (block 
   nil 
   (if (eq (car v) :|Char|) 
       (return 
        (PRETTYPRINT::strings 
         (cons "'" (cons (CHAR-SPEC::toString (cdr v)) (cons "'" nil))))) 
       (if (eq (car v) :|Int|) 
           (let ((pV1628 (cdr v))) 
             (return 
              (PRETTYPRINT::strings 
               (cons 
                (if (car pV1628) "" "-") 
                (cons (NAT-SPEC::toString (cdr pV1628)) nil))))) 
           (if (eq (car v) :|Float|) 
               (let ((pV1627 (cdr v))) 
                 (return 
                  (PRETTYPRINT::strings 
                   (cons 
                    (if (svref pV1627 0) "" "-") 
                    (cons 
                     (NAT-SPEC::toString (svref pV1627 1)) 
                     (cons "." (cons (NAT-SPEC::toString (svref pV1627 2)) nil))))))) 
               (if (eq (car v) :|String|) 
                   (return 
                    (PRETTYPRINT::strings 
                     (cons "" (cons (CGEN::ppQuoteString (cdr v)) (cons "" nil))))))))) 
   (return (CGEN::failPretty "Unexpected const to print"))))
                                                            
(defun CGEN::ppExpRec (e inOneLine) 
  (block 
   nil 
   (if (eq (car e) :|Const|) 
       (return (CGEN::ppExp_internal e inOneLine)) 
       (if (eq (car e) :|Var|) 
           (return (CGEN::ppExp_internal e inOneLine)) 
           (if (eq (car e) :|Fn|) (return (CGEN::ppExp_internal e inOneLine))))) 
   (return (CGEN::parens-1 (CGEN::ppExp_internal e inOneLine)))))
                                                                 
(defun PRETTYPRINT::prettysNoneDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysNone delims ps))
                                                                              
(defun CGEN::ppExpsInOneline (es) 
  (PRETTYPRINT::prettysNoneDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'(lambda (e) (CGEN::ppExp_internal e t)) es)))
                                                                         
(defun CGEN::ppUnary (u) 
  (PRETTYPRINT::|!string| 
   (block 
    nil 
    (if (eq (car u) :|Contents|) 
        (return "*") 
        (if (eq (car u) :|Address|) 
            (return "&") 
            (if (eq (car u) :|Negate|) 
                (return "-") 
                (if (eq (car u) :|BitNot|) 
                    (return "~") 
                    (if (eq (car u) :|LogNot|) 
                        (return "!") 
                        (if (eq (car u) :|PreInc|) 
                            (return "++") 
                            (if (eq (car u) :|PreDec|) 
                                (return "--") 
                                (if (eq (car u) :|PostInc|) 
                                    (return "++") 
                                    (if (eq (car u) :|PostDec|) (return "--")))))))))) 
    (return (CGEN::fail "Unexpected unary")))))
                                               
(defun CGEN::unaryPrefix? (u) 
  (block 
   nil 
   (if (eq (car u) :|PostInc|) 
       (return nil) 
       (if (eq (car u) :|PostDec|) (return nil))) 
   (return t)))
               
(defun CGEN::ppExp_internal (e inOneLine) 
  (let ((prettysFill_ 
         (if inOneLine #'PRETTYPRINT::prettysNone #'PRETTYPRINT::prettysFill))) 
    (let ((prettysLinear 
           (if inOneLine #'PRETTYPRINT::prettysNone #'PRETTYPRINT::prettysLinear))) 
      (block 
       nil 
       (if (eq (car e) :|Const|) 
           (return (CGEN::ppConst (cdr e))) 
           (if (eq (car e) :|Fn|) 
               (return (PRETTYPRINT::|!string| (svref (cdr e) 0))) 
               (if (eq (car e) :|Var|) 
                   (return (PRETTYPRINT::|!string| (car (cdr e)))) 
                   (if (eq (car e) :|Apply|) 
                       (let ((pV1655 (cdr e))) 
                         (let ((pV1683 (cdr pV1655))
                               (pV1682 (car pV1655))) 
                           (progn (if (eq (car pV1682) :|Unary|) 
                                      (let ((pV1685 (cdr pV1682))) 
                                        (if (consp pV1683) 
                                            (let ((pV1699 (car pV1683))) 
                                              (if (null (cdr pV1683)) 
                                                  (return 
                                                   (PRETTYPRINT::prettysNone 
                                                    (if (CGEN::unaryPrefix? 
                                                         pV1685) 
                                                        (cons 
                                                         (CGEN::ppUnary pV1685) 
                                                         (cons 
                                                          (CGEN::ppExpRec 
                                                           pV1699 
                                                           inOneLine) 
                                                          nil)) 
                                                        (cons 
                                                         (CGEN::ppExpRec 
                                                          pV1699 
                                                          inOneLine) 
                                                         (cons 
                                                          (CGEN::ppUnary pV1685) 
                                                          nil))))))))) 
                                      (if (eq (car pV1682) :|Binary|) 
                                          (let ((pV1684 (cdr pV1682))) 
                                            (progn (if (eq (car pV1684) :|Set|) 
                                                       (if (consp pV1683) 
                                                           (let ((pV1694 
                                                                  (cdr pV1683))) 
                                                             (if (consp pV1694) 
                                                                 (if (null 
                                                                      (cdr 
                                                                       pV1694)) 
                                                                     (return 
                                                                      (funcall prettysFill_ 
                                                                               (cons 
                                                                                (CGEN::ppExp_internal 
                                                                                 (car 
                                                                                  pV1683) 
                                                                                 inOneLine) 
                                                                                (cons 
                                                                                 (CGEN::ppBinary 
                                                                                  '(:|Set|)) 
                                                                                 (cons 
                                                                                  (CGEN::ppExp_internal 
                                                                                   (car 
                                                                                    pV1694) 
                                                                                   inOneLine) 
                                                                                  nil)))))))))) 
                                                   (if (consp pV1683) 
                                                       (let ((pV1688 
                                                              (cdr pV1683))) 
                                                         (if (consp pV1688) 
                                                             (if (null 
                                                                  (cdr pV1688)) 
                                                                 (return 
                                                                  (funcall prettysFill_ 
                                                                           (cons 
                                                                            (CGEN::ppExpRec 
                                                                             (car 
                                                                              pV1683) 
                                                                             inOneLine) 
                                                                            (cons 
                                                                             (CGEN::ppBinary 
                                                                              pV1684) 
                                                                             (cons 
                                                                              (CGEN::ppExpRec 
                                                                               (car 
                                                                                pV1688) 
                                                                               inOneLine) 
                                                                              nil))))))))))))) 
                                  (return 
                                   (funcall prettysFill_ 
                                            (cons 
                                             (CGEN::ppExp_internal 
                                              pV1682 
                                              inOneLine) 
                                             (cons 
                                              (PRETTYPRINT::prettysNone 
                                               (cons 
                                                (PRETTYPRINT::|!string| " ") 
                                                (cons 
                                                 (CGEN::ppExpsInOneline pV1683) 
                                                 nil))) 
                                              nil))))))) 
                       (if (eq (car e) :|Cast|) 
                           (let ((pV1654 (cdr e))) 
                             (return 
                              (CGEN::parens-1 
                               (PRETTYPRINT::prettysNone 
                                (cons 
                                 (CGEN::parens-1 
                                  (CGEN::ppPlainType (car pV1654))) 
                                 (cons 
                                  (PRETTYPRINT::|!string| " ") 
                                  (cons 
                                   (CGEN::ppExp_internal (cdr pV1654) inOneLine) 
                                   nil))))))) 
                           (if (eq (car e) :|StructRef|) 
                               (let ((pV1653 (cdr e))) 
                                 (let ((pV1669 (cdr pV1653))
                                       (pV1668 (car pV1653))) 
                                   (progn (if (eq (car pV1668) :|Apply|) 
                                              (let ((pV1671 (cdr pV1668))) 
                                                (let ((pV1675 (cdr pV1671))
                                                      (pV1674 (car pV1671))) 
                                                  (if (eq (car pV1674) :|Unary|) 
                                                      (if (eq 
                                                           (car (cdr pV1674)) 
                                                           :|Contents|) 
                                                          (if (consp pV1675) 
                                                              (if (null 
                                                                   (cdr pV1675)) 
                                                                  (return 
                                                                   (PRETTYPRINT::prettysNone 
                                                                    (cons 
                                                                     (CGEN::ppExpRec 
                                                                      (car 
                                                                       pV1675) 
                                                                      inOneLine) 
                                                                     (cons 
                                                                      (PRETTYPRINT::strings 
                                                                       (cons 
                                                                        " -> " 
                                                                        (cons 
                                                                         pV1669 
                                                                         nil))) 
                                                                      nil)))))))))) 
                                              (if (eq (car pV1668) :|Var|) 
                                                  (return 
                                                   (PRETTYPRINT::prettysNone 
                                                    (cons 
                                                     (PRETTYPRINT::strings 
                                                      (cons 
                                                       (car (cdr pV1668)) 
                                                       (cons 
                                                        "." 
                                                        (cons pV1669 nil)))) 
                                                     nil))))) 
                                          (return 
                                           (PRETTYPRINT::prettysNone 
                                            (cons 
                                             (CGEN::parens-1 
                                              (CGEN::ppExp_internal 
                                               pV1668 
                                               inOneLine)) 
                                             (cons 
                                              (PRETTYPRINT::strings 
                                               (cons "." (cons pV1669 nil))) 
                                              nil))))))) 
                               (if (eq (car e) :|UnionRef|) 
                                   (let ((pV1652 (cdr e))) 
                                     (return 
                                      (PRETTYPRINT::prettysNone 
                                       (cons 
                                        (CGEN::ppExp_internal 
                                         (car pV1652) 
                                         inOneLine) 
                                        (cons 
                                         (PRETTYPRINT::strings 
                                          (cons "." (cons (cdr pV1652) nil))) 
                                         nil))))) 
                                   (if (eq (car e) :|ArrayRef|) 
                                       (let ((pV1651 (cdr e))) 
                                         (return 
                                          (PRETTYPRINT::prettysNone 
                                           (cons 
                                            (CGEN::ppExpRec 
                                             (car pV1651) 
                                             inOneLine) 
                                            (cons 
                                             (PRETTYPRINT::|!string| "[") 
                                             (cons 
                                              (CGEN::ppExp_internal 
                                               (cdr pV1651) 
                                               inOneLine) 
                                              (cons 
                                               (PRETTYPRINT::|!string| "]") 
                                               nil))))))) 
                                       (if (eq (car e) :|IfExp|) 
                                           (let ((pV1650 (cdr e))) 
                                             (return 
                                              (funcall prettysLinear 
                                                       (cons 
                                                        (PRETTYPRINT::prettysNone 
                                                         (cons 
                                                          (CGEN::ppExpRec 
                                                           (svref pV1650 0) 
                                                           inOneLine) 
                                                          (cons 
                                                           (PRETTYPRINT::|!string| 
                                                            " ? ") 
                                                           nil))) 
                                                        (cons 
                                                         (PRETTYPRINT::prettysNone 
                                                          (cons 
                                                           (CGEN::ppExpRec 
                                                            (svref pV1650 1) 
                                                            inOneLine) 
                                                           (cons 
                                                            (PRETTYPRINT::|!string| 
                                                             " : ") 
                                                            nil))) 
                                                         (cons 
                                                          (CGEN::ppExpRec 
                                                           (svref pV1650 2) 
                                                           inOneLine) 
                                                          nil)))))) 
                                           (if (eq (car e) :|Comma|) 
                                               (let ((pV1649 (cdr e))) 
                                                 (return 
                                                  (CGEN::parens-1 
                                                   (funcall prettysFill_ 
                                                            (cons 
                                                             (CGEN::ppExp_internal 
                                                              (car pV1649) 
                                                              inOneLine) 
                                                             (cons 
                                                              (PRETTYPRINT::|!string| 
                                                               ", ") 
                                                              (cons 
                                                               (CGEN::ppExp_internal 
                                                                (cdr pV1649) 
                                                                inOneLine) 
                                                               nil))))))) 
                                               (if (eq (car e) :|SizeOfType|) 
                                                   (return 
                                                    (PRETTYPRINT::prettysNone 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       "sizeof (") 
                                                      (cons 
                                                       (CGEN::ppPlainType 
                                                        (cdr e)) 
                                                       (cons 
                                                        (PRETTYPRINT::|!string| 
                                                         ")") 
                                                        nil))))) 
                                                   (if (eq (car e) :|SizeOfExp|) 
                                                       (return 
                                                        (PRETTYPRINT::prettysNone 
                                                         (cons 
                                                          (PRETTYPRINT::|!string| 
                                                           "sizeof (") 
                                                          (cons 
                                                           (CGEN::ppExp_internal 
                                                            (cdr e) 
                                                            inOneLine) 
                                                           (cons 
                                                            (PRETTYPRINT::|!string| 
                                                             ")") 
                                                            nil))))) 
                                                       (if (eq (car e) :|Nop|) 
                                                           (return 
                                                            (PRETTYPRINT::prettysNone 
                                                             nil))))))))))))))) 
       (return (CGEN::failPretty "Unexpected expression"))))))
                                                              
(defun CGEN::ppExp (e) (CGEN::ppExp_internal e nil))
                                                    
(defun CGEN::ppAxiom (e) 
  (PRETTYPRINT::prettysAll 
   (cons 
    (CGEN::ppExp e) 
    (cons (PRETTYPRINT::emptyPretty) (cons (PRETTYPRINT::emptyPretty) nil)))))
                                                                              
(defun CGEN::ppBaseType-1 (x) (CGEN::ppBaseType (car x) (cdr x)))
                                                                 
(defun CGEN::ppBlock-1 (x) (CGEN::ppBlock (car x) (cdr x)))
                                                           
(defun CGEN::ppInBlock (s) 
  (block 
   nil 
   (if (eq (car s) :|Block|) 
       (let ((pV1708 (cdr s))) 
         (return (CGEN::ppPlainBlock (car pV1708) (cdr pV1708))))) 
   (return (CGEN::ppStmt s))))
                              
(defun CGEN::ppStmt (s) 
  (block 
   nil 
   (if (eq (car s) :|Exp|) 
       (return 
        (PRETTYPRINT::prettysNone 
         (cons (CGEN::ppExp (cdr s)) (cons (PRETTYPRINT::|!string| ";") nil)))) 
       (if (eq (car s) :|Block|) 
           (return (CGEN::ppBlock-1 (cdr s))) 
           (if (eq (car s) :|IfThen|) 
               (let ((pV1724 (cdr s))) 
                 (return 
                  (PRETTYPRINT::blockAll 
                   0 
                   (cons 
                    (cons 
                     0 
                     (PRETTYPRINT::prettysNone 
                      (cons 
                       (PRETTYPRINT::|!string| "if (") 
                       (cons 
                        (CGEN::ppExp (car pV1724)) 
                        (cons (PRETTYPRINT::|!string| ") {") nil))))) 
                    (cons 
                     (cons 2 (CGEN::ppInBlock (cdr pV1724))) 
                     (cons (cons 0 (PRETTYPRINT::|!string| "}")) nil)))))) 
               (if (eq (car s) :|If|) 
                   (let ((pV1723 (cdr s))) 
                     (return 
                      (PRETTYPRINT::blockAll 
                       0 
                       (cons 
                        (cons 
                         0 
                         (PRETTYPRINT::prettysNone 
                          (cons 
                           (PRETTYPRINT::|!string| "if (") 
                           (cons 
                            (CGEN::ppExp (svref pV1723 0)) 
                            (cons (PRETTYPRINT::|!string| ") {") nil))))) 
                        (cons 
                         (cons 2 (CGEN::ppInBlock (svref pV1723 1))) 
                         (cons 
                          (cons 0 (PRETTYPRINT::|!string| "} else {")) 
                          (cons 
                           (cons 2 (CGEN::ppInBlock (svref pV1723 2))) 
                           (cons (cons 0 (PRETTYPRINT::|!string| "}")) nil)))))))) 
                   (if (eq (car s) :|Return|) 
                       (return 
                        (PRETTYPRINT::prettysNone 
                         (cons 
                          (PRETTYPRINT::|!string| "return ") 
                          (cons 
                           (CGEN::ppExp (cdr s)) 
                           (cons (PRETTYPRINT::|!string| ";") nil))))) 
                       (if (eq (car s) :|VoidReturn|) 
                           (return 
                            (PRETTYPRINT::prettysNone 
                             (cons 
                              (PRETTYPRINT::|!string| "return ") 
                              (cons (PRETTYPRINT::|!string| ";") nil)))) 
                           (if (eq (car s) :|Break|) 
                               (return (PRETTYPRINT::|!string| "break;")) 
                               (if (eq (car s) :|Nop|) 
                                   (return (PRETTYPRINT::|!string| ";")) 
                                   (if (eq (car s) :|While|) 
                                       (let ((pV1721 (cdr s))) 
                                         (return 
                                          (PRETTYPRINT::blockAll 
                                           0 
                                           (cons 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::prettysNone 
                                              (cons 
                                               (PRETTYPRINT::|!string| "while (") 
                                               (cons 
                                                (CGEN::ppExp (car pV1721)) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| ") {") 
                                                 nil))))) 
                                            (cons 
                                             (cons 
                                              2 
                                              (CGEN::ppInBlock (cdr pV1721))) 
                                             (cons 
                                              (cons 
                                               0 
                                               (PRETTYPRINT::|!string| "}")) 
                                              nil)))))) 
                                       (if (eq (car s) :|Label|) 
                                           (return 
                                            (PRETTYPRINT::strings 
                                             (cons (cdr s) (cons ":" nil)))) 
                                           (if (eq (car s) :|Goto|) 
                                               (return 
                                                (PRETTYPRINT::strings 
                                                 (cons 
                                                  "goto " 
                                                  (cons (cdr s) (cons ";" nil))))) 
                                               (if (eq (car s) :|Switch|) 
                                                   (let ((pV1718 (cdr s))) 
                                                     (return 
                                                      (PRETTYPRINT::blockAll 
                                                       0 
                                                       (cons 
                                                        (cons 
                                                         0 
                                                         (PRETTYPRINT::prettysNone 
                                                          (cons 
                                                           (PRETTYPRINT::|!string| 
                                                            "switch (") 
                                                           (cons 
                                                            (CGEN::ppExp 
                                                             (car pV1718)) 
                                                            (cons 
                                                             (PRETTYPRINT::|!string| 
                                                              ") {") 
                                                             nil))))) 
                                                        (cons 
                                                         (cons 
                                                          2 
                                                          (CGEN::ppStmts 
                                                           (cdr pV1718))) 
                                                         (cons 
                                                          (cons 
                                                           0 
                                                           (PRETTYPRINT::|!string| 
                                                            "}")) 
                                                          nil)))))) 
                                                   (if (eq (car s) :|Case|) 
                                                       (return 
                                                        (PRETTYPRINT::prettysNone 
                                                         (cons 
                                                          (PRETTYPRINT::|!string| 
                                                           "case ") 
                                                          (cons 
                                                           (CGEN::ppConst 
                                                            (cdr s)) 
                                                           (cons 
                                                            (PRETTYPRINT::|!string| 
                                                             ":") 
                                                            nil)))))))))))))))))) 
   (return (CGEN::failPretty "Unexpected statement"))))
                                                       
(defun CGEN::ppStmts (ss) 
  (PRETTYPRINT::prettysAll (LIST-SPEC::|!map|-1-1 #'CGEN::ppStmt ss)))
                                                                      
(defun CGEN::ppVarDecl (s |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons (CGEN::ppArg s |!t|) (cons (PRETTYPRINT::|!string| ";") nil))))
                                                                        
(defun CGEN::ppVarDecl-1 (x) (CGEN::ppVarDecl (car x) (cdr x)))
                                                               
(defun CGEN::ppVarDecls (vds) 
  (PRETTYPRINT::prettysAll (LIST-SPEC::|!map|-1-1 #'CGEN::ppVarDecl-1 vds)))
                                                                            
(defun CGEN::ppPlainBlock (vds ss) 
  (if (LIST-SPEC::|!null| vds) 
      (CGEN::ppStmts ss) 
      (PRETTYPRINT::prettysAll 
       (cons (CGEN::ppVarDecls vds) (cons (CGEN::ppStmts ss) nil)))))
                                                                     
(defun CGEN::ppBlock (vds ss) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::|!string| "{")) 
    (cons 
     (cons 2 (CGEN::ppPlainBlock vds ss)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "}")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))
                                                         
(defun CGEN::ppDefine (s) (PRETTYPRINT::strings (cons "#define " (cons s nil))))
                                                                                
(defun CGEN::ppExtVar (s |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons (PRETTYPRINT::|!string| "extern ") (cons (CGEN::ppVarDecl s |!t|) nil))))


(defun CGEN::ppExtVar-1 (x) (CGEN::ppExtVar (car x) (cdr x)))
                                                             
(defun CGEN::ppFn (s ts |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons 
    (CGEN::ppType 
     |!t| 
     (PRETTYPRINT::prettysFill 
      (cons 
       (PRETTYPRINT::strings (cons " " (cons s (cons " " nil)))) 
       (cons (CGEN::ppPlainTypes ts) nil)))) 
    (cons (PRETTYPRINT::|!string| ";") nil))))
                                              
(defun CGEN::ppFn-1 (x) (CGEN::ppFn (svref x 0) (svref x 1) (svref x 2)))
                                                                         
(defun CGEN::ppFnDefn (s vds |!t| b) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 
     0 
     (PRETTYPRINT::prettysNone 
      (cons 
       (CGEN::ppType 
        |!t| 
        (PRETTYPRINT::prettysFill 
         (cons 
          (PRETTYPRINT::strings (cons " " (cons s (cons " " nil)))) 
          (cons (CGEN::ppArgs vds) nil)))) 
       (cons (PRETTYPRINT::|!string| " {") nil)))) 
    (cons 
     (cons 2 (CGEN::ppInBlock b)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "}")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))
                                                         
(defun CGEN::ppFnDefn-1 (x) 
  (CGEN::ppFnDefn (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                   
(defun CGEN::ppInclude (s) 
  (PRETTYPRINT::prettysAll 
   (cons 
    (PRETTYPRINT::strings (cons "#include \"" (cons s (cons "\"" nil)))) 
    (cons (PRETTYPRINT::emptyPretty) nil))))
                                            
(defun CGEN::ppStructDefn (s vds) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::strings (cons "struct " (cons s (cons " {" nil))))) 
    (cons 
     (cons 2 (CGEN::ppVarDecls vds)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "};")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))
                                                         
(defun CGEN::ppStructDefn-1 (x) (CGEN::ppStructDefn (car x) (cdr x)))
                                                                     
(defun CGEN::ppTypeDefn (s |!t|) 
  (let ((pp 
         (PRETTYPRINT::prettysNone 
          (cons 
           (PRETTYPRINT::|!string| "typedef ") 
           (cons (CGEN::ppVarDecl s |!t|) nil))))) 
    (block 
     nil 
     (if (eq (car |!t|) :|Base|) 
         (if (string=  "Any" (cdr |!t|)) 
             (return 
              (PRETTYPRINT::blockAll 
               0 
               (cons 
                (cons 
                 0 
                 (PRETTYPRINT::strings 
                  (cons 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ "#ifndef " s) 
                    "_is_externally_defined") 
                   nil))) 
                (cons 
                 (cons 0 pp) 
                 (cons (cons 0 (PRETTYPRINT::|!string| "#endif")) nil))))))) 
     (return pp))))
                   
(defun CGEN::ppTypeDefn-1 (x) (CGEN::ppTypeDefn (car x) (cdr x)))
                                                                 
(defun CGEN::ppUnionDefn (s vds) 
  (PRETTYPRINT::blockAll 
   0 
   (cons 
    (cons 0 (PRETTYPRINT::strings (cons "union " (cons s (cons " {" nil))))) 
    (cons 
     (cons 2 (CGEN::ppVarDecls vds)) 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "};")) 
      (cons (cons 0 (PRETTYPRINT::emptyPretty)) nil))))))
                                                         
(defun CGEN::ppUnionDefn-1 (x) (CGEN::ppUnionDefn (car x) (cdr x)))
                                                                   
(defun CGEN::ppVar (s |!t|) 
  (PRETTYPRINT::prettysNone 
   (cons (PRETTYPRINT::|!string| "static ") (cons (CGEN::ppVarDecl s |!t|) nil))))


(defun CGEN::ppVar-1 (x) (CGEN::ppVar (car x) (cdr x)))
                                                       
(defun CGEN::ppVarDefn (s |!t| e) 
  (if (slang-built-in::slang-term-equals e '(:|Nop|)) 
      (CGEN::ppVarDecl s |!t|) 
      (PRETTYPRINT::blockFill 
       0 
       (cons 
        (cons 
         0 
         (PRETTYPRINT::prettysNone 
          (cons 
           (PRETTYPRINT::|!string| "static ") 
           (cons 
            (CGEN::ppType |!t| (PRETTYPRINT::strings (cons " " (cons s nil)))) 
            (cons (PRETTYPRINT::|!string| " = ") nil))))) 
        (cons 
         (cons 
          2 
          (PRETTYPRINT::prettysNone 
           (cons (CGEN::ppExp e) (cons (PRETTYPRINT::|!string| ";") nil)))) 
         nil)))))
                 
(defun CGEN::ppVarDefn-1 (x) 
  (CGEN::ppVarDefn (svref x 0) (svref x 1) (svref x 2)))
                                                        
(defun CGEN::ppExpInOneLine (e) (CGEN::ppExp_internal e t))
                                                           
(defun PRETTYPRINT::newline () 
  (PRETTYPRINT::prettysAll 
   (cons (PRETTYPRINT::emptyPretty) (cons (PRETTYPRINT::emptyPretty) nil))))
                                                                            
(defun CGEN::ppVarDefnAsDefine (s pV1751 e) 
  (declare (ignore pV1751)) 
  (PRETTYPRINT::blockNone 
   0 
   (cons 
    (cons 
     0 
     (PRETTYPRINT::prettysNone 
      (cons 
       (PRETTYPRINT::|!string| "#define ") 
       (cons (PRETTYPRINT::|!string| s) (cons (PRETTYPRINT::|!string| " ") nil))))) 
    (cons 
     (cons 2 (PRETTYPRINT::prettysNone (cons (CGEN::ppExpInOneLine e) nil))) 
     (cons (cons 0 (PRETTYPRINT::newline)) nil)))))
                                                   
(defun CGEN::ppVarDefnAsDefine-1 (x) 
  (CGEN::ppVarDefnAsDefine (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun CGEN::section (title ps) 
  (if (LIST-SPEC::|!null| ps) 
      nil 
      (cons 
       (PRETTYPRINT::emptyPretty) 
       (cons (PRETTYPRINT::|!string| title) (cons (PRETTYPRINT::emptyPretty) ps)))))


(defparameter TOPSORT::mkLeaf '(:|Leaf|))
                                         
(defun TOPSORT::dfs (test g vs) 
  (let ((|!t| (HASHTABLE::initialize test (LIST-SPEC::|!length| vs)))) 
    (labels 
      ((dfsLoop (vs) 
        (block 
         nil 
         (if (null vs) 
             (return TOPSORT::mkLeaf) 
             (if (consp vs) 
                 (let ((pV9411 (cdr vs))
                       (pV9410 (car vs))) 
                   (return 
                    (if (marked pV9410) 
                        (dfsLoop pV9411) 
                        (progn (mark pV9410) 
                               (let ((ps (dfsLoop (funcall g pV9410)))) 
                                 (let ((qs (dfsLoop pV9411))) 
                                   (cons :|Node| (vector pV9410 ps qs)))))))))) 
         (error "Nonexhaustive match failure in dfs")))
       (marked (v) 
        (let ((pV9405 (HASHTABLE::lookup v |!t|))) 
          (block 
           nil 
           (if (eq (car pV9405) :|Some|) 
               (return t) 
               (if (eq (car pV9405) :|None|) (return nil))) 
           (error "Nonexhaustive match failure in dfs"))))
       (mark (v) (HASHTABLE::insert v nil |!t|))) (dfsLoop vs))))
                                                                 
(defun TOPSORT::inorderL (|!t| ls) 
  (block 
   nil 
   (if (eq (car |!t|) :|Leaf|) 
       (return ls) 
       (if (eq (car |!t|) :|Node|) 
           (let ((pV9413 (cdr |!t|))) 
             (return 
              (TOPSORT::inorderL 
               (svref pV9413 1) 
               (LIST-SPEC::|!cons| 
                (svref pV9413 0) 
                (TOPSORT::inorderL (svref pV9413 2) ls))))))) 
   (error "Nonexhaustive match failure in inorderL")))
                                                      
(defun TOPSORT::inorder (|!t|) (TOPSORT::inorderL |!t| nil))
                                                            
(defun TOPSORT::topSort (test g vs) (TOPSORT::inorder (TOPSORT::dfs test g vs)))
                                                                                
(defun CGEN::topSortTypeDefns (defns) 
  (let ((names (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) defns))) 
    (let ((sortedNames 
           (TOPSORT::topSort 
            '(:|EQUAL|) 
            #'(lambda (name) (CGEN::expand name defns)) 
            names))) (CGEN::findTypeDefns sortedNames defns))))
                                                               
(defun CGEN::ppCSpec-1 (s) 
  (let ((typeDefns (CGEN::topSortTypeDefns (svref s 8)))) 
    (let ((includes (LIST-SPEC::|!map|-1-1 #'CGEN::ppInclude (svref s 6)))) 
      (let ((defines (LIST-SPEC::|!map|-1-1 #'CGEN::ppDefine (svref s 2)))) 
        (let ((constDefns 
               (LIST-SPEC::|!map|-1-1 #'CGEN::ppVarDefnAsDefine-1 (svref s 1)))) 
          (let ((typeDefns 
                 (LIST-SPEC::|!map|-1-1 #'CGEN::ppTypeDefn-1 typeDefns))) 
            (let ((structDefns 
                   (LIST-SPEC::|!map|-1-1 #'CGEN::ppStructDefn-1 (svref s 7)))) 
              (let ((unionDefns 
                     (LIST-SPEC::|!map|-1-1 #'CGEN::ppUnionDefn-1 (svref s 9)))) 
                (let ((vars (LIST-SPEC::|!map|-1-1 #'CGEN::ppVar-1 (svref s 11)))) 
                  (let ((extVars 
                         (LIST-SPEC::|!map|-1-1 #'CGEN::ppExtVar-1 (svref s 3)))) 
                    (let ((fns 
                           (LIST-SPEC::|!map|-1-1 #'CGEN::ppFn-1 (svref s 5)))) 
                      (let ((varDefns 
                             (LIST-SPEC::|!map|-1-1 
                              #'CGEN::ppVarDefn-1 
                              (svref s 10)))) 
                        (let ((fnDefns 
                               (LIST-SPEC::|!map|-1-1 
                                #'CGEN::ppFnDefn-1 
                                (svref s 4)))) 
                          (let ((axioms 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'CGEN::ppAxiom 
                                  (svref s 0)))) 
                            (PRETTYPRINT::prettysAll 
                             (LIST-SPEC::|!++| 
                              (LIST-SPEC::|!++| 
                               (LIST-SPEC::|!++| 
                                (LIST-SPEC::|!++| 
                                 (LIST-SPEC::|!++| 
                                  (LIST-SPEC::|!++| 
                                   (LIST-SPEC::|!++| 
                                    (LIST-SPEC::|!++| 
                                     (LIST-SPEC::|!++| 
                                      (LIST-SPEC::|!++| 
                                       (LIST-SPEC::|!++| 
                                        (LIST-SPEC::|!++| 
                                         (LIST-SPEC::|!++| 
                                          (CGEN::section "/* C spec */" nil) 
                                          (CGEN::section 
                                           "/* Include files */" 
                                           includes)) 
                                         (CGEN::section 
                                          "/* Definitions */" 
                                          defines)) 
                                        (CGEN::section 
                                         "/* Constant Definitions */" 
                                         constDefns)) 
                                       (CGEN::section "/* Types */" typeDefns)) 
                                      (CGEN::section "/* Unions */" unionDefns)) 
                                     (CGEN::section "/* Structs */" structDefns)) 
                                    (CGEN::section "/* Variables */" vars)) 
                                   (CGEN::section 
                                    "/* External Variables */" 
                                    extVars)) 
                                  (CGEN::section "/* Functions */" fns)) 
                                 (CGEN::section 
                                  "/* Variable definitions */" 
                                  varDefns)) 
                                (CGEN::section 
                                 "/* Function definitions */" 
                                 fnDefns)) 
                               (CGEN::section "/* Axioms */" axioms)) 
                              (cons (PRETTYPRINT::emptyPretty) nil)))))))))))))))))


(defun CGEN::ppCSpec (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) 
  (CGEN::ppCSpec-1 (vector x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11)))
                                                                   
(defun CGEN::ppCSpecAsHeader (name s) 
  (let ((defname 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           "__METASLANG_" 
           (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase name)) 
          "_H"))) 
    (PRETTYPRINT::prettysAll 
     (LIST-SPEC::|!++| 
      (LIST-SPEC::|!++| 
       (LIST-SPEC::|!++| 
        (LIST-SPEC::|!++| 
         (LIST-SPEC::|!++| 
          (cons (PRETTYPRINT::emptyPretty) nil) 
          (cons (PRETTYPRINT::strings (cons "#ifndef " (cons defname nil))) nil)) 
         (cons (PRETTYPRINT::strings (cons "#define " (cons defname nil))) nil)) 
        (cons (CGEN::ppCSpec-1 s) nil)) 
       (cons (PRETTYPRINT::|!string| "#endif") nil)) 
      (cons (PRETTYPRINT::emptyPretty) nil)))))
                                               
(defun CGEN::ppCSpecAsHeader-1 (x) (CGEN::ppCSpecAsHeader (car x) (cdr x)))
                                                                           
(defun CGEN::ppDeclsWithoutDefns (decls) 
  (block 
   nil 
   (if (null decls) (return (PRETTYPRINT::emptyPretty))) 
   (return 
    (PRETTYPRINT::prettysAll 
     (LIST-SPEC::|!++| 
      (LIST-SPEC::|!++| 
       (LIST-SPEC::|!++| 
        (LIST-SPEC::|!++| 
         (cons (PRETTYPRINT::emptyPretty) nil) 
         (cons 
          (PRETTYPRINT::|!string| 
           "/* no code has been generated for the following functions: ") 
          nil)) 
        (LIST-SPEC::|!map|-1-1 #'CGEN::ppFn-1 decls)) 
       (cons (PRETTYPRINT::emptyPretty) nil)) 
      (cons (PRETTYPRINT::|!string| "*/") nil))))))
                                                   
(defun CGEN::ppExpRec-1 (x) (CGEN::ppExpRec (car x) (cdr x)))
                                                             
(defun CGEN::ppExp_internal-1 (x) (CGEN::ppExp_internal (car x) (cdr x)))
                                                                         
(defun CGEN::ppExps (es) 
  (PRETTYPRINT::prettysLinearDelim-1-1 
   (vector "(" ", " ")") 
   (LIST-SPEC::|!map|-1-1 #'CGEN::ppExp es)))
                                             
(defun CGEN::ppFnDefnAppendFile (fndefn filename) 
  (let ((fnPretty (CGEN::ppFnDefn-1 fndefn))) 
    (PRETTYPRINT::appendFile filename (PRETTYPRINT::|!format| 80 fnPretty))))
                                                                             
(defun CGEN::ppFnDefnAppendFile-1 (x) 
  (CGEN::ppFnDefnAppendFile (car x) (cdr x)))
                                             
(defun CGEN::ppPlainBlock-1 (x) (CGEN::ppPlainBlock (car x) (cdr x)))
                                                                     
(defun CGEN::ppType-1 (x) (CGEN::ppType (car x) (cdr x)))
                                                         
(defun CGEN::section-1 (x) (CGEN::section (car x) (cdr x)))
                                                           
(defun CGEN::termToCStmt (trm) 
  (block 
   nil 
   (if (eq (car trm) :|Apply|) 
       (let ((pV1906 (cdr trm))) 
         (let ((pV1908 (svref pV1906 1))
               (pV1907 (svref pV1906 0))) 
           (if (eq (car pV1907) :|Fun|) 
               (if (eq (car (svref (cdr pV1907) 0)) :|Equals|) 
                   (if (eq (car pV1908) :|Record|) 
                       (let ((pV1915 (car (cdr pV1908)))) 
                         (if (consp pV1915) 
                             (let ((pV1919 (cdr pV1915))
                                   (pV1918 (car pV1915))) 
                               (if (string=  "1" (car pV1918)) 
                                   (if (consp pV1919) 
                                       (let ((pV1923 (car pV1919))) 
                                         (if (string=  "2" (car pV1923)) 
                                             (if (null (cdr pV1919)) 
                                                 (return 
                                                  (cons 
                                                   :|Exp| 
                                                   (cons 
                                                    :|Apply| 
                                                    (cons 
                                                     (cons :|Binary| '(:|Set|)) 
                                                     (cons 
                                                      (CGEN::termToCExp 
                                                       (cdr pV1918)) 
                                                      (cons 
                                                       (CGEN::termToCExp 
                                                        (cdr pV1923)) 
                                                       nil)))))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "termToCStmt: term '" (ANNSPECPRINTER::printTerm trm)) 
      "' is not an equality")))))
                                 
(defun CGEN::specToC-1 (spc) 
  (let ((cSpec (CGEN::generateCTypes-1-1 CGEN::emptyCSpec spc))) 
    (let ((cSpec (CGEN::generateCVars-1-1 cSpec spc))) 
      (let ((cSpec (CGEN::generateCFunctions-1-1 cSpec spc))) 
        (let ((stmt 
               (cons 
                :|Block| 
                (cons 
                 nil 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) (CGEN::termToCStmt (svref x 3))) 
                  (svref spc 2)))))) 
          (let ((cSpec 
                 (CGEN::addFuncDefn-1-1-1-1-1 cSpec "main" nil '(:|Int|) stmt))) 
            (progn (STRING-SPEC::writeLine 
                    (PRETTYPRINT::toString 
                     (PRETTYPRINT::|!format| 80 (CGEN::ppCSpec-1 cSpec)))) 
                   cSpec)))))))
                               
(defun CGEN::specToC (x0 x1 x2 x3) (CGEN::specToC-1 (vector x0 x1 x2 x3)))
                                                                          
(defun CAT::functor-1 (dgm) (car dgm))
                                      
(defun CAT::shape-1 (dgm) (cdr dgm))
                                    
(defun FUNCTOR::cod-1 (functor) (svref functor 0))
                                                  
(defun FUNCTOR::dom-1 (functor) (svref functor 1))
                                                  
(defun FUNCTOR::edgeMap-1 (functor) (svref functor 2))
                                                      
(defun FUNCTOR::vertexMap-1 (functor) (svref functor 3))
                                                        
(defun POLYSET::member?-1-1 (l x) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (return 
            (lisp::or 
             (slang-built-in::slang-term-equals (car l) x) 
             (POLYSET::member?-1-1 (cdr l) x))))) 
   (error "Nonexhaustive match failure in member?")))
                                                     
(defun POLYSET::insert-1-1 (l a) (if (POLYSET::member?-1-1 l a) l (cons a l)))
                                                                              
(defun EDGE::insert-1-1 (x0 x1) (POLYSET::insert-1-1 x0 x1))
                                                            
(defun SKETCH::edges-1 (graph) (svref graph 0))
                                               
(defun SKETCH::src-1 (graph) (svref graph 1))
                                             
(defun SKETCH::target-1 (graph) (svref graph 2))
                                                
(defun POLYMAP::update-1-1-1 (|!map| x y) 
  (block 
   nil 
   (if (null |!map|) 
       (return (cons (cons x y) nil)) 
       (if (consp |!map|) 
           (let ((pV4410 (car |!map|))
                 (pV4411 (cdr |!map|))) 
             (let ((pV4412 (car pV4410))) 
               (return 
                (if (slang-built-in::slang-term-equals x pV4412) 
                    (cons (cons x y) pV4411) 
                    (cons 
                     (cons pV4412 (cdr pV4410)) 
                     (POLYMAP::update-1-1-1 pV4411 x y)))))))) 
   (error "Nonexhaustive match failure in update")))
                                                    
(defun SKETCH::update-1-1-1 (x0 x1 x2) (POLYMAP::update-1-1-1 x0 x1 x2))
                                                                        
(defun SKETCH::vertices-1 (graph) (svref graph 3))
                                                  
(defun VERTEX::insert-1-1 (x0 x1) (POLYSET::insert-1-1 x0 x1))
                                                              
(defun SKETCH::insertEdge-1-1-1-1 (graph edge dom cod) 
  (vector 
   (EDGE::insert-1-1 (SKETCH::edges-1 graph) edge) 
   (SKETCH::update-1-1-1 (SKETCH::src-1 graph) edge dom) 
   (SKETCH::update-1-1-1 (SKETCH::target-1 graph) edge cod) 
   (VERTEX::insert-1-1 (VERTEX::insert-1-1 (SKETCH::vertices-1 graph) dom) cod)))


(defun CAT::addEdge-1-1-1-1 (dgm edge src target) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (SKETCH::insertEdge-1-1-1-1 
     (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
     edge 
     src 
     target) 
    (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm))) 
   (SKETCH::insertEdge-1-1-1-1 (CAT::shape-1 dgm) edge src target)))
                                                                    
(defun CAT::addEdge-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) #'(lambda (x4) (CAT::addEdge-1-1-1-1 x1 x2 x3 x4)))))
                                                                         
(defun CAT::addEdge (x0 x1) (CAT::addEdge-1 (cons x0 x1)))
                                                          
(defun SKETCH::insertVertex-1-1 (graph vertex) 
  (vector 
   (SKETCH::edges-1 graph) 
   (SKETCH::src-1 graph) 
   (SKETCH::target-1 graph) 
   (VERTEX::insert-1-1 (SKETCH::vertices-1 graph) vertex)))
                                                           
(defun CAT::addVertex-1-1 (dgm vertex) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (SKETCH::insertVertex-1-1 (FUNCTOR::dom-1 (CAT::functor-1 dgm)) vertex) 
    (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm))) 
   (SKETCH::insertVertex-1-1 (CAT::shape-1 dgm) vertex)))
                                                         
(defun CAT::addVertex-1 (x1) #'(lambda (x2) (CAT::addVertex-1-1 x1 x2)))
                                                                        
(defun CAT::addVertex (x0 x1) (CAT::addVertex-1 (cons x0 x1)))
                                                              
(defun CAT::apex-1 (cocone) (svref cocone 0))
                                             
(defun CAT::apex (x0 x1 x2) (CAT::apex-1 (vector x0 x1 x2)))
                                                            
(defun CAT::cocone-1 (initCocone) (car initCocone))
                                                   
(defun CAT::cocone (x0 x1) (CAT::cocone-1 (cons x0 x1)))
                                                        
(defun CAT::cod-1 (cat) (svref cat 0))
                                      
(defun CAT::cod (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::cod-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                
(defun CAT::cod-1-1 (x1 x2) (funcall (CAT::cod-1 x1) x2))
                                                         
(defun CAT::colimit-1 (cat) (svref cat 1))
                                          
(defun CAT::colimit (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::colimit-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                    
(defun CAT::colimit-1-1 (x1 x2) (funcall (CAT::colimit-1 x1) x2))
                                                                 
(defun CAT::compose-1 (cat) (svref cat 2))
                                          
(defun CAT::compose (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::compose-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                    
(defun CAT::compose-1-1-1 (x1 x2 x3) 
  (funcall (funcall (CAT::compose-1 x1) x2) x3))
                                                
(defun CAT::diagram-1 (cocone) (svref cocone 1))
                                                
(defun CAT::diagram (x0 x1 x2) (CAT::diagram-1 (vector x0 x1 x2)))
                                                                  
(defun CAT::dom-1 (cat) (svref cat 3))
                                      
(defun CAT::dom (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::dom-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                
(defun CAT::dom-1-1 (x1 x2) (funcall (CAT::dom-1 x1) x2))
                                                         
(defun EDGE::member?-1-1 (x0 x1) (POLYSET::member?-1-1 x0 x1))
                                                              
(defun CAT::edgeInDiagram?-1-1 (dgm edge) 
  (EDGE::member?-1-1 (SKETCH::edges-1 (CAT::shape-1 dgm)) edge))
                                                                
(defun CAT::edgeInDiagram?-1 (x1) 
  #'(lambda (x2) (CAT::edgeInDiagram?-1-1 x1 x2)))
                                                  
(defun CAT::edgeInDiagram? (x0 x1) (CAT::edgeInDiagram?-1 (cons x0 x1)))
                                                                        
(defun POLYMAP::|!eval|-1-1 (|!map| x) 
  (block 
   nil 
   (if (null |!map|) 
       (return (SYSTEM-SPEC::fail "inside eval")) 
       (if (consp |!map|) 
           (let ((pV4371 (car |!map|))) 
             (return 
              (if (slang-built-in::slang-term-equals x (car pV4371)) 
                  (cdr pV4371) 
                  (POLYMAP::|!eval|-1-1 (cdr |!map|) x)))))) 
   (error "Nonexhaustive match failure in eval")))
                                                  
(defun CAT::edgeLabel-1-1 (dgm edge) 
  (POLYMAP::|!eval|-1-1 (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) edge))
                                                                        
(defun CAT::edgeLabel-1 (x1) #'(lambda (x2) (CAT::edgeLabel-1-1 x1 x2)))
                                                                        
(defun CAT::edgeLabel (x0 x1) (CAT::edgeLabel-1 (cons x0 x1)))
                                                              
(defparameter POLYMAP::emptyMap nil)
                                    
(defparameter POLYSET::empty nil)
                                 
(defparameter EDGE::empty POLYSET::empty)
                                         
(defparameter SKETCH::emptyMap POLYMAP::emptyMap)
                                                 
(defparameter VERTEX::empty POLYSET::empty)
                                           
(defparameter SKETCH::emptySketch 
  (vector EDGE::empty SKETCH::emptyMap SKETCH::emptyMap VERTEX::empty))
                                                                       
(defun CAT::emptyDiagram-1 (targetCat) 
  (cons 
   (vector targetCat SKETCH::emptySketch POLYMAP::emptyMap POLYMAP::emptyMap) 
   SKETCH::emptySketch))
                        
(defun CAT::initialObject-1 (cat) (svref cat 5))
                                                
(defun FUNCTOR::makeFunctor-1-1-1-1 (sketch cat vertexMap edgeMap) 
  (vector cat sketch edgeMap vertexMap))
                                        
(defun FUNCTOR::emptyFunctor-1 (targetCat) 
  (FUNCTOR::makeFunctor-1-1-1-1 
   SKETCH::emptySketch 
   targetCat 
   POLYMAP::emptyMap 
   POLYMAP::emptyMap))
                      
(defun NATTRANS::emptyNatTrans-1 (targetCat) 
  (vector 
   (FUNCTOR::emptyFunctor-1 targetCat) 
   POLYMAP::emptyMap 
   (FUNCTOR::emptyFunctor-1 targetCat)))
                                        
(defun CAT::emptyCocone-1 (targetCat) 
  (vector 
   (CAT::initialObject-1 targetCat) 
   (CAT::emptyDiagram-1 targetCat) 
   (NATTRANS::emptyNatTrans-1 targetCat)))
                                          
(defun CAT::emptyCocone (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::emptyCocone-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                        
(defun CAT::emptyDiagram (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::emptyDiagram-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                         
(defun CAT::ident-1 (cat) (svref cat 4))
                                        
(defun CAT::ident-1-1 (x1 x2) (funcall (CAT::ident-1 x1) x2))
                                                             
(defun CAT::emptyInitialCocone-1 (targetCat) 
  (cons 
   (CAT::emptyCocone-1 targetCat) 
   #'(lambda (pV1930) 
      (declare (ignore pV1930)) 
      (CAT::ident-1-1 targetCat (CAT::initialObject-1 targetCat)))))
                                                                    
(defun CAT::emptyInitialCocone (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::emptyInitialCocone-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                               
(defun POLYSET::fold-1-1-1 (f e l) 
  (block 
   nil 
   (if (null l) 
       (return e) 
       (if (consp l) 
           (return 
            (POLYSET::fold-1-1-1 f (funcall (funcall f e) (car l)) (cdr l))))) 
   (error "Nonexhaustive match failure in fold")))
                                                  
(defun EDGE::fold-1-1-1 (x0 x1 x2) (POLYSET::fold-1-1-1 x0 x1 x2))
                                                                  
(defun CAT::foldOverEdges-1-1-1 (f acc dgm) 
  (EDGE::fold-1-1-1 f acc (SKETCH::edges-1 (CAT::shape-1 dgm))))
                                                                
(defun CAT::foldOverEdges (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::foldOverEdges-1-1-1 x1 x2 x3))))
                                                                      
(defun VERTEX::fold-1-1-1 (x0 x1 x2) (POLYSET::fold-1-1-1 x0 x1 x2))
                                                                    
(defun CAT::foldOverVertices-1-1-1 (f acc dgm) 
  (VERTEX::fold-1-1-1 f acc (SKETCH::vertices-1 (CAT::shape-1 dgm))))
                                                                     
(defun CAT::foldOverVertices (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::foldOverVertices-1-1-1 x1 x2 x3))))
                                                                         
(defun CAT::functor (x0 x1) (CAT::functor-1 (cons x0 x1)))
                                                          
(defun CAT::ident (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::ident-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                  
(defun CAT::initialObject (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::initialObject-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                          
(defun CAT::labelEdge-1-1-1 (dgm edge label) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
    (POLYMAP::update-1-1-1 (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) edge label) 
    (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm))) 
   (CAT::shape-1 dgm)))
                       
(defun CAT::labelEdge-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::labelEdge-1-1-1 x1 x2 x3))))
                                                                  
(defun CAT::labelEdge (x0 x1) (CAT::labelEdge-1 (cons x0 x1)))
                                                              
(defun CAT::labelVertex-1-1-1 (dgm vertex label) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm)) 
    (POLYMAP::update-1-1-1 
     (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm)) 
     vertex 
     label)) 
   (CAT::shape-1 dgm)))
                       
(defun CAT::labelVertex-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::labelVertex-1-1-1 x1 x2 x3))))
                                                                    
(defun CAT::labelVertex (x0 x1) (CAT::labelVertex-1 (cons x0 x1)))
                                                                  
(defun POLYMAP::mapMap-1-1 (f |!map|) 
  (block 
   nil 
   (if (null |!map|) 
       (return nil) 
       (if (consp |!map|) 
           (let ((pV4396 (car |!map|))) 
             (return 
              (cons 
               (cons (car pV4396) (funcall f (cdr pV4396))) 
               (POLYMAP::mapMap-1-1 f (cdr |!map|))))))) 
   (error "Nonexhaustive match failure in mapMap")))
                                                    
(defun CAT::mapDiagram-1-1-1 (dgm objMap arrMap) 
  (cons 
   (vector 
    (FUNCTOR::cod-1 (CAT::functor-1 dgm)) 
    (FUNCTOR::dom-1 (CAT::functor-1 dgm)) 
    (POLYMAP::mapMap-1-1 arrMap (FUNCTOR::edgeMap-1 (CAT::functor-1 dgm))) 
    (POLYMAP::mapMap-1-1 objMap (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm)))) 
   (CAT::shape-1 dgm)))
                       
(defun CAT::mapDiagram-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (CAT::mapDiagram-1-1-1 x1 x2 x3))))
                                                                   
(defun CAT::mapDiagram (x0 x1) (CAT::mapDiagram-1 (cons x0 x1)))
                                                                
(defun CAT::natTrans-1 (cocone) (svref cocone 2))
                                                 
(defun CAT::natTrans (x0 x1 x2) (CAT::natTrans-1 (vector x0 x1 x2)))
                                                                    
(defun CAT::ppArr-1 (cat) (svref cat 6))
                                        
(defun CAT::ppArr (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::ppArr-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                  
(defun CAT::ppArr-1-1 (x1 x2) (funcall (CAT::ppArr-1 x1) x2))
                                                             
(defun CAT::ppObj-1 (cat) (svref cat 7))
                                        
(defun WADLERLINDIG::ppString (s) (cons :|DocText| s))
                                                      
(defun EDGE::ppElem (x) (WADLERLINDIG::ppString x))
                                                   
(defun POLYMAP::foldMap-1-1-1 (f z |!map|) 
  (block 
   nil 
   (if (null |!map|) 
       (return z) 
       (if (consp |!map|) 
           (let ((pV4383 (car |!map|))) 
             (return 
              (POLYMAP::foldMap-1-1-1 
               f 
               (funcall (funcall (funcall f z) (car pV4383)) (cdr pV4383)) 
               (cdr |!map|)))))) 
   (error "Nonexhaustive match failure in foldMap")))
                                                     
(defun WADLERLINDIG::ppCons-1-1 (x y) 
  (block 
   nil 
   (if (eq (car x) :|DocNil|) 
       (progn (if (eq (car y) :|DocNil|) (return '(:|DocNil|))) (return y))) 
   (if (eq (car y) :|DocNil|) (return x)) 
   (return (cons :|DocCons| (cons x y)))))
                                          
(defparameter WADLERLINDIG::ppNil '(:|DocNil|))
                                               
(defun WADLERLINDIG::ppConcat (l) 
  (block 
   nil 
   (if (null l) 
       (return WADLERLINDIG::ppNil) 
       (if (consp l) 
           (return 
            (WADLERLINDIG::ppCons-1-1 (car l) (WADLERLINDIG::ppConcat (cdr l)))))) 
   (error "Nonexhaustive match failure in ppConcat")))
                                                      
(defparameter WADLERLINDIG::ppBreak (cons :|DocBreak| " "))
                                                           
(defparameter WADLERLINDIG::ppNewline WADLERLINDIG::ppBreak)
                                                            
(defun WADLERLINDIG::ppSep-1-1 (sep l) 
  (block 
   nil 
   (if (null l) 
       (return WADLERLINDIG::ppNil) 
       (if (consp l) 
           (let ((pV12291 (car l))
                 (pV12292 (cdr l))) 
             (progn (if (null pV12292) (return pV12291)) 
                    (if (eq (car pV12291) :|DocNil|) 
                        (return (WADLERLINDIG::ppSep-1-1 sep pV12292))) 
                    (return 
                     (WADLERLINDIG::ppCons-1-1 
                      pV12291 
                      (WADLERLINDIG::ppCons-1-1 
                       sep 
                       (WADLERLINDIG::ppSep-1-1 sep pV12292)))))))) 
   (error "Nonexhaustive match failure in ppSep")))
                                                   
(defun POLYMAP::ppMap-1-1-1 (ppKey ppValue |!map|) 
  (WADLERLINDIG::ppSep-1-1 
   WADLERLINDIG::ppNewline 
   (POLYMAP::foldMap-1-1-1 
    #'(lambda (l) 
       #'(lambda (dom) 
          #'(lambda (cod) 
             (cons 
              (WADLERLINDIG::ppConcat 
               (cons 
                (funcall ppKey dom) 
                (cons 
                 (WADLERLINDIG::ppString " +-> ") 
                 (cons (funcall ppValue cod) nil)))) 
              l)))) 
    nil 
    |!map|)))
             
(defun VERTEX::ppElem (x) (WADLERLINDIG::ppString x))
                                                     
(defun WADLERLINDIG::ppNest-1-1 (i x) (cons :|DocNest| (cons i x)))
                                                                   
(defun WADLERLINDIG::ppIndent (p) (WADLERLINDIG::ppNest-1-1 2 p))
                                                                 
(defun FUNCTOR::ppFunctor-1 (functor) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "Vertex Map =") 
    (cons 
     WADLERLINDIG::ppNewline 
     (cons 
      (WADLERLINDIG::ppString "  ") 
      (cons 
       (WADLERLINDIG::ppIndent 
        (POLYMAP::ppMap-1-1-1 
         #'VERTEX::ppElem 
         (CAT::ppObj-1 (FUNCTOR::cod-1 functor)) 
         (FUNCTOR::vertexMap-1 functor))) 
       (cons 
        WADLERLINDIG::ppNewline 
        (cons 
         (WADLERLINDIG::ppString "Edge Map =") 
         (cons 
          WADLERLINDIG::ppNewline 
          (cons 
           (WADLERLINDIG::ppString "  ") 
           (cons 
            (WADLERLINDIG::ppIndent 
             (POLYMAP::ppMap-1-1-1 
              #'EDGE::ppElem 
              (CAT::ppArr-1 (FUNCTOR::cod-1 functor)) 
              (FUNCTOR::edgeMap-1 functor))) 
            nil)))))))))))
                          
(defun EDGE::ppSet (|!set|) 
  (WADLERLINDIG::ppSep-1-1 
   (WADLERLINDIG::ppString ",") 
   (EDGE::fold-1-1-1 
    #'(lambda (l) #'(lambda (elem) (cons (EDGE::ppElem elem) l))) 
    nil 
    |!set|)))
             
(defun POLYMAP::mapToList (l) l)
                                
(defun SKETCH::mapToList (x) (POLYMAP::mapToList x))
                                                    
(defun VERTEX::ppSet (|!set|) 
  (WADLERLINDIG::ppSep-1-1 
   (WADLERLINDIG::ppString ",") 
   (VERTEX::fold-1-1-1 
    #'(lambda (l) #'(lambda (elem) (cons (VERTEX::ppElem elem) l))) 
    nil 
    |!set|)))
             
(defun SKETCH::ppSketch-1 (graph) 
  (labels 
    ((ppPair (x y) 
      (WADLERLINDIG::ppConcat 
       (cons 
        (EDGE::ppElem x) 
        (cons (WADLERLINDIG::ppString "|->") (cons (VERTEX::ppElem y) nil)))))) 
    (WADLERLINDIG::ppConcat 
     (cons 
      (WADLERLINDIG::ppString "Vertices = {") 
      (cons 
       (VERTEX::ppSet (SKETCH::vertices-1 graph)) 
       (cons 
        (WADLERLINDIG::ppString "}") 
        (cons 
         WADLERLINDIG::ppNewline 
         (cons 
          (WADLERLINDIG::ppString "Edges = {") 
          (cons 
           (EDGE::ppSet (SKETCH::edges-1 graph)) 
           (cons 
            (WADLERLINDIG::ppString "}") 
            (cons 
             WADLERLINDIG::ppNewline 
             (cons 
              (WADLERLINDIG::ppString "Source map = {") 
              (cons 
               (WADLERLINDIG::ppSep-1-1 
                (WADLERLINDIG::ppString ",") 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) (ppPair (car x) (cdr x))) 
                 (SKETCH::mapToList (SKETCH::src-1 graph)))) 
               (cons 
                (WADLERLINDIG::ppString "}") 
                (cons 
                 WADLERLINDIG::ppNewline 
                 (cons 
                  (WADLERLINDIG::ppString "Target map = {") 
                  (cons 
                   (WADLERLINDIG::ppSep-1-1 
                    (WADLERLINDIG::ppString ",") 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) (ppPair (car x) (cdr x))) 
                     (SKETCH::mapToList (SKETCH::target-1 graph)))) 
                   (cons (WADLERLINDIG::ppString "}") nil))))))))))))))))))
                                                                           
(defun CAT::ppDiagram-1 (dgm) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "Shape=") 
    (cons 
     WADLERLINDIG::ppNewline 
     (cons 
      (WADLERLINDIG::ppString "  ") 
      (cons 
       (WADLERLINDIG::ppIndent (SKETCH::ppSketch-1 (CAT::shape-1 dgm))) 
       (cons 
        WADLERLINDIG::ppNewline 
        (cons 
         (WADLERLINDIG::ppString "  ") 
         (cons 
          (WADLERLINDIG::ppString "Functor=") 
          (cons 
           (WADLERLINDIG::ppIndent (FUNCTOR::ppFunctor-1 (CAT::functor-1 dgm))) 
           nil))))))))))
                        
(defun CAT::ppDiagram (x0 x1) (CAT::ppDiagram-1 (cons x0 x1)))
                                                              
(defun CAT::ppObj (x0 x1 x2 x3 x4 x5 x6 x7) 
  (CAT::ppObj-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                  
(defun CAT::ppObj-1-1 (x1 x2) (funcall (CAT::ppObj-1 x1) x2))
                                                             
(defun CAT::shape (x0 x1) (CAT::shape-1 (cons x0 x1)))
                                                      
(defun CAT::universal-1 (initCocone) (cdr initCocone))
                                                      
(defun CAT::universal (x0 x1) (CAT::universal-1 (cons x0 x1)))
                                                              
(defun CAT::universal-1-1 (x1 x2) (funcall (CAT::universal-1 x1) x2))
                                                                     
(defun VERTEX::member?-1-1 (x0 x1) (POLYSET::member?-1-1 x0 x1))
                                                                
(defun CAT::vertexInDiagram?-1-1 (dgm vertex) 
  (VERTEX::member?-1-1 (SKETCH::vertices-1 (CAT::shape-1 dgm)) vertex))
                                                                       
(defun CAT::vertexInDiagram?-1 (x1) 
  #'(lambda (x2) (CAT::vertexInDiagram?-1-1 x1 x2)))
                                                    
(defun CAT::vertexInDiagram? (x0 x1) (CAT::vertexInDiagram?-1 (cons x0 x1)))
                                                                            
(defun CAT::vertexLabel-1-1 (dgm vertex) 
  (POLYMAP::|!eval|-1-1 (FUNCTOR::vertexMap-1 (CAT::functor-1 dgm)) vertex))
                                                                            
(defun CAT::vertexLabel-1 (x1) #'(lambda (x2) (CAT::vertexLabel-1-1 x1 x2)))
                                                                            
(defun CAT::vertexLabel (x0 x1) (CAT::vertexLabel-1 (cons x0 x1)))
                                                                  
(defun CHAR-SPEC::show (c) (CHAR-SPEC::toString c))
                                                   
(defun COMPARE::show (cmp) 
  (block 
   nil 
   (if (eq (car cmp) :|Greater|) 
       (return "Greater") 
       (if (eq (car cmp) :|Equal|) 
           (return "Equal") 
           (if (eq (car cmp) :|Less|) (return "Less")))) 
   (error "Nonexhaustive match failure in show")))
                                                  
(defun POLYSET::|!delete|-1-1 (l x) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV4416 (car l))
                 (pV4417 (cdr l))) 
             (return 
              (if (slang-built-in::slang-term-equals pV4416 x) 
                  pV4417 
                  (cons pV4416 (POLYSET::|!delete|-1-1 pV4417 x))))))) 
   (error "Nonexhaustive match failure in delete")))
                                                    
(defun POLYSET::|!delete| (x1) 
  #'(lambda (x2) (POLYSET::|!delete|-1-1 x1 x2)))
                                                 
(defun EDGE::|!delete| (x) (POLYSET::|!delete| x))
                                                  
(defun EDGE::|!delete|-1-1 (x0 x1) (POLYSET::|!delete|-1-1 x0 x1))
                                                                  
(defun POLYSET::empty? (s) (slang-built-in::slang-term-equals nil s))
                                                                     
(defun EDGE::empty? (x) (POLYSET::empty? x))
                                            
(defun POLYSET::fold (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYSET::fold-1-1-1 x1 x2 x3))))
                                                                 
(defun EDGE::fold (x) (POLYSET::fold x))
                                        
(defun POLYSET::insert (x1) #'(lambda (x2) (POLYSET::insert-1-1 x1 x2)))
                                                                        
(defun EDGE::insert (x) (POLYSET::insert x))
                                            
(defun POLYSET::|!map|-1-1 (f s) 
  (block 
   nil 
   (if (null s) 
       (return nil) 
       (if (consp s) 
           (return (cons (funcall f (car s)) (POLYSET::|!map|-1-1 f (cdr s)))))) 
   (error "Nonexhaustive match failure in map")))
                                                 
(defun POLYSET::|!map| (x1) #'(lambda (x2) (POLYSET::|!map|-1-1 x1 x2)))
                                                                        
(defun EDGE::|!map| (x) (POLYSET::|!map| x))
                                            
(defun EDGE::|!map|-1-1 (x0 x1) (POLYSET::|!map|-1-1 x0 x1))
                                                            
(defun POLYSET::member? (x1) #'(lambda (x2) (POLYSET::member?-1-1 x1 x2)))
                                                                          
(defun EDGE::member? (x) (POLYSET::member? x))
                                              
(defun POLYSET::singleton (x) (cons x nil))
                                           
(defun EDGE::singleton (x) (POLYSET::singleton x))
                                                  
(defun POLYSET::toList (l) l)
                             
(defun EDGE::toList (x) (POLYSET::toList x))
                                            
(defun POLYSET::|!union|-1-1 (s1 s2) 
  (POLYSET::fold-1-1-1 #'POLYSET::insert s1 s2))
                                                
(defun POLYSET::|!union| (x1) #'(lambda (x2) (POLYSET::|!union|-1-1 x1 x2)))
                                                                            
(defun EDGE::|!union| (x) (POLYSET::|!union| x))
                                                
(defun EDGE::|!union|-1-1 (x0 x1) (POLYSET::|!union|-1-1 x0 x1))
                                                                
(defun FUNCTIONS::id (x) x)
                           
(defun FUNCTIONS::o-1-1 (!x1 x) (funcall (car !x1) (funcall (cdr !x1) x)))
                                                                          
(defun FUNCTIONS::o-1 (x1) #'(lambda (x2) (FUNCTIONS::o-1-1 x1 x2)))
                                                                    
(defun FUNCTIONS::o (x0 x1) (FUNCTIONS::o-1 (cons x0 x1)))
                                                          
(defun FUNCTOR::cod (x0 x1 x2 x3) (FUNCTOR::cod-1 (vector x0 x1 x2 x3)))
                                                                        
(defun FUNCTOR::dom (x0 x1 x2 x3) (FUNCTOR::dom-1 (vector x0 x1 x2 x3)))
                                                                        
(defun FUNCTOR::edgeMap (x0 x1 x2 x3) (FUNCTOR::edgeMap-1 (vector x0 x1 x2 x3)))
                                                                                
(defun FUNCTOR::emptyFunctor (x0 x1 x2 x3 x4 x5 x6 x7) 
  (FUNCTOR::emptyFunctor-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                             
(defun FUNCTOR::makeFunctor-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) (FUNCTOR::makeFunctor-1-1-1-1 x1 x2 x3 x4)))))
                                                                     
(defun FUNCTOR::makeFunctor (x0 x1 x2 x3) 
  (FUNCTOR::makeFunctor-1 (vector x0 x1 x2 x3)))
                                                
(defun FUNCTOR::ppFunctor (x0 x1 x2 x3) 
  (FUNCTOR::ppFunctor-1 (vector x0 x1 x2 x3)))
                                              
(defun FUNCTOR::vertexMap (x0 x1 x2 x3) 
  (FUNCTOR::vertexMap-1 (vector x0 x1 x2 x3)))
                                              
(defun POSITION-SPEC::printAll (|!position|) 
  (block 
   nil 
   (if (eq (car |!position|) :|Internal|) 
       (return (cdr |!position|)) 
       (if (eq (car |!position|) :|String|) 
           (let ((pV4705 (cdr |!position|))) 
             (return 
              (let ((printPos 
                     #'(lambda (x) 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ (NAT-SPEC::toString (svref x 0)) ".") 
                         (NAT-SPEC::toString (svref x 1)))))) 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ (funcall printPos (svref pV4705 1)) "-") 
                    (funcall printPos (svref pV4705 2))) 
                   " in [") 
                  (svref pV4705 0)) 
                 "]")))) 
           (if (eq (car |!position|) :|File|) 
               (let ((pV4704 (cdr |!position|))) 
                 (return 
                  (let ((printPos 
                         #'(lambda (x) 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              (NAT-SPEC::toString (svref x 0)) 
                              ".") 
                             (NAT-SPEC::toString (svref x 1)))))) 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ "in " (svref pV4704 0)) 
                        "
") 
                       (funcall printPos (svref pV4704 1))) 
                      "-") 
                     (funcall printPos (svref pV4704 2))))))))) 
   (error "Nonexhaustive match failure in printAll")))
                                                      
(defun STANDARDSPEC::tagTuple (|!labels|) 
  (labels 
    ((|!loop| (i |!labels|) 
      (block 
       nil 
       (if (null |!labels|) 
           (return nil) 
           (if (consp |!labels|) 
               (return 
                (LIST-SPEC::|!cons| 
                 (cons (NAT-SPEC::toString i) (car |!labels|)) 
                 (|!loop| (INTEGER-SPEC::|!+| i 1) (cdr |!labels|)))))) 
       (error "Nonexhaustive match failure in tagTuple")))) 
    (|!loop| 1 |!labels|)))
                           
(defun STANDARDSPEC::mkTuple (terms) 
  (block 
   nil 
   (if (consp terms) (if (null (cdr terms)) (return (car terms)))) 
   (return (STANDARDSPEC::mkRecord (STANDARDSPEC::tagTuple terms)))))
                                                                     
(defun INFIX::resolveInfixes (tagTermWithInfixInfo pos terms) 
  (labels 
    ((applyInfix (t1 infOp t2) 
      (cons 
       :|ApplyN| 
       (cons 
        (cons infOp (cons (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil))) nil)) 
        pos)))) 
    (labels 
      ((applyPrefixes (terms) 
        (block 
         nil 
         (if (null terms) 
             (return nil) 
             (if (consp terms) 
                 (let ((pV1935 (cdr terms))
                       (pV1934 (car terms))) 
                   (progn (if (null pV1935) (return (cons pV1934 nil))) 
                          (if (eq (car pV1934) :|Nonfix|) 
                              (if (consp pV1935) 
                                  (let ((pV1938 (car pV1935))) 
                                    (if (eq (car pV1938) :|Nonfix|) 
                                        (return 
                                         (applyPrefixes 
                                          (LIST-SPEC::|!cons| 
                                           (cons 
                                            :|Nonfix| 
                                            (cons 
                                             :|ApplyN| 
                                             (cons 
                                              (cons 
                                               (cdr pV1934) 
                                               (cons (cdr pV1938) nil)) 
                                              pos))) 
                                           (cdr pV1935)))))))) 
                          (return 
                           (LIST-SPEC::|!cons| pV1934 (applyPrefixes pV1935))))))) 
         (error "Nonexhaustive match failure in resolveInfixes")))) 
      (let ((tagged (LIST-SPEC::|!map|-1-1 tagTermWithInfixInfo terms))) 
        (let ((tagged (applyPrefixes tagged))) 
          (labels 
            ((scan (delta0 terms) 
              (block 
               nil 
               (if (null terms) 
                   (return 
                    (SYSTEM-SPEC::fail 
                     (STRING-SPEC::^ 
                      (POSITION-SPEC::printAll pos) 
                      " : No terms to apply"))) 
                   (if (consp terms) 
                       (let ((pV1972 (cdr terms))
                             (pV1971 (car terms))) 
                         (if (eq (car pV1971) :|Infix|) 
                             (let ((pV1984 (car (cdr pV1971)))) 
                               (progn (if (null pV1972) 
                                          (return 
                                           (cons (cons :|Nonfix| pV1984) nil))) 
                                      (return 
                                       (SYSTEM-SPEC::fail 
                                        (STRING-SPEC::^ 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ 
                                           (POSITION-SPEC::printAll pos) 
                                           " : Infix ") 
                                          (ANNSPECPRINTER::printTerm pV1984)) 
                                         " given without left argument"))))) 
                             (if (eq (car pV1971) :|Nonfix|) 
                                 (let ((pV1973 (cdr pV1971))) 
                                   (if (null pV1972) 
                                       (return 
                                        (cons (cons :|Nonfix| pV1973) nil)) 
                                       (if (consp pV1972) 
                                           (let ((pV1976 (car pV1972))) 
                                             (if (eq (car pV1976) :|Infix|) 
                                                 (let ((pV1979 (cdr pV1976))) 
                                                   (let ((pV1981 (cdr pV1979))
                                                         (pV1980 (car pV1979))) 
                                                     (let ((pV1983 (cdr pV1981))
                                                           (pV1982 (car pV1981))) 
                                                       (return 
                                                        (let ((|!rest| 
                                                               (scan 
                                                                pV1983 
                                                                (cdr pV1972)))) 
                                                          (if (lisp::or 
                                                               (INTEGER-SPEC::|!>| 
                                                                delta0 
                                                                pV1983) 
                                                               (lisp::and 
                                                                ( =  
                                                                 delta0 
                                                                 pV1983) 
                                                                (slang-built-in::slang-term-equals 
                                                                 pV1982 
                                                                 '(:|Left|)))) 
                                                              (LIST-SPEC::|!cons| 
                                                               (cons 
                                                                :|Nonfix| 
                                                                pV1973) 
                                                               (LIST-SPEC::|!cons| 
                                                                (cons 
                                                                 :|Infix| 
                                                                 (cons 
                                                                  pV1980 
                                                                  (cons 
                                                                   pV1982 
                                                                   pV1983))) 
                                                                |!rest|)) 
                                                              (block 
                                                               nil 
                                                               (if (consp 
                                                                    |!rest|) 
                                                                   (let ((pV1952 
                                                                          (cdr 
                                                                           |!rest|))
                                                                         (pV1951 
                                                                          (car 
                                                                           |!rest|))) 
                                                                     (if (eq 
                                                                          (car 
                                                                           pV1951) 
                                                                          :|Nonfix|) 
                                                                         (let ((pV1953 
                                                                                (cdr 
                                                                                 pV1951))) 
                                                                           (if (consp 
                                                                                pV1952) 
                                                                               (let ((pV1956 
                                                                                      (cdr 
                                                                                       pV1952))
                                                                                     (pV1955 
                                                                                      (car 
                                                                                       pV1952))) 
                                                                                 (if (eq 
                                                                                      (car 
                                                                                       pV1955) 
                                                                                      :|Infix|) 
                                                                                     (let ((pV1957 
                                                                                            (cdr 
                                                                                             pV1955))) 
                                                                                       (let ((pV1959 
                                                                                              (cdr 
                                                                                               pV1957))
                                                                                             (pV1958 
                                                                                              (car 
                                                                                               pV1957))) 
                                                                                         (let ((pV1961 
                                                                                                (cdr 
                                                                                                 pV1959))) 
                                                                                           (if (consp 
                                                                                                pV1956) 
                                                                                               (let ((pV1964 
                                                                                                      (cdr 
                                                                                                       pV1956))
                                                                                                     (pV1963 
                                                                                                      (car 
                                                                                                       pV1956))) 
                                                                                                 (if (eq 
                                                                                                      (car 
                                                                                                       pV1963) 
                                                                                                      :|Nonfix|) 
                                                                                                     (let ((pV1965 
                                                                                                            (cdr 
                                                                                                             pV1963))) 
                                                                                                       (return 
                                                                                                        (if (lisp::or 
                                                                                                             (INTEGER-SPEC::|!>| 
                                                                                                              pV1983 
                                                                                                              pV1961) 
                                                                                                             (lisp::and 
                                                                                                              ( =  
                                                                                                               pV1983 
                                                                                                               pV1961) 
                                                                                                              (slang-built-in::slang-term-equals 
                                                                                                               pV1982 
                                                                                                               '(:|Left|)))) 
                                                                                                            (LIST-SPEC::|!++| 
                                                                                                             (cons 
                                                                                                              (cons 
                                                                                                               :|Nonfix| 
                                                                                                               (applyInfix 
                                                                                                                pV1973 
                                                                                                                pV1980 
                                                                                                                pV1953)) 
                                                                                                              (cons 
                                                                                                               (cons 
                                                                                                                :|Infix| 
                                                                                                                (cons 
                                                                                                                 pV1958 
                                                                                                                 (cons 
                                                                                                                  (car 
                                                                                                                   pV1959) 
                                                                                                                  pV1961))) 
                                                                                                               (cons 
                                                                                                                (cons 
                                                                                                                 :|Nonfix| 
                                                                                                                 pV1965) 
                                                                                                                nil))) 
                                                                                                             pV1964) 
                                                                                                            (let ((pV1943 
                                                                                                                   (scan 
                                                                                                                    pV1961 
                                                                                                                    (LIST-SPEC::|!++| 
                                                                                                                     (cons 
                                                                                                                      (cons 
                                                                                                                       :|Nonfix| 
                                                                                                                       pV1965) 
                                                                                                                      nil) 
                                                                                                                     pV1964)))) 
                                                                                                              (block 
                                                                                                               nil 
                                                                                                               (if (consp 
                                                                                                                    pV1943) 
                                                                                                                   (let ((pV1945 
                                                                                                                          (car 
                                                                                                                           pV1943))) 
                                                                                                                     (if (eq 
                                                                                                                          (car 
                                                                                                                           pV1945) 
                                                                                                                          :|Nonfix|) 
                                                                                                                         (return 
                                                                                                                          (scan 
                                                                                                                           delta0 
                                                                                                                           (LIST-SPEC::|!++| 
                                                                                                                            (cons 
                                                                                                                             (cons 
                                                                                                                              :|Nonfix| 
                                                                                                                              pV1973) 
                                                                                                                             (cons 
                                                                                                                              (cons 
                                                                                                                               :|Infix| 
                                                                                                                               (cons 
                                                                                                                                pV1980 
                                                                                                                                (cons 
                                                                                                                                 pV1982 
                                                                                                                                 pV1983))) 
                                                                                                                              (cons 
                                                                                                                               (cons 
                                                                                                                                :|Nonfix| 
                                                                                                                                (applyInfix 
                                                                                                                                 pV1953 
                                                                                                                                 pV1958 
                                                                                                                                 (cdr 
                                                                                                                                  pV1945))) 
                                                                                                                               nil))) 
                                                                                                                            (cdr 
                                                                                                                             pV1943))))))) 
                                                                                                               (error 
                                                                                                                "Nonexhaustive match failure in resolveInfixes")))))))))))))) 
                                                                               (if (null 
                                                                                    pV1952) 
                                                                                   (return 
                                                                                    (cons 
                                                                                     (cons 
                                                                                      :|Nonfix| 
                                                                                      (applyInfix 
                                                                                       pV1973 
                                                                                       pV1980 
                                                                                       pV1953)) 
                                                                                     nil)))))))) 
                                                               (return 
                                                                (SYSTEM-SPEC::fail 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (POSITION-SPEC::printAll 
                                                                     pos) 
                                                                    " : Infix ") 
                                                                   (ANNSPECPRINTER::printTerm 
                                                                    pV1980)) 
                                                                  " given without left argument")))))))))) 
                                                 (if (eq (car pV1976) :|Nonfix|) 
                                                     (return 
                                                      (SYSTEM-SPEC::fail 
                                                       (STRING-SPEC::^ 
                                                        (POSITION-SPEC::printAll 
                                                         pos) 
                                                        " : Unreduced nonfix")))))))))))))) 
               (error "Nonexhaustive match failure in resolveInfixes")))) 
            (labels 
              ((scanrec (tagged) 
                (let ((pV1986 (scan 0 tagged))) 
                  (block 
                   nil 
                   (if (consp pV1986) 
                       (let ((pV1989 (cdr pV1986))
                             (pV1988 (car pV1986))) 
                         (if (eq (car pV1988) :|Nonfix|) 
                             (let ((pV1990 (cdr pV1988))) 
                               (if (null pV1989) 
                                   (return pV1990) 
                                   (if (consp pV1989) 
                                       (let ((pV1993 (cdr pV1989))
                                             (pV1992 (car pV1989))) 
                                         (if (eq (car pV1992) :|Infix|) 
                                             (let ((pV1994 (cdr pV1992))) 
                                               (let ((pV1996 (cdr pV1994))
                                                     (pV1995 (car pV1994))) 
                                                 (progn (if (consp pV1993) 
                                                            (let ((pV2000 
                                                                   (car pV1993))) 
                                                              (if (eq 
                                                                   (car pV2000) 
                                                                   :|Nonfix|) 
                                                                  (if (null 
                                                                       (cdr 
                                                                        pV1993)) 
                                                                      (return 
                                                                       (applyInfix 
                                                                        pV1990 
                                                                        pV1995 
                                                                        (cdr 
                                                                         pV2000))))))) 
                                                        (if (eq 
                                                             (car (car pV1996)) 
                                                             :|Left|) 
                                                            (if ( =  
                                                                 0 
                                                                 (cdr pV1996)) 
                                                                (return 
                                                                 (applyInfix 
                                                                  pV1990 
                                                                  pV1995 
                                                                  (scanrec 
                                                                   pV1993)))))))))))))))) 
                   (return (scanrec pV1986)))))) 
              (let ((term (scanrec tagged))) term))))))))
                                                         
(defun INFIX::resolveInfixes-1 (x) 
  (INFIX::resolveInfixes (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun INTEGER-SPEC::|!>|-1 (x) (INTEGER-SPEC::|!>| (car x) (cdr x)))
                                                                     
(defun INTEGER-SPEC::|!>=| (x y) (INTEGER-SPEC::|!<=| y x))
                                                           
(defun INTEGER-SPEC::|!>=|-1 (x) (INTEGER-SPEC::|!>=| (car x) (cdr x)))
                                                                       
(defun INTEGER-SPEC::|!max| (x y) (if (INTEGER-SPEC::|!<=| x y) y x))
                                                                     
(defun INTEGER-SPEC::|!max|-1 (x) (INTEGER-SPEC::|!max| (car x) (cdr x)))
                                                                         
(defun INTEGER-SPEC::|!min| (x y) (if (INTEGER-SPEC::|!<=| x y) x y))
                                                                     
(defun INTEGER-SPEC::|!min|-1 (x) (INTEGER-SPEC::|!min| (car x) (cdr x)))
                                                                         
(defun INTEGER-SPEC::show (n) (INTEGER-SPEC::toString n))
                                                         
(defun INTEGERSET::add (x0 x) (SPLAYSET::add x0 x))
                                                   
(defun INTEGERSET::add-1 (x) (INTEGERSET::add (car x) (cdr x)))
                                                               
(defun INTEGERSET::addList (x0 x) (SPLAYSET::addList x0 x))
                                                           
(defun INTEGERSET::addList-1 (x) (INTEGERSET::addList (car x) (cdr x)))
                                                                       
(defun SPLAYSET::appSplay-1-1 (f sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8846 (cdr sp))) 
             (return 
              (progn (SPLAYSET::appSplay-1-1 f (svref pV8846 0)) 
                     (funcall f (svref pV8846 2)) 
                     (SPLAYSET::appSplay-1-1 f (svref pV8846 1))))))) 
   (error "Nonexhaustive match failure in appSplay")))
                                                      
(defun SPLAYSET::app-1-1 (f |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::appSplay-1-1 f (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in app")))
                                                 
(defun SPLAYSET::app (x1) #'(lambda (x2) (SPLAYSET::app-1-1 x1 x2)))
                                                                    
(defun INTEGERSET::app (x) (SPLAYSET::app x))
                                             
(defun INTEGERSET::app-1-1 (x0 x1) (SPLAYSET::app-1-1 x0 x1))
                                                             
(defun SPLAYTREE::lrotate (sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|SplayNil|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV9283 (cdr sp))) 
             (let ((pV9285 (svref pV9283 1))) 
               (if (eq (car pV9285) :|SplayNil|) 
                   (return sp) 
                   (if (eq (car pV9285) :|SplayObj|) 
                       (let ((pV9287 (cdr pV9285))) 
                         (return 
                          (SPLAYTREE::lrotate 
                           (cons 
                            :|SplayObj| 
                            (vector 
                             (cons 
                              :|SplayObj| 
                              (vector 
                               (svref pV9283 0) 
                               (svref pV9287 0) 
                               (svref pV9283 2))) 
                             (svref pV9287 1) 
                             (svref pV9287 2)))))))))))) 
   (error "Nonexhaustive match failure in lrotate")))
                                                     
(defun SPLAYTREE::join (sp1 sp2) 
  (block 
   nil 
   (if (eq (car sp1) :|SplayNil|) 
       (progn (if (eq (car sp2) :|SplayNil|) (return '(:|SplayNil|))) 
              (return sp2))) 
   (if (eq (car sp2) :|SplayNil|) (return sp1)) 
   (return 
    (let ((pV9275 (SPLAYTREE::lrotate sp1))) 
      (block 
       nil 
       (if (eq (car pV9275) :|SplayNil|) 
           (return sp2) 
           (if (eq (car pV9275) :|SplayObj|) 
               (let ((pV9276 (cdr pV9275))) 
                 (return 
                  (cons 
                   :|SplayObj| 
                   (vector (svref pV9276 0) sp2 (svref pV9276 2))))))) 
       (error "Nonexhaustive match failure in join")))) 
   (error "Nonexhaustive match failure in join")))
                                                  
(defun SPLAYSET::|!delete| (|!set| key) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return |!set|) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV8910 (cdr |!set|))) 
             (let ((pV8914 (svref pV8910 2))
                   (pV8913 (svref pV8910 1))
                   (pV8912 (svref pV8910 0))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        (SPLAYSET::compf pV8912 key) 
                        (STATE::|!!| pV8914)))) 
                  (let ((pV8904 (cdr x))) 
                    (block 
                     nil 
                     (if (eq (car (car x)) :|Equal|) 
                         (if (eq (car pV8904) :|SplayObj|) 
                             (let ((pV8905 (cdr pV8904))) 
                               (return 
                                (if ( =  pV8913 1) 
                                    (SPLAYSET::empty pV8912) 
                                    (cons 
                                     :|SET| 
                                     (vector 
                                      pV8912 
                                      (INTEGER-SPEC::|!-| pV8913 1) 
                                      (cons 
                                       :|Ref| 
                                       (SPLAYTREE::join 
                                        (svref pV8905 0) 
                                        (svref pV8905 1)))))))))) 
                     (return (progn (STATE::|:=| pV8914 pV8904) |!set|)) 
                     (error "Nonexhaustive match failure in delete"))))))))) 
   (error "Nonexhaustive match failure in delete")))
                                                    
(defun INTEGERSET::|!delete| (x0 x) (SPLAYSET::|!delete| x0 x))
                                                               
(defun INTEGERSET::|!delete|-1 (x) (INTEGERSET::|!delete| (car x) (cdr x)))
                                                                           
(defun SPLAYSET::split (comp value s) 
  (let ((x (SPLAYTREE::splay (SPLAYSET::compf comp value) s))) 
    (let ((pV9173 (cdr x))
          (pV9172 (car x))) 
      (block 
       nil 
       (if (eq (car pV9172) :|Equal|) 
           (if (eq (car pV9173) :|SplayObj|) 
               (let ((pV9182 (cdr pV9173))) 
                 (return 
                  (vector 
                   (cons :|Some| (svref pV9182 2)) 
                   (svref pV9182 0) 
                   (svref pV9182 1))))) 
           (if (eq (car pV9172) :|Less|) 
               (if (eq (car pV9173) :|SplayObj|) 
                   (let ((pV9178 (cdr pV9173))) 
                     (return 
                      (vector 
                       '(:|None|) 
                       (cons 
                        :|SplayObj| 
                        (vector (svref pV9178 0) '(:|SplayNil|) (svref pV9178 2))) 
                       (svref pV9178 1))))) 
               (if (eq (car pV9172) :|Greater|) 
                   (if (eq (car pV9173) :|SplayObj|) 
                       (let ((pV9174 (cdr pV9173))) 
                         (return 
                          (vector 
                           '(:|None|) 
                           (svref pV9174 0) 
                           (cons 
                            :|SplayObj| 
                            (vector 
                             '(:|SplayNil|) 
                             (svref pV9174 1) 
                             (svref pV9174 2)))))))))) 
       (if (eq (car pV9173) :|SplayNil|) 
           (return (vector '(:|None|) '(:|SplayNil|) '(:|SplayNil|)))) 
       (error "Nonexhaustive match failure in split")))))
                                                         
(defun SPLAYSET::|!count| (sp n) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return n) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8897 (cdr sp))) 
             (return 
              (SPLAYSET::|!count| 
               (svref pV8897 0) 
               (SPLAYSET::|!count| (svref pV8897 1) (INTEGER-SPEC::|!+| n 1))))))) 
   (error "Nonexhaustive match failure in count")))
                                                   
(defun SPLAYSET::diffSplay (comp sp1 sp2) 
  (block 
   nil 
   (if (eq (car sp1) :|SplayNil|) (return (cons '(:|SplayNil|) 0))) 
   (if (eq (car sp2) :|SplayNil|) 
       (return (cons sp1 (SPLAYSET::|!count| sp1 0))) 
       (if (eq (car sp2) :|SplayObj|) 
           (let ((pV8929 (cdr sp2))) 
             (return 
              (let ((pV8923 (SPLAYSET::split comp (svref pV8929 2) sp1))) 
                (block 
                 nil 
                 (return 
                  (let ((pV8920 
                         (SPLAYSET::diffSplay 
                          comp 
                          (svref pV8923 1) 
                          (svref pV8929 0)))) 
                    (block 
                     nil 
                     (return 
                      (let ((pV8917 
                             (SPLAYSET::diffSplay 
                              comp 
                              (svref pV8923 2) 
                              (svref pV8929 1)))) 
                        (block 
                         nil 
                         (return 
                          (cons 
                           (SPLAYTREE::join (car pV8920) (car pV8917)) 
                           (INTEGER-SPEC::|!+| (cdr pV8920) (cdr pV8917)))) 
                         (error "Nonexhaustive match failure in diffSplay")))) 
                     (error "Nonexhaustive match failure in diffSplay")))) 
                 (error "Nonexhaustive match failure in diffSplay"))))))) 
   (error "Nonexhaustive match failure in diffSplay")))
                                                       
(defun SPLAYSET::difference (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) (return set1)) 
   (if (eq (car set2) :|EMPTY|) (return set1)) 
   (if (eq (car set1) :|SET|) 
       (let ((pV8942 (cdr set1))) 
         (let ((pV8943 (svref pV8942 0))) 
           (if (eq (car set2) :|SET|) 
               (return 
                (let ((x 
                       (SPLAYSET::diffSplay 
                        pV8943 
                        (STATE::|!!| (svref pV8942 2)) 
                        (STATE::|!!| (svref (cdr set2) 2))))) 
                  (let ((pV8939 (cdr x))) 
                    (block 
                     nil 
                     (if ( =  0 pV8939) (return (cons :|EMPTY| pV8943))) 
                     (return 
                      (cons :|SET| (vector pV8943 pV8939 (cons :|Ref| (car x))))) 
                     (error "Nonexhaustive match failure in difference"))))))))) 
   (error "Nonexhaustive match failure in difference")))
                                                        
(defun INTEGERSET::difference (x0 x) (SPLAYSET::difference x0 x))
                                                                 
(defun INTEGERSET::difference-1 (x) (INTEGERSET::difference (car x) (cdr x)))
                                                                             
(defun SPLAYSET::memberT (comp x tree) 
  (block 
   nil 
   (if (eq (car tree) :|SplayNil|) 
       (return nil) 
       (if (eq (car tree) :|SplayObj|) 
           (let ((pV9154 (cdr tree))) 
             (return 
              (let ((pV9152 (funcall comp (cons x (svref pV9154 2))))) 
                (block 
                 nil 
                 (if (eq (car pV9152) :|Less|) 
                     (return (SPLAYSET::memberT comp x (svref pV9154 0))) 
                     (if (eq (car pV9152) :|Greater|) 
                         (return (SPLAYSET::memberT comp x (svref pV9154 1))))) 
                 (return t))))))) 
   (error "Nonexhaustive match failure in memberT")))
                                                     
(defun SPLAYSET::treeIn (comp |!t| t_) 
  (block 
   nil 
   (if (eq (car |!t|) :|SplayNil|) 
       (return t) 
       (if (eq (car |!t|) :|SplayObj|) 
           (let ((pV9187 (cdr |!t|))) 
             (let ((pV9190 (svref pV9187 2))
                   (pV9189 (svref pV9187 1))
                   (pV9188 (svref pV9187 0))) 
               (progn (if (eq (car pV9188) :|SplayNil|) 
                          (if (eq (car pV9189) :|SplayNil|) 
                              (return (SPLAYSET::memberT comp pV9190 t_)))) 
                      (if (eq (car pV9189) :|SplayNil|) 
                          (return 
                           (lisp::and 
                            (SPLAYSET::memberT comp pV9190 t_) 
                            (SPLAYSET::treeIn comp pV9188 t_)))) 
                      (if (eq (car pV9188) :|SplayNil|) 
                          (return 
                           (lisp::and 
                            (SPLAYSET::memberT comp pV9190 t_) 
                            (SPLAYSET::treeIn comp pV9189 t_)))) 
                      (return 
                       (lisp::and 
                        (SPLAYSET::memberT comp pV9190 t_) 
                        (lisp::and 
                         (SPLAYSET::treeIn comp pV9188 t_) 
                         (SPLAYSET::treeIn comp pV9189 t_))))))))) 
   (error "Nonexhaustive match failure in treeIn")))
                                                    
(defun SPLAYSET::|!equal| (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|SET|) 
       (let ((pV8958 (cdr set1))) 
         (if (eq (car set2) :|SET|) 
             (let ((pV8963 (cdr set2))) 
               (return 
                (lisp::and 
                 ( =  (svref pV8958 1) (svref pV8963 1)) 
                 (SPLAYSET::treeIn 
                  (svref pV8958 0) 
                  (STATE::|!!| (svref pV8958 2)) 
                  (STATE::|!!| (svref pV8963 2)))))))) 
       (if (eq (car set1) :|EMPTY|) (if (eq (car set2) :|EMPTY|) (return t)))) 
   (return nil)))
                 
(defun INTEGERSET::|!equal| (x0 x) (SPLAYSET::|!equal| x0 x))
                                                             
(defun INTEGERSET::|!equal|-1 (x) (INTEGERSET::|!equal| (car x) (cdr x)))
                                                                         
(defun SPLAYSET::existsSplay-1-1 (p sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8975 (cdr sp))) 
             (return 
              (if (funcall p (svref pV8975 2)) 
                  t 
                  (if (SPLAYSET::existsSplay-1-1 p (svref pV8975 0)) 
                      t 
                      (SPLAYSET::existsSplay-1-1 p (svref pV8975 1)))))))) 
   (error "Nonexhaustive match failure in existsSplay")))
                                                         
(defun SPLAYSET::|!exists|-1-1 (p |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::existsSplay-1-1 p (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in exists")))
                                                    
(defun SPLAYSET::|!exists| (x1) 
  #'(lambda (x2) (SPLAYSET::|!exists|-1-1 x1 x2)))
                                                  
(defun INTEGERSET::|!exists| (x) (SPLAYSET::|!exists| x))
                                                         
(defun INTEGERSET::|!exists|-1-1 (x0 x1) (SPLAYSET::|!exists|-1-1 x0 x1))
                                                                         
(defun SPLAYSET::filterSplay-1-1 (comp x) 
  (let ((p (svref x 0))
        (sp (svref x 1))
        (tree (svref x 2))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return tree) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV8990 (cdr sp))) 
               (let ((pV8993 (svref pV8990 2))) 
                 (return 
                  (let ((t_ 
                         (SPLAYSET::filterSplay-1-1 
                          comp 
                          (vector 
                           p 
                           (svref pV8990 1) 
                           (SPLAYSET::filterSplay-1-1 
                            comp 
                            (vector p (svref pV8990 0) tree)))))) 
                    (if (funcall p pV8993) 
                        (SPLAYSET::insert-1-1 comp (cons pV8993 t_)) 
                        t_))))))) 
     (error "Nonexhaustive match failure in filterSplay"))))
                                                            
(defparameter SPLAYTREE::mkSplayNil '(:|SplayNil|))
                                                   
(defun SPLAYSET::filter-1-1 (p |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return |!set|) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV8984 (cdr |!set|))) 
             (let ((pV8986 (svref pV8984 0))) 
               (return 
                (let ((x 
                       (SPLAYSET::filterSplay-1-1 
                        pV8986 
                        (vector 
                         p 
                         (STATE::|!!| (svref pV8984 2)) 
                         (cons 0 SPLAYTREE::mkSplayNil))))) 
                  (let ((pV8981 (car x))) 
                    (block 
                     nil 
                     (if ( =  0 pV8981) (return (cons :|EMPTY| pV8986))) 
                     (return 
                      (cons :|SET| (vector pV8986 pV8981 (cons :|Ref| (cdr x))))) 
                     (error "Nonexhaustive match failure in filter"))))))))) 
   (error "Nonexhaustive match failure in filter")))
                                                    
(defun SPLAYSET::filter (x1) #'(lambda (x2) (SPLAYSET::filter-1-1 x1 x2)))
                                                                          
(defun INTEGERSET::filter (x) (SPLAYSET::filter x))
                                                   
(defun INTEGERSET::filter-1-1 (x0 x1) (SPLAYSET::filter-1-1 x0 x1))
                                                                   
(defun SPLAYSET::findSplay-1-1 (p sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return '(:|None|)) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV9006 (cdr sp))) 
             (let ((pV9009 (svref pV9006 2))) 
               (return 
                (if (funcall p pV9009) 
                    (cons :|Some| pV9009) 
                    (let ((pV9003 (SPLAYSET::findSplay-1-1 p (svref pV9006 0)))) 
                      (block 
                       nil 
                       (if (eq (car pV9003) :|Some|) (return pV9003)) 
                       (return (SPLAYSET::findSplay-1-1 p (svref pV9006 1))))))))))) 
   (error "Nonexhaustive match failure in findSplay")))
                                                       
(defun SPLAYSET::|!find|-1-1 (p |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return '(:|None|)) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::findSplay-1-1 p (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in find")))
                                                  
(defun SPLAYSET::|!find| (x1) #'(lambda (x2) (SPLAYSET::|!find|-1-1 x1 x2)))
                                                                            
(defun INTEGERSET::|!find| (x) (SPLAYSET::|!find| x))
                                                     
(defun INTEGERSET::|!find|-1-1 (x0 x1) (SPLAYSET::|!find|-1-1 x0 x1))
                                                                     
(defun SPLAYSET::foldlSplay-1-1-1 (f b sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return b) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV9018 (cdr sp))) 
             (return 
              (SPLAYSET::foldlSplay-1-1-1 
               f 
               (funcall f 
                        (cons 
                         (svref pV9018 2) 
                         (SPLAYSET::foldlSplay-1-1-1 f b (svref pV9018 0)))) 
               (svref pV9018 1)))))) 
   (error "Nonexhaustive match failure in foldlSplay")))
                                                        
(defun SPLAYSET::foldl-1-1-1 (abf b |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::foldlSplay-1-1-1 
             abf 
             b 
             (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in foldl")))
                                                   
(defun SPLAYSET::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldl-1-1-1 x1 x2 x3))))
                                                                   
(defun INTEGERSET::foldl (x) (SPLAYSET::foldl x))
                                                 
(defun INTEGERSET::foldl-1-1-1 (x0 x1 x2) (SPLAYSET::foldl-1-1-1 x0 x1 x2))
                                                                           
(defun SPLAYSET::foldrSplay-1-1-1 (f b sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return b) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV9030 (cdr sp))) 
             (return 
              (SPLAYSET::foldrSplay-1-1-1 
               f 
               (funcall f 
                        (cons 
                         (svref pV9030 2) 
                         (SPLAYSET::foldrSplay-1-1-1 f b (svref pV9030 1)))) 
               (svref pV9030 0)))))) 
   (error "Nonexhaustive match failure in foldrSplay")))
                                                        
(defun SPLAYSET::foldr-1-1-1 (abf b |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::foldrSplay-1-1-1 
             abf 
             b 
             (STATE::|!!| (svref (cdr |!set|) 2)))))) 
   (error "Nonexhaustive match failure in foldr")))
                                                   
(defun SPLAYSET::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldr-1-1-1 x1 x2 x3))))
                                                                   
(defun INTEGERSET::foldr (x) (SPLAYSET::foldr x))
                                                 
(defun INTEGERSET::foldr-1-1-1 (x0 x1 x2) (SPLAYSET::foldr-1-1-1 x0 x1 x2))
                                                                           
(defun INTEGERSET::fromList (ls) (SPLAYSET::addList INTEGERSET::empty ls))
                                                                          
(defun SPLAYSET::intersectionSplay (comp s1 s2) 
  (block 
   nil 
   (if (eq (car s1) :|SplayNil|) (return (cons '(:|SplayNil|) 0))) 
   (if (eq (car s2) :|SplayNil|) 
       (return (cons '(:|SplayNil|) 0)) 
       (if (eq (car s2) :|SplayObj|) 
           (let ((pV9093 (cdr s2))) 
             (let ((pV9095 (svref pV9093 1))
                   (pV9094 (svref pV9093 0))) 
               (return 
                (let ((x (SPLAYSET::split comp (svref pV9093 2) s1))) 
                  (let ((pV9089 (svref x 2))
                        (pV9088 (svref x 1))
                        (pV9087 (svref x 0))) 
                    (block 
                     nil 
                     (if (eq (car pV9087) :|Some|) 
                         (return 
                          (let ((pV9077 
                                 (SPLAYSET::intersectionSplay comp pV9088 pV9094))) 
                            (block 
                             nil 
                             (return 
                              (let ((pV9074 
                                     (SPLAYSET::intersectionSplay 
                                      comp 
                                      pV9089 
                                      pV9095))) 
                                (block 
                                 nil 
                                 (return 
                                  (cons 
                                   (cons 
                                    :|SplayObj| 
                                    (vector 
                                     (car pV9077) 
                                     (car pV9074) 
                                     (cdr pV9087))) 
                                   (INTEGER-SPEC::|!+| 
                                    (INTEGER-SPEC::|!+| 
                                     (cdr pV9077) 
                                     (cdr pV9074)) 
                                    1))) 
                                 (error 
                                  "Nonexhaustive match failure in intersectionSplay")))) 
                             (error 
                              "Nonexhaustive match failure in intersectionSplay"))))) 
                     (return 
                      (let ((pV9084 
                             (SPLAYSET::intersectionSplay comp pV9088 pV9094))) 
                        (block 
                         nil 
                         (return 
                          (let ((pV9081 
                                 (SPLAYSET::intersectionSplay comp pV9089 pV9095))) 
                            (block 
                             nil 
                             (return 
                              (cons 
                               (SPLAYTREE::join (car pV9084) (car pV9081)) 
                               (INTEGER-SPEC::|!+| (cdr pV9084) (cdr pV9081)))) 
                             (error 
                              "Nonexhaustive match failure in intersectionSplay")))) 
                         (error 
                          "Nonexhaustive match failure in intersectionSplay")))) 
                     (error "Nonexhaustive match failure in intersectionSplay"))))))))) 
   (error "Nonexhaustive match failure in intersectionSplay")))
                                                               
(defun SPLAYSET::|!intersection| (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) (return set1)) 
   (if (eq (car set2) :|EMPTY|) (return set2)) 
   (if (eq (car set1) :|SET|) 
       (let ((pV9062 (cdr set1))) 
         (let ((pV9063 (svref pV9062 0))) 
           (if (eq (car set2) :|SET|) 
               (return 
                (let ((x 
                       (SPLAYSET::intersectionSplay 
                        pV9063 
                        (STATE::|!!| (svref pV9062 2)) 
                        (STATE::|!!| (svref (cdr set2) 2))))) 
                  (let ((pV9059 (cdr x))) 
                    (block 
                     nil 
                     (if ( =  0 pV9059) (return (cons :|EMPTY| pV9063))) 
                     (return 
                      (cons :|SET| (vector pV9063 pV9059 (cons :|Ref| (car x))))) 
                     (error "Nonexhaustive match failure in intersection"))))))))) 
   (error "Nonexhaustive match failure in intersection")))
                                                          
(defun INTEGERSET::|!intersection| (x0 x) (SPLAYSET::|!intersection| x0 x))
                                                                           
(defun INTEGERSET::|!intersection|-1 (x) 
  (INTEGERSET::|!intersection| (car x) (cdr x)))
                                                
(defun SPLAYSET::isEmpty (|!set|) 
  (block nil (if (eq (car |!set|) :|EMPTY|) (return t)) (return nil)))
                                                                      
(defun INTEGERSET::isEmpty (x) (SPLAYSET::isEmpty x))
                                                     
(defun SPLAYSET::listItemsApp (sp l) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return l) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV9125 (cdr sp))) 
             (return 
              (SPLAYSET::listItemsApp 
               (svref pV9125 0) 
               (LIST-SPEC::|!cons| 
                (svref pV9125 2) 
                (SPLAYSET::listItemsApp (svref pV9125 1) l))))))) 
   (error "Nonexhaustive match failure in listItemsApp")))
                                                          
(defun SPLAYSET::listItems (|!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!set|) :|SET|) 
           (return 
            (SPLAYSET::listItemsApp (STATE::|!!| (svref (cdr |!set|) 2)) nil)))) 
   (error "Nonexhaustive match failure in listItems")))
                                                       
(defun INTEGERSET::listItems (x) (SPLAYSET::listItems x))
                                                         
(defun SPLAYSET::mapf (f acc sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return acc) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV9137 (cdr sp))) 
             (return 
              (SPLAYSET::mapf 
               f 
               (SPLAYSET::add 
                (SPLAYSET::mapf f acc (svref pV9137 0)) 
                (funcall f (svref pV9137 2))) 
               (svref pV9137 1)))))) 
   (error "Nonexhaustive match failure in mapf")))
                                                  
(defun SPLAYSET::|!map|-1-1 (f |!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return |!set|) 
       (if (eq (car |!set|) :|SET|) 
           (let ((pV9131 (cdr |!set|))) 
             (return 
              (SPLAYSET::mapf 
               f 
               (cons :|EMPTY| (svref pV9131 0)) 
               (STATE::|!!| (svref pV9131 2))))))) 
   (error "Nonexhaustive match failure in map")))
                                                 
(defun SPLAYSET::|!map| (x1) #'(lambda (x2) (SPLAYSET::|!map|-1-1 x1 x2)))
                                                                          
(defun INTEGERSET::|!map| (x) (SPLAYSET::|!map| x))
                                                   
(defun INTEGERSET::|!map|-1-1 (x0 x1) (SPLAYSET::|!map|-1-1 x0 x1))
                                                                   
(defun INTEGERSET::|!member|-1 (x) (INTEGERSET::|!member| (car x) (cdr x)))
                                                                           
(defun SPLAYSET::numItems (|!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return 0) 
       (if (eq (car |!set|) :|SET|) (return (svref (cdr |!set|) 1)))) 
   (error "Nonexhaustive match failure in numItems")))
                                                      
(defun INTEGERSET::numItems (x) (SPLAYSET::numItems x))
                                                       
(defun SPLAYSET::unionSplay (comp sp1 sp2) 
  (block 
   nil 
   (if (eq (car sp1) :|SplayNil|) (return (cons sp2 (SPLAYSET::|!count| sp2 0)))) 
   (if (eq (car sp2) :|SplayNil|) 
       (return (cons sp1 (SPLAYSET::|!count| sp1 0))) 
       (if (eq (car sp2) :|SplayObj|) 
           (let ((pV9226 (cdr sp2))) 
             (let ((pV9229 (svref pV9226 2))) 
               (return 
                (let ((pV9220 (SPLAYSET::split comp pV9229 sp1))) 
                  (block 
                   nil 
                   (return 
                    (let ((pV9217 
                           (SPLAYSET::unionSplay 
                            comp 
                            (svref pV9220 1) 
                            (svref pV9226 0)))) 
                      (block 
                       nil 
                       (return 
                        (let ((pV9214 
                               (SPLAYSET::unionSplay 
                                comp 
                                (svref pV9220 2) 
                                (svref pV9226 1)))) 
                          (block 
                           nil 
                           (return 
                            (cons 
                             (cons 
                              :|SplayObj| 
                              (vector (car pV9217) (car pV9214) pV9229)) 
                             (INTEGER-SPEC::|!+| 
                              (INTEGER-SPEC::|!+| (cdr pV9217) (cdr pV9214)) 
                              1))) 
                           (error "Nonexhaustive match failure in unionSplay")))) 
                       (error "Nonexhaustive match failure in unionSplay")))) 
                   (error "Nonexhaustive match failure in unionSplay")))))))) 
   (error "Nonexhaustive match failure in unionSplay")))
                                                        
(defun SPLAYSET::|!union| (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) (return set2)) 
   (if (eq (car set2) :|EMPTY|) (return set1)) 
   (if (eq (car set1) :|SET|) 
       (let ((pV9200 (cdr set1))) 
         (let ((pV9201 (svref pV9200 0))) 
           (if (eq (car set2) :|SET|) 
               (return 
                (let ((pV9195 
                       (SPLAYSET::unionSplay 
                        pV9201 
                        (STATE::|!!| (svref pV9200 2)) 
                        (STATE::|!!| (svref (cdr set2) 2))))) 
                  (block 
                   nil 
                   (return 
                    (cons 
                     :|SET| 
                     (vector pV9201 (cdr pV9195) (cons :|Ref| (car pV9195))))) 
                   (error "Nonexhaustive match failure in union")))))))) 
   (error "Nonexhaustive match failure in union")))
                                                   
(defun INTEGERSET::|!union| (x0 x) (SPLAYSET::|!union| x0 x))
                                                             
(defun INTEGERSET::|!union|-1 (x) (INTEGERSET::|!union| (car x) (cdr x)))
                                                                         
(defun LIST-SPEC::|!++|-1 (x) (LIST-SPEC::|!++| (car x) (cdr x)))
                                                                 
(defun LIST-SPEC::@-1 (x) (LIST-SPEC::@ (car x) (cdr x)))
                                                         
(defun LIST-SPEC::all-1-1 (p s) 
  (block 
   nil 
   (if (null s) 
       (return t) 
       (if (consp s) 
           (return (if (funcall p (car s)) (LIST-SPEC::all-1-1 p (cdr s)) nil)))) 
   (error "Nonexhaustive match failure in all")))
                                                 
(defun LIST-SPEC::all (x1) #'(lambda (x2) (LIST-SPEC::all-1-1 x1 x2)))
                                                                      
(defun LIST-SPEC::app (x1) #'(lambda (x2) (LIST-SPEC::app-1-1 x1 x2)))
                                                                      
(defun LIST-SPEC::compare-1-1 (comp x) 
  (let ((l1 (car x))
        (l2 (cdr x))) 
    (block 
     nil 
     (if (null l1) 
         (if (null l2) (return '(:|Equal|)) (if (consp l2) (return '(:|Less|)))) 
         (if (consp l1) 
             (if (consp l2) 
                 (return 
                  (let ((pV2011 (funcall comp (cons (car l1) (car l2))))) 
                    (block 
                     nil 
                     (if (eq (car pV2011) :|Equal|) 
                         (return 
                          (LIST-SPEC::compare-1-1 comp (cons (cdr l1) (cdr l2))))) 
                     (return pV2011)))) 
                 (if (null l2) (return '(:|Greater|)))))) 
     (error "Nonexhaustive match failure in compare"))))
                                                        
(defun LIST-SPEC::compare (x1) 
  #'(lambda (x2) (LIST-SPEC::compare-1-1 x1 x2)))
                                                 
(defun LIST-SPEC::concat-1 (x) (LIST-SPEC::concat (car x) (cdr x)))
                                                                   
(defun LIST-SPEC::|!cons|-1 (x) (LIST-SPEC::|!cons| (car x) (cdr x)))
                                                                     
(defun LIST-SPEC::diff (s1 s2) 
  (block 
   nil 
   (if (null s1) 
       (return nil) 
       (if (consp s1) 
           (let ((pV2034 (cdr s1))
                 (pV2033 (car s1))) 
             (return 
              (if (LIST-SPEC::|!member| pV2033 s2) 
                  (LIST-SPEC::diff pV2034 s2) 
                  (cons pV2033 (LIST-SPEC::diff pV2034 s2))))))) 
   (error "Nonexhaustive match failure in diff")))
                                                  
(defun LIST-SPEC::diff-1 (x) (LIST-SPEC::diff (car x) (cdr x)))
                                                               
(defun LIST-SPEC::|!exists| (x1) 
  #'(lambda (x2) (LIST-SPEC::|!exists|-1-1 x1 x2)))
                                                   
(defun LIST-SPEC::filter (x1) #'(lambda (x2) (LIST-SPEC::filter-1-1 x1 x2)))
                                                                            
(defun LIST-SPEC::|!find| (x1) 
  #'(lambda (x2) (LIST-SPEC::|!find|-1-1 x1 x2)))
                                                 
(defun LIST-SPEC::firstUpToHelper (p l res) 
  (block 
   nil 
   (if (null l) 
       (return '(:|None|)) 
       (if (consp l) 
           (let ((pV2049 (car l))) 
             (return 
              (if (funcall p pV2049) 
                  (cons :|Some| (cons pV2049 res)) 
                  (LIST-SPEC::firstUpToHelper p (cdr l) (cons pV2049 res))))))) 
   (error "Nonexhaustive match failure in firstUpToHelper")))
                                                             
(defun LIST-SPEC::firstUpTo-1-1 (p l) (LIST-SPEC::firstUpToHelper p l nil))
                                                                           
(defun LIST-SPEC::firstUpTo (x1) 
  #'(lambda (x2) (LIST-SPEC::firstUpTo-1-1 x1 x2)))
                                                   
(defun LIST-SPEC::firstUpToHelper-1 (x) 
  (LIST-SPEC::firstUpToHelper (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun LIST-SPEC::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (LIST-SPEC::foldl-1-1-1 x1 x2 x3))))
                                                                    
(defun LIST-SPEC::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (LIST-SPEC::foldr-1-1-1 x1 x2 x3))))
                                                                    
(defun LIST-SPEC::hd (l) 
  (block 
   nil 
   (if (consp l) (return (car l))) 
   (error "Nonexhaustive match failure in hd")))
                                                
(defun LIST-SPEC::insert (hd tl) (cons hd tl))
                                              
(defun LIST-SPEC::insert-1 (x) (LIST-SPEC::insert (car x) (cdr x)))
                                                                   
(defun LIST-SPEC::|!map| (x1) #'(lambda (x2) (LIST-SPEC::|!map|-1-1 x1 x2)))
                                                                            
(defun LIST-SPEC::mapPartial-1-1 (f l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV2082 (cdr l))) 
             (return 
              (let ((pV2077 (funcall f (car l)))) 
                (block 
                 nil 
                 (if (eq (car pV2077) :|Some|) 
                     (return 
                      (cons (cdr pV2077) (LIST-SPEC::mapPartial-1-1 f pV2082))) 
                     (if (eq (car pV2077) :|None|) 
                         (return (LIST-SPEC::mapPartial-1-1 f pV2082)))) 
                 (error "Nonexhaustive match failure in mapPartial"))))))) 
   (error "Nonexhaustive match failure in mapPartial")))
                                                        
(defun LIST-SPEC::mapPartial (x1) 
  #'(lambda (x2) (LIST-SPEC::mapPartial-1-1 x1 x2)))
                                                    
(defun LIST-SPEC::|!member|-1 (x) (LIST-SPEC::|!member| (car x) (cdr x)))
                                                                         
(defparameter LIST-SPEC::|!nil| nil)
                                    
(defun LIST-SPEC::|!nth| (ls i) 
  (block 
   nil 
   (if (consp ls) 
       (return 
        (if ( =  i 0) 
            (car ls) 
            (LIST-SPEC::|!nth| (cdr ls) (INTEGER-SPEC::|!-| i 1))))) 
   (error "Nonexhaustive match failure in nth")))
                                                 
(defun LIST-SPEC::|!nth|-1 (x) (LIST-SPEC::|!nth| (car x) (cdr x)))
                                                                   
(defun LIST-SPEC::nthTail (ls i) 
  (block 
   nil 
   (if (null ls) 
       (return nil) 
       (if (consp ls) 
           (let ((pV2094 (cdr ls))) 
             (return 
              (if ( =  i 0) 
                  pV2094 
                  (LIST-SPEC::nthTail pV2094 (INTEGER-SPEC::|!-| i 1))))))) 
   (error "Nonexhaustive match failure in nthTail")))
                                                     
(defun LIST-SPEC::nthTail-1 (x) (LIST-SPEC::nthTail (car x) (cdr x)))
                                                                     
(defun LIST-SPEC::rev2-1 (x) (LIST-SPEC::rev2 (car x) (cdr x)))
                                                               
(defun LIST-SPEC::show-1-1 (sep l) 
  (block 
   nil 
   (if (null l) 
       (return "") 
       (if (consp l) 
           (let ((pV2103 (car l))
                 (pV2104 (cdr l))) 
             (progn (if (null pV2104) (return pV2103)) 
                    (return 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ pV2103 sep) 
                      (LIST-SPEC::show-1-1 sep pV2104))))))) 
   (error "Nonexhaustive match failure in show")))
                                                  
(defun LIST-SPEC::show (x1) #'(lambda (x2) (LIST-SPEC::show-1-1 x1 x2)))
                                                                        
(defun LIST-SPEC::tabulate (n f) 
  (labels 
    ((tabulateRec (m tl) 
      (if (INTEGER-SPEC::|!<| m 0) 
          tl 
          (tabulateRec 
           (INTEGER-SPEC::|!-| m 1) 
           (LIST-SPEC::|!cons| (funcall f m) tl))))) 
    (tabulateRec (INTEGER-SPEC::|!-| n 1) nil)))
                                                
(defun LIST-SPEC::tabulate-1 (x) (LIST-SPEC::tabulate (car x) (cdr x)))
                                                                       
(defun LIST-SPEC::tl (l) 
  (block 
   nil 
   (if (consp l) (return (cdr l))) 
   (error "Nonexhaustive match failure in tl")))
                                                
(defun LISTADT::addDefinition (modulename defn |!lspc|) 
  (let ((mname (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase modulename))) 
    (let ((sname 
           (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase (svref |!lspc| 2)))) 
      (if (string=  mname sname) 
          (vector 
           (svref |!lspc| 0) 
           (svref |!lspc| 1) 
           (svref |!lspc| 2) 
           (LIST-SPEC::|!cons| defn (svref |!lspc| 3)) 
           (svref |!lspc| 4)) 
          |!lspc|))))
                     
(defun LISTADT::addDefinition-1 (x) 
  (LISTADT::addDefinition (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun LISTADT::addDefinitions (defns |!lspc|) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (let ((pV2110 (car x))) 
        (block 
         nil 
         (return (LISTADT::addDefinition (car pV2110) (cdr pV2110) (cdr x))) 
         (error "Nonexhaustive match failure in addDefinitions")))) 
   |!lspc| 
   defns))
          
(defun LISTADT::addDefinitions-1 (x) (LISTADT::addDefinitions (car x) (cdr x)))
                                                                               
(defparameter LISTADT::emptySpec (vector nil nil "BASESPECS" nil nil))
                                                                      
(defun LISTADT::mkDefinition (modulename name |!lispterm|) 
  (let ((|!t| (cons :|Const| (cons :|Cell| (LISP-SPEC::cell |!lispterm|))))) 
    (cons modulename (cons name |!t|))))
                                        
(defun LISTADT::mkDefinition-1 (x) 
  (LISTADT::mkDefinition (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun LISTADT::mkLApply (f terms) (cons :|Apply| (cons f terms)))
                                                                  
(defun LISTADT::mkLOp (s) (cons :|Op| s))
                                         
(defun LISTADT::mkDefinitionWithOp (modulename name |!opname| |!lispterm|) 
  (let ((|!t| 
         (LISTADT::mkLApply 
          (LISTADT::mkLOp |!opname|) 
          (cons (cons :|Const| (cons :|Cell| (LISP-SPEC::cell |!lispterm|))) nil)))) 
    (cons modulename (cons name |!t|))))
                                        
(defun LISTADT::mkDefinitionWithOp-1 (x) 
  (LISTADT::mkDefinitionWithOp (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                                
(defun LISTADT::mkLApply-1 (x) (LISTADT::mkLApply (car x) (cdr x)))
                                                                   
(defun LISTADT::mkLBool (b) (cons :|Const| (cons :|Boolean| b)))
                                                                
(defun LISTADT::mkLChar (ch) (cons :|Const| (cons :|Char| ch)))
                                                               
(defun LISTADT::mkLIf (t1 t2 t3) (cons :|If| (vector t1 t2 t3)))
                                                                
(defun LISTADT::mkLIf-1 (x) 
  (LISTADT::mkLIf (svref x 0) (svref x 1) (svref x 2)))
                                                       
(defun LISTADT::mkLNat (n) (cons :|Const| (cons :|Nat| n)))
                                                           
(defun LISTADT::mkLInt (n) 
  (if (INTEGER-SPEC::|!>=| n 0) 
      (LISTADT::mkLNat n) 
      (LISTADT::mkLApply 
       (LISTADT::mkLOp "-") 
       (cons (LISTADT::mkLNat (INTEGER-SPEC::~ n)) nil))))
                                                          
(defun LISTADT::mkLIntern (s) 
  (cons 
   :|Const| 
   (cons :|Parameter| (STRING-SPEC::^ (STRING-SPEC::^ ":|" s) "|"))))
                                                                     
(defun LISTADT::mkLLambda (args decls body) 
  (cons :|Lambda| (vector args decls body)))
                                            
(defun LISTADT::mkLLambda-1 (x) 
  (LISTADT::mkLLambda (svref x 0) (svref x 1) (svref x 2)))
                                                           
(defun LISTADT::mkLLet (vars terms term) 
  (if (LIST-SPEC::|!null| vars) term (cons :|Let| (vector vars terms term))))
                                                                             
(defun LISTADT::mkLLet-1 (x) 
  (LISTADT::mkLLet (svref x 0) (svref x 1) (svref x 2)))
                                                        
(defun LISTADT::mkLLetRec (vars terms term) 
  (cons :|Letrec| (vector vars terms term)))
                                            
(defun LISTADT::mkLLetRec-1 (x) 
  (LISTADT::mkLLetRec (svref x 0) (svref x 1) (svref x 2)))
                                                           
(defun LISTADT::mkLQuote (id) (LISTADT::mkLOp (STRING-SPEC::^ "'" id)))
                                                                       
(defun LISTADT::mkLSeq (terms) (cons :|Seq| terms))
                                                   
(defun LISTADT::mkLString (s) 
  (cons :|Const| (cons :|String| (IO-SPEC::formatString1 "~S" s))))
                                                                   
(defun LISTADT::mkLVar (s) (cons :|Var| s))
                                           
(defun LISTADT::oldMkLString (s) 
  (STRING-SPEC::translate-1-1 
   #'(lambda (pV2114) 
      (block 
       nil 
       (if (eq #\" pV2114) (return "\\\"") (if (eq #\\ pV2114) (return "\\\\"))) 
       (return (CHAR-SPEC::toString pV2114)))) 
   s))
      
(defun LISTADT::ops-1 (x) (LISTADT::ops (car x) (cdr x)))
                                                         
(defun LISTADT::ops (term names) 
  (block 
   nil 
   (if (eq (car term) :|Const|) 
       (let ((pV2133 (cdr term))) 
         (progn (if (eq (car pV2133) :|Parameter|) 
                    (return (STRINGSET::add names (cdr pV2133)))) 
                (return names))) 
       (if (eq (car term) :|Op|) 
           (return (STRINGSET::add names (cdr term))) 
           (if (eq (car term) :|Var|) 
               (return names) 
               (if (eq (car term) :|Set|) 
                   (return (LISTADT::ops (cdr (cdr term)) names)) 
                   (if (eq (car term) :|Lambda|) 
                       (return (LISTADT::ops (svref (cdr term) 2) names)) 
                       (if (eq (car term) :|Apply|) 
                           (let ((pV2128 (cdr term))) 
                             (return 
                              (LIST-SPEC::foldr-1-1-1 
                               #'LISTADT::ops-1 
                               (LISTADT::ops (car pV2128) names) 
                               (cdr pV2128)))) 
                           (if (eq (car term) :|If|) 
                               (let ((pV2127 (cdr term))) 
                                 (return 
                                  (LISTADT::ops 
                                   (svref pV2127 0) 
                                   (LISTADT::ops 
                                    (svref pV2127 1) 
                                    (LISTADT::ops (svref pV2127 2) names))))) 
                               (if (eq (car term) :|IfThen|) 
                                   (let ((pV2126 (cdr term))) 
                                     (return 
                                      (LISTADT::ops 
                                       (car pV2126) 
                                       (LISTADT::ops (cdr pV2126) names)))) 
                                   (if (eq (car term) :|Let|) 
                                       (let ((pV2125 (cdr term))) 
                                         (return 
                                          (LIST-SPEC::foldr-1-1-1 
                                           #'LISTADT::ops-1 
                                           (LISTADT::ops (svref pV2125 2) names) 
                                           (svref pV2125 1)))) 
                                       (if (eq (car term) :|Letrec|) 
                                           (let ((pV2124 (cdr term))) 
                                             (return 
                                              (LIST-SPEC::foldr-1-1-1 
                                               #'LISTADT::ops-1 
                                               (LISTADT::ops 
                                                (svref pV2124 2) 
                                                names) 
                                               (svref pV2124 1)))) 
                                           (if (eq (car term) :|Seq|) 
                                               (return 
                                                (LIST-SPEC::foldr-1-1-1 
                                                 #'LISTADT::ops-1 
                                                 names 
                                                 (cdr term)))))))))))))) 
   (error "Nonexhaustive match failure in ops")))
                                                 
(defun LISTADT::ppDecl (decl) 
  (block 
   nil 
   (if (eq (car decl) :|Ignore|) 
       (return 
        (PRETTYPRINT::prettysLinearDelim-1-1 
         (vector "(declare (ignore " " " ")) ") 
         (LIST-SPEC::|!map|-1-1 #'PRETTYPRINT::|!string| (cdr decl))))) 
   (error "Nonexhaustive match failure in ppDecl")))
                                                    
(defun PRETTYPRINT::prettysAllDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysAll delims ps))
                                                                             
(defun PRETTYPRINT::prettysFillDelim-1-1 (delims ps) 
  (PRETTYPRINT::prettysBlockDelim-1-1-1 #'PRETTYPRINT::prettysFill delims ps))
                                                                              
(defun LISTADT::ppTerm (|!t|) 
  (block 
   nil 
   (if (eq (car |!t|) :|Const|) 
       (let ((pV2188 (cdr |!t|))) 
         (return 
          (block 
           nil 
           (if (eq (car pV2188) :|Boolean|) 
               (return (PRETTYPRINT::|!string| (if (cdr pV2188) "t" "nil"))) 
               (if (eq (car pV2188) :|Nat|) 
                   (return 
                    (PRETTYPRINT::|!string| (NAT-SPEC::toString (cdr pV2188)))) 
                   (if (eq (car pV2188) :|Char|) 
                       (return 
                        (PRETTYPRINT::strings 
                         (cons 
                          "#\\" 
                          (cons (CHAR-SPEC::toString (cdr pV2188)) nil)))) 
                       (if (eq (car pV2188) :|String|) 
                           (return (PRETTYPRINT::|!string| (cdr pV2188))) 
                           (if (eq (car pV2188) :|Symbol|) 
                               (let ((pV2164 (cdr pV2188))) 
                                 (return 
                                  (PRETTYPRINT::strings 
                                   (cons 
                                    "'" 
                                    (cons 
                                     (car pV2164) 
                                     (cons "::" (cons (cdr pV2164) nil))))))) 
                               (if (eq (car pV2188) :|Cell|) 
                                   (return 
                                    (PRETTYPRINT::strings 
                                     (cons 
                                      "'" 
                                      (cons 
                                       (SYSTEM-SPEC::toString (cdr pV2188)) 
                                       nil)))) 
                                   (if (eq (car pV2188) :|Parameter|) 
                                       (return 
                                        (PRETTYPRINT::|!string| (cdr pV2188)))))))))) 
           (error "Nonexhaustive match failure in ppTerm")))) 
       (if (eq (car |!t|) :|Op|) 
           (return (PRETTYPRINT::strings (cons "#'" (cons (cdr |!t|) nil)))) 
           (if (eq (car |!t|) :|Var|) 
               (return (PRETTYPRINT::|!string| (cdr |!t|))) 
               (if (eq (car |!t|) :|Set|) 
                   (let ((pV2185 (cdr |!t|))) 
                     (return 
                      (PRETTYPRINT::blockFill 
                       0 
                       (cons 
                        (cons 
                         0 
                         (PRETTYPRINT::strings 
                          (cons "(setq " (cons (car pV2185) (cons " " nil))))) 
                        (cons 
                         (cons 
                          2 
                          (PRETTYPRINT::prettysNone 
                           (cons 
                            (LISTADT::ppTerm (cdr pV2185)) 
                            (cons (PRETTYPRINT::|!string| ")") nil)))) 
                         nil))))) 
                   (if (eq (car |!t|) :|Lambda|) 
                       (let ((pV2184 (cdr |!t|))) 
                         (return 
                          (PRETTYPRINT::blockFill 
                           0 
                           (cons 
                            (cons 
                             0 
                             (PRETTYPRINT::prettysLinearDelim-1-1 
                              (vector "#'(lambda (" " " ") ") 
                              (LIST-SPEC::|!map|-1-1 
                               #'PRETTYPRINT::|!string| 
                               (svref pV2184 0)))) 
                            (cons 
                             (cons 
                              3 
                              (PRETTYPRINT::prettysAll 
                               (LIST-SPEC::@ 
                                (LIST-SPEC::|!map|-1-1 
                                 #'LISTADT::ppDecl 
                                 (svref pV2184 1)) 
                                (cons 
                                 (PRETTYPRINT::prettysNone 
                                  (cons 
                                   (LISTADT::ppTerm (svref pV2184 2)) 
                                   (cons (PRETTYPRINT::|!string| ")") nil))) 
                                 nil)))) 
                             nil))))) 
                       (if (eq (car |!t|) :|Apply|) 
                           (let ((pV2183 (cdr |!t|))) 
                             (let ((pV2201 (cdr pV2183))
                                   (pV2200 (car pV2183))) 
                               (progn (if (eq (car pV2200) :|Op|) 
                                          (let ((pV2202 (cdr pV2200))) 
                                            (progn (if (string=  "list" pV2202) 
                                                       (if (consp pV2201) 
                                                           (let ((pV2204 
                                                                  (car pV2201))) 
                                                             (if (eq 
                                                                  (car pV2204) 
                                                                  :|Const|) 
                                                                 (let ((pV2206 
                                                                        (cdr 
                                                                         pV2204))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV2206) 
                                                                        :|Parameter|) 
                                                                       (let ((pV2207 
                                                                              (cdr 
                                                                               pV2206))) 
                                                                         (if (null 
                                                                              (cdr 
                                                                               pV2201)) 
                                                                             (return 
                                                                              (if (eq 
                                                                                   (STRING-SPEC::sub 
                                                                                    pV2207 
                                                                                    0) 
                                                                                   #\:) 
                                                                                  (PRETTYPRINT::strings 
                                                                                   (cons 
                                                                                    "'(" 
                                                                                    (cons 
                                                                                     pV2207 
                                                                                     (cons 
                                                                                      ")" 
                                                                                      nil)))) 
                                                                                  (PRETTYPRINT::strings 
                                                                                   (cons 
                                                                                    "(list " 
                                                                                    (cons 
                                                                                     pV2207 
                                                                                     (cons 
                                                                                      ")" 
                                                                                      nil)))))))))))))) 
                                                   (return 
                                                    (PRETTYPRINT::prettysLinearDelim-1-1 
                                                     (vector "(" " " ")") 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       pV2202) 
                                                      (LIST-SPEC::|!map|-1-1 
                                                       #'LISTADT::ppTerm 
                                                       pV2201))))))) 
                                      (return 
                                       (PRETTYPRINT::prettysLinearDelim-1-1 
                                        (vector "(funcall " " " ")") 
                                        (cons 
                                         (LISTADT::ppTerm pV2200) 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'LISTADT::ppTerm 
                                          pV2201))))))) 
                           (if (eq (car |!t|) :|If|) 
                               (let ((pV2182 (cdr |!t|))) 
                                 (return 
                                  (PRETTYPRINT::prettysLinearDelim-1-1 
                                   (vector "(if " " " ")") 
                                   (cons 
                                    (LISTADT::ppTerm (svref pV2182 0)) 
                                    (cons 
                                     (LISTADT::ppTerm (svref pV2182 1)) 
                                     (cons 
                                      (LISTADT::ppTerm (svref pV2182 2)) 
                                      nil)))))) 
                               (if (eq (car |!t|) :|IfThen|) 
                                   (let ((pV2181 (cdr |!t|))) 
                                     (return 
                                      (PRETTYPRINT::prettysLinearDelim-1-1 
                                       (vector "(if " " " ")") 
                                       (cons 
                                        (LISTADT::ppTerm (car pV2181)) 
                                        (cons (LISTADT::ppTerm (cdr pV2181)) nil))))) 
                                   (if (eq (car |!t|) :|Let|) 
                                       (let ((pV2180 (cdr |!t|))) 
                                         (return 
                                          (PRETTYPRINT::blockFill 
                                           0 
                                           (cons 
                                            (cons 
                                             0 
                                             (PRETTYPRINT::prettysAllDelim-1-1 
                                              (vector "(let (" "" ") ") 
                                              (LISTPAIR::|!map|-1-1 
                                               #'(lambda (x) 
                                                  (PRETTYPRINT::prettysFillDelim-1-1 
                                                   (vector "(" " " ")") 
                                                   (cons 
                                                    (PRETTYPRINT::|!string| 
                                                     (car x)) 
                                                    (cons 
                                                     (LISTADT::ppTerm (cdr x)) 
                                                     nil)))) 
                                               (cons 
                                                (svref pV2180 0) 
                                                (svref pV2180 1))))) 
                                            (cons 
                                             (cons 
                                              2 
                                              (PRETTYPRINT::prettysNone 
                                               (cons 
                                                (LISTADT::ppTerm 
                                                 (svref pV2180 2)) 
                                                (cons 
                                                 (PRETTYPRINT::|!string| ")") 
                                                 nil)))) 
                                             nil))))) 
                                       (if (eq (car |!t|) :|Letrec|) 
                                           (let ((pV2179 (cdr |!t|))) 
                                             (return 
                                              (PRETTYPRINT::blockFill 
                                               0 
                                               (cons 
                                                (cons 
                                                 0 
                                                 (PRETTYPRINT::|!string| 
                                                  "(labels ")) 
                                                (cons 
                                                 (cons 
                                                  2 
                                                  (PRETTYPRINT::prettysAllDelim-1-1 
                                                   (vector "(" "" ") ") 
                                                   (LISTPAIR::|!map|-1-1 
                                                    #'(lambda (x) 
                                                       (let ((pV2172 (cdr x))) 
                                                         (block 
                                                          nil 
                                                          (if (eq 
                                                               (car pV2172) 
                                                               :|Lambda|) 
                                                              (let ((pV2173 
                                                                     (cdr pV2172))) 
                                                                (return 
                                                                 (PRETTYPRINT::prettysFillDelim-1-1 
                                                                  (vector 
                                                                   "(" 
                                                                   " " 
                                                                   ")") 
                                                                  (cons 
                                                                   (PRETTYPRINT::|!string| 
                                                                    (car x)) 
                                                                   (cons 
                                                                    (PRETTYPRINT::prettysLinearDelim-1-1 
                                                                     (vector 
                                                                      "(" 
                                                                      " " 
                                                                      ")") 
                                                                     (LIST-SPEC::|!map|-1-1 
                                                                      #'PRETTYPRINT::|!string| 
                                                                      (svref 
                                                                       pV2173 
                                                                       0))) 
                                                                    (cons 
                                                                     (PRETTYPRINT::prettysAll 
                                                                      (LIST-SPEC::@ 
                                                                       (LIST-SPEC::|!map|-1-1 
                                                                        #'LISTADT::ppDecl 
                                                                        (svref 
                                                                         pV2173 
                                                                         1)) 
                                                                       (cons 
                                                                        (PRETTYPRINT::prettysNone 
                                                                         (cons 
                                                                          (LISTADT::ppTerm 
                                                                           (svref 
                                                                            pV2173 
                                                                            2)) 
                                                                          nil)) 
                                                                        nil))) 
                                                                     nil))))))) 
                                                          (error 
                                                           "Nonexhaustive match failure in ppTerm")))) 
                                                    (cons 
                                                     (svref pV2179 0) 
                                                     (svref pV2179 1))))) 
                                                 (cons 
                                                  (cons 
                                                   2 
                                                   (PRETTYPRINT::prettysNone 
                                                    (cons 
                                                     (LISTADT::ppTerm 
                                                      (svref pV2179 2)) 
                                                     (cons 
                                                      (PRETTYPRINT::|!string| 
                                                       ")") 
                                                      nil)))) 
                                                  nil)))))) 
                                           (if (eq (car |!t|) :|Seq|) 
                                               (return 
                                                (PRETTYPRINT::prettysLinearDelim-1-1 
                                                 (vector "(progn " " " ")") 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'LISTADT::ppTerm 
                                                  (cdr |!t|))))))))))))))) 
   (error "Nonexhaustive match failure in ppTerm")))
                                                    
(defun LISTADT::ppOpDefn (s term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (let ((pV2157 (cdr term))) 
         (return 
          (PRETTYPRINT::blockFill 
           0 
           (cons 
            (cons 0 (PRETTYPRINT::|!string| "(defun ")) 
            (cons 
             (cons 0 (PRETTYPRINT::|!string| s)) 
             (cons 
              (cons 
               0 
               (PRETTYPRINT::prettysLinearDelim-1-1 
                (vector " (" " " ") ") 
                (LIST-SPEC::|!map|-1-1 #'PRETTYPRINT::|!string| (svref pV2157 0)))) 
              (cons 
               (cons 
                2 
                (PRETTYPRINT::prettysAll 
                 (LIST-SPEC::@ 
                  (LIST-SPEC::|!map|-1-1 #'LISTADT::ppDecl (svref pV2157 1)) 
                  (cons 
                   (PRETTYPRINT::prettysNone 
                    (cons 
                     (LISTADT::ppTerm (svref pV2157 2)) 
                     (cons (PRETTYPRINT::|!string| ")") nil))) 
                   nil)))) 
               (cons (cons 0 (PRETTYPRINT::newline)) nil))))))))) 
   (return 
    (PRETTYPRINT::blockFill 
     0 
     (cons 
      (cons 0 (PRETTYPRINT::|!string| "(defparameter ")) 
      (cons 
       (cons 0 (PRETTYPRINT::|!string| s)) 
       (cons 
        (cons 0 (PRETTYPRINT::|!string| " ")) 
        (cons 
         (cons 
          2 
          (PRETTYPRINT::prettysNone 
           (cons (LISTADT::ppTerm term) (cons (PRETTYPRINT::|!string| ")") nil)))) 
         (cons (cons 0 (PRETTYPRINT::newline)) nil)))))))))
                                                           
(defun LISTADT::ppOpDefn-1 (x) (LISTADT::ppOpDefn (car x) (cdr x)))
                                                                   
(defun LISTADT::section (title ps) 
  (cons 
   (PRETTYPRINT::emptyPretty) 
   (cons (PRETTYPRINT::|!string| title) (cons (PRETTYPRINT::emptyPretty) ps))))
                                                                               
(defun STRINGSET::listItems (x) (SPLAYSET::listItems x))
                                                        
(defun LISTADT::sortDefs (defs) 
  (let ((defMap 
         (LIST-SPEC::foldr-1-1-1 
          #'(lambda (x) 
             (let ((pV2213 (car x))) 
               (block 
                nil 
                (let ((pV2215 (car pV2213))) 
                  (return 
                   (STRINGMAP::insert (cdr x) pV2215 (cons pV2215 (cdr pV2213))))) 
                (error "Nonexhaustive match failure in sortDefs")))) 
          STRINGMAP::empty 
          defs))) 
    (let ((|!map| 
           (LIST-SPEC::foldr-1-1-1 
            #'(lambda (x) 
               (let ((pV2217 (car x))) 
                 (block 
                  nil 
                  (return 
                   (let ((opers (LISTADT::ops (cdr pV2217) STRINGSET::empty))) 
                     (let ((opers (STRINGSET::listItems opers))) 
                       (STRINGMAP::insert (cdr x) (car pV2217) opers)))) 
                  (error "Nonexhaustive match failure in sortDefs")))) 
            STRINGMAP::empty 
            defs))) 
      (let ((names 
             (TOPSORT::topSort 
              '(:|EQUAL|) 
              #'(lambda (name) 
                 (let ((pV2221 (STRINGMAP::|!find| |!map| name))) 
                   (block 
                    nil 
                    (if (eq (car pV2221) :|None|) 
                        (return nil) 
                        (if (eq (car pV2221) :|Some|) (return (cdr pV2221)))) 
                    (error "Nonexhaustive match failure in sortDefs")))) 
              (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) defs)))) 
        (let ((defs 
               (LIST-SPEC::mapPartial-1-1 
                #'(lambda (name1) (STRINGMAP::|!find| defMap name1)) 
                names))) defs)))))
                                  
(defun LISTADT::ppSpec-1 (s) 
  (let ((defs (LISTADT::sortDefs (svref s 3)))) 
    (let ((name (svref s 2))) 
      (PRETTYPRINT::prettysAll 
       (LIST-SPEC::|!++| 
        (LISTADT::section 
         ";;; Lisp spec" 
         (LIST-SPEC::|!++| 
          (LIST-SPEC::|!map|-1-1 
           #'(lambda (pkgName) 
              (PRETTYPRINT::|!string| 
               (STRING-SPEC::^ (STRING-SPEC::^ "(defpackage \"" pkgName) "\")"))) 
           (svref s 1)) 
          (cons 
           (PRETTYPRINT::|!string| 
            (STRING-SPEC::^ (STRING-SPEC::^ "(defpackage \"" name) "\")")) 
           (cons 
            (PRETTYPRINT::|!string| 
             (STRING-SPEC::^ (STRING-SPEC::^ "(in-package \"" name) "\")")) 
            nil)))) 
        (LISTADT::section 
         ";;; Definitions" 
         (LIST-SPEC::|!map|-1-1 #'LISTADT::ppOpDefn-1 defs)))))))
                                                                 
(defun LISTADT::ppSpec (x0 x1 x2 x3 x4) 
  (LISTADT::ppSpec-1 (vector x0 x1 x2 x3 x4)))
                                              
(defun LISTADT::ppSpecToFile (spc file preamble) 
  (let ((p (LISTADT::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
      (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble)))))
                                                                    
(defun LISTADT::ppSpecToFile-1 (x) 
  (LISTADT::ppSpecToFile (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun LISTADT::ppSpecToTerminal-1 (spc) 
  (let ((p (LISTADT::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) (PRETTYPRINT::toTerminal |!t|))))


(defun LISTADT::ppSpecToTerminal (x0 x1 x2 x3 x4) 
  (LISTADT::ppSpecToTerminal-1 (vector x0 x1 x2 x3 x4)))
                                                        
(defun LISTADT::ppSpecsToFile (specs file preamble) 
  (let ((ps (LIST-SPEC::|!map|-1-1 #'LISTADT::ppSpec-1 specs))) 
    (let ((p (PRETTYPRINT::prettysAll ps))) 
      (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
        (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble))))))
                                                                       
(defun LISTADT::ppSpecsToFile-1 (x) 
  (LISTADT::ppSpecsToFile (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun LISTADT::section-1 (x) (LISTADT::section (car x) (cdr x)))
                                                                 
(defun LISTPAIR::all-1-1 (p x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (lisp::and 
               (funcall p (cons (car l) (car r))) 
               (LISTPAIR::all-1-1 p (cons (cdr l) (cdr r))))))) 
     (return t))))
                  
(defun LISTPAIR::all (x1) #'(lambda (x2) (LISTPAIR::all-1-1 x1 x2)))
                                                                    
(defun LISTPAIR::app-1-1 (f x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (progn (funcall f (cons (car l) (car r))) 
                     (LISTPAIR::app-1-1 f (cons (cdr l) (cdr r))))))) 
     (return nil))))
                    
(defun LISTPAIR::app (x1) #'(lambda (x2) (LISTPAIR::app-1-1 x1 x2)))
                                                                    
(defun LISTPAIR::|!exists|-1-1 (p x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (lisp::or 
               (funcall p (cons (car l) (car r))) 
               (LISTPAIR::|!exists|-1-1 p (cons (cdr l) (cdr r))))))) 
     (return nil))))
                    
(defun LISTPAIR::|!exists| (x1) 
  #'(lambda (x2) (LISTPAIR::|!exists|-1-1 x1 x2)))
                                                  
(defun LISTPAIR::foldl-1-1-1 (f u x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (LISTPAIR::foldl-1-1-1 
               f 
               (funcall f (vector (car l) (car r) u)) 
               (cons (cdr l) (cdr r)))))) 
     (return u))))
                  
(defun LISTPAIR::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (LISTPAIR::foldl-1-1-1 x1 x2 x3))))
                                                                   
(defun LISTPAIR::foldr-1-1-1 (f u x) 
  (let ((l (car x))
        (r (cdr x))) 
    (block 
     nil 
     (if (consp l) 
         (if (consp r) 
             (return 
              (funcall f 
                       (vector 
                        (car l) 
                        (car r) 
                        (LISTPAIR::foldr-1-1-1 f u (cons (cdr l) (cdr r)))))))) 
     (return u))))
                  
(defun LISTPAIR::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (LISTPAIR::foldr-1-1-1 x1 x2 x3))))
                                                                   
(defun LISTPAIR::|!map| (x1) #'(lambda (x2) (LISTPAIR::|!map|-1-1 x1 x2)))
                                                                          
(defun LISTPAIR::unzip (l) 
  (labels 
    ((unzipLoop (l a b) 
      (block 
       nil 
       (if (null l) 
           (return (cons (LIST-SPEC::rev a) (LIST-SPEC::rev b))) 
           (if (consp l) 
               (let ((pV2280 (car l))) 
                 (return 
                  (unzipLoop (cdr l) (cons (car pV2280) a) (cons (cdr pV2280) b)))))) 
       (error "Nonexhaustive match failure in unzip")))) (unzipLoop l nil nil)))
                                                                                
(defun LISTPAIR::zip-1 (x) (LISTPAIR::zip (car x) (cdr x)))
                                                           
(defun LISTUTILITIES::appi-1-1 (f xs) 
  (labels 
    ((|!loop| (i xs) 
      (block 
       nil 
       (if (null xs) 
           (return nil) 
           (if (consp xs) 
               (return 
                (progn (funcall f (cons i (car xs))) 
                       (|!loop| (INTEGER-SPEC::|!+| i 1) (cdr xs)))))) 
       (error "Nonexhaustive match failure in appi")))) (|!loop| 0 xs)))
                                                                        
(defun LISTUTILITIES::appi (x1) 
  #'(lambda (x2) (LISTUTILITIES::appi-1-1 x1 x2)))
                                                  
(defun LISTUTILITIES::split (test l) 
  (labels 
    ((splitAux (l trues falses) 
      (block 
       nil 
       (if (null l) 
           (return (cons (LIST-SPEC::rev trues) (LIST-SPEC::rev falses))) 
           (if (consp l) 
               (let ((pV2351 (cdr l))
                     (pV2350 (car l))) 
                 (return 
                  (if (funcall test pV2350) 
                      (splitAux pV2351 (cons pV2350 trues) falses) 
                      (splitAux pV2351 trues (cons pV2350 falses))))))) 
       (error "Nonexhaustive match failure in split")))) (splitAux l nil nil)))
                                                                               
(defun LISTUTILITIES::collectDuplicates (l eqTest) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV2303 (car l))) 
             (return 
              (let ((pV2298 
                     (LISTUTILITIES::split 
                      #'(lambda (e) (funcall eqTest (cons pV2303 e))) 
                      (cdr l)))) 
                (block 
                 nil 
                 (let ((pV2300 (cdr pV2298))) 
                   (return 
                    (if (LIST-SPEC::|!null| (car pV2298)) 
                        (LISTUTILITIES::collectDuplicates pV2300 eqTest) 
                        (cons 
                         pV2303 
                         (LISTUTILITIES::collectDuplicates pV2300 eqTest))))) 
                 (error "Nonexhaustive match failure in collectDuplicates"))))))) 
   (error "Nonexhaustive match failure in collectDuplicates")))
                                                               
(defun LISTUTILITIES::collectDuplicates-1 (x) 
  (LISTUTILITIES::collectDuplicates (car x) (cdr x)))
                                                     
(defun LISTUTILITIES::|!delete| (e l) 
  (block 
   nil 
   (if (null l) 
       (return nil) 
       (if (consp l) 
           (let ((pV2308 (cdr l))
                 (pV2307 (car l))) 
             (return 
              (if (slang-built-in::slang-term-equals e pV2307) 
                  (LISTUTILITIES::|!delete| e pV2308) 
                  (cons pV2307 (LISTUTILITIES::|!delete| e pV2308))))))) 
   (error "Nonexhaustive match failure in delete")))
                                                    
(defun LISTUTILITIES::|!delete|-1 (x) 
  (LISTUTILITIES::|!delete| (car x) (cdr x)))
                                             
(defun LISTUTILITIES::deleteNth (n ls) 
  (if ( =  n 0) 
      (LIST-SPEC::tl ls) 
      (cons 
       (LIST-SPEC::hd ls) 
       (LISTUTILITIES::deleteNth (INTEGER-SPEC::|!-| n 1) (LIST-SPEC::tl ls)))))
                                                                                
(defun LISTUTILITIES::deleteNth-1 (x) 
  (LISTUTILITIES::deleteNth (car x) (cdr x)))
                                             
(defun LISTUTILITIES::drop (n es) 
  (if ( =  n 0) 
      es 
      (block 
       nil 
       (if (null es) 
           (return nil) 
           (if (consp es) 
               (return (LISTUTILITIES::drop (INTEGER-SPEC::|!-| n 1) (cdr es))))) 
       (error "Nonexhaustive match failure in drop"))))
                                                       
(defun LISTUTILITIES::drop-1 (x) (LISTUTILITIES::drop (car x) (cdr x)))
                                                                       
(defun LISTUTILITIES::enumerate (i j) 
  (if (INTEGER-SPEC::|!>| i j) 
      nil 
      (cons i (LISTUTILITIES::enumerate (INTEGER-SPEC::|!+| i 1) j))))
                                                                      
(defun LISTUTILITIES::enumerate-1 (x) 
  (LISTUTILITIES::enumerate (car x) (cdr x)))
                                             
(defun LISTUTILITIES::findOption-1-1 (f l) 
  (block 
   nil 
   (if (null l) 
       (return '(:|None|)) 
       (if (consp l) 
           (return 
            (let ((pV2313 (funcall f (car l)))) 
              (block 
               nil 
               (if (eq (car pV2313) :|None|) 
                   (return (LISTUTILITIES::findOption-1-1 f (cdr l)))) 
               (return pV2313)))))) 
   (error "Nonexhaustive match failure in findOption")))
                                                        
(defun LISTUTILITIES::findOption (x1) 
  #'(lambda (x2) (LISTUTILITIES::findOption-1-1 x1 x2)))
                                                        
(defun LISTUTILITIES::findOptionIndexRec (f xs i) 
  (block 
   nil 
   (if (null xs) 
       (return '(:|None|)) 
       (if (consp xs) 
           (return 
            (let ((pV2318 (funcall f (cons (car xs) i)))) 
              (block 
               nil 
               (if (eq (car pV2318) :|Some|) 
                   (return (cons :|Some| (cons i (cdr pV2318)))) 
                   (if (eq (car pV2318) :|None|) 
                       (return 
                        (LISTUTILITIES::findOptionIndexRec 
                         f 
                         (cdr xs) 
                         (INTEGER-SPEC::|!+| i 1))))) 
               (error "Nonexhaustive match failure in findOptionIndexRec")))))) 
   (error "Nonexhaustive match failure in findOptionIndexRec")))
                                                                
(defun LISTUTILITIES::findOptionIndex-1-1 (f l) 
  (LISTUTILITIES::findOptionIndexRec f l 0))
                                            
(defun LISTUTILITIES::findOptionIndex (x1) 
  #'(lambda (x2) (LISTUTILITIES::findOptionIndex-1-1 x1 x2)))
                                                             
(defun LISTUTILITIES::findOptionIndexRec-1 (x) 
  (LISTUTILITIES::findOptionIndexRec (svref x 0) (svref x 1) (svref x 2)))
                                                                          
(defun LISTUTILITIES::flatMap (f) 
  (labels 
    ((|!loop| (l) 
      (block 
       nil 
       (if (null l) 
           (return nil) 
           (if (consp l) 
               (return (LIST-SPEC::@ (funcall f (car l)) (|!loop| (cdr l)))))) 
       (error "Nonexhaustive match failure in flatMap")))) #'|!loop|))
                                                                      
(defun LISTUTILITIES::flatMap-1-1 (x1 x2) 
  (funcall (LISTUTILITIES::flatMap x1) x2))
                                           
(defun LISTUTILITIES::index (ls elem) 
  (labels 
    ((indexRec (ls counter) 
      (block 
       nil 
       (if (null ls) 
           (return 0) 
           (if (consp ls) 
               (return 
                (if (slang-built-in::slang-term-equals elem (car ls)) 
                    counter 
                    (indexRec (cdr ls) (INTEGER-SPEC::|!+| counter 1)))))) 
       (error "Nonexhaustive match failure in index")))) (indexRec ls 1)))
                                                                          
(defun LISTUTILITIES::index-1 (x) (LISTUTILITIES::index (car x) (cdr x)))
                                                                         
(defun LISTUTILITIES::insert (e l) 
  (block 
   nil 
   (if (null l) 
       (return (cons e nil)) 
       (if (consp l) 
           (let ((pV2334 (car l))) 
             (return 
              (if (slang-built-in::slang-term-equals e pV2334) 
                  l 
                  (cons pV2334 (LISTUTILITIES::insert e (cdr l)))))))) 
   (error "Nonexhaustive match failure in insert")))
                                                    
(defun LISTUTILITIES::insert-1 (x) (LISTUTILITIES::insert (car x) (cdr x)))
                                                                           
(defun LISTUTILITIES::listUnion (l1 l2) 
  (LIST-SPEC::foldr-1-1-1 #'LISTUTILITIES::insert-1 l1 l2))
                                                           
(defun LISTUTILITIES::listUnion-1 (x) 
  (LISTUTILITIES::listUnion (car x) (cdr x)))
                                             
(defun LISTUTILITIES::mapCross-1-1 (f x) 
  (let ((l2 (cdr x))) 
    (LISTUTILITIES::flatMap-1-1 
     #'(lambda (a) 
        (LIST-SPEC::|!map|-1-1 #'(lambda (b) (funcall f (cons a b))) l2)) 
     (car x))))
               
(defun LISTUTILITIES::mapCross (x1) 
  #'(lambda (x2) (LISTUTILITIES::mapCross-1-1 x1 x2)))
                                                      
(defun LISTUTILITIES::mapWithIndex (x1) 
  #'(lambda (x2) (LISTUTILITIES::mapWithIndex-1-1 x1 x2)))
                                                          
(defun LISTUTILITIES::mapWithIndexRec-1 (x) 
  (LISTUTILITIES::mapWithIndexRec (svref x 0) (svref x 1) (svref x 2)))
                                                                       
(defun LISTUTILITIES::mapi-1-1 (f xs) 
  (labels 
    ((|!loop| (i xs) 
      (block 
       nil 
       (if (null xs) 
           (return nil) 
           (if (consp xs) 
               (return 
                (LIST-SPEC::|!cons| 
                 (funcall f (cons i (car xs))) 
                 (|!loop| (INTEGER-SPEC::|!+| i 1) (cdr xs)))))) 
       (error "Nonexhaustive match failure in mapi")))) (|!loop| 0 xs)))
                                                                        
(defun LISTUTILITIES::mapi (x1) 
  #'(lambda (x2) (LISTUTILITIES::mapi-1-1 x1 x2)))
                                                  
(defun LISTUTILITIES::removeDuplicates (l) 
  (block 
   nil 
   (if (null l) 
       (return l) 
       (if (consp l) 
           (return 
            (LISTUTILITIES::insert 
             (car l) 
             (LISTUTILITIES::removeDuplicates (cdr l)))))) 
   (error "Nonexhaustive match failure in removeDuplicates")))
                                                              
(defun LISTUTILITIES::replaceNth (n ls elem) 
  (if ( =  n 0) 
      (cons elem (LIST-SPEC::tl ls)) 
      (cons 
       (LIST-SPEC::hd ls) 
       (LISTUTILITIES::replaceNth 
        (INTEGER-SPEC::|!-| n 1) 
        (LIST-SPEC::tl ls) 
        elem))))
                
(defun LISTUTILITIES::replaceNth-1 (x) 
  (LISTUTILITIES::replaceNth (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun LISTUTILITIES::split-1 (x) (LISTUTILITIES::split (car x) (cdr x)))
                                                                         
(defun LISTUTILITIES::subset? (l1 l2) 
  (LIST-SPEC::all-1-1 #'(lambda (x1) (LIST-SPEC::|!member| x1 l2)) l1))
                                                                       
(defun LISTUTILITIES::subset?-1 (x) (LISTUTILITIES::subset? (car x) (cdr x)))
                                                                             
(defun LISTUTILITIES::take (n es) 
  (if ( =  n 0) 
      nil 
      (block 
       nil 
       (if (null es) 
           (return nil) 
           (if (consp es) 
               (return 
                (cons 
                 (car es) 
                 (LISTUTILITIES::take (INTEGER-SPEC::|!-| n 1) (cdr es)))))) 
       (error "Nonexhaustive match failure in take"))))
                                                       
(defun LISTUTILITIES::take-1 (x) (LISTUTILITIES::take (car x) (cdr x)))
                                                                       
(defun MFSET::augmentMFSetMap-1-1 (mu_map element) 
  (POLYMAP::update-1-1-1 mu_map element (vector '(:|None|) 0 element)))
                                                                       
(defun MFSET::augmentMFSetMap (x1) 
  #'(lambda (x2) (MFSET::augmentMFSetMap-1-1 x1 x2)))
                                                     
(defun MFSET::class_member (x y) (LIST-SPEC::|!member| x y))
                                                            
(defun MFSET::class_member-1 (x) (MFSET::class_member (car x) (cdr x)))
                                                                       
(defparameter MFSET::emptyMFSetMap POLYMAP::emptyMap)
                                                     
(defun MFSET::findRootValue-1-1 (mu_map mu_node) 
  (let ((pV2359 (svref mu_node 0))) 
    (block 
     nil 
     (if (eq (car pV2359) :|None|) 
         (return (svref mu_node 2)) 
         (if (eq (car pV2359) :|Some|) 
             (return 
              (let ((current_parent_node 
                     (POLYMAP::|!eval|-1-1 mu_map (svref (cdr pV2359) 2)))) 
                (MFSET::findRootValue-1-1 mu_map current_parent_node))))) 
     (error "Nonexhaustive match failure in findRootValue"))))
                                                              
(defun POLYMAP::evalPartial-1-1 (|!map| x) 
  (block 
   nil 
   (if (null |!map|) 
       (return '(:|None|)) 
       (if (consp |!map|) 
           (let ((pV4377 (car |!map|))) 
             (return 
              (if (slang-built-in::slang-term-equals x (car pV4377)) 
                  (cons :|Some| (cdr pV4377)) 
                  (POLYMAP::evalPartial-1-1 (cdr |!map|) x)))))) 
   (error "Nonexhaustive match failure in evalPartial")))
                                                         
(defun MFSET::extractQuotientSet (mu_map) 
  (let ((root_map 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (root_to_class_map) 
             #'(lambda (element) 
                #'(lambda (mu_node) 
                   (let ((root_value (MFSET::findRootValue-1-1 mu_map mu_node))) 
                     (let ((old_class_list 
                            (let ((pV2356 
                                   (POLYMAP::evalPartial-1-1 
                                    root_to_class_map 
                                    root_value))) 
                              (block 
                               nil 
                               (if (eq (car pV2356) :|None|) 
                                   (return nil) 
                                   (if (eq (car pV2356) :|Some|) 
                                       (return (cdr pV2356)))) 
                               (error 
                                "Nonexhaustive match failure in extractQuotientSet"))))) 
                       (POLYMAP::update-1-1-1 
                        root_to_class_map 
                        root_value 
                        (cons element old_class_list))))))) 
          POLYMAP::emptyMap 
          mu_map))) 
    (POLYMAP::foldMap-1-1-1 
     #'(lambda (list_of_class_lists) 
        #'(lambda (pV2358) 
           (declare (ignore pV2358)) 
           #'(lambda (class_list) (cons class_list list_of_class_lists)))) 
     nil 
     root_map)))
                
(defun MFSET::|!find|-1-1 (mu_map value) 
  (MFSET::findRootValue-1-1 mu_map (POLYMAP::|!eval|-1-1 mu_map value)))
                                                                        
(defun MFSET::|!find| (x1) #'(lambda (x2) (MFSET::|!find|-1-1 x1 x2)))
                                                                      
(defun MFSET::findRootValue (x1) 
  #'(lambda (x2) (MFSET::findRootValue-1-1 x1 x2)))
                                                   
(defun MFSET::updateMFSetMap-1-1-1 (mu_map element node) 
  (POLYMAP::update-1-1-1 mu_map element node))
                                              
(defun MFSET::|!merge|-1-1-1 (mu_map mu_node_a mu_node_b) 
  (labels 
    ((find_root_node (mu_map) 
      #'(lambda (mu_node) 
         (let ((pV2364 (svref mu_node 0))) 
           (block 
            nil 
            (if (eq (car pV2364) :|Some|) 
                (return 
                 (let ((pV2361 (funcall (find_root_node mu_map) (cdr pV2364)))) 
                   (block 
                    nil 
                    (let ((pV2363 (cdr pV2361))) 
                      (return 
                       (let ((new_map 
                              (MFSET::updateMFSetMap-1-1-1 
                               (car pV2361) 
                               (svref mu_node 2) 
                               (vector 
                                (cons 
                                 :|Some| 
                                 (vector 
                                  (svref pV2363 0) 
                                  (svref pV2363 1) 
                                  (svref pV2363 2))) 
                                (svref mu_node 1) 
                                (svref mu_node 2))))) (cons new_map pV2363)))) 
                    (error "Nonexhaustive match failure in merge")))) 
                (if (eq (car pV2364) :|None|) (return (cons mu_map mu_node)))) 
            (error "Nonexhaustive match failure in merge")))))) 
    (let ((pV2369 (funcall (find_root_node mu_map) mu_node_a))) 
      (block 
       nil 
       (let ((pV2371 (cdr pV2369))) 
         (return 
          (let ((pV2366 (funcall (find_root_node (car pV2369)) mu_node_b))) 
            (block 
             nil 
             (let ((pV2367 (car pV2366))
                   (pV2368 (cdr pV2366))) 
               (return 
                (let ((rank_a (svref pV2371 1))) 
                  (let ((rank_b (svref pV2368 1))) 
                    (let ((root_value_b (svref pV2368 2))) 
                      (if (INTEGER-SPEC::|!>| rank_a rank_b) 
                          (MFSET::updateMFSetMap-1-1-1 
                           pV2367 
                           root_value_b 
                           (vector 
                            (cons 
                             :|Some| 
                             (vector 
                              (svref pV2371 0) 
                              (svref pV2371 1) 
                              (svref pV2371 2))) 
                            (svref pV2368 1) 
                            root_value_b)) 
                          (let ((root_value_a (svref pV2371 2))) 
                            (let ((map_with_new_a 
                                   (MFSET::updateMFSetMap-1-1-1 
                                    pV2367 
                                    root_value_a 
                                    (vector 
                                     (cons 
                                      :|Some| 
                                      (vector 
                                       (svref pV2368 0) 
                                       (svref pV2368 1) 
                                       (svref pV2368 2))) 
                                     (svref pV2371 1) 
                                     root_value_a)))) 
                              (if (INTEGER-SPEC::|!<| rank_a rank_b) 
                                  map_with_new_a 
                                  (MFSET::updateMFSetMap-1-1-1 
                                   map_with_new_a 
                                   root_value_b 
                                   (vector 
                                    '(:|None|) 
                                    (INTEGER-SPEC::|!+| (svref pV2368 1) 1) 
                                    root_value_b))))))))))) 
             (error "Nonexhaustive match failure in merge"))))) 
       (error "Nonexhaustive match failure in merge")))))
                                                         
(defun MFSET::|!merge| (x1) 
  #'(lambda (x2) #'(lambda (x3) (MFSET::|!merge|-1-1-1 x1 x2 x3))))
                                                                   
(defun MFSET::qset_member (y z) (LIST-SPEC::|!member| y z))
                                                           
(defun MFSET::qset_member-1 (x) (MFSET::qset_member (car x) (cdr x)))
                                                                     
(defun MFSET::updateMFSetMap (x1) 
  #'(lambda (x2) #'(lambda (x3) (MFSET::updateMFSetMap-1-1-1 x1 x2 x3))))
                                                                         
(defun NAT-SPEC::div (n m) 
  (if (INTEGER-SPEC::|!<| n m) 
      0 
      (INTEGER-SPEC::|!+| 1 (NAT-SPEC::div (INTEGER-SPEC::|!-| n m) m))))
                                                                         
(defun MERGESORT::sortGT-1-1 (cmpGT ls) 
  (block 
   nil 
   (if (null ls) (return nil) (if (consp ls) (if (null (cdr ls)) (return ls)))) 
   (return 
    (labels 
      ((|!merge| (xs ys) 
        (block 
         nil 
         (if (null xs) (return ys)) 
         (if (null ys) (return xs)) 
         (if (consp xs) 
             (let ((pV2377 (car xs))
                   (pV2378 (cdr xs))) 
               (if (consp ys) 
                   (let ((pV2380 (car ys))
                         (pV2381 (cdr ys))) 
                     (return 
                      (if (funcall cmpGT (cons pV2377 pV2380)) 
                          (cons pV2380 (|!merge| (cons pV2377 pV2378) pV2381)) 
                          (cons pV2377 (|!merge| pV2378 (cons pV2380 pV2381))))))))) 
         (error "Nonexhaustive match failure in sortGT")))) 
      (labels 
        ((mergepairs (ls1 k) 
          (block 
           nil 
           (if (consp ls1) 
               (let ((pV2385 (car ls1))
                     (pV2386 (cdr ls1))) 
                 (if (null pV2386) 
                     (return ls1) 
                     (if (consp pV2386) 
                         (let ((pV2388 (car pV2386))
                               (pV2389 (cdr pV2386))) 
                           (return 
                            (if ( =  (NAT-SPEC::|!rem| k 2) 1) 
                                (cons pV2385 (cons pV2388 pV2389)) 
                                (mergepairs 
                                 (cons (|!merge| pV2385 pV2388) pV2389) 
                                 (NAT-SPEC::div k 2))))))))) 
           (return (SYSTEM-SPEC::fail "Impossible: mergepairs"))))) 
        (labels 
          ((nextrun (run xs) 
            (block 
             nil 
             (if (null xs) 
                 (return (cons (LIST-SPEC::rev run) nil)) 
                 (if (consp xs) 
                     (let ((pV2392 (car xs))
                           (pV2393 (cdr xs))) 
                       (return 
                        (if (funcall cmpGT (cons pV2392 (LIST-SPEC::hd run))) 
                            (nextrun (cons pV2392 run) pV2393) 
                            (cons (LIST-SPEC::rev run) (cons pV2392 pV2393))))))) 
             (error "Nonexhaustive match failure in sortGT")))) 
          (labels 
            ((samsorting (xs ls1 k) 
              (block 
               nil 
               (if (null xs) 
                   (return (LIST-SPEC::hd (mergepairs ls1 0))) 
                   (if (consp xs) 
                       (return 
                        (let ((pV2394 (nextrun (cons (car xs) nil) (cdr xs)))) 
                          (block 
                           nil 
                           (return 
                            (samsorting 
                             (cdr pV2394) 
                             (mergepairs 
                              (cons (car pV2394) ls1) 
                              (INTEGER-SPEC::|!+| k 1)) 
                             (INTEGER-SPEC::|!+| k 1))) 
                           (error "Nonexhaustive match failure in sortGT")))))) 
               (error "Nonexhaustive match failure in sortGT")))) 
            (block 
             nil 
             (if (null ls) (return nil)) 
             (return (samsorting ls nil 0))))))))))
                                                   
(defun MERGESORT::sortGT (x1) #'(lambda (x2) (MERGESORT::sortGT-1-1 x1 x2)))
                                                                            
(defun MERGESORT::sorted-1-1 (cmpGT xs) 
  (block 
   nil 
   (if (consp xs) 
       (let ((pV2412 (cdr xs))) 
         (if (consp pV2412) 
             (return 
              (lisp::and 
               (BOOLEAN-SPEC::~ (funcall cmpGT (cons (car xs) (car pV2412)))) 
               (MERGESORT::sorted-1-1 cmpGT pV2412)))))) 
   (return t)))
               
(defun MERGESORT::sorted (x1) #'(lambda (x2) (MERGESORT::sorted-1-1 x1 x2)))
                                                                            
(defun MERGESORT::uniqueSort-1-1 (cmpfn ls) 
  (labels 
    ((|!merge| (xs ys) 
      (block 
       nil 
       (if (null xs) (return ys)) 
       (if (null ys) (return xs)) 
       (if (consp xs) 
           (let ((pV2421 (car xs))
                 (pV2422 (cdr xs))) 
             (if (consp ys) 
                 (let ((pV2424 (car ys))
                       (pV2425 (cdr ys))) 
                   (return 
                    (let ((pV2417 (funcall cmpfn (cons pV2421 pV2424)))) 
                      (block 
                       nil 
                       (if (eq (car pV2417) :|Greater|) 
                           (return 
                            (cons pV2424 (|!merge| (cons pV2421 pV2422) pV2425))) 
                           (if (eq (car pV2417) :|Equal|) 
                               (return (|!merge| (cons pV2421 pV2422) pV2425)))) 
                       (return 
                        (cons pV2421 (|!merge| pV2422 (cons pV2424 pV2425))))))))))) 
       (error "Nonexhaustive match failure in uniqueSort")))) 
    (labels 
      ((mergepairs (ls k) 
        (block 
         nil 
         (if (consp ls) 
             (let ((pV2429 (car ls))
                   (pV2430 (cdr ls))) 
               (if (null pV2430) 
                   (return ls) 
                   (if (consp pV2430) 
                       (let ((pV2432 (car pV2430))
                             (pV2433 (cdr pV2430))) 
                         (return 
                          (if ( =  (NAT-SPEC::|!rem| k 2) 1) 
                              (cons pV2429 (cons pV2432 pV2433)) 
                              (mergepairs 
                               (cons (|!merge| pV2429 pV2432) pV2433) 
                               (NAT-SPEC::div k 2))))))))) 
         (return (SYSTEM-SPEC::fail "Impossible: mergepairs"))))) 
      (labels 
        ((nextrun (run xs) 
          (block 
           nil 
           (if (null xs) 
               (return (cons (LIST-SPEC::rev run) nil)) 
               (if (consp xs) 
                   (let ((pV2438 (car xs))
                         (pV2439 (cdr xs))) 
                     (return 
                      (let ((pV2435 
                             (funcall cmpfn (cons pV2438 (LIST-SPEC::hd run))))) 
                        (block 
                         nil 
                         (if (eq (car pV2435) :|Greater|) 
                             (return (nextrun (cons pV2438 run) pV2439)) 
                             (if (eq (car pV2435) :|Equal|) 
                                 (return (nextrun run pV2439)))) 
                         (return 
                          (cons (LIST-SPEC::rev run) (cons pV2438 pV2439))))))))) 
           (error "Nonexhaustive match failure in uniqueSort")))) 
        (labels 
          ((samsorting (xs ls k) 
            (block 
             nil 
             (if (null xs) 
                 (return (LIST-SPEC::hd (mergepairs ls 0))) 
                 (if (consp xs) 
                     (return 
                      (let ((pV2440 (nextrun (cons (car xs) nil) (cdr xs)))) 
                        (block 
                         nil 
                         (return 
                          (samsorting 
                           (cdr pV2440) 
                           (mergepairs 
                            (cons (car pV2440) ls) 
                            (INTEGER-SPEC::|!+| k 1)) 
                           (INTEGER-SPEC::|!+| k 1))) 
                         (error "Nonexhaustive match failure in uniqueSort")))))) 
             (error "Nonexhaustive match failure in uniqueSort")))) 
          (block nil (if (null ls) (return nil)) (return (samsorting ls nil 0))))))))


(defun MERGESORT::uniqueSort (x1) 
  #'(lambda (x2) (MERGESORT::uniqueSort-1-1 x1 x2)))
                                                    
(defun METASLANG::appPattern-1 (x1) 
  #'(lambda (x2) (METASLANG::appPattern-1-1 x1 x2)))
                                                    
(defun METASLANG::appPattern (x0 x1 x2) 
  (METASLANG::appPattern-1 (vector x0 x1 x2)))
                                              
(defun METASLANG::appSort (x0 x1 x2) (METASLANG::appSort-1 (vector x0 x1 x2)))
                                                                              
(defun METASLANG::appSortOpt (x0 x1 x2) 
  (METASLANG::appSortOpt-1 (vector x0 x1 x2)))
                                              
(defun METASLANG::appTerm (x0 x1 x2) (METASLANG::appTerm-1 (vector x0 x1 x2)))
                                                                              
(defun METASLANG::appTermOpt (x0 x1 x2) 
  (METASLANG::appTermOpt-1 (vector x0 x1 x2)))
                                              
(defun METASLANG::boolSort? (s) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV2593 (cdr s))) 
         (let ((pV2594 (svref pV2593 0))) 
           (if (eq (car pV2594) :|Qualified|) 
               (let ((pV2597 (cdr pV2594))) 
                 (if (string=  "Boolean" (car pV2597)) 
                     (if (string=  "Boolean" (cdr pV2597)) 
                         (if (null (svref pV2593 1)) (return t))))))))) 
   (return nil)))
                 
(defun METASLANG::equalFun?-1 (x) (METASLANG::equalFun? (car x) (cdr x)))
                                                                         
(defun METASLANG::equalList?-1 (x) 
  (METASLANG::equalList? (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun METASLANG::equalOpt?-1 (x) 
  (METASLANG::equalOpt? (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun METASLANG::existsSubTerm-1-1 (pred? term) 
  (lisp::or 
   (funcall pred? term) 
   (block 
    nil 
    (if (eq (car term) :|Var|) 
        (return nil) 
        (if (eq (car term) :|Fun|) 
            (return nil) 
            (if (eq (car term) :|Apply|) 
                (let ((pV3065 (cdr term))) 
                  (return 
                   (lisp::or 
                    (METASLANG::existsSubTerm-1-1 pred? (svref pV3065 0)) 
                    (METASLANG::existsSubTerm-1-1 pred? (svref pV3065 1))))) 
                (if (eq (car term) :|Record|) 
                    (return 
                     (LIST-SPEC::|!exists|-1-1 
                      #'(lambda (x) 
                         (METASLANG::existsSubTerm-1-1 pred? (cdr x))) 
                      (car (cdr term)))) 
                    (if (eq (car term) :|Let|) 
                        (let ((pV3063 (cdr term))) 
                          (return 
                           (lisp::or 
                            (METASLANG::existsSubTerm-1-1 pred? (svref pV3063 1)) 
                            (LIST-SPEC::|!exists|-1-1 
                             #'(lambda (x) 
                                (METASLANG::existsSubTerm-1-1 pred? (cdr x))) 
                             (svref pV3063 0))))) 
                        (if (eq (car term) :|LetRec|) 
                            (let ((pV3062 (cdr term))) 
                              (return 
                               (lisp::or 
                                (METASLANG::existsSubTerm-1-1 
                                 pred? 
                                 (svref pV3062 1)) 
                                (LIST-SPEC::|!exists|-1-1 
                                 #'(lambda (x) 
                                    (METASLANG::existsSubTerm-1-1 pred? (cdr x))) 
                                 (svref pV3062 0))))) 
                            (if (eq (car term) :|Seq|) 
                                (return 
                                 (LIST-SPEC::|!exists|-1-1 
                                  (METASLANG::existsSubTerm pred?) 
                                  (car (cdr term)))) 
                                (if (eq (car term) :|IfThenElse|) 
                                    (let ((pV3060 (cdr term))) 
                                      (return 
                                       (lisp::or 
                                        (METASLANG::existsSubTerm-1-1 
                                         pred? 
                                         (svref pV3060 0)) 
                                        (lisp::or 
                                         (METASLANG::existsSubTerm-1-1 
                                          pred? 
                                          (svref pV3060 1)) 
                                         (METASLANG::existsSubTerm-1-1 
                                          pred? 
                                          (svref pV3060 2)))))) 
                                    (if (eq (car term) :|Bind|) 
                                        (return 
                                         (METASLANG::existsSubTerm-1-1 
                                          pred? 
                                          (svref (cdr term) 2))) 
                                        (if (eq (car term) :|Lambda|) 
                                            (return 
                                             (LIST-SPEC::|!exists|-1-1 
                                              #'(lambda (x) 
                                                 (lisp::or 
                                                  (METASLANG::existsSubTerm-1-1 
                                                   pred? 
                                                   (svref x 1)) 
                                                  (METASLANG::existsSubTerm-1-1 
                                                   pred? 
                                                   (svref x 2)))) 
                                              (car (cdr term)))) 
                                            (if (eq (car term) :|ApplyN|) 
                                                (return 
                                                 (LIST-SPEC::|!exists|-1-1 
                                                  (METASLANG::existsSubTerm 
                                                   pred?) 
                                                  (car (cdr term)))) 
                                                (if (eq (car term) :|SortedTerm|) 
                                                    (return 
                                                     (METASLANG::existsSubTerm-1-1 
                                                      pred? 
                                                      (svref (cdr term) 0))))))))))))))) 
    (error "Nonexhaustive match failure in existsSubTerm"))))
                                                             
(defun METASLANG::existsSubTerm (x1) 
  #'(lambda (x2) (METASLANG::existsSubTerm-1-1 x1 x2)))
                                                       
(defun METASLANG::mapPattern-1 (x1) 
  #'(lambda (x2) (METASLANG::mapPattern-1-1 x1 x2)))
                                                    
(defun METASLANG::mapPattern (x0 x1 x2) 
  (METASLANG::mapPattern-1 (vector x0 x1 x2)))
                                              
(defun METASLANG::mapSort-1 (x1) 
  #'(lambda (x2) (METASLANG::mapSort-1-1 x1 x2)))
                                                 
(defun METASLANG::mapSort (x0 x1 x2) (METASLANG::mapSort-1 (vector x0 x1 x2)))
                                                                              
(defun METASLANG::mapTerm-1 (x1) 
  #'(lambda (x2) (METASLANG::mapTerm-1-1 x1 x2)))
                                                 
(defun METASLANG::mapTerm (x0 x1 x2) (METASLANG::mapTerm-1 (vector x0 x1 x2)))
                                                                              
(defun METASLANG::mkABase-1 (x) 
  (METASLANG::mkABase (svref x 0) (svref x 1) (svref x 2)))
                                                           
(defun METASLANG::mkAQualifiedId (qualifier id x) 
  (cons (cons :|Qualified| (cons qualifier id)) x))
                                                   
(defun METASLANG::mkAQualifiedId-1 (x) 
  (METASLANG::mkAQualifiedId (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun METASLANG::mkAUnQualifiedId (id x) 
  (cons (cons :|Qualified| (cons METASLANG::UnQualified id)) x))
                                                                
(defun METASLANG::mkAUnQualifiedId-1 (x) 
  (METASLANG::mkAUnQualifiedId (car x) (cdr x)))
                                                
(defun METASLANG::mkFalseA (a) 
  (cons :|Fun| (vector (cons :|Bool| nil) (METASLANG::boolSort a) a)))
                                                                      
(defun METASLANG::mkQualifiedId (qualifier id) 
  (cons :|Qualified| (cons qualifier id)))
                                          
(defun METASLANG::mkQualifiedId-1 (x) 
  (METASLANG::mkQualifiedId (car x) (cdr x)))
                                             
(defun METASLANG::mkUnQualifiedId (id) 
  (cons :|Qualified| (cons METASLANG::UnQualified id)))
                                                       
(defun METASLANG::natSort? (s) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV3243 (cdr s))) 
         (let ((pV3244 (svref pV3243 0))) 
           (if (eq (car pV3244) :|Qualified|) 
               (let ((pV3247 (cdr pV3244))) 
                 (if (string=  "Nat" (car pV3247)) 
                     (if (string=  "Nat" (cdr pV3247)) 
                         (if (null (svref pV3243 1)) (return t))))))))) 
   (return nil)))
                 
(defun METASLANG::printQualifierDotId (qualifier id) 
  (if (lisp::or 
       (string=  qualifier "Nat") 
       (lisp::or 
        (string=  qualifier "Boolean") 
        (lisp::or 
         (string=  qualifier "String") 
         (lisp::or 
          (string=  qualifier "Char") 
          (string=  qualifier METASLANG::UnQualified))))) 
      id 
      (STRING-SPEC::^ (STRING-SPEC::^ qualifier ".") id)))
                                                          
(defun METASLANG::printQualifiedId (pV3308) 
  (block 
   nil 
   (if (eq (car pV3308) :|Qualified|) 
       (let ((pV3309 (cdr pV3308))) 
         (let ((pV3311 (cdr pV3309))
               (pV3310 (car pV3309))) 
           (return 
            (if (string=  pV3310 METASLANG::UnQualified) 
                pV3311 
                (METASLANG::printQualifierDotId pV3310 pV3311)))))) 
   (error "Nonexhaustive match failure in printQualifiedId")))
                                                              
(defun METASLANG::printQualifierDotId-1 (x) 
  (METASLANG::printQualifierDotId (car x) (cdr x)))
                                                   
(defun METASLANG::replaceTerm-1-1 (tsp_maps term) 
  (let ((term_map (svref tsp_maps 0))) 
    (labels 
      ((replaceRec (term) 
        (let ((pV3427 (funcall term_map term))) 
          (block 
           nil 
           (if (eq (car pV3427) :|None|) 
               (return (|!replace| term)) 
               (if (eq (car pV3427) :|Some|) (return (cdr pV3427)))) 
           (error "Nonexhaustive match failure in replaceTerm"))))
       (|!replace| (term) 
        (block 
         nil 
         (if (eq (car term) :|Fun|) 
             (let ((pV3391 (cdr term))) 
               (return 
                (cons 
                 :|Fun| 
                 (vector 
                  (svref pV3391 0) 
                  (METASLANG::replaceSort-1-1 tsp_maps (svref pV3391 1)) 
                  (svref pV3391 2))))) 
             (if (eq (car term) :|Var|) 
                 (let ((pV3390 (cdr term))) 
                   (let ((pV3420 (car pV3390))) 
                     (return 
                      (cons 
                       :|Var| 
                       (cons 
                        (cons 
                         (car pV3420) 
                         (METASLANG::replaceSort-1-1 tsp_maps (cdr pV3420))) 
                        (cdr pV3390)))))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV3389 (cdr term))) 
                       (return 
                        (cons 
                         :|Let| 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x1) 
                              (cons 
                               (METASLANG::replacePattern-1-1 tsp_maps (car x1)) 
                               (replaceRec (cdr x1)))) 
                           (svref pV3389 0)) 
                          (replaceRec (svref pV3389 1)) 
                          (svref pV3389 2))))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV3388 (cdr term))) 
                           (return 
                            (cons 
                             :|LetRec| 
                             (vector 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x1) 
                                  (cons (car x1) (replaceRec (cdr x1)))) 
                               (svref pV3388 0)) 
                              (replaceRec (svref pV3388 1)) 
                              (svref pV3388 2))))) 
                         (if (eq (car term) :|Record|) 
                             (let ((pV3387 (cdr term))) 
                               (return 
                                (cons 
                                 :|Record| 
                                 (cons 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'(lambda (x1) 
                                      (cons (car x1) (replaceRec (cdr x1)))) 
                                   (car pV3387)) 
                                  (cdr pV3387))))) 
                             (if (eq (car term) :|IfThenElse|) 
                                 (let ((pV3386 (cdr term))) 
                                   (return 
                                    (cons 
                                     :|IfThenElse| 
                                     (vector 
                                      (replaceRec (svref pV3386 0)) 
                                      (replaceRec (svref pV3386 1)) 
                                      (replaceRec (svref pV3386 2)) 
                                      (svref pV3386 3))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (let ((pV3385 (cdr term))) 
                                       (return 
                                        (cons 
                                         :|Lambda| 
                                         (cons 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x1) 
                                              (vector 
                                               (METASLANG::replacePattern-1-1 
                                                tsp_maps 
                                                (svref x1 0)) 
                                               (replaceRec (svref x1 1)) 
                                               (replaceRec (svref x1 2)))) 
                                           (car pV3385)) 
                                          (cdr pV3385))))) 
                                     (if (eq (car term) :|Bind|) 
                                         (let ((pV3384 (cdr term))) 
                                           (return 
                                            (cons 
                                             :|Bind| 
                                             (vector 
                                              (svref pV3384 0) 
                                              (LIST-SPEC::|!map|-1-1 
                                               #'(lambda (x1) 
                                                  (cons 
                                                   (car x1) 
                                                   (METASLANG::replaceSort-1-1 
                                                    tsp_maps 
                                                    (cdr x1)))) 
                                               (svref pV3384 1)) 
                                              (replaceRec (svref pV3384 2)) 
                                              (svref pV3384 3))))) 
                                         (if (eq (car term) :|Apply|) 
                                             (let ((pV3383 (cdr term))) 
                                               (return 
                                                (cons 
                                                 :|Apply| 
                                                 (vector 
                                                  (replaceRec (svref pV3383 0)) 
                                                  (replaceRec (svref pV3383 1)) 
                                                  (svref pV3383 2))))) 
                                             (if (eq (car term) :|Seq|) 
                                                 (let ((pV3382 (cdr term))) 
                                                   (return 
                                                    (cons 
                                                     :|Seq| 
                                                     (cons 
                                                      (LIST-SPEC::|!map|-1-1 
                                                       #'replaceRec 
                                                       (car pV3382)) 
                                                      (cdr pV3382))))) 
                                                 (if (eq (car term) :|ApplyN|) 
                                                     (let ((pV3381 (cdr term))) 
                                                       (return 
                                                        (cons 
                                                         :|ApplyN| 
                                                         (cons 
                                                          (LIST-SPEC::|!map|-1-1 
                                                           #'replaceRec 
                                                           (car pV3381)) 
                                                          (cdr pV3381))))) 
                                                     (if (eq 
                                                          (car term) 
                                                          :|SortedTerm|) 
                                                         (let ((pV3380 
                                                                (cdr term))) 
                                                           (return 
                                                            (cons 
                                                             :|SortedTerm| 
                                                             (vector 
                                                              (replaceRec 
                                                               (svref pV3380 0)) 
                                                              (METASLANG::replaceSort-1-1 
                                                               tsp_maps 
                                                               (svref pV3380 1)) 
                                                              (svref pV3380 2))))))))))))))))) 
         (error "Nonexhaustive match failure in replaceTerm")))) 
      (replaceRec term))))
                          
(defun METASLANG::replaceSort-1-1 (tsp_maps srt) 
  (let ((sort_map (svref tsp_maps 1))) 
    (labels 
      ((replaceRec (srt) 
        (let ((pV3375 (funcall sort_map srt))) 
          (block 
           nil 
           (if (eq (car pV3375) :|None|) 
               (return (|!replace| srt)) 
               (if (eq (car pV3375) :|Some|) (return (cdr pV3375)))) 
           (error "Nonexhaustive match failure in replaceSort"))))
       (replaceRecOpt (opt_srt) 
        (block 
         nil 
         (if (eq (car opt_srt) :|None|) 
             (return '(:|None|)) 
             (if (eq (car opt_srt) :|Some|) 
                 (return (cons :|Some| (replaceRec (cdr opt_srt)))))) 
         (error "Nonexhaustive match failure in replaceSort")))
       (|!replace| (srt) 
        (block 
         nil 
         (if (eq (car srt) :|CoProduct|) 
             (let ((pV3356 (cdr srt))) 
               (return 
                (cons 
                 :|CoProduct| 
                 (cons 
                  (LIST-SPEC::|!map|-1-1 
                   #'(lambda (x1) (cons (car x1) (replaceRecOpt (cdr x1)))) 
                   (car pV3356)) 
                  (cdr pV3356))))) 
             (if (eq (car srt) :|Product|) 
                 (let ((pV3355 (cdr srt))) 
                   (return 
                    (cons 
                     :|Product| 
                     (cons 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (x1) (cons (car x1) (replaceRec (cdr x1)))) 
                       (car pV3355)) 
                      (cdr pV3355))))) 
                 (if (eq (car srt) :|Arrow|) 
                     (let ((pV3354 (cdr srt))) 
                       (return 
                        (cons 
                         :|Arrow| 
                         (vector 
                          (replaceRec (svref pV3354 0)) 
                          (replaceRec (svref pV3354 1)) 
                          (svref pV3354 2))))) 
                     (if (eq (car srt) :|Quotient|) 
                         (let ((pV3353 (cdr srt))) 
                           (return 
                            (cons 
                             :|Quotient| 
                             (vector 
                              (replaceRec (svref pV3353 0)) 
                              (METASLANG::replaceTerm-1-1 
                               tsp_maps 
                               (svref pV3353 1)) 
                              (svref pV3353 2))))) 
                         (if (eq (car srt) :|Subsort|) 
                             (let ((pV3352 (cdr srt))) 
                               (return 
                                (cons 
                                 :|Subsort| 
                                 (vector 
                                  (replaceRec (svref pV3352 0)) 
                                  (METASLANG::replaceTerm-1-1 
                                   tsp_maps 
                                   (svref pV3352 1)) 
                                  (svref pV3352 2))))) 
                             (if (eq (car srt) :|Base|) 
                                 (let ((pV3351 (cdr srt))) 
                                   (let ((pV3357 (svref pV3351 0))
                                         (pV3358 (svref pV3351 1))
                                         (pV3359 (svref pV3351 2))) 
                                     (progn (return 
                                             (cons 
                                              :|Base| 
                                              (vector 
                                               pV3357 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'replaceRec 
                                                pV3358) 
                                               pV3359))) 
                                            (return 
                                             (cons 
                                              :|Base| 
                                              (vector 
                                               pV3357 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'replaceRec 
                                                pV3358) 
                                               pV3359)))))))))))) 
         (return srt)))) (replaceRec srt))))
                                            
(defun METASLANG::replacePattern-1-1 (tsp_maps pattern) 
  (let ((pattern_map (svref tsp_maps 2))) 
    (labels 
      ((replaceRec (pattern) 
        (let ((pV3345 (funcall pattern_map pattern))) 
          (block 
           nil 
           (if (eq (car pV3345) :|None|) 
               (return (|!replace| pattern)) 
               (if (eq (car pV3345) :|Some|) (return (cdr pV3345)))) 
           (error "Nonexhaustive match failure in replacePattern"))))
       (|!replace| (pattern) 
        (block 
         nil 
         (if (eq (car pattern) :|AliasPat|) 
             (let ((pV3322 (cdr pattern))) 
               (return 
                (cons 
                 :|AliasPat| 
                 (vector 
                  (replaceRec (svref pV3322 0)) 
                  (replaceRec (svref pV3322 1)) 
                  (svref pV3322 2))))) 
             (if (eq (car pattern) :|EmbedPat|) 
                 (let ((pV3321 (cdr pattern))) 
                   (let ((pV3337 (svref pV3321 0))
                         (pV3338 (svref pV3321 1))
                         (pV3339 (svref pV3321 2))
                         (pV3340 (svref pV3321 3))) 
                     (if (eq (car pV3338) :|Some|) 
                         (return 
                          (cons 
                           :|EmbedPat| 
                           (vector 
                            pV3337 
                            (cons :|Some| (replaceRec (cdr pV3338))) 
                            (METASLANG::replaceSort-1-1 tsp_maps pV3339) 
                            pV3340))) 
                         (if (eq (car pV3338) :|None|) 
                             (return 
                              (cons 
                               :|EmbedPat| 
                               (vector 
                                pV3337 
                                '(:|None|) 
                                (METASLANG::replaceSort-1-1 tsp_maps pV3339) 
                                pV3340))))))) 
                 (if (eq (car pattern) :|RelaxPat|) 
                     (let ((pV3320 (cdr pattern))) 
                       (return 
                        (cons 
                         :|RelaxPat| 
                         (vector 
                          (replaceRec (svref pV3320 0)) 
                          (METASLANG::replaceTerm-1-1 tsp_maps (svref pV3320 1)) 
                          (svref pV3320 2))))) 
                     (if (eq (car pattern) :|QuotientPat|) 
                         (let ((pV3319 (cdr pattern))) 
                           (return 
                            (cons 
                             :|QuotientPat| 
                             (vector 
                              (replaceRec (svref pV3319 0)) 
                              (METASLANG::replaceTerm-1-1 
                               tsp_maps 
                               (svref pV3319 1)) 
                              (svref pV3319 2))))) 
                         (if (eq (car pattern) :|VarPat|) 
                             (let ((pV3318 (cdr pattern))) 
                               (let ((pV3327 (car pV3318))) 
                                 (return 
                                  (cons 
                                   :|VarPat| 
                                   (cons 
                                    (cons 
                                     (car pV3327) 
                                     (METASLANG::replaceSort-1-1 
                                      tsp_maps 
                                      (cdr pV3327))) 
                                    (cdr pV3318)))))) 
                             (if (eq (car pattern) :|WildPat|) 
                                 (let ((pV3317 (cdr pattern))) 
                                   (return 
                                    (cons 
                                     :|WildPat| 
                                     (cons 
                                      (METASLANG::replaceSort-1-1 
                                       tsp_maps 
                                       (car pV3317)) 
                                      (cdr pV3317))))) 
                                 (if (eq (car pattern) :|RecordPat|) 
                                     (let ((pV3316 (cdr pattern))) 
                                       (return 
                                        (cons 
                                         :|RecordPat| 
                                         (cons 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x1) 
                                              (cons 
                                               (car x1) 
                                               (replaceRec (cdr x1)))) 
                                           (car pV3316)) 
                                          (cdr pV3316)))))))))))) 
         (return pattern)))) (replaceRec pattern))))
                                                    
(defun METASLANG::replacePattern-1 (x1) 
  #'(lambda (x2) (METASLANG::replacePattern-1-1 x1 x2)))
                                                        
(defun METASLANG::replacePattern (x0 x1 x2) 
  (METASLANG::replacePattern-1 (vector x0 x1 x2)))
                                                  
(defun METASLANG::replaceSort-1 (x1) 
  #'(lambda (x2) (METASLANG::replaceSort-1-1 x1 x2)))
                                                     
(defun METASLANG::replaceSort (x0 x1 x2) 
  (METASLANG::replaceSort-1 (vector x0 x1 x2)))
                                               
(defun METASLANG::replaceTerm-1 (x1) 
  #'(lambda (x2) (METASLANG::replaceTerm-1-1 x1 x2)))
                                                     
(defun METASLANG::replaceTerm (x0 x1 x2) 
  (METASLANG::replaceTerm-1 (vector x0 x1 x2)))
                                               
(defun METASLANG::sortAnn (s) 
  (block 
   nil 
   (if (eq (car s) :|Arrow|) 
       (return (svref (cdr s) 2)) 
       (if (eq (car s) :|Product|) 
           (return (cdr (cdr s))) 
           (if (eq (car s) :|CoProduct|) 
               (return (cdr (cdr s))) 
               (if (eq (car s) :|Quotient|) 
                   (return (svref (cdr s) 2)) 
                   (if (eq (car s) :|Subsort|) 
                       (return (svref (cdr s) 2)) 
                       (if (eq (car s) :|Base|) 
                           (return (svref (cdr s) 2)) 
                           (if (eq (car s) :|TyVar|) 
                               (return (cdr (cdr s))) 
                               (if (eq (car s) :|MetaTyVar|) 
                                   (return (cdr (cdr s))))))))))) 
   (error "Nonexhaustive match failure in sortAnn")))
                                                     
(defun METASLANG::stringSort? (s) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV3473 (cdr s))) 
         (let ((pV3474 (svref pV3473 0))) 
           (if (eq (car pV3474) :|Qualified|) 
               (let ((pV3477 (cdr pV3474))) 
                 (if (string=  "String" (car pV3477)) 
                     (if (string=  "String" (cdr pV3477)) 
                         (if (null (svref pV3473 1)) (return t))))))))) 
   (return nil)))
                 
(defun METASLANG::termAnn (|!t|) 
  (block 
   nil 
   (if (eq (car |!t|) :|ApplyN|) 
       (return (cdr (cdr |!t|))) 
       (if (eq (car |!t|) :|Record|) 
           (return (cdr (cdr |!t|))) 
           (if (eq (car |!t|) :|Bind|) 
               (return (svref (cdr |!t|) 3)) 
               (if (eq (car |!t|) :|Let|) 
                   (return (svref (cdr |!t|) 2)) 
                   (if (eq (car |!t|) :|LetRec|) 
                       (return (svref (cdr |!t|) 2)) 
                       (if (eq (car |!t|) :|Var|) 
                           (return (cdr (cdr |!t|))) 
                           (if (eq (car |!t|) :|SortedTerm|) 
                               (return (svref (cdr |!t|) 2)) 
                               (if (eq (car |!t|) :|Fun|) 
                                   (return (svref (cdr |!t|) 2)) 
                                   (if (eq (car |!t|) :|Lambda|) 
                                       (return (cdr (cdr |!t|))) 
                                       (if (eq (car |!t|) :|IfThenElse|) 
                                           (return (svref (cdr |!t|) 3)) 
                                           (if (eq (car |!t|) :|Seq|) 
                                               (return (cdr (cdr |!t|)))))))))))))) 
   (error "Nonexhaustive match failure in termAnn")))
                                                     
(defun METASLANG::withAnnS (s a) 
  (block 
   nil 
   (if (eq (car s) :|Arrow|) 
       (let ((pV3653 (cdr s))) 
         (return (cons :|Arrow| (vector (svref pV3653 0) (svref pV3653 1) a)))) 
       (if (eq (car s) :|Product|) 
           (return (cons :|Product| (cons (car (cdr s)) a))) 
           (if (eq (car s) :|CoProduct|) 
               (return (cons :|CoProduct| (cons (car (cdr s)) a))) 
               (if (eq (car s) :|Quotient|) 
                   (let ((pV3650 (cdr s))) 
                     (return 
                      (cons 
                       :|Quotient| 
                       (vector (svref pV3650 0) (svref pV3650 1) a)))) 
                   (if (eq (car s) :|Subsort|) 
                       (let ((pV3649 (cdr s))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector (svref pV3649 0) (svref pV3649 1) a)))) 
                       (if (eq (car s) :|Base|) 
                           (let ((pV3648 (cdr s))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector (svref pV3648 0) (svref pV3648 1) a)))) 
                           (if (eq (car s) :|TyVar|) 
                               (return (cons :|TyVar| (cons (car (cdr s)) a))) 
                               (if (eq (car s) :|MetaTyVar|) 
                                   (return 
                                    (cons :|MetaTyVar| (cons (car (cdr s)) a))))))))))) 
   (error "Nonexhaustive match failure in withAnnS")))
                                                      
(defun METASLANG::withAnnS-1 (x) (METASLANG::withAnnS (car x) (cdr x)))
                                                                       
(defun NAT-SPEC::div-1 (x) (NAT-SPEC::div (car x) (cdr x)))
                                                           
(defparameter NAT-SPEC::one 1)
                              
(defun NAT-SPEC::posNat? (n) (INTEGER-SPEC::|!>| n 0))
                                                      
(defun NAT-SPEC::pred (n) (INTEGER-SPEC::|!-| n 1))
                                                   
(defun NAT-SPEC::show (n) (NAT-SPEC::natToString n))
                                                    
(defun NAT-SPEC::succ (n) (INTEGER-SPEC::|!+| n 1))
                                                   
(defparameter NAT-SPEC::two 2)
                              
(defparameter NAT-SPEC::zero 0)
                               
(defun SPLAYMAP::applyi-1-1 (af sp) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return nil) 
       (if (eq (car sp) :|SplayObj|) 
           (let ((pV8553 (cdr sp))) 
             (return 
              (progn (SPLAYMAP::applyi-1-1 af (svref pV8553 0)) 
                     (funcall af (svref pV8553 2)) 
                     (SPLAYMAP::applyi-1-1 af (svref pV8553 1))))))) 
   (error "Nonexhaustive match failure in applyi")))
                                                    
(defun SPLAYMAP::appi-1-1 (af |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::applyi-1-1 af (STATE::|!!| (svref (cdr |!map|) 2)))))) 
   (error "Nonexhaustive match failure in appi")))
                                                  
(defun SPLAYMAP::appi (x1) #'(lambda (x2) (SPLAYMAP::appi-1-1 x1 x2)))
                                                                      
(defun NATMAP::appi (x) (SPLAYMAP::appi x))
                                           
(defun NATMAP::appi-1-1 (x0 x1) (SPLAYMAP::appi-1-1 x0 x1))
                                                           
(defun SPLAYMAP::compose (map1 map2) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (let ((map3 (svref x 2))) 
        (let ((pV8618 (SPLAYMAP::|!find| map2 (svref x 1)))) 
          (block 
           nil 
           (if (eq (car pV8618) :|Some|) 
               (return (SPLAYMAP::insert map3 (svref x 0) (cdr pV8618))) 
               (if (eq (car pV8618) :|None|) (return map3))) 
           (error "Nonexhaustive match failure in compose"))))) 
   (SPLAYMAP::empty 
    (block 
     nil 
     (if (eq (car map1) :|EMPTY|) 
         (return (cdr map1)) 
         (if (eq (car map1) :|MAP|) (return (svref (cdr map1) 0)))) 
     (error "Nonexhaustive match failure in compose"))) 
   map1))
         
(defun NATMAP::compose (x0 x) (SPLAYMAP::compose x0 x))
                                                       
(defun NATMAP::compose-1 (x) (NATMAP::compose (car x) (cdr x)))
                                                               
(defun NATMAP::|!find| (x0 x) (SPLAYMAP::|!find| x0 x))
                                                       
(defun NATMAP::|!find|-1 (x) (NATMAP::|!find| (car x) (cdr x)))
                                                               
(defun SPLAYMAP::foldri (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldri-1-1-1 x1 x2 x3))))
                                                                    
(defun NATMAP::foldri (x) (SPLAYMAP::foldri x))
                                               
(defun NATMAP::foldri-1-1-1 (x0 x1 x2) (SPLAYMAP::foldri-1-1-1 x0 x1 x2))
                                                                         
(defun SPLAYMAP::inDomain (|!map| key) 
  (let ((pV8700 (SPLAYMAP::|!find| |!map| key))) 
    (block 
     nil 
     (if (eq (car pV8700) :|Some|) 
         (return t) 
         (if (eq (car pV8700) :|None|) (return nil))) 
     (error "Nonexhaustive match failure in inDomain"))))
                                                         
(defun NATMAP::inDomain (x0 x) (SPLAYMAP::inDomain x0 x))
                                                         
(defun NATMAP::inDomain-1 (x) (NATMAP::inDomain (car x) (cdr x)))
                                                                 
(defun NATMAP::insert-1 (x) 
  (NATMAP::insert (svref x 0) (svref x 1) (svref x 2)))
                                                       
(defun SPLAYMAP::listItems (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::listItemsf 
             #'(lambda (x) (cdr x)) 
             (STATE::|!!| (svref (cdr |!map|) 2)) 
             nil)))) 
   (error "Nonexhaustive match failure in listItems")))
                                                       
(defun NATMAP::listItems (x) (SPLAYMAP::listItems x))
                                                     
(defun SPLAYMAP::|!map| (x1) #'(lambda (x2) (SPLAYMAP::|!map|-1-1 x1 x2)))
                                                                          
(defun NATMAP::|!map| (x) (SPLAYMAP::|!map| x))
                                               
(defun NATMAP::|!map|-1-1 (x0 x1) (SPLAYMAP::|!map|-1-1 x0 x1))
                                                               
(defun SPLAYMAP::mapi (x1) #'(lambda (x2) (SPLAYMAP::mapi-1-1 x1 x2)))
                                                                      
(defun NATMAP::mapi (x) (SPLAYMAP::mapi x))
                                           
(defun NATMAP::mapi-1-1 (x0 x1) (SPLAYMAP::mapi-1-1 x0 x1))
                                                           
(defun SPLAYMAP::numItems (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return 0) 
       (if (eq (car |!map|) :|MAP|) (return (svref (cdr |!map|) 1)))) 
   (error "Nonexhaustive match failure in numItems")))
                                                      
(defun NATMAP::numItems (x) (SPLAYMAP::numItems x))
                                                   
(defun NATTRANS::build-1-1-1 (domFunc codFunc components) 
  (vector codFunc components domFunc))
                                      
(defun NATTRANS::build-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (NATTRANS::build-1-1-1 x1 x2 x3))))
                                                                   
(defun NATTRANS::build (x0 x1 x2 x3) (NATTRANS::build-1 (vector x0 x1 x2 x3)))
                                                                              
(defun NATTRANS::cod-1 (nt) (svref nt 0))
                                         
(defun NATTRANS::cod (x0 x1 x2) (NATTRANS::cod-1 (vector x0 x1 x2)))
                                                                    
(defun NATTRANS::components-1 (nt) (svref nt 1))
                                                
(defun NATTRANS::components (x0 x1 x2) 
  (NATTRANS::components-1 (vector x0 x1 x2)))
                                             
(defun NATTRANS::dom-1 (nt) (svref nt 2))
                                         
(defun NATTRANS::dom (x0 x1 x2) (NATTRANS::dom-1 (vector x0 x1 x2)))
                                                                    
(defun NATTRANS::emptyNatTrans (x0 x1 x2 x3 x4 x5 x6 x7) 
  (NATTRANS::emptyNatTrans-1 (vector x0 x1 x2 x3 x4 x5 x6 x7)))
                                                               
(defun NATTRANS::ppNatTrans-1 (nt) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "Components=") 
    (cons 
     (WADLERLINDIG::ppNest-1-1 
      2 
      (POLYMAP::ppMap-1-1-1 
       #'VERTEX::ppElem 
       (CAT::ppArr-1 (FUNCTOR::cod-1 (NATTRANS::cod-1 nt))) 
       (NATTRANS::components-1 nt))) 
     nil))))
            
(defun NATTRANS::ppNatTrans (x0 x1 x2) 
  (NATTRANS::ppNatTrans-1 (vector x0 x1 x2)))
                                             
(defun OPTION::compare-1-1 (comp x) 
  (let ((o1 (car x))
        (o2 (cdr x))) 
    (block 
     nil 
     (if (eq (car o1) :|None|) 
         (if (eq (car o2) :|Some|) (return '(:|Less|))) 
         (if (eq (car o1) :|Some|) 
             (if (eq (car o2) :|Some|) 
                 (return (funcall comp (cons (cdr o1) (cdr o2)))) 
                 (if (eq (car o2) :|None|) (return '(:|Greater|)))))) 
     (return '(:|Equal|)))))
                            
(defun OPTION::compare (x1) #'(lambda (x2) (OPTION::compare-1-1 x1 x2)))
                                                                        
(defun OPTION::mapOption (x1) #'(lambda (x2) (OPTION::mapOption-1-1 x1 x2)))
                                                                            
(defun OPTION::none? (x) (if (OPTION::some? x) nil t))
                                                      
(defun OPTION::show-1-1 (showX opt) 
  (block 
   nil 
   (if (eq (car opt) :|None|) 
       (return "None") 
       (if (eq (car opt) :|Some|) 
           (return 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ "(Some " (funcall showX (cdr opt))) 
             ")")))) 
   (error "Nonexhaustive match failure in show")))
                                                  
(defun OPTION::show (x1) #'(lambda (x2) (OPTION::show-1-1 x1 x2)))
                                                                  
(defun PATTERNMATCH::match_type (srt) 
  (STANDARDSPEC::mkBase 
   (cons :|Qualified| (cons "TranslationBuiltIn" "Match")) 
   (cons srt nil)))
                   
(defun PATTERNMATCH::abstract (vs |!t| srt) 
  (let ((srt (STANDARDSPEC::mkArrow (PATTERNMATCH::match_type srt) srt))) 
    (let ((oper 
           (STANDARDSPEC::mkOp 
            (cons :|Qualified| (cons "TranslationBuiltIn" "block")) 
            srt))) 
      (let ((|!t| (STANDARDSPEC::mkApply oper |!t|))) 
        (let ((pat 
               (block 
                nil 
                (if (consp vs) 
                    (if (null (cdr vs)) 
                        (return (STANDARDSPEC::mkVarPat-1 (cdr (car vs)))))) 
                (return 
                 (cons 
                  :|RecordPat| 
                  (cons 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (x) 
                       (cons (car x) (STANDARDSPEC::mkVarPat-1 (cdr x)))) 
                    vs) 
                   POSITION-SPEC::noPos)))))) 
          (cons 
           :|Lambda| 
           (cons 
            (cons (vector pat (STANDARDSPEC::mkTrue) |!t|) nil) 
            POSITION-SPEC::noPos)))))))
                                       
(defun PATTERNMATCH::abstract-1 (x) 
  (PATTERNMATCH::abstract (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun PATTERNMATCH::wildPattern?-1 (rule) 
  (let ((pV4338 (svref rule 1))
        (pV4337 (svref rule 0))) 
    (block 
     nil 
     (if (eq (car pV4337) :|WildPat|) 
         (if (eq (car pV4338) :|Fun|) 
             (let ((pV4350 (svref (cdr pV4338) 0))) 
               (if (eq (car pV4350) :|Bool|) (if (eq t (cdr pV4350)) (return t))))) 
         (if (eq (car pV4337) :|VarPat|) 
             (if (eq (car pV4338) :|Fun|) 
                 (let ((pV4345 (svref (cdr pV4338) 0))) 
                   (if (eq (car pV4345) :|Bool|) 
                       (if (eq t (cdr pV4345)) (return t))))))) 
     (return nil))))
                    
(defun PATTERNMATCH::checkUnreachableCase (context term rules) 
  (labels 
    ((nonfinalWildPattern? (rules) 
      (block 
       nil 
       (if (null rules) 
           (return nil) 
           (if (consp rules) 
               (let ((pV3701 (cdr rules))) 
                 (progn (if (null pV3701) (return nil)) 
                        (return 
                         (lisp::or 
                          (PATTERNMATCH::wildPattern?-1 (car rules)) 
                          (nonfinalWildPattern? pV3701))))))) 
       (error "Nonexhaustive match failure in checkUnreachableCase")))) 
    (if (nonfinalWildPattern? rules) 
        (STRING-SPEC::writeLine 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ "Warning: Unreachable case in " (svref context 1)) 
           "
") 
          (ANNSPECPRINTER::printTerm term))) 
        nil)))
              
(defun PATTERNMATCH::checkUnreachableCase-1 (x) 
  (PATTERNMATCH::checkUnreachableCase (svref x 0) (svref x 1) (svref x 2)))
                                                                           
(defun PATTERNMATCH::coproductFields (spc srt) 
  (let ((pV3706 (SPECENVIRONMENT::unfoldBase spc srt))) 
    (block 
     nil 
     (if (eq (car pV3706) :|CoProduct|) 
         (return (car (cdr pV3706))) 
         (if (eq (car pV3706) :|Subsort|) 
             (return (PATTERNMATCH::coproductFields spc (svref (cdr pV3706) 0))))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        "CoProduct sort expected, but got " 
        (ANNSPECPRINTER::printSort srt)))))))
                                             
(defun PATTERNMATCH::coproductFields-1 (x) 
  (PATTERNMATCH::coproductFields (car x) (cdr x)))
                                                  
(defun PATTERNMATCH::eliminateSort-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::eliminateSort-1-1 x1 x2)))
                                                          
(defun PATTERNMATCH::eliminateTerm-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::eliminateTerm-1-1 x1 x2)))
                                                          
(defun PATTERNMATCH::freshVar (context srt) 
  (let ((num (INTEGER-SPEC::|!+| (STATE::|!!| (svref context 0)) 1))) 
    (progn (STATE::|:=| (svref context 0) num) 
           (cons (STRING-SPEC::|!++| "pV" (NAT-SPEC::toString num)) srt))))
                                                                           
(defun PATTERNMATCH::zipFields (fields terms) 
  (block 
   nil 
   (if (null fields) 
       (if (null terms) (return nil)) 
       (if (consp fields) 
           (if (consp terms) 
               (return 
                (LIST-SPEC::|!cons| 
                 (cons (cdr (car fields)) (cdr (car terms))) 
                 (PATTERNMATCH::zipFields (cdr fields) (cdr terms))))))) 
   (return (SYSTEM-SPEC::fail "zipFields: Uneven length of fields"))))
                                                                      
(defun SPECENVIRONMENT::product (sp srt) 
  (let ((pV7180 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7180) :|Product|) (return (car (cdr pV7180)))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        "Could not extract product sort " 
        (ANNSPECPRINTER::printSort srt)))))))
                                             
(defun SPECENVIRONMENT::mkProjectTerm (sp id term) 
  (let ((srt (SPECENVIRONMENT::inferType sp term))) 
    (let ((fields (SPECENVIRONMENT::product sp srt))) 
      (let ((pV7163 
             (LIST-SPEC::|!find|-1-1 
              #'(lambda (x) (string=  id (car x))) 
              fields))) 
        (block 
         nil 
         (if (eq (car pV7163) :|Some|) 
             (return 
              (STANDARDSPEC::mkApply 
               (cons 
                :|Fun| 
                (vector 
                 (cons :|Project| id) 
                 (STANDARDSPEC::mkArrow srt (cdr (cdr pV7163))) 
                 POSITION-SPEC::noPos)) 
               term))) 
         (return (SYSTEM-SPEC::fail "Projection index not found in product")))))))


(defun PATTERNMATCH::flattenLetDecl (pV3884 pV3885) 
  (block 
   nil 
   (let ((pV3887 (cdr pV3884))
         (pV3886 (car pV3884))) 
     (let ((pV3889 (cdr pV3885))
           (pV3888 (car pV3885))) 
       (return 
        (block 
         nil 
         (if (eq (car pV3886) :|WildPat|) 
             (progn (if (eq (car pV3887) :|Var|) 
                        (return (cons pV3888 pV3889)) 
                        (if (eq (car pV3887) :|Record|) 
                            (if (null (car (cdr pV3887))) 
                                (return (cons pV3888 pV3889))))) 
                    (return 
                     (cons 
                      pV3888 
                      (LIST-SPEC::|!cons| 
                       (cons 
                        (STANDARDSPEC::mkVarPat-1 
                         (PATTERNMATCH::freshVar 
                          pV3888 
                          (METASLANG::patternSort pV3886))) 
                        pV3887) 
                       pV3889)))) 
             (if (eq (car pV3886) :|RecordPat|) 
                 (let ((pV3873 (car (cdr pV3886)))) 
                   (progn (if (eq (car pV3887) :|Record|) 
                              (return 
                               (LIST-SPEC::foldr-1-1-1 
                                #'PATTERNMATCH::flattenLetDecl-1 
                                (cons pV3888 pV3889) 
                                (PATTERNMATCH::zipFields 
                                 pV3873 
                                 (car (cdr pV3887)))))) 
                          (return 
                           (let ((v 
                                  (PATTERNMATCH::freshVar 
                                   pV3888 
                                   (SPECENVIRONMENT::inferType 
                                    (svref pV3888 2) 
                                    pV3887)))) 
                             (let ((vTerm (STANDARDSPEC::mkVar-1 v))) 
                               (let ((decls1 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (x) 
                                          (cons 
                                           (cdr x) 
                                           (SPECENVIRONMENT::mkProjectTerm 
                                            (svref pV3888 2) 
                                            (car x) 
                                            vTerm))) 
                                       pV3873))) 
                                 (let ((pV3865 
                                        (LIST-SPEC::foldr-1-1-1 
                                         #'PATTERNMATCH::flattenLetDecl-1 
                                         (cons pV3888 pV3889) 
                                         decls1))) 
                                   (block 
                                    nil 
                                    (return 
                                     (cons 
                                      (car pV3865) 
                                      (LIST-SPEC::|!cons| 
                                       (cons (STANDARDSPEC::mkVarPat-1 v) pV3887) 
                                       (LIST-SPEC::@ (cdr pV3865) pV3889)))) 
                                    (error 
                                     "Nonexhaustive match failure in flattenLetDecl"))))))))))) 
         (return (cons pV3888 (LIST-SPEC::|!cons| (cons pV3886 pV3887) pV3889))))))) 
   (error "Nonexhaustive match failure in flattenLetDecl")))
                                                            
(defun PATTERNMATCH::flattenLetDecl-1 (x) 
  (PATTERNMATCH::flattenLetDecl (car x) (cdr x)))
                                                 
(defun PATTERNMATCH::freshVars (num context pat) 
  (if ( =  num 0) 
      nil 
      (if ( =  num 1) 
          (cons 
           (cons 
            "" 
            (PATTERNMATCH::freshVar context (METASLANG::patternSort pat))) 
           nil) 
          (block 
           nil 
           (if (eq (car pat) :|RecordPat|) 
               (return 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons 
                     (car x) 
                     (PATTERNMATCH::freshVar 
                      context 
                      (METASLANG::patternSort (cdr x))))) 
                 (car (cdr pat))))) 
           (return (SYSTEM-SPEC::fail "Record pattern expected"))))))
                                                                     
(defparameter STANDARDSPEC::stringSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "String" "String")) nil))
                                                                          
(defun STANDARDSPEC::mkString (str) 
  (STANDARDSPEC::mkFun (cons :|String| str) STANDARDSPEC::stringSort))
                                                                      
(defun PATTERNMATCH::makeFail (name srt pV3982) 
  (declare (ignore pV3982)) 
  (let ((srt1 (STANDARDSPEC::mkArrow srt (PATTERNMATCH::match_type srt)))) 
    (let ((msg (STRING-SPEC::^ "Nonexhaustive match failure in " name))) 
      (STANDARDSPEC::mkApply 
       (STANDARDSPEC::mkOp 
        (cons :|Qualified| (cons "TranslationBuiltIn" "mkFail")) 
        srt1) 
       (STANDARDSPEC::mkString msg)))))
                                       
(defun PATTERNMATCH::mkLet (lets term) 
  (block 
   nil 
   (if (null lets) (return term)) 
   (return (STANDARDSPEC::mkLet lets term))))
                                             
(defun PATTERNMATCH::mkSuccess (srt0 trm) 
  (let ((srt (STANDARDSPEC::mkArrow srt0 (PATTERNMATCH::match_type srt0)))) 
    (STANDARDSPEC::mkApply 
     (STANDARDSPEC::mkOp 
      (cons :|Qualified| (cons "TranslationBuiltIn" "mkSuccess")) 
      srt) 
     trm)))
           
(defun PATTERNMATCH::makeDefault (context srt rules vs term) 
  (labels 
    ((|!loop| (rules firstRules) 
      (block 
       nil 
       (if (null rules) 
           (return 
            (cons 
             (LIST-SPEC::rev firstRules) 
             (PATTERNMATCH::makeFail (svref context 1) srt term))) 
           (if (consp rules) 
               (let ((pV3964 (cdr rules))
                     (pV3963 (car rules))) 
                 (progn (let ((pV3967 (svref pV3963 2))
                              (pV3966 (svref pV3963 1))
                              (pV3965 (svref pV3963 0))) 
                          (if (eq (car pV3965) :|WildPat|) 
                              (if (eq (car pV3966) :|Fun|) 
                                  (let ((pV3978 (svref (cdr pV3966) 0))) 
                                    (if (eq (car pV3978) :|Bool|) 
                                        (if (eq t (cdr pV3978)) 
                                            (if (null pV3964) 
                                                (return 
                                                 (cons 
                                                  (LIST-SPEC::rev firstRules) 
                                                  (PATTERNMATCH::mkSuccess 
                                                   srt 
                                                   pV3967)))))))) 
                              (if (eq (car pV3965) :|VarPat|) 
                                  (if (eq (car pV3966) :|Fun|) 
                                      (let ((pV3973 (svref (cdr pV3966) 0))) 
                                        (if (eq (car pV3973) :|Bool|) 
                                            (if (eq t (cdr pV3973)) 
                                                (if (null pV3964) 
                                                    (return 
                                                     (let ((term 
                                                            (block 
                                                             nil 
                                                             (if (consp vs) 
                                                                 (if (null 
                                                                      (cdr vs)) 
                                                                     (return 
                                                                      (cons 
                                                                       :|Var| 
                                                                       (cons 
                                                                        (cdr 
                                                                         (car vs)) 
                                                                        POSITION-SPEC::noPos))))) 
                                                             (return 
                                                              (cons 
                                                               :|Record| 
                                                               (cons 
                                                                (LIST-SPEC::|!map|-1-1 
                                                                 #'(lambda (x) 
                                                                    (cons 
                                                                     (car x) 
                                                                     (STANDARDSPEC::mkVar-1 
                                                                      (cdr x)))) 
                                                                 vs) 
                                                                POSITION-SPEC::noPos)))))) 
                                                       (let ((body 
                                                              (PATTERNMATCH::mkLet 
                                                               (cons 
                                                                (cons 
                                                                 (cons 
                                                                  :|VarPat| 
                                                                  (cons 
                                                                   (car 
                                                                    (cdr pV3965)) 
                                                                   POSITION-SPEC::noPos)) 
                                                                 term) 
                                                                nil) 
                                                               pV3967))) 
                                                         (cons 
                                                          (LIST-SPEC::rev 
                                                           firstRules) 
                                                          (PATTERNMATCH::mkSuccess 
                                                           srt 
                                                           body))))))))))))) 
                        (return 
                         (|!loop| pV3964 (LIST-SPEC::|!cons| pV3963 firstRules))))))) 
       (error "Nonexhaustive match failure in makeDefault")))) 
    (|!loop| rules nil)))
                         
(defun PATTERNMATCH::isBreak (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV3902 (svref (cdr term) 0))) 
         (if (eq (car pV3902) :|Op|) 
             (let ((pV3906 (car (cdr pV3902)))) 
               (if (eq (car pV3906) :|Qualified|) 
                   (let ((pV3908 (cdr pV3906))) 
                     (if (string=  "TranslationBuiltIn" (car pV3908)) 
                         (if (string=  "mkBreak" (cdr pV3908)) (return t))))))))) 
   (return nil)))
                 
(defun PATTERNMATCH::isSuccess (trm) 
  (block 
   nil 
   (if (eq (car trm) :|Apply|) 
       (let ((pV3925 (svref (cdr trm) 0))) 
         (if (eq (car pV3925) :|Fun|) 
             (let ((pV3929 (svref (cdr pV3925) 0))) 
               (if (eq (car pV3929) :|Op|) 
                   (let ((pV3933 (car (cdr pV3929)))) 
                     (if (eq (car pV3933) :|Qualified|) 
                         (let ((pV3935 (cdr pV3933))) 
                           (if (string=  "TranslationBuiltIn" (car pV3935)) 
                               (if (string=  "mkSuccess" (cdr pV3935)) 
                                   (return t))))))))))) 
   (return nil)))
                 
(defun PATTERNMATCH::warnUnreachable-1 (context) 
  (STRING-SPEC::writeLine 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     (STRING-SPEC::^ "Warning: Redundant case in " (svref context 1)) 
     "
") 
    (let ((pV4326 (svref context 3))) 
      (block 
       nil 
       (if (eq (car pV4326) :|Some|) 
           (return (ANNSPECPRINTER::printTerm (cdr pV4326)))) 
       (return ""))))))
                       
(defun STANDARDSPEC::mkProduct (sorts) 
  (labels 
    ((|!loop| (n sorts) 
      (block 
       nil 
       (if (null sorts) 
           (return nil) 
           (if (consp sorts) 
               (return 
                (LIST-SPEC::|!cons| 
                 (cons (NAT-SPEC::toString n) (car sorts)) 
                 (|!loop| (INTEGER-SPEC::|!+| n 1) (cdr sorts)))))) 
       (error "Nonexhaustive match failure in mkProduct")))) 
    (cons :|Product| (cons (|!loop| 1 sorts) POSITION-SPEC::noPos))))
                                                                     
(defun PATTERNMATCH::failWith-1-1-1 (context t1 t2) 
  (if (PATTERNMATCH::isBreak t2) 
      t1 
      (if (PATTERNMATCH::isSuccess t1) 
          (progn (PATTERNMATCH::warnUnreachable-1 context) t1) 
          (let ((srt (SPECENVIRONMENT::inferType (svref context 2) t1))) 
            (let ((srt 
                   (STANDARDSPEC::mkArrow 
                    (STANDARDSPEC::mkProduct (cons srt (cons srt nil))) 
                    srt))) 
              (let ((trm 
                     (STANDARDSPEC::mkApply 
                      (STANDARDSPEC::mkOp 
                       (cons :|Qualified| (cons "TranslationBuiltIn" "failWith")) 
                       srt) 
                      (STANDARDSPEC::mkRecord 
                       (cons (cons "1" t1) (cons (cons "2" t2) nil)))))) trm))))))


(defun PATTERNMATCH::matchAlias
 (context pat1 pat2 terms rules default |!break|) 
  (let ((|!t| (LIST-SPEC::hd terms))) 
    (let ((rules 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (x) 
               (let ((pV3993 (svref x 0))) 
                 (block 
                  nil 
                  (if (consp pV3993) 
                      (return 
                       (vector 
                        (cons pat1 (cons pat2 (cdr pV3993))) 
                        (svref x 1) 
                        (svref x 2)))) 
                  (error "Nonexhaustive match failure in matchAlias")))) 
            rules))) 
      (PATTERNMATCH::match 
       context 
       (LIST-SPEC::|!cons| |!t| terms) 
       rules 
       default 
       |!break|))))
                   
(defun PATTERNMATCH::isTrue (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV3943 (svref (cdr term) 0))) 
         (if (eq (car pV3943) :|Bool|) (if (eq t (cdr pV3943)) (return t))))) 
   (return nil)))
                 
(defun STANDARDSPEC::mkIfThenElse (t1 t2 t3) 
  (cons :|IfThenElse| (vector t1 t2 t3 POSITION-SPEC::noPos)))
                                                              
(defun PATTERNMATCH::mkOptimizedIfThenElse (|!cond| thenBranch elseBranch) 
  (if (PATTERNMATCH::isTrue |!cond|) 
      thenBranch 
      (STANDARDSPEC::mkIfThenElse |!cond| thenBranch elseBranch)))
                                                                  
(defun STANDARDSPEC::mkEmbedded (id srt) 
  (STANDARDSPEC::mkFun 
   (cons :|Embedded| id) 
   (STANDARDSPEC::mkArrow srt STANDARDSPEC::boolSort)))
                                                       
(defun PATTERNMATCH::embedded-1-1 (constructorName term) 
  (STANDARDSPEC::mkApply 
   (STANDARDSPEC::mkEmbedded constructorName (METASLANG::termSort term)) 
   term))
         
(defun PATTERNMATCH::embedded (x1) 
  #'(lambda (x2) (PATTERNMATCH::embedded-1-1 x1 x2)))
                                                     
(defun STANDARDSPEC::mkEquals (srt) (STANDARDSPEC::mkFun '(:|Equals|) srt))
                                                                           
(defun STANDARDSPEC::mkEquality (dom_sort t1 t2) 
  (let ((srt 
         (STANDARDSPEC::mkArrow 
          (STANDARDSPEC::mkProduct (cons dom_sort (cons dom_sort nil))) 
          STANDARDSPEC::boolSort))) 
    (STANDARDSPEC::mkApply 
     (STANDARDSPEC::mkEquals srt) 
     (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil))))))
                                                       
(defun PATTERNMATCH::equalToConstant-1-1 (!x1 term) 
  (STANDARDSPEC::mkEquality (car !x1) (cdr !x1) term))
                                                      
(defun PATTERNMATCH::equalToConstant-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::equalToConstant-1-1 x1 x2)))
                                                            
(defun PATTERNMATCH::equalToConstant (x0 x1) 
  (PATTERNMATCH::equalToConstant-1 (cons x0 x1)))
                                                 
(defparameter STANDARDSPEC::charSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Char" "Char")) nil))
                                                                      
(defun STANDARDSPEC::mkBool (bool) 
  (STANDARDSPEC::mkFun (cons :|Bool| bool) STANDARDSPEC::boolSort))
                                                                   
(defun STANDARDSPEC::mkChar (|!char|) 
  (STANDARDSPEC::mkFun (cons :|Char| |!char|) STANDARDSPEC::charSort))
                                                                      
(defparameter STANDARDSPEC::natSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Nat" "Nat")) nil))
                                                                    
(defun STANDARDSPEC::mkNat (n) 
  (STANDARDSPEC::mkFun (cons :|Nat| n) STANDARDSPEC::natSort))
                                                              
(defun PATTERNMATCH::queryPat (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|EmbedPat|) 
       (return (PATTERNMATCH::embedded (svref (cdr pattern) 0))) 
       (if (eq (car pattern) :|NatPat|) 
           (return 
            (PATTERNMATCH::equalToConstant 
             STANDARDSPEC::natSort 
             (STANDARDSPEC::mkNat (car (cdr pattern))))) 
           (if (eq (car pattern) :|CharPat|) 
               (return 
                (PATTERNMATCH::equalToConstant 
                 STANDARDSPEC::charSort 
                 (STANDARDSPEC::mkChar (car (cdr pattern))))) 
               (if (eq (car pattern) :|BoolPat|) 
                   (return 
                    (PATTERNMATCH::equalToConstant 
                     STANDARDSPEC::boolSort 
                     (STANDARDSPEC::mkBool (car (cdr pattern))))) 
                   (if (eq (car pattern) :|StringPat|) 
                       (return 
                        (PATTERNMATCH::equalToConstant 
                         STANDARDSPEC::stringSort 
                         (STANDARDSPEC::mkString (car (cdr pattern))))) 
                       (if (eq (car pattern) :|RecordPat|) 
                           (return 
                            #'(lambda (pV4150) 
                               (declare (ignore pV4150)) 
                               (STANDARDSPEC::mkTrue))))))))) 
   (return 
    #'(lambda (pV4152) (declare (ignore pV4152)) 
                       (STANDARDSPEC::mkTrue)))))
                                                 
(defun PATTERNMATCH::queryPat-1-1 (x1 x2) 
  (funcall (PATTERNMATCH::queryPat x1) x2))
                                           
(defun PATTERNMATCH::sameConstructor (pat1 pat2) 
  (block 
   nil 
   (if (eq (car pat1) :|EmbedPat|) 
       (if (eq (car pat2) :|EmbedPat|) 
           (return (string=  (svref (cdr pat1) 0) (svref (cdr pat2) 0)))) 
       (if (eq (car pat1) :|RecordPat|) 
           (if (eq (car pat2) :|RecordPat|) (return t)))) 
   (return (METASLANG::equalPattern? pat1 pat2))))
                                                  
(defun PATTERNMATCH::partitionConstructors (context |!t| rules) 
  (labels 
    ((patDecompose (pattern) 
      (block 
       nil 
       (if (eq (car pattern) :|RecordPat|) 
           (return 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (x) 
                (cons 
                 (cdr x) 
                 (SPECENVIRONMENT::mkProjectTerm (svref context 2) (car x) |!t|))) 
             (car (cdr pattern)))) 
           (if (eq (car pattern) :|EmbedPat|) 
               (let ((pV4105 (cdr pattern))) 
                 (let ((pV4109 (svref pV4105 2))
                       (pV4108 (svref pV4105 1))
                       (pV4107 (svref pV4105 0))) 
                   (if (eq (car pV4108) :|Some|) 
                       (return 
                        (let ((fields 
                               (PATTERNMATCH::coproductFields 
                                (svref context 2) 
                                pV4109))) 
                          (let ((trm 
                                 (let ((pV4098 
                                        (LIST-SPEC::|!find|-1-1 
                                         #'(lambda (x) 
                                            (string=  pV4107 (car x))) 
                                         fields))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV4098) :|Some|) 
                                        (let ((pV4101 (cdr (cdr pV4098)))) 
                                          (if (eq (car pV4101) :|Some|) 
                                              (return 
                                               (STANDARDSPEC::mkApply 
                                                (cons 
                                                 :|Fun| 
                                                 (vector 
                                                  (cons :|Select| pV4107) 
                                                  (STANDARDSPEC::mkArrow 
                                                   pV4109 
                                                   (cdr pV4101)) 
                                                  POSITION-SPEC::noPos)) 
                                                |!t|))))) 
                                    (return 
                                     (SYSTEM-SPEC::fail 
                                      "Selection index not found in product")))))) 
                            (cons (cons (cdr pV4108) trm) nil))))))))) 
       (return nil)))) 
    (labels 
      ((insert (rule rules) 
        (block 
         nil 
         (let ((pV4130 (svref rule 2))
               (pV4129 (svref rule 1))
               (pV4128 (svref rule 0))) 
           (if (consp pV4128) 
               (let ((pV4133 (cdr pV4128))
                     (pV4132 (car pV4128))) 
                 (if (null rules) 
                     (return 
                      (let ((query (PATTERNMATCH::queryPat-1-1 pV4132 |!t|))) 
                        (let ((decomposition (patDecompose pV4132))) 
                          (let ((newVars 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x) 
                                     (PATTERNMATCH::freshVar 
                                      context 
                                      (METASLANG::patternSort (car x)))) 
                                  decomposition))) 
                            (let ((lets 
                                   (LISTPAIR::|!map|-1-1 
                                    #'(lambda (x) 
                                       (block 
                                        nil 
                                        (return 
                                         (cons 
                                          (STANDARDSPEC::mkVarPat-1 (cdr x)) 
                                          (cdr (car x)))) 
                                        (error 
                                         "Nonexhaustive match failure in partitionConstructors"))) 
                                    (cons decomposition newVars)))) 
                              (let ((newPats 
                                     (LIST-SPEC::|!map|-1-1 
                                      #'(lambda (x) (car x)) 
                                      decomposition))) 
                                (cons 
                                 (vector 
                                  query 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'STANDARDSPEC::mkVar-1 
                                   newVars) 
                                  lets 
                                  pV4132 
                                  (cons 
                                   (vector 
                                    (LIST-SPEC::concat newPats pV4133) 
                                    pV4129 
                                    pV4130) 
                                   nil)) 
                                 nil))))))) 
                     (if (consp rules) 
                         (let ((pV4136 (cdr rules))
                               (pV4135 (car rules))) 
                           (let ((pV4140 (svref pV4135 3))) 
                             (return 
                              (if (PATTERNMATCH::sameConstructor pV4132 pV4140) 
                                  (let ((decomposition (patDecompose pV4132))) 
                                    (let ((newPats 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) (car x)) 
                                            decomposition))) 
                                      (let ((rule1 
                                             (vector 
                                              (LIST-SPEC::concat newPats pV4133) 
                                              pV4129 
                                              pV4130))) 
                                        (cons 
                                         (vector 
                                          (svref pV4135 0) 
                                          (svref pV4135 1) 
                                          (svref pV4135 2) 
                                          pV4140 
                                          (cons rule1 (svref pV4135 4))) 
                                         pV4136)))) 
                                  (if (LIST-SPEC::|!exists|-1-1 
                                       #'(lambda (x) 
                                          (PATTERNMATCH::sameConstructor 
                                           pV4132 
                                           (svref x 3))) 
                                       pV4136) 
                                      (LIST-SPEC::|!cons| 
                                       pV4135 
                                       (insert rule pV4136)) 
                                      (LIST-SPEC::concat 
                                       (insert rule nil) 
                                       (LIST-SPEC::|!cons| pV4135 pV4136)))))))))))) 
         (return rules)))) 
      (LIST-SPEC::foldr-1-1-1 
       #'(lambda (x) (insert (car x) (cdr x))) 
       nil 
       rules))))
                
(defun PATTERNMATCH::matchCon (context terms rules default |!break|) 
  (let ((|!t| (LIST-SPEC::hd terms))) 
    (let ((terms (LIST-SPEC::tl terms))) 
      (let ((rulePartition 
             (PATTERNMATCH::partitionConstructors context |!t| rules))) 
        (let ((rule 
               (LIST-SPEC::foldr-1-1-1 
                #'(lambda (x) 
                   (let ((pV4000 (car x))) 
                     (block 
                      nil 
                      (return 
                       (PATTERNMATCH::mkOptimizedIfThenElse 
                        (svref pV4000 0) 
                        (PATTERNMATCH::mkLet 
                         (svref pV4000 2) 
                         (PATTERNMATCH::match 
                          context 
                          (LIST-SPEC::@ (svref pV4000 1) terms) 
                          (svref pV4000 4) 
                          |!break| 
                          |!break|)) 
                        (cdr x))) 
                      (error "Nonexhaustive match failure in matchCon")))) 
                |!break| 
                rulePartition))) 
          (PATTERNMATCH::failWith-1-1-1 context rule default))))))
                                                                  
(defun STANDARDSPEC::mkQuotientSort (srt rel) 
  (cons :|Quotient| (vector srt rel POSITION-SPEC::noPos)))
                                                           
(defun STANDARDSPEC::mkChooseFun (equiv srt1 srt2 f) 
  (let ((chSrt 
         (STANDARDSPEC::mkArrow 
          (STANDARDSPEC::mkArrow srt1 srt2) 
          (STANDARDSPEC::mkArrow (STANDARDSPEC::mkQuotientSort srt1 equiv) srt2)))) 
    (let ((ch (STANDARDSPEC::mkFun '(:|Choose|) chSrt))) 
      (STANDARDSPEC::mkApply ch f))))
                                     
(defun STANDARDSPEC::mkLambda (pat term) 
  (cons 
   :|Lambda| 
   (cons 
    (cons (vector pat (STANDARDSPEC::mkTrue) term) nil) 
    POSITION-SPEC::noPos)))
                           
(defun PATTERNMATCH::matchQuotient (pV4024 pV4025 pV4026 pV4027 pV4028) 
  (block 
   nil 
   (if (consp pV4025) 
       (let ((pV4030 (car pV4025))) 
         (return 
          (let ((pV4019 (SPECENVIRONMENT::inferType (svref pV4024 2) pV4030))) 
            (block 
             nil 
             (if (eq (car pV4019) :|Quotient|) 
                 (let ((pV4020 (cdr pV4019))) 
                   (let ((pV4021 (svref pV4020 0))) 
                     (return 
                      (let ((v (cons "v" pV4021))) 
                        (let ((f 
                               (STANDARDSPEC::mkLambda 
                                (cons :|VarPat| (cons v POSITION-SPEC::noPos)) 
                                (cons :|Var| (cons v POSITION-SPEC::noPos))))) 
                          (let ((t1 
                                 (STANDARDSPEC::mkApply 
                                  (STANDARDSPEC::mkChooseFun 
                                   (svref pV4020 1) 
                                   pV4021 
                                   pV4021 
                                   f) 
                                  pV4030))) 
                            (let ((rules 
                                   (LIST-SPEC::|!map|-1-1 
                                    #'(lambda (x) 
                                       (let ((pV4009 (svref x 0))) 
                                         (block 
                                          nil 
                                          (if (consp pV4009) 
                                              (let ((pV4013 (car pV4009))) 
                                                (if (eq 
                                                     (car pV4013) 
                                                     :|QuotientPat|) 
                                                    (return 
                                                     (vector 
                                                      (cons 
                                                       (svref (cdr pV4013) 0) 
                                                       (cdr pV4009)) 
                                                      (svref x 1) 
                                                      (svref x 2)))))) 
                                          (error 
                                           "Nonexhaustive match failure in matchQuotient")))) 
                                    pV4026))) 
                              (PATTERNMATCH::failWith-1-1-1 
                               pV4024 
                               (PATTERNMATCH::match 
                                pV4024 
                                (LIST-SPEC::|!cons| t1 (cdr pV4025)) 
                                rules 
                                pV4028 
                                pV4028) 
                               pV4027))))))))) 
             (error "Nonexhaustive match failure in matchQuotient")))))) 
   (error "Nonexhaustive match failure in matchQuotient")))
                                                           
(defun SPECENVIRONMENT::mkRestrict (pV7167 pV7168) 
  (block 
   nil 
   (let ((pV7170 (cdr pV7168))) 
     (return 
      (let ((srt (SPECENVIRONMENT::inferType pV7167 pV7170))) 
        (let ((srt 
               (STANDARDSPEC::mkArrow 
                srt 
                (STANDARDSPEC::mkSubsort srt (car pV7168))))) 
          (STANDARDSPEC::mkApply 
           (cons :|Fun| (vector '(:|Restrict|) srt POSITION-SPEC::noPos)) 
           pV7170))))) 
   (error "Nonexhaustive match failure in mkRestrict")))
                                                        
(defun PATTERNMATCH::matchSubsort (pV4054 pV4055 pV4056 pV4057 pV4058 pV4059) 
  (block 
   nil 
   (if (consp pV4056) 
       (let ((pV4061 (car pV4056))) 
         (return 
          (progn (SPECENVIRONMENT::inferType (svref pV4054 2) pV4061) 
                 (let ((t1 
                        (SPECENVIRONMENT::mkRestrict 
                         (svref pV4054 2) 
                         (cons pV4055 pV4061)))) 
                   (let ((rules 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x) 
                              (let ((pV4044 (svref x 0))) 
                                (block 
                                 nil 
                                 (if (consp pV4044) 
                                     (let ((pV4048 (car pV4044))) 
                                       (if (eq (car pV4048) :|RelaxPat|) 
                                           (return 
                                            (vector 
                                             (LIST-SPEC::|!cons| 
                                              (svref (cdr pV4048) 0) 
                                              (cdr pV4044)) 
                                             (svref x 1) 
                                             (svref x 2)))))) 
                                 (error 
                                  "Nonexhaustive match failure in matchSubsort")))) 
                           pV4057))) 
                     (PATTERNMATCH::failWith-1-1-1 
                      pV4054 
                      (STANDARDSPEC::mkIfThenElse 
                       (STANDARDSPEC::mkApply pV4055 pV4061) 
                       (PATTERNMATCH::match 
                        pV4054 
                        (LIST-SPEC::|!cons| t1 (cdr pV4056)) 
                        rules 
                        pV4059 
                        pV4059) 
                       pV4059) 
                      pV4058))))))) 
   (error "Nonexhaustive match failure in matchSubsort")))
                                                          
(defun PATTERNMATCH::substPat (e pat |!t|) 
  (if (PATTERNMATCH::isTrue e) 
      e 
      (block 
       nil 
       (if (eq (car pat) :|WildPat|) 
           (return e) 
           (if (eq (car pat) :|VarPat|) 
               (return (PATTERNMATCH::mkLet (cons (cons pat |!t|) nil) e)))) 
       (return e))))
                    
(defun PATTERNMATCH::matchVar (context terms rules default |!break|) 
  (let ((|!t| (LIST-SPEC::hd terms))) 
    (let ((terms (LIST-SPEC::tl terms))) 
      (let ((rules 
             (LIST-SPEC::|!map|-1-1 
              #'(lambda (x) 
                 (let ((pV4064 (svref x 0))) 
                   (block 
                    nil 
                    (if (consp pV4064) 
                        (let ((pV4068 (car pV4064))) 
                          (return 
                           (vector 
                            (cdr pV4064) 
                            (PATTERNMATCH::substPat (svref x 1) pV4068 |!t|) 
                            (PATTERNMATCH::substPat (svref x 2) pV4068 |!t|))))) 
                    (return (SYSTEM-SPEC::fail "Empty list of patterns "))))) 
              rules))) 
        (PATTERNMATCH::match context terms rules default |!break|)))))
                                                                      
(defun PATTERNMATCH::ruleType-1 (q) 
  (let ((pV4216 (svref q 0))) 
    (block 
     nil 
     (if (consp pV4216) 
         (let ((pV4220 (car pV4216))) 
           (if (eq (car pV4220) :|VarPat|) 
               (return '(:|Var|)) 
               (if (eq (car pV4220) :|WildPat|) 
                   (return '(:|Var|)) 
                   (if (eq (car pV4220) :|AliasPat|) 
                       (let ((pV4230 (cdr pV4220))) 
                         (return 
                          (cons 
                           :|Alias| 
                           (cons (svref pV4230 0) (svref pV4230 1))))) 
                       (if (eq (car pV4220) :|EmbedPat|) 
                           (return '(:|Con|)) 
                           (if (eq (car pV4220) :|RecordPat|) 
                               (return '(:|Con|)) 
                               (if (eq (car pV4220) :|StringPat|) 
                                   (return '(:|Con|)) 
                                   (if (eq (car pV4220) :|BoolPat|) 
                                       (return '(:|Con|)) 
                                       (if (eq (car pV4220) :|NatPat|) 
                                           (return '(:|Con|)) 
                                           (if (eq (car pV4220) :|CharPat|) 
                                               (return '(:|Con|)) 
                                               (if (eq (car pV4220) :|RelaxPat|) 
                                                   (let ((pV4223 (cdr pV4220))) 
                                                     (return 
                                                      (cons 
                                                       :|Relax| 
                                                       (cons 
                                                        (svref pV4223 0) 
                                                        (svref pV4223 1))))) 
                                                   (if (eq 
                                                        (car pV4220) 
                                                        :|QuotientPat|) 
                                                       (let ((pV4222 
                                                              (cdr pV4220))) 
                                                         (return 
                                                          (cons 
                                                           :|Quotient| 
                                                           (cons 
                                                            (svref pV4222 0) 
                                                            (svref pV4222 1)))))))))))))))))) 
     (error "Nonexhaustive match failure in ruleType"))))
                                                         
(defun PATTERNMATCH::matchRules-1-1 (!x1 x) 
  (let ((vars (svref !x1 2))
        (|!break| (svref !x1 1))
        (context (svref !x1 0))) 
    (let ((rules (car x))
          (default (cdr x))) 
      (let ((pV4033 (PATTERNMATCH::ruleType-1 (LIST-SPEC::hd rules)))) 
        (block 
         nil 
         (if (eq (car pV4033) :|Var|) 
             (return 
              (PATTERNMATCH::matchVar context vars rules default |!break|)) 
             (if (eq (car pV4033) :|Con|) 
                 (return 
                  (PATTERNMATCH::matchCon context vars rules default |!break|)) 
                 (if (eq (car pV4033) :|Alias|) 
                     (let ((pV4036 (cdr pV4033))) 
                       (return 
                        (PATTERNMATCH::matchAlias 
                         context 
                         (car pV4036) 
                         (cdr pV4036) 
                         vars 
                         rules 
                         default 
                         |!break|))) 
                     (if (eq (car pV4033) :|Relax|) 
                         (return 
                          (PATTERNMATCH::matchSubsort 
                           context 
                           (cdr (cdr pV4033)) 
                           vars 
                           rules 
                           default 
                           |!break|)) 
                         (if (eq (car pV4033) :|Quotient|) 
                             (return 
                              (PATTERNMATCH::matchQuotient 
                               context 
                               vars 
                               rules 
                               default 
                               |!break|))))))) 
         (error "Nonexhaustive match failure in matchRules"))))))
                                                                 
(defun PATTERNMATCH::matchRules-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::matchRules-1-1 x1 x2)))
                                                       
(defun PATTERNMATCH::matchRules (x0 x1 x2) 
  (PATTERNMATCH::matchRules-1 (vector x0 x1 x2)))
                                                 
(defun PATTERNMATCH::tack-1-1 (x xss) 
  (cons (cons x (LIST-SPEC::hd xss)) (LIST-SPEC::tl xss)))
                                                          
(defun PATTERNMATCH::partition-1-1 (f qs) 
  (block 
   nil 
   (if (null qs) 
       (return nil) 
       (if (consp qs) 
           (let ((pV4089 (car qs))
                 (pV4090 (cdr qs))) 
             (if (null pV4090) 
                 (return (cons (cons pV4089 nil) nil)) 
                 (if (consp pV4090) 
                     (let ((pV4092 (car pV4090))
                           (pV4093 (cdr pV4090))) 
                       (return 
                        (if (slang-built-in::slang-term-equals 
                             (funcall f pV4089) 
                             (funcall f pV4092)) 
                            (PATTERNMATCH::tack-1-1 
                             pV4089 
                             (PATTERNMATCH::partition-1-1 
                              f 
                              (LIST-SPEC::|!cons| pV4092 pV4093))) 
                            (cons 
                             (cons pV4089 nil) 
                             (PATTERNMATCH::partition-1-1 
                              f 
                              (LIST-SPEC::|!cons| pV4092 pV4093))))))))))) 
   (error "Nonexhaustive match failure in partition")))
                                                       
(defun PATTERNMATCH::match (context vars rules default |!break|) 
  (block 
   nil 
   (if (null vars) 
       (return 
        (LIST-SPEC::foldr-1-1-1 
         #'(lambda (x) 
            (let ((pV3984 (car x))) 
              (block 
               nil 
               (return 
                (PATTERNMATCH::failWith-1-1-1 
                 context 
                 (PATTERNMATCH::mkOptimizedIfThenElse 
                  (svref pV3984 1) 
                  (svref pV3984 2) 
                  |!break|) 
                 (cdr x))) 
               (error "Nonexhaustive match failure in match")))) 
         default 
         rules)) 
       (if (consp vars) 
           (return 
            (let ((rules 
                   (PATTERNMATCH::partition-1-1 #'PATTERNMATCH::ruleType-1 rules))) 
              (LIST-SPEC::foldr-1-1-1 
               (PATTERNMATCH::matchRules context |!break| vars) 
               default 
               rules))))) 
   (error "Nonexhaustive match failure in match")))
                                                   
(defun PATTERNMATCH::mkBreak (srt) 
  (STANDARDSPEC::mkOp 
   (cons :|Qualified| (cons "TranslationBuiltIn" "mkBreak")) 
   (PATTERNMATCH::match_type srt)))
                                   
(defun PATTERNMATCH::normalizeSimpleAlias (rules) 
  (block 
   nil 
   (if (consp rules) 
       (let ((pV4075 (car rules))) 
         (let ((pV4077 (svref pV4075 0))) 
           (if (eq (car pV4077) :|AliasPat|) 
               (let ((pV4080 (cdr pV4077))) 
                 (let ((pV4083 (svref pV4080 2))
                       (pV4081 (svref pV4080 0))) 
                   (if (eq (car pV4081) :|VarPat|) 
                       (let ((pV4084 (cdr pV4081))) 
                         (let ((pV4086 (cdr pV4084))
                               (pV4085 (car pV4084))) 
                           (if (null (cdr rules)) 
                               (return 
                                (cons 
                                 (vector 
                                  (cons :|VarPat| (cons pV4085 pV4086)) 
                                  (STANDARDSPEC::mkTrue) 
                                  (cons 
                                   :|Apply| 
                                   (vector 
                                    (cons 
                                     :|Lambda| 
                                     (cons 
                                      (cons 
                                       (vector 
                                        (svref pV4080 1) 
                                        (svref pV4075 1) 
                                        (svref pV4075 2)) 
                                       nil) 
                                      pV4083)) 
                                    (cons :|Var| (cons pV4085 pV4086)) 
                                    pV4083))) 
                                 nil)))))))))))) 
   (return rules)))
                   
(defun PATTERNMATCH::simplePattern (pattern) 
  (block nil (if (eq (car pattern) :|VarPat|) (return t)) (return nil)))
                                                                        
(defun PATTERNMATCH::simpleAbstraction (rules) 
  (block 
   nil 
   (if (consp rules) 
       (let ((pV4273 (cdr rules))
             (pV4272 (car rules))) 
         (let ((pV4275 (svref pV4272 1))
               (pV4274 (svref pV4272 0))) 
           (progn (if (eq (car pV4274) :|RecordPat|) 
                      (if (null pV4273) 
                          (return 
                           (lisp::and 
                            (PATTERNMATCH::isTrue pV4275) 
                            (LIST-SPEC::all-1-1 
                             #'(lambda (x) 
                                (PATTERNMATCH::simplePattern (cdr x))) 
                             (car (cdr pV4274))))))) 
                  (if (null pV4273) 
                      (return 
                       (lisp::and 
                        (PATTERNMATCH::simplePattern pV4274) 
                        (PATTERNMATCH::isTrue pV4275)))))))) 
   (return nil)))
                 
(defun PATTERNMATCH::splitPattern (arity pat) 
  (if ( =  arity 1) 
      (cons pat nil) 
      (block 
       nil 
       (if (eq (car pat) :|RecordPat|) 
           (return 
            (LIST-SPEC::|!map|-1-1 #'(lambda (x) (cdr x)) (car (cdr pat)))) 
           (if (eq (car pat) :|WildPat|) 
               (return 
                (LIST-SPEC::tabulate 
                 arity 
                 #'(lambda (pV4287) (declare (ignore pV4287)) 
                                    pat))))) 
       (return (SYSTEM-SPEC::fail "Unexpected pattern")))))
                                                           
(defun PATTERNMATCH::storeTerm (pV4296 pV4297) 
  (block 
   nil 
   (return 
    (vector 
     (svref pV4297 0) 
     (svref pV4297 1) 
     (svref pV4297 2) 
     (cons :|Some| pV4296))) 
   (error "Nonexhaustive match failure in storeTerm")))
                                                       
(defun PATTERNMATCH::eliminateTerm-1-1 (context term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (return 
        (let ((rules (PATTERNMATCH::normalizeSimpleAlias (car (cdr term))))) 
          (let ((arity (ARITYNORMALIZE::matchArity rules))) 
            (let ((rules 
                   (LIST-SPEC::|!map|-1-1 
                    #'(lambda (x) 
                       (vector 
                        (PATTERNMATCH::eliminatePattern-1-1 context (svref x 0)) 
                        (PATTERNMATCH::eliminateTerm-1-1 context (svref x 1)) 
                        (PATTERNMATCH::eliminateTerm-1-1 context (svref x 2)))) 
                    rules))) 
              (if (PATTERNMATCH::simpleAbstraction rules) 
                  (cons :|Lambda| (cons rules POSITION-SPEC::noPos)) 
                  (progn (PATTERNMATCH::checkUnreachableCase context term rules) 
                         (let ((pV3789 (LIST-SPEC::hd rules))) 
                           (block 
                            nil 
                            (return 
                             (let ((bdySort 
                                    (SPECENVIRONMENT::inferType 
                                     (svref context 2) 
                                     (svref pV3789 2)))) 
                               (let ((vs 
                                      (PATTERNMATCH::freshVars 
                                       arity 
                                       context 
                                       (svref pV3789 0)))) 
                                 (let ((pV3786 
                                        (PATTERNMATCH::makeDefault 
                                         context 
                                         bdySort 
                                         rules 
                                         vs 
                                         term))) 
                                   (block 
                                    nil 
                                    (return 
                                     (let ((rules 
                                            (LIST-SPEC::|!map|-1-1 
                                             #'(lambda (x) 
                                                (vector 
                                                 (PATTERNMATCH::splitPattern 
                                                  arity 
                                                  (svref x 0)) 
                                                 (svref x 1) 
                                                 (PATTERNMATCH::mkSuccess 
                                                  bdySort 
                                                  (svref x 2)))) 
                                             (car pV3786)))) 
                                       (let ((vars 
                                              (LIST-SPEC::|!map|-1-1 
                                               #'(lambda (x) 
                                                  (STANDARDSPEC::mkVar-1 (cdr x))) 
                                               vs))) 
                                         (let ((trm 
                                                (PATTERNMATCH::match 
                                                 (PATTERNMATCH::storeTerm 
                                                  term 
                                                  context) 
                                                 vars 
                                                 rules 
                                                 (cdr pV3786) 
                                                 (PATTERNMATCH::mkBreak bdySort)))) 
                                           (let ((trm 
                                                  (PATTERNMATCH::abstract 
                                                   vs 
                                                   trm 
                                                   bdySort))) trm))))) 
                                    (error 
                                     "Nonexhaustive match failure in eliminateTerm")))))) 
                            (error 
                             "Nonexhaustive match failure in eliminateTerm"))))))))) 
       (if (eq (car term) :|Let|) 
           (let ((pV3825 (cdr term))) 
             (return 
              (let ((decls 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x) 
                         (cons 
                          (PATTERNMATCH::eliminatePattern-1-1 context (car x)) 
                          (PATTERNMATCH::eliminateTerm-1-1 context (cdr x)))) 
                      (svref pV3825 0)))) 
                (let ((body 
                       (PATTERNMATCH::eliminateTerm-1-1 context (svref pV3825 1)))) 
                  (let ((pV3809 
                         (LIST-SPEC::foldr-1-1-1 
                          #'PATTERNMATCH::flattenLetDecl-1 
                          (cons context decls) 
                          nil))) 
                    (block 
                     nil 
                     (let ((pV3810 (car pV3809))
                           (pV3811 (cdr pV3809))) 
                       (return 
                        (if (LIST-SPEC::all-1-1 
                             #'(lambda (x) 
                                (PATTERNMATCH::simplePattern (car x))) 
                             pV3811) 
                            (PATTERNMATCH::mkLet pV3811 body) 
                            (let ((pV3806 (LISTPAIR::unzip pV3811))) 
                              (block 
                               nil 
                               (let ((pV3807 (car pV3806))
                                     (pV3808 (cdr pV3806))) 
                                 (return 
                                  (let ((trm 
                                         (block 
                                          nil 
                                          (if (consp pV3808) 
                                              (if (null (cdr pV3808)) 
                                                  (return (car pV3808)))) 
                                          (return (STANDARDSPEC::mkTuple pV3808))))) 
                                    (let ((bdySrt 
                                           (SPECENVIRONMENT::inferType 
                                            (svref pV3810 2) 
                                            body))) 
                                      (let ((vs 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'(lambda (pat) 
                                                 (PATTERNMATCH::freshVar 
                                                  pV3810 
                                                  (METASLANG::patternSort pat))) 
                                              pV3807))) 
                                        (let ((pV3803 
                                               (LIST-SPEC::foldl-1-1-1 
                                                #'(lambda (x) 
                                                   (let ((pV3800 (cdr x))) 
                                                     (block 
                                                      nil 
                                                      (let ((pV3802 (cdr pV3800))) 
                                                        (return 
                                                         (cons 
                                                          (LIST-SPEC::|!cons| 
                                                           (cons 
                                                            (NAT-SPEC::toString 
                                                             pV3802) 
                                                            (car x)) 
                                                           (car pV3800)) 
                                                          (INTEGER-SPEC::|!+| 
                                                           pV3802 
                                                           1)))) 
                                                      (error 
                                                       "Nonexhaustive match failure in eliminateTerm")))) 
                                                (cons nil 1) 
                                                vs))) 
                                          (block 
                                           nil 
                                           (return 
                                            (let ((|!t| 
                                                   (PATTERNMATCH::match 
                                                    pV3810 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'STANDARDSPEC::mkVar-1 
                                                     vs) 
                                                    (cons 
                                                     (vector 
                                                      pV3807 
                                                      (STANDARDSPEC::mkTrue) 
                                                      (PATTERNMATCH::mkSuccess 
                                                       bdySrt 
                                                       body)) 
                                                     nil) 
                                                    (PATTERNMATCH::makeFail 
                                                     (svref pV3810 1) 
                                                     bdySrt 
                                                     term) 
                                                    (PATTERNMATCH::mkBreak 
                                                     bdySrt)))) 
                                              (let ((|!t| 
                                                     (PATTERNMATCH::abstract 
                                                      (car pV3803) 
                                                      |!t| 
                                                      bdySrt))) 
                                                (STANDARDSPEC::mkApply |!t| trm)))) 
                                           (error 
                                            "Nonexhaustive match failure in eliminateTerm")))))))) 
                               (error 
                                "Nonexhaustive match failure in eliminateTerm")))))) 
                     (error "Nonexhaustive match failure in eliminateTerm"))))))) 
           (if (eq (car term) :|Apply|) 
               (let ((pV3824 (cdr term))) 
                 (return 
                  (cons 
                   :|Apply| 
                   (vector 
                    (PATTERNMATCH::eliminateTerm-1-1 context (svref pV3824 0)) 
                    (PATTERNMATCH::eliminateTerm-1-1 context (svref pV3824 1)) 
                    (svref pV3824 2))))) 
               (if (eq (car term) :|Record|) 
                   (let ((pV3823 (cdr term))) 
                     (return 
                      (cons 
                       :|Record| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (PATTERNMATCH::eliminateTerm-1-1 context (cdr x)))) 
                         (car pV3823)) 
                        (cdr pV3823))))) 
                   (if (eq (car term) :|Bind|) 
                       (let ((pV3822 (cdr term))) 
                         (return 
                          (cons 
                           :|Bind| 
                           (vector 
                            (svref pV3822 0) 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (car x) 
                                 (PATTERNMATCH::eliminateSort-1-1 
                                  context 
                                  (cdr x)))) 
                             (svref pV3822 1)) 
                            (PATTERNMATCH::eliminateTerm-1-1 
                             context 
                             (svref pV3822 2)) 
                            (svref pV3822 3))))) 
                       (if (eq (car term) :|LetRec|) 
                           (let ((pV3821 (cdr term))) 
                             (return 
                              (cons 
                               :|LetRec| 
                               (vector 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (x) 
                                    (let ((pV3812 (car x))) 
                                      (block 
                                       nil 
                                       (return 
                                        (cons 
                                         (cons 
                                          (car pV3812) 
                                          (PATTERNMATCH::eliminateSort-1-1 
                                           context 
                                           (cdr pV3812))) 
                                         (PATTERNMATCH::eliminateTerm-1-1 
                                          context 
                                          (cdr x)))) 
                                       (error 
                                        "Nonexhaustive match failure in eliminateTerm")))) 
                                 (svref pV3821 0)) 
                                (PATTERNMATCH::eliminateTerm-1-1 
                                 context 
                                 (svref pV3821 1)) 
                                (svref pV3821 2))))) 
                           (if (eq (car term) :|Var|) 
                               (let ((pV3820 (cdr term))) 
                                 (let ((pV3836 (car pV3820))) 
                                   (return 
                                    (cons 
                                     :|Var| 
                                     (cons 
                                      (cons 
                                       (car pV3836) 
                                       (PATTERNMATCH::eliminateSort-1-1 
                                        context 
                                        (cdr pV3836))) 
                                      (cdr pV3820)))))) 
                               (if (eq (car term) :|Fun|) 
                                   (let ((pV3819 (cdr term))) 
                                     (return 
                                      (cons 
                                       :|Fun| 
                                       (vector 
                                        (svref pV3819 0) 
                                        (PATTERNMATCH::eliminateSort-1-1 
                                         context 
                                         (svref pV3819 1)) 
                                        (svref pV3819 2))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV3818 (cdr term))) 
                                         (return 
                                          (cons 
                                           :|IfThenElse| 
                                           (vector 
                                            (PATTERNMATCH::eliminateTerm-1-1 
                                             context 
                                             (svref pV3818 0)) 
                                            (PATTERNMATCH::eliminateTerm-1-1 
                                             context 
                                             (svref pV3818 1)) 
                                            (PATTERNMATCH::eliminateTerm-1-1 
                                             context 
                                             (svref pV3818 2)) 
                                            (svref pV3818 3))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (let ((pV3817 (cdr term))) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 (PATTERNMATCH::eliminateTerm-1 
                                                  context) 
                                                 (car pV3817)) 
                                                (cdr pV3817))))))))))))))) 
   (error "Nonexhaustive match failure in eliminateTerm")))
                                                           
(defun PATTERNMATCH::eliminateSort-1-1 (context srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV3767 (cdr srt))) 
         (return 
          (cons 
           :|Arrow| 
           (vector 
            (PATTERNMATCH::eliminateSort-1-1 context (svref pV3767 0)) 
            (PATTERNMATCH::eliminateSort-1-1 context (svref pV3767 1)) 
            (svref pV3767 2))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV3766 (cdr srt))) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons 
                     (car x) 
                     (PATTERNMATCH::eliminateSort-1-1 context (cdr x)))) 
                 (car pV3766)) 
                (cdr pV3766))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV3765 (cdr srt))) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((pV3756 (car x))
                              (pV3757 (cdr x))) 
                          (block 
                           nil 
                           (if (eq (car pV3757) :|Some|) 
                               (return 
                                (cons 
                                 pV3756 
                                 (cons 
                                  :|Some| 
                                  (PATTERNMATCH::eliminateSort-1-1 
                                   context 
                                   (cdr pV3757))))) 
                               (if (eq (car pV3757) :|None|) 
                                   (return (cons pV3756 '(:|None|))))) 
                           (error "Nonexhaustive match failure in eliminateSort")))) 
                     (car pV3765)) 
                    (cdr pV3765))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV3764 (cdr srt))) 
                     (return 
                      (cons 
                       :|Quotient| 
                       (vector 
                        (PATTERNMATCH::eliminateSort-1-1 
                         context 
                         (svref pV3764 0)) 
                        (PATTERNMATCH::eliminateTerm-1-1 
                         context 
                         (svref pV3764 1)) 
                        (svref pV3764 2))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV3763 (cdr srt))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector 
                            (PATTERNMATCH::eliminateSort-1-1 
                             context 
                             (svref pV3763 0)) 
                            (PATTERNMATCH::eliminateTerm-1-1 
                             context 
                             (svref pV3763 1)) 
                            (svref pV3763 2))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV3762 (cdr srt))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector 
                                (svref pV3762 0) 
                                (LIST-SPEC::|!map|-1-1 
                                 (PATTERNMATCH::eliminateSort-1 context) 
                                 (svref pV3762 1)) 
                                (svref pV3762 2))))) 
                           (if (eq (car srt) :|TyVar|) (return srt)))))))) 
   (error "Nonexhaustive match failure in eliminateSort")))
                                                           
(defun PATTERNMATCH::eliminatePattern-1-1 (context pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV3725 (cdr pat))) 
         (return 
          (cons 
           :|AliasPat| 
           (vector 
            (PATTERNMATCH::eliminatePattern-1-1 context (svref pV3725 0)) 
            (PATTERNMATCH::eliminatePattern-1-1 context (svref pV3725 1)) 
            (svref pV3725 2))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV3724 (cdr pat))) 
             (let ((pV3749 (car pV3724))) 
               (return 
                (cons 
                 :|VarPat| 
                 (cons 
                  (cons 
                   (car pV3749) 
                   (PATTERNMATCH::eliminateSort-1-1 context (cdr pV3749))) 
                  (cdr pV3724)))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV3723 (cdr pat))) 
                 (let ((pV3744 (svref pV3723 0))
                       (pV3745 (svref pV3723 1))
                       (pV3746 (svref pV3723 2))
                       (pV3747 (svref pV3723 3))) 
                   (if (eq (car pV3745) :|Some|) 
                       (return 
                        (cons 
                         :|EmbedPat| 
                         (vector 
                          pV3744 
                          (cons 
                           :|Some| 
                           (PATTERNMATCH::eliminatePattern-1-1 
                            context 
                            (cdr pV3745))) 
                          (PATTERNMATCH::eliminateSort-1-1 context pV3746) 
                          pV3747))) 
                       (if (eq (car pV3745) :|None|) 
                           (return 
                            (cons 
                             :|EmbedPat| 
                             (vector 
                              pV3744 
                              '(:|None|) 
                              (PATTERNMATCH::eliminateSort-1-1 context pV3746) 
                              pV3747))))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (let ((pV3722 (cdr pat))) 
                     (return 
                      (cons 
                       :|RecordPat| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (PATTERNMATCH::eliminatePattern-1-1 context (cdr x)))) 
                         (car pV3722)) 
                        (cdr pV3722))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (let ((pV3721 (cdr pat))) 
                         (return 
                          (cons 
                           :|VarPat| 
                           (cons 
                            (PATTERNMATCH::freshVar 
                             context 
                             (PATTERNMATCH::eliminateSort-1-1 
                              context 
                              (car pV3721))) 
                            (cdr pV3721))))) 
                       (if (eq (car pat) :|StringPat|) 
                           (let ((pV3720 (cdr pat))) 
                             (return 
                              (cons 
                               :|StringPat| 
                               (cons (car pV3720) (cdr pV3720))))) 
                           (if (eq (car pat) :|BoolPat|) 
                               (let ((pV3719 (cdr pat))) 
                                 (return 
                                  (cons 
                                   :|BoolPat| 
                                   (cons (car pV3719) (cdr pV3719))))) 
                               (if (eq (car pat) :|CharPat|) 
                                   (let ((pV3718 (cdr pat))) 
                                     (return 
                                      (cons 
                                       :|CharPat| 
                                       (cons (car pV3718) (cdr pV3718))))) 
                                   (if (eq (car pat) :|NatPat|) 
                                       (let ((pV3717 (cdr pat))) 
                                         (return 
                                          (cons 
                                           :|NatPat| 
                                           (cons (car pV3717) (cdr pV3717))))) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (let ((pV3716 (cdr pat))) 
                                             (return 
                                              (cons 
                                               :|RelaxPat| 
                                               (vector 
                                                (PATTERNMATCH::eliminatePattern-1-1 
                                                 context 
                                                 (svref pV3716 0)) 
                                                (PATTERNMATCH::eliminateTerm-1-1 
                                                 context 
                                                 (svref pV3716 1)) 
                                                (svref pV3716 2))))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (let ((pV3715 (cdr pat))) 
                                                 (return 
                                                  (cons 
                                                   :|QuotientPat| 
                                                   (vector 
                                                    (PATTERNMATCH::eliminatePattern-1-1 
                                                     context 
                                                     (svref pV3715 0)) 
                                                    (PATTERNMATCH::eliminateTerm-1-1 
                                                     context 
                                                     (svref pV3715 1)) 
                                                    (svref pV3715 2)))))))))))))))) 
   (error "Nonexhaustive match failure in eliminatePattern")))
                                                              
(defun PATTERNMATCH::eliminatePattern-1 (x1) 
  #'(lambda (x2) (PATTERNMATCH::eliminatePattern-1-1 x1 x2)))
                                                             
(defun PATTERNMATCH::eliminatePattern (x0 x1 x2 x3) 
  (PATTERNMATCH::eliminatePattern-1 (vector x0 x1 x2 x3)))
                                                          
(defun PATTERNMATCH::eliminateSort (x0 x1 x2 x3) 
  (PATTERNMATCH::eliminateSort-1 (vector x0 x1 x2 x3)))
                                                       
(defun PATTERNMATCH::eliminateTerm (x0 x1 x2 x3) 
  (PATTERNMATCH::eliminateTerm-1 (vector x0 x1 x2 x3)))
                                                       
(defun PATTERNMATCH::failWith-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (PATTERNMATCH::failWith-1-1-1 x1 x2 x3))))
                                                                          
(defun PATTERNMATCH::failWith (x0 x1 x2 x3) 
  (PATTERNMATCH::failWith-1 (vector x0 x1 x2 x3)))
                                                  
(defun PATTERNMATCH::freshVar-1 (x) (PATTERNMATCH::freshVar (car x) (cdr x)))
                                                                             
(defun PATTERNMATCH::freshVars-1 (x) 
  (PATTERNMATCH::freshVars (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun PATTERNMATCH::isShortTuple (i row) 
  (block 
   nil 
   (if (null row) 
       (return t) 
       (if (consp row) 
           (return 
            (lisp::and 
             (string=  (car (car row)) (NAT-SPEC::toString i)) 
             (PATTERNMATCH::isShortTuple (INTEGER-SPEC::|!+| i 1) (cdr row)))))) 
   (error "Nonexhaustive match failure in isShortTuple")))
                                                          
(defun PATTERNMATCH::isShortTuple-1 (x) 
  (PATTERNMATCH::isShortTuple (car x) (cdr x)))
                                               
(defun PATTERNMATCH::makeDefault-1 (x) 
  (PATTERNMATCH::makeDefault 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun PATTERNMATCH::makeFail-1 (x) 
  (PATTERNMATCH::makeFail (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun PATTERNMATCH::match-1 (x) 
  (PATTERNMATCH::match 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun PATTERNMATCH::matchAlias-1 (x) 
  (PATTERNMATCH::matchAlias 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))
                
(defun PATTERNMATCH::matchCon-1 (x) 
  (PATTERNMATCH::matchCon 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun PATTERNMATCH::matchQuotient-1 (x) 
  (PATTERNMATCH::matchQuotient 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun PATTERNMATCH::matchSubsort-1 (x) 
  (PATTERNMATCH::matchSubsort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun PATTERNMATCH::matchVar-1 (x) 
  (PATTERNMATCH::matchVar 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun PATTERNMATCH::mkLet-1 (x) (PATTERNMATCH::mkLet (car x) (cdr x)))
                                                                       
(defun PATTERNMATCH::mkOptimizedIfThenElse-1 (x) 
  (PATTERNMATCH::mkOptimizedIfThenElse (svref x 0) (svref x 1) (svref x 2)))
                                                                            
(defun PATTERNMATCH::mkSuccess-1 (x) (PATTERNMATCH::mkSuccess (car x) (cdr x)))
                                                                               
(defun PATTERNMATCH::partition (x1) 
  #'(lambda (x2) (PATTERNMATCH::partition-1-1 x1 x2)))
                                                      
(defun PATTERNMATCH::partitionConstructors-1 (x) 
  (PATTERNMATCH::partitionConstructors (svref x 0) (svref x 1) (svref x 2)))
                                                                            
(defun PATTERNMATCH::printRule (pats |!cond| body) 
  (progn (STRING-SPEC::toScreen "Pattern : ") 
         (LIST-SPEC::app-1-1 
          #'(lambda (p) 
             (STRING-SPEC::toScreen 
              (STRING-SPEC::^ (ANNSPECPRINTER::printPattern p) " "))) 
          pats) 
         (STRING-SPEC::writeLine "") 
         (STRING-SPEC::writeLine 
          (STRING-SPEC::^ "Condition: " (ANNSPECPRINTER::printTerm |!cond|))) 
         (STRING-SPEC::writeLine 
          (STRING-SPEC::^ "Body: " (ANNSPECPRINTER::printTerm body)))))
                                                                       
(defun PATTERNMATCH::printRule-1 (x) 
  (PATTERNMATCH::printRule (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun PATTERNMATCH::recordfields? (fields) 
  (BOOLEAN-SPEC::~ (PATTERNMATCH::isShortTuple 1 fields)))
                                                          
(defun PATTERNMATCH::relaxed-1-1 (predicate term) 
  (STANDARDSPEC::mkApply predicate term))
                                         
(defun PATTERNMATCH::relaxed (x1) 
  #'(lambda (x2) (PATTERNMATCH::relaxed-1-1 x1 x2)))
                                                    
(defun PATTERNMATCH::ruleType (x0 x1 x2) 
  (PATTERNMATCH::ruleType-1 (vector x0 x1 x2)))
                                               
(defun PATTERNMATCH::sameConstructor-1 (x) 
  (PATTERNMATCH::sameConstructor (car x) (cdr x)))
                                                  
(defun PATTERNMATCH::splitPattern-1 (x) 
  (PATTERNMATCH::splitPattern (car x) (cdr x)))
                                               
(defun PATTERNMATCH::storeTerm-1 (x) (PATTERNMATCH::storeTerm (car x) (cdr x)))
                                                                               
(defun PATTERNMATCH::substPat-1 (x) 
  (PATTERNMATCH::substPat (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun PATTERNMATCH::tack (x1) 
  #'(lambda (x2) (PATTERNMATCH::tack-1-1 x1 x2)))
                                                 
(defun PATTERNMATCH::translateMatch-1 (spc) 
  (let ((mkContext 
         #'(lambda (funName) (vector (cons :|Ref| 0) funName spc '(:|None|))))) 
    (vector 
     (svref spc 0) 
     (mapiAQualifierMap-1-1 
      #'(lambda (x) 
         (let ((pV4310 (svref x 2))
               (pV4309 (svref x 1))) 
           (block 
            nil 
            (let ((pV4314 (svref pV4310 3))
                  (pV4313 (svref pV4310 2))
                  (pV4312 (svref pV4310 1))
                  (pV4311 (svref pV4310 0))) 
              (let ((pV4316 (cdr pV4313))
                    (pV4315 (car pV4313))) 
                (if (eq (car pV4314) :|Some|) 
                    (return 
                     (vector 
                      pV4311 
                      pV4312 
                      (cons 
                       pV4315 
                       (PATTERNMATCH::eliminateSort-1-1 
                        (funcall mkContext pV4309) 
                        pV4316)) 
                      (cons 
                       :|Some| 
                       (PATTERNMATCH::eliminateTerm-1-1 
                        (funcall mkContext pV4309) 
                        (cdr pV4314))))) 
                    (if (eq (car pV4314) :|None|) 
                        (return 
                         (vector 
                          pV4311 
                          pV4312 
                          (cons 
                           pV4315 
                           (PATTERNMATCH::eliminateSort-1-1 
                            (funcall mkContext pV4309) 
                            pV4316)) 
                          '(:|None|))))))) 
            (error "Nonexhaustive match failure in translateMatch")))) 
      (svref spc 1)) 
     (LIST-SPEC::|!map|-1-1 
      #'(lambda (x) 
         (let ((name (svref x 1))) 
           (vector 
            (svref x 0) 
            name 
            (svref x 2) 
            (PATTERNMATCH::eliminateTerm-1-1 
             (funcall mkContext name) 
             (svref x 3))))) 
      (svref spc 2)) 
     (mapiAQualifierMap-1-1 
      #'(lambda (x) 
         (let ((pV4320 (svref x 2))) 
           (block 
            nil 
            (let ((pV4323 (svref pV4320 2))
                  (pV4322 (svref pV4320 1))
                  (pV4321 (svref pV4320 0))) 
              (if (eq (car pV4323) :|Some|) 
                  (return 
                   (vector 
                    pV4321 
                    pV4322 
                    (cons 
                     :|Some| 
                     (PATTERNMATCH::eliminateSort-1-1 
                      (funcall mkContext (svref x 1)) 
                      (cdr pV4323))))) 
                  (if (eq (car pV4323) :|None|) 
                      (return (vector pV4321 pV4322 '(:|None|)))))) 
            (error "Nonexhaustive match failure in translateMatch")))) 
      (svref spc 3)))))
                       
(defun PATTERNMATCH::translateMatch (x0 x1 x2 x3) 
  (PATTERNMATCH::translateMatch-1 (vector x0 x1 x2 x3)))
                                                        
(defun PATTERNMATCH::warnUnreachable (x0 x1 x2 x3) 
  (PATTERNMATCH::warnUnreachable-1 (vector x0 x1 x2 x3)))
                                                         
(defun PATTERNMATCH::wildPattern? (x0 x1 x2) 
  (PATTERNMATCH::wildPattern?-1 (vector x0 x1 x2)))
                                                   
(defun PATTERNMATCH::zipFields-1 (x) (PATTERNMATCH::zipFields (car x) (cdr x)))
                                                                               
(defun POLYMAP::compose-1-1 (|!m1| |!m2|) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (new_map) 
      #'(lambda (dom) 
         #'(lambda (med) 
            (let ((cod (POLYMAP::|!eval|-1-1 |!m2| med))) 
              (POLYMAP::update-1-1-1 new_map dom cod))))) 
   POLYMAP::emptyMap 
   |!m1|))
          
(defun POLYMAP::compose (x1) #'(lambda (x2) (POLYMAP::compose-1-1 x1 x2)))
                                                                          
(defun POLYMAP::|!eval| (x1) #'(lambda (x2) (POLYMAP::|!eval|-1-1 x1 x2)))
                                                                          
(defun POLYMAP::evalPartial (x1) 
  #'(lambda (x2) (POLYMAP::evalPartial-1-1 x1 x2)))
                                                   
(defun POLYMAP::foldMap (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYMAP::foldMap-1-1-1 x1 x2 x3))))
                                                                    
(defun POLYMAP::imageToList (|!map|) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (|!values|) 
      #'(lambda (pV4387) 
         (declare (ignore pV4387)) 
         #'(lambda (value) (cons value |!values|)))) 
   nil 
   |!map|))
           
(defun POLYMAP::inDomain?-1-1 (|!map| key) 
  (block 
   nil 
   (if (null |!map|) 
       (return nil) 
       (if (consp |!map|) 
           (return 
            (lisp::or 
             (slang-built-in::slang-term-equals (car (car |!map|)) key) 
             (POLYMAP::inDomain?-1-1 (cdr |!map|) key))))) 
   (error "Nonexhaustive match failure in inDomain?")))
                                                       
(defun POLYMAP::inDomain? (x1) 
  #'(lambda (x2) (POLYMAP::inDomain?-1-1 x1 x2)))
                                                 
(defun POLYMAP::mapMap (x1) #'(lambda (x2) (POLYMAP::mapMap-1-1 x1 x2)))
                                                                        
(defun POLYMAP::mapPartial-1-1 (f m) 
  (labels 
    ((g (m) 
      #'(lambda (key) 
         #'(lambda (item) 
            (let ((pV4400 (funcall f item))) 
              (block 
               nil 
               (if (eq (car pV4400) :|None|) 
                   (return m) 
                   (if (eq (car pV4400) :|Some|) 
                       (return (POLYMAP::update-1-1-1 m key (cdr pV4400))))) 
               (error "Nonexhaustive match failure in mapPartial"))))))) 
    (POLYMAP::foldMap-1-1-1 #'g POLYMAP::emptyMap m)))
                                                      
(defun POLYMAP::mapPartial (x1) 
  #'(lambda (x2) (POLYMAP::mapPartial-1-1 x1 x2)))
                                                  
(defun POLYMAP::ppMap (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYMAP::ppMap-1-1-1 x1 x2 x3))))
                                                                  
(defun POLYMAP::|!remove|-1-1 (|!map| x) 
  (block 
   nil 
   (if (null |!map|) 
       (return nil) 
       (if (consp |!map|) 
           (let ((pV4404 (car |!map|))
                 (pV4405 (cdr |!map|))) 
             (let ((pV4406 (car pV4404))) 
               (return 
                (if (slang-built-in::slang-term-equals pV4406 x) 
                    pV4405 
                    (cons 
                     (cons pV4406 (cdr pV4404)) 
                     (POLYMAP::|!remove|-1-1 pV4405 x)))))))) 
   (error "Nonexhaustive match failure in remove")))
                                                    
(defun POLYMAP::|!remove| (x1) 
  #'(lambda (x2) (POLYMAP::|!remove|-1-1 x1 x2)))
                                                 
(defun POLYMAP::update (x1) 
  #'(lambda (x2) #'(lambda (x3) (POLYMAP::update-1-1-1 x1 x2 x3))))
                                                                   
(defun POLYSET::|!find|-1-1 (pred s) 
  (block 
   nil 
   (if (null s) 
       (return '(:|None|)) 
       (if (consp s) 
           (let ((pV4420 (car s))) 
             (return 
              (if (funcall pred pV4420) 
                  (cons :|Some| pV4420) 
                  (POLYSET::|!find|-1-1 pred (cdr s))))))) 
   (error "Nonexhaustive match failure in find")))
                                                  
(defun POLYSET::|!find| (x1) #'(lambda (x2) (POLYSET::|!find|-1-1 x1 x2)))
                                                                          
(defun POLYSET::ppSet-1-1 (ppElem l) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "{") 
    (cons 
     (WADLERLINDIG::ppSep-1-1 
      (WADLERLINDIG::ppString ",") 
      (POLYSET::|!map|-1-1 ppElem l)) 
     (cons (WADLERLINDIG::ppString "}") nil)))))
                                                
(defun POLYSET::ppSet (x1) #'(lambda (x2) (POLYSET::ppSet-1-1 x1 x2)))
                                                                      
(defun POLYSET::take (s) 
  (block 
   nil 
   (if (null s) 
       (return '(:|None|)) 
       (if (consp s) (return (cons :|Some| (cons (car s) (cdr s)))))) 
   (error "Nonexhaustive match failure in take")))
                                                  
(defun POSSPEC::makeTyVarMap (fresh |!tyVars|) 
  (labels 
    ((insert (tv |!map|) (STRINGMAP::insert |!map| tv (funcall fresh tv)))) 
    (let ((m 
           (LIST-SPEC::foldr-1-1-1 
            #'(lambda (x) (insert (car x) (cdr x))) 
            STRINGMAP::empty 
            |!tyVars|))) 
      (cons 
       m 
       #'(lambda (pV4555) 
          (block 
           nil 
           (if (eq (car pV4555) :|Base|) 
               (let ((pV4556 (cdr pV4555))) 
                 (let ((pV4557 (svref pV4556 0))) 
                   (if (eq (car pV4557) :|Qualified|) 
                       (if (null (svref pV4556 1)) 
                           (return 
                            (let ((pV4553 
                                   (STRINGMAP::|!find| m (cdr (cdr pV4557))))) 
                              (block 
                               nil 
                               (if (eq (car pV4553) :|Some|) 
                                   (return 
                                    (cons 
                                     :|TyVar| 
                                     (cons (cdr pV4553) (svref pV4556 2)))) 
                                   (if (eq (car pV4553) :|None|) (return pV4555))) 
                               (error 
                                "Nonexhaustive match failure in makeTyVarMap"))))))))) 
           (return pV4555)))))))
                                
(defun POSSPEC::mapImage (m vars) 
  (LIST-SPEC::|!map|-1-1 
   #'(lambda (d) 
      (let ((pV4563 (STRINGMAP::|!find| m d))) 
        (block 
         nil 
         (if (eq (car pV4563) :|Some|) (return (cdr pV4563))) 
         (error "Nonexhaustive match failure in mapImage")))) 
   vars))
         
(defun POSSPEC::abstractSort (fresh |!tyVars| srt) 
  (if (LIST-SPEC::|!null| |!tyVars|) 
      (cons nil srt) 
      (let ((pV4438 (POSSPEC::makeTyVarMap fresh |!tyVars|))) 
        (block 
         nil 
         (return 
          (let ((srt 
                 (METASLANG::mapSort-1-1 
                  (vector 
                   #'(lambda (|!M|) |!M|) 
                   (cdr pV4438) 
                   #'(lambda (p) p)) 
                  srt))) (cons (POSSPEC::mapImage (car pV4438) |!tyVars|) srt))) 
         (error "Nonexhaustive match failure in abstractSort")))))
                                                                  
(defun POSSPEC::abstractSort-1 (x) 
  (POSSPEC::abstractSort (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun POSSPEC::abstractTerm (fresh |!tyVars| trm) 
  (let ((pV4441 (POSSPEC::makeTyVarMap fresh |!tyVars|))) 
    (block 
     nil 
     (return 
      (let ((trm 
             (METASLANG::mapTerm-1-1 
              (vector #'(lambda (|!M|) |!M|) (cdr pV4441) #'(lambda (p) p)) 
              trm))) (cons (POSSPEC::mapImage (car pV4441) |!tyVars|) trm))) 
     (error "Nonexhaustive match failure in abstractTerm"))))
                                                             
(defun POSSPEC::abstractTerm-1 (x) 
  (POSSPEC::abstractTerm (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun POSSPEC::addPOp (pV4462 pV4463) 
  (block 
   nil 
   (let ((pV4467 (svref pV4462 3))
         (pV4466 (svref pV4462 2))
         (pV4465 (svref pV4462 1))
         (pV4464 (svref pV4462 0))) 
     (if (consp pV4464) 
         (let ((pV4469 (car pV4464))) 
           (if (eq (car pV4469) :|Qualified|) 
               (let ((pV4471 (cdr pV4469))) 
                 (let ((pV4473 (cdr pV4471))
                       (pV4472 (car pV4471))) 
                   (return 
                    (let ((old_ops (svref pV4463 1))) 
                      (let ((old_qmap 
                             (let ((pV4445 (STRINGMAP::|!find| old_ops pV4472))) 
                               (block 
                                nil 
                                (if (eq (car pV4445) :|None|) 
                                    (return STRINGMAP::empty) 
                                    (if (eq (car pV4445) :|Some|) 
                                        (return (cdr pV4445)))) 
                                (error "Nonexhaustive match failure in addPOp"))))) 
                        (let ((new_qmap 
                               (let ((pV4456 
                                      (STRINGMAP::|!find| old_qmap pV4473))) 
                                 (block 
                                  nil 
                                  (if (eq (car pV4456) :|None|) 
                                      (return 
                                       (STRINGMAP::insert 
                                        old_qmap 
                                        pV4473 
                                        (vector pV4464 pV4465 pV4466 pV4467))) 
                                      (if (eq (car pV4456) :|Some|) 
                                          (let ((pV4457 (cdr pV4456))) 
                                            (let ((pV4461 (svref pV4457 3))
                                                  (pV4458 (svref pV4457 0))) 
                                              (return 
                                               (block 
                                                nil 
                                                (if (eq (car pV4467) :|None|) 
                                                    (if (eq (car pV4461) :|Some|) 
                                                        (return 
                                                         (STRINGMAP::insert 
                                                          old_qmap 
                                                          pV4473 
                                                          (vector 
                                                           pV4458 
                                                           pV4465 
                                                           pV4466 
                                                           pV4461))) 
                                                        (if (eq 
                                                             (car pV4461) 
                                                             :|None|) 
                                                            (return 
                                                             (SYSTEM-SPEC::fail 
                                                              (STRING-SPEC::^ 
                                                               (STRING-SPEC::^ 
                                                                "Operator " 
                                                                pV4473) 
                                                               " has been redeclared"))))) 
                                                    (if (eq (car pV4467) :|Some|) 
                                                        (if (eq 
                                                             (car pV4461) 
                                                             :|None|) 
                                                            (return 
                                                             (STRINGMAP::insert 
                                                              old_qmap 
                                                              pV4473 
                                                              (vector 
                                                               pV4458 
                                                               (svref pV4457 1) 
                                                               (svref pV4457 2) 
                                                               pV4467))) 
                                                            (if (eq 
                                                                 (car pV4461) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Operator " 
                                                                    pV4473) 
                                                                   " has been redefined"))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in addPOp"))))))) 
                                  (error "Nonexhaustive match failure in addPOp"))))) 
                          (let ((new_ops 
                                 (STRINGMAP::insert old_ops pV4472 new_qmap))) 
                            (let ((sp (setOps pV4463 new_ops))) 
                              (LIST-SPEC::foldl-1-1-1 
                               #'(lambda (x) (addLocalOpName (cdr x) (car x))) 
                               sp 
                               pV4464))))))))))))) 
   (error "Nonexhaustive match failure in addPOp")))
                                                    
(defun POSSPEC::addPOp-1 (x) (POSSPEC::addPOp (car x) (cdr x)))
                                                               
(defun POSSPEC::addPSort (pV4491 pV4492) 
  (block 
   nil 
   (let ((pV4495 (svref pV4491 2))
         (pV4494 (svref pV4491 1))
         (pV4493 (svref pV4491 0))) 
     (if (consp pV4493) 
         (let ((pV4497 (car pV4493))) 
           (if (eq (car pV4497) :|Qualified|) 
               (let ((pV4499 (cdr pV4497))) 
                 (let ((pV4501 (cdr pV4499))
                       (pV4500 (car pV4499))) 
                   (return 
                    (let ((old_sorts (svref pV4492 3))) 
                      (let ((old_qmap 
                             (let ((pV4475 (STRINGMAP::|!find| old_sorts pV4500))) 
                               (block 
                                nil 
                                (if (eq (car pV4475) :|None|) 
                                    (return STRINGMAP::empty) 
                                    (if (eq (car pV4475) :|Some|) 
                                        (return (cdr pV4475)))) 
                                (error "Nonexhaustive match failure in addPSort"))))) 
                        (let ((new_qmap 
                               (let ((pV4486 
                                      (STRINGMAP::|!find| old_qmap pV4501))) 
                                 (block 
                                  nil 
                                  (if (eq (car pV4486) :|None|) 
                                      (return 
                                       (STRINGMAP::insert 
                                        old_qmap 
                                        pV4501 
                                        (vector pV4493 pV4494 pV4495))) 
                                      (if (eq (car pV4486) :|Some|) 
                                          (let ((pV4487 (cdr pV4486))) 
                                            (let ((pV4490 (svref pV4487 2))
                                                  (pV4489 (svref pV4487 1))) 
                                              (return 
                                               (block 
                                                nil 
                                                (if (eq (car pV4495) :|None|) 
                                                    (if (eq (car pV4490) :|None|) 
                                                        (return 
                                                         (SYSTEM-SPEC::fail 
                                                          (STRING-SPEC::^ 
                                                           (STRING-SPEC::^ 
                                                            "Sort " 
                                                            pV4501) 
                                                           " has been redeclared"))) 
                                                        (if (eq 
                                                             (car pV4490) 
                                                             :|Some|) 
                                                            (return 
                                                             (if ( =  
                                                                  (LIST-SPEC::|!length| 
                                                                   pV4494) 
                                                                  (LIST-SPEC::|!length| 
                                                                   pV4489)) 
                                                                 old_qmap 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Sort " 
                                                                    pV4501) 
                                                                   " redefined using different type variable lists")))))) 
                                                    (if (eq (car pV4495) :|Some|) 
                                                        (if (eq 
                                                             (car pV4490) 
                                                             :|None|) 
                                                            (return 
                                                             (if ( =  
                                                                  (LIST-SPEC::|!length| 
                                                                   pV4494) 
                                                                  (LIST-SPEC::|!length| 
                                                                   pV4489)) 
                                                                 (STRINGMAP::insert 
                                                                  old_qmap 
                                                                  pV4501 
                                                                  (vector 
                                                                   (svref 
                                                                    pV4487 
                                                                    0) 
                                                                   pV4494 
                                                                   pV4495)) 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Sort " 
                                                                    pV4501) 
                                                                   " redefined using different type variable lists")))) 
                                                            (if (eq 
                                                                 (car pV4490) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (SYSTEM-SPEC::fail 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Sort " 
                                                                    pV4501) 
                                                                   " has been redefined"))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in addPSort"))))))) 
                                  (error 
                                   "Nonexhaustive match failure in addPSort"))))) 
                          (let ((new_sorts 
                                 (STRINGMAP::insert old_sorts pV4500 new_qmap))) 
                            (let ((sp (setSorts pV4492 new_sorts))) 
                              (LIST-SPEC::foldl-1-1-1 
                               #'(lambda (x) (addLocalSortName (cdr x) (car x))) 
                               sp 
                               pV4493))))))))))))) 
   (error "Nonexhaustive match failure in addPSort")))
                                                      
(defun POSSPEC::addPSort-1 (x) (POSSPEC::addPSort (car x) (cdr x)))
                                                                   
(defparameter POSSPEC::boolPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Boolean" "Boolean")) nil))
                                                                            
(defparameter POSSPEC::charPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Char" "Char")) nil))
                                                                      
(defun POSSPEC::exportSpec-1 (spc) spc)
                                       
(defun POSSPEC::exportSpec (x0 x1 x2 x3) 
  (POSSPEC::exportSpec-1 (vector x0 x1 x2 x3)))
                                               
(defparameter POSITION-SPEC::internalPosition (cons :|Internal| "built-in"))
                                                                            
(defparameter POSSPEC::stringPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "String" "String")) nil))
                                                                          
(defun POSSPEC::mkFail (|!position| srt) 
  (let ((msg 
         (STRING-SPEC::^ 
          "Non-exhaustive match failure near " 
          (POSITION-SPEC::printAll |!position|)))) 
    (cons 
     :|ApplyN| 
     (cons 
      (cons 
       (STANDARDSPEC::mkOp 
        (cons :|Qualified| (cons "BuiltIn" "Fail")) 
        (cons 
         :|Arrow| 
         (vector POSSPEC::stringPSort srt POSITION-SPEC::internalPosition))) 
       (cons (STANDARDSPEC::mkString msg) nil)) 
      POSITION-SPEC::internalPosition))))
                                         
(defun POSSPEC::extendMatch (match pos) 
  (labels 
    ((|!loop| (rules) 
      (block 
       nil 
       (if (null rules) 
           (return nil) 
           (if (consp rules) 
               (let ((pV4512 (cdr rules))
                     (pV4511 (car rules))) 
                 (progn (let ((pV4517 (svref pV4511 1))
                              (pV4516 (svref pV4511 0))) 
                          (if (eq (car pV4516) :|WildPat|) 
                              (if (eq (car pV4517) :|Fun|) 
                                  (let ((pV4527 (svref (cdr pV4517) 0))) 
                                    (if (eq (car pV4527) :|Bool|) 
                                        (if (eq t (cdr pV4527)) 
                                            (if (null pV4512) (return match)))))) 
                              (if (eq (car pV4516) :|VarPat|) 
                                  (if (eq (car pV4517) :|Fun|) 
                                      (let ((pV4522 (svref (cdr pV4517) 0))) 
                                        (if (eq (car pV4522) :|Bool|) 
                                            (if (eq t (cdr pV4522)) 
                                                (if (null pV4512) (return match))))))))) 
                        (if (null pV4512) 
                            (return 
                             (LIST-SPEC::|!++| 
                              match 
                              (cons 
                               (vector 
                                (cons 
                                 :|WildPat| 
                                 (cons 
                                  (METASLANG::patternSort (svref pV4511 0)) 
                                  pos)) 
                                (STANDARDSPEC::mkTrue) 
                                (POSSPEC::mkFail 
                                 pos 
                                 (METASLANG::termSort (svref pV4511 2)))) 
                               nil)))) 
                        (return (|!loop| pV4512)))))) 
       (error "Nonexhaustive match failure in extendMatch")))) (|!loop| match)))
                                                                                
(defun POSSPEC::extendMatch-1 (x) (POSSPEC::extendMatch (car x) (cdr x)))
                                                                         
(defun POSSPEC::findTyVar (context uniqueId) 
  (let ((mp (STATE::|!!| (cdr context)))) 
    (let ((pV4532 (NATMAP::|!find| mp uniqueId))) 
      (block 
       nil 
       (if (eq (car pV4532) :|Some|) 
           (return (cdr pV4532)) 
           (if (eq (car pV4532) :|None|) 
               (return 
                (let ((|!number| (STATE::|!!| (car context)))) 
                  (let ((increment (NAT-SPEC::div |!number| 5))) 
                    (let ((parity (NAT-SPEC::|!rem| |!number| 5))) 
                      (let ((prefix 
                             (block 
                              nil 
                              (if ( =  0 parity) 
                                  (return "a") 
                                  (if ( =  1 parity) 
                                      (return "b") 
                                      (if ( =  2 parity) 
                                          (return "c") 
                                          (if ( =  3 parity) 
                                              (return "d") 
                                              (if ( =  4 parity) (return "e")))))) 
                              (error "Nonexhaustive match failure in findTyVar")))) 
                        (let ((suffix 
                               (if ( =  increment 0) 
                                   "" 
                                   (NAT-SPEC::toString increment)))) 
                          (let ((name (STRING-SPEC::^ prefix suffix))) name))))))))) 
       (error "Nonexhaustive match failure in findTyVar")))))
                                                             
(defun POSSPEC::findTyVar-1 (x) (POSSPEC::findTyVar (car x) (cdr x)))
                                                                     
(defun POSSPEC::initializeMetaTyVars () 
  (cons (cons :|Ref| 0) (cons :|Ref| NATMAP::empty)))
                                                     
(defun POSSPEC::initializeMetaTyVars-1 (ignore) 
  (declare (ignore ignore)) 
  (POSSPEC::initializeMetaTyVars))
                                  
(defun POSSPEC::insertDefaultMatches-1 (old_spec) 
  (labels 
    ((doTerm (term) 
      (block 
       nil 
       (if (eq (car term) :|Lambda|) 
           (let ((pV4543 (cdr term))) 
             (let ((pV4545 (cdr pV4543))
                   (pV4544 (car pV4543))) 
               (return 
                (progn (METASLANG::termSort 
                        (let ((pV4537 (LIST-SPEC::hd pV4544))) 
                          (block 
                           nil 
                           (return (svref pV4537 2)) 
                           (error 
                            "Nonexhaustive match failure in insertDefaultMatches")))) 
                       (let ((match (POSSPEC::extendMatch pV4544 pV4545))) 
                         (cons :|Lambda| (cons match pV4545)))))))) 
       (return term)))) 
    (let ((mkT 
           (METASLANG::mapTerm #'doTerm #'(lambda (s) s) #'(lambda (p) p)))) 
      (setOps 
       old_spec 
       (STRINGMAP::|!map|-1-1 
        #'(lambda (qmap) 
           (STRINGMAP::|!map|-1-1 
            #'(lambda (pV4546) 
               (block 
                nil 
                (let ((pV4550 (svref pV4546 3))) 
                  (if (eq (car pV4550) :|Some|) 
                      (return 
                       (vector 
                        (svref pV4546 0) 
                        (svref pV4546 1) 
                        (svref pV4546 2) 
                        (cons :|Some| (funcall mkT (cdr pV4550))))))) 
                (return pV4546))) 
            qmap)) 
        (svref old_spec 1))))))
                               
(defun POSSPEC::insertDefaultMatches (x0 x1 x2 x3) 
  (POSSPEC::insertDefaultMatches-1 (vector x0 x1 x2 x3)))
                                                         
(defun POSSPEC::makeTyVarMap-1 (x) (POSSPEC::makeTyVarMap (car x) (cdr x)))
                                                                           
(defun POSSPEC::mapImage-1 (x) (POSSPEC::mapImage (car x) (cdr x)))
                                                                   
(defun POSSPEC::mkApplyN (t1 t2) 
  (cons :|ApplyN| (cons (cons t1 (cons t2 nil)) POSITION-SPEC::internalPosition)))


(defun POSSPEC::mkApplyN-1 (x) (POSSPEC::mkApplyN (car x) (cdr x)))
                                                                   
(defun POSSPEC::mkConsPattern (p1 p2 pos element_type) 
  (cons 
   :|EmbedPat| 
   (vector 
    "Cons" 
    (cons 
     :|Some| 
     (cons :|RecordPat| (cons (cons (cons "1" p1) (cons (cons "2" p2) nil)) pos))) 
    (cons 
     :|Base| 
     (vector 
      (cons :|Qualified| (cons "List" "List")) 
      (cons element_type nil) 
      pos)) 
    pos)))
          
(defun POSSPEC::mkConsPattern-1 (x) 
  (POSSPEC::mkConsPattern (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                           
(defun POSSPEC::mkFail-1 (x) (POSSPEC::mkFail (car x) (cdr x)))
                                                               
(defun POSSPEC::mkList (terms pos element_type) 
  (let ((list_type 
         (cons 
          :|Base| 
          (vector 
           (cons :|Qualified| (cons "List" "List")) 
           (cons element_type nil) 
           pos)))) 
    (let ((consFun 
           (cons 
            :|Fun| 
            (vector 
             (cons :|Embed| (cons "Cons" t)) 
             (cons 
              :|Arrow| 
              (vector 
               (cons 
                :|Product| 
                (cons 
                 (cons (cons "1" element_type) (cons (cons "2" list_type) nil)) 
                 pos)) 
               list_type 
               pos)) 
             pos)))) 
      (let ((empty_list 
             (cons 
              :|Fun| 
              (vector (cons :|Embed| (cons "Nil" nil)) list_type pos)))) 
        (labels 
          ((mkCons (x xs) 
            (cons 
             :|ApplyN| 
             (cons 
              (cons 
               consFun 
               (cons 
                (cons 
                 :|Record| 
                 (cons (cons (cons "1" x) (cons (cons "2" xs) nil)) pos)) 
                nil)) 
              pos)))) 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) (mkCons (car x) (cdr x))) 
           empty_list 
           terms))))))
                      
(defun POSSPEC::mkList-1 (x) 
  (POSSPEC::mkList (svref x 0) (svref x 1) (svref x 2)))
                                                        
(defun POSSPEC::mkListPattern (patterns pos element_type) 
  (let ((list_type 
         (cons 
          :|Base| 
          (vector 
           (cons :|Qualified| (cons "List" "List")) 
           (cons element_type nil) 
           pos)))) 
    (let ((empty_list (cons :|EmbedPat| (vector "Nil" '(:|None|) list_type pos)))) 
      (labels 
        ((mkCons (x xs) 
          (cons 
           :|EmbedPat| 
           (vector 
            "Cons" 
            (cons 
             :|Some| 
             (cons 
              :|RecordPat| 
              (cons (cons (cons "1" x) (cons (cons "2" xs) nil)) pos))) 
            list_type 
            pos)))) 
        (LIST-SPEC::foldr-1-1-1 
         #'(lambda (x) (mkCons (car x) (cdr x))) 
         empty_list 
         patterns)))))
                      
(defun POSSPEC::mkListPattern-1 (x) 
  (POSSPEC::mkListPattern (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defparameter POSSPEC::natPSort 
  (STANDARDSPEC::mkBase (cons :|Qualified| (cons "Nat" "Nat")) nil))
                                                                    
(defun POSSPEC::removeDefinitions-1 (old_spec) 
  (let ((new_ops 
         (STRINGMAP::mapDouble-1-1 
          #'(lambda (x) 
             (let ((pV4567 (svref x 2))) 
               (block 
                nil 
                (return 
                 (vector 
                  (svref x 0) 
                  (svref x 1) 
                  (cons (car pV4567) (cdr pV4567)) 
                  '(:|None|))) 
                (error "Nonexhaustive match failure in removeDefinitions")))) 
          (svref old_spec 1)))) 
    (vector (svref old_spec 0) new_ops emptyAProperties (svref old_spec 3))))
                                                                             
(defun POSSPEC::removeDefinitions (x0 x1 x2 x3) 
  (POSSPEC::removeDefinitions-1 (vector x0 x1 x2 x3)))
                                                      
(defun POSSPECTOSPEC::convertPosSpecToSpec-1 (spc) 
  (let ((context (POSSPEC::initializeMetaTyVars))) 
    (labels 
      ((convertPFun (f) 
        (block 
         nil 
         (if (eq (car f) :|PQuotient|) 
             (return '(:|Quotient|)) 
             (if (eq (car f) :|PChoose|) 
                 (return '(:|Choose|)) 
                 (if (eq (car f) :|PRestrict|) 
                     (return '(:|Restrict|)) 
                     (if (eq (car f) :|PRelax|) 
                         (return '(:|Relax|)) 
                         (if (eq (car f) :|OneName|) 
                             (let ((pV4600 (cdr f))) 
                               (return 
                                (cons 
                                 :|Op| 
                                 (cons 
                                  (cons 
                                   :|Qualified| 
                                   (cons METASLANG::UnQualified (car pV4600))) 
                                  (cdr pV4600))))) 
                             (if (eq (car f) :|TwoNames|) 
                                 (let ((pV4599 (cdr f))) 
                                   (return 
                                    (cons 
                                     :|Op| 
                                     (cons 
                                      (cons 
                                       :|Qualified| 
                                       (cons (svref pV4599 0) (svref pV4599 1))) 
                                      (svref pV4599 2))))))))))) 
         (return f)))
       (convertPSort (srt) 
        (block 
         nil 
         (if (eq (car srt) :|MetaTyVar|) 
             (let ((pV4594 (cdr srt))) 
               (return 
                (let ((pV4588 (STATE::|!!| (car pV4594)))) 
                  (block 
                   nil 
                   (let ((pV4589 (svref pV4588 0))) 
                     (return 
                      (block 
                       nil 
                       (if (eq (car pV4589) :|None|) 
                           (return 
                            (cons 
                             :|TyVar| 
                             (cons 
                              (POSSPEC::findTyVar context (svref pV4588 2)) 
                              (cdr pV4594)))) 
                           (if (eq (car pV4589) :|Some|) 
                               (return (convertPSort (cdr pV4589))))) 
                       (error 
                        "Nonexhaustive match failure in convertPosSpecToSpec")))) 
                   (error "Nonexhaustive match failure in convertPosSpecToSpec")))))) 
         (return srt)))
       (convertPTerm (term) 
        (block 
         nil 
         (if (eq (car term) :|ApplyN|) 
             (let ((pV4574 (cdr term))) 
               (let ((pV4579 (cdr pV4574))
                     (pV4578 (car pV4574))) 
                 (if (consp pV4578) 
                     (let ((pV4582 (cdr pV4578))
                           (pV4581 (car pV4578))) 
                       (if (consp pV4582) 
                           (let ((pV4585 (cdr pV4582))
                                 (pV4584 (car pV4582))) 
                             (progn (if (null pV4585) 
                                        (return 
                                         (cons 
                                          :|Apply| 
                                          (vector pV4581 pV4584 pV4579)))) 
                                    (return 
                                     (convertPTerm 
                                      (cons 
                                       :|ApplyN| 
                                       (cons 
                                        (cons 
                                         pV4581 
                                         (cons 
                                          (cons 
                                           :|ApplyN| 
                                           (cons 
                                            (LIST-SPEC::|!cons| pV4584 pV4585) 
                                            pV4579)) 
                                          nil)) 
                                        pV4579))))))))))) 
             (if (eq (car term) :|Fun|) 
                 (let ((pV4573 (cdr term))) 
                   (return 
                    (cons 
                     :|Fun| 
                     (vector 
                      (convertPFun (svref pV4573 0)) 
                      (svref pV4573 1) 
                      (svref pV4573 2))))))) 
         (return term)))) 
      (block 
       nil 
       (let ((pV4624 (svref spc 0))) 
         (return 
          (block 
           nil 
           (let ((pV4622 (svref pV4624 3))
                 (pV4621 (svref pV4624 2))) 
             (return 
              (let ((tsp_maps 
                     (vector #'convertPTerm #'convertPSort #'(lambda (x) x)))) 
                (vector 
                 pV4624 
                 (mapAQualifierMap-1-1 
                  #'(lambda (opinfo) 
                     (let ((pV4614 (svref opinfo 2))
                           (pV4612 (svref opinfo 0))) 
                       (block 
                        nil 
                        (return 
                         (let ((nm (LIST-SPEC::hd pV4612))) 
                           (if (LIST-SPEC::|!member| nm pV4621) 
                               (vector 
                                pV4612 
                                (svref opinfo 1) 
                                (cons 
                                 (car pV4614) 
                                 (METASLANG::mapSort-1-1 tsp_maps (cdr pV4614))) 
                                (mapTermOpt-1-1 tsp_maps (svref opinfo 3))) 
                               opinfo))) 
                        (error 
                         "Nonexhaustive match failure in convertPosSpecToSpec")))) 
                  (svref spc 1)) 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) 
                     (vector 
                      (svref x 0) 
                      (svref x 1) 
                      (svref x 2) 
                      (METASLANG::mapTerm-1-1 tsp_maps (svref x 3)))) 
                  (svref spc 2)) 
                 (mapAQualifierMap-1-1 
                  #'(lambda (|!sortinfo|) 
                     (let ((aliases (svref |!sortinfo| 0))) 
                       (let ((nm (LIST-SPEC::hd aliases))) 
                         (if (LIST-SPEC::|!member| nm pV4622) 
                             (vector 
                              aliases 
                              (svref |!sortinfo| 1) 
                              (mapSortOpt-1-1 tsp_maps (svref |!sortinfo| 2))) 
                             |!sortinfo|)))) 
                  (svref spc 3)))))) 
           (error "Nonexhaustive match failure in convertPosSpecToSpec")))) 
       (error "Nonexhaustive match failure in convertPosSpecToSpec")))))
                                                                        
(defun POSSPECTOSPEC::convertPosSpecToSpec (x0 x1 x2 x3) 
  (POSSPECTOSPEC::convertPosSpecToSpec-1 (vector x0 x1 x2 x3)))
                                                               
(defun POSITION-SPEC::chooseNonZeroPos (p1 p2) 
  (block 
   nil 
   (if (eq (car p1) :|File|) (return p1)) 
   (if (eq (car p2) :|File|) (return p2)) 
   (if (eq (car p1) :|String|) (return p1)) 
   (if (eq (car p2) :|String|) (return p2)) 
   (return p1)))
                
(defun POSITION-SPEC::chooseNonZeroPos-1 (x) 
  (POSITION-SPEC::chooseNonZeroPos (car x) (cdr x)))
                                                    
(defun POSITION-SPEC::compare (p1 p2) 
  (labels 
    ((compareLineColumnByte (pV4647 pV4648) 
      (block 
       nil 
       (let ((pV4651 (svref pV4647 2))) 
         (let ((pV4654 (svref pV4648 2))) 
           (return 
            (if (INTEGER-SPEC::|!<| pV4651 pV4654) 
                '(:|Less|) 
                (if (INTEGER-SPEC::|!>| pV4651 pV4654) '(:|Greater|) '(:|Equal|)))))) 
       (error "Nonexhaustive match failure in compare")))) 
    (block 
     nil 
     (if (eq (car p1) :|Internal|) 
         (return 
          (block 
           nil 
           (if (eq (car p2) :|Internal|) 
               (return (STRING-SPEC::compare (cdr p1) (cdr p2))) 
               (if (eq (car p2) :|String|) 
                   (return '(:|Less|)) 
                   (if (eq (car p2) :|File|) (return '(:|Less|))))) 
           (error "Nonexhaustive match failure in compare"))) 
         (if (eq (car p1) :|String|) 
             (let ((pV4685 (cdr p1))) 
               (return 
                (block 
                 nil 
                 (if (eq (car p2) :|Internal|) 
                     (return '(:|Greater|)) 
                     (if (eq (car p2) :|String|) 
                         (let ((pV4667 (cdr p2))) 
                           (return 
                            (let ((pV4663 
                                   (STRING-SPEC::compare 
                                    (svref pV4685 0) 
                                    (svref pV4667 0)))) 
                              (block 
                               nil 
                               (if (eq (car pV4663) :|Equal|) 
                                   (return 
                                    (let ((pV4662 
                                           (compareLineColumnByte 
                                            (svref pV4685 1) 
                                            (svref pV4667 1)))) 
                                      (block 
                                       nil 
                                       (if (eq (car pV4662) :|Equal|) 
                                           (return 
                                            (compareLineColumnByte 
                                             (svref pV4685 2) 
                                             (svref pV4667 2)))) 
                                       (return pV4662))))) 
                               (return pV4663))))) 
                         (if (eq (car p2) :|File|) (return '(:|Less|))))) 
                 (error "Nonexhaustive match failure in compare")))) 
             (if (eq (car p1) :|File|) 
                 (let ((pV4684 (cdr p1))) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car p2) :|Internal|) 
                         (return '(:|Greater|)) 
                         (if (eq (car p2) :|String|) 
                             (return '(:|Greater|)) 
                             (if (eq (car p2) :|File|) 
                                 (let ((pV4677 (cdr p2))) 
                                   (return 
                                    (let ((pV4675 
                                           (STRING-SPEC::compare 
                                            (svref pV4684 0) 
                                            (svref pV4677 0)))) 
                                      (block 
                                       nil 
                                       (if (eq (car pV4675) :|Equal|) 
                                           (return 
                                            (let ((pV4674 
                                                   (compareLineColumnByte 
                                                    (svref pV4684 1) 
                                                    (svref pV4677 1)))) 
                                              (block 
                                               nil 
                                               (if (eq (car pV4674) :|Equal|) 
                                                   (return 
                                                    (compareLineColumnByte 
                                                     (svref pV4684 2) 
                                                     (svref pV4677 2)))) 
                                               (return pV4674))))) 
                                       (return pV4675)))))))) 
                     (error "Nonexhaustive match failure in compare"))))))) 
     (error "Nonexhaustive match failure in compare"))))
                                                        
(defun POSITION-SPEC::compare-1 (x) (POSITION-SPEC::compare (car x) (cdr x)))
                                                                             
(defun POSITION-SPEC::endLineColumnByte (|!string|) 
  (let ((|!last| (INTEGER-SPEC::|!-| (STRING-SPEC::|!length| |!string|) 1))) 
    (vector 1 |!last| |!last|)))
                                
(defun POSITION-SPEC::|!print| (|!position|) 
  (block 
   nil 
   (if (eq (car |!position|) :|Internal|) 
       (return (cdr |!position|)) 
       (if (eq (car |!position|) :|String|) 
           (let ((pV4695 (cdr |!position|))) 
             (return 
              (let ((printPos 
                     #'(lambda (x) 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ (NAT-SPEC::toString (svref x 0)) ".") 
                         (NAT-SPEC::toString (svref x 1)))))) 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ (funcall printPos (svref pV4695 1)) "-") 
                   (funcall printPos (svref pV4695 2))) 
                  " in ") 
                 (svref pV4695 0))))) 
           (if (eq (car |!position|) :|File|) 
               (let ((pV4694 (cdr |!position|))) 
                 (return 
                  (let ((printPos 
                         #'(lambda (x) 
                            (STRING-SPEC::^ 
                             (STRING-SPEC::^ 
                              (NAT-SPEC::toString (svref x 0)) 
                              ".") 
                             (NAT-SPEC::toString (svref x 1)))))) 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ (funcall printPos (svref pV4694 1)) "-") 
                     (funcall printPos (svref pV4694 2))))))))) 
   (error "Nonexhaustive match failure in print")))
                                                   
(defparameter POSITION-SPEC::startLineColumnByte (vector 1 0 0))
                                                                
(defun PRETTYPRINT::addBreak-1 (x) 
  (PRETTYPRINT::addBreak (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun PRETTYPRINT::addSeparator-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::addSeparator-1-1 x1 x2)))
                                                        
(defun PRETTYPRINT::addSeparator (x0 x1) 
  (PRETTYPRINT::addSeparator-1 (cons x0 x1)))
                                             
(defun PRETTYPRINT::appendFile-1 (x) (PRETTYPRINT::appendFile (car x) (cdr x)))
                                                                               
(defun PRETTYPRINT::appendFileWithNewline-1 (x) 
  (PRETTYPRINT::appendFileWithNewline (svref x 0) (svref x 1) (svref x 2)))
                                                                           
(defun PRETTYPRINT::appendLatexFile-1 (x) 
  (PRETTYPRINT::appendLatexFile (car x) (cdr x)))
                                                 
(defun PRETTYPRINT::blankLines-1 (x) (PRETTYPRINT::blankLines (car x) (cdr x)))
                                                                               
(defun PRETTYPRINT::|!block| (style |!newlines| lines) 
  (block 
   nil 
   (if (eq (car style) :|None|) 
       (return (PRETTYPRINT::blockNone |!newlines| lines)) 
       (if (eq (car style) :|All|) 
           (return (PRETTYPRINT::blockAll |!newlines| lines)) 
           (if (eq (car style) :|Fill|) 
               (return (PRETTYPRINT::blockFill |!newlines| lines)) 
               (if (eq (car style) :|Linear|) 
                   (return (PRETTYPRINT::blockLinear |!newlines| lines)))))) 
   (error "Nonexhaustive match failure in block")))
                                                   
(defun PRETTYPRINT::|!block|-1 (x) 
  (PRETTYPRINT::|!block| (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun PRETTYPRINT::buttonPretty-1 (x) 
  (PRETTYPRINT::buttonPretty (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                              
(defun PRETTYPRINT::emptyPretty-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::emptyPretty))
                             
(defun PRETTYPRINT::emptyText-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::emptyText))
                           
(defun PRETTYPRINT::extend-1 (x) 
  (PRETTYPRINT::extend (svref x 0) (svref x 1) (svref x 2)))
                                                            
(defun PRETTYPRINT::fits?-1 (x) 
  (PRETTYPRINT::fits? (svref x 0) (svref x 1) (svref x 2)))
                                                           
(defun PRETTYPRINT::|!format|-1 (x) (PRETTYPRINT::|!format| (car x) (cdr x)))
                                                                             
(defun PRETTYPRINT::formatLines-1 (x) 
  (PRETTYPRINT::formatLines (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                             
(defun PRETTYPRINT::formatPretty-1 (x) 
  (PRETTYPRINT::formatPretty (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun PRETTYPRINT::insertElem-1 (x) (PRETTYPRINT::insertElem (car x) (cdr x)))
                                                                               
(defun PRETTYPRINT::lengthString-1 (x) 
  (PRETTYPRINT::lengthString (car x) (cdr x)))
                                              
(defun PRETTYPRINT::lines (ps) (PRETTYPRINT::prettysAll ps))
                                                            
(defun PRETTYPRINT::markLines-1 (x) (PRETTYPRINT::markLines (car x) (cdr x)))
                                                                             
(defun PRETTYPRINT::markPretty-1 (x) (PRETTYPRINT::markPretty (car x) (cdr x)))
                                                                               
(defun PRETTYPRINT::newline-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::newline))
                         
(defun PRETTYPRINT::newlineString-1 (ignore) 
  (declare (ignore ignore)) 
  (PRETTYPRINT::newlineString))
                               
(defun PRETTYPRINT::ppList (x1) 
  #'(lambda (x2) #'(lambda (x3) (PRETTYPRINT::ppList-1-1-1 x1 x2 x3))))
                                                                       
(defun PRETTYPRINT::pretty-1 (x) (PRETTYPRINT::pretty (car x) (cdr x)))
                                                                       
(defun PRETTYPRINT::prettysAllDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysAllDelim-1-1 x1 x2)))
                                                           
(defun PRETTYPRINT::prettysAllDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysAllDelim-1 (vector x0 x1 x2)))
                                                     
(defun PRETTYPRINT::prettysBlock (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysBlock-1-1 x1 x2)))
                                                        
(defun PRETTYPRINT::prettysBlockDelim (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (PRETTYPRINT::prettysBlockDelim-1-1-1 x1 x2 x3))))
                                                                      
(defun PRETTYPRINT::prettysFillDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysFillDelim-1-1 x1 x2)))
                                                            
(defun PRETTYPRINT::prettysFillDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysFillDelim-1 (vector x0 x1 x2)))
                                                      
(defun PRETTYPRINT::prettysLinearDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysLinearDelim-1-1 x1 x2)))
                                                              
(defun PRETTYPRINT::prettysLinearDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysLinearDelim-1 (vector x0 x1 x2)))
                                                        
(defun PRETTYPRINT::prettysNoneDelim-1 (x1) 
  #'(lambda (x2) (PRETTYPRINT::prettysNoneDelim-1-1 x1 x2)))
                                                            
(defun PRETTYPRINT::prettysNoneDelim (x0 x1 x2) 
  (PRETTYPRINT::prettysNoneDelim-1 (vector x0 x1 x2)))
                                                      
(defun PRETTYPRINT::|!reduce|-1 (x) (PRETTYPRINT::|!reduce| (car x) (cdr x)))
                                                                             
(defun PRETTYPRINT::shift-1 (x) 
  (PRETTYPRINT::shift (svref x 0) (svref x 1) (svref x 2)))
                                                           
(defun PRETTYPRINT::streamWriter-1 (x) 
  (PRETTYPRINT::streamWriter (car x) (cdr x)))
                                              
(defun PRETTYPRINT::toFile-1 (x) (PRETTYPRINT::toFile (car x) (cdr x)))
                                                                       
(defun PRETTYPRINT::toFileWithNewline-1 (x) 
  (PRETTYPRINT::toFileWithNewline (svref x 0) (svref x 1) (svref x 2)))
                                                                       
(defun PRETTYPRINT::toFileWithPathIndexing-1 (x) 
  (PRETTYPRINT::toFileWithPathIndexing (car x) (cdr x)))
                                                        
(defun PRETTYPRINT::toLatexFile-1 (x) 
  (PRETTYPRINT::toLatexFile (car x) (cdr x)))
                                             
(defun PRETTYPRINT::toPathFiles-1 (x) 
  (PRETTYPRINT::toPathFiles (svref x 0) (svref x 1) (svref x 2)))
                                                                 
(defun PRETTYPRINT::toStream-1 (x) 
  (PRETTYPRINT::toStream (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                          
(defun PRETTYPRINT::widthPretty (x0 x1) 
  (PRETTYPRINT::widthPretty-1 (cons x0 x1)))
                                            
(defun SKETCH::edges (x0 x1 x2 x3) (SKETCH::edges-1 (vector x0 x1 x2 x3)))
                                                                          
(defun SKETCH::|!eval| (x) (POLYMAP::|!eval| x))
                                                
(defun SKETCH::|!eval|-1-1 (x0 x1) (POLYMAP::|!eval|-1-1 x0 x1))
                                                                
(defun SKETCH::foldMap (x) (POLYMAP::foldMap x))
                                                
(defun SKETCH::foldMap-1-1-1 (x0 x1 x2) (POLYMAP::foldMap-1-1-1 x0 x1 x2))
                                                                          
(defun SKETCH::insertEdge-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) #'(lambda (x4) (SKETCH::insertEdge-1-1-1-1 x1 x2 x3 x4)))))
                                                                               
(defun SKETCH::insertEdge (x0 x1 x2 x3) 
  (SKETCH::insertEdge-1 (vector x0 x1 x2 x3)))
                                              
(defun SKETCH::insertVertex-1 (x1) 
  #'(lambda (x2) (SKETCH::insertVertex-1-1 x1 x2)))
                                                   
(defun SKETCH::insertVertex (x0 x1 x2 x3) 
  (SKETCH::insertVertex-1 (vector x0 x1 x2 x3)))
                                                
(defun SKETCH::ppCod (x) (VERTEX::ppElem x))
                                            
(defun SKETCH::ppDom (x) (EDGE::ppElem x))
                                          
(defun SKETCH::ppMap (|!map|) 
  (WADLERLINDIG::ppSep-1-1 
   WADLERLINDIG::ppNewline 
   (SKETCH::foldMap-1-1-1 
    #'(lambda (l) 
       #'(lambda (dom) 
          #'(lambda (cod) 
             (cons 
              (WADLERLINDIG::ppConcat 
               (cons 
                (SKETCH::ppDom dom) 
                (cons 
                 (WADLERLINDIG::ppString "+->") 
                 (cons (SKETCH::ppCod cod) nil)))) 
              l)))) 
    nil 
    |!map|)))
             
(defun SKETCH::ppSketch (x0 x1 x2 x3) (SKETCH::ppSketch-1 (vector x0 x1 x2 x3)))
                                                                                
(defun SKETCH::src (x0 x1 x2 x3) (SKETCH::src-1 (vector x0 x1 x2 x3)))
                                                                      
(defun SKETCH::target (x0 x1 x2 x3) (SKETCH::target-1 (vector x0 x1 x2 x3)))
                                                                            
(defun SKETCH::update (x) (POLYMAP::update x))
                                              
(defun SKETCH::vertices (x0 x1 x2 x3) (SKETCH::vertices-1 (vector x0 x1 x2 x3)))
                                                                                
(defun WADLERLINDIG::ppAppend-1-1 (p1 p2) (WADLERLINDIG::ppCons-1-1 p1 p2))
                                                                           
(defun SPECCALC::ppURIlocal (hashSuffix path) 
  (let ((prefix 
         (WADLERLINDIG::ppSep-1-1 
          (WADLERLINDIG::ppString "/") 
          (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString path)))) 
    (block 
     nil 
     (if (eq (car hashSuffix) :|None|) 
         (return prefix) 
         (if (eq (car hashSuffix) :|Some|) 
             (return 
              (WADLERLINDIG::ppAppend-1-1 
               prefix 
               (WADLERLINDIG::ppString (STRING-SPEC::^ "#" (cdr hashSuffix))))))) 
     (error "Nonexhaustive match failure in ppURIlocal"))))
                                                           
(defun SPECCALC::ppURIlocal-1 (x) (SPECCALC::ppURIlocal (car x) (cdr x)))
                                                                         
(defun SPECCALC::ppRelativeURI (relURI) 
  (block 
   nil 
   (if (eq (car relURI) :|SpecPath_Relative|) 
       (return 
        (WADLERLINDIG::ppAppend-1-1 
         (WADLERLINDIG::ppString "/") 
         (SPECCALC::ppURIlocal-1 (cdr relURI)))) 
       (if (eq (car relURI) :|URI_Relative|) 
           (return (SPECCALC::ppURIlocal-1 (cdr relURI))))) 
   (error "Nonexhaustive match failure in ppRelativeURI")))
                                                           
(defun WADLERLINDIG::ppFits-1-1 (w x) 
  (lisp::and 
   (INTEGER-SPEC::|!>=| w 0) 
   (block 
    nil 
    (if (null x) 
        (return t) 
        (if (consp x) 
            (let ((pV12267 (car x))
                  (pV12268 (cdr x))) 
              (let ((pV12269 (svref pV12267 0))
                    (pV12270 (svref pV12267 1))
                    (pV12271 (svref pV12267 2))) 
                (progn (if (eq (car pV12271) :|DocNil|) 
                           (return (WADLERLINDIG::ppFits-1-1 w pV12268)) 
                           (if (eq (car pV12271) :|DocCons|) 
                               (let ((pV12277 (cdr pV12271))) 
                                 (return 
                                  (WADLERLINDIG::ppFits-1-1 
                                   w 
                                   (cons 
                                    (vector pV12269 pV12270 (car pV12277)) 
                                    (cons 
                                     (vector pV12269 pV12270 (cdr pV12277)) 
                                     pV12268))))) 
                               (if (eq (car pV12271) :|DocNest|) 
                                   (let ((pV12276 (cdr pV12271))) 
                                     (return 
                                      (WADLERLINDIG::ppFits-1-1 
                                       w 
                                       (cons 
                                        (vector 
                                         (INTEGER-SPEC::|!+| 
                                          pV12269 
                                          (car pV12276)) 
                                         pV12270 
                                         (cdr pV12276)) 
                                        pV12268)))) 
                                   (if (eq (car pV12271) :|DocText|) 
                                       (return 
                                        (WADLERLINDIG::ppFits-1-1 
                                         (INTEGER-SPEC::|!-| 
                                          w 
                                          (STRING-SPEC::|!length| (cdr pV12271))) 
                                         pV12268)))))) 
                       (if (eq (car pV12270) :|Flat|) 
                           (if (eq (car pV12271) :|DocBreak|) 
                               (return 
                                (WADLERLINDIG::ppFits-1-1 
                                 (INTEGER-SPEC::|!-| 
                                  w 
                                  (STRING-SPEC::|!length| (cdr pV12271))) 
                                 pV12268))) 
                           (if (eq (car pV12270) :|Break|) 
                               (if (eq (car pV12271) :|DocBreak|) (return t)))) 
                       (if (eq (car pV12271) :|DocGroup|) 
                           (return 
                            (WADLERLINDIG::ppFits-1-1 
                             w 
                             (cons 
                              (vector pV12269 '(:|Flat|) (cdr pV12271)) 
                              pV12268))))))))) 
    (error "Nonexhaustive match failure in ppFits"))))
                                                      
(defun WADLERLINDIG::ppBest-1-1-1 (w k x) 
  (block 
   nil 
   (if (null x) 
       (return '(:|SNil|)) 
       (if (consp x) 
           (let ((pV12242 (car x))
                 (pV12243 (cdr x))) 
             (let ((pV12244 (svref pV12242 0))
                   (pV12245 (svref pV12242 1))
                   (pV12246 (svref pV12242 2))) 
               (progn (if (eq (car pV12246) :|DocNil|) 
                          (return (WADLERLINDIG::ppBest-1-1-1 w k pV12243)) 
                          (if (eq (car pV12246) :|DocCons|) 
                              (let ((pV12252 (cdr pV12246))) 
                                (return 
                                 (WADLERLINDIG::ppBest-1-1-1 
                                  w 
                                  k 
                                  (cons 
                                   (vector pV12244 pV12245 (car pV12252)) 
                                   (cons 
                                    (vector pV12244 pV12245 (cdr pV12252)) 
                                    pV12243))))) 
                              (if (eq (car pV12246) :|DocNest|) 
                                  (let ((pV12251 (cdr pV12246))) 
                                    (return 
                                     (WADLERLINDIG::ppBest-1-1-1 
                                      w 
                                      k 
                                      (cons 
                                       (vector 
                                        (INTEGER-SPEC::|!+| 
                                         pV12244 
                                         (car pV12251)) 
                                        pV12245 
                                        (cdr pV12251)) 
                                       pV12243)))) 
                                  (if (eq (car pV12246) :|DocText|) 
                                      (let ((pV12250 (cdr pV12246))) 
                                        (return 
                                         (cons 
                                          :|SText| 
                                          (cons 
                                           pV12250 
                                           (WADLERLINDIG::ppBest-1-1-1 
                                            w 
                                            (INTEGER-SPEC::|!+| 
                                             k 
                                             (STRING-SPEC::|!length| pV12250)) 
                                            pV12243))))))))) 
                      (if (eq (car pV12245) :|Flat|) 
                          (if (eq (car pV12246) :|DocBreak|) 
                              (let ((pV12249 (cdr pV12246))) 
                                (return 
                                 (cons 
                                  :|SText| 
                                  (cons 
                                   pV12249 
                                   (WADLERLINDIG::ppBest-1-1-1 
                                    w 
                                    (INTEGER-SPEC::|!+| 
                                     k 
                                     (STRING-SPEC::|!length| pV12249)) 
                                    pV12243)))))) 
                          (if (eq (car pV12245) :|Break|) 
                              (if (eq (car pV12246) :|DocBreak|) 
                                  (return 
                                   (cons 
                                    :|SLine| 
                                    (cons 
                                     pV12244 
                                     (WADLERLINDIG::ppBest-1-1-1 
                                      w 
                                      pV12244 
                                      pV12243))))))) 
                      (if (eq (car pV12246) :|DocGroup|) 
                          (let ((pV12247 (cdr pV12246))) 
                            (return 
                             (if (WADLERLINDIG::ppFits-1-1 
                                  (INTEGER-SPEC::|!-| w k) 
                                  (cons 
                                   (vector pV12244 '(:|Flat|) pV12247) 
                                   pV12243)) 
                                 (WADLERLINDIG::ppBest-1-1-1 
                                  w 
                                  k 
                                  (cons 
                                   (vector pV12244 '(:|Flat|) pV12247) 
                                   pV12243)) 
                                 (WADLERLINDIG::ppBest-1-1-1 
                                  w 
                                  k 
                                  (cons 
                                   (vector pV12244 '(:|Break|) pV12247) 
                                   pV12243))))))))))) 
   (error "Nonexhaustive match failure in ppBest")))
                                                    
(defun WADLERLINDIG::ppLayout (doc) 
  (labels 
    ((replicate (cnt) 
      #'(lambda (str) 
         (if ( =  cnt 0) 
             (cons "" nil) 
             (cons str (funcall (replicate (INTEGER-SPEC::|!-| cnt 1)) str)))))) 
    (labels 
      ((makeStringList (doc) 
        (block 
         nil 
         (if (eq (car doc) :|SNil|) 
             (return (cons "" nil)) 
             (if (eq (car doc) :|SText|) 
                 (let ((pV12284 (cdr doc))) 
                   (return (cons (car pV12284) (makeStringList (cdr pV12284))))) 
                 (if (eq (car doc) :|SLine|) 
                     (let ((pV12283 (cdr doc))) 
                       (return 
                        (cons 
                         (STRING-SPEC::concatList 
                          (cons "
" (funcall (replicate (car pV12283)) " "))) 
                         (makeStringList (cdr pV12283)))))))) 
         (error "Nonexhaustive match failure in ppLayout")))) 
      (STRING-SPEC::concatList (makeStringList doc)))))
                                                       
(defun WADLERLINDIG::ppFormatWidth-1-1 (w doc) 
  (WADLERLINDIG::ppLayout 
   (WADLERLINDIG::ppBest-1-1-1 
    w 
    0 
    (cons (vector 0 '(:|Flat|) (cons :|DocGroup| doc)) nil))))
                                                              
(defun WADLERLINDIG::ppFormat (doc) (WADLERLINDIG::ppFormatWidth-1-1 80 doc))
                                                                             
(defun SPECCALC::showRelativeURI (uri) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppRelativeURI uri)))
                                                         
(defun SPECCALC::SpecTermToSpecName-1 (scterm) 
  (let ((term (car scterm))) 
    (block 
     nil 
     (if (eq (car term) :|URI|) 
         (return (cons :|Some| (SPECCALC::showRelativeURI (cdr term)))) 
         (if (eq (car term) :|Spec|) (return '(:|None|)))) 
     (return '(:|None|)))))
                           
(defun SPECCALC::SpecTermToSpecName (x0 x1) 
  (SPECCALC::SpecTermToSpecName-1 (cons x0 x1)))
                                                
(defun SPECCALC::raise-1-1 (except state) 
  (progn (if SPECCALC::specwareWizard? 
             (SYSTEM-SPEC::fail (SYSTEM-SPEC::toString except)) 
             nil) 
         (cons (cons :|Exception| except) state)))
                                                  
(defun SPECCALC::raise (x1) #'(lambda (x2) (SPECCALC::raise-1-1 x1 x2)))
                                                                        
(defun SPECCALC::|!error| (str) (SPECCALC::raise (cons :|Fail| str)))
                                                                     
(defun SPECCALC::|!return|-1-1 (x state) (cons (cons :|Ok| x) state))
                                                                     
(defun SPECCALC::|!return| (x1) 
  #'(lambda (x2) (SPECCALC::|!return|-1-1 x1 x2)))
                                                  
(defun SPECCALC::lastElem (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "lastElem: encountered empty string list")) 
       (if (consp elems) 
           (let ((pV5680 (cdr elems))) 
             (progn (if (null pV5680) (return (SPECCALC::|!return| (car elems)))) 
                    (return (SPECCALC::lastElem pV5680)))))) 
   (error "Nonexhaustive match failure in lastElem")))
                                                      
(defun SPECCALC::monadBind-1-1 (!x1 state) 
  (let ((x (funcall (car !x1) state))) 
    (let ((pV6188 (car x))
          (pV6189 (cdr x))) 
      (block 
       nil 
       (if (eq (car pV6188) :|Ok|) 
           (return (funcall (funcall (cdr !x1) (cdr pV6188)) pV6189)) 
           (if (eq (car pV6188) :|Exception|) 
               (return (cons (cons :|Exception| (cdr pV6188)) pV6189)))) 
       (error "Nonexhaustive match failure in monadBind")))))
                                                             
(defun SPECCALC::monadBind-1 (x1) 
  #'(lambda (x2) (SPECCALC::monadBind-1-1 x1 x2)))
                                                  
(defun SPECCALC::monadBind (x0 x1) (SPECCALC::monadBind-1 (cons x0 x1)))
                                                                        
(defun SPECCALC::removeLastElem (elems) 
  (block 
   nil 
   (if (null elems) 
       (return 
        (SPECCALC::|!error| "removeLastElem: encountered empty string list")) 
       (if (consp elems) 
           (let ((pV6802 (cdr elems))
                 (pV6801 (car elems))) 
             (progn (if (null pV6802) (return (SPECCALC::|!return| nil))) 
                    (return 
                     (SPECCALC::monadBind 
                      (SPECCALC::removeLastElem pV6802) 
                      #'(lambda (suffix) 
                         (SPECCALC::|!return| (cons pV6801 suffix))))))))) 
   (error "Nonexhaustive match failure in removeLastElem")))
                                                            
(defun SPECCALC::takeWhile-1-1 (pred l) 
  (block 
   nil 
   (if (null l) 
       (return (cons nil nil)) 
       (if (consp l) 
           (let ((pV7009 (car l))) 
             (return 
              (if (funcall pred pV7009) 
                  (let ((pV7004 (SPECCALC::takeWhile-1-1 pred (cdr l)))) 
                    (block 
                     nil 
                     (return (cons (cons pV7009 (car pV7004)) (cdr pV7004))) 
                     (error "Nonexhaustive match failure in takeWhile"))) 
                  (cons nil l)))))) 
   (error "Nonexhaustive match failure in takeWhile")))
                                                       
(defun SPECCALC::splitStringAtChar-1-1 (|!char| str) 
  (labels 
    ((parseCharList (chars) 
      (block 
       nil 
       (if (null chars) 
           (return nil) 
           (if (consp chars) 
               (return 
                (if (eq (car chars) |!char|) 
                    (parseCharList (cdr chars)) 
                    (let ((pV6997 
                           (SPECCALC::takeWhile-1-1 
                            #'(lambda (c) (BOOLEAN-SPEC::~ (eq c |!char|))) 
                            chars))) 
                      (block 
                       nil 
                       (return 
                        (cons 
                         (STRING-SPEC::implode (car pV6997)) 
                         (parseCharList (cdr pV6997)))) 
                       (error "Nonexhaustive match failure in splitStringAtChar"))))))) 
       (error "Nonexhaustive match failure in splitStringAtChar")))) 
    (parseCharList (STRING-SPEC::explode str))))
                                                
(defun SPECCALC::abbreviatedPath (path) 
  (let ((home 
         (let ((pV4934 (SYSTEM-SPEC::getEnv "HOME"))) 
           (block 
            nil 
            (if (eq (car pV4934) :|Some|) 
                (return (SPECCALC::splitStringAtChar-1-1 #\/ (cdr pV4934))) 
                (if (eq (car pV4934) :|None|) 
                    (return 
                     (let ((pV4932 (SYSTEM-SPEC::getEnv "HOMEPATH"))) 
                       (block 
                        nil 
                        (if (eq (car pV4932) :|Some|) 
                            (return 
                             (SPECCALC::splitStringAtChar-1-1 #\/ (cdr pV4932))) 
                            (if (eq (car pV4932) :|None|) (return nil))) 
                        (error "Nonexhaustive match failure in abbreviatedPath")))))) 
            (error "Nonexhaustive match failure in abbreviatedPath"))))) 
    (if (slang-built-in::slang-term-equals home nil) 
        path 
        (labels 
          ((removeCommonPrefix (p home) 
            (block 
             nil 
             (if (null home) (return (LIST-SPEC::|!++| (cons "~" nil) p))) 
             (if (null p) 
                 (return path) 
                 (if (consp p) 
                     (if (consp home) 
                         (return 
                          (if (string=  (car p) (car home)) 
                              (removeCommonPrefix (cdr p) (cdr home)) 
                              path))))) 
             (return path)))) (removeCommonPrefix path home)))))
                                                                
(defun SPECCALC::deviceString? (s) 
  (eq (STRING-SPEC::sub s (INTEGER-SPEC::|!-| (STRING-SPEC::|!length| s) 1)) #\:))


(defun SPECCALC::uriToPath (pV7030 path) 
  (declare (ignore pV7030)) 
  (let ((path (SPECCALC::abbreviatedPath path))) 
    (let ((device? (SPECCALC::deviceString? (LIST-SPEC::hd path)))) 
      (let ((tildaPath? (string=  (LIST-SPEC::hd path) "~"))) 
        (let ((mainPath 
               (STRING-SPEC::concatList 
                (LIST-SPEC::foldr-1-1-1 
                 #'(lambda (x) 
                    (LIST-SPEC::|!cons| "/" (LIST-SPEC::|!cons| (car x) (cdr x)))) 
                 nil 
                 (if (lisp::or tildaPath? device?) (LIST-SPEC::tl path) path))))) 
          (if tildaPath? 
              (STRING-SPEC::^ "~" mainPath) 
              (if device? 
                  (STRING-SPEC::^ (LIST-SPEC::hd path) mainPath) 
                  mainPath)))))))
                                 
(defun SPECCALC::URItoLispFile (pV4916 pV4917) 
  (block 
   nil 
   (let ((pV4919 (cdr pV4916))) 
     (return 
      (block 
       nil 
       (if (eq (car pV4917) :|Some|) (return (SPECCALC::|!return| (cdr pV4917)))) 
       (return 
        (SPECCALC::monadBind 
         (SPECCALC::removeLastElem pV4919) 
         #'(lambda (prefix) 
            (SPECCALC::monadBind 
             (SPECCALC::lastElem pV4919) 
             #'(lambda (mainName) 
                (SPECCALC::monadBind 
                 (SPECCALC::|!return| 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (SPECCALC::uriToPath '(:|None|) prefix) 
                     "/lisp/") 
                    mainName) 
                   ".lisp")) 
                 #'(lambda (|!fileName|) (SPECCALC::|!return| |!fileName|))))))))))) 
   (error "Nonexhaustive match failure in URItoLispFile")))
                                                           
(defun SPECCALC::URItoLispFile-1 (x) (SPECCALC::URItoLispFile (car x) (cdr x)))
                                                                               
(defun SPECCALC::URItoLispFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoLispFile-1 x1) x2))
                                              
(defun SPECCALC::URItoMultipleSnarkLogFile-1 (uri) 
  (let ((path (cdr uri))
        (hashSuffix (car uri))) 
    (block 
     nil 
     (if (eq (car hashSuffix) :|Some|) 
         (let ((pV4921 (cdr hashSuffix))) 
           (return 
            (SPECCALC::monadBind 
             (SPECCALC::removeLastElem path) 
             #'(lambda (prefix) 
                (SPECCALC::monadBind 
                 (SPECCALC::lastElem path) 
                 #'(lambda (newSubDir) 
                    (SPECCALC::monadBind 
                     (SPECCALC::|!return| pV4921) 
                     #'(lambda (mainName) 
                        (let ((filNm 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (SPECCALC::uriToPath '(:|None|) prefix) 
                                    "/snark/") 
                                   newSubDir) 
                                  "/") 
                                 mainName) 
                                ".log"))) (SPECCALC::|!return| filNm))))))))))) 
     (error "Nonexhaustive match failure in URItoMultipleSnarkLogFile"))))
                                                                          
(defun SPECCALC::URItoMultipleSnarkLogFile (x0 x1) 
  (SPECCALC::URItoMultipleSnarkLogFile-1 (cons x0 x1)))
                                                       
(defun SPECCALC::URItoMultipleSnarkLogFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoMultipleSnarkLogFile-1 x1) x2))
                                                          
(defun SPECCALC::URItoProofName-1 (uri) (car uri))
                                                  
(defun SPECCALC::URItoProofName (x0 x1) 
  (SPECCALC::URItoProofName-1 (cons x0 x1)))
                                            
(defun SPECCALC::URItoSingleSnarkLogFile-1 (uri) 
  (let ((path (cdr uri))) 
    (SPECCALC::monadBind 
     (SPECCALC::removeLastElem path) 
     #'(lambda (prefix) 
        (SPECCALC::monadBind 
         (SPECCALC::lastElem path) 
         #'(lambda (mainName) 
            (let ((filNm 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (SPECCALC::uriToPath '(:|None|) prefix) 
                      "/snark/") 
                     mainName) 
                    ".log"))) (SPECCALC::|!return| filNm))))))))
                                                                
(defun SPECCALC::URItoSingleSnarkLogFile (x0 x1) 
  (SPECCALC::URItoSingleSnarkLogFile-1 (cons x0 x1)))
                                                     
(defun SPECCALC::URItoSingleSnarkLogFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoSingleSnarkLogFile-1 x1) x2))
                                                        
(defun SPECCALC::monadSeq (f g) 
  (SPECCALC::monadBind f #'(lambda (pV6192) (declare (ignore pV6192)) 
                                            g)))
                                                
(defun SPECCALC::|!print|-1-1 (str state) 
  (progn (STRING-SPEC::toScreen str) (cons (cons :|Ok| nil) state)))
                                                                    
(defun SPECCALC::|!print| (x1) 
  #'(lambda (x2) (SPECCALC::|!print|-1-1 x1 x2)))
                                                 
(defun SPECCALC::URItoSnarkFile (pV4925 pV4926) 
  (block 
   nil 
   (let ((pV4928 (cdr pV4925))) 
     (return 
      (block 
       nil 
       (if (eq (car pV4926) :|Some|) (return (SPECCALC::|!return| (cdr pV4926)))) 
       (return 
        (SPECCALC::monadBind 
         (SPECCALC::removeLastElem pV4928) 
         #'(lambda (prefix) 
            (SPECCALC::monadBind 
             (SPECCALC::lastElem pV4928) 
             #'(lambda (mainName) 
                (let ((filNm 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          (SPECCALC::uriToPath '(:|None|) prefix) 
                          "/snark/") 
                         mainName) 
                        ".lisp"))) 
                  (SPECCALC::monadSeq 
                   (SPECCALC::|!print| 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ "Snark file name " filNm) 
                     "
")) 
                   (SPECCALC::|!return| filNm))))))))))) 
   (error "Nonexhaustive match failure in URItoSnarkFile")))
                                                            
(defun SPECCALC::URItoSnarkFile-1 (x) 
  (SPECCALC::URItoSnarkFile (car x) (cdr x)))
                                             
(defun SPECCALC::URItoSnarkFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoSnarkFile-1 x1) x2))
                                               
(defun SPECCALC::URItoSnarkLogFile-1 (uri) 
  (let ((hashSuffix (car uri))) 
    (SPECCALC::monadBind 
     (block 
      nil 
      (if (eq (car hashSuffix) :|None|) 
          (return (SPECCALC::URItoSingleSnarkLogFile-1 uri)) 
          (if (eq (car hashSuffix) :|Some|) 
              (return (SPECCALC::URItoMultipleSnarkLogFile-1 uri)))) 
      (error "Nonexhaustive match failure in URItoSnarkLogFile")) 
     #'(lambda (result) (SPECCALC::|!return| result)))))
                                                        
(defun SPECCALC::URItoSnarkLogFile (x0 x1) 
  (SPECCALC::URItoSnarkLogFile-1 (cons x0 x1)))
                                               
(defun SPECCALC::URItoSnarkLogFile-1-1 (x1 x2) 
  (funcall (SPECCALC::URItoSnarkLogFile-1 x1) x2))
                                                  
(defun SPECCALC::actualHypothesis (validHypothesis assertions) 
  (block 
   nil 
   (if (eq (car assertions) :|All|) 
       (return validHypothesis) 
       (if (eq (car assertions) :|Explicit|) 
           (let ((pV4950 (cdr assertions))) 
             (return 
              (let ((hypothesis 
                     (LIST-SPEC::filter-1-1 
                      #'(lambda (x) (LIST-SPEC::|!member| (svref x 1) pV4950)) 
                      validHypothesis))) hypothesis))))) 
   (error "Nonexhaustive match failure in actualHypothesis")))
                                                              
(defun SPECCALC::actualHypothesis-1 (x) 
  (SPECCALC::actualHypothesis (car x) (cdr x)))
                                               
(defun SPECCALC::addDevice? (path) 
  (if SYSTEM-SPEC::msWindowsSystem? 
      (if (SPECCALC::deviceString? (LIST-SPEC::hd path)) path (cons "C:" path)) 
      path))
            
(defun SPECCALC::addLabelledVertex-1 (dgm) 
  #'(lambda (nodeId) 
     #'(lambda (spc) 
        #'(lambda (|!position|) 
           (if (CAT::vertexInDiagram?-1-1 dgm nodeId) 
               (if (slang-built-in::slang-term-equals 
                    spc 
                    (CAT::vertexLabel-1-1 dgm nodeId)) 
                   (SPECCALC::|!return| dgm) 
                   (SPECCALC::raise 
                    (cons 
                     :|DiagError| 
                     (cons 
                      |!position| 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ "node " nodeId) 
                       " inconsistently labeled in diagram"))))) 
               (SPECCALC::|!return| 
                (CAT::labelVertex-1-1-1 
                 (CAT::addVertex-1-1 dgm nodeId) 
                 nodeId 
                 spc)))))))
                           
(defun SPECCALC::addLabelledVertex (x0 x1) 
  (SPECCALC::addLabelledVertex-1 (cons x0 x1)))
                                               
(defun SPECCALC::addLabelledVertex-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 x1) x2) x3) 
                    x4) 
           x5))
               
(defun SPECCALC::addOp (names) 
  (block 
   nil 
   (if (consp names) 
       (let ((pV4971 (car names))) 
         (if (eq (car pV4971) :|Qualified|) 
             (let ((pV4973 (cdr pV4971))) 
               (let ((pV4975 (cdr pV4973))
                     (pV4974 (car pV4973))) 
                 (return 
                  #'(lambda (new_fixity) 
                     #'(lambda (new_sort_scheme) 
                        #'(lambda (new_opt_def) 
                           #'(lambda (old_spec) 
                              #'(lambda (|!position|) 
                                 (let ((old_ops (svref old_spec 1))) 
                                   (let ((old_qmap 
                                          (let ((pV4952 
                                                 (STRINGMAP::|!find| 
                                                  old_ops 
                                                  pV4974))) 
                                            (block 
                                             nil 
                                             (if (eq (car pV4952) :|None|) 
                                                 (return STRINGMAP::empty) 
                                                 (if (eq (car pV4952) :|Some|) 
                                                     (return (cdr pV4952)))) 
                                             (error 
                                              "Nonexhaustive match failure in addOp"))))) 
                                     (SPECCALC::monadBind 
                                      (let ((pV4963 
                                             (STRINGMAP::|!find| old_qmap pV4975))) 
                                        (block 
                                         nil 
                                         (if (eq (car pV4963) :|None|) 
                                             (return 
                                              (SPECCALC::|!return| 
                                               (STRINGMAP::insert 
                                                old_qmap 
                                                pV4975 
                                                (vector 
                                                 names 
                                                 new_fixity 
                                                 new_sort_scheme 
                                                 new_opt_def)))) 
                                             (if (eq (car pV4963) :|Some|) 
                                                 (let ((pV4964 (cdr pV4963))) 
                                                   (let ((pV4968 
                                                          (svref pV4964 3))
                                                         (pV4965 
                                                          (svref pV4964 0))) 
                                                     (return 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car new_opt_def) 
                                                            :|None|) 
                                                           (if (eq 
                                                                (car pV4968) 
                                                                :|Some|) 
                                                               (return 
                                                                (SPECCALC::|!return| 
                                                                 (STRINGMAP::insert 
                                                                  old_qmap 
                                                                  pV4975 
                                                                  (vector 
                                                                   pV4965 
                                                                   new_fixity 
                                                                   new_sort_scheme 
                                                                   pV4968)))) 
                                                               (if (eq 
                                                                    (car pV4968) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (SPECCALC::raise 
                                                                     (cons 
                                                                      :|SpecError| 
                                                                      (cons 
                                                                       |!position| 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         "Operator " 
                                                                         pV4975) 
                                                                        " has been redeclared"))))))) 
                                                           (if (eq 
                                                                (car new_opt_def) 
                                                                :|Some|) 
                                                               (if (eq 
                                                                    (car pV4968) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (SPECCALC::|!return| 
                                                                     (STRINGMAP::insert 
                                                                      old_qmap 
                                                                      pV4975 
                                                                      (vector 
                                                                       pV4965 
                                                                       (svref 
                                                                        pV4964 
                                                                        1) 
                                                                       (svref 
                                                                        pV4964 
                                                                        2) 
                                                                       new_opt_def)))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV4968) 
                                                                        :|Some|) 
                                                                       (return 
                                                                        (SPECCALC::raise 
                                                                         (cons 
                                                                          :|SpecError| 
                                                                          (cons 
                                                                           |!position| 
                                                                           (STRING-SPEC::^ 
                                                                            (STRING-SPEC::^ 
                                                                             "Operator " 
                                                                             pV4975) 
                                                                            " has been redefined"))))))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in addOp"))))))) 
                                         (error 
                                          "Nonexhaustive match failure in addOp"))) 
                                      #'(lambda (new_qmap) 
                                         (let ((new_ops 
                                                (STRINGMAP::insert 
                                                 old_ops 
                                                 pV4974 
                                                 new_qmap))) 
                                           (let ((sp (setOps old_spec new_ops))) 
                                             (SPECCALC::|!return| 
                                              (LIST-SPEC::foldl-1-1-1 
                                               #'(lambda (x) 
                                                  (addLocalOpName 
                                                   (cdr x) 
                                                   (car x))) 
                                               sp 
                                               names))))))))))))))))))) 
   (error "Nonexhaustive match failure in addOp")))
                                                   
(defun SPECCALC::addOp-1-1-1-1-1-1-1 (x1 x2 x3 x4 x5 x6 x7) 
  (funcall (funcall (funcall (funcall (funcall (funcall (SPECCALC::addOp x1) x2) 
                                               x3) 
                                      x4) 
                             x5) 
                    x6) 
           x7))
               
(defun SPECCALC::addSort (names) 
  (block 
   nil 
   (if (consp names) 
       (let ((pV4995 (car names))) 
         (if (eq (car pV4995) :|Qualified|) 
             (let ((pV4997 (cdr pV4995))) 
               (let ((pV4999 (cdr pV4997))
                     (pV4998 (car pV4997))) 
                 (return 
                  #'(lambda (new_type_vars) 
                     #'(lambda (new_opt_def) 
                        #'(lambda (old_spec) 
                           #'(lambda (|!position|) 
                              (let ((old_sorts (svref old_spec 3))) 
                                (let ((old_qmap 
                                       (let ((pV4977 
                                              (STRINGMAP::|!find| 
                                               old_sorts 
                                               pV4998))) 
                                         (block 
                                          nil 
                                          (if (eq (car pV4977) :|None|) 
                                              (return STRINGMAP::empty) 
                                              (if (eq (car pV4977) :|Some|) 
                                                  (return (cdr pV4977)))) 
                                          (error 
                                           "Nonexhaustive match failure in addSort"))))) 
                                  (SPECCALC::monadBind 
                                   (let ((pV4988 
                                          (STRINGMAP::|!find| old_qmap pV4999))) 
                                     (block 
                                      nil 
                                      (if (eq (car pV4988) :|None|) 
                                          (return 
                                           (SPECCALC::|!return| 
                                            (STRINGMAP::insert 
                                             old_qmap 
                                             pV4999 
                                             (vector 
                                              names 
                                              new_type_vars 
                                              new_opt_def)))) 
                                          (if (eq (car pV4988) :|Some|) 
                                              (let ((pV4989 (cdr pV4988))) 
                                                (let ((pV4992 (svref pV4989 2))
                                                      (pV4991 (svref pV4989 1))) 
                                                  (return 
                                                   (block 
                                                    nil 
                                                    (if (eq 
                                                         (car new_opt_def) 
                                                         :|None|) 
                                                        (if (eq 
                                                             (car pV4992) 
                                                             :|None|) 
                                                            (return 
                                                             (SPECCALC::raise 
                                                              (cons 
                                                               :|SpecError| 
                                                               (cons 
                                                                |!position| 
                                                                (STRING-SPEC::^ 
                                                                 (STRING-SPEC::^ 
                                                                  "Sort " 
                                                                  pV4999) 
                                                                 " has been redeclared"))))) 
                                                            (if (eq 
                                                                 (car pV4992) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (if ( =  
                                                                      (LIST-SPEC::|!length| 
                                                                       new_type_vars) 
                                                                      (LIST-SPEC::|!length| 
                                                                       pV4991)) 
                                                                     (SPECCALC::|!return| 
                                                                      old_qmap) 
                                                                     (SPECCALC::raise 
                                                                      (cons 
                                                                       :|SpecError| 
                                                                       (cons 
                                                                        |!position| 
                                                                        (STRING-SPEC::^ 
                                                                         (STRING-SPEC::^ 
                                                                          "Sort " 
                                                                          pV4999) 
                                                                         " redefined using different type variable lists")))))))) 
                                                        (if (eq 
                                                             (car new_opt_def) 
                                                             :|Some|) 
                                                            (if (eq 
                                                                 (car pV4992) 
                                                                 :|None|) 
                                                                (return 
                                                                 (if ( =  
                                                                      (LIST-SPEC::|!length| 
                                                                       new_type_vars) 
                                                                      (LIST-SPEC::|!length| 
                                                                       pV4991)) 
                                                                     (SPECCALC::|!return| 
                                                                      (STRINGMAP::insert 
                                                                       old_qmap 
                                                                       pV4999 
                                                                       (vector 
                                                                        (svref 
                                                                         pV4989 
                                                                         0) 
                                                                        new_type_vars 
                                                                        new_opt_def))) 
                                                                     (SPECCALC::raise 
                                                                      (cons 
                                                                       :|SpecError| 
                                                                       (cons 
                                                                        |!position| 
                                                                        (STRING-SPEC::^ 
                                                                         (STRING-SPEC::^ 
                                                                          "Sort " 
                                                                          pV4999) 
                                                                         " redefined using different type variable lists")))))) 
                                                                (if (eq 
                                                                     (car pV4992) 
                                                                     :|Some|) 
                                                                    (return 
                                                                     (SPECCALC::raise 
                                                                      (cons 
                                                                       :|SpecError| 
                                                                       (cons 
                                                                        |!position| 
                                                                        (STRING-SPEC::^ 
                                                                         (STRING-SPEC::^ 
                                                                          "Sort " 
                                                                          pV4999) 
                                                                         " has been redefined"))))))))) 
                                                    (error 
                                                     "Nonexhaustive match failure in addSort"))))))) 
                                      (error 
                                       "Nonexhaustive match failure in addSort"))) 
                                   #'(lambda (new_qmap) 
                                      (let ((new_sorts 
                                             (STRINGMAP::insert 
                                              old_sorts 
                                              pV4998 
                                              new_qmap))) 
                                        (let ((sp (setSorts old_spec new_sorts))) 
                                          (SPECCALC::|!return| 
                                           (LIST-SPEC::foldl-1-1-1 
                                            #'(lambda (x) 
                                               (addLocalSortName (cdr x) (car x))) 
                                            sp 
                                            names)))))))))))))))))) 
   (error "Nonexhaustive match failure in addSort")))
                                                     
(defun SPECCALC::addSort-1-1-1-1-1-1 (x1 x2 x3 x4 x5 x6) 
  (funcall (funcall (funcall (funcall (funcall (SPECCALC::addSort x1) x2) x3) x4) 
                    x5) 
           x6))
               
(defun SPECCALC::foldM (f) 
  #'(lambda (a) 
     #'(lambda (l) 
        (block 
         nil 
         (if (null l) 
             (return (SPECCALC::|!return| a)) 
             (if (consp l) 
                 (let ((pV5538 (cdr l))) 
                   (return 
                    (SPECCALC::monadBind 
                     (funcall (funcall f a) (car l)) 
                     #'(lambda (y) 
                        (funcall (funcall (SPECCALC::foldM f) y) pV5538))))))) 
         (error "Nonexhaustive match failure in foldM")))))
                                                           
(defun SPECCALC::foldMapAp (abf) 
  #'(lambda (x) 
     (let ((b (cdr x))
           (sp (car x))) 
       (block 
        nil 
        (if (eq (car sp) :|SplayNil|) 
            (return (SPECCALC::|!return| b)) 
            (if (eq (car sp) :|SplayObj|) 
                (let ((pV5547 (cdr sp))) 
                  (let ((pV5550 (svref pV5547 2))
                        (pV5548 (svref pV5547 0))) 
                    (let ((pV5552 (cdr pV5550))
                          (pV5551 (car pV5550))) 
                      (return 
                       (SPECCALC::monadBind 
                        (funcall (SPECCALC::foldMapAp abf) 
                                 (cons (svref pV5547 1) b)) 
                        #'(lambda (rightResult) 
                           (SPECCALC::monadBind 
                            (funcall abf (vector pV5551 pV5552 rightResult)) 
                            #'(lambda (rootResult) 
                               (funcall (SPECCALC::foldMapAp abf) 
                                        (cons pV5548 rootResult)))))))))))) 
        (error "Nonexhaustive match failure in foldMapAp")))))
                                                              
(defun SPECCALC::foldMap (abf) 
  #'(lambda (b) 
     #'(lambda (|!map|) 
        (block 
         nil 
         (if (eq (car |!map|) :|EMPTY|) 
             (return (SPECCALC::|!return| b)) 
             (if (eq (car |!map|) :|MAP|) 
                 (return 
                  (funcall (SPECCALC::foldMapAp abf) 
                           (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
         (error "Nonexhaustive match failure in foldMap")))))
                                                             
(defun SPECCALC::foldDoubleMap (f) 
  #'(lambda (ob) 
     #'(lambda (omap) 
        (funcall (funcall (SPECCALC::foldMap 
                           #'(lambda (x) 
                              (let ((key1 (svref x 0))) 
                                (funcall (funcall (SPECCALC::foldMap 
                                                   #'(lambda (x1) 
                                                      (funcall f 
                                                               (vector 
                                                                key1 
                                                                (svref x1 0) 
                                                                (svref x1 1) 
                                                                (svref x1 2))))) 
                                                  (svref x 2)) 
                                         (svref x 1))))) 
                          ob) 
                 omap))))
                         
(defun SPECCALC::foldOverQualifierMap (x) (SPECCALC::foldDoubleMap x))
                                                                      
(defun SPECCALC::mergeOpInfo-1 (newPOpInfo) 
  #'(lambda (optOldPOpInfo) 
     #'(lambda (qualifier) 
        #'(lambda (id) 
           #'(lambda (|!position|) 
              (block 
               nil 
               (if (eq (car optOldPOpInfo) :|None|) 
                   (return (SPECCALC::|!return| newPOpInfo))) 
               (let ((pV5998 (svref newPOpInfo 3))
                     (pV5997 (svref newPOpInfo 2))
                     (pV5996 (svref newPOpInfo 1))) 
                 (if (eq (car optOldPOpInfo) :|Some|) 
                     (let ((pV5999 (cdr optOldPOpInfo))) 
                       (let ((pV6003 (svref pV5999 3))
                             (pV6002 (svref pV5999 2))) 
                         (return 
                          (if (BOOLEAN-SPEC::~ 
                               (slang-built-in::slang-term-equals 
                                pV5996 
                                (svref pV5999 1))) 
                              (SPECCALC::raise 
                               (cons 
                                :|SpecError| 
                                (cons 
                                 |!position| 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     "Merged versions of Op " 
                                     qualifier) 
                                    ".") 
                                   id) 
                                  " have different fixity")))) 
                              (if (BOOLEAN-SPEC::~ 
                                   (equalSortScheme? pV5997 pV6002)) 
                                  (SPECCALC::raise 
                                   (cons 
                                    :|SpecError| 
                                    (cons 
                                     |!position| 
                                     (STRING-SPEC::^ 
                                      (STRING-SPEC::^ 
                                       (STRING-SPEC::^ 
                                        (STRING-SPEC::^ 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ 
                                           (STRING-SPEC::^ 
                                            "Merged versions of Op " 
                                            qualifier) 
                                           ".") 
                                          id) 
                                         " have different sorts:
") 
                                        (ANNSPECPRINTER::printSortScheme-1 
                                         pV5997)) 
                                       "
") 
                                      (ANNSPECPRINTER::printSortScheme-1 pV6002))))) 
                                  (let ((op_names 
                                         (LISTUTILITIES::listUnion 
                                          (svref newPOpInfo 0) 
                                          (svref pV5999 0)))) 
                                    (block 
                                     nil 
                                     (if (eq (car pV5998) :|None|) 
                                         (if (eq (car pV6003) :|None|) 
                                             (return 
                                              (SPECCALC::|!return| 
                                               (vector 
                                                op_names 
                                                pV5996 
                                                pV5997 
                                                '(:|None|)))) 
                                             (if (eq (car pV6003) :|Some|) 
                                                 (return 
                                                  (SPECCALC::|!return| 
                                                   (vector 
                                                    op_names 
                                                    pV5996 
                                                    pV5997 
                                                    pV6003))))) 
                                         (if (eq (car pV5998) :|Some|) 
                                             (let ((pV5990 (cdr pV5998))) 
                                               (if (eq (car pV6003) :|None|) 
                                                   (return 
                                                    (SPECCALC::|!return| 
                                                     (vector 
                                                      op_names 
                                                      pV5996 
                                                      pV5997 
                                                      pV5998))) 
                                                   (if (eq (car pV6003) :|Some|) 
                                                       (let ((pV5991 
                                                              (cdr pV6003))) 
                                                         (return 
                                                          (if (METASLANG::equalTerm? 
                                                               pV5990 
                                                               pV5991) 
                                                              (SPECCALC::|!return| 
                                                               (vector 
                                                                op_names 
                                                                pV5996 
                                                                pV5997 
                                                                pV5998)) 
                                                              (SPECCALC::raise 
                                                               (cons 
                                                                :|SpecError| 
                                                                (cons 
                                                                 |!position| 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     (STRING-SPEC::^ 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        "Merged versions of Op " 
                                                                        qualifier) 
                                                                       ".") 
                                                                      id) 
                                                                     " have different definitions:
") 
                                                                    (ANNSPECPRINTER::printTerm 
                                                                     pV5990)) 
                                                                   "
") 
                                                                  (ANNSPECPRINTER::printTerm 
                                                                   pV5991))))))))))))) 
                                     (error 
                                      "Nonexhaustive match failure in mergeOpInfo")))))))))) 
               (error "Nonexhaustive match failure in mergeOpInfo")))))))
                                                                         
(defun SPECCALC::mergeSortInfo-1 (newPSortInfo) 
  #'(lambda (optOldPSortInfo) 
     #'(lambda (qualifier) 
        #'(lambda (id) 
           #'(lambda (|!position|) 
              (block 
               nil 
               (if (eq (car optOldPSortInfo) :|None|) 
                   (return (SPECCALC::|!return| newPSortInfo))) 
               (let ((pV6016 (svref newPSortInfo 2))
                     (pV6015 (svref newPSortInfo 1))) 
                 (if (eq (car optOldPSortInfo) :|Some|) 
                     (let ((pV6017 (cdr optOldPSortInfo))) 
                       (let ((pV6020 (svref pV6017 2))) 
                         (return 
                          (if (BOOLEAN-SPEC::~ 
                               ( =  
                                (LIST-SPEC::|!length| pV6015) 
                                (LIST-SPEC::|!length| (svref pV6017 1)))) 
                              (SPECCALC::raise 
                               (cons 
                                :|SpecError| 
                                (cons 
                                 |!position| 
                                 (STRING-SPEC::^ 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     "Merged versions of Sort " 
                                     qualifier) 
                                    ".") 
                                   id) 
                                  " have different type variable lists")))) 
                              (let ((sort_names 
                                     (LISTUTILITIES::listUnion 
                                      (svref newPSortInfo 0) 
                                      (svref pV6017 0)))) 
                                (block 
                                 nil 
                                 (if (eq (car pV6016) :|None|) 
                                     (if (eq (car pV6020) :|None|) 
                                         (return 
                                          (SPECCALC::|!return| 
                                           (vector sort_names pV6015 '(:|None|)))) 
                                         (if (eq (car pV6020) :|Some|) 
                                             (return 
                                              (SPECCALC::|!return| 
                                               (vector sort_names pV6015 pV6020))))) 
                                     (if (eq (car pV6016) :|Some|) 
                                         (let ((pV6009 (cdr pV6016))) 
                                           (if (eq (car pV6020) :|None|) 
                                               (return 
                                                (SPECCALC::|!return| 
                                                 (vector 
                                                  sort_names 
                                                  pV6015 
                                                  pV6016))) 
                                               (if (eq (car pV6020) :|Some|) 
                                                   (let ((pV6010 (cdr pV6020))) 
                                                     (return 
                                                      (if (METASLANG::equalSort? 
                                                           pV6009 
                                                           pV6010) 
                                                          (SPECCALC::|!return| 
                                                           (vector 
                                                            sort_names 
                                                            pV6015 
                                                            pV6016)) 
                                                          (SPECCALC::raise 
                                                           (cons 
                                                            :|SpecError| 
                                                            (cons 
                                                             |!position| 
                                                             (STRING-SPEC::^ 
                                                              (STRING-SPEC::^ 
                                                               (STRING-SPEC::^ 
                                                                (STRING-SPEC::^ 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    "Merged versions of Sort " 
                                                                    qualifier) 
                                                                   ".") 
                                                                  id) 
                                                                 " have different definitions:
") 
                                                                (ANNSPECPRINTER::printSort 
                                                                 pV6009)) 
                                                               "
") 
                                                              (ANNSPECPRINTER::printSort 
                                                               pV6010))))))))))))) 
                                 (error 
                                  "Nonexhaustive match failure in mergeSortInfo"))))))))) 
               (error "Nonexhaustive match failure in mergeSortInfo")))))))
                                                                           
(defun SPECCALC::auxTranslateSpec-1 (spc) 
  #'(lambda (x) 
     (let ((sort_id_map (cdr x))
           (op_id_map (car x))) 
       #'(lambda (|!position|) 
          (labels 
            ((translateSortMap (old_sorts) 
              (labels 
                ((translateStep (pV5101 pV5102 pV5103 pV5104) 
                  (block 
                   nil 
                   (let ((pV5105 (svref pV5103 0))) 
                     (if (consp pV5105) 
                         (let ((pV5109 (car pV5105))) 
                           (if (eq (car pV5109) :|Qualified|) 
                               (let ((pV5111 (cdr pV5109))) 
                                 (return 
                                  (if (BOOLEAN-SPEC::~ 
                                       (lisp::and 
                                        (string=  pV5101 (car pV5111)) 
                                        (string=  pV5102 (cdr pV5111)))) 
                                      (SPECCALC::|!return| pV5104) 
                                      (let ((new_aliases 
                                             (LIST-SPEC::rev 
                                              (LIST-SPEC::foldl-1-1-1 
                                               #'(lambda (x1) 
                                                  (let ((new_aliases (cdr x1))) 
                                                    (LIST-SPEC::foldl-1-1-1 
                                                     #'(lambda (x11) 
                                                        (let ((new_aliases 
                                                               (cdr x11))
                                                              (new_alias 
                                                               (car x11))) 
                                                          (if (LIST-SPEC::|!member| 
                                                               new_alias 
                                                               new_aliases) 
                                                              new_aliases 
                                                              (cons 
                                                               new_alias 
                                                               new_aliases)))) 
                                                     new_aliases 
                                                     (translateSortQualifiedIdToAliases 
                                                      (car x1))))) 
                                               nil 
                                               pV5105)))) 
                                        (SPECCALC::monadBind 
                                         (SPECCALC::|!return| 
                                          (vector 
                                           new_aliases 
                                           (svref pV5103 1) 
                                           (svref pV5103 2))) 
                                         #'(lambda (first_sortinfo) 
                                            (SPECCALC::monadBind 
                                             (funcall (funcall (SPECCALC::foldM 
                                                                #'(lambda (merged_sortinfo) 
                                                                   #'(lambda (new_alias) 
                                                                      (block 
                                                                       nil 
                                                                       (if (eq 
                                                                            (car 
                                                                             new_alias) 
                                                                            :|Qualified|) 
                                                                           (let ((pV5094 
                                                                                  (cdr 
                                                                                   new_alias))) 
                                                                             (let ((pV5096 
                                                                                    (cdr 
                                                                                     pV5094))
                                                                                   (pV5095 
                                                                                    (car 
                                                                                     pV5094))) 
                                                                               (return 
                                                                                (funcall (funcall (funcall (funcall (SPECCALC::mergeSortInfo-1 
                                                                                                                     merged_sortinfo) 
                                                                                                                    (findAQualifierMap 
                                                                                                                     pV5104 
                                                                                                                     pV5095 
                                                                                                                     pV5096)) 
                                                                                                           pV5095) 
                                                                                                  pV5096) 
                                                                                         |!position|))))) 
                                                                       (error 
                                                                        "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                               first_sortinfo) 
                                                      new_aliases) 
                                             #'(lambda (merged_sortinfo) 
                                                (funcall (funcall (SPECCALC::foldM 
                                                                   #'(lambda (new_sort_map) 
                                                                      #'(lambda (pV5097) 
                                                                         (block 
                                                                          nil 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV5097) 
                                                                               :|Qualified|) 
                                                                              (let ((pV5098 
                                                                                     (cdr 
                                                                                      pV5097))) 
                                                                                (return 
                                                                                 (SPECCALC::|!return| 
                                                                                  (insertAQualifierMap 
                                                                                   new_sort_map 
                                                                                   (car 
                                                                                    pV5098) 
                                                                                   (cdr 
                                                                                    pV5098) 
                                                                                   merged_sortinfo))))) 
                                                                          (error 
                                                                           "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                                  pV5104) 
                                                         new_aliases))))))))))))) 
                   (error "Nonexhaustive match failure in auxTranslateSpec")))) 
                (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                   #'(lambda (x1) 
                                      (translateStep 
                                       (svref x1 0) 
                                       (svref x1 1) 
                                       (svref x1 2) 
                                       (svref x1 3)))) 
                                  emptyAQualifierMap) 
                         old_sorts)))
             (translateOpMap (old_ops) 
              (labels 
                ((translateStep (pV5078 pV5079 pV5080 pV5081) 
                  (block 
                   nil 
                   (let ((pV5082 (svref pV5080 0))) 
                     (if (consp pV5082) 
                         (let ((pV5087 (car pV5082))) 
                           (if (eq (car pV5087) :|Qualified|) 
                               (let ((pV5089 (cdr pV5087))) 
                                 (return 
                                  (if (BOOLEAN-SPEC::~ 
                                       (lisp::and 
                                        (string=  pV5078 (car pV5089)) 
                                        (string=  pV5079 (cdr pV5089)))) 
                                      (SPECCALC::|!return| pV5081) 
                                      (let ((new_aliases 
                                             (LIST-SPEC::rev 
                                              (LIST-SPEC::foldl-1-1-1 
                                               #'(lambda (x1) 
                                                  (let ((new_aliases (cdr x1))) 
                                                    (LIST-SPEC::foldl-1-1-1 
                                                     #'(lambda (x11) 
                                                        (let ((new_aliases 
                                                               (cdr x11))
                                                              (new_alias 
                                                               (car x11))) 
                                                          (if (LIST-SPEC::|!member| 
                                                               new_alias 
                                                               new_aliases) 
                                                              new_aliases 
                                                              (cons 
                                                               new_alias 
                                                               new_aliases)))) 
                                                     new_aliases 
                                                     (translateOpQualifiedIdToAliases 
                                                      (car x1))))) 
                                               nil 
                                               pV5082)))) 
                                        (SPECCALC::monadBind 
                                         (SPECCALC::|!return| 
                                          (vector 
                                           new_aliases 
                                           (svref pV5080 1) 
                                           (svref pV5080 2) 
                                           (svref pV5080 3))) 
                                         #'(lambda (first_opinfo) 
                                            (SPECCALC::monadBind 
                                             (funcall (funcall (SPECCALC::foldM 
                                                                #'(lambda (merged_opinfo) 
                                                                   #'(lambda (new_alias) 
                                                                      (block 
                                                                       nil 
                                                                       (if (eq 
                                                                            (car 
                                                                             new_alias) 
                                                                            :|Qualified|) 
                                                                           (let ((pV5071 
                                                                                  (cdr 
                                                                                   new_alias))) 
                                                                             (let ((pV5073 
                                                                                    (cdr 
                                                                                     pV5071))
                                                                                   (pV5072 
                                                                                    (car 
                                                                                     pV5071))) 
                                                                               (return 
                                                                                (funcall (funcall (funcall (funcall (SPECCALC::mergeOpInfo-1 
                                                                                                                     merged_opinfo) 
                                                                                                                    (findAQualifierMap 
                                                                                                                     pV5081 
                                                                                                                     pV5072 
                                                                                                                     pV5073)) 
                                                                                                           pV5072) 
                                                                                                  pV5073) 
                                                                                         |!position|))))) 
                                                                       (error 
                                                                        "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                               first_opinfo) 
                                                      new_aliases) 
                                             #'(lambda (merged_opinfo) 
                                                (funcall (funcall (SPECCALC::foldM 
                                                                   #'(lambda (new_op_map) 
                                                                      #'(lambda (pV5074) 
                                                                         (block 
                                                                          nil 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV5074) 
                                                                               :|Qualified|) 
                                                                              (let ((pV5075 
                                                                                     (cdr 
                                                                                      pV5074))) 
                                                                                (return 
                                                                                 (SPECCALC::|!return| 
                                                                                  (insertAQualifierMap 
                                                                                   new_op_map 
                                                                                   (car 
                                                                                    pV5075) 
                                                                                   (cdr 
                                                                                    pV5075) 
                                                                                   merged_opinfo))))) 
                                                                          (error 
                                                                           "Nonexhaustive match failure in auxTranslateSpec"))))) 
                                                                  pV5081) 
                                                         new_aliases))))))))))))) 
                   (error "Nonexhaustive match failure in auxTranslateSpec")))) 
                (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                   #'(lambda (x1) 
                                      (translateStep 
                                       (svref x1 0) 
                                       (svref x1 1) 
                                       (svref x1 2) 
                                       (svref x1 3)))) 
                                  emptyAQualifierMap) 
                         old_ops)))
             (translatePattern (pat) pat)
             (translateSort (sort_term) 
              (block 
               nil 
               (if (eq (car sort_term) :|Base|) 
                   (let ((pV5065 (cdr sort_term))) 
                     (let ((pV5066 (svref pV5065 0))) 
                       (return 
                        (let ((new_qid (translateSortQualifiedId pV5066))) 
                          (if (slang-built-in::slang-term-equals new_qid pV5066) 
                              sort_term 
                              (cons 
                               :|Base| 
                               (vector new_qid (svref pV5065 1) (svref pV5065 2))))))))) 
               (return sort_term)))
             (translateOp (op_term) 
              (block 
               nil 
               (if (eq (car op_term) :|Fun|) 
                   (let ((pV5056 (cdr op_term))) 
                     (let ((pV5057 (svref pV5056 0))) 
                       (if (eq (car pV5057) :|Op|) 
                           (let ((pV5060 (cdr pV5057))) 
                             (let ((pV5061 (car pV5060))) 
                               (return 
                                (let ((new_qid (translateOpQualifiedId pV5061))) 
                                  (if (slang-built-in::slang-term-equals 
                                       new_qid 
                                       pV5061) 
                                      op_term 
                                      (cons 
                                       :|Fun| 
                                       (vector 
                                        (cons :|Op| (cons new_qid (cdr pV5060))) 
                                        (svref pV5056 1) 
                                        (svref pV5056 2)))))))))))) 
               (return op_term)))
             (translateSortQualifiedIdToAliases (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV5051 (cdr qid))) 
                     (return 
                      (let ((pV5046 
                             (findAQualifierMap 
                              sort_id_map 
                              (car pV5051) 
                              (cdr pV5051)))) 
                        (block 
                         nil 
                         (if (eq (car pV5046) :|Some|) 
                             (return (cdr (cdr pV5046))) 
                             (if (eq (car pV5046) :|None|) 
                                 (return (cons qid nil)))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))
             (translateOpQualifiedIdToAliases (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV5042 (cdr qid))) 
                     (return 
                      (let ((pV5037 
                             (findAQualifierMap 
                              op_id_map 
                              (car pV5042) 
                              (cdr pV5042)))) 
                        (block 
                         nil 
                         (if (eq (car pV5037) :|Some|) 
                             (return (cdr (cdr pV5037))) 
                             (if (eq (car pV5037) :|None|) 
                                 (return (cons qid nil)))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))
             (translateSortQualifiedId (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV5033 (cdr qid))) 
                     (return 
                      (let ((pV5028 
                             (findAQualifierMap 
                              sort_id_map 
                              (car pV5033) 
                              (cdr pV5033)))) 
                        (block 
                         nil 
                         (if (eq (car pV5028) :|Some|) 
                             (return (car (cdr pV5028))) 
                             (if (eq (car pV5028) :|None|) (return qid))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))
             (translateOpQualifiedId (qid) 
              (block 
               nil 
               (if (eq (car qid) :|Qualified|) 
                   (let ((pV5024 (cdr qid))) 
                     (return 
                      (let ((pV5019 
                             (findAQualifierMap 
                              op_id_map 
                              (car pV5024) 
                              (cdr pV5024)))) 
                        (block 
                         nil 
                         (if (eq (car pV5019) :|Some|) 
                             (return (car (cdr pV5019))) 
                             (if (eq (car pV5019) :|None|) (return qid))) 
                         (error 
                          "Nonexhaustive match failure in auxTranslateSpec")))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec")))) 
            (let ((pV5114 
                   (mapSpec-1-1 
                    (vector #'translateOp #'translateSort #'translatePattern) 
                    spc))) 
              (block 
               nil 
               (let ((pV5117 (svref pV5114 2))
                     (pV5116 (svref pV5114 1))
                     (pV5115 (svref pV5114 0))) 
                 (let ((pV5122 (svref pV5115 3))
                       (pV5121 (svref pV5115 2))) 
                   (return 
                    (SPECCALC::monadBind 
                     (translateSortMap (svref pV5114 3)) 
                     #'(lambda (newSorts) 
                        (SPECCALC::monadBind 
                         (translateOpMap pV5116) 
                         #'(lambda (newOps) 
                            (SPECCALC::|!return| 
                             (vector 
                              (vector 
                               '(:|None|) 
                               nil 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateOpQualifiedId 
                                pV5121) 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateSortQualifiedId 
                                pV5122)) 
                              newOps 
                              pV5117 
                              newSorts))))))))) 
               (error "Nonexhaustive match failure in auxTranslateSpec"))))))))
                                                                               
(defun SPECCALC::opMap-1 (morph) (svref morph 2))
                                                 
(defun SPECCALC::sortMap-1 (morph) (svref morph 3))
                                                   
(defun SPECCALC::applyMorphism-1 (sm) 
  #'(lambda (spc) 
     #'(lambda (|!position|) 
        (let ((op_id_map 
               (POLYMAP::foldMap-1-1-1 
                #'(lambda (op_id_map) 
                   #'(lambda (pV5000) 
                      (block 
                       nil 
                       (if (eq (car pV5000) :|Qualified|) 
                           (let ((pV5001 (cdr pV5000))) 
                             (let ((pV5003 (cdr pV5001))
                                   (pV5002 (car pV5001))) 
                               (return 
                                #'(lambda (cod_qid) 
                                   (insertAQualifierMap 
                                    op_id_map 
                                    pV5002 
                                    pV5003 
                                    (cons cod_qid (cons cod_qid nil)))))))) 
                       (error "Nonexhaustive match failure in applyMorphism")))) 
                emptyAQualifierMap 
                (SPECCALC::opMap-1 sm)))) 
          (let ((sort_id_map 
                 (POLYMAP::foldMap-1-1-1 
                  #'(lambda (sort_id_map) 
                     #'(lambda (pV5004) 
                        (block 
                         nil 
                         (if (eq (car pV5004) :|Qualified|) 
                             (let ((pV5005 (cdr pV5004))) 
                               (let ((pV5007 (cdr pV5005))
                                     (pV5006 (car pV5005))) 
                                 (return 
                                  #'(lambda (cod_qid) 
                                     (insertAQualifierMap 
                                      sort_id_map 
                                      pV5006 
                                      pV5007 
                                      (cons cod_qid (cons cod_qid nil)))))))) 
                         (error "Nonexhaustive match failure in applyMorphism")))) 
                  emptyAQualifierMap 
                  (SPECCALC::sortMap-1 sm)))) 
            (funcall (funcall (SPECCALC::auxTranslateSpec-1 spc) 
                              (cons op_id_map sort_id_map)) 
                     |!position|))))))
                                      
(defun SPECCALC::applyMorphism (x0 x1 x2 x3) 
  (SPECCALC::applyMorphism-1 (vector x0 x1 x2 x3)))
                                                   
(defun SPECCALC::applyMorphism-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::applyMorphism-1 x1) x2) x3) x4))
                                                                        
(defun SPECCALC::cod-1 (morph) (svref morph 0))
                                               
(defun SPECCALC::dom-1 (morph) (svref morph 1))
                                               
(defun SPECCALC::ppDecls (decls) 
  (labels 
    ((ppDecl (name term) 
      (WADLERLINDIG::ppConcat 
       (cons 
        (WADLERLINDIG::ppString name) 
        (cons 
         (WADLERLINDIG::ppString " = ") 
         (cons (SPECCALC::ppTerm-1 term) nil)))))) 
    (WADLERLINDIG::ppSep-1-1 
     WADLERLINDIG::ppNewline 
     (LIST-SPEC::|!map|-1-1 #'(lambda (x) (ppDecl (car x) (cdr x))) decls))))
                                                                             
(defun SPECCALC::ppDiagElem (elem pV6553) 
  (declare (ignore pV6553)) 
  (block 
   nil 
   (if (eq (car elem) :|Node|) 
       (let ((pV6556 (cdr elem))) 
         (return 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString (car pV6556)) 
            (cons 
             (WADLERLINDIG::ppString " |-> ") 
             (cons (SPECCALC::ppTerm-1 (cdr pV6556)) nil)))))) 
       (if (eq (car elem) :|Edge|) 
           (let ((pV6555 (cdr elem))) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons 
                (WADLERLINDIG::ppString (svref pV6555 0)) 
                (cons 
                 (WADLERLINDIG::ppString " : ") 
                 (cons 
                  (WADLERLINDIG::ppString (svref pV6555 1)) 
                  (cons 
                   (WADLERLINDIG::ppString " -> ") 
                   (cons 
                    (WADLERLINDIG::ppString (svref pV6555 2)) 
                    (cons 
                     (WADLERLINDIG::ppString " |-> ") 
                     (cons (SPECCALC::ppTerm-1 (svref pV6555 3)) nil)))))))))))) 
   (error "Nonexhaustive match failure in ppDiagElem")))
                                                        
(defun SPECCALC::ppDiagElem-1 (x) (SPECCALC::ppDiagElem (car x) (cdr x)))
                                                                         
(defun SPECCALC::ppQualifier (pV6585) 
  (block 
   nil 
   (if (eq (car pV6585) :|Qualified|) 
       (let ((pV6586 (cdr pV6585))) 
         (let ((pV6588 (cdr pV6586))
               (pV6587 (car pV6586))) 
           (return 
            (if (string=  pV6587 METASLANG::UnQualified) 
                (WADLERLINDIG::ppString pV6588) 
                (WADLERLINDIG::ppString 
                 (STRING-SPEC::^ (STRING-SPEC::^ pV6587 ".") pV6588))))))) 
   (error "Nonexhaustive match failure in ppQualifier")))
                                                         
(defun SPECCALC::isFiniteList (term) 
  (block 
   nil 
   (if (eq (car term) :|Fun|) 
       (let ((pV5655 (svref (cdr term) 0))) 
         (if (eq (car pV5655) :|Embed|) 
             (let ((pV5658 (cdr pV5655))) 
               (if (string=  "Nil" (car pV5658)) 
                   (if (eq nil (cdr pV5658)) (return (cons :|Some| nil))))))) 
       (if (eq (car term) :|Apply|) 
           (let ((pV5630 (cdr term))) 
             (let ((pV5633 (svref pV5630 1))
                   (pV5632 (svref pV5630 0))) 
               (if (eq (car pV5632) :|Fun|) 
                   (let ((pV5636 (svref (cdr pV5632) 0))) 
                     (if (eq (car pV5636) :|Embed|) 
                         (let ((pV5639 (cdr pV5636))) 
                           (if (string=  "Cons" (car pV5639)) 
                               (if (eq t (cdr pV5639)) 
                                   (if (eq (car pV5633) :|Record|) 
                                       (let ((pV5643 (car (cdr pV5633)))) 
                                         (if (consp pV5643) 
                                             (let ((pV5647 (cdr pV5643))) 
                                               (let ((pV5649 (cdr (car pV5643)))) 
                                                 (if (consp pV5647) 
                                                     (let ((pV5654 
                                                            (cdr (car pV5647)))) 
                                                       (if (null (cdr pV5647)) 
                                                           (progn (return 
                                                                   (let ((pV5618 
                                                                          (SPECCALC::isFiniteList 
                                                                           pV5654))) 
                                                                     (block 
                                                                      nil 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV5618) 
                                                                           :|Some|) 
                                                                          (return 
                                                                           (cons 
                                                                            :|Some| 
                                                                            (cons 
                                                                             pV5649 
                                                                             (cdr 
                                                                              pV5618)))) 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV5618) 
                                                                               :|None|) 
                                                                              (return 
                                                                               '(:|None|)))) 
                                                                      (error 
                                                                       "Nonexhaustive match failure in isFiniteList")))) 
                                                                  (return 
                                                                   (let ((pV5626 
                                                                          (SPECCALC::isFiniteList 
                                                                           pV5654))) 
                                                                     (block 
                                                                      nil 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV5626) 
                                                                           :|Some|) 
                                                                          (return 
                                                                           (cons 
                                                                            :|Some| 
                                                                            (cons 
                                                                             pV5649 
                                                                             (cdr 
                                                                              pV5626)))) 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV5626) 
                                                                               :|None|) 
                                                                              (return 
                                                                               '(:|None|)))) 
                                                                      (error 
                                                                       "Nonexhaustive match failure in isFiniteList"))))))))))))))))))))))) 
   (return '(:|None|))))
                        
(defun SPECCALC::isSimpleTerm? (trm) 
  (block 
   nil 
   (if (eq (car trm) :|Var|) (return t) (if (eq (car trm) :|Fun|) (return t))) 
   (return nil)))
                 
(defun SPECCALC::ppBoolean (b) 
  (block 
   nil 
   (if (eq t b) 
       (return (WADLERLINDIG::ppString "true")) 
       (if (eq nil b) (return (WADLERLINDIG::ppString "false")))) 
   (error "Nonexhaustive match failure in ppBoolean")))
                                                       
(defun SPECCALC::ppFixity (fix) 
  (block 
   nil 
   (if (consp fix) 
       (let ((pV6566 (cdr fix))
             (pV6565 (car fix))) 
         (if (eq (car pV6565) :|Left|) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons 
                (WADLERLINDIG::ppString "infixl ") 
                (cons (WADLERLINDIG::ppString (NAT-SPEC::toString pV6566)) nil)))) 
             (if (eq (car pV6565) :|Right|) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString "infixr ") 
                    (cons 
                     (WADLERLINDIG::ppString (NAT-SPEC::toString pV6566)) 
                     nil))))))) 
       (if (null fix) (return WADLERLINDIG::ppNil))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "No match in ppFixity with: '" (SYSTEM-SPEC::toString fix)) 
      "'")))))
              
(defun WADLERLINDIG::ppGroup (d) (cons :|DocGroup| d))
                                                      
(defun SPECCALC::ppGrConcat (x) 
  (WADLERLINDIG::ppGroup (WADLERLINDIG::ppConcat x)))
                                                     
(defparameter SPECCALC::omittedQualifiers 
  (cons 
   "Boolean" 
   (cons 
    "Integer" 
    (cons "Nat" (cons "Double" (cons "List" (cons "String" (cons "Char" nil))))))))


(defun SPECCALC::ppQualifiedId (pV6581) 
  (block 
   nil 
   (if (eq (car pV6581) :|Qualified|) 
       (let ((pV6582 (cdr pV6581))) 
         (let ((pV6584 (cdr pV6582))
               (pV6583 (car pV6582))) 
           (return 
            (if (lisp::or 
                 (string=  pV6583 METASLANG::UnQualified) 
                 (LIST-SPEC::|!member| pV6583 SPECCALC::omittedQualifiers)) 
                (WADLERLINDIG::ppString pV6584) 
                (WADLERLINDIG::ppString 
                 (STRING-SPEC::^ (STRING-SPEC::^ pV6583 ".") pV6584))))))) 
   (error "Nonexhaustive match failure in ppQualifiedId")))
                                                           
(defun SPECCALC::ppAFun (fun) 
  (block 
   nil 
   (if (eq (car fun) :|Equals|) 
       (return (WADLERLINDIG::ppString "=")) 
       (if (eq (car fun) :|Quotient|) 
           (return (WADLERLINDIG::ppString "quotient")) 
           (if (eq (car fun) :|Choose|) 
               (return (WADLERLINDIG::ppString "choose")) 
               (if (eq (car fun) :|Restrict|) 
                   (return (WADLERLINDIG::ppString "restrict")) 
                   (if (eq (car fun) :|Relax|) 
                       (return (WADLERLINDIG::ppString "relax")) 
                       (if (eq (car fun) :|Op|) 
                           (let ((pV6256 (cdr fun))) 
                             (let ((pV6265 (cdr pV6256))
                                   (pV6264 (car pV6256))) 
                               (progn (if (null pV6265) 
                                          (return 
                                           (SPECCALC::ppQualifiedId pV6264))) 
                                      (return 
                                       (SPECCALC::ppGrConcat 
                                        (cons 
                                         (WADLERLINDIG::ppString "(") 
                                         (cons 
                                          (SPECCALC::ppQualifiedId pV6264) 
                                          (cons 
                                           (WADLERLINDIG::ppString ",") 
                                           (cons 
                                            (SPECCALC::ppFixity pV6265) 
                                            (cons 
                                             (WADLERLINDIG::ppString ")") 
                                             nil)))))))))) 
                           (if (eq (car fun) :|Project|) 
                               (return 
                                (WADLERLINDIG::ppConcat 
                                 (cons 
                                  (WADLERLINDIG::ppString "project ") 
                                  (cons (WADLERLINDIG::ppString (cdr fun)) nil)))) 
                               (if (eq (car fun) :|Embed|) 
                                   (return 
                                    (WADLERLINDIG::ppString (car (cdr fun)))) 
                                   (if (eq (car fun) :|Embedded|) 
                                       (return 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (WADLERLINDIG::ppString "embedded ") 
                                          (cons 
                                           (WADLERLINDIG::ppString (cdr fun)) 
                                           nil)))) 
                                       (if (eq (car fun) :|Select|) 
                                           (return 
                                            (WADLERLINDIG::ppConcat 
                                             (cons 
                                              (WADLERLINDIG::ppString "select ") 
                                              (cons 
                                               (WADLERLINDIG::ppString (cdr fun)) 
                                               nil)))) 
                                           (if (eq (car fun) :|Nat|) 
                                               (return 
                                                (WADLERLINDIG::ppString 
                                                 (NAT-SPEC::toString (cdr fun)))) 
                                               (if (eq (car fun) :|Char|) 
                                                   (return 
                                                    (WADLERLINDIG::ppString 
                                                     (CHAR-SPEC::toString 
                                                      (cdr fun)))) 
                                                   (if (eq (car fun) :|String|) 
                                                       (return 
                                                        (WADLERLINDIG::ppString 
                                                         (cdr fun))) 
                                                       (if (eq (car fun) :|Bool|) 
                                                           (return 
                                                            (SPECCALC::ppBoolean 
                                                             (cdr fun))) 
                                                           (if (eq 
                                                                (car fun) 
                                                                :|OneName|) 
                                                               (return 
                                                                (WADLERLINDIG::ppString 
                                                                 (car (cdr fun)))) 
                                                               (if (eq 
                                                                    (car fun) 
                                                                    :|TwoNames|) 
                                                                   (let ((pV6246 
                                                                          (cdr 
                                                                           fun))) 
                                                                     (return 
                                                                      (SPECCALC::ppQualifiedId 
                                                                       (cons 
                                                                        :|Qualified| 
                                                                        (cons 
                                                                         (svref 
                                                                          pV6246 
                                                                          0) 
                                                                         (svref 
                                                                          pV6246 
                                                                          1)))))))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "No match in ppAFun with: '" (SYSTEM-SPEC::toString fun)) 
      "'")))))
              
(defun SPECCALC::ppAVarWithoutSort (id pV6549) 
  (declare (ignore pV6549)) 
  (WADLERLINDIG::ppString id))
                              
(defun SPECCALC::ppAVarWithoutSort-1 (x) 
  (SPECCALC::ppAVarWithoutSort (car x) (cdr x)))
                                                
(defun SPECCALC::ppAPattern (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|AliasPat|) 
       (let ((pV6310 (cdr pattern))) 
         (return 
          (SPECCALC::ppGrConcat 
           (cons 
            (SPECCALC::ppAPattern (svref pV6310 0)) 
            (cons 
             (WADLERLINDIG::ppString " as ") 
             (cons (SPECCALC::ppAPattern (svref pV6310 1)) nil)))))) 
       (if (eq (car pattern) :|VarPat|) 
           (return (SPECCALC::ppAVarWithoutSort-1 (car (cdr pattern)))) 
           (if (eq (car pattern) :|EmbedPat|) 
               (let ((pV6308 (cdr pattern))) 
                 (let ((pV6330 (svref pV6308 1))) 
                   (return 
                    (SPECCALC::ppGrConcat 
                     (cons 
                      (WADLERLINDIG::ppString (svref pV6308 0)) 
                      (cons 
                       (block 
                        nil 
                        (if (eq (car pV6330) :|None|) 
                            (return WADLERLINDIG::ppNil) 
                            (if (eq (car pV6330) :|Some|) 
                                (return 
                                 (WADLERLINDIG::ppAppend-1-1 
                                  (WADLERLINDIG::ppString " ") 
                                  (SPECCALC::ppAPattern (cdr pV6330)))))) 
                        (error "Nonexhaustive match failure in ppAPattern")) 
                       nil)))))) 
               (if (eq (car pattern) :|RecordPat|) 
                   (let ((pV6327 (car (cdr pattern)))) 
                     (return 
                      (block 
                       nil 
                       (if (null pV6327) 
                           (return (WADLERLINDIG::ppString "()")) 
                           (if (consp pV6327) 
                               (if (string=  "1" (car (car pV6327))) 
                                   (return 
                                    (labels 
                                      ((ppField (pV6284 pat) 
                                        (declare (ignore pV6284)) 
                                        (SPECCALC::ppAPattern pat))) 
                                      (WADLERLINDIG::ppConcat 
                                       (cons 
                                        (WADLERLINDIG::ppString "(") 
                                        (cons 
                                         (WADLERLINDIG::ppSep-1-1 
                                          (WADLERLINDIG::ppString ",") 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x) 
                                              (ppField (car x) (cdr x))) 
                                           pV6327)) 
                                         (cons (WADLERLINDIG::ppString ")") nil))))))))) 
                       (return 
                        (labels 
                          ((ppField (x pat) 
                            (WADLERLINDIG::ppConcat 
                             (cons 
                              (WADLERLINDIG::ppString x) 
                              (cons 
                               (WADLERLINDIG::ppString "=") 
                               (cons (SPECCALC::ppAPattern pat) nil)))))) 
                          (WADLERLINDIG::ppConcat 
                           (cons 
                            (WADLERLINDIG::ppString "{") 
                            (cons 
                             (WADLERLINDIG::ppSep-1-1 
                              (WADLERLINDIG::ppString ",") 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x) (ppField (car x) (cdr x))) 
                               pV6327)) 
                             (cons (WADLERLINDIG::ppString "}") nil))))))))) 
                   (if (eq (car pattern) :|WildPat|) 
                       (return (WADLERLINDIG::ppString "_")) 
                       (if (eq (car pattern) :|StringPat|) 
                           (return (WADLERLINDIG::ppString (car (cdr pattern)))) 
                           (if (eq (car pattern) :|BoolPat|) 
                               (return (SPECCALC::ppBoolean (car (cdr pattern)))) 
                               (if (eq (car pattern) :|CharPat|) 
                                   (return 
                                    (WADLERLINDIG::ppString 
                                     (CHAR-SPEC::toString (car (cdr pattern))))) 
                                   (if (eq (car pattern) :|NatPat|) 
                                       (return 
                                        (WADLERLINDIG::ppString 
                                         (NAT-SPEC::toString (car (cdr pattern))))) 
                                       (if (eq (car pattern) :|RelaxPat|) 
                                           (let ((pV6301 (cdr pattern))) 
                                             (return 
                                              (SPECCALC::ppGrConcat 
                                               (cons 
                                                (WADLERLINDIG::ppString 
                                                 "(relax ") 
                                                (cons 
                                                 (SPECCALC::ppAPattern 
                                                  (svref pV6301 0)) 
                                                 (cons 
                                                  (WADLERLINDIG::ppString " ") 
                                                  (cons 
                                                   (SPECCALC::ppATerm 
                                                    (svref pV6301 1)) 
                                                   (cons 
                                                    (WADLERLINDIG::ppString ")") 
                                                    nil)))))))) 
                                           (if (eq (car pattern) :|QuotientPat|) 
                                               (let ((pV6300 (cdr pattern))) 
                                                 (return 
                                                  (SPECCALC::ppGrConcat 
                                                   (cons 
                                                    (WADLERLINDIG::ppString 
                                                     "(quotient ") 
                                                    (cons 
                                                     (SPECCALC::ppAPattern 
                                                      (svref pV6300 0)) 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       " ") 
                                                      (cons 
                                                       (SPECCALC::ppATerm 
                                                        (svref pV6300 1)) 
                                                       (cons 
                                                        (WADLERLINDIG::ppString 
                                                         ")") 
                                                        nil))))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       "No match in ppAPattern with: '" 
       (SYSTEM-SPEC::toString pattern)) 
      "'")))))
              
(defun SPECCALC::ppAMatch (cases) 
  (labels 
    ((ppCase (pattern pV6266 term) 
      (declare (ignore pV6266)) 
      (SPECCALC::ppGrConcat 
       (cons 
        (WADLERLINDIG::ppString "| ") 
        (cons 
         (SPECCALC::ppAPattern pattern) 
         (cons 
          (WADLERLINDIG::ppString " -> ") 
          (cons (SPECCALC::ppATerm term) nil))))))) 
    (WADLERLINDIG::ppGroup 
     (WADLERLINDIG::ppSep-1-1 
      WADLERLINDIG::ppNewline 
      (LIST-SPEC::|!map|-1-1 
       #'(lambda (x) (ppCase (svref x 0) (svref x 1) (svref x 2))) 
       cases)))))
                 
(defun SPECCALC::ppBinder (binder) 
  (block 
   nil 
   (if (eq (car binder) :|Forall|) 
       (return (WADLERLINDIG::ppString "fa")) 
       (if (eq (car binder) :|Exists|) (return (WADLERLINDIG::ppString "ex")))) 
   (error "Nonexhaustive match failure in ppBinder")))
                                                      
(defun SPECCALC::ppATerm (term) 
  (let ((pV6547 (SPECCALC::isFiniteList term))) 
    (block 
     nil 
     (if (eq (car pV6547) :|Some|) 
         (return 
          (SPECCALC::ppGrConcat 
           (cons 
            (WADLERLINDIG::ppString "[") 
            (cons 
             (WADLERLINDIG::ppSep-1-1 
              (WADLERLINDIG::ppString ",") 
              (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppATerm (cdr pV6547))) 
             (cons (WADLERLINDIG::ppString "]") nil))))) 
         (if (eq (car pV6547) :|None|) 
             (return 
              (block 
               nil 
               (if (eq (car term) :|Apply|) 
                   (let ((pV6465 (cdr term))) 
                     (let ((pV6500 (svref pV6465 1))
                           (pV6499 (svref pV6465 0))) 
                       (progn (if (eq (car pV6499) :|Fun|) 
                                  (let ((pV6512 (svref (cdr pV6499) 0))) 
                                    (if (eq (car pV6512) :|Op|) 
                                        (let ((pV6515 (cdr pV6512))) 
                                          (let ((pV6529 (car pV6515))) 
                                            (if (consp (cdr pV6515)) 
                                                (if (eq (car pV6500) :|Record|) 
                                                    (let ((pV6535 
                                                           (car (cdr pV6500)))) 
                                                      (if (consp pV6535) 
                                                          (let ((pV6539 
                                                                 (cdr pV6535))
                                                                (pV6538 
                                                                 (car pV6535))) 
                                                            (let ((pV6541 
                                                                   (cdr pV6538))) 
                                                              (if (string=  
                                                                   "1" 
                                                                   (car pV6538)) 
                                                                  (if (consp 
                                                                       pV6539) 
                                                                      (let ((pV6543 
                                                                             (car 
                                                                              pV6539))) 
                                                                        (let ((pV6546 
                                                                               (cdr 
                                                                                pV6543))) 
                                                                          (if (string=  
                                                                               "2" 
                                                                               (car 
                                                                                pV6543)) 
                                                                              (if (null 
                                                                                   (cdr 
                                                                                    pV6539)) 
                                                                                  (return 
                                                                                   (if (lisp::or 
                                                                                        (SPECCALC::isSimpleTerm? 
                                                                                         pV6541) 
                                                                                        (SPECCALC::isSimpleTerm? 
                                                                                         pV6546)) 
                                                                                       (WADLERLINDIG::ppGroup 
                                                                                        (WADLERLINDIG::ppConcat 
                                                                                         (cons 
                                                                                          (WADLERLINDIG::ppString 
                                                                                           "(") 
                                                                                          (cons 
                                                                                           (SPECCALC::ppATerm 
                                                                                            pV6541) 
                                                                                           (cons 
                                                                                            (WADLERLINDIG::ppString 
                                                                                             " ") 
                                                                                            (cons 
                                                                                             (SPECCALC::ppQualifiedId 
                                                                                              pV6529) 
                                                                                             (cons 
                                                                                              (WADLERLINDIG::ppString 
                                                                                               " ") 
                                                                                              (cons 
                                                                                               (SPECCALC::ppATerm 
                                                                                                pV6546) 
                                                                                               (cons 
                                                                                                (WADLERLINDIG::ppString 
                                                                                                 ")") 
                                                                                                nil))))))))) 
                                                                                       (SPECCALC::ppGrConcat 
                                                                                        (cons 
                                                                                         (WADLERLINDIG::ppString 
                                                                                          "(") 
                                                                                         (cons 
                                                                                          (SPECCALC::ppATerm 
                                                                                           pV6541) 
                                                                                          (cons 
                                                                                           (WADLERLINDIG::ppGroup 
                                                                                            (WADLERLINDIG::ppIndent 
                                                                                             (WADLERLINDIG::ppConcat 
                                                                                              (cons 
                                                                                               (WADLERLINDIG::ppString 
                                                                                                " ") 
                                                                                               (cons 
                                                                                                (SPECCALC::ppQualifiedId 
                                                                                                 pV6529) 
                                                                                                (cons 
                                                                                                 WADLERLINDIG::ppBreak 
                                                                                                 (cons 
                                                                                                  (WADLERLINDIG::ppAppend-1-1 
                                                                                                   (SPECCALC::ppATerm 
                                                                                                    pV6546) 
                                                                                                   (WADLERLINDIG::ppString 
                                                                                                    ")")) 
                                                                                                  nil))))))) 
                                                                                           nil)))))))))))))))))))) 
                                        (if (eq (car pV6512) :|Equals|) 
                                            (if (eq (car pV6500) :|Record|) 
                                                (let ((pV6517 (car (cdr pV6500)))) 
                                                  (if (consp pV6517) 
                                                      (let ((pV6521 (cdr pV6517))
                                                            (pV6520 (car pV6517))) 
                                                        (let ((pV6523 
                                                               (cdr pV6520))) 
                                                          (if (string=  
                                                               "1" 
                                                               (car pV6520)) 
                                                              (if (consp pV6521) 
                                                                  (let ((pV6525 
                                                                         (car 
                                                                          pV6521))) 
                                                                    (let ((pV6528 
                                                                           (cdr 
                                                                            pV6525))) 
                                                                      (if (string=  
                                                                           "2" 
                                                                           (car 
                                                                            pV6525)) 
                                                                          (if (null 
                                                                               (cdr 
                                                                                pV6521)) 
                                                                              (return 
                                                                               (if (lisp::or 
                                                                                    (SPECCALC::isSimpleTerm? 
                                                                                     pV6523) 
                                                                                    (SPECCALC::isSimpleTerm? 
                                                                                     pV6528)) 
                                                                                   (WADLERLINDIG::ppGroup 
                                                                                    (WADLERLINDIG::ppConcat 
                                                                                     (cons 
                                                                                      (WADLERLINDIG::ppString 
                                                                                       "(") 
                                                                                      (cons 
                                                                                       (SPECCALC::ppATerm 
                                                                                        pV6523) 
                                                                                       (cons 
                                                                                        (WADLERLINDIG::ppString 
                                                                                         " = ") 
                                                                                        (cons 
                                                                                         (SPECCALC::ppATerm 
                                                                                          pV6528) 
                                                                                         (cons 
                                                                                          (WADLERLINDIG::ppString 
                                                                                           ")") 
                                                                                          nil))))))) 
                                                                                   (SPECCALC::ppGrConcat 
                                                                                    (cons 
                                                                                     (WADLERLINDIG::ppString 
                                                                                      "(") 
                                                                                     (cons 
                                                                                      (SPECCALC::ppATerm 
                                                                                       pV6523) 
                                                                                      (cons 
                                                                                       (WADLERLINDIG::ppGroup 
                                                                                        (WADLERLINDIG::ppIndent 
                                                                                         (WADLERLINDIG::ppConcat 
                                                                                          (cons 
                                                                                           (WADLERLINDIG::ppString 
                                                                                            " =") 
                                                                                           (cons 
                                                                                            WADLERLINDIG::ppBreak 
                                                                                            (cons 
                                                                                             (WADLERLINDIG::ppAppend-1-1 
                                                                                              (SPECCALC::ppATerm 
                                                                                               pV6528) 
                                                                                              (WADLERLINDIG::ppString 
                                                                                               ")")) 
                                                                                             nil)))))) 
                                                                                       nil)))))))))))))))))))) 
                                  (if (eq (car pV6499) :|Lambda|) 
                                      (let ((pV6504 (car (cdr pV6499)))) 
                                        (if (consp pV6504) 
                                            (if (consp (cdr pV6504)) 
                                                (return 
                                                 (WADLERLINDIG::ppIndent 
                                                  (SPECCALC::ppGrConcat 
                                                   (cons 
                                                    (WADLERLINDIG::ppString 
                                                     "case ") 
                                                    (cons 
                                                     (SPECCALC::ppATerm pV6500) 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       " of") 
                                                      (cons 
                                                       (WADLERLINDIG::ppIndent 
                                                        (WADLERLINDIG::ppAppend-1-1 
                                                         WADLERLINDIG::ppBreak 
                                                         (SPECCALC::ppAMatch 
                                                          pV6504))) 
                                                       nil)))))))))))) 
                              (return 
                               (if (lisp::or 
                                    (SPECCALC::isSimpleTerm? pV6499) 
                                    (SPECCALC::isSimpleTerm? pV6500)) 
                                   (WADLERLINDIG::ppGroup 
                                    (WADLERLINDIG::ppConcat 
                                     (cons 
                                      (WADLERLINDIG::ppString "(") 
                                      (cons 
                                       (SPECCALC::ppATerm pV6499) 
                                       (cons 
                                        (WADLERLINDIG::ppString " ") 
                                        (cons 
                                         (SPECCALC::ppATerm pV6500) 
                                         (cons (WADLERLINDIG::ppString ")") nil))))))) 
                                   (SPECCALC::ppGrConcat 
                                    (cons 
                                     (WADLERLINDIG::ppString "(") 
                                     (cons 
                                      (WADLERLINDIG::ppGroup 
                                       (WADLERLINDIG::ppIndent 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (SPECCALC::ppATerm pV6499) 
                                          (cons 
                                           WADLERLINDIG::ppBreak 
                                           (cons 
                                            (WADLERLINDIG::ppAppend-1-1 
                                             (SPECCALC::ppATerm pV6500) 
                                             (WADLERLINDIG::ppString ")")) 
                                            nil)))))) 
                                      nil)))))))) 
                   (if (eq (car term) :|ApplyN|) 
                       (let ((pV6497 (car (cdr term)))) 
                         (return 
                          (labels 
                            ((ppTerms (l) 
                              (block 
                               nil 
                               (if (null l) 
                                   (return WADLERLINDIG::ppNil) 
                                   (if (consp l) 
                                       (let ((pV6432 (cdr l))
                                             (pV6431 (car l))) 
                                         (progn (if (null pV6432) 
                                                    (return 
                                                     (SPECCALC::ppATerm pV6431))) 
                                                (return 
                                                 (WADLERLINDIG::ppGroup 
                                                  (WADLERLINDIG::ppIndent 
                                                   (WADLERLINDIG::ppCons-1-1 
                                                    (SPECCALC::ppATerm pV6431) 
                                                    (WADLERLINDIG::ppCons-1-1 
                                                     WADLERLINDIG::ppBreak 
                                                     (ppTerms pV6432)))))))))) 
                               (error "Nonexhaustive match failure in ppATerm")))) 
                            (ppTerms pV6497)))) 
                       (if (eq (car term) :|Record|) 
                           (let ((pV6495 (car (cdr term)))) 
                             (return 
                              (block 
                               nil 
                               (if (null pV6495) 
                                   (return (WADLERLINDIG::ppString "()")) 
                                   (if (consp pV6495) 
                                       (if (string=  "1" (car (car pV6495))) 
                                           (return 
                                            (labels 
                                              ((ppField (pV6436 y) 
                                                (declare (ignore pV6436)) 
                                                (SPECCALC::ppATerm y))) 
                                              (WADLERLINDIG::ppConcat 
                                               (cons 
                                                (WADLERLINDIG::ppString "(") 
                                                (cons 
                                                 (WADLERLINDIG::ppSep-1-1 
                                                  (WADLERLINDIG::ppString ",") 
                                                  (LIST-SPEC::|!map|-1-1 
                                                   #'(lambda (x) 
                                                      (ppField (car x) (cdr x))) 
                                                   pV6495)) 
                                                 (cons 
                                                  (WADLERLINDIG::ppString ")") 
                                                  nil))))))))) 
                               (return 
                                (labels 
                                  ((ppField (x y) 
                                    (WADLERLINDIG::ppConcat 
                                     (cons 
                                      (WADLERLINDIG::ppString x) 
                                      (cons 
                                       (WADLERLINDIG::ppString "=") 
                                       (cons (SPECCALC::ppATerm y) nil)))))) 
                                  (WADLERLINDIG::ppConcat 
                                   (cons 
                                    (WADLERLINDIG::ppString "{") 
                                    (cons 
                                     (WADLERLINDIG::ppSep-1-1 
                                      (WADLERLINDIG::ppString ",") 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (x) (ppField (car x) (cdr x))) 
                                       pV6495)) 
                                     (cons (WADLERLINDIG::ppString "}") nil))))))))) 
                           (if (eq (car term) :|Bind|) 
                               (let ((pV6462 (cdr term))) 
                                 (return 
                                  (SPECCALC::ppGrConcat 
                                   (cons 
                                    (SPECCALC::ppBinder (svref pV6462 0)) 
                                    (cons 
                                     (WADLERLINDIG::ppString " (") 
                                     (cons 
                                      (WADLERLINDIG::ppSep-1-1 
                                       (WADLERLINDIG::ppString ",") 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'SPECCALC::ppAVarWithoutSort-1 
                                        (svref pV6462 1))) 
                                      (cons 
                                       (WADLERLINDIG::ppString ") ") 
                                       (cons 
                                        (SPECCALC::ppATerm (svref pV6462 2)) 
                                        nil)))))))) 
                               (if (eq (car term) :|Let|) 
                                   (let ((pV6461 (cdr term))) 
                                     (let ((pV6489 (svref pV6461 1))
                                           (pV6488 (svref pV6461 0))) 
                                       (return 
                                        (labels 
                                          ((ppDecl (pattern term1) 
                                            (WADLERLINDIG::ppConcat 
                                             (cons 
                                              (SPECCALC::ppAPattern pattern) 
                                              (cons 
                                               (WADLERLINDIG::ppString "=") 
                                               (cons 
                                                (SPECCALC::ppATerm term1) 
                                                nil)))))) 
                                          (SPECCALC::ppGrConcat 
                                           (cons 
                                            (WADLERLINDIG::ppString "let ") 
                                            (cons 
                                             (WADLERLINDIG::ppIndent 
                                              (WADLERLINDIG::ppSep-1-1 
                                               WADLERLINDIG::ppNewline 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'(lambda (x) 
                                                   (ppDecl (car x) (cdr x))) 
                                                pV6488))) 
                                             (cons 
                                              (WADLERLINDIG::ppString "in") 
                                              (cons 
                                               WADLERLINDIG::ppNewline 
                                               (cons 
                                                (WADLERLINDIG::ppIndent 
                                                 (SPECCALC::ppATerm pV6489)) 
                                                nil)))))))))) 
                                   (if (eq (car term) :|LetRec|) 
                                       (let ((pV6460 (cdr term))) 
                                         (let ((pV6486 (svref pV6460 1))
                                               (pV6485 (svref pV6460 0))) 
                                           (return 
                                            (labels 
                                              ((ppDecl (var term1) 
                                                (SPECCALC::ppGrConcat 
                                                 (cons 
                                                  (WADLERLINDIG::ppString "def ") 
                                                  (cons 
                                                   (SPECCALC::ppAVarWithoutSort-1 
                                                    var) 
                                                   (cons 
                                                    (WADLERLINDIG::ppString 
                                                     " = ") 
                                                    (cons 
                                                     (SPECCALC::ppATerm term1) 
                                                     nil))))))) 
                                              (SPECCALC::ppGrConcat 
                                               (cons 
                                                (WADLERLINDIG::ppString "let") 
                                                (cons 
                                                 WADLERLINDIG::ppNewline 
                                                 (cons 
                                                  (WADLERLINDIG::ppString "  ") 
                                                  (cons 
                                                   (WADLERLINDIG::ppIndent 
                                                    (WADLERLINDIG::ppSep-1-1 
                                                     WADLERLINDIG::ppNewline 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (ppDecl (car x) (cdr x))) 
                                                      pV6485))) 
                                                   (cons 
                                                    WADLERLINDIG::ppNewline 
                                                    (cons 
                                                     (WADLERLINDIG::ppString 
                                                      "in") 
                                                     (cons 
                                                      WADLERLINDIG::ppNewline 
                                                      (cons 
                                                       (SPECCALC::ppATerm pV6486) 
                                                       nil))))))))))))) 
                                       (if (eq (car term) :|Var|) 
                                           (return 
                                            (SPECCALC::ppAVarWithoutSort-1 
                                             (car (cdr term)))) 
                                           (if (eq (car term) :|Fun|) 
                                               (return 
                                                (SPECCALC::ppAFun 
                                                 (svref (cdr term) 0))) 
                                               (if (eq (car term) :|Lambda|) 
                                                   (let ((pV6472 
                                                          (car (cdr term)))) 
                                                     (progn (if (consp pV6472) 
                                                                (let ((pV6475 
                                                                       (car 
                                                                        pV6472))) 
                                                                  (if (null 
                                                                       (cdr 
                                                                        pV6472)) 
                                                                      (return 
                                                                       (SPECCALC::ppGrConcat 
                                                                        (cons 
                                                                         (WADLERLINDIG::ppString 
                                                                          "(fn ") 
                                                                         (cons 
                                                                          (SPECCALC::ppAPattern 
                                                                           (svref 
                                                                            pV6475 
                                                                            0)) 
                                                                          (cons 
                                                                           (WADLERLINDIG::ppGroup 
                                                                            (WADLERLINDIG::ppIndent 
                                                                             (WADLERLINDIG::ppConcat 
                                                                              (cons 
                                                                               (WADLERLINDIG::ppString 
                                                                                " ->") 
                                                                               (cons 
                                                                                WADLERLINDIG::ppBreak 
                                                                                (cons 
                                                                                 (WADLERLINDIG::ppAppend-1-1 
                                                                                  (SPECCALC::ppATerm 
                                                                                   (svref 
                                                                                    pV6475 
                                                                                    2)) 
                                                                                  (WADLERLINDIG::ppString 
                                                                                   ")")) 
                                                                                 nil)))))) 
                                                                           nil)))))))) 
                                                            (return 
                                                             (SPECCALC::ppAMatch 
                                                              pV6472)))) 
                                                   (if (eq 
                                                        (car term) 
                                                        :|IfThenElse|) 
                                                       (let ((pV6456 (cdr term))) 
                                                         (return 
                                                          (SPECCALC::ppGrConcat 
                                                           (cons 
                                                            (WADLERLINDIG::ppString 
                                                             "if ") 
                                                            (cons 
                                                             (SPECCALC::ppATerm 
                                                              (svref pV6456 0)) 
                                                             (cons 
                                                              (WADLERLINDIG::ppString 
                                                               " then") 
                                                              (cons 
                                                               WADLERLINDIG::ppBreak 
                                                               (cons 
                                                                (WADLERLINDIG::ppIndent 
                                                                 (SPECCALC::ppATerm 
                                                                  (svref 
                                                                   pV6456 
                                                                   1))) 
                                                                (cons 
                                                                 WADLERLINDIG::ppBreak 
                                                                 (cons 
                                                                  (WADLERLINDIG::ppString 
                                                                   "else") 
                                                                  (cons 
                                                                   WADLERLINDIG::ppBreak 
                                                                   (cons 
                                                                    (WADLERLINDIG::ppIndent 
                                                                     (SPECCALC::ppATerm 
                                                                      (svref 
                                                                       pV6456 
                                                                       2))) 
                                                                    nil)))))))))))) 
                                                       (if (eq (car term) :|Seq|) 
                                                           (return 
                                                            (WADLERLINDIG::ppSep-1-1 
                                                             (WADLERLINDIG::ppString 
                                                              "; ") 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'SPECCALC::ppATerm 
                                                              (car (cdr term)))))))))))))))) 
               (return 
                (SYSTEM-SPEC::fail 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   "No match in ppATerm with: '" 
                   (SYSTEM-SPEC::toString term)) 
                  "'"))))))) 
     (error "Nonexhaustive match failure in ppATerm"))))
                                                        
(defun SPECCALC::ppPropertyType (propType) 
  (block 
   nil 
   (if (eq (car propType) :|Axiom|) 
       (return (WADLERLINDIG::ppString "axiom")) 
       (if (eq (car propType) :|Theorem|) 
           (return (WADLERLINDIG::ppString "theorem")) 
           (if (eq (car propType) :|Conjecture|) 
               (return (WADLERLINDIG::ppString "conjecture"))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ 
       "No match in ppPropertyType with: '" 
       (SYSTEM-SPEC::toString propType)) 
      "'")))))
              
(defun SPECCALC::ppAProperty (propType name |!tyVars| term) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (SPECCALC::ppPropertyType propType) 
    (cons 
     (WADLERLINDIG::ppString " ") 
     (cons 
      (WADLERLINDIG::ppString name) 
      (cons 
       (WADLERLINDIG::ppGroup 
        (WADLERLINDIG::ppIndent 
         (WADLERLINDIG::ppConcat 
          (cons 
           (WADLERLINDIG::ppString " is") 
           (cons 
            WADLERLINDIG::ppBreak 
            (cons 
             (WADLERLINDIG::ppGroup 
              (WADLERLINDIG::ppConcat 
               (cons 
                (block 
                 nil 
                 (if (null |!tyVars|) (return WADLERLINDIG::ppNil)) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString "fa (") 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      (WADLERLINDIG::ppString ",") 
                      (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString |!tyVars|)) 
                     (cons (WADLERLINDIG::ppString ") ") nil)))))) 
                (cons 
                 (WADLERLINDIG::ppString " ") 
                 (cons (SPECCALC::ppATerm term) nil))))) 
             nil)))))) 
       nil))))))
                
(defun SPECCALC::ppAProperty-1 (x) 
  (SPECCALC::ppAProperty (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                          
(defun SPECCALC::ppIdInfo (qids) 
  (WADLERLINDIG::ppSep-1-1 
   (WADLERLINDIG::ppString ",") 
   (LIST-SPEC::|!map|-1-1 
    #'WADLERLINDIG::ppString 
    (LIST-SPEC::|!map|-1-1 #'METASLANG::printQualifiedId qids))))
                                                                 
(defun SPECCALC::isSimpleSort? (srt) 
  (block nil (if (eq (car srt) :|Base|) (return t)) (return nil)))
                                                                  
(defun SPECCALC::ppASort (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV6374 (cdr srt))) 
         (let ((pV6396 (svref pV6374 1))
               (pV6395 (svref pV6374 0))) 
           (return 
            (if (lisp::or 
                 (SPECCALC::isSimpleSort? pV6395) 
                 (SPECCALC::isSimpleSort? pV6396)) 
                (WADLERLINDIG::ppGroup 
                 (WADLERLINDIG::ppConcat 
                  (cons 
                   (WADLERLINDIG::ppString "(") 
                   (cons 
                    (SPECCALC::ppASort pV6395) 
                    (cons 
                     (WADLERLINDIG::ppString " -> ") 
                     (cons 
                      (SPECCALC::ppASort pV6396) 
                      (cons (WADLERLINDIG::ppString ")") nil))))))) 
                (SPECCALC::ppGrConcat 
                 (cons 
                  (WADLERLINDIG::ppString "(") 
                  (cons 
                   (SPECCALC::ppASort pV6395) 
                   (cons 
                    (WADLERLINDIG::ppGroup 
                     (WADLERLINDIG::ppIndent 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (WADLERLINDIG::ppString " ->") 
                        (cons 
                         WADLERLINDIG::ppBreak 
                         (cons 
                          (SPECCALC::ppASort pV6396) 
                          (cons (WADLERLINDIG::ppString ")") nil))))))) 
                    nil)))))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV6393 (car (cdr srt)))) 
             (return 
              (block 
               nil 
               (if (null pV6393) 
                   (return (WADLERLINDIG::ppString "()")) 
                   (if (consp pV6393) 
                       (if (string=  "1" (car (car pV6393))) 
                           (return 
                            (labels 
                              ((ppField (pV6344 y) 
                                (declare (ignore pV6344)) 
                                (SPECCALC::ppASort y))) 
                              (SPECCALC::ppGrConcat 
                               (cons 
                                (WADLERLINDIG::ppString "(") 
                                (cons 
                                 (WADLERLINDIG::ppSep-1-1 
                                  (WADLERLINDIG::ppString " * ") 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'(lambda (x) (ppField (car x) (cdr x))) 
                                   pV6393)) 
                                 (cons (WADLERLINDIG::ppString ")") nil))))))))) 
               (return 
                (labels 
                  ((ppField (x y) 
                    (WADLERLINDIG::ppGroup 
                     (WADLERLINDIG::ppConcat 
                      (cons 
                       (WADLERLINDIG::ppString x) 
                       (cons 
                        (WADLERLINDIG::ppString " : ") 
                        (cons (SPECCALC::ppASort y) nil))))))) 
                  (WADLERLINDIG::ppIndent 
                   (SPECCALC::ppGrConcat 
                    (cons 
                     (WADLERLINDIG::ppString "{") 
                     (cons 
                      (WADLERLINDIG::ppSep-1-1 
                       (WADLERLINDIG::ppAppend-1-1 
                        (WADLERLINDIG::ppString ",") 
                        WADLERLINDIG::ppBreak) 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (x) (ppField (car x) (cdr x))) 
                        pV6393)) 
                      (cons (WADLERLINDIG::ppString "}") nil)))))))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV6391 (car (cdr srt)))) 
                 (return 
                  (labels 
                    ((ppTaggedSort (id |!optSrt|) 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (WADLERLINDIG::ppString "(") 
                        (cons 
                         (WADLERLINDIG::ppString id) 
                         (cons 
                          (WADLERLINDIG::ppString " ") 
                          (cons 
                           (block 
                            nil 
                            (if (eq (car |!optSrt|) :|None|) 
                                (return WADLERLINDIG::ppNil) 
                                (if (eq (car |!optSrt|) :|Some|) 
                                    (return (SPECCALC::ppASort (cdr |!optSrt|))))) 
                            (error "Nonexhaustive match failure in ppASort")) 
                           (cons (WADLERLINDIG::ppString ")") nil)))))))) 
                    (SPECCALC::ppGrConcat 
                     (cons 
                      (WADLERLINDIG::ppString "(") 
                      (cons 
                       WADLERLINDIG::ppBreak 
                       (cons 
                        (WADLERLINDIG::ppSep-1-1 
                         (WADLERLINDIG::ppAppend-1-1 
                          WADLERLINDIG::ppBreak 
                          (WADLERLINDIG::ppString "|")) 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (x) (ppTaggedSort (car x) (cdr x))) 
                          pV6391)) 
                        (cons (WADLERLINDIG::ppString ")") nil)))))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV6371 (cdr srt))) 
                     (return 
                      (SPECCALC::ppGrConcat 
                       (cons 
                        (WADLERLINDIG::ppString "(") 
                        (cons 
                         (SPECCALC::ppASort (svref pV6371 0)) 
                         (cons 
                          (WADLERLINDIG::ppString " \\ ") 
                          (cons 
                           (SPECCALC::ppATerm (svref pV6371 1)) 
                           (cons (WADLERLINDIG::ppString ")") nil)))))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV6370 (cdr srt))) 
                         (return 
                          (SPECCALC::ppGrConcat 
                           (cons 
                            (WADLERLINDIG::ppString "(") 
                            (cons 
                             (SPECCALC::ppASort (svref pV6370 0)) 
                             (cons 
                              (WADLERLINDIG::ppString " | ") 
                              (cons 
                               (SPECCALC::ppATerm (svref pV6370 1)) 
                               (cons (WADLERLINDIG::ppString ")") nil)))))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV6369 (cdr srt))) 
                             (let ((pV6380 (svref pV6369 1))
                                   (pV6379 (svref pV6369 0))) 
                               (progn (if (null pV6380) 
                                          (return 
                                           (SPECCALC::ppQualifiedId pV6379)) 
                                          (if (consp pV6380) 
                                              (if (null (cdr pV6380)) 
                                                  (return 
                                                   (SPECCALC::ppGrConcat 
                                                    (cons 
                                                     (SPECCALC::ppQualifiedId 
                                                      pV6379) 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       " ") 
                                                      (cons 
                                                       (SPECCALC::ppASort 
                                                        (car pV6380)) 
                                                       nil)))))))) 
                                      (return 
                                       (SPECCALC::ppGrConcat 
                                        (cons 
                                         (SPECCALC::ppQualifiedId pV6379) 
                                         (cons 
                                          (WADLERLINDIG::ppString " (") 
                                          (cons 
                                           (WADLERLINDIG::ppSep-1-1 
                                            (WADLERLINDIG::ppString ",") 
                                            (LIST-SPEC::|!map|-1-1 
                                             #'SPECCALC::ppASort 
                                             pV6380)) 
                                           (cons 
                                            (WADLERLINDIG::ppString ")") 
                                            nil))))))))) 
                           (if (eq (car srt) :|TyVar|) 
                               (return (WADLERLINDIG::ppString (car (cdr srt)))) 
                               (if (eq (car srt) :|MetaTyVar|) 
                                   (return 
                                    (let ((pV6362 (STATE::|!!| (car (cdr srt))))) 
                                      (block 
                                       nil 
                                       (return 
                                        (WADLERLINDIG::ppString 
                                         (STRING-SPEC::^ 
                                          (svref pV6362 1) 
                                          (NAT-SPEC::toString (svref pV6362 2))))) 
                                       (error 
                                        "Nonexhaustive match failure in ppASort")))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      (STRING-SPEC::^ "No match in ppASort with: '" (SYSTEM-SPEC::toString srt)) 
      "'")))))
              
(defun SPECCALC::ppdAOpInfo (pV6695 pV6696 pV6697) 
  (block 
   nil 
   (let ((pV6698 (car pV6696))) 
     (return 
      (WADLERLINDIG::ppConcat 
       (cons 
        (SPECCALC::ppFixity pV6695) 
        (cons 
         (WADLERLINDIG::ppString " : ") 
         (cons 
          (block 
           nil 
           (if (null pV6698) (return WADLERLINDIG::ppNil)) 
           (return 
            (WADLERLINDIG::ppConcat 
             (cons 
              (WADLERLINDIG::ppString "fa (") 
              (cons 
               (WADLERLINDIG::ppSep-1-1 
                (WADLERLINDIG::ppString ",") 
                (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString pV6698)) 
               (cons (WADLERLINDIG::ppString ") ") nil)))))) 
          (cons 
           (SPECCALC::ppASort (cdr pV6696)) 
           (cons 
            (block 
             nil 
             (if (eq (car pV6697) :|None|) 
                 (return WADLERLINDIG::ppNil) 
                 (if (eq (car pV6697) :|Some|) 
                     (return 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (WADLERLINDIG::ppString " = ") 
                        (cons (SPECCALC::ppATerm (cdr pV6697)) nil)))))) 
             (error "Nonexhaustive match failure in ppdAOpInfo")) 
            nil)))))))) 
   (error "Nonexhaustive match failure in ppdAOpInfo")))
                                                        
(defun SPECCALC::ppdAOpInfo-1 (x) 
  (SPECCALC::ppdAOpInfo (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun SPECCALC::ppdASortInfo-1 (sortInfo) 
  (let ((pV6701 (cdr sortInfo))
        (pV6700 (car sortInfo))) 
    (block 
     nil 
     (if (null pV6700) 
         (if (eq (car pV6701) :|None|) 
             (return WADLERLINDIG::ppNil) 
             (if (eq (car pV6701) :|Some|) 
                 (return 
                  (WADLERLINDIG::ppAppend-1-1 
                   (WADLERLINDIG::ppString " = ") 
                   (SPECCALC::ppASort (cdr pV6701))))))) 
     (if (eq (car pV6701) :|Some|) 
         (return 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString " (") 
            (cons 
             (WADLERLINDIG::ppSep-1-1 
              (WADLERLINDIG::ppString ",") 
              (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString pV6700)) 
             (cons 
              (WADLERLINDIG::ppString ") = ") 
              (cons (SPECCALC::ppASort (cdr pV6701)) nil))))))) 
     (error "Nonexhaustive match failure in ppdASortInfo"))))
                                                             
(defun SPECCALC::ppSpecElem (elem pV6592) 
  (declare (ignore pV6592)) 
  (block 
   nil 
   (if (eq (car elem) :|Import|) 
       (return 
        (WADLERLINDIG::ppConcat 
         (cons 
          (WADLERLINDIG::ppString "import ") 
          (cons (SPECCALC::ppTerm-1 (cdr elem)) nil)))) 
       (if (eq (car elem) :|Sort|) 
           (let ((pV6596 (cdr elem))) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons 
                (WADLERLINDIG::ppString "sort ") 
                (cons 
                 (SPECCALC::ppIdInfo (car pV6596)) 
                 (cons (SPECCALC::ppdASortInfo-1 (cdr pV6596)) nil)))))) 
           (if (eq (car elem) :|Op|) 
               (let ((pV6595 (cdr elem))) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString "op ") 
                    (cons 
                     (SPECCALC::ppIdInfo (car pV6595)) 
                     (cons (SPECCALC::ppdAOpInfo-1 (cdr pV6595)) nil)))))) 
               (if (eq (car elem) :|Claim|) 
                   (return (SPECCALC::ppAProperty-1 (cdr elem))))))) 
   (error "Nonexhaustive match failure in ppSpecElem")))
                                                        
(defun SPECCALC::ppSpecElem-1 (x) (SPECCALC::ppSpecElem (car x) (cdr x)))
                                                                         
(defun SPECCALC::ppSpecElems (elems) 
  (WADLERLINDIG::ppSep-1-1 
   WADLERLINDIG::ppNewline 
   (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppSpecElem-1 elems)))
                                                           
(defun SPECCALC::ppTerm (term pV6606) 
  (declare (ignore pV6606)) 
  (block 
   nil 
   (if (eq (car term) :|Print|) 
       (return 
        (WADLERLINDIG::ppConcat 
         (cons 
          (WADLERLINDIG::ppString "print ") 
          (cons (SPECCALC::ppTerm-1 (cdr term)) nil)))) 
       (if (eq (car term) :|URI|) 
           (return (SPECCALC::ppRelativeURI (cdr term))) 
           (if (eq (car term) :|Spec|) 
               (return 
                (WADLERLINDIG::ppConcat 
                 (cons 
                  (WADLERLINDIG::ppString "spec {") 
                  (cons 
                   WADLERLINDIG::ppNewline 
                   (cons 
                    (WADLERLINDIG::ppString "  ") 
                    (cons 
                     (WADLERLINDIG::ppNest-1-1 
                      2 
                      (SPECCALC::ppSpecElems (cdr term))) 
                     (cons 
                      WADLERLINDIG::ppNewline 
                      (cons (WADLERLINDIG::ppString "}") nil)))))))) 
               (if (eq (car term) :|Qualify|) 
                   (let ((pV6639 (cdr term))) 
                     (return 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (WADLERLINDIG::ppString (cdr pV6639)) 
                        (cons 
                         (WADLERLINDIG::ppString " qualifying ") 
                         (cons (SPECCALC::ppTerm-1 (car pV6639)) nil)))))) 
                   (if (eq (car term) :|Translate|) 
                       (let ((pV6638 (cdr term))) 
                         (let ((pV6652 (car pV6638))) 
                           (let ((pV6654 (car (cdr pV6638)))) 
                             (return 
                              (labels 
                                ((ppTranslateRule (rule pV6608) 
                                  (declare (ignore pV6608)) 
                                  (block 
                                   nil 
                                   (if (eq (car rule) :|Sort|) 
                                       (let ((pV6614 (cdr rule))) 
                                         (return 
                                          (WADLERLINDIG::ppConcat 
                                           (cons 
                                            (SPECCALC::ppQualifier 
                                             (svref pV6614 0)) 
                                            (cons 
                                             (WADLERLINDIG::ppString " -> ") 
                                             (cons 
                                              (SPECCALC::ppQualifier 
                                               (svref pV6614 1)) 
                                              nil)))))) 
                                       (if (eq (car rule) :|Op|) 
                                           (let ((pV6613 (cdr rule))) 
                                             (return 
                                              (WADLERLINDIG::ppConcat 
                                               (cons 
                                                (SPECCALC::ppQualifier 
                                                 (car (svref pV6613 0))) 
                                                (cons 
                                                 (WADLERLINDIG::ppString " -> ") 
                                                 (cons 
                                                  (SPECCALC::ppQualifier 
                                                   (car (svref pV6613 1))) 
                                                  nil)))))) 
                                           (if (eq (car rule) :|Ambiguous|) 
                                               (let ((pV6612 (cdr rule))) 
                                                 (return 
                                                  (WADLERLINDIG::ppConcat 
                                                   (cons 
                                                    (SPECCALC::ppQualifier 
                                                     (svref pV6612 0)) 
                                                    (cons 
                                                     (WADLERLINDIG::ppString 
                                                      " -> ") 
                                                     (cons 
                                                      (SPECCALC::ppQualifier 
                                                       (svref pV6612 1)) 
                                                      nil))))))))) 
                                   (error 
                                    "Nonexhaustive match failure in ppTerm")))) 
                                (WADLERLINDIG::ppConcat 
                                 (cons 
                                  (WADLERLINDIG::ppString "{") 
                                  (cons 
                                   (WADLERLINDIG::ppSep-1-1 
                                    (WADLERLINDIG::ppString ", ") 
                                    (LIST-SPEC::|!map|-1-1 
                                     #'(lambda (x) 
                                        (ppTranslateRule (car x) (cdr x))) 
                                     pV6654)) 
                                   (cons 
                                    (WADLERLINDIG::ppString "}") 
                                    (cons 
                                     (WADLERLINDIG::ppString " translating ") 
                                     (cons (SPECCALC::ppTerm-1 pV6652) nil))))))))))) 
                       (if (eq (car term) :|Let|) 
                           (let ((pV6637 (cdr term))) 
                             (return 
                              (WADLERLINDIG::ppConcat 
                               (cons 
                                (WADLERLINDIG::ppString "let {") 
                                (cons 
                                 WADLERLINDIG::ppNewline 
                                 (cons 
                                  (WADLERLINDIG::ppString "  ") 
                                  (cons 
                                   (WADLERLINDIG::ppNest-1-1 
                                    2 
                                    (SPECCALC::ppDecls (car pV6637))) 
                                   (cons 
                                    WADLERLINDIG::ppNewline 
                                    (cons 
                                     (WADLERLINDIG::ppString "} in") 
                                     (cons 
                                      WADLERLINDIG::ppNewline 
                                      (cons 
                                       (WADLERLINDIG::ppNest-1-1 
                                        2 
                                        (SPECCALC::ppTerm-1 (cdr pV6637))) 
                                       nil))))))))))) 
                           (if (eq (car term) :|Where|) 
                               (let ((pV6636 (cdr term))) 
                                 (return 
                                  (WADLERLINDIG::ppConcat 
                                   (cons 
                                    (SPECCALC::ppTerm-1 (cdr pV6636)) 
                                    (cons 
                                     WADLERLINDIG::ppNewline 
                                     (cons 
                                      (WADLERLINDIG::ppString "  ") 
                                      (cons 
                                       (WADLERLINDIG::ppString "where {") 
                                       (cons 
                                        WADLERLINDIG::ppNewline 
                                        (cons 
                                         (WADLERLINDIG::ppString "    ") 
                                         (cons 
                                          (WADLERLINDIG::ppNest-1-1 
                                           4 
                                           (SPECCALC::ppDecls (car pV6636))) 
                                          (cons 
                                           WADLERLINDIG::ppNewline 
                                           (cons 
                                            (WADLERLINDIG::ppString "}") 
                                            nil)))))))))))) 
                               (if (eq (car term) :|Diag|) 
                                   (return 
                                    (WADLERLINDIG::ppConcat 
                                     (cons 
                                      (WADLERLINDIG::ppString "diag {") 
                                      (cons 
                                       WADLERLINDIG::ppNewline 
                                       (cons 
                                        (WADLERLINDIG::ppString "  ") 
                                        (cons 
                                         (WADLERLINDIG::ppNest-1-1 
                                          2 
                                          (WADLERLINDIG::ppSep-1-1 
                                           WADLERLINDIG::ppNewline 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'SPECCALC::ppDiagElem-1 
                                            (cdr term)))) 
                                         (cons 
                                          WADLERLINDIG::ppNewline 
                                          (cons (WADLERLINDIG::ppString "}") nil)))))))) 
                                   (if (eq (car term) :|Colimit|) 
                                       (return 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (WADLERLINDIG::ppString "colim ") 
                                          (cons 
                                           (SPECCALC::ppTerm-1 (cdr term)) 
                                           nil)))) 
                                       (if (eq (car term) :|Subst|) 
                                           (let ((pV6633 (cdr term))) 
                                             (return 
                                              (WADLERLINDIG::ppConcat 
                                               (cons 
                                                (SPECCALC::ppTerm-1 (car pV6633)) 
                                                (cons 
                                                 (WADLERLINDIG::ppString " [") 
                                                 (cons 
                                                  (SPECCALC::ppTerm-1 
                                                   (cdr pV6633)) 
                                                  (cons 
                                                   (WADLERLINDIG::ppString "]") 
                                                   nil))))))) 
                                           (if (eq (car term) :|Generate|) 
                                               (let ((pV6632 (cdr term))) 
                                                 (let ((pV6645 (svref pV6632 2))) 
                                                   (return 
                                                    (WADLERLINDIG::ppConcat 
                                                     (cons 
                                                      (WADLERLINDIG::ppString 
                                                       (STRING-SPEC::^ 
                                                        (STRING-SPEC::^ 
                                                         "generate " 
                                                         (svref pV6632 0)) 
                                                        " ")) 
                                                      (cons 
                                                       (SPECCALC::ppTerm-1 
                                                        (svref pV6632 1)) 
                                                       (cons 
                                                        (block 
                                                         nil 
                                                         (if (eq 
                                                              (car pV6645) 
                                                              :|Some|) 
                                                             (return 
                                                              (WADLERLINDIG::ppString 
                                                               (STRING-SPEC::^ 
                                                                " in " 
                                                                (cdr pV6645))))) 
                                                         (return 
                                                          WADLERLINDIG::ppNil)) 
                                                        nil)))))))))))))))))) 
   (error "Nonexhaustive match failure in ppTerm")))
                                                    
(defun SPECCALC::ppTerm-1 (x) (SPECCALC::ppTerm (car x) (cdr x)))
                                                                 
(defun SPECCALC::showTerm-1 (term) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppTerm-1 term)))
                                                     
(defun SPECUNION::importsUnion (specs) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) (LISTUTILITIES::listUnion (svref (svref (car x) 0) 1) (cdr x))) 
   nil 
   specs))
          
(defun SPECUNION::unionOpMaps (old_op_map) 
  #'(lambda (new_op_map) 
     (labels 
       ((augmentOpMap (qualifier id new_info merged_op_map) 
         (let ((opt_old_info (findAQualifierMap merged_op_map qualifier id))) 
           (SPECCALC::monadBind 
            (funcall (funcall (funcall (funcall (SPECCALC::mergeOpInfo-1 
                                                 new_info) 
                                                opt_old_info) 
                                       qualifier) 
                              id) 
                     POSITION-SPEC::noPos) 
            #'(lambda (merged_info) 
               (SPECCALC::|!return| 
                (insertAQualifierMap merged_op_map qualifier id merged_info))))))) 
       (funcall (funcall (SPECCALC::foldOverQualifierMap 
                          #'(lambda (x) 
                             (augmentOpMap 
                              (svref x 0) 
                              (svref x 1) 
                              (svref x 2) 
                              (svref x 3)))) 
                         old_op_map) 
                new_op_map))))
                              
(defparameter STANDARDSPEC::emptyOpMap emptyASortMap)
                                                     
(defun SPECUNION::opsUnion (specs) 
  (funcall (funcall (SPECCALC::foldM #'SPECUNION::unionOpMaps) 
                    STANDARDSPEC::emptyOpMap) 
           (LIST-SPEC::foldl-1-1-1 
            #'(lambda (x) (LIST-SPEC::|!cons| (svref (car x) 1) (cdr x))) 
            nil 
            specs)))
                    
(defun SPECUNION::propertiesUnion (specs) 
  (SPECCALC::|!return| 
   (LIST-SPEC::foldl-1-1-1 
    #'(lambda (x) (LISTUTILITIES::listUnion (svref (car x) 2) (cdr x))) 
    nil 
    specs)))
            
(defun SPECUNION::unionSortMaps (old_sort_map) 
  #'(lambda (new_sort_map) 
     (labels 
       ((augmentSortMap (qualifier id new_info merged_sort_map) 
         (let ((opt_old_info (findAQualifierMap merged_sort_map qualifier id))) 
           (SPECCALC::monadBind 
            (funcall (funcall (funcall (funcall (SPECCALC::mergeSortInfo-1 
                                                 new_info) 
                                                opt_old_info) 
                                       qualifier) 
                              id) 
                     POSITION-SPEC::noPos) 
            #'(lambda (merged_info) 
               (SPECCALC::|!return| 
                (insertAQualifierMap merged_sort_map qualifier id merged_info))))))) 
       (funcall (funcall (SPECCALC::foldOverQualifierMap 
                          #'(lambda (x) 
                             (augmentSortMap 
                              (svref x 0) 
                              (svref x 1) 
                              (svref x 2) 
                              (svref x 3)))) 
                         old_sort_map) 
                new_sort_map))))
                                
(defparameter STANDARDSPEC::emptySortMap emptyASortMap)
                                                       
(defun SPECUNION::sortsUnion (specs) 
  (funcall (funcall (SPECCALC::foldM #'SPECUNION::unionSortMaps) 
                    STANDARDSPEC::emptySortMap) 
           (LIST-SPEC::foldl-1-1-1 
            #'(lambda (x) (LIST-SPEC::|!cons| (svref (car x) 3) (cdr x))) 
            nil 
            specs)))
                    
(defun SPECUNION::specUnion (specs) 
  (let ((merged_imports (SPECUNION::importsUnion specs))) 
    (SPECCALC::monadBind 
     (SPECUNION::sortsUnion specs) 
     #'(lambda (merged_sorts) 
        (SPECCALC::monadBind 
         (SPECUNION::opsUnion specs) 
         #'(lambda (merged_ops) 
            (SPECCALC::monadBind 
             (SPECUNION::propertiesUnion specs) 
             #'(lambda (merged_props) 
                (SPECCALC::|!return| 
                 (vector 
                  (vector '(:|None|) merged_imports emptyOpNames emptySortNames) 
                  merged_ops 
                  merged_props 
                  merged_sorts))))))))))
                                        
(defun SPECCALC::applySubstitution-1 (sm) 
  #'(lambda (spc) 
     #'(lambda (sm_tm) 
        #'(lambda (|!position|) 
           (let ((dom_spec (SPECCALC::dom-1 sm))) 
             (let ((cod_spec (SPECCALC::cod-1 sm))) 
               (let ((residue (subtractSpec-1-1 spc dom_spec))) 
                 (SPECCALC::monadBind 
                  (funcall (funcall (SPECCALC::applyMorphism-1 sm) residue) 
                           |!position|) 
                  #'(lambda (translated_residue) 
                     (SPECCALC::monadBind 
                      (SPECUNION::specUnion 
                       (cons translated_residue (cons cod_spec nil))) 
                      #'(lambda (new_spec) 
                         (SPECCALC::monadBind 
                          (SPECCALC::|!return| 
                           (let ((pV5012 (car sm_tm))) 
                             (block 
                              nil 
                              (if (eq (car pV5012) :|SpecMorph|) 
                                  (return 
                                   (SPECCALC::showTerm-1 (svref (cdr pV5012) 1)))) 
                              (return 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 "cod (" 
                                 (SPECCALC::showTerm-1 sm_tm)) 
                                ")"))))) 
                          #'(lambda (spec_ref) 
                             (SPECCALC::|!return| 
                              (setImportInfo 
                               new_spec 
                               (vector 
                                (cons 
                                 :|Some| 
                                 (vector 
                                  (svref cod_spec 0) 
                                  (svref cod_spec 1) 
                                  (svref cod_spec 2) 
                                  (svref cod_spec 3))) 
                                (cons (cons spec_ref cod_spec) nil) 
                                emptyOpNames 
                                emptySortNames))))))))))))))))
                                                              
(defun SPECCALC::applySubstitution (x0 x1 x2 x3) 
  (SPECCALC::applySubstitution-1 (vector x0 x1 x2 x3)))
                                                       
(defun SPECCALC::applySubstitution-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::applySubstitution-1 x1) x2) x3) 
                    x4) 
           x5))
               
(defparameter SPECCALC::declare_function 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-FUNCTION-SYMBOL"))
                                                           
(defparameter SPECCALC::arithmeticFunctions 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_function 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "+")) 
      (cons 
       (LISP-SPEC::|!nat| 2) 
       (cons 
        (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
        (cons 
         (LISP-SPEC::bool t) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
          (cons (LISP-SPEC::bool t) nil)))))))) 
   (cons 
    (LISP-SPEC::|!list| 
     (cons 
      SPECCALC::declare_function 
      (cons 
       (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "*")) 
       (cons 
        (LISP-SPEC::|!nat| 2) 
        (cons 
         (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
         (cons 
          (LISP-SPEC::bool t) 
          (cons 
           (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
           (cons (LISP-SPEC::bool t) nil)))))))) 
    nil)))
          
(defparameter SPECCALC::declare_sort 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-SORT"))
                                                
(defparameter SPECCALC::declare_subsorts 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-SUBSORTS"))
                                                    
(defparameter SPECCALC::arithmeticSorts 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_sort 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Integer")) 
      (cons 
       (LISP-SPEC::|!symbol| "KEYWORD" "IFF") 
       (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "INTEGER")) nil))))) 
   (cons 
    (LISP-SPEC::|!list| 
     (cons 
      SPECCALC::declare_sort 
      (cons 
       (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Nat")) 
       (cons 
        (LISP-SPEC::|!symbol| "KEYWORD" "IFF") 
        (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "NATURAL")) nil))))) 
    (cons 
     (LISP-SPEC::|!list| 
      (cons 
       SPECCALC::declare_sort 
       (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "PosNat")) nil))) 
     (cons 
      (LISP-SPEC::|!list| 
       (cons 
        SPECCALC::declare_sort 
        (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "LOGICAL")) nil))) 
      (cons 
       (LISP-SPEC::|!list| 
        (cons 
         SPECCALC::declare_sort 
         (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Char")) nil))) 
       (cons 
        (LISP-SPEC::|!list| 
         (cons 
          SPECCALC::declare_sort 
          (cons 
           (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "String")) 
           nil))) 
        (cons 
         (LISP-SPEC::|!list| 
          (cons 
           SPECCALC::declare_subsorts 
           (cons 
            (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Integer")) 
            (cons 
             (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Nat")) 
             (cons 
              (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "PosNat")) 
              nil))))) 
         (cons 
          (LISP-SPEC::|!list| 
           (cons 
            SPECCALC::declare_subsorts 
            (cons 
             (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Nat")) 
             (cons 
              (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "PosNat")) 
              nil)))) 
          nil)))))))))
                      
(defun SPECCALC::printNamesInAQualifierMap (qmap) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((str (svref x 3))) 
        (let ((qid (METASLANG::printQualifierDotId (svref x 0) (svref x 1)))) 
          (if (string=  str "") 
              qid 
              (STRING-SPEC::^ (STRING-SPEC::^ str ", ") qid))))) 
   "" 
   qmap))
         
(defun SPECCALC::warnAboutMissingItems-1 (should_be_empty_spec) 
  (let ((sorts_msg 
         (SPECCALC::printNamesInAQualifierMap (svref should_be_empty_spec 3)))) 
    (let ((ops_msg 
           (SPECCALC::printNamesInAQualifierMap (svref should_be_empty_spec 1)))) 
      (let ((props_msg 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x) 
                 (let ((pV7044 (cdr x))) 
                   (block 
                    nil 
                    (let ((pV7046 (svref (car x) 1))) 
                      (return 
                       (if (string=  pV7044 "") 
                           pV7046 
                           (STRING-SPEC::^ (STRING-SPEC::^ pV7044 ", ") pV7046)))) 
                    (error 
                     "Nonexhaustive match failure in warnAboutMissingItems")))) 
              "" 
              (svref should_be_empty_spec 2)))) 
        (STRING-SPEC::^ 
         (STRING-SPEC::^ 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ 
            "
" 
            (if (string=  sorts_msg "") 
                "" 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  "  These sorts from the domain of the morphism are not in the source spec: " 
                  sorts_msg) 
                 "
"))) 
           (if (string=  ops_msg "") 
               "" 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 "  These ops from the domain of the morphism are not in the source spec: " 
                 ops_msg) 
                "
"))) 
          (if (string=  props_msg "") 
              "" 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                "  These axioms, etc. from the domain of the morphism are not in the source spec: " 
                props_msg) 
               "
"))) 
         "  in substitution term")))))
                                      
(defun SPECCALC::|!when| (p) 
  #'(lambda (command) 
     (if p #'(lambda (s) (funcall command s)) (SPECCALC::|!return| nil))))
                                                                          
(defparameter STANDARDSPEC::emptyProperties emptyAProperties)
                                                             
(defun SPECCALC::attemptSubstitution-1 (original_spec) 
  #'(lambda (sm) 
     #'(lambda (sm_tm) 
        #'(lambda (term_pos) 
           (let ((sub_spec (SPECCALC::dom-1 sm))) 
             (let ((should_be_empty_spec 
                    (subtractSpec-1-1 sub_spec original_spec))) 
               (SPECCALC::monadSeq 
                (funcall (SPECCALC::|!when| 
                          (lisp::or 
                           (BOOLEAN-SPEC::~ 
                            (slang-built-in::slang-term-equals 
                             (svref should_be_empty_spec 3) 
                             emptyASortMap)) 
                           (lisp::or 
                            (BOOLEAN-SPEC::~ 
                             (slang-built-in::slang-term-equals 
                              (svref should_be_empty_spec 1) 
                              emptyAOpMap)) 
                            (BOOLEAN-SPEC::~ 
                             (slang-built-in::slang-term-equals 
                              (svref should_be_empty_spec 2) 
                              STANDARDSPEC::emptyProperties))))) 
                         (SPECCALC::raise 
                          (cons 
                           :|TypeCheck| 
                           (cons 
                            term_pos 
                            (SPECCALC::warnAboutMissingItems-1 
                             should_be_empty_spec))))) 
                (funcall (funcall (funcall (SPECCALC::applySubstitution-1 sm) 
                                           original_spec) 
                                  sm_tm) 
                         term_pos))))))))
                                         
(defun SPECCALC::attemptSubstitution (x0 x1 x2 x3) 
  (SPECCALC::attemptSubstitution-1 (vector x0 x1 x2 x3)))
                                                         
(defun SPECCALC::attemptSubstitution-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::attemptSubstitution-1 x1) x2) 
                             x3) 
                    x4) 
           x5))
               
(defun SPECCALC::auxTranslateSpec (x0 x1 x2 x3) 
  (SPECCALC::auxTranslateSpec-1 (vector x0 x1 x2 x3)))
                                                      
(defun SPECCALC::auxTranslateSpec-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::auxTranslateSpec-1 x1) x2) x3) x4))
                                                                           
(defparameter SPECCALC::snark_assert (LISP-SPEC::|!symbol| "SNARK" "ASSERT"))
                                                                             
(defparameter SPECCALC::baseAxioms 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::snark_assert 
     (cons 
      (LISP-SPEC::|!quote| 
       (LISP-SPEC::|!list| 
        (cons 
         (LISP-SPEC::|!symbol| "SNARK" "ALL") 
         (cons 
          (LISP-SPEC::|!list| 
           (cons 
            (LISP-SPEC::|!list| 
             (cons 
              (LISP-SPEC::|!symbol| "SNARK" "?X") 
              (cons 
               (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
               (cons (LISP-SPEC::|!symbol| "SNARK" "Option") nil)))) 
            nil)) 
          (cons 
           (LISP-SPEC::|!list| 
            (cons 
             (LISP-SPEC::|!symbol| "SNARK" "OR") 
             (cons 
              (LISP-SPEC::|!list| 
               (cons 
                (LISP-SPEC::|!symbol| "SNARK" "embed?") 
                (cons 
                 (LISP-SPEC::|!symbol| "SNARK" "Some") 
                 (cons (LISP-SPEC::|!symbol| "SNARK" "?X") nil)))) 
              (cons 
               (LISP-SPEC::|!list| 
                (cons 
                 (LISP-SPEC::|!symbol| "SNARK" "embed?") 
                 (cons 
                  (LISP-SPEC::|!symbol| "SNARK" "None") 
                  (cons (LISP-SPEC::|!symbol| "SNARK" "?X") nil)))) 
               nil)))) 
           nil))))) 
      nil))) 
   nil))
        
(defparameter SPECCALC::baseSorts 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_sort 
     (cons (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "Option")) nil))) 
   nil))
        
(defun SPECCALC::baseSpecPath? (path) 
  (block 
   nil 
   (if (null path) 
       (return nil) 
       (if (consp path) 
           (let ((pV5131 (cdr path))
                 (pV5130 (car path))) 
             (progn (if (null pV5131) (return nil)) 
                    (if (string=  "Library" pV5130) 
                        (if (consp pV5131) 
                            (if (string=  "Base" (car pV5131)) 
                                (if (null (cdr pV5131)) (return t))))) 
                    (if (consp pV5131) (if (null (cdr pV5131)) (return nil))) 
                    (if (string=  "Library" pV5130) 
                        (if (consp pV5131) 
                            (let ((pV5134 (cdr pV5131))) 
                              (if (string=  "Base" (car pV5131)) 
                                  (if (consp pV5134) 
                                      (if (null (cdr pV5134)) (return t))))))) 
                    (return (SPECCALC::baseSpecPath? pV5131)))))) 
   (error "Nonexhaustive match failure in baseSpecPath?")))
                                                           
(defun SPECCALC::baseSpecURI?-1 (uri) 
  (block 
   nil 
   (if (eq (car (car uri)) :|None|) (return (SPECCALC::baseSpecPath? (cdr uri)))) 
   (return nil)))
                 
(defun SPECCALC::baseSpecURI? (x0 x1) (SPECCALC::baseSpecURI?-1 (cons x0 x1)))
                                                                              
(defun SPECCALC::bindInGlobalContext-1-1-1 (uri value x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (POLYMAP::update-1-1-1 (svref x 0) uri value) 
    (svref x 1) 
    (svref x 2) 
    (svref x 3))))
                  
(defun SPECCALC::bindInGlobalContext-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::bindInGlobalContext-1-1-1 x1 x2 x3))))
                                                                     
(defun SPECCALC::bindInGlobalContext (x0 x1) 
  (SPECCALC::bindInGlobalContext-1 (cons x0 x1)))
                                                 
(defun SPECCALC::bindInLocalContext-1-1-1 (uri value x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (svref x 0) 
    (POLYMAP::update-1-1-1 (svref x 1) uri value) 
    (svref x 2) 
    (svref x 3))))
                  
(defun SPECCALC::bindInLocalContext (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::bindInLocalContext-1-1-1 x1 x2 x3))))
                                                                    
(defun SPECCALC::bndrString (bndr) 
  (block 
   nil 
   (if (eq (car bndr) :|Forall|) 
       (return "ALL") 
       (if (eq (car bndr) :|Exists|) (return "EXISTS"))) 
   (error "Nonexhaustive match failure in bndrString")))
                                                        
(defun SPECCALC::completeMorphismMap (trans_map dom_map cod_map) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) 
      (let ((new_map (svref x 3))
            (id (svref x 1))
            (qualifier (svref x 0))) 
        (let ((pV5185 (findAQualifierMap trans_map qualifier id))) 
          (block 
           nil 
           (if (eq (car pV5185) :|Some|) 
               (return 
                (POLYMAP::update-1-1-1 
                 new_map 
                 (cons :|Qualified| (cons qualifier id)) 
                 (cdr pV5185)))) 
           (return 
            (let ((pV5183 (findAQualifierMap cod_map qualifier id))) 
              (block 
               nil 
               (if (eq (car pV5183) :|Some|) 
                   (return 
                    (POLYMAP::update-1-1-1 
                     new_map 
                     (cons :|Qualified| (cons qualifier id)) 
                     (cons :|Qualified| (cons qualifier id))))) 
               (return 
                (SYSTEM-SPEC::fail 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ "morphism: No mapping for " qualifier) 
                   ".") 
                  id)))))))))) 
   POLYMAP::emptyMap 
   dom_map))
            
(defun SPECCALC::buildSpecMorphism (pV5162 pV5163 pV5164) 
  (block 
   nil 
   (return 
    (block 
     nil 
     (return 
      (block 
       nil 
       (return 
        (vector 
         pV5163 
         pV5162 
         (SPECCALC::completeMorphismMap 
          (car pV5164) 
          (svref pV5162 1) 
          (svref pV5163 1)) 
         (SPECCALC::completeMorphismMap 
          (cdr pV5164) 
          (svref pV5162 3) 
          (svref pV5163 3)))) 
       (error "Nonexhaustive match failure in buildSpecMorphism"))) 
     (error "Nonexhaustive match failure in buildSpecMorphism"))) 
   (error "Nonexhaustive match failure in buildSpecMorphism")))
                                                               
(defun SPECCALC::buildSpecMorphism-1 (x) 
  (SPECCALC::buildSpecMorphism (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun SPECCALC::|!catch|-1-1-1 (f handler state) 
  (let ((x (funcall f state))) 
    (let ((pV5167 (car x))
          (pV5168 (cdr x))) 
      (block 
       nil 
       (if (eq (car pV5167) :|Ok|) 
           (return (cons (cons :|Ok| (cdr pV5167)) pV5168)) 
           (if (eq (car pV5167) :|Exception|) 
               (return (funcall (funcall handler (cdr pV5167)) pV5168)))) 
       (error "Nonexhaustive match failure in catch")))))
                                                         
(defun SPECCALC::|!catch| (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::|!catch|-1-1-1 x1 x2 x3))))
                                                                      
(defparameter SPECCALC::checkSpecPathsExistence? t)
                                                   
(defparameter SPECCALC::specPathSeparator 
  (if SYSTEM-SPEC::msWindowsSystem? #\; #\:))
                                             
(defun SPECCALC::checkSpecPathsExistence (str) 
  (if SPECCALC::checkSpecPathsExistence? 
      (LIST-SPEC::app-1-1 
       #'(lambda (dir) 
          (if (IO-SPEC::fileExists? dir) 
              nil 
              (SYSTEM-SPEC::|!warn| 
               (STRING-SPEC::^ "Directory does not exist: " dir)))) 
       (SPECCALC::splitStringAtChar-1-1 SPECCALC::specPathSeparator str)) 
      nil))
           
(defun SPECCALC::getGlobalContext
 (globalContext localContext uri validatedURIs) 
  (cons 
   (cons :|Ok| globalContext) 
   (vector globalContext localContext uri validatedURIs)))
                                                          
(defun SPECCALC::getGlobalContext-1 (x) 
  (SPECCALC::getGlobalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                               
(defun SPECCALC::setGlobalContext-1-1 (newGlobalContext x) 
  (cons 
   (cons :|Ok| nil) 
   (vector newGlobalContext (svref x 1) (svref x 2) (svref x 3))))
                                                                  
(defun SPECCALC::setGlobalContext (x1) 
  #'(lambda (x2) (SPECCALC::setGlobalContext-1-1 x1 x2)))
                                                         
(defun SPECCALC::cleanupGlobalContext (x2 x1 x0 x) 
  (SPECCALC::monadBind-1-1 
   (cons 
    #'SPECCALC::getGlobalContext-1 
    #'(lambda (gCtxt) 
       (SPECCALC::setGlobalContext 
        (POLYMAP::mapPartial-1-1 
         #'(lambda (x) 
            (block 
             nil 
             (if (eq (car (svref x 0)) :|InProcess|) (return '(:|None|))) 
             (return (cons :|Some| (vector (svref x 0) (svref x 1) (svref x 2)))))) 
         gCtxt)))) 
   (vector x2 x1 x0 x)))
                        
(defun SPECCALC::cleanupGlobalContext-1 (x) 
  (SPECCALC::cleanupGlobalContext 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECCALC::setLocalContext-1-1 (newLocalContext x) 
  (cons 
   (cons :|Ok| nil) 
   (vector (svref x 0) newLocalContext (svref x 2) (svref x 3))))
                                                                 
(defun SPECCALC::clearLocalContext (x2 x1 x0 x) 
  (SPECCALC::setLocalContext-1-1 POLYMAP::emptyMap (vector x2 x1 x0 x)))
                                                                        
(defun SPECCALC::clearLocalContext-1 (x) 
  (SPECCALC::clearLocalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                                
(defun SPECCALC::cod (x0 x1 x2 x3) (SPECCALC::cod-1 (vector x0 x1 x2 x3)))
                                                                          
(defun SPECCALC::coerceToSpec (value) 
  (block 
   nil 
   (if (eq (car value) :|Morph|) 
       (return 
        (let ((x (SPECCALC::cod-1 (cdr value)))) 
          (cons :|Spec| (vector (svref x 0) (svref x 1) (svref x 2) (svref x 3))))) 
       (if (eq (car value) :|Colimit|) 
           (return 
            (let ((x (CAT::apex-1 (CAT::cocone-1 (cdr value))))) 
              (cons 
               :|Spec| 
               (vector (svref x 0) (svref x 1) (svref x 2) (svref x 3))))))) 
   (return value)))
                   
(defun SPECCALC::completeMorphismMap-1 (x) 
  (SPECCALC::completeMorphismMap (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defun SPECCALC::compose-1-1 (mor1 mor2) 
  (vector 
   (svref mor2 0) 
   (svref mor1 1) 
   (POLYMAP::compose-1-1 (svref mor1 2) (svref mor2 2)) 
   (POLYMAP::compose-1-1 (svref mor1 3) (svref mor2 3))))
                                                         
(defun SPECCALC::compose-1 (x1) 
  #'(lambda (x2) (SPECCALC::compose-1-1 x1 x2)))
                                                
(defun SPECCALC::compose (x0 x1 x2 x3) 
  (SPECCALC::compose-1 (vector x0 x1 x2 x3)))
                                             
(defun SPECCALC::computeQuotientSet-1-1-1 (dg non_base_items sm_qid_map) 
  (let ((initial_mfset_vqid_map 
         (CAT::foldOverVertices-1-1-1 
          #'(lambda (mfset_map) 
             #'(lambda (vertex) 
                (LIST-SPEC::foldl-1-1-1 
                 #'(lambda (x) 
                    (let ((pV5187 (car x))) 
                      (block 
                       nil 
                       (return 
                        (MFSET::augmentMFSetMap-1-1 
                         (cdr x) 
                         (cons 
                          vertex 
                          (cons 
                           :|Qualified| 
                           (cons (svref pV5187 0) (svref pV5187 1)))))) 
                       (error 
                        "Nonexhaustive match failure in computeQuotientSet")))) 
                 mfset_map 
                 (funcall non_base_items (CAT::vertexLabel-1-1 dg vertex))))) 
          MFSET::emptyMFSetMap 
          dg))) 
    (let ((final_mfset_vqid_map 
           (let ((sketch (CAT::shape-1 dg))) 
             (let ((source_fn (SKETCH::|!eval| (SKETCH::src-1 sketch)))) 
               (let ((target_fn (SKETCH::|!eval| (SKETCH::target-1 sketch)))) 
                 (CAT::foldOverEdges-1-1-1 
                  #'(lambda (mfset_map) 
                     #'(lambda (edge) 
                        (let ((sm (CAT::edgeLabel-1-1 dg edge))) 
                          (let ((source_vertex (funcall source_fn edge))) 
                            (let ((target_vertex (funcall target_fn edge))) 
                              (POLYMAP::foldMap-1-1-1 
                               #'(lambda (mfset_map) 
                                  #'(lambda (dom_qid) 
                                     #'(lambda (cod_qid) 
                                        (let ((pV5194 
                                               (POLYMAP::evalPartial-1-1 
                                                mfset_map 
                                                (cons source_vertex dom_qid)))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV5194) :|None|) 
                                               (return mfset_map) 
                                               (if (eq (car pV5194) :|Some|) 
                                                   (return 
                                                    (let ((pV5192 
                                                           (POLYMAP::evalPartial-1-1 
                                                            mfset_map 
                                                            (cons 
                                                             target_vertex 
                                                             cod_qid)))) 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV5192) 
                                                            :|None|) 
                                                           (return mfset_map) 
                                                           (if (eq 
                                                                (car pV5192) 
                                                                :|Some|) 
                                                               (return 
                                                                (MFSET::|!merge|-1-1-1 
                                                                 mfset_map 
                                                                 (cdr pV5194) 
                                                                 (cdr pV5192))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in computeQuotientSet")))))) 
                                           (error 
                                            "Nonexhaustive match failure in computeQuotientSet")))))) 
                               mfset_map 
                               (funcall sm_qid_map sm))))))) 
                  initial_mfset_vqid_map 
                  dg)))))) (MFSET::extractQuotientSet final_mfset_vqid_map))))
                                                                              
(defun SPECCALC::computeQuotientSet-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::computeQuotientSet-1-1-1 x1 x2 x3))))
                                                                    
(defun SPECCALC::computeQuotientSet (x0 x1) 
  (SPECCALC::computeQuotientSet-1 (cons x0 x1)))
                                                
(defun SPECCALC::makeIdToQualifiersMap (qset) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (LIST-SPEC::foldl-1-1-1 
       #'(lambda (x1) 
          (let ((pV5694 (cdr x1))) 
            (block 
             nil 
             (let ((pV5696 (cdr (car x1)))) 
               (if (eq (car pV5696) :|Qualified|) 
                   (let ((pV5697 (cdr pV5696))) 
                     (let ((pV5699 (cdr pV5697))
                           (pV5698 (car pV5697))) 
                       (return 
                        (let ((pV5691 (POLYMAP::evalPartial-1-1 pV5694 pV5699))) 
                          (block 
                           nil 
                           (if (eq (car pV5691) :|None|) 
                               (return 
                                (POLYMAP::update-1-1-1 
                                 pV5694 
                                 pV5699 
                                 (cons pV5698 nil))) 
                               (if (eq (car pV5691) :|Some|) 
                                   (let ((pV5692 (cdr pV5691))) 
                                     (return 
                                      (if (LIST-SPEC::|!member| pV5698 pV5692) 
                                          pV5694 
                                          (POLYMAP::update-1-1-1 
                                           pV5694 
                                           pV5699 
                                           (cons pV5698 pV5692))))))) 
                           (error 
                            "Nonexhaustive match failure in makeIdToQualifiersMap")))))))) 
             (error "Nonexhaustive match failure in makeIdToQualifiersMap")))) 
       (cdr x) 
       (car x))) 
   POLYMAP::emptyMap 
   qset))
         
(defun SPECCALC::makeQidToClassIndicesMap (qset) 
  (let ((pV5711 
         (LIST-SPEC::foldl-1-1-1 
          #'(lambda (x) 
             (let ((pV5708 (cdr x))) 
               (block 
                nil 
                (let ((pV5710 (cdr pV5708))) 
                  (return 
                   (cons 
                    (LIST-SPEC::foldl-1-1-1 
                     #'(lambda (x1) 
                        (let ((qid_to_class_indices (cdr x1))) 
                          (let ((qid (cdr (car x1)))) 
                            (let ((pV5702 
                                   (POLYMAP::evalPartial-1-1 
                                    qid_to_class_indices 
                                    qid))) 
                              (block 
                               nil 
                               (if (eq (car pV5702) :|None|) 
                                   (return 
                                    (POLYMAP::update-1-1-1 
                                     qid_to_class_indices 
                                     qid 
                                     (cons pV5710 nil))) 
                                   (if (eq (car pV5702) :|Some|) 
                                       (let ((pV5703 (cdr pV5702))) 
                                         (if (consp pV5703) 
                                             (return 
                                              (if ( =  pV5710 (car pV5703)) 
                                                  qid_to_class_indices 
                                                  (POLYMAP::update-1-1-1 
                                                   qid_to_class_indices 
                                                   qid 
                                                   (cons pV5710 pV5703)))))))) 
                               (error 
                                "Nonexhaustive match failure in makeQidToClassIndicesMap")))))) 
                     (car pV5708) 
                     (car x)) 
                    (INTEGER-SPEC::|!+| pV5710 1)))) 
                (error "Nonexhaustive match failure in makeQidToClassIndicesMap")))) 
          (cons POLYMAP::emptyMap 0) 
          qset))) 
    (block 
     nil 
     (return (car pV5711)) 
     (error "Nonexhaustive match failure in makeQidToClassIndicesMap"))))
                                                                         
(defun SPECCALC::vertexName (v) v)
                                  
(defun SPECCALC::reviseQId (vertex qualifier id id_to_qualifiers) 
  (let ((qualifiers_to_avoid (POLYMAP::|!eval|-1-1 id_to_qualifiers id))) 
    (labels 
      ((revised (old_qualifier) 
        (let ((new_qualifier 
               (if (string=  old_qualifier METASLANG::UnQualified) 
                   (SPECCALC::vertexName vertex) 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ (SPECCALC::vertexName vertex) "_") 
                    old_qualifier)))) 
          (if (LIST-SPEC::|!member| new_qualifier qualifiers_to_avoid) 
              (revised new_qualifier) 
              new_qualifier)))) 
      (cons :|Qualified| (cons (revised qualifier) id)))))
                                                          
(defun SPECCALC::computeVQidToApexQidAndAliasesMap (qset) 
  (let ((qid_to_class_indices (SPECCALC::makeQidToClassIndicesMap qset))) 
    (let ((id_to_qualifiers (SPECCALC::makeIdToQualifiersMap qset))) 
      (LIST-SPEC::foldl-1-1-1 
       #'(lambda (x) 
          (let ((|!class| (car x))) 
            (let ((pV5211 
                   (LIST-SPEC::foldl-1-1-1 
                    #'(lambda (x1) 
                       (let ((pV5203 (cdr x1))
                             (pV5202 (car x1))) 
                         (block 
                          nil 
                          (let ((pV5205 (cdr pV5202))) 
                            (if (eq (car pV5205) :|Qualified|) 
                                (let ((pV5206 (cdr pV5205))) 
                                  (return 
                                   (let ((apex_qid 
                                          (let ((pV5198 
                                                 (POLYMAP::|!eval|-1-1 
                                                  qid_to_class_indices 
                                                  pV5205))) 
                                            (block 
                                             nil 
                                             (if (consp pV5198) 
                                                 (if (null (cdr pV5198)) 
                                                     (return pV5205))) 
                                             (return 
                                              (SPECCALC::reviseQId 
                                               (car pV5202) 
                                               (car pV5206) 
                                               (cdr pV5206) 
                                               id_to_qualifiers)))))) 
                                     (cons 
                                      (LIST-SPEC::|!cons| apex_qid (car pV5203)) 
                                      (POLYMAP::update-1-1-1 
                                       (cdr pV5203) 
                                       pV5202 
                                       apex_qid))))))) 
                          (error 
                           "Nonexhaustive match failure in computeVQidToApexQidAndAliasesMap")))) 
                    (cons nil POLYMAP::emptyMap) 
                    |!class|))) 
              (block 
               nil 
               (let ((pV5213 (cdr pV5211))
                     (pV5212 (car pV5211))) 
                 (return 
                  (LIST-SPEC::foldl-1-1-1 
                   #'(lambda (x1) 
                      (let ((vqid (car x1))) 
                        (POLYMAP::update-1-1-1 
                         (cdr x1) 
                         vqid 
                         (cons (POLYMAP::|!eval|-1-1 pV5213 vqid) pV5212)))) 
                   (cdr x) 
                   |!class|))) 
               (error 
                "Nonexhaustive match failure in computeVQidToApexQidAndAliasesMap"))))) 
       POLYMAP::emptyMap 
       qset))))
               
(defun SPECCALC::convertOpRules (translate_rules) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (let ((pV5219 (car (car x)))) 
         (if (eq (car pV5219) :|Op|) 
             (let ((pV5221 (cdr pV5219))) 
               (return 
                (POLYMAP::update-1-1-1 
                 (cdr x) 
                 (car (svref pV5221 0)) 
                 (car (svref pV5221 1))))))) 
       (error "Nonexhaustive match failure in convertOpRules"))) 
   POLYMAP::emptyMap 
   translate_rules))
                    
(defun SPECCALC::convertSortRules (translate_rules) 
  (LIST-SPEC::foldl-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (let ((pV5232 (car (car x)))) 
         (if (eq (car pV5232) :|Sort|) 
             (let ((pV5234 (cdr pV5232))) 
               (return 
                (POLYMAP::update-1-1-1 (cdr x) (svref pV5234 0) (svref pV5234 1)))))) 
       (error "Nonexhaustive match failure in convertSortRules"))) 
   POLYMAP::emptyMap 
   translate_rules))
                    
(defun SPECCALC::countKeysInAQualifierMap (qmap) 
  (foldriAQualifierMap-1-1-1 
   #'(lambda (x) (INTEGER-SPEC::|!+| (svref x 3) 1)) 
   0 
   qmap))
         
(defparameter SPECCALC::declare_constant 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-CONSTANT-SYMBOL"))
                                                           
(defparameter SPECCALC::declare_predicate 
  (LISP-SPEC::|!symbol| "SNARK" "DECLARE-PREDICATE-SYMBOL"))
                                                            
(defun SPECCALC::displayMultipleAnonymousProofResult
 (proof_name claim_type claim_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ (STRING-SPEC::^ proof_name ": ") claim_type) 
                " ") 
               claim_name) 
              " ") 
             provedString)) 
           proved)))
                    
(defun SPECCALC::displayMultipleAnonymousProofResult-1 (x) 
  (SPECCALC::displayMultipleAnonymousProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECCALC::displayMultipleProofResult
 (proof_name claim_type claim_name spec_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ (STRING-SPEC::^ proof_name ": ") claim_type) 
                  " ") 
                 claim_name) 
                " in ") 
               spec_name) 
              " ") 
             provedString)) 
           proved)))
                    
(defun SPECCALC::displayMultipleProofResult-1 (x) 
  (SPECCALC::displayMultipleProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun SPECCALC::displaySingleAnonymousProofResult
 (claim_type claim_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ (STRING-SPEC::^ claim_type " ") claim_name) 
              " ") 
             provedString)) 
           proved)))
                    
(defun SPECCALC::displaySingleProofResult
 (claim_type claim_name spec_name proved) 
  (let ((provedString (if proved "is Proved!" "is NOT proved."))) 
    (progn (STRING-SPEC::writeLine 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ (STRING-SPEC::^ claim_type " ") claim_name) 
                " in ") 
               spec_name) 
              " ") 
             provedString)) 
           proved)))
                    
(defun SPECCALC::displayProofResult
 (proof_name claim_type claim_name spec_name proved snarkLogFileName) 
  (progn (block 
          nil 
          (if (eq (car proof_name) :|None|) 
              (return 
               (block 
                nil 
                (if (eq (car spec_name) :|None|) 
                    (return 
                     (SPECCALC::displaySingleAnonymousProofResult 
                      claim_type 
                      claim_name 
                      proved)) 
                    (if (eq (car spec_name) :|Some|) 
                        (return 
                         (SPECCALC::displaySingleProofResult 
                          claim_type 
                          claim_name 
                          (cdr spec_name) 
                          proved)))) 
                (error "Nonexhaustive match failure in displayProofResult"))) 
              (if (eq (car proof_name) :|Some|) 
                  (let ((pV5249 (cdr proof_name))) 
                    (return 
                     (block 
                      nil 
                      (if (eq (car spec_name) :|None|) 
                          (return 
                           (SPECCALC::displayMultipleAnonymousProofResult 
                            pV5249 
                            claim_type 
                            claim_name 
                            proved)) 
                          (if (eq (car spec_name) :|Some|) 
                              (return 
                               (SPECCALC::displayMultipleProofResult 
                                pV5249 
                                claim_type 
                                claim_name 
                                (cdr spec_name) 
                                proved)))) 
                      (error "Nonexhaustive match failure in displayProofResult")))))) 
          (error "Nonexhaustive match failure in displayProofResult")) 
         (progn (STRING-SPEC::writeLine 
                 (STRING-SPEC::^ "    Snark Log file: " snarkLogFileName)) 
                proved)))
                         
(defun SPECCALC::displayProofResult-1 (x) 
  (SPECCALC::displayProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun SPECCALC::displaySingleAnonymousProofResult-1 (x) 
  (SPECCALC::displaySingleAnonymousProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2)))
                
(defun SPECCALC::displaySingleProofResult-1 (x) 
  (SPECCALC::displaySingleProofResult 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECCALC::dom (x0 x1 x2 x3) (SPECCALC::dom-1 (vector x0 x1 x2 x3)))
                                                                          
(defun SPECCALC::getCurrentURI-1 (state) 
  (let ((optURI (svref state 2))) 
    (block 
     nil 
     (if (eq (car optURI) :|None|) 
         (return 
          (cons (cons :|Exception| (cons :|Fail| "No current URI")) state)) 
         (if (eq (car optURI) :|Some|) 
             (let ((pV5590 (cdr optURI))) 
               (return 
                (cons (cons :|Ok| (cons (car pV5590) (cdr pV5590))) state))))) 
     (error "Nonexhaustive match failure in getCurrentURI"))))
                                                              
(defun SPECCALC::hackMemory-1-1 (pV5598 state) 
  (declare (ignore pV5598)) 
  (progn (SYSTEM-SPEC::hackMemory) (cons (cons :|Ok| nil) state)))
                                                                  
(defun SPECCALC::hackMemory-1 (x1) 
  #'(lambda (x2) (SPECCALC::hackMemory-1-1 x1 x2)))
                                                   
(defun SPECCALC::hackMemory () (SPECCALC::hackMemory-1 nil))
                                                            
(defun SPECCALC::uriToPath-1 (x) (SPECCALC::uriToPath (car x) (cdr x)))
                                                                       
(defun TYPECHECKER::checkDifferent (tvs setOfUniqueIds) 
  (block 
   nil 
   (if (null tvs) 
       (return t) 
       (if (consp tvs) 
           (let ((pV9777 (car tvs))) 
             (return 
              (if (STRINGSET::|!member| setOfUniqueIds pV9777) 
                  nil 
                  (TYPECHECKER::checkDifferent 
                   (cdr tvs) 
                   (STRINGSET::add setOfUniqueIds pV9777))))))) 
   (error "Nonexhaustive match failure in checkDifferent")))
                                                            
(defun STANDARDSPEC::wildFindUnQualified (qualifier_map id) 
  (STRINGMAP::foldri-1-1-1 
   #'(lambda (x) 
      (let ((results (svref x 2))) 
        (let ((pV9391 (STRINGMAP::|!find| (svref x 1) id))) 
          (block 
           nil 
           (if (eq (car pV9391) :|Some|) 
               (return (LIST-SPEC::|!++| results (cons (cdr pV9391) nil))) 
               (if (eq (car pV9391) :|None|) (return results))) 
           (error "Nonexhaustive match failure in wildFindUnQualified"))))) 
   nil 
   qualifier_map))
                  
(defun STANDARDSPEC::findAllSorts (pV9308 pV9309) 
  (block 
   nil 
   (if (eq (car pV9309) :|Qualified|) 
       (let ((pV9310 (cdr pV9309))) 
         (let ((pV9312 (cdr pV9310))
               (pV9311 (car pV9310))) 
           (return 
            (let ((found 
                   (let ((pV9306 
                          (findAQualifierMap (svref pV9308 3) pV9311 pV9312))) 
                     (block 
                      nil 
                      (if (eq (car pV9306) :|Some|) 
                          (return (cons (cdr pV9306) nil)) 
                          (if (eq (car pV9306) :|None|) (return nil))) 
                      (error "Nonexhaustive match failure in findAllSorts"))))) 
              (if (string=  pV9311 METASLANG::UnQualified) 
                  (LIST-SPEC::|!++| 
                   found 
                   (LIST-SPEC::filter-1-1 
                    #'(lambda (op_info) 
                       (BOOLEAN-SPEC::~ (LIST-SPEC::|!member| op_info found))) 
                    (STANDARDSPEC::wildFindUnQualified (svref pV9308 3) pV9312))) 
                  found)))))) 
   (error "Nonexhaustive match failure in findAllSorts")))
                                                          
(defun UTILITIES::unlinkPSort (srt) 
  (block 
   nil 
   (if (eq (car srt) :|MetaTyVar|) 
       (return 
        (let ((x (STATE::|!!| (car (cdr srt))))) 
          (let ((pV12231 (svref x 0))) 
            (block 
             nil 
             (if (eq (car pV12231) :|Some|) 
                 (return (UTILITIES::unlinkPSort (cdr pV12231)))) 
             (return srt)))))) 
   (return srt)))
                 
(defun UTILITIES::|!error| (pV10933 pV10934 pV10935) 
  (block 
   nil 
   (let ((pV10937 (svref pV10933 1))) 
     (return 
      (STATE::|:=| 
       pV10937 
       (LIST-SPEC::|!cons| (cons pV10934 pV10935) (STATE::|!!| pV10937))))) 
   (error "Nonexhaustive match failure in error")))
                                                   
(defun TYPECHECKER::adjustEqualitySort (env srt t1 eq_args) 
  (let ((pV9424 (UTILITIES::unlinkPSort srt))) 
    (block 
     nil 
     (if (eq (car eq_args) :|Record|) 
         (let ((pV9426 (car (cdr eq_args)))) 
           (if (consp pV9426) 
               (let ((pV9430 (cdr pV9426))) 
                 (if (string=  "1" (car (car pV9426))) 
                     (if (consp pV9430) 
                         (if (string=  "2" (car (car pV9430))) 
                             (if (null (cdr pV9430)) 
                                 (if (eq (car pV9424) :|Arrow|) 
                                     (let ((pV9439 (svref (cdr pV9424) 0))) 
                                       (if (eq (car pV9439) :|Product|) 
                                           (let ((pV9443 (car (cdr pV9439)))) 
                                             (if (consp pV9443) 
                                                 (let ((pV9447 (cdr pV9443))) 
                                                   (if (string=  
                                                        "1" 
                                                        (car (car pV9443))) 
                                                       (if (consp pV9447) 
                                                           (if (string=  
                                                                "2" 
                                                                (car 
                                                                 (car pV9447))) 
                                                               (if (null 
                                                                    (cdr pV9447)) 
                                                                   (return t1))))))))))))))))))) 
     (return 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               "Illegal Equality" 
               (ANNSPECPRINTER::printTerm eq_args)) 
              (METASLANG::sortAnn srt)) 
             t1)))))
                    
(defun TYPECHECKER::consistentInfixPTerms (competing_pterms optional_priority) 
  (block 
   nil 
   (if (null competing_pterms) 
       (return (cons t optional_priority)) 
       (if (consp competing_pterms) 
           (let ((pV9855 (cdr competing_pterms))
                 (pV9854 (car competing_pterms))) 
             (progn (if (eq (car pV9854) :|Fun|) 
                        (let ((pV9857 (svref (cdr pV9854) 0))) 
                          (if (eq (car pV9857) :|OneName|) 
                              (let ((pV9867 (cdr (cdr pV9857)))) 
                                (if (consp pV9867) 
                                    (return 
                                     (block 
                                      nil 
                                      (if (eq (car optional_priority) :|None|) 
                                          (return (cons nil '(:|None|))) 
                                          (if (eq 
                                               (car optional_priority) 
                                               :|Some|) 
                                              (return 
                                               (if (slang-built-in::slang-term-equals 
                                                    pV9867 
                                                    (cdr optional_priority)) 
                                                   (TYPECHECKER::consistentInfixPTerms 
                                                    pV9855 
                                                    optional_priority) 
                                                   (cons nil '(:|None|)))))) 
                                      (error 
                                       "Nonexhaustive match failure in consistentInfixPTerms"))))) 
                              (if (eq (car pV9857) :|TwoNames|) 
                                  (let ((pV9864 (svref (cdr pV9857) 2))) 
                                    (if (consp pV9864) 
                                        (return 
                                         (block 
                                          nil 
                                          (if (eq 
                                               (car optional_priority) 
                                               :|None|) 
                                              (return (cons nil '(:|None|))) 
                                              (if (eq 
                                                   (car optional_priority) 
                                                   :|Some|) 
                                                  (return 
                                                   (if (slang-built-in::slang-term-equals 
                                                        pV9864 
                                                        (cdr optional_priority)) 
                                                       (TYPECHECKER::consistentInfixPTerms 
                                                        pV9855 
                                                        optional_priority) 
                                                       (cons nil '(:|None|)))))) 
                                          (error 
                                           "Nonexhaustive match failure in consistentInfixPTerms"))))))))) 
                    (return 
                     (block 
                      nil 
                      (if (eq (car optional_priority) :|None|) 
                          (return 
                           (TYPECHECKER::consistentInfixPTerms 
                            pV9855 
                            optional_priority))) 
                      (return (cons nil '(:|None|))))))))) 
   (error "Nonexhaustive match failure in consistentInfixPTerms")))
                                                                   
(defun TYPECHECKER::consistentTag (competing_pterms) 
  (block 
   nil 
   (if (consp competing_pterms) 
       (let ((pV9886 (cdr competing_pterms))
             (pV9885 (car competing_pterms))) 
         (progn (if (eq (car pV9885) :|Fun|) 
                    (let ((pV9888 (svref (cdr pV9885) 0))) 
                      (if (eq (car pV9888) :|OneName|) 
                          (let ((pV9898 (cdr (cdr pV9888)))) 
                            (if (consp pV9898) 
                                (return 
                                 (TYPECHECKER::consistentInfixPTerms 
                                  pV9886 
                                  (cons :|Some| (cons (car pV9898) (cdr pV9898))))))) 
                          (if (eq (car pV9888) :|TwoNames|) 
                              (let ((pV9895 (svref (cdr pV9888) 2))) 
                                (if (consp pV9895) 
                                    (return 
                                     (TYPECHECKER::consistentInfixPTerms 
                                      pV9886 
                                      (cons 
                                       :|Some| 
                                       (cons (car pV9895) (cdr pV9895))))))))))) 
                (return (TYPECHECKER::consistentInfixPTerms pV9886 '(:|None|)))))) 
   (return (cons t '(:|None|)))))
                                 
(defun TYPECHECKER::blankString (n) 
  (if (INTEGER-SPEC::|!<=| n 0) 
      "" 
      (if (INTEGER-SPEC::|!<| n 100) 
          (STRING-SPEC::substring 
           "                                                                                                    " 
           0 
           n) 
          (STRING-SPEC::^ 
           "                                                                                                    " 
           (TYPECHECKER::blankString (INTEGER-SPEC::|!-| n 100))))))
                                                                    
(defun TYPECHECKER::newLines (lines) 
  (block 
   nil 
   (if (null lines) 
       (return "") 
       (if (consp lines) 
           (let ((pV10230 (cdr lines))
                 (pV10229 (car lines))) 
             (progn (if (null pV10230) (return pV10229)) 
                    (return 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        pV10229 
                        (CHAR-SPEC::toString (CHAR-SPEC::chr 10))) 
                       "          ") 
                      (TYPECHECKER::newLines pV10230))))))) 
   (error "Nonexhaustive match failure in newLines")))
                                                      
(defun UTILITIES::linkMetaTyVar-1-1 (v |!t|) 
  (let ((pV11313 (STATE::|!!| v))) 
    (block 
     nil 
     (return 
      (STATE::|:=| 
       v 
       (vector (cons :|Some| |!t|) (svref pV11313 1) (svref pV11313 2)))) 
     (error "Nonexhaustive match failure in linkMetaTyVar"))))
                                                              
(defun UTILITIES::occursT (v pred) 
  (block 
   nil 
   (if (eq (car pred) :|ApplyN|) 
       (return 
        (LIST-SPEC::|!exists|-1-1 
         #'(lambda (|!M|) (UTILITIES::occursT v |!M|)) 
         (car (cdr pred)))) 
       (if (eq (car pred) :|Record|) 
           (return 
            (LIST-SPEC::|!exists|-1-1 
             #'(lambda (x) (UTILITIES::occursT v (cdr x))) 
             (car (cdr pred)))) 
           (if (eq (car pred) :|Bind|) 
               (let ((pV11600 (cdr pred))) 
                 (return 
                  (lisp::or 
                   (LIST-SPEC::|!exists|-1-1 
                    #'(lambda (x) (UTILITIES::occurs v (cdr x))) 
                    (svref pV11600 1)) 
                   (UTILITIES::occursT v (svref pV11600 2))))) 
               (if (eq (car pred) :|IfThenElse|) 
                   (let ((pV11599 (cdr pred))) 
                     (return 
                      (lisp::or 
                       (UTILITIES::occursT v (svref pV11599 0)) 
                       (lisp::or 
                        (UTILITIES::occursT v (svref pV11599 1)) 
                        (UTILITIES::occursT v (svref pV11599 2)))))) 
                   (if (eq (car pred) :|Var|) 
                       (return (UTILITIES::occurs v (cdr (car (cdr pred))))) 
                       (if (eq (car pred) :|Fun|) 
                           (return (UTILITIES::occurs v (svref (cdr pred) 1))) 
                           (if (eq (car pred) :|Seq|) 
                               (return 
                                (LIST-SPEC::|!exists|-1-1 
                                 #'(lambda (|!M|) (UTILITIES::occursT v |!M|)) 
                                 (car (cdr pred)))) 
                               (if (eq (car pred) :|Let|) 
                                   (let ((pV11595 (cdr pred))) 
                                     (return 
                                      (lisp::or 
                                       (UTILITIES::occursT v (svref pV11595 1)) 
                                       (LIST-SPEC::|!exists|-1-1 
                                        #'(lambda (x) 
                                           (UTILITIES::occursT v (cdr x))) 
                                        (svref pV11595 0))))) 
                                   (if (eq (car pred) :|LetRec|) 
                                       (let ((pV11594 (cdr pred))) 
                                         (return 
                                          (lisp::or 
                                           (UTILITIES::occursT 
                                            v 
                                            (svref pV11594 1)) 
                                           (LIST-SPEC::|!exists|-1-1 
                                            #'(lambda (x) 
                                               (UTILITIES::occursT v (cdr x))) 
                                            (svref pV11594 0))))) 
                                       (if (eq (car pred) :|Lambda|) 
                                           (return 
                                            (LIST-SPEC::|!exists|-1-1 
                                             #'(lambda (x) 
                                                (UTILITIES::occursT 
                                                 v 
                                                 (svref x 2))) 
                                             (car (cdr pred)))))))))))))) 
   (return nil)))
                 
(defun UTILITIES::occurs (v srt) 
  (labels 
    ((occursRow (v row) 
      (block 
       nil 
       (if (null row) 
           (return nil) 
           (if (consp row) 
               (return 
                (lisp::or 
                 (UTILITIES::occurs v (cdr (car row))) 
                 (occursRow v (cdr row)))))) 
       (error "Nonexhaustive match failure in occurs")))
     (occursOptRow (v row) 
      (block 
       nil 
       (if (null row) 
           (return nil) 
           (if (consp row) 
               (let ((pV11526 (cdr row))) 
                 (let ((pV11528 (cdr (car row)))) 
                   (if (eq (car pV11528) :|Some|) 
                       (return 
                        (lisp::or 
                         (UTILITIES::occurs v (cdr pV11528)) 
                         (occursOptRow v pV11526))) 
                       (if (eq (car pV11528) :|None|) 
                           (return (occursOptRow v pV11526)))))))) 
       (error "Nonexhaustive match failure in occurs")))) 
    (block 
     nil 
     (if (eq (car srt) :|CoProduct|) 
         (return (occursOptRow v (car (cdr srt)))) 
         (if (eq (car srt) :|Product|) 
             (return (occursRow v (car (cdr srt)))) 
             (if (eq (car srt) :|Arrow|) 
                 (let ((pV11557 (cdr srt))) 
                   (return 
                    (lisp::or 
                     (UTILITIES::occurs v (svref pV11557 0)) 
                     (UTILITIES::occurs v (svref pV11557 1))))) 
                 (if (eq (car srt) :|Quotient|) 
                     (let ((pV11556 (cdr srt))) 
                       (return 
                        (lisp::or 
                         (UTILITIES::occurs v (svref pV11556 0)) 
                         (UTILITIES::occursT v (svref pV11556 1))))) 
                     (if (eq (car srt) :|Subsort|) 
                         (let ((pV11555 (cdr srt))) 
                           (return 
                            (lisp::or 
                             (UTILITIES::occurs v (svref pV11555 0)) 
                             (UTILITIES::occursT v (svref pV11555 1))))) 
                         (if (eq (car srt) :|Base|) 
                             (return 
                              (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (s) (UTILITIES::occurs v s)) 
                               (svref (cdr srt) 1))) 
                             (if (eq (car srt) :|TyVar|) 
                                 (return nil) 
                                 (if (eq (car srt) :|MetaTyVar|) 
                                     (return 
                                      (let ((pV11547 
                                             (UTILITIES::unlinkPSort srt))) 
                                        (block 
                                         nil 
                                         (if (eq (car pV11547) :|MetaTyVar|) 
                                             (return 
                                              (slang-built-in::slang-term-equals 
                                               v 
                                               (car (cdr pV11547))))) 
                                         (return (UTILITIES::occurs v pV11547))))))))))))) 
     (error "Nonexhaustive match failure in occurs"))))
                                                       
(defun UTILITIES::compareQId (pV10883 pV10884) 
  (block 
   nil 
   (if (eq (car pV10883) :|Qualified|) 
       (let ((pV10885 (cdr pV10883))) 
         (if (eq (car pV10884) :|Qualified|) 
             (let ((pV10888 (cdr pV10884))) 
               (return 
                (let ((pV10882 
                       (STRING-SPEC::compare (car pV10885) (car pV10888)))) 
                  (block 
                   nil 
                   (if (eq (car pV10882) :|Equal|) 
                       (return 
                        (STRING-SPEC::compare (cdr pV10885) (cdr pV10888)))) 
                   (return pV10882)))))))) 
   (error "Nonexhaustive match failure in compareQId")))
                                                        
(defun UTILITIES::compareQId-1 (x) (UTILITIES::compareQId (car x) (cdr x)))
                                                                           
(defparameter UTILITIES::counter (cons :|Ref| 0))
                                                 
(defun UTILITIES::freshMetaTyVar (pos) 
  (progn (STATE::|:=| 
          UTILITIES::counter 
          (INTEGER-SPEC::|!+| 1 (STATE::|!!| UTILITIES::counter))) 
         (cons 
          :|MetaTyVar| 
          (cons 
           (cons 
            :|Ref| 
            (vector '(:|None|) "#fresh" (STATE::|!!| UTILITIES::counter))) 
           pos))))
                  
(defun UTILITIES::copySort (|!tyVars| srt) 
  (if (LIST-SPEC::|!null| |!tyVars|) 
      (cons nil srt) 
      (let ((mtvar_position (cons :|Internal| "copySort"))) 
        (let ((tyVarMap 
               (LIST-SPEC::|!map|-1-1 
                #'(lambda (tv) 
                   (cons tv (UTILITIES::freshMetaTyVar mtvar_position))) 
                |!tyVars|))) 
          (labels 
            ((mapTyVar (tv tvs pos) 
              (block 
               nil 
               (if (null tvs) 
                   (return (cons :|TyVar| (cons tv pos))) 
                   (if (consp tvs) 
                       (let ((pV10912 (car tvs))) 
                         (return 
                          (if (string=  tv (car pV10912)) 
                              (cdr pV10912) 
                              (mapTyVar tv (cdr tvs) pos)))))) 
               (error "Nonexhaustive match failure in copySort")))) 
            (labels 
              ((cp (srt) 
                (block 
                 nil 
                 (if (eq (car srt) :|TyVar|) 
                     (let ((pV10917 (cdr srt))) 
                       (return (mapTyVar (car pV10917) tyVarMap (cdr pV10917))))) 
                 (return srt)))) 
              (let ((srt 
                     (METASLANG::mapSort-1-1 
                      (vector #'(lambda (x) x) #'cp #'(lambda (x) x)) 
                      srt))) 
                (let ((metaTyVars 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (x) 
                           (let ((pV10923 (cdr x))) 
                             (block 
                              nil 
                              (if (eq (car pV10923) :|MetaTyVar|) 
                                  (return (car (cdr pV10923)))) 
                              (error "Nonexhaustive match failure in copySort")))) 
                        tyVarMap))) (cons metaTyVars srt)))))))))
                                                                 
(defun UTILITIES::instantiateScheme (env pos types type_vars srt) 
  (if (BOOLEAN-SPEC::~ 
       ( =  (LIST-SPEC::|!length| types) (LIST-SPEC::|!length| type_vars))) 
      (progn (UTILITIES::|!error| 
              env 
              "
  Instantiation list does not match argument list" 
              pos) 
             srt) 
      (let ((pV11114 (UTILITIES::copySort type_vars srt))) 
        (block 
         nil 
         (return 
          (progn (LISTPAIR::app-1-1 
                  #'(lambda (x) 
                     (let ((new_type_var (cdr x))) 
                       (let ((pV11110 (STATE::|!!| new_type_var))) 
                         (block 
                          nil 
                          (return 
                           (STATE::|:=| 
                            new_type_var 
                            (vector 
                             (cons :|Some| (car x)) 
                             (svref pV11110 1) 
                             (svref pV11110 2)))) 
                          (error 
                           "Nonexhaustive match failure in instantiateScheme"))))) 
                  (cons types (car pV11114))) 
                 (cdr pV11114))) 
         (error "Nonexhaustive match failure in instantiateScheme")))))
                                                                       
(defun UTILITIES::unfoldPSortRec (env srt qids) 
  (let ((unlinked_sort (UTILITIES::unlinkPSort srt))) 
    (block 
     nil 
     (if (eq (car unlinked_sort) :|Base|) 
         (let ((pV12096 (cdr unlinked_sort))) 
           (let ((pV12099 (svref pV12096 2))
                 (pV12098 (svref pV12096 1))
                 (pV12097 (svref pV12096 0))) 
             (return 
              (if (SPLAYSET::|!member| qids pV12097) 
                  (progn (UTILITIES::|!error| 
                          env 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            "The sort " 
                            (METASLANG::printQualifiedId pV12097)) 
                           " is recursively defined using itself") 
                          pV12099) 
                         unlinked_sort) 
                  (let ((pV12091 
                         (STANDARDSPEC::findAllSorts (svref env 5) pV12097))) 
                    (block 
                     nil 
                     (if (consp pV12091) 
                         (let ((pV12093 (car pV12091))) 
                           (return 
                            (let ((pV12082 (svref pV12093 2))
                                  (pV12081 (svref pV12093 1))
                                  (pV12080 (svref pV12093 0))) 
                              (block 
                               nil 
                               (if (consp pV12080) 
                                   (if (eq (car pV12082) :|None|) 
                                       (return 
                                        (let ((l1 (LIST-SPEC::|!length| pV12081))) 
                                          (let ((l2 
                                                 (LIST-SPEC::|!length| pV12098))) 
                                            (progn (if (BOOLEAN-SPEC::~ 
                                                        ( =  l1 l2)) 
                                                       (UTILITIES::|!error| 
                                                        env 
                                                        "
  Instantiation list does not match argument list" 
                                                        pV12099) 
                                                       nil) 
                                                   (cons 
                                                    :|Base| 
                                                    (vector 
                                                     (car pV12080) 
                                                     pV12098 
                                                     pV12099)))))))) 
                               (if (eq (car pV12082) :|Some|) 
                                   (let ((pV12083 (cdr pV12082))) 
                                     (progn (if (eq (car pV12083) :|Base|) 
                                                (return 
                                                 (UTILITIES::unfoldPSortRec 
                                                  env 
                                                  (UTILITIES::instantiateScheme 
                                                   env 
                                                   (svref (cdr pV12083) 2) 
                                                   pV12098 
                                                   pV12081 
                                                   pV12083) 
                                                  (LIST-SPEC::foldl-1-1-1 
                                                   #'(lambda (x) 
                                                      (SPLAYSET::add 
                                                       (cdr x) 
                                                       (car x))) 
                                                   qids 
                                                   pV12080)))) 
                                            (return 
                                             (UTILITIES::instantiateScheme 
                                              env 
                                              pV12099 
                                              pV12098 
                                              pV12081 
                                              pV12083))))) 
                               (error 
                                "Nonexhaustive match failure in unfoldPSortRec"))))) 
                         (if (null pV12091) 
                             (return 
                              (progn (UTILITIES::|!error| 
                                      env 
                                      (STRING-SPEC::^ 
                                       "Could not find definition of sort " 
                                       (METASLANG::printQualifiedId pV12097)) 
                                      pV12099) 
                                     unlinked_sort)))) 
                     (error "Nonexhaustive match failure in unfoldPSortRec")))))))) 
     (return unlinked_sort))))
                              
(defun UTILITIES::unfoldPSort (env srt) 
  (UTILITIES::unfoldPSortRec env srt (SPLAYSET::empty #'UTILITIES::compareQId-1)))


(defun UTILITIES::unifyL (srt1 srt2 l1 l2 pairs unify) 
  (block 
   nil 
   (if (null l1) 
       (if (null l2) (return (cons :|Unify| pairs))) 
       (if (consp l1) 
           (if (consp l2) 
               (return 
                (let ((pV12100 (funcall unify (vector (car l1) (car l2) pairs)))) 
                  (block 
                   nil 
                   (if (eq (car pV12100) :|Unify|) 
                       (return 
                        (UTILITIES::unifyL 
                         srt1 
                         srt2 
                         (cdr l1) 
                         (cdr l2) 
                         (cdr pV12100) 
                         unify))) 
                   (return pV12100))))))) 
   (return (cons :|NotUnify| (cons srt1 srt2)))))
                                                 
(defun UTILITIES::unifySorts-1-1-1 (env s1 s2) 
  (labels 
    ((unify (s1 s2 pairs) 
      (let ((pos1 (METASLANG::sortAnn s1))) 
        (let ((pos2 (METASLANG::sortAnn s2))) 
          (let ((srt1 (METASLANG::withAnnS (UTILITIES::unlinkPSort s1) pos1))) 
            (let ((srt2 (METASLANG::withAnnS (UTILITIES::unlinkPSort s2) pos2))) 
              (if (METASLANG::equalSort? srt1 srt2) 
                  (cons :|Unify| pairs) 
                  (block 
                   nil 
                   (if (eq (car srt1) :|CoProduct|) 
                       (if (eq (car srt2) :|CoProduct|) 
                           (return 
                            (unifyCP 
                             srt1 
                             srt2 
                             (car (cdr srt1)) 
                             (car (cdr srt2)) 
                             pairs))) 
                       (if (eq (car srt1) :|Product|) 
                           (if (eq (car srt2) :|Product|) 
                               (return 
                                (unifyP 
                                 srt1 
                                 srt2 
                                 (car (cdr srt1)) 
                                 (car (cdr srt2)) 
                                 pairs))) 
                           (if (eq (car srt1) :|Arrow|) 
                               (let ((pV12173 (cdr srt1))) 
                                 (if (eq (car srt2) :|Arrow|) 
                                     (let ((pV12200 (cdr srt2))) 
                                       (return 
                                        (let ((pV12136 
                                               (unify 
                                                (svref pV12173 0) 
                                                (svref pV12200 0) 
                                                pairs))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV12136) :|Unify|) 
                                               (return 
                                                (unify 
                                                 (svref pV12173 1) 
                                                 (svref pV12200 1) 
                                                 (cdr pV12136)))) 
                                           (return pV12136))))))) 
                               (if (eq (car srt1) :|Quotient|) 
                                   (if (eq (car srt2) :|Quotient|) 
                                       (return 
                                        (unify 
                                         (svref (cdr srt1) 0) 
                                         (svref (cdr srt2) 0) 
                                         pairs))) 
                                   (if (eq (car srt1) :|Base|) 
                                       (let ((pV12171 (cdr srt1))) 
                                         (if (eq (car srt2) :|Base|) 
                                             (let ((pV12186 (cdr srt2))) 
                                               (return 
                                                (if (LIST-SPEC::|!exists|-1-1 
                                                     #'(lambda (x) 
                                                        (lisp::and 
                                                         (METASLANG::equalSort? 
                                                          (car x) 
                                                          srt1) 
                                                         (METASLANG::equalSort? 
                                                          (cdr x) 
                                                          srt2))) 
                                                     pairs) 
                                                    (cons :|Unify| pairs) 
                                                    (if (slang-built-in::slang-term-equals 
                                                         (svref pV12171 0) 
                                                         (svref pV12186 0)) 
                                                        (UTILITIES::unifyL 
                                                         srt1 
                                                         srt2 
                                                         (svref pV12171 1) 
                                                         (svref pV12186 1) 
                                                         pairs 
                                                         #'(lambda (x) 
                                                            (unify 
                                                             (svref x 0) 
                                                             (svref x 1) 
                                                             (svref x 2)))) 
                                                        (let ((s1_ 
                                                               (UTILITIES::unfoldPSort 
                                                                env 
                                                                srt1))) 
                                                          (let ((s2_ 
                                                                 (UTILITIES::unfoldPSort 
                                                                  env 
                                                                  srt2))) 
                                                            (if (lisp::and 
                                                                 (METASLANG::equalSort? 
                                                                  s1 
                                                                  s1_) 
                                                                 (METASLANG::equalSort? 
                                                                  s2_ 
                                                                  s2)) 
                                                                (cons 
                                                                 :|NotUnify| 
                                                                 (cons srt1 srt2)) 
                                                                (unify 
                                                                 (METASLANG::withAnnS 
                                                                  s1_ 
                                                                  (svref 
                                                                   pV12171 
                                                                   2)) 
                                                                 (METASLANG::withAnnS 
                                                                  s2_ 
                                                                  (svref 
                                                                   pV12186 
                                                                   2)) 
                                                                 (LIST-SPEC::|!cons| 
                                                                  (cons s1 s2) 
                                                                  pairs))))))))))) 
                                       (if (eq (car srt1) :|TyVar|) 
                                           (if (eq (car srt2) :|TyVar|) 
                                               (return 
                                                (if (string=  
                                                     (car (cdr srt1)) 
                                                     (car (cdr srt2))) 
                                                    (cons :|Unify| pairs) 
                                                    (cons 
                                                     :|NotUnify| 
                                                     (cons srt1 srt2))))) 
                                           (if (eq (car srt1) :|MetaTyVar|) 
                                               (let ((pV12176 (car (cdr srt1)))) 
                                                 (return 
                                                  (let ((s2_ 
                                                         (UTILITIES::unfoldPSort 
                                                          env 
                                                          srt2))) 
                                                    (let ((|!t| 
                                                           (UTILITIES::unlinkPSort 
                                                            s2_))) 
                                                      (if (METASLANG::equalSort? 
                                                           |!t| 
                                                           s1) 
                                                          (cons :|Unify| pairs) 
                                                          (if (UTILITIES::occurs 
                                                               pV12176 
                                                               |!t|) 
                                                              (cons 
                                                               :|NotUnify| 
                                                               (cons srt1 srt2)) 
                                                              (progn (UTILITIES::linkMetaTyVar-1-1 
                                                                      pV12176 
                                                                      (METASLANG::withAnnS 
                                                                       s2 
                                                                       pos2)) 
                                                                     (cons 
                                                                      :|Unify| 
                                                                      pairs))))))))))))))) 
                   (if (eq (car srt2) :|MetaTyVar|) 
                       (let ((pV12167 (car (cdr srt2)))) 
                         (return 
                          (let ((|!t| (UTILITIES::unfoldPSort env srt1))) 
                            (let ((|!t| (UTILITIES::unlinkPSort |!t|))) 
                              (if (METASLANG::equalSort? |!t| s2) 
                                  (cons :|Unify| pairs) 
                                  (if (UTILITIES::occurs pV12167 |!t|) 
                                      (cons :|NotUnify| (cons srt1 srt2)) 
                                      (progn (UTILITIES::linkMetaTyVar-1-1 
                                              pV12167 
                                              (METASLANG::withAnnS s1 pos1)) 
                                             (cons :|Unify| pairs))))))))) 
                   (if (eq (car srt1) :|Subsort|) 
                       (return (unify (svref (cdr srt1) 0) srt2 pairs))) 
                   (if (eq (car srt2) :|Subsort|) 
                       (return (unify srt1 (svref (cdr srt2) 0) pairs))) 
                   (if (eq (car srt1) :|Base|) 
                       (return 
                        (let ((s1_ (UTILITIES::unfoldPSort env srt1))) 
                          (if (METASLANG::equalSort? s1 s1_) 
                              (cons :|NotUnify| (cons srt1 srt2)) 
                              (unify s1_ s2 pairs))))) 
                   (if (eq (car srt2) :|Base|) 
                       (return 
                        (let ((s2_ (UTILITIES::unfoldPSort env srt2))) 
                          (if (METASLANG::equalSort? s2 s2_) 
                              (cons :|NotUnify| (cons srt1 srt2)) 
                              (unify s1 s2_ pairs))))) 
                   (return (cons :|NotUnify| (cons srt1 srt2))))))))))
     (unifyP (srt1 srt2 r1 r2 pairs) 
      (UTILITIES::unifyL 
       srt1 
       srt2 
       r1 
       r2 
       pairs 
       #'(lambda (x) 
          (let ((pV12123 (svref x 0))
                (pV12124 (svref x 1))) 
            (block 
             nil 
             (return 
              (if (string=  (car pV12123) (car pV12124)) 
                  (unify (cdr pV12123) (cdr pV12124) (svref x 2)) 
                  (cons :|NotUnify| (cons srt1 srt2)))) 
             (error "Nonexhaustive match failure in unifySorts"))))))
     (unifyCP (srt1 srt2 r1 r2 pairs) 
      (UTILITIES::unifyL 
       srt1 
       srt2 
       r1 
       r2 
       pairs 
       #'(lambda (x) 
          (let ((pV12116 (svref x 0))
                (pV12117 (svref x 1))
                (pV12118 (svref x 2))) 
            (block 
             nil 
             (let ((pV12120 (cdr pV12116))) 
               (let ((pV12122 (cdr pV12117))) 
                 (return 
                  (if (string=  (car pV12116) (car pV12117)) 
                      (block 
                       nil 
                       (if (eq (car pV12120) :|None|) 
                           (if (eq (car pV12122) :|None|) 
                               (return (cons :|Unify| pV12118))) 
                           (if (eq (car pV12120) :|Some|) 
                               (if (eq (car pV12122) :|Some|) 
                                   (return 
                                    (unify (cdr pV12120) (cdr pV12122) pV12118))))) 
                       (return (cons :|NotUnify| (cons srt1 srt2)))) 
                      (cons :|NotUnify| (cons srt1 srt2)))))) 
             (error "Nonexhaustive match failure in unifySorts"))))))) 
    (let ((pV12215 (unify s1 s2 nil))) 
      (block 
       nil 
       (if (eq (car pV12215) :|Unify|) 
           (return (cons t "")) 
           (if (eq (car pV12215) :|NotUnify|) 
               (let ((pV12216 (cdr pV12215))) 
                 (return 
                  (cons 
                   nil 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (ANNSPECPRINTER::printSort (car pV12216)) 
                     " ! = ") 
                    (ANNSPECPRINTER::printSort (cdr pV12216)))))))) 
       (error "Nonexhaustive match failure in unifySorts")))))
                                                              
(defun TYPECHECKER::elaborateSortForTerm (env term givenSort expectedSort) 
  (let ((pV10136 (UTILITIES::unifySorts-1-1-1 env givenSort expectedSort))) 
    (block 
     nil 
     (return 
      (progn (if (car pV10136) 
                 nil 
                 (let ((pos (METASLANG::termAnn term))) 
                   (let ((termString (ANNSPECPRINTER::printTerm term))) 
                     (let ((tsLength (STRING-SPEC::|!length| termString))) 
                       (let ((fillerA 
                              (TYPECHECKER::blankString 
                               (INTEGER-SPEC::|!-| 10 tsLength)))) 
                         (let ((fillerB 
                                (TYPECHECKER::blankString 
                                 (INTEGER-SPEC::|!-| tsLength 10)))) 
                           (UTILITIES::|!error| 
                            env 
                            (TYPECHECKER::newLines 
                             (cons 
                              " Could not match sort constraint" 
                              (cons 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ fillerA termString) 
                                 " of sort ") 
                                (ANNSPECPRINTER::printSort givenSort)) 
                               (cons 
                                (STRING-SPEC::^ 
                                 (STRING-SPEC::^ fillerB "with expected sort ") 
                                 (ANNSPECPRINTER::printSort expectedSort)) 
                                nil)))) 
                            pos))))))) 
             givenSort)) 
     (error "Nonexhaustive match failure in elaborateSortForTerm"))))
                                                                     
(defun TYPECHECKER::elaborateCheckSortForTerm (env term givenSort expectedSort) 
  (TYPECHECKER::elaborateSortForTerm 
   env 
   term 
   (TYPECHECKER::checkSort env givenSort) 
   expectedSort))
                 
(defun TYPECHECKER::elaborateSort (env s1 s2) 
  (let ((s1Checked (TYPECHECKER::checkSort env s1))) 
    (let ((pV10133 (UTILITIES::unifySorts-1-1-1 env s1Checked s2))) 
      (block 
       nil 
       (return 
        (progn (if (car pV10133) 
                   nil 
                   (UTILITIES::|!error| 
                    env 
                    (TYPECHECKER::newLines 
                     (cons 
                      (STRING-SPEC::^ 
                       "Could not match sort " 
                       (ANNSPECPRINTER::printSort s1)) 
                      (cons 
                       (STRING-SPEC::^ 
                        "                with " 
                        (ANNSPECPRINTER::printSort s2)) 
                       nil))) 
                    (POSITION-SPEC::chooseNonZeroPos 
                     (METASLANG::sortAnn s1) 
                     (METASLANG::sortAnn s2)))) 
               s1Checked)) 
       (error "Nonexhaustive match failure in elaborateSort")))))
                                                                 
(defun TYPECHECKER::lookupEmbedId (env id srt) 
  (let ((pV10171 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV10171) :|CoProduct|) 
         (let ((pV10177 (car (cdr pV10171)))) 
           (return 
            (labels 
              ((lookup (row) 
                (block 
                 nil 
                 (if (null row) 
                     (return '(:|None|)) 
                     (if (consp row) 
                         (let ((pV10165 (car row))) 
                           (let ((pV10168 (cdr pV10165))) 
                             (return 
                              (if (string=  id (car pV10165)) 
                                  (cons 
                                   :|Some| 
                                   (block 
                                    nil 
                                    (if (eq (car pV10168) :|None|) 
                                        (return '(:|None|)) 
                                        (if (eq (car pV10168) :|Some|) 
                                            (return 
                                             (cons 
                                              :|Some| 
                                              (TYPECHECKER::checkSort 
                                               env 
                                               (cdr pV10168)))))) 
                                    (error 
                                     "Nonexhaustive match failure in lookupEmbedId"))) 
                                  (lookup (cdr row)))))))) 
                 (error "Nonexhaustive match failure in lookupEmbedId")))) 
              (lookup pV10177)))) 
         (if (eq (car pV10171) :|Subsort|) 
             (return (TYPECHECKER::lookupEmbedId env id (svref (cdr pV10171) 0))))) 
     (return '(:|None|)))))
                           
(defparameter TYPECHECKER::type_bool POSSPEC::boolPSort)
                                                        
(defparameter TYPECHECKER::type_char POSSPEC::charPSort)
                                                        
(defparameter TYPECHECKER::type_nat POSSPEC::natPSort)
                                                      
(defparameter TYPECHECKER::type_string POSSPEC::stringPSort)
                                                            
(defun TYPECHECKER::undeterminedSort? (srt) 
  (let ((pV10291 (UTILITIES::unlinkPSort srt))) 
    (block nil (if (eq (car pV10291) :|MetaTyVar|) (return t)) (return nil))))
                                                                              
(defun UTILITIES::addVariable (pV10855 pV10856 pV10857) 
  (block 
   nil 
   (return 
    (vector 
     (svref pV10855 0) 
     (svref pV10855 1) 
     (svref pV10855 2) 
     (svref pV10855 3) 
     (svref pV10855 4) 
     (svref pV10855 5) 
     (STRINGMAP::insert (svref pV10855 6) pV10856 pV10857))) 
   (error "Nonexhaustive match failure in addVariable")))
                                                         
(defun UTILITIES::copySort-1 (x) (UTILITIES::copySort (car x) (cdr x)))
                                                                       
(defun TYPECHECKER::elaboratePattern (env p sort1) 
  (let ((sort1 (TYPECHECKER::checkSort env sort1))) 
    (labels 
      ((elab (p) 
        (block 
         nil 
         (if (eq (car p) :|WildPat|) 
             (let ((pV9999 (cdr p))) 
               (return 
                (cons 
                 (cons 
                  :|WildPat| 
                  (cons 
                   (TYPECHECKER::elaborateSort env (car pV9999) sort1) 
                   (cdr pV9999))) 
                 env))) 
             (if (eq (car p) :|BoolPat|) 
                 (return 
                  (progn (TYPECHECKER::elaborateSort 
                          env 
                          sort1 
                          TYPECHECKER::type_bool) 
                         (cons p env))) 
                 (if (eq (car p) :|NatPat|) 
                     (return 
                      (progn (TYPECHECKER::elaborateSort 
                              env 
                              sort1 
                              TYPECHECKER::type_nat) 
                             (cons p env))) 
                     (if (eq (car p) :|StringPat|) 
                         (return 
                          (progn (TYPECHECKER::elaborateSort 
                                  env 
                                  sort1 
                                  TYPECHECKER::type_string) 
                                 (cons p env))) 
                         (if (eq (car p) :|CharPat|) 
                             (return 
                              (progn (TYPECHECKER::elaborateSort 
                                      env 
                                      sort1 
                                      TYPECHECKER::type_char) 
                                     (cons p env))) 
                             (if (eq (car p) :|VarPat|) 
                                 (let ((pV9994 (cdr p))) 
                                   (let ((pV10019 (cdr pV9994))
                                         (pV10018 (car pV9994))) 
                                     (let ((pV10020 (car pV10018))) 
                                       (return 
                                        (let ((srt 
                                               (TYPECHECKER::elaborateSort 
                                                env 
                                                (cdr pV10018) 
                                                sort1))) 
                                          (let ((pV9915 
                                                 (TYPECHECKER::lookupEmbedId 
                                                  env 
                                                  pV10020 
                                                  srt))) 
                                            (block 
                                             nil 
                                             (if (eq (car pV9915) :|Some|) 
                                                 (progn (if (eq 
                                                             (car (cdr pV9915)) 
                                                             :|None|) 
                                                            (return 
                                                             (cons 
                                                              (cons 
                                                               :|EmbedPat| 
                                                               (vector 
                                                                pV10020 
                                                                '(:|None|) 
                                                                srt 
                                                                pV10019)) 
                                                              env))) 
                                                        (return 
                                                         (progn (UTILITIES::|!error| 
                                                                 env 
                                                                 (STRING-SPEC::^ 
                                                                  (STRING-SPEC::^ 
                                                                   "Constructor " 
                                                                   pV10020) 
                                                                  " expects an argument, but was given none") 
                                                                 pV10019) 
                                                                (cons 
                                                                 (cons 
                                                                  :|VarPat| 
                                                                  (cons 
                                                                   (cons 
                                                                    pV10020 
                                                                    srt) 
                                                                   pV10019)) 
                                                                 env)))) 
                                                 (if (eq (car pV9915) :|None|) 
                                                     (return 
                                                      (if (TYPECHECKER::undeterminedSort? 
                                                           srt) 
                                                          (let ((pV9910 
                                                                 (STRINGMAP::|!find| 
                                                                  (svref env 0) 
                                                                  pV10020))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV9910) 
                                                                  :|None|) 
                                                                 (return 
                                                                  (cons 
                                                                   (cons 
                                                                    :|VarPat| 
                                                                    (cons 
                                                                     (cons 
                                                                      pV10020 
                                                                      srt) 
                                                                     pV10019)) 
                                                                   (UTILITIES::addVariable 
                                                                    env 
                                                                    pV10020 
                                                                    srt))) 
                                                                 (if (eq 
                                                                      (car 
                                                                       pV9910) 
                                                                      :|Some|) 
                                                                     (let ((pV9911 
                                                                            (cdr 
                                                                             pV9910))) 
                                                                       (progn (if (consp 
                                                                                   pV9911) 
                                                                                  (if (null 
                                                                                       (cdr 
                                                                                        pV9911)) 
                                                                                      (return 
                                                                                       (let ((pV9906 
                                                                                              (UTILITIES::copySort-1 
                                                                                               (car 
                                                                                                pV9911)))) 
                                                                                         (block 
                                                                                          nil 
                                                                                          (return 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             :|VarPat| 
                                                                                             (cons 
                                                                                              (cons 
                                                                                               pV10020 
                                                                                               (cdr 
                                                                                                pV9906)) 
                                                                                              pV10019)) 
                                                                                            env)) 
                                                                                          (error 
                                                                                           "Nonexhaustive match failure in elaboratePattern")))))) 
                                                                              (return 
                                                                               (cons 
                                                                                (cons 
                                                                                 :|VarPat| 
                                                                                 (cons 
                                                                                  (cons 
                                                                                   pV10020 
                                                                                   srt) 
                                                                                  pV10019)) 
                                                                                env)))))) 
                                                             (error 
                                                              "Nonexhaustive match failure in elaboratePattern"))) 
                                                          (cons 
                                                           (cons 
                                                            :|VarPat| 
                                                            (cons 
                                                             (cons pV10020 srt) 
                                                             pV10019)) 
                                                           (UTILITIES::addVariable 
                                                            env 
                                                            pV10020 
                                                            srt)))))) 
                                             (error 
                                              "Nonexhaustive match failure in elaboratePattern")))))))) 
                                 (if (eq (car p) :|SortedPat|) 
                                     (let ((pV9993 (cdr p))) 
                                       (return 
                                        (let ((srt 
                                               (TYPECHECKER::elaborateSort 
                                                env 
                                                (svref pV9993 1) 
                                                sort1))) 
                                          (let ((pV9918 
                                                 (TYPECHECKER::elaboratePattern 
                                                  env 
                                                  (svref pV9993 0) 
                                                  srt))) 
                                            (block 
                                             nil 
                                             (return 
                                              (cons (car pV9918) (cdr pV9918))) 
                                             (error 
                                              "Nonexhaustive match failure in elaboratePattern")))))) 
                                     (if (eq (car p) :|AliasPat|) 
                                         (let ((pV9992 (cdr p))) 
                                           (return 
                                            (let ((pV9924 
                                                   (TYPECHECKER::elaboratePattern 
                                                    env 
                                                    (svref pV9992 0) 
                                                    sort1))) 
                                              (block 
                                               nil 
                                               (return 
                                                (let ((pV9921 
                                                       (TYPECHECKER::elaboratePattern 
                                                        (cdr pV9924) 
                                                        (svref pV9992 1) 
                                                        sort1))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (cons 
                                                     (cons 
                                                      :|AliasPat| 
                                                      (vector 
                                                       (car pV9924) 
                                                       (car pV9921) 
                                                       (svref pV9992 2))) 
                                                     (cdr pV9921))) 
                                                   (error 
                                                    "Nonexhaustive match failure in elaboratePattern")))) 
                                               (error 
                                                "Nonexhaustive match failure in elaboratePattern"))))) 
                                         (if (eq (car p) :|EmbedPat|) 
                                             (let ((pV9991 (cdr p))) 
                                               (let ((pV10011 (svref pV9991 3))
                                                     (pV10009 (svref pV9991 1))
                                                     (pV10008 (svref pV9991 0))) 
                                                 (return 
                                                  (let ((sort0 
                                                         (TYPECHECKER::elaborateSort 
                                                          env 
                                                          (svref pV9991 2) 
                                                          sort1))) 
                                                    (let ((sort0 
                                                           (if (TYPECHECKER::undeterminedSort? 
                                                                sort0) 
                                                               (let ((pV9932 
                                                                      (STRINGMAP::|!find| 
                                                                       (svref 
                                                                        env 
                                                                        0) 
                                                                       pV10008))) 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV9932) 
                                                                       :|Some|) 
                                                                      (let ((pV9933 
                                                                             (cdr 
                                                                              pV9932))) 
                                                                        (if (consp 
                                                                             pV9933) 
                                                                            (if (null 
                                                                                 (cdr 
                                                                                  pV9933)) 
                                                                                (return 
                                                                                 (let ((pV9928 
                                                                                        (UTILITIES::copySort-1 
                                                                                         (car 
                                                                                          pV9933)))) 
                                                                                   (block 
                                                                                    nil 
                                                                                    (return 
                                                                                     (TYPECHECKER::elaborateSort 
                                                                                      env 
                                                                                      (cdr 
                                                                                       pV9928) 
                                                                                      sort1)) 
                                                                                    (error 
                                                                                     "Nonexhaustive match failure in elaboratePattern")))))))) 
                                                                  (return sort0))) 
                                                               sort0))) 
                                                      (if (lisp::and 
                                                           (svref env 3) 
                                                           (TYPECHECKER::undeterminedSort? 
                                                            sort0)) 
                                                          (let ((pV9942 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV10009) 
                                                                       :|None|) 
                                                                      (return 
                                                                       (cons 
                                                                        env 
                                                                        '(:|None|))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV10009) 
                                                                           :|Some|) 
                                                                          (return 
                                                                           (let ((alpha 
                                                                                  (UTILITIES::freshMetaTyVar 
                                                                                   pV10011))) 
                                                                             (let ((pV9937 
                                                                                    (TYPECHECKER::elaboratePattern 
                                                                                     env 
                                                                                     (cdr 
                                                                                      pV10009) 
                                                                                     alpha))) 
                                                                               (block 
                                                                                nil 
                                                                                (return 
                                                                                 (cons 
                                                                                  (cdr 
                                                                                   pV9937) 
                                                                                  (cons 
                                                                                   :|Some| 
                                                                                   (car 
                                                                                    pV9937)))) 
                                                                                (error 
                                                                                 "Nonexhaustive match failure in elaboratePattern"))))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in elaboratePattern")))) 
                                                            (block 
                                                             nil 
                                                             (return 
                                                              (cons 
                                                               (cons 
                                                                :|EmbedPat| 
                                                                (vector 
                                                                 pV10008 
                                                                 (cdr pV9942) 
                                                                 sort0 
                                                                 pV10011)) 
                                                               (car pV9942))) 
                                                             (error 
                                                              "Nonexhaustive match failure in elaboratePattern"))) 
                                                          (let ((srt 
                                                                 (TYPECHECKER::lookupEmbedId 
                                                                  env 
                                                                  pV10008 
                                                                  sort0))) 
                                                            (let ((pV9959 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          srt) 
                                                                         :|None|) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV10009) 
                                                                             :|None|) 
                                                                            (return 
                                                                             (progn (UTILITIES::|!error| 
                                                                                     env 
                                                                                     (STRING-SPEC::^ 
                                                                                      (STRING-SPEC::^ 
                                                                                       (STRING-SPEC::^ 
                                                                                        "Sort for constructor " 
                                                                                        pV10008) 
                                                                                       " not found. Resolving with sort ") 
                                                                                      (ANNSPECPRINTER::printSort 
                                                                                       sort1)) 
                                                                                     pV10011) 
                                                                                    (cons 
                                                                                     env 
                                                                                     '(:|None|)))) 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV10009) 
                                                                                 :|Some|) 
                                                                                (return 
                                                                                 (let ((alpha 
                                                                                        (UTILITIES::freshMetaTyVar 
                                                                                         pV10011))) 
                                                                                   (let ((pV9948 
                                                                                          (TYPECHECKER::elaboratePattern 
                                                                                           env 
                                                                                           (cdr 
                                                                                            pV10009) 
                                                                                           alpha))) 
                                                                                     (block 
                                                                                      nil 
                                                                                      (let ((pV9950 
                                                                                             (cdr 
                                                                                              pV9948))) 
                                                                                        (return 
                                                                                         (progn (UTILITIES::|!error| 
                                                                                                 pV9950 
                                                                                                 (STRING-SPEC::^ 
                                                                                                  (STRING-SPEC::^ 
                                                                                                   (STRING-SPEC::^ 
                                                                                                    "Sort for constructor " 
                                                                                                    pV10008) 
                                                                                                   " not found. Resolving with sort ") 
                                                                                                  (ANNSPECPRINTER::printSort 
                                                                                                   sort1)) 
                                                                                                 pV10011) 
                                                                                                (cons 
                                                                                                 pV9950 
                                                                                                 '(:|None|))))) 
                                                                                      (error 
                                                                                       "Nonexhaustive match failure in elaboratePattern"))))))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              srt) 
                                                                             :|Some|) 
                                                                            (let ((pV9954 
                                                                                   (cdr 
                                                                                    srt))) 
                                                                              (if (eq 
                                                                                   (car 
                                                                                    pV9954) 
                                                                                   :|None|) 
                                                                                  (if (eq 
                                                                                       (car 
                                                                                        pV10009) 
                                                                                       :|None|) 
                                                                                      (return 
                                                                                       (cons 
                                                                                        env 
                                                                                        '(:|None|))) 
                                                                                      (if (eq 
                                                                                           (car 
                                                                                            pV10009) 
                                                                                           :|Some|) 
                                                                                          (let ((pV9957 
                                                                                                 (cdr 
                                                                                                  pV10009))) 
                                                                                            (return 
                                                                                             (progn (UTILITIES::|!error| 
                                                                                                     env 
                                                                                                     (TYPECHECKER::newLines 
                                                                                                      (cons 
                                                                                                       (STRING-SPEC::^ 
                                                                                                        (STRING-SPEC::^ 
                                                                                                         "Constructor " 
                                                                                                         pV10008) 
                                                                                                        " takes no argument") 
                                                                                                       (cons 
                                                                                                        (STRING-SPEC::^ 
                                                                                                         "but was given " 
                                                                                                         (ANNSPECPRINTER::printPattern 
                                                                                                          pV9957)) 
                                                                                                        nil))) 
                                                                                                     pV10011) 
                                                                                                    (cons 
                                                                                                     env 
                                                                                                     (cons 
                                                                                                      :|Some| 
                                                                                                      pV9957))))))) 
                                                                                  (if (eq 
                                                                                       (car 
                                                                                        pV9954) 
                                                                                       :|Some|) 
                                                                                      (if (eq 
                                                                                           (car 
                                                                                            pV10009) 
                                                                                           :|Some|) 
                                                                                          (return 
                                                                                           (let ((pV9945 
                                                                                                  (TYPECHECKER::elaboratePattern 
                                                                                                   env 
                                                                                                   (cdr 
                                                                                                    pV10009) 
                                                                                                   (cdr 
                                                                                                    pV9954)))) 
                                                                                             (block 
                                                                                              nil 
                                                                                              (return 
                                                                                               (cons 
                                                                                                (cdr 
                                                                                                 pV9945) 
                                                                                                (cons 
                                                                                                 :|Some| 
                                                                                                 (car 
                                                                                                  pV9945)))) 
                                                                                              (error 
                                                                                               "Nonexhaustive match failure in elaboratePattern")))) 
                                                                                          (if (eq 
                                                                                               (car 
                                                                                                pV10009) 
                                                                                               :|None|) 
                                                                                              (return 
                                                                                               (progn (UTILITIES::|!error| 
                                                                                                       env 
                                                                                                       (STRING-SPEC::^ 
                                                                                                        "Argument expected for constructor " 
                                                                                                        pV10008) 
                                                                                                       pV10011) 
                                                                                                      (cons 
                                                                                                       env 
                                                                                                       '(:|None|))))))))))) 
                                                                    (error 
                                                                     "Nonexhaustive match failure in elaboratePattern")))) 
                                                              (block 
                                                               nil 
                                                               (return 
                                                                (cons 
                                                                 (cons 
                                                                  :|EmbedPat| 
                                                                  (vector 
                                                                   pV10008 
                                                                   (cdr pV9959) 
                                                                   sort1 
                                                                   pV10011)) 
                                                                 (car pV9959))) 
                                                               (error 
                                                                "Nonexhaustive match failure in elaboratePattern")))))))))) 
                                             (if (eq (car p) :|RecordPat|) 
                                                 (let ((pV9990 (cdr p))) 
                                                   (let ((pV10007 (cdr pV9990))
                                                         (pV10006 (car pV9990))) 
                                                     (return 
                                                      (let ((r 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'(lambda (x) 
                                                                 (cons 
                                                                  (car x) 
                                                                  (UTILITIES::freshMetaTyVar 
                                                                   pV10007))) 
                                                              pV10006))) 
                                                        (progn (TYPECHECKER::elaborateSort 
                                                                env 
                                                                (cons 
                                                                 :|Product| 
                                                                 (cons r pV10007)) 
                                                                sort1) 
                                                               (let ((r 
                                                                      (LISTPAIR::zip 
                                                                       r 
                                                                       pV10006))) 
                                                                 (let ((pV9977 
                                                                        (LIST-SPEC::foldr-1-1-1 
                                                                         #'(lambda (x) 
                                                                            (let ((pV9968 
                                                                                   (cdr 
                                                                                    x))
                                                                                  (pV9967 
                                                                                   (car 
                                                                                    x))) 
                                                                              (block 
                                                                               nil 
                                                                               (let ((pV9969 
                                                                                      (car 
                                                                                       pV9967))) 
                                                                                 (return 
                                                                                  (let ((pV9964 
                                                                                         (TYPECHECKER::elaboratePattern 
                                                                                          (cdr 
                                                                                           pV9968) 
                                                                                          (cdr 
                                                                                           (cdr 
                                                                                            pV9967)) 
                                                                                          (cdr 
                                                                                           pV9969)))) 
                                                                                    (block 
                                                                                     nil 
                                                                                     (return 
                                                                                      (cons 
                                                                                       (LIST-SPEC::|!cons| 
                                                                                        (cons 
                                                                                         (car 
                                                                                          pV9969) 
                                                                                         (car 
                                                                                          pV9964)) 
                                                                                        (car 
                                                                                         pV9968)) 
                                                                                       (cdr 
                                                                                        pV9964))) 
                                                                                     (error 
                                                                                      "Nonexhaustive match failure in elaboratePattern"))))) 
                                                                               (error 
                                                                                "Nonexhaustive match failure in elaboratePattern")))) 
                                                                         (cons 
                                                                          nil 
                                                                          env) 
                                                                         r))) 
                                                                   (block 
                                                                    nil 
                                                                    (return 
                                                                     (cons 
                                                                      (cons 
                                                                       :|RecordPat| 
                                                                       (cons 
                                                                        (car 
                                                                         pV9977) 
                                                                        pV10007)) 
                                                                      (cdr 
                                                                       pV9977))) 
                                                                    (error 
                                                                     "Nonexhaustive match failure in elaboratePattern"))))))))) 
                                                 (if (eq (car p) :|RelaxPat|) 
                                                     (let ((pV9989 (cdr p))) 
                                                       (let ((pV10005 
                                                              (svref pV9989 2))) 
                                                         (return 
                                                          (let ((term 
                                                                 (TYPECHECKER::elaborateTerm 
                                                                  env 
                                                                  (svref 
                                                                   pV9989 
                                                                   1) 
                                                                  (cons 
                                                                   :|Arrow| 
                                                                   (vector 
                                                                    sort1 
                                                                    TYPECHECKER::type_bool 
                                                                    pV10005))))) 
                                                            (let ((pV9980 
                                                                   (TYPECHECKER::elaboratePattern 
                                                                    env 
                                                                    (svref 
                                                                     pV9989 
                                                                     0) 
                                                                    (cons 
                                                                     :|Subsort| 
                                                                     (vector 
                                                                      sort1 
                                                                      term 
                                                                      pV10005))))) 
                                                              (block 
                                                               nil 
                                                               (return 
                                                                (cons 
                                                                 (cons 
                                                                  :|RelaxPat| 
                                                                  (vector 
                                                                   (car pV9980) 
                                                                   term 
                                                                   pV10005)) 
                                                                 (cdr pV9980))) 
                                                               (error 
                                                                "Nonexhaustive match failure in elaboratePattern"))))))) 
                                                     (if (eq 
                                                          (car p) 
                                                          :|QuotientPat|) 
                                                         (let ((pV9988 (cdr p))) 
                                                           (let ((pV10002 
                                                                  (svref 
                                                                   pV9988 
                                                                   2))
                                                                 (pV10001 
                                                                  (svref 
                                                                   pV9988 
                                                                   1))) 
                                                             (return 
                                                              (let ((v 
                                                                     (UTILITIES::freshMetaTyVar 
                                                                      pV10002))) 
                                                                (progn (TYPECHECKER::elaborateSort 
                                                                        env 
                                                                        (cons 
                                                                         :|Quotient| 
                                                                         (vector 
                                                                          v 
                                                                          pV10001 
                                                                          pV10002)) 
                                                                        sort1) 
                                                                       (let ((term1 
                                                                              (TYPECHECKER::elaborateTerm 
                                                                               env 
                                                                               pV10001 
                                                                               (cons 
                                                                                :|Arrow| 
                                                                                (vector 
                                                                                 (cons 
                                                                                  :|Product| 
                                                                                  (cons 
                                                                                   (cons 
                                                                                    (cons 
                                                                                     "1" 
                                                                                     v) 
                                                                                    (cons 
                                                                                     (cons 
                                                                                      "2" 
                                                                                      v) 
                                                                                     nil)) 
                                                                                   pV10002)) 
                                                                                 TYPECHECKER::type_bool 
                                                                                 pV10002))))) 
                                                                         (let ((pV9984 
                                                                                (TYPECHECKER::elaboratePattern 
                                                                                 env 
                                                                                 (svref 
                                                                                  pV9988 
                                                                                  0) 
                                                                                 v))) 
                                                                           (block 
                                                                            nil 
                                                                            (return 
                                                                             (cons 
                                                                              (cons 
                                                                               :|QuotientPat| 
                                                                               (vector 
                                                                                (car 
                                                                                 pV9984) 
                                                                                term1 
                                                                                pV10002)) 
                                                                              (cdr 
                                                                               pV9984))) 
                                                                            (error 
                                                                             "Nonexhaustive match failure in elaboratePattern"))))))))))))))))))))) 
         (return 
          (progn (SYSTEM-SPEC::|!print| p) (SYSTEM-SPEC::fail "Nonexhaustive")))))) 
      (let ((pV10024 (elab p))) 
        (block 
         nil 
         (return (cons (car pV10024) (cdr pV10024))) 
         (error "Nonexhaustive match failure in elaboratePattern"))))))
                                                                       
(defun TYPECHECKER::isCoproduct (env srt) 
  (let ((pV10152 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV10152) :|CoProduct|) 
         (return (cons :|Some| (car (cdr pV10152)))) 
         (if (eq (car pV10152) :|Subsort|) 
             (return (TYPECHECKER::isCoproduct env (svref (cdr pV10152) 0))))) 
     (return '(:|None|)))))
                           
(defun TYPECHECKER::mkEmbed0 (env srt id) 
  (let ((pV10180 (TYPECHECKER::lookupEmbedId env id srt))) 
    (block 
     nil 
     (if (eq (car pV10180) :|Some|) 
         (if (eq (car (cdr pV10180)) :|None|) (return (cons :|Some| id)))) 
     (return '(:|None|)))))
                           
(defun TYPECHECKER::isArrowCoProduct (env srt) 
  (let ((pV10143 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV10143) :|Arrow|) 
         (let ((pV10144 (cdr pV10143))) 
           (return 
            (let ((pV10140 (TYPECHECKER::isCoproduct env (svref pV10144 1)))) 
              (block 
               nil 
               (if (eq (car pV10140) :|Some|) 
                   (return (cons :|Some| (cons (svref pV10144 0) (cdr pV10140)))) 
                   (if (eq (car pV10140) :|None|) (return '(:|None|)))) 
               (error "Nonexhaustive match failure in isArrowCoProduct")))))) 
     (return '(:|None|)))))
                           
(defun TYPECHECKER::undeclared (env fun id srt pos) 
  (if (svref env 3) 
      fun 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ "Name " id) 
               " has not been declared") 
              pos) 
             (cons :|Fun| (vector (cons :|OneName| (cons id nil)) srt pos)))))
                                                                              
(defun TYPECHECKER::mkEmbed1 (env srt trm id pos) 
  (let ((pV10192 (TYPECHECKER::isArrowCoProduct env srt))) 
    (block 
     nil 
     (if (eq (car pV10192) :|Some|) 
         (let ((pV10193 (cdr pV10192))) 
           (let ((pV10195 (cdr pV10193))
                 (pV10194 (car pV10193))) 
             (return 
              (labels 
                ((findId (ls) 
                  (block 
                   nil 
                   (if (null ls) 
                       (return 
                        (cons 
                         :|Some| 
                         (TYPECHECKER::undeclared env trm id srt pos))) 
                       (if (consp ls) 
                           (let ((pV10187 (cdr ls))
                                 (pV10186 (car ls))) 
                             (progn (let ((pV10189 (cdr pV10186))) 
                                      (if (eq (car pV10189) :|Some|) 
                                          (return 
                                           (if (string=  id (car pV10186)) 
                                               (let ((constructor_dom_sort 
                                                      (TYPECHECKER::checkSort 
                                                       env 
                                                       (cdr pV10189)))) 
                                                 (progn (TYPECHECKER::elaborateSort 
                                                         env 
                                                         (METASLANG::withAnnS 
                                                          pV10194 
                                                          pos) 
                                                         constructor_dom_sort) 
                                                        (cons 
                                                         :|Some| 
                                                         (cons 
                                                          :|Fun| 
                                                          (vector 
                                                           (cons 
                                                            :|Embed| 
                                                            (cons id t)) 
                                                           (TYPECHECKER::checkSort 
                                                            env 
                                                            srt) 
                                                           pos))))) 
                                               (findId pV10187))))) 
                                    (return (findId pV10187)))))) 
                   (error "Nonexhaustive match failure in mkEmbed1")))) 
                (findId pV10195)))))) 
     (return '(:|None|)))))
                           
(defun TYPECHECKER::mkProject (env id srt pos) 
  (let ((pV10218 (UTILITIES::unfoldPSort env srt))) 
    (block 
     nil 
     (if (eq (car pV10218) :|Arrow|) 
         (let ((pV10220 (cdr pV10218))) 
           (let ((pV10225 (svref pV10220 1))
                 (pV10224 (svref pV10220 0))) 
             (return 
              (labels 
                ((analyzeDom (dom) 
                  (let ((pV10207 (UTILITIES::unfoldPSort env dom))) 
                    (block 
                     nil 
                     (if (eq (car pV10207) :|Product|) 
                         (let ((pV10213 (car (cdr pV10207)))) 
                           (return 
                            (labels 
                              ((findId (ls) 
                                (block 
                                 nil 
                                 (if (null ls) 
                                     (return '(:|None|)) 
                                     (if (consp ls) 
                                         (let ((pV10200 (car ls))) 
                                           (return 
                                            (if (string=  id (car pV10200)) 
                                                (progn (TYPECHECKER::elaborateSort 
                                                        env 
                                                        (METASLANG::withAnnS 
                                                         pV10225 
                                                         pos) 
                                                        (cdr pV10200)) 
                                                       (cons 
                                                        :|Some| 
                                                        (cons 
                                                         :|Fun| 
                                                         (vector 
                                                          (cons :|Project| id) 
                                                          srt 
                                                          pos)))) 
                                                (findId (cdr ls))))))) 
                                 (error 
                                  "Nonexhaustive match failure in mkProject")))) 
                              (findId pV10213)))) 
                         (if (eq (car pV10207) :|Subsort|) 
                             (return (analyzeDom (svref (cdr pV10207) 0))))) 
                     (return '(:|None|)))))) (analyzeDom pV10224))))) 
         (if (eq (car pV10218) :|Subsort|) 
             (return (TYPECHECKER::mkProject env id (svref (cdr pV10218) 0) pos)))) 
     (return '(:|None|)))))
                           
(defun TYPECHECKER::pass2Error (env pV10231 msg pos) 
  (declare (ignore pV10231)) 
  (if (svref env 3) nil (UTILITIES::|!error| env msg pos)))
                                                           
(defun UTILITIES::clearMetaTyVarLinks (meta_ty_vars) 
  (LIST-SPEC::app-1-1 
   #'(lambda (mtv) 
      (let ((pV10878 (STATE::|!!| mtv))) 
        (block 
         nil 
         (return 
          (STATE::|:=| 
           mtv 
           (vector '(:|None|) (svref pV10878 1) (svref pV10878 2)))) 
         (error "Nonexhaustive match failure in clearMetaTyVarLinks")))) 
   meta_ty_vars))
                 
(defun UTILITIES::freeTypeVars (srt) 
  (let ((vars (cons :|Ref| nil))) 
    (labels 
      ((vr (srt) 
        (block 
         nil 
         (if (eq (car srt) :|MetaTyVar|) 
             (return 
              (let ((pV11017 (UTILITIES::unlinkPSort srt))) 
                (block 
                 nil 
                 (if (eq (car pV11017) :|MetaTyVar|) 
                     (return 
                      (progn (STATE::|:=| 
                              vars 
                              (LIST-SPEC::|!cons| 
                               (car (cdr pV11017)) 
                               (STATE::|!!| vars))) 
                             srt))) 
                 (return 
                  (METASLANG::mapSort-1-1 
                   (vector #'(lambda (x) x) #'vr #'(lambda (x) x)) 
                   (METASLANG::withAnnS pV11017 (cdr (cdr srt))))))))) 
         (return srt)))) 
      (progn (METASLANG::mapSort-1-1 
              (vector #'(lambda (x) x) #'vr #'(lambda (x) x)) 
              srt) 
             (STATE::|!!| vars)))))
                                   
(defun UTILITIES::consistentSorts? (env srt1 srt2) 
  (let ((free_meta_ty_vars 
         (LIST-SPEC::|!++| 
          (UTILITIES::freeTypeVars srt1) 
          (UTILITIES::freeTypeVars srt2)))) 
    (let ((pV10905 (UTILITIES::unifySorts-1-1-1 env srt1 srt2))) 
      (block 
       nil 
       (return 
        (progn (UTILITIES::clearMetaTyVarLinks free_meta_ty_vars) (car pV10905))) 
       (error "Nonexhaustive match failure in consistentSorts?")))))
                                                                    
(defun TYPECHECKER::consistentSortOp?-1-1 (!x1 pV9871) 
  (block 
   nil 
   (if (eq (car pV9871) :|Fun|) 
       (return 
        (UTILITIES::consistentSorts? (car !x1) (cdr !x1) (svref (cdr pV9871) 1)))) 
   (error "Nonexhaustive match failure in consistentSortOp?")))
                                                               
(defun TYPECHECKER::consistentSortOp?-1 (x1) 
  #'(lambda (x2) (TYPECHECKER::consistentSortOp?-1-1 x1 x2)))
                                                             
(defun TYPECHECKER::consistentSortOp? (x0 x1) 
  (TYPECHECKER::consistentSortOp?-1 (cons x0 x1)))
                                                  
(defun TYPECHECKER::selectTermWithConsistentSort (env id pos terms srt) 
  (block 
   nil 
   (if (consp terms) (if (null (cdr terms)) (return (cons :|Some| (car terms))))) 
   (return 
    (let ((pV10283 (UTILITIES::unlinkPSort srt))) 
      (block 
       nil 
       (if (eq (car pV10283) :|MetaTyVar|) (return '(:|None|))) 
       (return 
        (let ((srtPos (METASLANG::sortAnn srt))) 
          (let ((pV10279 
                 (LIST-SPEC::filter-1-1 
                  (TYPECHECKER::consistentSortOp? 
                   env 
                   (METASLANG::withAnnS pV10283 srtPos)) 
                  terms))) 
            (block 
             nil 
             (if (null pV10279) 
                 (return 
                  (progn (UTILITIES::|!error| 
                          env 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ "No matches for op " id) 
                            " of sort ") 
                           (ANNSPECPRINTER::printSort srt)) 
                          pos) 
                         '(:|None|))) 
                 (if (consp pV10279) 
                     (if (null (cdr pV10279)) 
                         (return (cons :|Some| (car pV10279)))))) 
             (return 
              (if (svref env 3) 
                  '(:|None|) 
                  (labels 
                    ((findUnqualified (tms) 
                      (block 
                       nil 
                       (if (null tms) 
                           (return '(:|None|)) 
                           (if (consp tms) 
                               (let ((pV10258 (cdr tms))
                                     (pV10257 (car tms))) 
                                 (return 
                                  (block 
                                   nil 
                                   (if (eq (car pV10257) :|Fun|) 
                                       (let ((pV10245 (svref (cdr pV10257) 0))) 
                                         (if (eq (car pV10245) :|OneName|) 
                                             (return (cons :|Some| pV10257)) 
                                             (if (eq (car pV10245) :|TwoNames|) 
                                                 (return 
                                                  (if (string=  
                                                       (svref (cdr pV10245) 0) 
                                                       METASLANG::UnQualified) 
                                                      (cons :|Some| pV10257) 
                                                      (findUnqualified pV10258))))))) 
                                   (return (findUnqualified pV10258))))))) 
                       (error 
                        "Nonexhaustive match failure in selectTermWithConsistentSort")))) 
                    (let ((pV10277 (findUnqualified pV10279))) 
                      (block 
                       nil 
                       (if (eq (car pV10277) :|Some|) 
                           (return (cons :|Some| (cdr pV10277))) 
                           (if (eq (car pV10277) :|None|) 
                               (return 
                                (progn (UTILITIES::|!error| 
                                        env 
                                        (STRING-SPEC::^ 
                                         (STRING-SPEC::^ 
                                          (STRING-SPEC::^ 
                                           (STRING-SPEC::^ 
                                            "Several matches for overloaded op " 
                                            id) 
                                           " of sort ") 
                                          (ANNSPECPRINTER::printSort srt)) 
                                         (LIST-SPEC::foldl-1-1-1 
                                          #'(lambda (x) 
                                             (let ((tm (car x))) 
                                               (STRING-SPEC::^ 
                                                (cdr x) 
                                                (block 
                                                 nil 
                                                 (if (eq (car tm) :|Fun|) 
                                                     (let ((pV10267 
                                                            (svref (cdr tm) 0))) 
                                                       (if (eq 
                                                            (car pV10267) 
                                                            :|OneName|) 
                                                           (return 
                                                            (STRING-SPEC::^ 
                                                             " " 
                                                             (car (cdr pV10267)))) 
                                                           (if (eq 
                                                                (car pV10267) 
                                                                :|TwoNames|) 
                                                               (let ((pV10270 
                                                                      (cdr 
                                                                       pV10267))) 
                                                                 (return 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     " " 
                                                                     (svref 
                                                                      pV10270 
                                                                      0)) 
                                                                    ".") 
                                                                   (svref 
                                                                    pV10270 
                                                                    1)))))))) 
                                                 (error 
                                                  "Nonexhaustive match failure in selectTermWithConsistentSort"))))) 
                                          " : " 
                                          terms)) 
                                        pos) 
                                       '(:|None|))))) 
                       (error 
                        "Nonexhaustive match failure in selectTermWithConsistentSort")))))))))))))))


(defun TYPECHECKER::undeclared2 (env fun id1 id2 srt pos) 
  (if (svref env 3) 
      fun 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ (STRING-SPEC::^ id1 ".") id2) 
               " has not been declared as a qualified name or as a field selection") 
              pos) 
             (cons 
              :|Fun| 
              (vector (cons :|TwoNames| (vector id1 id2 nil)) srt pos)))))
                                                                          
(defun TYPECHECKER::undeclaredResolving (env fun id srt pos) 
  (if (svref env 3) 
      fun 
      (progn (UTILITIES::|!error| 
              env 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 (STRING-SPEC::^ "Name " id) 
                 " has not been declared.") 
                " Resolving with ") 
               (ANNSPECPRINTER::printSort srt)) 
              pos) 
             (cons :|Fun| (vector (cons :|OneName| (cons id nil)) srt pos)))))
                                                                              
(defun TYPECHECKER::uniqueConstr (env trm id pos) 
  (let ((pV10313 (STRINGMAP::|!find| (svref env 0) id))) 
    (block 
     nil 
     (if (eq (car pV10313) :|Some|) 
         (let ((pV10314 (cdr pV10313))) 
           (if (consp pV10314) 
               (if (null (cdr pV10314)) 
                   (return 
                    (let ((pV10309 (UTILITIES::copySort-1 (car pV10314)))) 
                      (block 
                       nil 
                       (let ((pV10311 (cdr pV10309))) 
                         (return 
                          (let ((id_srt 
                                 (block 
                                  nil 
                                  (if (eq (car pV10311) :|CoProduct|) 
                                      (let ((pV10304 (cdr pV10311))) 
                                        (return 
                                         (let ((pV10296 
                                                (LIST-SPEC::|!find|-1-1 
                                                 #'(lambda (x) 
                                                    (string=  id (car x))) 
                                                 (car pV10304)))) 
                                           (block 
                                            nil 
                                            (if (eq (car pV10296) :|Some|) 
                                                (let ((pV10299 
                                                       (cdr (cdr pV10296)))) 
                                                  (if (eq (car pV10299) :|Some|) 
                                                      (return 
                                                       (cons 
                                                        :|Arrow| 
                                                        (vector 
                                                         (cdr pV10299) 
                                                         pV10311 
                                                         (cdr pV10304))))))) 
                                            (return pV10311)))))) 
                                  (return pV10311)))) 
                            (let ((pV10307 (TYPECHECKER::mkEmbed0 env id_srt id))) 
                              (block 
                               nil 
                               (if (eq (car pV10307) :|Some|) 
                                   (return 
                                    (cons 
                                     :|Some| 
                                     (cons 
                                      :|Fun| 
                                      (vector 
                                       (cons :|Embed| (cons (cdr pV10307) nil)) 
                                       (TYPECHECKER::checkSort env id_srt) 
                                       pos)))) 
                                   (if (eq (car pV10307) :|None|) 
                                       (return 
                                        (TYPECHECKER::mkEmbed1 
                                         env 
                                         id_srt 
                                         trm 
                                         id 
                                         pos)))) 
                               (error 
                                "Nonexhaustive match failure in uniqueConstr")))))) 
                       (error "Nonexhaustive match failure in uniqueConstr")))))))) 
     (return '(:|None|)))))
                           
(defun UTILITIES::findTheOp2 (env qualifier id) 
  (findAQualifierMap (svref (svref env 5) 1) qualifier id))
                                                           
(defun UTILITIES::findVarOrOps (pV11006 pV11007 pV11008) 
  (block 
   nil 
   (let ((pV11015 (svref pV11006 6))
         (pV11014 (svref pV11006 5))) 
     (return 
      (labels 
        ((mkTerms (infos) 
          (LIST-SPEC::|!map|-1-1 
           #'(lambda (info) (mkTerm pV11008 info)) 
           infos))
         (mkTerm (pV10996 pV10997) 
          (block 
           nil 
           (let ((pV11000 (svref pV10997 2))
                 (pV10998 (svref pV10997 0))) 
             (return 
              (let ((pV10993 (UTILITIES::copySort (car pV11000) (cdr pV11000)))) 
                (block 
                 nil 
                 (return 
                  (block 
                   nil 
                   (if (consp pV10998) 
                       (let ((pV10988 (car pV10998))) 
                         (if (eq (car pV10988) :|Qualified|) 
                             (let ((pV10990 (cdr pV10988))) 
                               (return 
                                (cons 
                                 :|Fun| 
                                 (vector 
                                  (cons 
                                   :|TwoNames| 
                                   (vector 
                                    (car pV10990) 
                                    (cdr pV10990) 
                                    (svref pV10997 1))) 
                                  (cdr pV10993) 
                                  pV10996))))))) 
                   (error "Nonexhaustive match failure in findVarOrOps"))) 
                 (error "Nonexhaustive match failure in findVarOrOps"))))) 
           (error "Nonexhaustive match failure in findVarOrOps")))) 
        (let ((pV11004 (STRINGMAP::|!find| pV11015 pV11007))) 
          (block 
           nil 
           (if (eq (car pV11004) :|Some|) 
               (return 
                (cons 
                 (cons :|Var| (cons (cons pV11007 (cdr pV11004)) pV11008)) 
                 nil)) 
               (if (eq (car pV11004) :|None|) 
                   (return 
                    (mkTerms 
                     (STANDARDSPEC::wildFindUnQualified 
                      (svref pV11014 1) 
                      pV11007))))) 
           (error "Nonexhaustive match failure in findVarOrOps")))))) 
   (error "Nonexhaustive match failure in findVarOrOps")))
                                                          
(defun TYPECHECKER::aux_elaborateTerm (env trm term_sort) 
  (block 
   nil 
   (if (eq (car trm) :|Fun|) 
       (let ((pV9693 (cdr trm))) 
         (let ((pV9754 (svref pV9693 2))
               (pV9753 (svref pV9693 1))
               (pV9752 (svref pV9693 0))) 
           (if (eq (car pV9752) :|OneName|) 
               (let ((pV9773 (car (cdr pV9752)))) 
                 (return 
                  (progn (TYPECHECKER::elaborateCheckSortForTerm 
                          env 
                          trm 
                          pV9753 
                          term_sort) 
                         (let ((pV9483 
                                (UTILITIES::findVarOrOps env pV9773 pV9754))) 
                           (block 
                            nil 
                            (if (consp pV9483) 
                                (return 
                                 (let ((pV9474 
                                        (TYPECHECKER::selectTermWithConsistentSort 
                                         env 
                                         pV9773 
                                         pV9754 
                                         pV9483 
                                         term_sort))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV9474) :|None|) 
                                        (return trm) 
                                        (if (eq (car pV9474) :|Some|) 
                                            (let ((pV9475 (cdr pV9474))) 
                                              (return 
                                               (let ((srt 
                                                      (METASLANG::termSort 
                                                       pV9475))) 
                                                 (let ((srt 
                                                        (TYPECHECKER::elaborateCheckSortForTerm 
                                                         env 
                                                         pV9475 
                                                         srt 
                                                         term_sort))) 
                                                   (block 
                                                    nil 
                                                    (if (eq (car pV9475) :|Var|) 
                                                        (let ((pV9464 
                                                               (cdr pV9475))) 
                                                          (return 
                                                           (cons 
                                                            :|Var| 
                                                            (cons 
                                                             (cons 
                                                              (car (car pV9464)) 
                                                              srt) 
                                                             (cdr pV9464))))) 
                                                        (if (eq 
                                                             (car pV9475) 
                                                             :|Fun|) 
                                                            (let ((pV9463 
                                                                   (cdr pV9475))) 
                                                              (let ((pV9467 
                                                                     (svref 
                                                                      pV9463 
                                                                      2))
                                                                    (pV9465 
                                                                     (svref 
                                                                      pV9463 
                                                                      0))) 
                                                                (if (eq 
                                                                     (car pV9465) 
                                                                     :|OneName|) 
                                                                    (let ((pV9469 
                                                                           (cdr 
                                                                            pV9465))) 
                                                                      (return 
                                                                       (cons 
                                                                        :|Fun| 
                                                                        (vector 
                                                                         (cons 
                                                                          :|OneName| 
                                                                          (cons 
                                                                           (car 
                                                                            pV9469) 
                                                                           (cdr 
                                                                            pV9469))) 
                                                                         srt 
                                                                         pV9467)))) 
                                                                    (if (eq 
                                                                         (car 
                                                                          pV9465) 
                                                                         :|TwoNames|) 
                                                                        (let ((pV9468 
                                                                               (cdr 
                                                                                pV9465))) 
                                                                          (return 
                                                                           (cons 
                                                                            :|Fun| 
                                                                            (vector 
                                                                             (cons 
                                                                              :|TwoNames| 
                                                                              (vector 
                                                                               (svref 
                                                                                pV9468 
                                                                                0) 
                                                                               (svref 
                                                                                pV9468 
                                                                                1) 
                                                                               (svref 
                                                                                pV9468 
                                                                                2))) 
                                                                             srt 
                                                                             pV9467)))))))))) 
                                                    (return 
                                                     (SYSTEM-SPEC::fail 
                                                      "Variable or constant expected"))))))))) 
                                    (error 
                                     "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                            (if (null pV9483) 
                                (return 
                                 (let ((pV9481 
                                        (TYPECHECKER::mkEmbed0 env pV9753 pV9773))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV9481) :|Some|) 
                                        (return 
                                         (cons 
                                          :|Fun| 
                                          (vector 
                                           (cons 
                                            :|Embed| 
                                            (cons (cdr pV9481) nil)) 
                                           (TYPECHECKER::checkSort env pV9753) 
                                           pV9754))) 
                                        (if (eq (car pV9481) :|None|) 
                                            (return 
                                             (let ((pV9479 
                                                    (TYPECHECKER::mkEmbed1 
                                                     env 
                                                     pV9753 
                                                     trm 
                                                     pV9773 
                                                     pV9754))) 
                                               (block 
                                                nil 
                                                (if (eq (car pV9479) :|Some|) 
                                                    (return (cdr pV9479)) 
                                                    (if (eq (car pV9479) :|None|) 
                                                        (return 
                                                         (let ((pV9477 
                                                                (TYPECHECKER::uniqueConstr 
                                                                 env 
                                                                 trm 
                                                                 pV9773 
                                                                 pV9754))) 
                                                           (block 
                                                            nil 
                                                            (if (eq 
                                                                 (car pV9477) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (cdr pV9477))) 
                                                            (return 
                                                             (TYPECHECKER::undeclared 
                                                              env 
                                                              trm 
                                                              pV9773 
                                                              term_sort 
                                                              pV9754))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                    (error 
                                     "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                            (error 
                             "Nonexhaustive match failure in aux_elaborateTerm")))))) 
               (if (eq (car pV9752) :|TwoNames|) 
                   (let ((pV9766 (cdr pV9752))) 
                     (let ((pV9771 (svref pV9766 1))
                           (pV9770 (svref pV9766 0))) 
                       (return 
                        (progn (TYPECHECKER::elaborateCheckSortForTerm 
                                env 
                                trm 
                                pV9753 
                                term_sort) 
                               (let ((pV9528 
                                      (UTILITIES::findTheOp2 env pV9770 pV9771))) 
                                 (block 
                                  nil 
                                  (if (eq (car pV9528) :|Some|) 
                                      (let ((pV9529 (cdr pV9528))) 
                                        (let ((pV9532 (svref pV9529 2))
                                              (pV9530 (svref pV9529 0))) 
                                          (if (consp pV9530) 
                                              (let ((pV9535 (car pV9530))) 
                                                (if (eq 
                                                     (car pV9535) 
                                                     :|Qualified|) 
                                                    (let ((pV9537 (cdr pV9535))) 
                                                      (let ((pV9539 (cdr pV9537))
                                                            (pV9538 (car pV9537))) 
                                                        (return 
                                                         (let ((pV9498 
                                                                (UTILITIES::copySort 
                                                                 (car pV9532) 
                                                                 (cdr pV9532)))) 
                                                           (block 
                                                            nil 
                                                            (let ((pV9500 
                                                                   (cdr pV9498))) 
                                                              (return 
                                                               (let ((term 
                                                                      (cons 
                                                                       :|Fun| 
                                                                       (vector 
                                                                        (cons 
                                                                         :|TwoNames| 
                                                                         (vector 
                                                                          pV9538 
                                                                          pV9539 
                                                                          (svref 
                                                                           pV9529 
                                                                           1))) 
                                                                        pV9500 
                                                                        pV9754)))) 
                                                                 (let ((srt 
                                                                        (TYPECHECKER::elaborateCheckSortForTerm 
                                                                         env 
                                                                         term 
                                                                         pV9500 
                                                                         term_sort))) 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          term) 
                                                                         :|Fun|) 
                                                                        (let ((pV9493 
                                                                               (cdr 
                                                                                term))) 
                                                                          (let ((pV9494 
                                                                                 (svref 
                                                                                  pV9493 
                                                                                  0))) 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV9494) 
                                                                                 :|TwoNames|) 
                                                                                (let ((pV9497 
                                                                                       (cdr 
                                                                                        pV9494))) 
                                                                                  (return 
                                                                                   (cons 
                                                                                    :|Fun| 
                                                                                    (vector 
                                                                                     (cons 
                                                                                      :|TwoNames| 
                                                                                      (vector 
                                                                                       (svref 
                                                                                        pV9497 
                                                                                        0) 
                                                                                       (svref 
                                                                                        pV9497 
                                                                                        1) 
                                                                                       (svref 
                                                                                        pV9497 
                                                                                        2))) 
                                                                                     srt 
                                                                                     (svref 
                                                                                      pV9493 
                                                                                      2))))))))) 
                                                                    (return 
                                                                     (SYSTEM-SPEC::fail 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         (STRING-SPEC::^ 
                                                                          (STRING-SPEC::^ 
                                                                           (STRING-SPEC::^ 
                                                                            (STRING-SPEC::^ 
                                                                             "Op expected for elaboration of " 
                                                                             pV9770) 
                                                                            ".") 
                                                                           pV9771) 
                                                                          " as resolved to ") 
                                                                         pV9538) 
                                                                        ".") 
                                                                       pV9539)))))))) 
                                                            (error 
                                                             "Nonexhaustive match failure in aux_elaborateTerm"))))))))))) 
                                      (if (eq (car pV9528) :|None|) 
                                          (return 
                                           (let ((pV9523 
                                                  (UTILITIES::findVarOrOps 
                                                   env 
                                                   pV9770 
                                                   pV9754))) 
                                             (block 
                                              nil 
                                              (if (consp pV9523) 
                                                  (let ((pV9525 (car pV9523))) 
                                                    (if (null (cdr pV9523)) 
                                                        (return 
                                                         (let ((big_sort 
                                                                (METASLANG::termSort 
                                                                 pV9525))) 
                                                           (let ((big_sort 
                                                                  (TYPECHECKER::checkSort 
                                                                   env 
                                                                   big_sort))) 
                                                             (labels 
                                                               ((getProduct 
                                                                 (srt) 
                                                                 (let ((pV9511 
                                                                        (UTILITIES::unfoldPSort 
                                                                         env 
                                                                         srt))) 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          pV9511) 
                                                                         :|Product|) 
                                                                        (return 
                                                                         (cons 
                                                                          :|Some| 
                                                                          (car 
                                                                           (cdr 
                                                                            pV9511)))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV9511) 
                                                                             :|Subsort|) 
                                                                            (return 
                                                                             (getProduct 
                                                                              (svref 
                                                                               (cdr 
                                                                                pV9511) 
                                                                               0))))) 
                                                                    (return 
                                                                     '(:|None|)))))
                                                                (projectRow 
                                                                 (big_term 
                                                                  big_sort 
                                                                  row 
                                                                  id2) 
                                                                 (block 
                                                                  nil 
                                                                  (if (null row) 
                                                                      (return 
                                                                       (TYPECHECKER::undeclared2 
                                                                        env 
                                                                        trm 
                                                                        pV9770 
                                                                        id2 
                                                                        term_sort 
                                                                        pV9754)) 
                                                                      (if (consp 
                                                                           row) 
                                                                          (let ((pV9504 
                                                                                 (car 
                                                                                  row))) 
                                                                            (return 
                                                                             (if (string=  
                                                                                  id2 
                                                                                  (car 
                                                                                   pV9504)) 
                                                                                 (let ((field_sort 
                                                                                        (TYPECHECKER::checkSort 
                                                                                         env 
                                                                                         (cdr 
                                                                                          pV9504)))) 
                                                                                   (let ((projection 
                                                                                          (cons 
                                                                                           :|ApplyN| 
                                                                                           (cons 
                                                                                            (cons 
                                                                                             (cons 
                                                                                              :|Fun| 
                                                                                              (vector 
                                                                                               (cons 
                                                                                                :|Project| 
                                                                                                id2) 
                                                                                               (cons 
                                                                                                :|Arrow| 
                                                                                                (vector 
                                                                                                 big_sort 
                                                                                                 field_sort 
                                                                                                 pV9754)) 
                                                                                               pV9754)) 
                                                                                             (cons 
                                                                                              big_term 
                                                                                              nil)) 
                                                                                            pV9754)))) 
                                                                                     (progn (TYPECHECKER::elaborateSortForTerm 
                                                                                             env 
                                                                                             projection 
                                                                                             field_sort 
                                                                                             term_sort) 
                                                                                            projection))) 
                                                                                 (projectRow 
                                                                                  big_term 
                                                                                  big_sort 
                                                                                  (cdr 
                                                                                   row) 
                                                                                  id2)))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                                               (let ((pV9520 
                                                                      (getProduct 
                                                                       big_sort))) 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV9520) 
                                                                       :|Some|) 
                                                                      (return 
                                                                       (projectRow 
                                                                        pV9525 
                                                                        big_sort 
                                                                        (cdr 
                                                                         pV9520) 
                                                                        pV9771)) 
                                                                      (if (eq 
                                                                           (car 
                                                                            pV9520) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (TYPECHECKER::undeclared2 
                                                                            env 
                                                                            trm 
                                                                            pV9770 
                                                                            pV9771 
                                                                            term_sort 
                                                                            pV9754)))) 
                                                                  (return 
                                                                   (TYPECHECKER::undeclared2 
                                                                    env 
                                                                    trm 
                                                                    pV9770 
                                                                    pV9771 
                                                                    term_sort 
                                                                    pV9754))))))))))) 
                                              (return 
                                               (TYPECHECKER::undeclared2 
                                                env 
                                                trm 
                                                pV9770 
                                                pV9771 
                                                term_sort 
                                                pV9754))))))) 
                                  (return 
                                   (TYPECHECKER::undeclared2 
                                    env 
                                    trm 
                                    pV9770 
                                    pV9771 
                                    term_sort 
                                    pV9754)))))))) 
                   (if (eq (car pV9752) :|Embed|) 
                       (let ((pV9768 (car (cdr pV9752)))) 
                         (return 
                          (progn (TYPECHECKER::elaborateCheckSortForTerm 
                                  env 
                                  trm 
                                  pV9753 
                                  term_sort) 
                                 (let ((pV9546 
                                        (TYPECHECKER::mkEmbed0 
                                         env 
                                         term_sort 
                                         pV9768))) 
                                   (block 
                                    nil 
                                    (if (eq (car pV9546) :|Some|) 
                                        (return 
                                         (cons 
                                          :|Fun| 
                                          (vector 
                                           (cons 
                                            :|Embed| 
                                            (cons (cdr pV9546) nil)) 
                                           (TYPECHECKER::checkSort env term_sort) 
                                           pV9754))) 
                                        (if (eq (car pV9546) :|None|) 
                                            (return 
                                             (let ((pV9544 
                                                    (TYPECHECKER::mkEmbed1 
                                                     env 
                                                     term_sort 
                                                     trm 
                                                     pV9768 
                                                     pV9754))) 
                                               (block 
                                                nil 
                                                (if (eq (car pV9544) :|Some|) 
                                                    (return (cdr pV9544)) 
                                                    (if (eq (car pV9544) :|None|) 
                                                        (return 
                                                         (TYPECHECKER::undeclared 
                                                          env 
                                                          trm 
                                                          pV9768 
                                                          term_sort 
                                                          pV9754)))) 
                                                (error 
                                                 "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                    (error 
                                     "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                       (if (eq (car pV9752) :|Project|) 
                           (let ((pV9764 (cdr pV9752))) 
                             (return 
                              (let ((srt 
                                     (TYPECHECKER::elaborateCheckSortForTerm 
                                      env 
                                      trm 
                                      pV9753 
                                      term_sort))) 
                                (let ((pV9548 
                                       (TYPECHECKER::mkProject 
                                        env 
                                        pV9764 
                                        srt 
                                        pV9754))) 
                                  (block 
                                   nil 
                                   (if (eq (car pV9548) :|Some|) 
                                       (return (cdr pV9548)) 
                                       (if (eq (car pV9548) :|None|) 
                                           (return 
                                            (TYPECHECKER::undeclaredResolving 
                                             env 
                                             trm 
                                             pV9764 
                                             term_sort 
                                             pV9754)))) 
                                   (error 
                                    "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                           (if (eq (car pV9752) :|Embedded|) 
                               (let ((pV9763 (cdr pV9752))) 
                                 (return 
                                  (let ((srt 
                                         (TYPECHECKER::elaborateCheckSortForTerm 
                                          env 
                                          trm 
                                          pV9753 
                                          term_sort))) 
                                    (progn (let ((pV9556 
                                                  (UTILITIES::unfoldPSort 
                                                   env 
                                                   srt))) 
                                             (block 
                                              nil 
                                              (if (eq (car pV9556) :|Arrow|) 
                                                  (let ((pV9558 
                                                         (svref (cdr pV9556) 0))) 
                                                    (return 
                                                     (let ((pV9553 
                                                            (TYPECHECKER::isCoproduct 
                                                             env 
                                                             pV9558))) 
                                                       (block 
                                                        nil 
                                                        (if (eq 
                                                             (car pV9553) 
                                                             :|Some|) 
                                                            (return 
                                                             (if (LIST-SPEC::|!exists|-1-1 
                                                                  #'(lambda (x) 
                                                                     (string=  
                                                                      pV9763 
                                                                      (car x))) 
                                                                  (cdr pV9553)) 
                                                                 nil 
                                                                 (UTILITIES::|!error| 
                                                                  env 
                                                                  (STRING-SPEC::^ 
                                                                   (STRING-SPEC::^ 
                                                                    (STRING-SPEC::^ 
                                                                     "Name " 
                                                                     pV9763) 
                                                                    " is not among the constructors of ") 
                                                                   (ANNSPECPRINTER::printSort 
                                                                    pV9558)) 
                                                                  pV9754))) 
                                                            (if (eq 
                                                                 (car pV9553) 
                                                                 :|None|) 
                                                                (return 
                                                                 (TYPECHECKER::pass2Error 
                                                                  env 
                                                                  pV9558 
                                                                  (TYPECHECKER::newLines 
                                                                   (cons 
                                                                    (STRING-SPEC::^ 
                                                                     (STRING-SPEC::^ 
                                                                      "Sum sort with constructor " 
                                                                      pV9763) 
                                                                     " expected") 
                                                                    (cons 
                                                                     (STRING-SPEC::^ 
                                                                      "found instead " 
                                                                      (ANNSPECPRINTER::printSort 
                                                                       pV9558)) 
                                                                     nil))) 
                                                                  pV9754)))) 
                                                        (error 
                                                         "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                              (return 
                                               (TYPECHECKER::pass2Error 
                                                env 
                                                srt 
                                                "Function sort expected " 
                                                pV9754)))) 
                                           (cons 
                                            :|Fun| 
                                            (vector 
                                             (cons :|Embedded| pV9763) 
                                             srt 
                                             pV9754)))))) 
                               (if (eq (car pV9752) :|PChoose|) 
                                   (return 
                                    (let ((a (UTILITIES::freshMetaTyVar pV9754))) 
                                      (let ((b 
                                             (UTILITIES::freshMetaTyVar pV9754))) 
                                        (let ((equiv 
                                               (TYPECHECKER::elaborateTerm 
                                                env 
                                                (cdr pV9752) 
                                                (cons 
                                                 :|Arrow| 
                                                 (vector 
                                                  (cons 
                                                   :|Product| 
                                                   (cons 
                                                    (cons 
                                                     (cons "1" a) 
                                                     (cons (cons "2" a) nil)) 
                                                    pV9754)) 
                                                  TYPECHECKER::type_bool 
                                                  pV9754))))) 
                                          (let ((ty4 
                                                 (cons 
                                                  :|Arrow| 
                                                  (vector 
                                                   (cons 
                                                    :|Arrow| 
                                                    (vector a b pV9754)) 
                                                   (cons 
                                                    :|Arrow| 
                                                    (vector 
                                                     (cons 
                                                      :|Quotient| 
                                                      (vector a equiv pV9754)) 
                                                     b 
                                                     pV9754)) 
                                                   pV9754)))) 
                                            (progn (TYPECHECKER::elaborateSortForTerm 
                                                    env 
                                                    trm 
                                                    ty4 
                                                    term_sort) 
                                                   (TYPECHECKER::elaborateSortForTerm 
                                                    env 
                                                    trm 
                                                    pV9753 
                                                    ty4) 
                                                   (cons 
                                                    :|Fun| 
                                                    (vector 
                                                     (cons :|PChoose| equiv) 
                                                     pV9753 
                                                     pV9754)))))))) 
                                   (if (eq (car pV9752) :|PQuotient|) 
                                       (return 
                                        (let ((a 
                                               (UTILITIES::freshMetaTyVar pV9754))) 
                                          (let ((equiv 
                                                 (TYPECHECKER::elaborateTerm 
                                                  env 
                                                  (cdr pV9752) 
                                                  (cons 
                                                   :|Arrow| 
                                                   (vector 
                                                    (cons 
                                                     :|Product| 
                                                     (cons 
                                                      (cons 
                                                       (cons "1" a) 
                                                       (cons (cons "2" a) nil)) 
                                                      pV9754)) 
                                                    TYPECHECKER::type_bool 
                                                    pV9754))))) 
                                            (let ((ty2 
                                                   (cons 
                                                    :|Arrow| 
                                                    (vector 
                                                     a 
                                                     (cons 
                                                      :|Quotient| 
                                                      (vector a equiv pV9754)) 
                                                     pV9754)))) 
                                              (progn (TYPECHECKER::elaborateSortForTerm 
                                                      env 
                                                      trm 
                                                      ty2 
                                                      term_sort) 
                                                     (TYPECHECKER::elaborateSortForTerm 
                                                      env 
                                                      trm 
                                                      pV9753 
                                                      ty2) 
                                                     (cons 
                                                      :|Fun| 
                                                      (vector 
                                                       (cons :|PQuotient| equiv) 
                                                       pV9753 
                                                       pV9754))))))) 
                                       (if (eq (car pV9752) :|Equals|) 
                                           (return 
                                            (let ((a 
                                                   (UTILITIES::freshMetaTyVar 
                                                    pV9754))) 
                                              (let ((ty 
                                                     (cons 
                                                      :|Arrow| 
                                                      (vector 
                                                       (cons 
                                                        :|Product| 
                                                        (cons 
                                                         (cons 
                                                          (cons "1" a) 
                                                          (cons (cons "2" a) nil)) 
                                                         pV9754)) 
                                                       TYPECHECKER::type_bool 
                                                       pV9754)))) 
                                                (progn (TYPECHECKER::elaborateSortForTerm 
                                                        env 
                                                        trm 
                                                        ty 
                                                        term_sort) 
                                                       (TYPECHECKER::elaborateSortForTerm 
                                                        env 
                                                        trm 
                                                        pV9753 
                                                        ty) 
                                                       (cons 
                                                        :|Fun| 
                                                        (vector 
                                                         '(:|Equals|) 
                                                         pV9753 
                                                         pV9754)))))) 
                                           (if (eq (car pV9752) :|Bool|) 
                                               (return 
                                                (progn (TYPECHECKER::elaborateSortForTerm 
                                                        env 
                                                        trm 
                                                        TYPECHECKER::type_bool 
                                                        term_sort) 
                                                       (TYPECHECKER::elaborateCheckSortForTerm 
                                                        env 
                                                        trm 
                                                        pV9753 
                                                        TYPECHECKER::type_bool) 
                                                       (cons 
                                                        :|Fun| 
                                                        (vector 
                                                         (cons 
                                                          :|Bool| 
                                                          (cdr pV9752)) 
                                                         pV9753 
                                                         pV9754)))) 
                                               (if (eq (car pV9752) :|Nat|) 
                                                   (return 
                                                    (progn (TYPECHECKER::elaborateSortForTerm 
                                                            env 
                                                            trm 
                                                            TYPECHECKER::type_nat 
                                                            term_sort) 
                                                           (TYPECHECKER::elaborateCheckSortForTerm 
                                                            env 
                                                            trm 
                                                            pV9753 
                                                            TYPECHECKER::type_nat) 
                                                           (cons 
                                                            :|Fun| 
                                                            (vector 
                                                             (cons 
                                                              :|Nat| 
                                                              (cdr pV9752)) 
                                                             pV9753 
                                                             pV9754)))) 
                                                   (if (eq 
                                                        (car pV9752) 
                                                        :|String|) 
                                                       (return 
                                                        (progn (TYPECHECKER::elaborateSortForTerm 
                                                                env 
                                                                trm 
                                                                TYPECHECKER::type_string 
                                                                term_sort) 
                                                               (TYPECHECKER::elaborateCheckSortForTerm 
                                                                env 
                                                                trm 
                                                                pV9753 
                                                                TYPECHECKER::type_string) 
                                                               (cons 
                                                                :|Fun| 
                                                                (vector 
                                                                 (cons 
                                                                  :|String| 
                                                                  (cdr pV9752)) 
                                                                 pV9753 
                                                                 pV9754)))) 
                                                       (if (eq 
                                                            (car pV9752) 
                                                            :|Char|) 
                                                           (return 
                                                            (progn (TYPECHECKER::elaborateSortForTerm 
                                                                    env 
                                                                    trm 
                                                                    TYPECHECKER::type_char 
                                                                    term_sort) 
                                                                   (TYPECHECKER::elaborateCheckSortForTerm 
                                                                    env 
                                                                    trm 
                                                                    pV9753 
                                                                    TYPECHECKER::type_char) 
                                                                   (cons 
                                                                    :|Fun| 
                                                                    (vector 
                                                                     (cons 
                                                                      :|Char| 
                                                                      (cdr 
                                                                       pV9752)) 
                                                                     pV9753 
                                                                     pV9754)))) 
                                                           (if (eq 
                                                                (car pV9752) 
                                                                :|PRelax|) 
                                                               (return 
                                                                (let ((a 
                                                                       (UTILITIES::freshMetaTyVar 
                                                                        pV9754))) 
                                                                  (let ((pred 
                                                                         (TYPECHECKER::elaborateTerm 
                                                                          env 
                                                                          (cdr 
                                                                           pV9752) 
                                                                          (cons 
                                                                           :|Arrow| 
                                                                           (vector 
                                                                            a 
                                                                            TYPECHECKER::type_bool 
                                                                            pV9754))))) 
                                                                    (let ((ty2 
                                                                           (cons 
                                                                            :|Arrow| 
                                                                            (vector 
                                                                             (cons 
                                                                              :|Subsort| 
                                                                              (vector 
                                                                               a 
                                                                               pred 
                                                                               pV9754)) 
                                                                             a 
                                                                             pV9754)))) 
                                                                      (progn (TYPECHECKER::elaborateSortForTerm 
                                                                              env 
                                                                              trm 
                                                                              ty2 
                                                                              term_sort) 
                                                                             (TYPECHECKER::elaborateSortForTerm 
                                                                              env 
                                                                              trm 
                                                                              pV9753 
                                                                              ty2) 
                                                                             (cons 
                                                                              :|Fun| 
                                                                              (vector 
                                                                               (cons 
                                                                                :|PRelax| 
                                                                                pred) 
                                                                               pV9753 
                                                                               pV9754))))))) 
                                                               (if (eq 
                                                                    (car pV9752) 
                                                                    :|PRestrict|) 
                                                                   (return 
                                                                    (let ((a 
                                                                           (UTILITIES::freshMetaTyVar 
                                                                            pV9754))) 
                                                                      (let ((pred 
                                                                             (TYPECHECKER::elaborateTerm 
                                                                              env 
                                                                              (cdr 
                                                                               pV9752) 
                                                                              (cons 
                                                                               :|Arrow| 
                                                                               (vector 
                                                                                a 
                                                                                TYPECHECKER::type_bool 
                                                                                pV9754))))) 
                                                                        (let ((ty2 
                                                                               (cons 
                                                                                :|Arrow| 
                                                                                (vector 
                                                                                 a 
                                                                                 (cons 
                                                                                  :|Subsort| 
                                                                                  (vector 
                                                                                   a 
                                                                                   pred 
                                                                                   pV9754)) 
                                                                                 pV9754)))) 
                                                                          (progn (TYPECHECKER::elaborateSortForTerm 
                                                                                  env 
                                                                                  trm 
                                                                                  ty2 
                                                                                  term_sort) 
                                                                                 (TYPECHECKER::elaborateSortForTerm 
                                                                                  env 
                                                                                  trm 
                                                                                  pV9753 
                                                                                  ty2) 
                                                                                 (cons 
                                                                                  :|Fun| 
                                                                                  (vector 
                                                                                   (cons 
                                                                                    :|PRestrict| 
                                                                                    pred) 
                                                                                   pV9753 
                                                                                   pV9754))))))))))))))))))))))) 
       (if (eq (car trm) :|Var|) 
           (let ((pV9692 (cdr trm))) 
             (let ((pV9748 (car pV9692))) 
               (return 
                (let ((srt 
                       (TYPECHECKER::elaborateCheckSortForTerm 
                        env 
                        trm 
                        (cdr pV9748) 
                        term_sort))) 
                  (cons :|Var| (cons (cons (car pV9748) srt) (cdr pV9692))))))) 
           (if (eq (car trm) :|LetRec|) 
               (let ((pV9691 (cdr trm))) 
                 (let ((pV9747 (svref pV9691 2))
                       (pV9746 (svref pV9691 1))
                       (pV9745 (svref pV9691 0))) 
                   (return 
                    (labels 
                      ((declareFun (pV9561 pV9562) 
                        (block 
                         nil 
                         (let ((pV9563 (car pV9561))) 
                           (return 
                            (UTILITIES::addVariable 
                             pV9562 
                             (car pV9563) 
                             (cdr pV9563)))) 
                         (error 
                          "Nonexhaustive match failure in aux_elaborateTerm")))) 
                      (labels 
                        ((elaborateDecl (env) 
                          #'(lambda (x) 
                             (block 
                              nil 
                              (let ((pV9569 (car (car x)))) 
                                (return 
                                 (let ((terms 
                                        (UTILITIES::findVarOrOps 
                                         env 
                                         pV9569 
                                         pV9747))) 
                                   (let ((srt 
                                          (METASLANG::termSort 
                                           (LIST-SPEC::hd terms)))) 
                                     (let ((bdy 
                                            (TYPECHECKER::elaborateTerm 
                                             env 
                                             (cdr x) 
                                             srt))) 
                                       (cons (cons pV9569 srt) bdy)))))) 
                              (error 
                               "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                        (let ((env 
                               (LIST-SPEC::foldr-1-1-1 
                                #'(lambda (x) (declareFun (car x) (cdr x))) 
                                env 
                                pV9745))) 
                          (let ((decls 
                                 (LIST-SPEC::|!map|-1-1 
                                  (elaborateDecl env) 
                                  pV9745))) 
                            (let ((bdy 
                                   (TYPECHECKER::elaborateTerm 
                                    env 
                                    pV9746 
                                    term_sort))) 
                              (cons :|LetRec| (vector decls bdy pV9747)))))))))) 
               (if (eq (car trm) :|Let|) 
                   (let ((pV9690 (cdr trm))) 
                     (let ((pV9744 (svref pV9690 2))
                           (pV9743 (svref pV9690 1))
                           (pV9742 (svref pV9690 0))) 
                       (return 
                        (labels 
                          ((doDeclaration (pV9583 pV9584) 
                            (block 
                             nil 
                             (let ((pV9586 (cdr pV9583))
                                   (pV9585 (car pV9583))) 
                               (return 
                                (let ((alpha (UTILITIES::freshMetaTyVar pV9744))) 
                                  (let ((pV9580 
                                         (block 
                                          nil 
                                          (if (eq (car pV9585) :|SortedPat|) 
                                              (let ((pV9573 (cdr pV9585))) 
                                                (return 
                                                 (cons 
                                                  (svref pV9573 0) 
                                                  (cons 
                                                   :|SortedTerm| 
                                                   (vector 
                                                    pV9586 
                                                    (svref pV9573 1) 
                                                    (svref pV9573 2))))))) 
                                          (return (cons pV9585 pV9586))))) 
                                    (block 
                                     nil 
                                     (return 
                                      (let ((bdy 
                                             (TYPECHECKER::elaborateTerm 
                                              env 
                                              (cdr pV9580) 
                                              alpha))) 
                                        (let ((pV9577 
                                               (TYPECHECKER::elaboratePattern 
                                                (cdr pV9584) 
                                                (car pV9580) 
                                                alpha))) 
                                          (block 
                                           nil 
                                           (return 
                                            (cons 
                                             (LIST-SPEC::|!cons| 
                                              (cons (car pV9577) bdy) 
                                              (car pV9584)) 
                                             (cdr pV9577))) 
                                           (error 
                                            "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                                     (error 
                                      "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                             (error 
                              "Nonexhaustive match failure in aux_elaborateTerm")))) 
                          (let ((pV9589 
                                 (LIST-SPEC::foldr-1-1-1 
                                  #'(lambda (x) (doDeclaration (car x) (cdr x))) 
                                  (cons nil env) 
                                  pV9742))) 
                            (block 
                             nil 
                             (return 
                              (let ((body 
                                     (TYPECHECKER::elaborateTerm 
                                      (cdr pV9589) 
                                      pV9743 
                                      term_sort))) 
                                (cons :|Let| (vector (car pV9589) body pV9744)))) 
                             (error 
                              "Nonexhaustive match failure in aux_elaborateTerm"))))))) 
                   (if (eq (car trm) :|IfThenElse|) 
                       (let ((pV9689 (cdr trm))) 
                         (return 
                          (let ((test 
                                 (TYPECHECKER::elaborateTerm 
                                  env 
                                  (svref pV9689 0) 
                                  TYPECHECKER::type_bool))) 
                            (let ((thenTrm 
                                   (TYPECHECKER::elaborateTerm 
                                    env 
                                    (svref pV9689 1) 
                                    term_sort))) 
                              (let ((elseTrm 
                                     (TYPECHECKER::elaborateTerm 
                                      env 
                                      (svref pV9689 2) 
                                      term_sort))) 
                                (cons 
                                 :|IfThenElse| 
                                 (vector test thenTrm elseTrm (svref pV9689 3)))))))) 
                       (if (eq (car trm) :|Record|) 
                           (let ((pV9688 (cdr trm))) 
                             (let ((pV9737 (cdr pV9688))
                                   (pV9736 (car pV9688))) 
                               (return 
                                (labels 
                                  ((unfoldConstraint (srt) 
                                    (let ((pV9597 
                                           (UTILITIES::unfoldPSort env srt))) 
                                      (block 
                                       nil 
                                       (if (eq (car pV9597) :|Product|) 
                                           (let ((pV9606 (car (cdr pV9597)))) 
                                             (return 
                                              (progn (if (BOOLEAN-SPEC::~ 
                                                          ( =  
                                                           (LIST-SPEC::|!length| 
                                                            pV9736) 
                                                           (LIST-SPEC::|!length| 
                                                            pV9606))) 
                                                         (UTILITIES::|!error| 
                                                          env 
                                                          (TYPECHECKER::newLines 
                                                           (cons 
                                                            (ANNSPECPRINTER::printTerm 
                                                             trm) 
                                                            (cons 
                                                             "is incompatible with constraint" 
                                                             (cons 
                                                              (ANNSPECPRINTER::printSort 
                                                               term_sort) 
                                                              nil)))) 
                                                          pV9737) 
                                                         nil) 
                                                     pV9606))) 
                                           (if (eq (car pV9597) :|MetaTyVar|) 
                                               (return 
                                                (let ((row 
                                                       (LIST-SPEC::|!map|-1-1 
                                                        #'(lambda (x) 
                                                           (cons 
                                                            (car x) 
                                                            (UTILITIES::freshMetaTyVar 
                                                             pV9737))) 
                                                        pV9736))) 
                                                  (progn (UTILITIES::linkMetaTyVar-1-1 
                                                          (car (cdr pV9597)) 
                                                          (cons 
                                                           :|Product| 
                                                           (cons row pV9737))) 
                                                         row))) 
                                               (if (eq (car pV9597) :|Subsort|) 
                                                   (return 
                                                    (unfoldConstraint 
                                                     (svref (cdr pV9597) 0)))))) 
                                       (return 
                                        (progn (TYPECHECKER::pass2Error 
                                                env 
                                                pV9597 
                                                (STRING-SPEC::^ 
                                                 (STRING-SPEC::^ 
                                                  (STRING-SPEC::^ 
                                                   (ANNSPECPRINTER::printTerm 
                                                    trm) 
                                                   " is constrained to be of an incompatible sort ") 
                                                  STRING-SPEC::newline) 
                                                 (ANNSPECPRINTER::printSort 
                                                  term_sort)) 
                                                pV9737) 
                                               (LIST-SPEC::|!map|-1-1 
                                                #'(lambda (x) 
                                                   (cons 
                                                    (car x) 
                                                    (UTILITIES::freshMetaTyVar 
                                                     pV9737))) 
                                                pV9736))))))) 
                                  (let ((tyrows (unfoldConstraint term_sort))) 
                                    (let ((trow (LISTPAIR::zip pV9736 tyrows))) 
                                      (let ((row 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'(lambda (x) 
                                                 (let ((pV9609 (cdr x))
                                                       (pV9608 (car x))) 
                                                   (block 
                                                    nil 
                                                    (let ((pV9611 (cdr pV9608))
                                                          (pV9610 (car pV9608))) 
                                                      (let ((pV9612 (car pV9609))) 
                                                        (return 
                                                         (if (string=  
                                                              pV9610 
                                                              pV9612) 
                                                             (cons 
                                                              pV9610 
                                                              (TYPECHECKER::elaborateTerm 
                                                               env 
                                                               pV9611 
                                                               (cdr pV9609))) 
                                                             (progn (UTILITIES::|!error| 
                                                                     env 
                                                                     (STRING-SPEC::^ 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        "Field-name " 
                                                                        pV9610) 
                                                                       " is not the one imposed by sort constraint.  Expected field-name is: ") 
                                                                      pV9612) 
                                                                     pV9737) 
                                                                    (cons 
                                                                     pV9610 
                                                                     pV9611)))))) 
                                                    (error 
                                                     "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                              trow))) 
                                        (cons :|Record| (cons row pV9737))))))))) 
                           (if (eq (car trm) :|Lambda|) 
                               (let ((pV9687 (cdr trm))) 
                                 (let ((pV9735 (cdr pV9687))) 
                                   (return 
                                    (let ((alpha 
                                           (UTILITIES::freshMetaTyVar pV9735))) 
                                      (let ((beta 
                                             (UTILITIES::freshMetaTyVar pV9735))) 
                                        (progn (TYPECHECKER::elaborateSort 
                                                env 
                                                (cons 
                                                 :|Arrow| 
                                                 (vector alpha beta pV9735)) 
                                                term_sort) 
                                               (cons 
                                                :|Lambda| 
                                                (cons 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'(lambda (x) 
                                                     (let ((term (svref x 2))
                                                           (|!cond| (svref x 1))) 
                                                       (let ((pV9615 
                                                              (TYPECHECKER::elaboratePattern 
                                                               env 
                                                               (svref x 0) 
                                                               alpha))) 
                                                         (block 
                                                          nil 
                                                          (let ((pV9617 
                                                                 (cdr pV9615))) 
                                                            (return 
                                                             (let ((term 
                                                                    (TYPECHECKER::elaborateTerm 
                                                                     pV9617 
                                                                     term 
                                                                     beta))) 
                                                               (let ((|!cond| 
                                                                      (TYPECHECKER::elaborateTerm 
                                                                       pV9617 
                                                                       |!cond| 
                                                                       TYPECHECKER::type_bool))) 
                                                                 (vector 
                                                                  (car pV9615) 
                                                                  |!cond| 
                                                                  term))))) 
                                                          (error 
                                                           "Nonexhaustive match failure in aux_elaborateTerm"))))) 
                                                  (car pV9687)) 
                                                 pV9735)))))))) 
                               (if (eq (car trm) :|Bind|) 
                                   (let ((pV9686 (cdr trm))) 
                                     (return 
                                      (progn (TYPECHECKER::elaborateSort 
                                              env 
                                              term_sort 
                                              TYPECHECKER::type_bool) 
                                             (let ((pV9625 
                                                    (LIST-SPEC::foldl-1-1-1 
                                                     #'(lambda (x) 
                                                        (let ((pV9620 (cdr x))
                                                              (pV9619 (car x))) 
                                                          (block 
                                                           nil 
                                                           (let ((pV9621 
                                                                  (car pV9619))) 
                                                             (let ((pV9624 
                                                                    (cdr pV9620))) 
                                                               (return 
                                                                (let ((srt 
                                                                       (TYPECHECKER::checkSort 
                                                                        pV9624 
                                                                        (cdr 
                                                                         pV9619)))) 
                                                                  (cons 
                                                                   (LIST-SPEC::|!cons| 
                                                                    (cons 
                                                                     pV9621 
                                                                     srt) 
                                                                    (car pV9620)) 
                                                                   (UTILITIES::addVariable 
                                                                    pV9624 
                                                                    pV9621 
                                                                    srt)))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                                     (cons nil env) 
                                                     (svref pV9686 1)))) 
                                               (block 
                                                nil 
                                                (return 
                                                 (let ((vars 
                                                        (LIST-SPEC::rev 
                                                         (car pV9625)))) 
                                                   (cons 
                                                    :|Bind| 
                                                    (vector 
                                                     (svref pV9686 0) 
                                                     vars 
                                                     (TYPECHECKER::elaborateTerm 
                                                      (cdr pV9625) 
                                                      (svref pV9686 2) 
                                                      term_sort) 
                                                     (svref pV9686 3))))) 
                                                (error 
                                                 "Nonexhaustive match failure in aux_elaborateTerm")))))) 
                                   (if (eq (car trm) :|SortedTerm|) 
                                       (let ((pV9685 (cdr trm))) 
                                         (return 
                                          (let ((srt 
                                                 (TYPECHECKER::elaborateSort 
                                                  env 
                                                  (svref pV9685 1) 
                                                  term_sort))) 
                                            (let ((term 
                                                   (TYPECHECKER::elaborateTerm 
                                                    env 
                                                    (svref pV9685 0) 
                                                    srt))) term)))) 
                                       (if (eq (car trm) :|Seq|) 
                                           (let ((pV9684 (cdr trm))) 
                                             (let ((pV9726 (cdr pV9684))
                                                   (pV9725 (car pV9684))) 
                                               (return 
                                                (labels 
                                                  ((elab (ts) 
                                                    (block 
                                                     nil 
                                                     (if (null ts) 
                                                         (return nil) 
                                                         (if (consp ts) 
                                                             (let ((pV9632 
                                                                    (cdr ts))
                                                                   (pV9631 
                                                                    (car ts))) 
                                                               (progn (if (null 
                                                                           pV9632) 
                                                                          (return 
                                                                           (cons 
                                                                            (TYPECHECKER::elaborateTerm 
                                                                             env 
                                                                             pV9631 
                                                                             term_sort) 
                                                                            nil))) 
                                                                      (return 
                                                                       (let ((alpha 
                                                                              (UTILITIES::freshMetaTyVar 
                                                                               pV9726))) 
                                                                         (let ((|!t| 
                                                                                (TYPECHECKER::elaborateTerm 
                                                                                 env 
                                                                                 pV9631 
                                                                                 alpha))) 
                                                                           (LIST-SPEC::|!cons| 
                                                                            |!t| 
                                                                            (elab 
                                                                             pV9632))))))))) 
                                                     (error 
                                                      "Nonexhaustive match failure in aux_elaborateTerm")))) 
                                                  (cons 
                                                   :|Seq| 
                                                   (cons (elab pV9725) pV9726)))))) 
                                           (if (eq (car trm) :|ApplyN|) 
                                               (let ((pV9683 (cdr trm))) 
                                                 (let ((pV9695 (cdr pV9683))
                                                       (pV9694 (car pV9683))) 
                                                   (progn (if (consp pV9694) 
                                                              (let ((pV9698 
                                                                     (cdr pV9694))
                                                                    (pV9697 
                                                                     (car pV9694))) 
                                                                (progn (if (eq 
                                                                            (car 
                                                                             pV9697) 
                                                                            :|Fun|) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 (svref 
                                                                                  (cdr 
                                                                                   pV9697) 
                                                                                  0)) 
                                                                                :|Embedded|) 
                                                                               (if (consp 
                                                                                    pV9698) 
                                                                                   (if (null 
                                                                                        (cdr 
                                                                                         pV9698)) 
                                                                                       (return 
                                                                                        (let ((alpha 
                                                                                               (UTILITIES::freshMetaTyVar 
                                                                                                pV9695))) 
                                                                                          (let ((t2 
                                                                                                 (TYPECHECKER::elaborateTerm 
                                                                                                  env 
                                                                                                  (car 
                                                                                                   pV9698) 
                                                                                                  alpha))) 
                                                                                            (let ((t1 
                                                                                                   (TYPECHECKER::elaborateTerm 
                                                                                                    env 
                                                                                                    pV9697 
                                                                                                    (cons 
                                                                                                     :|Arrow| 
                                                                                                     (vector 
                                                                                                      alpha 
                                                                                                      term_sort 
                                                                                                      pV9695))))) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 t1 
                                                                                                 (cons 
                                                                                                  t2 
                                                                                                  nil)) 
                                                                                                pV9695)))))))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV9697) 
                                                                            :|Fun|) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 (svref 
                                                                                  (cdr 
                                                                                   pV9697) 
                                                                                  0)) 
                                                                                :|Project|) 
                                                                               (if (consp 
                                                                                    pV9698) 
                                                                                   (if (null 
                                                                                        (cdr 
                                                                                         pV9698)) 
                                                                                       (return 
                                                                                        (let ((alpha 
                                                                                               (UTILITIES::freshMetaTyVar 
                                                                                                pV9695))) 
                                                                                          (let ((t2 
                                                                                                 (TYPECHECKER::elaborateTerm 
                                                                                                  env 
                                                                                                  (car 
                                                                                                   pV9698) 
                                                                                                  alpha))) 
                                                                                            (let ((t1 
                                                                                                   (TYPECHECKER::elaborateTerm 
                                                                                                    env 
                                                                                                    pV9697 
                                                                                                    (cons 
                                                                                                     :|Arrow| 
                                                                                                     (vector 
                                                                                                      alpha 
                                                                                                      term_sort 
                                                                                                      pV9695))))) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 t1 
                                                                                                 (cons 
                                                                                                  t2 
                                                                                                  nil)) 
                                                                                                pV9695)))))))))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV9697) 
                                                                            :|Fun|) 
                                                                           (let ((pV9702 
                                                                                  (cdr 
                                                                                   pV9697))) 
                                                                             (if (consp 
                                                                                  pV9698) 
                                                                                 (if (null 
                                                                                      (cdr 
                                                                                       pV9698)) 
                                                                                     (return 
                                                                                      (let ((alpha 
                                                                                             (UTILITIES::freshMetaTyVar 
                                                                                              pV9695))) 
                                                                                        (let ((t1 
                                                                                               (TYPECHECKER::elaborateTerm 
                                                                                                env 
                                                                                                pV9697 
                                                                                                (cons 
                                                                                                 :|Arrow| 
                                                                                                 (vector 
                                                                                                  alpha 
                                                                                                  term_sort 
                                                                                                  pV9695))))) 
                                                                                          (let ((t2 
                                                                                                 (TYPECHECKER::elaborateTerm 
                                                                                                  env 
                                                                                                  (car 
                                                                                                   pV9698) 
                                                                                                  alpha))) 
                                                                                            (let ((t1 
                                                                                                   (if (lisp::and 
                                                                                                        (BOOLEAN-SPEC::~ 
                                                                                                         (svref 
                                                                                                          env 
                                                                                                          3)) 
                                                                                                        (slang-built-in::slang-term-equals 
                                                                                                         (svref 
                                                                                                          pV9702 
                                                                                                          0) 
                                                                                                         '(:|Equals|))) 
                                                                                                       (TYPECHECKER::adjustEqualitySort 
                                                                                                        env 
                                                                                                        (svref 
                                                                                                         pV9702 
                                                                                                         1) 
                                                                                                        t1 
                                                                                                        t2) 
                                                                                                       t1))) 
                                                                                              (cons 
                                                                                               :|ApplyN| 
                                                                                               (cons 
                                                                                                (cons 
                                                                                                 t1 
                                                                                                 (cons 
                                                                                                  t2 
                                                                                                  nil)) 
                                                                                                pV9695))))))))))) 
                                                                       (if (consp 
                                                                            pV9698) 
                                                                           (if (null 
                                                                                (cdr 
                                                                                 pV9698)) 
                                                                               (return 
                                                                                (let ((alpha 
                                                                                       (UTILITIES::freshMetaTyVar 
                                                                                        pV9695))) 
                                                                                  (let ((t2 
                                                                                         (TYPECHECKER::elaborateTerm 
                                                                                          env 
                                                                                          (car 
                                                                                           pV9698) 
                                                                                          alpha))) 
                                                                                    (let ((t1 
                                                                                           (TYPECHECKER::elaborateTerm 
                                                                                            env 
                                                                                            pV9697 
                                                                                            (cons 
                                                                                             :|Arrow| 
                                                                                             (vector 
                                                                                              alpha 
                                                                                              term_sort 
                                                                                              pV9695))))) 
                                                                                      (cons 
                                                                                       :|ApplyN| 
                                                                                       (cons 
                                                                                        (cons 
                                                                                         t1 
                                                                                         (cons 
                                                                                          t2 
                                                                                          nil)) 
                                                                                        pV9695))))))))))) 
                                                          (return 
                                                           (labels 
                                                             ((tagTermWithInfixInfo 
                                                               (term) 
                                                               (block 
                                                                nil 
                                                                (if (eq 
                                                                     (car term) 
                                                                     :|Fun|) 
                                                                    (let ((pV9669 
                                                                           (cdr 
                                                                            term))) 
                                                                      (let ((pV9672 
                                                                             (svref 
                                                                              pV9669 
                                                                              2))
                                                                            (pV9670 
                                                                             (svref 
                                                                              pV9669 
                                                                              0))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV9670) 
                                                                             :|OneName|) 
                                                                            (let ((pV9674 
                                                                                   (cdr 
                                                                                    pV9670))) 
                                                                              (let ((pV9680 
                                                                                     (cdr 
                                                                                      pV9674))
                                                                                    (pV9679 
                                                                                     (car 
                                                                                      pV9674))) 
                                                                                (progn (if (consp 
                                                                                            pV9680) 
                                                                                           (return 
                                                                                            (cons 
                                                                                             :|Infix| 
                                                                                             (cons 
                                                                                              term 
                                                                                              pV9680)))) 
                                                                                       (return 
                                                                                        (let ((x 
                                                                                               (TYPECHECKER::consistentTag 
                                                                                                (UTILITIES::findVarOrOps 
                                                                                                 env 
                                                                                                 pV9679 
                                                                                                 pV9672)))) 
                                                                                          (let ((pV9647 
                                                                                                 (cdr 
                                                                                                  x))) 
                                                                                            (block 
                                                                                             nil 
                                                                                             (if (eq 
                                                                                                  t 
                                                                                                  (car 
                                                                                                   x)) 
                                                                                                 (progn (if (eq 
                                                                                                             (car 
                                                                                                              pV9647) 
                                                                                                             :|Some|) 
                                                                                                            (return 
                                                                                                             (cons 
                                                                                                              :|Infix| 
                                                                                                              (cons 
                                                                                                               term 
                                                                                                               (cdr 
                                                                                                                pV9647))))) 
                                                                                                        (return 
                                                                                                         (cons 
                                                                                                          :|Nonfix| 
                                                                                                          term)))) 
                                                                                             (return 
                                                                                              (progn (UTILITIES::|!error| 
                                                                                                      env 
                                                                                                      (STRING-SPEC::^ 
                                                                                                       "Inconsistent infix information for overloaded op: " 
                                                                                                       pV9679) 
                                                                                                      pV9672) 
                                                                                                     (cons 
                                                                                                      :|Nonfix| 
                                                                                                      term)))))))))) 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV9670) 
                                                                                 :|TwoNames|) 
                                                                                (let ((pV9673 
                                                                                       (cdr 
                                                                                        pV9670))) 
                                                                                  (let ((pV9677 
                                                                                         (svref 
                                                                                          pV9673 
                                                                                          2))) 
                                                                                    (progn (if (consp 
                                                                                                pV9677) 
                                                                                               (return 
                                                                                                (cons 
                                                                                                 :|Infix| 
                                                                                                 (cons 
                                                                                                  term 
                                                                                                  pV9677)))) 
                                                                                           (return 
                                                                                            (let ((pV9658 
                                                                                                   (UTILITIES::findTheOp2 
                                                                                                    env 
                                                                                                    (svref 
                                                                                                     pV9673 
                                                                                                     0) 
                                                                                                    (svref 
                                                                                                     pV9673 
                                                                                                     1)))) 
                                                                                              (block 
                                                                                               nil 
                                                                                               (if (eq 
                                                                                                    (car 
                                                                                                     pV9658) 
                                                                                                    :|Some|) 
                                                                                                   (let ((pV9661 
                                                                                                          (svref 
                                                                                                           (cdr 
                                                                                                            pV9658) 
                                                                                                           1))) 
                                                                                                     (if (consp 
                                                                                                          pV9661) 
                                                                                                         (return 
                                                                                                          (cons 
                                                                                                           :|Infix| 
                                                                                                           (cons 
                                                                                                            term 
                                                                                                            pV9661)))))) 
                                                                                               (return 
                                                                                                (cons 
                                                                                                 :|Nonfix| 
                                                                                                 term)))))))) 
                                                                                (if (eq 
                                                                                     (car 
                                                                                      pV9670) 
                                                                                     :|Equals|) 
                                                                                    (return 
                                                                                     (cons 
                                                                                      :|Infix| 
                                                                                      (cons 
                                                                                       term 
                                                                                       (cons 
                                                                                        '(:|Left|) 
                                                                                        20)))))))))) 
                                                                (return 
                                                                 (cons 
                                                                  :|Nonfix| 
                                                                  term))))) 
                                                             (let ((term 
                                                                    (INFIX::resolveInfixes 
                                                                     #'tagTermWithInfixInfo 
                                                                     pV9695 
                                                                     pV9694))) 
                                                               (TYPECHECKER::elaborateTerm 
                                                                env 
                                                                term 
                                                                term_sort)))))))))))))))))) 
   (return trm)))
                 
(defun TYPECHECKER::elaborateTerm (env trm term_sort) 
  (TYPECHECKER::aux_elaborateTerm env trm term_sort))
                                                     
(defun TYPECHECKER::checkSort (env srt) 
  (block 
   nil 
   (if (eq (car srt) :|TyVar|) 
       (return srt) 
       (if (eq (car srt) :|MetaTyVar|) 
           (return 
            (let ((x (STATE::|!!| (car (cdr srt))))) 
              (let ((pV9782 (svref x 0))) 
                (block 
                 nil 
                 (if (eq (car pV9782) :|Some|) 
                     (return (TYPECHECKER::checkSort env (cdr pV9782)))) 
                 (return srt))))) 
           (if (eq (car srt) :|Base|) 
               (let ((pV9819 (cdr srt))) 
                 (let ((pV9837 (svref pV9819 2))
                       (pV9836 (svref pV9819 1))
                       (pV9835 (svref pV9819 0))) 
                   (return 
                    (let ((pV9806 
                           (STANDARDSPEC::findAllSorts (svref env 5) pV9835))) 
                      (block 
                       nil 
                       (if (consp pV9806) 
                           (let ((pV9808 (car pV9806))) 
                             (return 
                              (let ((pV9797 (svref pV9808 1))
                                    (pV9796 (svref pV9808 0))) 
                                (block 
                                 nil 
                                 (if (consp pV9796) 
                                     (let ((pV9800 (car pV9796))) 
                                       (return 
                                        (progn (if (BOOLEAN-SPEC::~ 
                                                    ( =  
                                                     (LIST-SPEC::|!length| 
                                                      pV9797) 
                                                     (LIST-SPEC::|!length| 
                                                      pV9836))) 
                                                   (let ((given_sort_str 
                                                          (STRING-SPEC::^ 
                                                           (METASLANG::printQualifiedId 
                                                            pV9800) 
                                                           (block 
                                                            nil 
                                                            (if (null pV9836) 
                                                                (return "") 
                                                                (if (consp 
                                                                     pV9836) 
                                                                    (return 
                                                                     (STRING-SPEC::^ 
                                                                      (STRING-SPEC::^ 
                                                                       (STRING-SPEC::^ 
                                                                        "(" 
                                                                        "??") 
                                                                       (LIST-SPEC::foldl-1-1-1 
                                                                        #'(lambda (x1) 
                                                                           (STRING-SPEC::^ 
                                                                            (STRING-SPEC::^ 
                                                                             (cdr 
                                                                              x1) 
                                                                             ", ") 
                                                                            "??")) 
                                                                        "" 
                                                                        (cdr 
                                                                         pV9836))) 
                                                                      ")")))) 
                                                            (error 
                                                             "Nonexhaustive match failure in checkSort"))))) 
                                                     (let ((found_sort_str 
                                                            (STRING-SPEC::^ 
                                                             (METASLANG::printQualifiedId 
                                                              pV9800) 
                                                             (block 
                                                              nil 
                                                              (if (null pV9797) 
                                                                  (return "") 
                                                                  (if (consp 
                                                                       pV9797) 
                                                                      (return 
                                                                       (STRING-SPEC::^ 
                                                                        (STRING-SPEC::^ 
                                                                         (STRING-SPEC::^ 
                                                                          "(" 
                                                                          (car 
                                                                           pV9797)) 
                                                                         (LIST-SPEC::foldl-1-1-1 
                                                                          #'(lambda (x1) 
                                                                             (STRING-SPEC::^ 
                                                                              (STRING-SPEC::^ 
                                                                               (cdr 
                                                                                x1) 
                                                                               ", ") 
                                                                              (car 
                                                                               x1))) 
                                                                          "" 
                                                                          (cdr 
                                                                           pV9797))) 
                                                                        ")")))) 
                                                              (error 
                                                               "Nonexhaustive match failure in checkSort"))))) 
                                                       (UTILITIES::|!error| 
                                                        env 
                                                        (STRING-SPEC::^ 
                                                         (STRING-SPEC::^ 
                                                          (STRING-SPEC::^ 
                                                           "Sort reference " 
                                                           given_sort_str) 
                                                          " does not match declared sort ") 
                                                         found_sort_str) 
                                                        pV9837))) 
                                                   nil) 
                                               (cons 
                                                :|Base| 
                                                (vector 
                                                 pV9800 
                                                 (LIST-SPEC::|!map|-1-1 
                                                  #'(lambda (instance_sort) 
                                                     (TYPECHECKER::checkSort 
                                                      env 
                                                      instance_sort)) 
                                                  pV9836) 
                                                 pV9837)))))) 
                                 (error 
                                  "Nonexhaustive match failure in checkSort"))))) 
                           (if (null pV9806) 
                               (return 
                                (progn (let ((given_sort_str 
                                              (STRING-SPEC::^ 
                                               (METASLANG::printQualifiedId 
                                                pV9835) 
                                               (block 
                                                nil 
                                                (if (null pV9836) 
                                                    (return "") 
                                                    (if (consp pV9836) 
                                                        (return 
                                                         (STRING-SPEC::^ 
                                                          (STRING-SPEC::^ 
                                                           (STRING-SPEC::^ 
                                                            "(" 
                                                            "??") 
                                                           (LIST-SPEC::foldl-1-1-1 
                                                            #'(lambda (x) 
                                                               (STRING-SPEC::^ 
                                                                (STRING-SPEC::^ 
                                                                 (cdr x) 
                                                                 ", ") 
                                                                "??")) 
                                                            "" 
                                                            (cdr pV9836))) 
                                                          ")")))) 
                                                (error 
                                                 "Nonexhaustive match failure in checkSort"))))) 
                                         (UTILITIES::|!error| 
                                          env 
                                          (STRING-SPEC::^ 
                                           (STRING-SPEC::^ 
                                            "Sort identifier in " 
                                            given_sort_str) 
                                           " has not been declared") 
                                          pV9837)) 
                                       (cons 
                                        :|Base| 
                                        (vector pV9835 pV9836 pV9837)))))) 
                       (error "Nonexhaustive match failure in checkSort")))))) 
               (if (eq (car srt) :|CoProduct|) 
                   (let ((pV9818 (cdr srt))) 
                     (return 
                      (cons 
                       :|CoProduct| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (let ((pV9811 (cdr x))
                                  (pV9810 (car x))) 
                              (block 
                               nil 
                               (if (eq (car pV9811) :|None|) 
                                   (return (cons pV9810 '(:|None|))) 
                                   (if (eq (car pV9811) :|Some|) 
                                       (return 
                                        (cons 
                                         pV9810 
                                         (cons 
                                          :|Some| 
                                          (TYPECHECKER::checkSort 
                                           env 
                                           (cdr pV9811))))))) 
                               (error "Nonexhaustive match failure in checkSort")))) 
                         (car pV9818)) 
                        (cdr pV9818))))) 
                   (if (eq (car srt) :|Product|) 
                       (let ((pV9817 (cdr srt))) 
                         (return 
                          (cons 
                           :|Product| 
                           (cons 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (car x) 
                                 (TYPECHECKER::checkSort env (cdr x)))) 
                             (car pV9817)) 
                            (cdr pV9817))))) 
                       (if (eq (car srt) :|Quotient|) 
                           (let ((pV9816 (cdr srt))) 
                             (let ((pV9830 (svref pV9816 2))) 
                               (return 
                                (let ((new_base_sort 
                                       (TYPECHECKER::checkSort 
                                        env 
                                        (svref pV9816 0)))) 
                                  (let ((new_relation 
                                         (TYPECHECKER::elaborateTerm 
                                          env 
                                          (svref pV9816 1) 
                                          (cons 
                                           :|Arrow| 
                                           (vector 
                                            (cons 
                                             :|Product| 
                                             (cons 
                                              (cons 
                                               (cons "1" new_base_sort) 
                                               (cons 
                                                (cons "2" new_base_sort) 
                                                nil)) 
                                              pV9830)) 
                                            TYPECHECKER::type_bool 
                                            pV9830))))) 
                                    (cons 
                                     :|Quotient| 
                                     (vector new_base_sort new_relation pV9830))))))) 
                           (if (eq (car srt) :|Subsort|) 
                               (let ((pV9815 (cdr srt))) 
                                 (let ((pV9827 (svref pV9815 2))) 
                                   (return 
                                    (let ((new_super_sort 
                                           (TYPECHECKER::checkSort 
                                            env 
                                            (svref pV9815 0)))) 
                                      (let ((new_predicate 
                                             (TYPECHECKER::elaborateTerm 
                                              env 
                                              (svref pV9815 1) 
                                              (cons 
                                               :|Arrow| 
                                               (vector 
                                                new_super_sort 
                                                TYPECHECKER::type_bool 
                                                pV9827))))) 
                                        (cons 
                                         :|Subsort| 
                                         (vector 
                                          new_super_sort 
                                          new_predicate 
                                          pV9827))))))) 
                               (if (eq (car srt) :|Arrow|) 
                                   (let ((pV9814 (cdr srt))) 
                                     (return 
                                      (cons 
                                       :|Arrow| 
                                       (vector 
                                        (TYPECHECKER::checkSort 
                                         env 
                                         (svref pV9814 0)) 
                                        (TYPECHECKER::checkSort 
                                         env 
                                         (svref pV9814 1)) 
                                        (svref pV9814 2))))))))))))) 
   (error "Nonexhaustive match failure in checkSort")))
                                                       
(defun UTILITIES::sameCPSort? (s1 s2) 
  (block 
   nil 
   (if (eq (car s1) :|CoProduct|) 
       (let ((pV11882 (car (cdr s1)))) 
         (if (eq (car s2) :|CoProduct|) 
             (let ((pV11885 (car (cdr s2)))) 
               (return 
                (lisp::and 
                 ( =  
                  (LIST-SPEC::|!length| pV11882) 
                  (LIST-SPEC::|!length| pV11885)) 
                 (LIST-SPEC::all-1-1 
                  #'(lambda (x) 
                     (let ((cs1 (cdr x))
                           (id1 (car x))) 
                       (LIST-SPEC::|!exists|-1-1 
                        #'(lambda (x1) 
                           (lisp::and 
                            (string=  id1 (car x1)) 
                            (slang-built-in::slang-term-equals cs1 (cdr x1)))) 
                        pV11885))) 
                  pV11882))))))) 
   (return nil)))
                 
(defun UTILITIES::computeConstrMap-1 (spc) 
  (let ((sorts (svref spc 3))) 
    (let ((constrMap (cons :|Ref| STRINGMAP::empty))) 
      (labels 
        ((addConstr (id tvs cp_srt constrMap) 
          (let ((cMap (STATE::|!!| constrMap))) 
            (let ((pV10892 (STRINGMAP::|!find| cMap id))) 
              (block 
               nil 
               (if (eq (car pV10892) :|None|) 
                   (return 
                    (STATE::|:=| 
                     constrMap 
                     (STRINGMAP::insert cMap id (cons (cons tvs cp_srt) nil)))) 
                   (if (eq (car pV10892) :|Some|) 
                       (let ((pV10893 (cdr pV10892))) 
                         (return 
                          (if (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (x) 
                                  (UTILITIES::sameCPSort? (cdr x) cp_srt)) 
                               pV10893) 
                              nil 
                              (STATE::|:=| 
                               constrMap 
                               (STRINGMAP::insert 
                                cMap 
                                id 
                                (LIST-SPEC::|!cons| (cons tvs cp_srt) pV10893)))))))) 
               (error "Nonexhaustive match failure in computeConstrMap")))))) 
        (labels 
          ((addSort (tvs srt constrMap) 
            (block 
             nil 
             (if (eq (car srt) :|CoProduct|) 
                 (return 
                  (LIST-SPEC::app-1-1 
                   #'(lambda (x) (addConstr (car x) tvs srt constrMap)) 
                   (car (cdr srt))))) 
             (return nil)))) 
          (progn (appAQualifierMap-1-1 
                  #'(lambda (x) 
                     (let ((opt_def (svref x 2))) 
                       (block 
                        nil 
                        (if (eq (car opt_def) :|None|) 
                            (return nil) 
                            (if (eq (car opt_def) :|Some|) 
                                (return 
                                 (addSort (svref x 1) (cdr opt_def) constrMap)))) 
                        (error "Nonexhaustive match failure in computeConstrMap")))) 
                  sorts) 
                 (STATE::|!!| constrMap)))))))
                                              
(defun UTILITIES::addConstrsEnv (pV10846 pV10847) 
  (block 
   nil 
   (return 
    (vector 
     (UTILITIES::computeConstrMap-1 pV10847) 
     (svref pV10846 1) 
     (svref pV10846 2) 
     (svref pV10846 3) 
     (svref pV10846 4) 
     pV10847 
     (svref pV10846 6))) 
   (error "Nonexhaustive match failure in addConstrsEnv")))
                                                           
(defun UTILITIES::gotoErrorLocation (errors) 
  (block 
   nil 
   (if (consp errors) 
       (let ((pV11099 (cdr (car errors)))) 
         (return 
          (block 
           nil 
           (if (eq (car pV11099) :|File|) 
               (let ((pV11086 (cdr pV11099))) 
                 (let ((pV11088 (svref pV11086 1))) 
                   (return 
                    (IO-SPEC::gotoFilePosition 
                     (svref pV11086 0) 
                     (svref pV11088 0) 
                     (svref pV11088 1)))))) 
           (return (UTILITIES::gotoErrorLocation (cdr errors))))))) 
   (return nil)))
                 
(defun UTILITIES::checkErrors-1 (env) 
  (let ((errors (svref env 1))) 
    (labels 
      ((compare (pV10866 pV10867) 
        (block 
         nil 
         (return 
          (let ((pV10865 (POSITION-SPEC::compare (cdr pV10866) (cdr pV10867)))) 
            (block 
             nil 
             (if (eq (car pV10865) :|Equal|) 
                 (return (STRING-SPEC::compare (car pV10866) (car pV10867)))) 
             (return pV10865)))) 
         (error "Nonexhaustive match failure in checkErrors")))) 
      (let ((errors 
             (MERGESORT::uniqueSort-1-1 
              #'(lambda (x) (compare (car x) (cdr x))) 
              (STATE::|!!| errors)))) 
        (let ((errMsg (cons :|Ref| ""))) 
          (let ((last_file (cons :|Ref| ""))) 
            (labels 
              ((printError (msg pos) 
                (let ((same_file? 
                       (block 
                        nil 
                        (if (eq (car pos) :|File|) 
                            (let ((pV10875 (svref (cdr pos) 0))) 
                              (return 
                               (let ((same? 
                                      (string=  pV10875 (STATE::|!!| last_file)))) 
                                 (progn (STATE::|:=| last_file pV10875) same?))))) 
                        (return nil)))) 
                  (STATE::|:=| 
                   errMsg 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STATE::|!!| errMsg) 
                       (funcall (if same_file? 
                                    #'POSITION-SPEC::|!print| 
                                    #'POSITION-SPEC::printAll) 
                                pos)) 
                      " : ") 
                     msg) 
                    (PRETTYPRINT::newlineString)))))) 
              (if (LIST-SPEC::|!null| errors) 
                  '(:|None|) 
                  (progn (UTILITIES::gotoErrorLocation errors) 
                         (LIST-SPEC::app-1-1 
                          #'(lambda (x) (printError (car x) (cdr x))) 
                          errors) 
                         (cons :|Some| (STATE::|!!| errMsg)))))))))))
                                                                     
(defun UTILITIES::initialEnv (spc file) 
  (block 
   nil 
   (return 
    (let ((pV11101 (UTILITIES::freshMetaTyVar (cons :|Internal| "ignored")))) 
      (block 
       nil 
       (if (eq (car pV11101) :|MetaTyVar|) 
           (return 
            (vector 
             STRINGMAP::empty 
             (cons :|Ref| nil) 
             file 
             t 
             STRINGMAP::empty 
             (vector (svref spc 0) (svref spc 1) (svref spc 2) (svref spc 3)) 
             STRINGMAP::empty))) 
       (error "Nonexhaustive match failure in initialEnv")))) 
   (error "Nonexhaustive match failure in initialEnv")))
                                                        
(defun UTILITIES::initializeMetaTyVar () (STATE::|:=| UTILITIES::counter 0))
                                                                            
(defun UTILITIES::secondPass
 (constrs errors file pV11887 importMap internal vars) 
  (declare (ignore pV11887)) 
  (vector constrs errors file nil importMap internal vars))
                                                           
(defun UTILITIES::secondPass-1 (x) 
  (UTILITIES::secondPass 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))
                
(defun TYPECHECKER::elaboratePosSpec (given_spec filename) 
  (progn (UTILITIES::initializeMetaTyVar) 
         (let ((env_1 (UTILITIES::initialEnv given_spec filename))) 
           (block 
            nil 
            (let ((pV10128 (svref given_spec 3))
                  (pV10127 (svref given_spec 2))
                  (pV10126 (svref given_spec 1))
                  (pV10125 (svref given_spec 0))) 
              (let ((pV10132 (svref pV10125 3))
                    (pV10131 (svref pV10125 2))) 
                (return 
                 (labels 
                   ((elaborate_sort_0 (pV10032 pV10033 pV10034) 
                     (block 
                      nil 
                      (let ((pV10037 (svref pV10034 2))) 
                        (return 
                         (if (BOOLEAN-SPEC::~ 
                              (memberQualifiedId pV10032 pV10033 pV10132)) 
                             pV10034 
                             (vector 
                              (svref pV10034 0) 
                              (svref pV10034 1) 
                              (block 
                               nil 
                               (if (eq (car pV10037) :|None|) 
                                   (return '(:|None|)) 
                                   (if (eq (car pV10037) :|Some|) 
                                       (return 
                                        (cons 
                                         :|Some| 
                                         (TYPECHECKER::checkSort 
                                          env_1 
                                          (cdr pV10037)))))) 
                               (error 
                                "Nonexhaustive match failure in elaboratePosSpec")))))) 
                      (error "Nonexhaustive match failure in elaboratePosSpec")))) 
                   (let ((sorts_1 
                          (mapiAQualifierMap-1-1 
                           #'(lambda (x) 
                              (elaborate_sort_0 
                               (svref x 0) 
                               (svref x 1) 
                               (svref x 2))) 
                           pV10128))) 
                     (let ((env_2 
                            (UTILITIES::addConstrsEnv 
                             env_1 
                             (vector pV10125 pV10126 pV10127 sorts_1)))) 
                       (labels 
                         ((elaborate_op_1 (poly?) 
                           #'(lambda (x) 
                              (let ((pV10042 (svref x 2))) 
                                (block 
                                 nil 
                                 (let ((pV10046 (svref pV10042 3))
                                       (pV10045 (svref pV10042 2))) 
                                   (let ((pV10047 (car pV10045))) 
                                     (return 
                                      (if (BOOLEAN-SPEC::~ 
                                           (memberQualifiedId 
                                            (svref x 0) 
                                            (svref x 1) 
                                            pV10131)) 
                                          pV10042 
                                          (let ((srt_2 
                                                 (TYPECHECKER::checkSort 
                                                  env_2 
                                                  (cdr pV10045)))) 
                                            (vector 
                                             (svref pV10042 0) 
                                             (svref pV10042 1) 
                                             (cons pV10047 srt_2) 
                                             (block 
                                              nil 
                                              (if (eq (car pV10046) :|None|) 
                                                  (return '(:|None|)) 
                                                  (if (eq (car pV10046) :|Some|) 
                                                      (let ((pV10039 
                                                             (cdr pV10046))) 
                                                        (return 
                                                         (let ((term_2 
                                                                (if (eq 
                                                                     poly? 
                                                                     (BOOLEAN-SPEC::~ 
                                                                      (slang-built-in::slang-term-equals 
                                                                       pV10047 
                                                                       nil))) 
                                                                    (TYPECHECKER::elaborateTerm 
                                                                     env_2 
                                                                     pV10039 
                                                                     srt_2) 
                                                                    pV10039))) 
                                                           (cons :|Some| term_2)))))) 
                                              (error 
                                               "Nonexhaustive match failure in elaboratePosSpec")))))))) 
                                 (error 
                                  "Nonexhaustive match failure in elaboratePosSpec")))))) 
                         (let ((ops_2_a 
                                (mapiAQualifierMap-1-1 
                                 (elaborate_op_1 t) 
                                 pV10126))) 
                           (let ((ops_2_b 
                                  (mapiAQualifierMap-1-1 
                                   (elaborate_op_1 nil) 
                                   ops_2_a))) 
                             (let ((ops_2_c 
                                    (mapiAQualifierMap-1-1 
                                     (elaborate_op_1 t) 
                                     ops_2_b))) 
                               (let ((ops_2 
                                      (mapiAQualifierMap-1-1 
                                       (elaborate_op_1 nil) 
                                       ops_2_c))) 
                                 (labels 
                                   ((elaborate_fm_1 
                                     (prop_type name type_vars_1 fm_1) 
                                     (let ((fm_2 
                                            (TYPECHECKER::elaborateTerm 
                                             env_2 
                                             fm_1 
                                             TYPECHECKER::type_bool))) 
                                       (vector prop_type name type_vars_1 fm_2)))) 
                                   (let ((props_2 
                                          (LIST-SPEC::|!map|-1-1 
                                           #'(lambda (x) 
                                              (elaborate_fm_1 
                                               (svref x 0) 
                                               (svref x 1) 
                                               (svref x 2) 
                                               (svref x 3))) 
                                           pV10127))) 
                                     (let ((env_3 
                                            (UTILITIES::secondPass-1 env_2))) 
                                       (labels 
                                         ((elaborate_sort_2 
                                           (pV10051 pV10052 pV10053) 
                                           (declare (ignore pV10051 pV10052)) 
                                           (block 
                                            nil 
                                            (let ((pV10056 (svref pV10053 2))) 
                                              (return 
                                               (vector 
                                                (svref pV10053 0) 
                                                (svref pV10053 1) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV10056) :|None|) 
                                                     (return '(:|None|)) 
                                                     (if (eq 
                                                          (car pV10056) 
                                                          :|Some|) 
                                                         (return 
                                                          (cons 
                                                           :|Some| 
                                                           (TYPECHECKER::checkSort 
                                                            env_3 
                                                            (cdr pV10056)))))) 
                                                 (error 
                                                  "Nonexhaustive match failure in elaboratePosSpec"))))) 
                                            (error 
                                             "Nonexhaustive match failure in elaboratePosSpec")))) 
                                         (let ((sorts_3 
                                                (mapiAQualifierMap-1-1 
                                                 #'(lambda (x) 
                                                    (elaborate_sort_2 
                                                     (svref x 0) 
                                                     (svref x 1) 
                                                     (svref x 2))) 
                                                 sorts_1))) 
                                           (labels 
                                             ((elaborate_op_2 
                                               (pV10113 pV10114 pV10115) 
                                               (block 
                                                nil 
                                                (let ((pV10119 (svref pV10115 3))
                                                      (pV10118 (svref pV10115 2))) 
                                                  (let ((pV10120 (car pV10118))) 
                                                    (return 
                                                     (if (BOOLEAN-SPEC::~ 
                                                          (memberQualifiedId 
                                                           pV10113 
                                                           pV10114 
                                                           pV10131)) 
                                                         pV10115 
                                                         (let ((srt_3 
                                                                (TYPECHECKER::checkSort 
                                                                 env_3 
                                                                 (cdr pV10118)))) 
                                                           (vector 
                                                            (svref pV10115 0) 
                                                            (svref pV10115 1) 
                                                            (cons pV10120 srt_3) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV10119) 
                                                                  :|None|) 
                                                                 (return 
                                                                  '(:|None|)) 
                                                                 (if (eq 
                                                                      (car 
                                                                       pV10119) 
                                                                      :|Some|) 
                                                                     (let ((pV10112 
                                                                            (cdr 
                                                                             pV10119))) 
                                                                       (return 
                                                                        (let ((pos 
                                                                               (METASLANG::termAnn 
                                                                                pV10112))) 
                                                                          (let ((term_3 
                                                                                 (TYPECHECKER::elaborateTerm 
                                                                                  env_3 
                                                                                  pV10112 
                                                                                  srt_3))) 
                                                                            (let ((all_different? 
                                                                                   (TYPECHECKER::checkDifferent 
                                                                                    pV10120 
                                                                                    STRINGSET::empty))) 
                                                                              (let ((tvpe_vars_used 
                                                                                     (let ((tv_cell 
                                                                                            (cons 
                                                                                             :|Ref| 
                                                                                             nil))) 
                                                                                       (labels 
                                                                                         ((insert 
                                                                                           (tv) 
                                                                                           (STATE::|:=| 
                                                                                            tv_cell 
                                                                                            (LISTUTILITIES::insert 
                                                                                             tv 
                                                                                             (STATE::|!!| 
                                                                                              tv_cell))))) 
                                                                                         (labels 
                                                                                           ((record_type_vars_used 
                                                                                             (aSrt) 
                                                                                             (block 
                                                                                              nil 
                                                                                              (if (eq 
                                                                                                   (car 
                                                                                                    aSrt) 
                                                                                                   :|MetaTyVar|) 
                                                                                                  (return 
                                                                                                   (let ((pV10061 
                                                                                                          (STATE::|!!| 
                                                                                                           (car 
                                                                                                            (cdr 
                                                                                                             aSrt))))) 
                                                                                                     (block 
                                                                                                      nil 
                                                                                                      (let ((pV10062 
                                                                                                             (svref 
                                                                                                              pV10061 
                                                                                                              0))) 
                                                                                                        (return 
                                                                                                         (block 
                                                                                                          nil 
                                                                                                          (if (eq 
                                                                                                               (car 
                                                                                                                pV10062) 
                                                                                                               :|Some|) 
                                                                                                              (return 
                                                                                                               (record_type_vars_used 
                                                                                                                (cdr 
                                                                                                                 pV10062))) 
                                                                                                              (if (eq 
                                                                                                                   (car 
                                                                                                                    pV10062) 
                                                                                                                   :|None|) 
                                                                                                                  (return 
                                                                                                                   (UTILITIES::|!error| 
                                                                                                                    env_3 
                                                                                                                    (STRING-SPEC::^ 
                                                                                                                     (STRING-SPEC::^ 
                                                                                                                      (STRING-SPEC::^ 
                                                                                                                       (STRING-SPEC::^ 
                                                                                                                        "Incomplete sort for op " 
                                                                                                                        pV10114) 
                                                                                                                       ":") 
                                                                                                                      STRING-SPEC::newline) 
                                                                                                                     (ANNSPECPRINTER::printSort 
                                                                                                                      srt_3)) 
                                                                                                                    pos)))) 
                                                                                                          (error 
                                                                                                           "Nonexhaustive match failure in elaboratePosSpec")))) 
                                                                                                      (error 
                                                                                                       "Nonexhaustive match failure in elaboratePosSpec")))) 
                                                                                                  (if (eq 
                                                                                                       (car 
                                                                                                        aSrt) 
                                                                                                       :|TyVar|) 
                                                                                                      (return 
                                                                                                       (insert 
                                                                                                        (car 
                                                                                                         (cdr 
                                                                                                          aSrt)))) 
                                                                                                      (if (eq 
                                                                                                           (car 
                                                                                                            aSrt) 
                                                                                                           :|Product|) 
                                                                                                          (return 
                                                                                                           (LIST-SPEC::app-1-1 
                                                                                                            #'(lambda (x) 
                                                                                                               (record_type_vars_used 
                                                                                                                (cdr 
                                                                                                                 x))) 
                                                                                                            (car 
                                                                                                             (cdr 
                                                                                                              aSrt)))) 
                                                                                                          (if (eq 
                                                                                                               (car 
                                                                                                                aSrt) 
                                                                                                               :|CoProduct|) 
                                                                                                              (return 
                                                                                                               (LIST-SPEC::app-1-1 
                                                                                                                #'(lambda (x) 
                                                                                                                   (let ((pV10072 
                                                                                                                          (cdr 
                                                                                                                           x))) 
                                                                                                                     (block 
                                                                                                                      nil 
                                                                                                                      (if (eq 
                                                                                                                           (car 
                                                                                                                            pV10072) 
                                                                                                                           :|Some|) 
                                                                                                                          (return 
                                                                                                                           (record_type_vars_used 
                                                                                                                            (cdr 
                                                                                                                             pV10072)))) 
                                                                                                                      (return 
                                                                                                                       nil)))) 
                                                                                                                (car 
                                                                                                                 (cdr 
                                                                                                                  aSrt)))) 
                                                                                                              (if (eq 
                                                                                                                   (car 
                                                                                                                    aSrt) 
                                                                                                                   :|Subsort|) 
                                                                                                                  (return 
                                                                                                                   (record_type_vars_used 
                                                                                                                    (svref 
                                                                                                                     (cdr 
                                                                                                                      aSrt) 
                                                                                                                     0))) 
                                                                                                                  (if (eq 
                                                                                                                       (car 
                                                                                                                        aSrt) 
                                                                                                                       :|Quotient|) 
                                                                                                                      (return 
                                                                                                                       (record_type_vars_used 
                                                                                                                        (svref 
                                                                                                                         (cdr 
                                                                                                                          aSrt) 
                                                                                                                         0))) 
                                                                                                                      (if (eq 
                                                                                                                           (car 
                                                                                                                            aSrt) 
                                                                                                                           :|Arrow|) 
                                                                                                                          (let ((pV10083 
                                                                                                                                 (cdr 
                                                                                                                                  aSrt))) 
                                                                                                                            (return 
                                                                                                                             (progn (record_type_vars_used 
                                                                                                                                     (svref 
                                                                                                                                      pV10083 
                                                                                                                                      0)) 
                                                                                                                                    (record_type_vars_used 
                                                                                                                                     (svref 
                                                                                                                                      pV10083 
                                                                                                                                      1))))) 
                                                                                                                          (if (eq 
                                                                                                                               (car 
                                                                                                                                aSrt) 
                                                                                                                               :|Base|) 
                                                                                                                              (return 
                                                                                                                               (LIST-SPEC::app-1-1 
                                                                                                                                #'record_type_vars_used 
                                                                                                                                (svref 
                                                                                                                                 (cdr 
                                                                                                                                  aSrt) 
                                                                                                                                 1))))))))))) 
                                                                                              (error 
                                                                                               "Nonexhaustive match failure in elaboratePosSpec")))) 
                                                                                           (progn (record_type_vars_used 
                                                                                                   srt_3) 
                                                                                                  (STATE::|!!| 
                                                                                                   tv_cell))))))) 
                                                                                (let ((type_vars_3_b 
                                                                                       (if (LIST-SPEC::|!null| 
                                                                                            pV10120) 
                                                                                           tvpe_vars_used 
                                                                                           (if ( =  
                                                                                                (LIST-SPEC::|!length| 
                                                                                                 tvpe_vars_used) 
                                                                                                (LIST-SPEC::|!length| 
                                                                                                 pV10120)) 
                                                                                               tvpe_vars_used 
                                                                                               (let ((scheme 
                                                                                                      (cons 
                                                                                                       pV10120 
                                                                                                       srt_3))) 
                                                                                                 (let ((scheme 
                                                                                                        (ANNSPECPRINTER::printSortScheme-1 
                                                                                                         scheme))) 
                                                                                                   (progn (UTILITIES::|!error| 
                                                                                                           env_3 
                                                                                                           (STRING-SPEC::^ 
                                                                                                            "mismatch between bound and free variables " 
                                                                                                            scheme) 
                                                                                                           pos) 
                                                                                                          pV10120))))))) 
                                                                                  (progn (if all_different? 
                                                                                             nil 
                                                                                             (let ((scheme 
                                                                                                    (cons 
                                                                                                     type_vars_3_b 
                                                                                                     srt_3))) 
                                                                                               (let ((scheme 
                                                                                                      (ANNSPECPRINTER::printSortScheme-1 
                                                                                                       scheme))) 
                                                                                                 (UTILITIES::|!error| 
                                                                                                  env_3 
                                                                                                  (STRING-SPEC::^ 
                                                                                                   "Repeated sort variables contained in " 
                                                                                                   scheme) 
                                                                                                  pos)))) 
                                                                                         (cons 
                                                                                          :|Some| 
                                                                                          term_3))))))))))) 
                                                             (error 
                                                              "Nonexhaustive match failure in elaboratePosSpec")))))))) 
                                                (error 
                                                 "Nonexhaustive match failure in elaboratePosSpec")))) 
                                             (let ((ops_3 
                                                    (mapiAQualifierMap-1-1 
                                                     #'(lambda (x) 
                                                        (elaborate_op_2 
                                                         (svref x 0) 
                                                         (svref x 1) 
                                                         (svref x 2))) 
                                                     ops_2))) 
                                               (labels 
                                                 ((elaborate_fm_2 
                                                   (prop_type 
                                                    name 
                                                    type_vars_2 
                                                    fm_2) 
                                                   (let ((fm_3 
                                                          (TYPECHECKER::elaborateTerm 
                                                           env_3 
                                                           fm_2 
                                                           TYPECHECKER::type_bool))) 
                                                     (vector 
                                                      prop_type 
                                                      name 
                                                      type_vars_2 
                                                      fm_3)))) 
                                                 (let ((props_3 
                                                        (LIST-SPEC::|!map|-1-1 
                                                         #'(lambda (x) 
                                                            (elaborate_fm_2 
                                                             (svref x 0) 
                                                             (svref x 1) 
                                                             (svref x 2) 
                                                             (svref x 3))) 
                                                         props_2))) 
                                                   (let ((spec_3 
                                                          (vector 
                                                           pV10125 
                                                           ops_3 
                                                           props_3 
                                                           sorts_3))) 
                                                     (let ((pV10122 
                                                            (UTILITIES::checkErrors-1 
                                                             env_3))) 
                                                       (block 
                                                        nil 
                                                        (if (eq 
                                                             (car pV10122) 
                                                             :|None|) 
                                                            (return 
                                                             (cons 
                                                              :|Ok| 
                                                              (vector 
                                                               (svref spec_3 0) 
                                                               (svref spec_3 1) 
                                                               (svref spec_3 2) 
                                                               (svref spec_3 3)))) 
                                                            (if (eq 
                                                                 (car pV10122) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (cons 
                                                                  :|Error| 
                                                                  (cdr pV10122))))) 
                                                        (error 
                                                         "Nonexhaustive match failure in elaboratePosSpec")))))))))))))))))))))))) 
            (error "Nonexhaustive match failure in elaboratePosSpec")))))
                                                                         
(defun SPECCALC::elaborateSpecM-1 (spc) 
  (SPECCALC::monadBind 
   #'SPECCALC::getCurrentURI-1 
   #'(lambda (uri) 
      (SPECCALC::monadBind 
       (SPECCALC::|!return| (STRING-SPEC::^ (SPECCALC::uriToPath-1 uri) ".sw")) 
       #'(lambda (filename) 
          (SPECCALC::monadSeq 
           (SPECCALC::hackMemory) 
           (SPECCALC::monadSeq 
            (SPECCALC::|!print| 
             (STRING-SPEC::^ 
              (STRING-SPEC::^ 
               (STRING-SPEC::^ 
                (STRING-SPEC::^ 
                 ";;; Processing spec " 
                 (let ((pV5254 (car uri))) 
                   (block 
                    nil 
                    (if (eq (car pV5254) :|Some|) 
                        (return (STRING-SPEC::^ (cdr pV5254) " "))) 
                    (return "")))) 
                "in ") 
               filename) 
              "
")) 
            (let ((pV5256 (TYPECHECKER::elaboratePosSpec spc filename))) 
              (block 
               nil 
               (if (eq (car pV5256) :|Ok|) 
                   (return 
                    (SPECCALC::|!return| 
                     (POSSPECTOSPEC::convertPosSpecToSpec-1 (cdr pV5256)))) 
                   (if (eq (car pV5256) :|Error|) 
                       (return 
                        (SPECCALC::raise (cons :|OldTypeCheck| (cdr pV5256)))))) 
               (error "Nonexhaustive match failure in elaborateSpecM"))))))))))
                                                                               
(defun SPECCALC::elaborateSpecM (x0 x1 x2 x3) 
  (SPECCALC::elaborateSpecM-1 (vector x0 x1 x2 x3)))
                                                    
(defun SPECCALC::elaborateSpecM-1-1 (x1 x2) 
  (funcall (SPECCALC::elaborateSpecM-1 x1) x2))
                                               
(defun SPECCALC::|!error|-1-1 (x1 x2) (funcall (SPECCALC::|!error| x1) x2))
                                                                           
(defun SPECCALC::positionOf (pV6244 |!position|) 
  (declare (ignore pV6244)) 
  |!position|)
              
(defun SPECCALC::positionOf-1 (x) (SPECCALC::positionOf (car x) (cdr x)))
                                                                         
(defun SPECCALC::valueOf (value pV7039) (declare (ignore pV7039)) 
                                        value)
                                              
(defun SPECCALC::valueOf-1 (x) (SPECCALC::valueOf (car x) (cdr x)))
                                                                   
(defun SPECCALC::evaluateDiagElem (dgm timeStamp depURIs) 
  #'(lambda (elem) 
     (let ((pV5268 (SPECCALC::valueOf-1 elem))) 
       (block 
        nil 
        (if (eq (car pV5268) :|Node|) 
            (let ((pV5270 (cdr pV5268))) 
              (let ((pV5276 (cdr pV5270))
                    (pV5275 (car pV5270))) 
                (return 
                 (SPECCALC::monadBind 
                  (SPECCALC::evaluateTermInfo-1 pV5276) 
                  #'(lambda (x) 
                     (let ((termDeps (svref x 2))
                           (termTime (svref x 1))) 
                       (let ((pV5263 (SPECCALC::coerceToSpec (svref x 0)))) 
                         (block 
                          nil 
                          (if (eq (car pV5263) :|Spec|) 
                              (return 
                               (SPECCALC::monadBind 
                                (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 
                                                            dgm) 
                                                           pV5275) 
                                                  (cdr pV5263)) 
                                         (SPECCALC::positionOf-1 pV5276)) 
                                #'(lambda (newDgm) 
                                   (SPECCALC::|!return| 
                                    (vector 
                                     newDgm 
                                     (INTEGER-SPEC::|!max| timeStamp termTime) 
                                     (LISTUTILITIES::listUnion depURIs termDeps))))))) 
                          (return 
                           (SPECCALC::raise 
                            (cons 
                             :|TypeCheck| 
                             (cons 
                              (SPECCALC::positionOf-1 pV5276) 
                              "diagram node not labeled with a specification")))))))))))) 
            (if (eq (car pV5268) :|Edge|) 
                (let ((pV5269 (cdr pV5268))) 
                  (let ((pV5274 (svref pV5269 3))
                        (pV5273 (svref pV5269 2))
                        (pV5272 (svref pV5269 1))
                        (pV5271 (svref pV5269 0))) 
                    (return 
                     (SPECCALC::monadBind 
                      (SPECCALC::evaluateTermInfo-1 pV5274) 
                      #'(lambda (x) 
                         (let ((termDeps (svref x 2))
                               (termTime (svref x 1))
                               (termValue (svref x 0))) 
                           (block 
                            nil 
                            (if (eq (car termValue) :|Morph|) 
                                (let ((pV5267 (cdr termValue))) 
                                  (return 
                                   (if (CAT::edgeInDiagram?-1-1 dgm pV5271) 
                                       (if (lisp::and 
                                            (string=  
                                             pV5272 
                                             (SKETCH::|!eval|-1-1 
                                              (SKETCH::src-1 (CAT::shape-1 dgm)) 
                                              pV5271)) 
                                            (string=  
                                             pV5273 
                                             (SKETCH::|!eval|-1-1 
                                              (SKETCH::target-1 
                                               (CAT::shape-1 dgm)) 
                                              pV5271))) 
                                           (if (slang-built-in::slang-term-equals 
                                                pV5267 
                                                (CAT::edgeLabel-1-1 dgm pV5271)) 
                                               (SPECCALC::|!return| 
                                                (vector 
                                                 dgm 
                                                 (INTEGER-SPEC::|!max| 
                                                  timeStamp 
                                                  termTime) 
                                                 (LISTUTILITIES::listUnion 
                                                  depURIs 
                                                  termDeps))) 
                                               (SPECCALC::raise 
                                                (cons 
                                                 :|DiagError| 
                                                 (cons 
                                                  (SPECCALC::positionOf-1 pV5274) 
                                                  (STRING-SPEC::^ 
                                                   (STRING-SPEC::^ 
                                                    "edge " 
                                                    pV5271) 
                                                   " inconsistently labeled in diagram"))))) 
                                           (SPECCALC::raise 
                                            (cons 
                                             :|DiagError| 
                                             (cons 
                                              (SPECCALC::positionOf-1 pV5274) 
                                              (STRING-SPEC::^ 
                                               (STRING-SPEC::^ "edge " pV5271) 
                                               " has inconsisent source and/or target"))))) 
                                       (SPECCALC::monadBind 
                                        (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 
                                                                    dgm) 
                                                                   pV5272) 
                                                          (SPECCALC::dom-1 
                                                           pV5267)) 
                                                 (SPECCALC::positionOf-1 pV5274)) 
                                        #'(lambda (dgm1) 
                                           (SPECCALC::monadBind 
                                            (funcall (funcall (funcall (SPECCALC::addLabelledVertex-1 
                                                                        dgm1) 
                                                                       pV5273) 
                                                              (SPECCALC::cod-1 
                                                               pV5267)) 
                                                     (SPECCALC::positionOf-1 
                                                      pV5274)) 
                                            #'(lambda (dgm2) 
                                               (let ((dgm3 
                                                      (CAT::labelEdge-1-1-1 
                                                       (CAT::addEdge-1-1-1-1 
                                                        dgm2 
                                                        pV5271 
                                                        pV5272 
                                                        pV5273) 
                                                       pV5271 
                                                       pV5267))) 
                                                 (SPECCALC::|!return| 
                                                  (vector 
                                                   dgm3 
                                                   (INTEGER-SPEC::|!max| 
                                                    timeStamp 
                                                    termTime) 
                                                   (LISTUTILITIES::listUnion 
                                                    depURIs 
                                                    termDeps)))))))))))) 
                            (return 
                             (SPECCALC::raise 
                              (cons 
                               :|TypeCheck| 
                               (cons 
                                (SPECCALC::positionOf-1 pV5274) 
                                "diagram edge not labeled by a morphism"))))))))))))) 
        (error "Nonexhaustive match failure in evaluateDiagElem")))))
                                                                     
(defun SPECCALC::evaluateDiagElem-1 (x) 
  (SPECCALC::evaluateDiagElem (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun SPECCALC::ppAOpInfo-1 (|!opInfo|) 
  (let ((optTerm (svref |!opInfo| 3))
        (srtScheme (svref |!opInfo| 2))
        (names (svref |!opInfo| 0))) 
    (let ((ppNames 
           (block 
            nil 
            (if (null names) 
                (return 
                 (SYSTEM-SPEC::fail "ppAOpInfo: empty name list in sort info")) 
                (if (consp names) 
                    (if (null (cdr names)) 
                        (return (SPECCALC::ppQualifiedId (car names)))))) 
            (return 
             (WADLERLINDIG::ppConcat 
              (cons 
               (WADLERLINDIG::ppString "{") 
               (cons 
                (WADLERLINDIG::ppSep-1-1 
                 (WADLERLINDIG::ppString ",") 
                 (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppQualifiedId names)) 
                (cons (WADLERLINDIG::ppString "}") nil)))))))) 
      (let ((ppSrtScheme 
             (let ((pV6273 (cdr srtScheme))
                   (pV6272 (car srtScheme))) 
               (block 
                nil 
                (if (null pV6272) (return (SPECCALC::ppASort pV6273))) 
                (return 
                 (WADLERLINDIG::ppConcat 
                  (cons 
                   (WADLERLINDIG::ppString "fa (") 
                   (cons 
                    (WADLERLINDIG::ppSep-1-1 
                     (WADLERLINDIG::ppString ",") 
                     (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString pV6272)) 
                    (cons 
                     (WADLERLINDIG::ppString ") ") 
                     (cons (SPECCALC::ppASort pV6273) nil)))))) 
                (error "Nonexhaustive match failure in ppAOpInfo"))))) 
        (let ((ppTrm 
               (block 
                nil 
                (if (eq (car optTerm) :|None|) 
                    (return WADLERLINDIG::ppNil) 
                    (if (eq (car optTerm) :|Some|) 
                        (return 
                         (WADLERLINDIG::ppConcat 
                          (cons 
                           WADLERLINDIG::ppNewline 
                           (cons 
                            (WADLERLINDIG::ppGroup 
                             (WADLERLINDIG::ppConcat 
                              (cons 
                               (WADLERLINDIG::ppString "def ") 
                               (cons 
                                ppNames 
                                (cons 
                                 (WADLERLINDIG::ppGroup 
                                  (WADLERLINDIG::ppIndent 
                                   (WADLERLINDIG::ppConcat 
                                    (cons 
                                     (WADLERLINDIG::ppString " =") 
                                     (cons 
                                      WADLERLINDIG::ppBreak 
                                      (cons 
                                       (WADLERLINDIG::ppGroup 
                                        (SPECCALC::ppATerm (cdr optTerm))) 
                                       nil)))))) 
                                 nil))))) 
                            nil)))))) 
                (error "Nonexhaustive match failure in ppAOpInfo")))) 
          (WADLERLINDIG::ppConcat 
           (cons 
            ppNames 
            (cons 
             (WADLERLINDIG::ppString " : ") 
             (cons ppSrtScheme (cons ppTrm nil))))))))))
                                                        
(defun SPECCALC::ppASortInfo-1 (sortInfo) 
  (let ((optSort (svref sortInfo 2))
        (|!tyVars| (svref sortInfo 1))
        (names (svref sortInfo 0))) 
    (let ((ppNames 
           (block 
            nil 
            (if (null names) 
                (return 
                 (SYSTEM-SPEC::fail "ppASortInfo: empty name list in sort info")) 
                (if (consp names) 
                    (if (null (cdr names)) 
                        (return (SPECCALC::ppQualifiedId (car names)))))) 
            (return 
             (WADLERLINDIG::ppConcat 
              (cons 
               (WADLERLINDIG::ppString "{") 
               (cons 
                (WADLERLINDIG::ppSep-1-1 
                 (WADLERLINDIG::ppString ",") 
                 (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppQualifiedId names)) 
                (cons (WADLERLINDIG::ppString "}") nil)))))))) 
      (let ((ppTyVars 
             (block 
              nil 
              (if (null |!tyVars|) 
                  (return WADLERLINDIG::ppNil) 
                  (if (consp |!tyVars|) 
                      (progn (if (null (cdr |!tyVars|)) 
                                 (return 
                                  (WADLERLINDIG::ppString 
                                   (STRING-SPEC::^ " " (car |!tyVars|))))) 
                             (return 
                              (WADLERLINDIG::ppConcat 
                               (cons 
                                (WADLERLINDIG::ppString " (") 
                                (cons 
                                 (WADLERLINDIG::ppSep-1-1 
                                  (WADLERLINDIG::ppString ",") 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'WADLERLINDIG::ppString 
                                   |!tyVars|)) 
                                 (cons (WADLERLINDIG::ppString ")") nil)))))))) 
              (error "Nonexhaustive match failure in ppASortInfo")))) 
        (let ((ppSrt 
               (block 
                nil 
                (if (eq (car optSort) :|None|) 
                    (return WADLERLINDIG::ppNil) 
                    (if (eq (car optSort) :|Some|) 
                        (return 
                         (WADLERLINDIG::ppAppend-1-1 
                          (WADLERLINDIG::ppString " = ") 
                          (SPECCALC::ppASort (cdr optSort)))))) 
                (error "Nonexhaustive match failure in ppASortInfo")))) 
          (WADLERLINDIG::ppConcat 
           (cons 
            ppNames 
            (cons 
             ppTyVars 
             (cons (WADLERLINDIG::ppGroup (WADLERLINDIG::ppIndent ppSrt)) nil)))))))))


(defun SPECCALC::ppASpec-1 (spc) 
  (let ((properties (svref spc 2))) 
    (let ((ppImports 
           (block 
            nil 
            (return 
             (let ((ppNames 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x1) 
                        (WADLERLINDIG::ppString 
                         (STRING-SPEC::^ "import " (car x1)))) 
                     (svref (svref spc 0) 1)))) 
               (WADLERLINDIG::ppSep-1-1 WADLERLINDIG::ppNewline ppNames))) 
            (error "Nonexhaustive match failure in ppASpec")))) 
      (labels 
        ((doSortInfo (sortInfo) 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString "sort ") 
            (cons (SPECCALC::ppASortInfo-1 sortInfo) nil))))) 
        (labels 
          ((doOpInfo (|!opInfo|) 
            (WADLERLINDIG::ppConcat 
             (cons 
              (WADLERLINDIG::ppString "op ") 
              (cons (SPECCALC::ppAOpInfo-1 |!opInfo|) nil))))) 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString "spec {") 
            (cons 
             (WADLERLINDIG::ppIndent 
              (WADLERLINDIG::ppConcat 
               (cons 
                WADLERLINDIG::ppNewline 
                (cons 
                 (WADLERLINDIG::ppSep-1-1 
                  WADLERLINDIG::ppNewline 
                  (cons 
                   ppImports 
                   (cons 
                    (WADLERLINDIG::ppSep-1-1 
                     WADLERLINDIG::ppNewline 
                     (LIST-SPEC::|!map|-1-1 #'doSortInfo (sortInfosAsList-1 spc))) 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      WADLERLINDIG::ppNewline 
                      (LIST-SPEC::|!map|-1-1 #'doOpInfo (opInfosAsList-1 spc))) 
                     (cons 
                      (WADLERLINDIG::ppSep-1-1 
                       WADLERLINDIG::ppNewline 
                       (LIST-SPEC::|!map|-1-1 
                        #'SPECCALC::ppAProperty-1 
                        properties)) 
                      nil))))) 
                 nil)))) 
             (cons (WADLERLINDIG::ppString "}") nil)))))))))
                                                            
(defun SPECCALC::ppMorphMap (|!map|) 
  (let ((abbrevMap 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (newMap) 
             #'(lambda (d) 
                #'(lambda (c) 
                   (if (slang-built-in::slang-term-equals d c) 
                       newMap 
                       (POLYMAP::update-1-1-1 newMap d c))))) 
          POLYMAP::emptyMap 
          |!map|))) 
    (if (slang-built-in::slang-term-equals abbrevMap POLYMAP::emptyMap) 
        (WADLERLINDIG::ppString "{}") 
        (WADLERLINDIG::ppGroup 
         (WADLERLINDIG::ppIndent 
          (WADLERLINDIG::ppConcat 
           (cons 
            (WADLERLINDIG::ppString "{") 
            (cons 
             WADLERLINDIG::ppBreak 
             (cons 
              (WADLERLINDIG::ppGroup 
               (WADLERLINDIG::ppSep-1-1 
                (WADLERLINDIG::ppCons-1-1 
                 (WADLERLINDIG::ppString ",") 
                 WADLERLINDIG::ppBreak) 
                (POLYMAP::foldMap-1-1-1 
                 #'(lambda (l) 
                    #'(lambda (dom) 
                       #'(lambda (cod) 
                          (cons 
                           (WADLERLINDIG::ppConcat 
                            (cons 
                             (SPECCALC::ppQualifiedId dom) 
                             (cons 
                              (WADLERLINDIG::ppString " +-> ") 
                              (cons (SPECCALC::ppQualifiedId cod) nil)))) 
                           l)))) 
                 nil 
                 abbrevMap))) 
              (cons 
               WADLERLINDIG::ppBreak 
               (cons (WADLERLINDIG::ppString "}") nil)))))))))))
                                                                
(defun SPECCALC::ppMorphism (pV6567 pV6568 opMap sortMap) 
  (declare (ignore pV6567 pV6568)) 
  (WADLERLINDIG::ppGroup 
   (WADLERLINDIG::ppConcat 
    (cons 
     (WADLERLINDIG::ppString "sort map = ") 
     (cons 
      (SPECCALC::ppMorphMap sortMap) 
      (cons 
       WADLERLINDIG::ppNewline 
       (cons 
        (WADLERLINDIG::ppString "op map = ") 
        (cons (SPECCALC::ppMorphMap opMap) nil))))))))
                                                      
(defun SPECCALC::ppMorphism-1 (x) 
  (SPECCALC::ppMorphism (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                         
(defun SPECCALC::generateFileList-1 (uri) 
  (SPECCALC::|!return| 
   (cons (cons uri (STRING-SPEC::^ (SPECCALC::uriToPath-1 uri) ".sw")) nil)))
                                                                             
(defun SPECCALC::mapM (f) 
  #'(lambda (l) 
     (block 
      nil 
      (if (null l) 
          (return (SPECCALC::|!return| nil)) 
          (if (consp l) 
              (let ((pV5978 (cdr l))) 
                (return 
                 (SPECCALC::monadBind 
                  (funcall f (car l)) 
                  #'(lambda (xNew) 
                     (SPECCALC::monadBind 
                      (funcall (SPECCALC::mapM f) pV5978) 
                      #'(lambda (xsNew) (SPECCALC::|!return| (cons xNew xsNew)))))))))) 
      (error "Nonexhaustive match failure in mapM"))))
                                                      
(defun SPECCALC::pathStringToCanonicalURI (str) 
  (let ((str 
         (STRING-SPEC::|!map|-1-1 
          #'(lambda (pV6214) 
             (block nil (if (eq #\\ pV6214) (return #\/)) (return pV6214))) 
          str))) 
    (let ((absoluteString 
           (let ((pV6217 (STRING-SPEC::explode str))) 
             (block 
              nil 
              (if (consp pV6217) 
                  (let ((pV6220 (cdr pV6217))
                        (pV6219 (car pV6217))) 
                    (progn (if (eq #\/ pV6219) (return str)) 
                           (if (consp pV6220) 
                               (if (eq #\: (car pV6220)) 
                                   (return 
                                    (STRING-SPEC::^ 
                                     (STRING-SPEC::^ 
                                      (CHAR-SPEC::toString 
                                       (CHAR-SPEC::toUpperCase pV6219)) 
                                      ":") 
                                     (STRING-SPEC::implode (cdr pV6220))))))))) 
              (return 
               (STRING-SPEC::|!++| 
                (STRING-SPEC::|!++| (IO-SPEC::getCurrentDirectory) "/") 
                str)))))) 
      (cons '(:|None|) (SPECCALC::splitStringAtChar-1-1 #\/ absoluteString)))))
                                                                               
(defun SPECCALC::pathToCanonicalURI (str) 
  (SPECCALC::|!return| (SPECCALC::pathStringToCanonicalURI str)))
                                                                 
(defun SPECCALC::getSpecPath (x2 x1 x0 x) 
  (funcall (let ((strings 
                  (let ((pV5592 (SYSTEM-SPEC::getEnv "SWPATH"))) 
                    (block 
                     nil 
                     (if (eq (car pV5592) :|Some|) 
                         (return 
                          (LIST-SPEC::|!++| 
                           (SPECCALC::splitStringAtChar-1-1 
                            SPECCALC::specPathSeparator 
                            (cdr pV5592)) 
                           (cons (IO-SPEC::getCurrentDirectory) nil)))) 
                     (return 
                      (cons (IO-SPEC::getCurrentDirectory) (cons "/" nil))))))) 
             (funcall (SPECCALC::mapM #'SPECCALC::pathToCanonicalURI) strings)) 
           (vector x2 x1 x0 x)))
                                
(defun SPECCALC::getSpecPath-1 (x) 
  (SPECCALC::getSpecPath (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                          
(defun SPECCALC::normalizeURI (hashSuffix path) 
  (labels 
    ((iterate (current) 
      #'(lambda (next) 
         (if (slang-built-in::slang-term-equals current next) 
             current 
             (funcall (iterate next) (onePass next)))))
     (onePass (elems) 
      (block 
       nil 
       (if (null elems) 
           (return nil) 
           (if (consp elems) 
               (let ((pV6210 (cdr elems))
                     (pV6209 (car elems))) 
                 (progn (if (consp pV6210) 
                            (let ((pV6213 (cdr pV6210))
                                  (pV6212 (car pV6210))) 
                              (if (string=  "." pV6212) 
                                  (return (cons pV6209 pV6213)) 
                                  (if (string=  ".." pV6212) (return pV6213))))) 
                        (return (cons pV6209 (onePass pV6210))))))) 
       (error "Nonexhaustive match failure in normalizeURI")))) 
    (cons 
     hashSuffix 
     (SPECCALC::addDevice? (funcall (iterate path) (onePass path))))))
                                                                      
(defun SPECCALC::removeLast (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "removeLast: encountered empty list")) 
       (if (consp elems) 
           (let ((pV6798 (cdr elems))
                 (pV6797 (car elems))) 
             (progn (if (null pV6798) (return (SPECCALC::|!return| nil))) 
                    (return 
                     (SPECCALC::monadBind 
                      (SPECCALC::removeLast pV6798) 
                      #'(lambda (suffix) 
                         (SPECCALC::|!return| (cons pV6797 suffix))))))))) 
   (error "Nonexhaustive match failure in removeLast")))
                                                        
(defun SPECCALC::generateURIList (uri) 
  (block 
   nil 
   (if (eq (car uri) :|SpecPath_Relative|) 
       (let ((pV5571 (cdr uri))) 
         (let ((pV5575 (cdr pV5571))
               (pV5574 (car pV5571))) 
           (return 
            (SPECCALC::monadBind 
             #'SPECCALC::getSpecPath-1 
             #'(lambda (specPath) 
                (SPECCALC::|!return| 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) 
                     (SPECCALC::normalizeURI 
                      pV5574 
                      (LIST-SPEC::|!++| (cdr x) pV5575))) 
                  specPath))))))) 
       (if (eq (car uri) :|URI_Relative|) 
           (let ((pV5570 (cdr uri))) 
             (let ((pV5573 (cdr pV5570))
                   (pV5572 (car pV5570))) 
               (return 
                (SPECCALC::monadBind 
                 #'SPECCALC::getCurrentURI-1 
                 #'(lambda (x) 
                    (let ((currentPath (cdr x))
                          (currentSuffix (car x))) 
                      (SPECCALC::monadBind 
                       (SPECCALC::removeLast currentPath) 
                       #'(lambda (root) 
                          (block 
                           nil 
                           (if (eq (car currentSuffix) :|Some|) 
                               (if (consp pV5573) 
                                   (if (null (cdr pV5573)) 
                                       (if (eq (car pV5572) :|None|) 
                                           (return 
                                            (SPECCALC::|!return| 
                                             (cons 
                                              (SPECCALC::normalizeURI 
                                               (cons :|Some| (car pV5573)) 
                                               currentPath) 
                                              (cons 
                                               (SPECCALC::normalizeURI 
                                                '(:|None|) 
                                                (LIST-SPEC::|!++| root pV5573)) 
                                               nil)))))))) 
                           (return 
                            (SPECCALC::|!return| 
                             (cons 
                              (SPECCALC::normalizeURI 
                               pV5572 
                               (LIST-SPEC::|!++| root pV5573)) 
                              nil))) 
                           (error 
                            "Nonexhaustive match failure in generateURIList")))))))))))) 
   (error "Nonexhaustive match failure in generateURIList")))
                                                             
(defun SPECCALC::lookupInLocalContext-1-1 (uri state) 
  (cons (cons :|Ok| (POLYMAP::evalPartial-1-1 (svref state 1) uri)) state))
                                                                           
(defun SPECCALC::lookupInLocalContext (x1) 
  #'(lambda (x2) (SPECCALC::lookupInLocalContext-1-1 x1 x2)))
                                                             
(defun SPECCALC::lookupInGlobalContext-1-1 (uri state) 
  (cons (cons :|Ok| (POLYMAP::evalPartial-1-1 (svref state 0) uri)) state))
                                                                           
(defun SPECCALC::lookupInGlobalContext-1 (x1) 
  #'(lambda (x2) (SPECCALC::lookupInGlobalContext-1-1 x1 x2)))
                                                              
(defparameter SPECCALC::futureTimeStamp 9999999999)
                                                   
(defun SPECCALC::removeFromGlobalContext-1-1 (uri x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (POLYMAP::|!remove|-1-1 (svref x 0) uri) 
    (svref x 1) 
    (svref x 2) 
    (svref x 3))))
                  
(defun SPECCALC::removeFromGlobalContext-1 (x1) 
  #'(lambda (x2) (SPECCALC::removeFromGlobalContext-1-1 x1 x2)))
                                                                
(defun SPECCALC::setValidatedURI-1-1 (uri x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (svref x 0) 
    (svref x 1) 
    (svref x 2) 
    (LIST-SPEC::|!cons| uri (svref x 3)))))
                                           
(defun SPECCALC::setValidatedURI-1 (x1) 
  #'(lambda (x2) (SPECCALC::setValidatedURI-1-1 x1 x2)))
                                                        
(defun SPECCALC::upToDate? (uri timeStamp) 
  (let ((|!fileName| (STRING-SPEC::^ (SPECCALC::uriToPath-1 uri) ".sw"))) 
    (INTEGER-SPEC::|!<=| (IO-SPEC::fileWriteTime |!fileName|) timeStamp)))
                                                                          
(defun SPECCALC::validatedURI?-1-1 (uri state) 
  (cons (cons :|Ok| (LIST-SPEC::|!member| uri (svref state 3))) state))
                                                                       
(defun SPECCALC::validatedURI?-1 (x1) 
  #'(lambda (x2) (SPECCALC::validatedURI?-1-1 x1 x2)))
                                                      
(defun SPECCALC::validateCache-1 (uri) 
  (SPECCALC::monadBind 
   (SPECCALC::validatedURI?-1 uri) 
   #'(lambda (validated?) 
      (if validated? 
          (SPECCALC::|!return| 0) 
          (SPECCALC::monadBind 
           (SPECCALC::lookupInGlobalContext-1 uri) 
           #'(lambda (optValue) 
              (block 
               nil 
               (if (eq (car optValue) :|None|) 
                   (return (SPECCALC::|!return| SPECCALC::futureTimeStamp)) 
                   (if (eq (car optValue) :|Some|) 
                       (let ((pV7035 (cdr optValue))) 
                         (let ((pV7037 (svref pV7035 1))) 
                           (return 
                            (SPECCALC::monadBind 
                             (funcall (funcall (SPECCALC::foldM 
                                                #'(lambda (val) 
                                                   #'(lambda (depURI) 
                                                      (SPECCALC::monadBind 
                                                       (SPECCALC::validateCache-1 
                                                        depURI) 
                                                       #'(lambda (dVal) 
                                                          (SPECCALC::|!return| 
                                                           (INTEGER-SPEC::|!max| 
                                                            val 
                                                            dVal))))))) 
                                               pV7037) 
                                      (svref pV7035 2)) 
                             #'(lambda (rVal) 
                                (if (lisp::and 
                                     (INTEGER-SPEC::|!>=| pV7037 rVal) 
                                     (SPECCALC::upToDate? uri rVal)) 
                                    (SPECCALC::monadSeq 
                                     (SPECCALC::setValidatedURI-1 uri) 
                                     (SPECCALC::|!return| rVal)) 
                                    (SPECCALC::monadSeq 
                                     (SPECCALC::removeFromGlobalContext-1 uri) 
                                     (SPECCALC::|!return| 
                                      SPECCALC::futureTimeStamp)))))))))) 
               (error "Nonexhaustive match failure in validateCache"))))))))
                                                                            
(defun SPECCALC::searchContextForURI (uris) 
  (block 
   nil 
   (if (null uris) 
       (return (SPECCALC::|!return| '(:|None|))) 
       (if (consp uris) 
           (let ((pV6821 (cdr uris))
                 (pV6820 (car uris))) 
             (return 
              (SPECCALC::monadBind 
               (SPECCALC::lookupInGlobalContext-1 pV6820) 
               #'(lambda (optValue) 
                  (block 
                   nil 
                   (if (eq (car optValue) :|Some|) 
                       (let ((pV6814 (cdr optValue))) 
                         (let ((pV6816 (svref pV6814 1))
                               (pV6815 (svref pV6814 0))) 
                           (return 
                            (block 
                             nil 
                             (if (eq (car pV6815) :|InProcess|) 
                                 (return 
                                  (SPECCALC::raise 
                                   (cons 
                                    :|CircularDefinition| 
                                    (cons (car pV6820) (cdr pV6820)))))) 
                             (return 
                              (SPECCALC::monadBind 
                               (SPECCALC::validateCache-1 pV6820) 
                               #'(lambda (cacheTS) 
                                  (SPECCALC::|!return| 
                                   (if (INTEGER-SPEC::|!<=| cacheTS pV6816) 
                                       (cons 
                                        :|Some| 
                                        (cons 
                                         (vector pV6815 pV6816 (cons pV6820 nil)) 
                                         pV6820)) 
                                       '(:|None|)))))))))) 
                       (if (eq (car optValue) :|None|) 
                           (return (SPECCALC::searchContextForURI pV6821)))) 
                   (error "Nonexhaustive match failure in searchContextForURI")))))))) 
   (error "Nonexhaustive match failure in searchContextForURI")))
                                                                 
(defun SPECCALC::fileExistsAndReadable? (|!fileName|) 
  (SPECCALC::|!return| (IO-SPEC::fileExistsAndReadable |!fileName|)))
                                                                     
(defun SPECCALC::inSameFile? (uri currentURI) 
  (block 
   nil 
   (if (eq (car (car uri)) :|Some|) 
       (return (slang-built-in::slang-term-equals (cdr uri) (cdr currentURI)))) 
   (return nil)))
                 
(defun SPECCALC::getLocalContext (globalContext localContext uri validatedURIs) 
  (cons 
   (cons :|Ok| localContext) 
   (vector globalContext localContext uri validatedURIs)))
                                                          
(defun SPECCALC::getLocalContext-1 (x) 
  (SPECCALC::getLocalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                              
(defun SPECCALC::setCurrentURI-1-1 (newURI x) 
  (cons 
   (cons :|Ok| nil) 
   (vector 
    (svref x 0) 
    (svref x 1) 
    (cons :|Some| (cons (car newURI) (cdr newURI))) 
    (svref x 3))))
                  
(defun SPECCALC::setCurrentURI-1 (x1) 
  #'(lambda (x2) (SPECCALC::setCurrentURI-1-1 x1 x2)))
                                                      
(defun SPECCALC::setLocalContext (x1) 
  #'(lambda (x2) (SPECCALC::setLocalContext-1-1 x1 x2)))
                                                        
(defun SPECCALC::evaluateGlobalDecls (pV5289 path) 
  (declare (ignore pV5289)) 
  #'(lambda (|!fileName|) 
     #'(lambda (decls) 
        (labels 
          ((evaluateGlobalDecl (name term) 
            (let ((newURI (cons (cons :|Some| name) path))) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 newURI) 
               (SPECCALC::monadBind 
                (SPECCALC::evaluateTermInfo-1 term) 
                #'(lambda (x) 
                   (funcall (SPECCALC::bindInGlobalContext-1 newURI) 
                            (vector 
                             (svref x 0) 
                             (INTEGER-SPEC::|!max| 
                              (svref x 1) 
                              (IO-SPEC::fileWriteTime |!fileName|)) 
                             (svref x 2))))))))) 
          (SPECCALC::monadBind 
           #'SPECCALC::getCurrentURI-1 
           #'(lambda (saveURI) 
              (SPECCALC::monadBind 
               #'SPECCALC::getLocalContext-1 
               #'(lambda (saveLocalContext) 
                  (SPECCALC::monadSeq 
                   #'SPECCALC::clearLocalContext-1 
                   (SPECCALC::monadSeq 
                    (funcall (SPECCALC::mapM 
                              #'(lambda (x) 
                                 (evaluateGlobalDecl (car x) (cdr x)))) 
                             decls) 
                    (SPECCALC::monadSeq 
                     (SPECCALC::setCurrentURI-1 saveURI) 
                     (SPECCALC::setLocalContext saveLocalContext))))))))))))
                                                                            
(defun SPECCALC::evaluateGlobalDecls-1 (x) 
  (SPECCALC::evaluateGlobalDecls (car x) (cdr x)))
                                                  
(defun SPECCALC::parseFile (file) 
  (let ((file (LISP-SPEC::|!string| file))) 
    (let ((result 
           (LISP-SPEC::|!apply| 
            (LISP-SPEC::|!symbol| "PARSER4" "PARSEFILE") 
            (cons file nil)))) (LISP-SPEC::uncell result))))
                                                            
(defun SPECCALC::loadFile-1 (uri) 
  #'(lambda (|!fileName|) 
     (let ((pV5687 (SPECCALC::parseFile |!fileName|))) 
       (block 
        nil 
        (if (eq (car pV5687) :|None|) 
            (return (SPECCALC::raise (cons :|ParserError| |!fileName|))) 
            (if (eq (car pV5687) :|Some|) 
                (return 
                 (let ((pV5684 (SPECCALC::valueOf-1 (cdr pV5687)))) 
                   (block 
                    nil 
                    (if (eq (car pV5684) :|Term|) 
                        (let ((pV5686 (cdr pV5684))) 
                          (return 
                           (block 
                            nil 
                            (if (eq (car (car uri)) :|Some|) 
                                (return (SPECCALC::|!return| nil))) 
                            (return 
                             (SPECCALC::monadBind 
                              #'SPECCALC::getCurrentURI-1 
                              #'(lambda (saveURI) 
                                 (SPECCALC::monadBind 
                                  #'SPECCALC::getLocalContext-1 
                                  #'(lambda (saveLocalContext) 
                                     (SPECCALC::monadSeq 
                                      (SPECCALC::setCurrentURI-1 uri) 
                                      (SPECCALC::monadSeq 
                                       #'SPECCALC::clearLocalContext-1 
                                       (SPECCALC::monadSeq 
                                        (funcall (SPECCALC::bindInGlobalContext-1 
                                                  uri) 
                                                 (vector '(:|InProcess|) 0 nil)) 
                                        (SPECCALC::monadBind 
                                         (SPECCALC::evaluateTermInfo-1 pV5686) 
                                         #'(lambda (x) 
                                            (SPECCALC::monadSeq 
                                             (SPECCALC::setCurrentURI-1 saveURI) 
                                             (SPECCALC::monadSeq 
                                              (SPECCALC::setLocalContext 
                                               saveLocalContext) 
                                              (funcall (SPECCALC::bindInGlobalContext-1 
                                                        uri) 
                                                       (vector 
                                                        (svref x 0) 
                                                        (INTEGER-SPEC::|!max| 
                                                         (svref x 1) 
                                                         (IO-SPEC::fileWriteTime 
                                                          |!fileName|)) 
                                                        (svref x 2)))))))))))))))))) 
                        (if (eq (car pV5684) :|Decls|) 
                            (return 
                             (funcall (funcall (SPECCALC::evaluateGlobalDecls-1 
                                                uri) 
                                               |!fileName|) 
                                      (cdr pV5684))))) 
                    (error "Nonexhaustive match failure in loadFile")))))) 
        (error "Nonexhaustive match failure in loadFile")))))
                                                             
(defun SPECCALC::searchFileSystemForURI (|!position| relURI pairs currentURI) 
  (block 
   nil 
   (if (null pairs) 
       (return 
        (SPECCALC::raise (cons :|FileNotFound| (cons |!position| relURI)))) 
       (if (consp pairs) 
           (let ((pV6831 (cdr pairs))
                 (pV6830 (car pairs))) 
             (let ((pV6833 (cdr pV6830))
                   (pV6832 (car pV6830))) 
               (return 
                (SPECCALC::monadBind 
                 (SPECCALC::fileExistsAndReadable? pV6833) 
                 #'(lambda (test) 
                    (if (lisp::and 
                         test 
                         (BOOLEAN-SPEC::~ 
                          (SPECCALC::inSameFile? pV6832 currentURI))) 
                        (SPECCALC::monadSeq 
                         (funcall (SPECCALC::loadFile-1 pV6832) pV6833) 
                         (SPECCALC::monadBind 
                          (SPECCALC::lookupInGlobalContext-1 pV6832) 
                          #'(lambda (optValue) 
                             (block 
                              nil 
                              (if (eq (car optValue) :|Some|) 
                                  (let ((pV6824 (cdr optValue))) 
                                    (return 
                                     (SPECCALC::|!return| 
                                      (cons 
                                       (vector 
                                        (svref pV6824 0) 
                                        (svref pV6824 1) 
                                        (cons pV6832 nil)) 
                                       pV6832)))) 
                                  (if (eq (car optValue) :|None|) 
                                      (return 
                                       (SPECCALC::raise 
                                        (cons 
                                         :|URINotFound| 
                                         (cons |!position| relURI)))))) 
                              (error 
                               "Nonexhaustive match failure in searchFileSystemForURI"))))) 
                        (SPECCALC::searchFileSystemForURI 
                         |!position| 
                         relURI 
                         pV6831 
                         currentURI))))))))) 
   (error "Nonexhaustive match failure in searchFileSystemForURI")))
                                                                    
(defun SPECCALC::evaluateReturnURI (|!position|) 
  #'(lambda (uri) 
     (SPECCALC::monadBind 
      (SPECCALC::lookupInLocalContext uri) 
      #'(lambda (optValue) 
         (SPECCALC::monadBind 
          #'SPECCALC::getCurrentURI-1 
          #'(lambda (currentURI) 
             (block 
              nil 
              (if (eq (car optValue) :|Some|) 
                  (return (SPECCALC::|!return| (cons (cdr optValue) currentURI))) 
                  (if (eq (car optValue) :|None|) 
                      (return 
                       (SPECCALC::monadBind 
                        (SPECCALC::generateURIList uri) 
                        #'(lambda (uriList) 
                           (SPECCALC::monadBind 
                            (SPECCALC::searchContextForURI uriList) 
                            #'(lambda (optValue1) 
                               (block 
                                nil 
                                (if (eq (car optValue1) :|Some|) 
                                    (return 
                                     (SPECCALC::|!return| (cdr optValue1))) 
                                    (if (eq (car optValue1) :|None|) 
                                        (return 
                                         (SPECCALC::monadBind 
                                          (funcall (funcall (SPECCALC::foldM 
                                                             #'(lambda (l) 
                                                                #'(lambda (uri) 
                                                                   (SPECCALC::monadBind 
                                                                    (SPECCALC::generateFileList-1 
                                                                     uri) 
                                                                    #'(lambda (pair) 
                                                                       (SPECCALC::|!return| 
                                                                        (LIST-SPEC::|!++| 
                                                                         l 
                                                                         pair))))))) 
                                                            nil) 
                                                   uriList) 
                                          #'(lambda (uriPathPairs) 
                                             (SPECCALC::searchFileSystemForURI 
                                              |!position| 
                                              uri 
                                              uriPathPairs 
                                              currentURI)))))) 
                                (error 
                                 "Nonexhaustive match failure in evaluateReturnURI"))))))))) 
              (error "Nonexhaustive match failure in evaluateReturnURI"))))))))
                                                                               
(defun SPECCALC::evaluateURI (|!position|) 
  #'(lambda (uri) 
     (SPECCALC::monadBind 
      (funcall (SPECCALC::evaluateReturnURI |!position|) uri) 
      #'(lambda (x) (SPECCALC::|!return| (car x))))))
                                                     
(defun SPECCALC::splitAtChar-1-1 (|!char| charList) 
  (labels 
    ((parseCharList (chars) 
      (block 
       nil 
       (if (null chars) 
           (return nil) 
           (if (consp chars) 
               (return 
                (if (eq (car chars) |!char|) 
                    (parseCharList (cdr chars)) 
                    (let ((pV6990 
                           (SPECCALC::takeWhile-1-1 
                            #'(lambda (c) (BOOLEAN-SPEC::~ (eq c |!char|))) 
                            chars))) 
                      (block 
                       nil 
                       (return (cons (car pV6990) (parseCharList (cdr pV6990)))) 
                       (error "Nonexhaustive match failure in splitAtChar"))))))) 
       (error "Nonexhaustive match failure in splitAtChar")))) 
    (parseCharList charList)))
                              
(defun SPECCALC::|!first| (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "first: encountered empty list")) 
       (if (consp elems) (return (SPECCALC::|!return| (car elems))))) 
   (error "Nonexhaustive match failure in first")))
                                                   
(defun SPECCALC::|!last| (elems) 
  (block 
   nil 
   (if (null elems) 
       (return (SPECCALC::|!error| "last: encountered empty list")) 
       (if (consp elems) 
           (let ((pV5675 (cdr elems))) 
             (progn (if (null pV5675) (return (SPECCALC::|!return| (car elems)))) 
                    (return (SPECCALC::|!last| pV5675)))))) 
   (error "Nonexhaustive match failure in last")))
                                                  
(defun SPECCALC::pathToRelativeURI (str) 
  (let ((charList (STRING-SPEC::explode str))) 
    (let ((pathElems (SPECCALC::splitAtChar-1-1 #\/ charList))) 
      (labels 
        ((validElem (charList) 
          (funcall (SPECCALC::|!when| (LIST-SPEC::|!member| #\# charList)) 
                   (SPECCALC::raise 
                    (cons :|SyntaxError| "URI path element contains # symbol"))))) 
        (SPECCALC::monadSeq 
         (funcall (SPECCALC::|!when| 
                   (slang-built-in::slang-term-equals pathElems nil)) 
                  (SPECCALC::raise (cons :|SyntaxError| "Empty URI"))) 
         (SPECCALC::monadBind 
          (SPECCALC::|!last| pathElems) 
          #'(lambda (suffix) 
             (SPECCALC::monadBind 
              (SPECCALC::removeLast pathElems) 
              #'(lambda (pathPrefix) 
                 (SPECCALC::monadSeq 
                  (funcall (SPECCALC::mapM #'validElem) pathPrefix) 
                  (SPECCALC::monadBind 
                   (SPECCALC::|!first| suffix) 
                   #'(lambda (firstSuffixChar) 
                      (SPECCALC::monadBind 
                       (SPECCALC::|!last| suffix) 
                       #'(lambda (lastSuffixChar) 
                          (SPECCALC::monadSeq 
                           (funcall (SPECCALC::|!when| (eq firstSuffixChar #\#)) 
                                    (SPECCALC::raise 
                                     (cons :|SyntaxError| "Misplaced #"))) 
                           (SPECCALC::monadSeq 
                            (funcall (SPECCALC::|!when| (eq lastSuffixChar #\#)) 
                                     (SPECCALC::raise 
                                      (cons :|SyntaxError| "Misplaced #"))) 
                            (let ((pV6237 (SPECCALC::splitAtChar-1-1 #\# suffix))) 
                              (block 
                               nil 
                               (if (null pV6237) 
                                   (return 
                                    (SPECCALC::|!error| 
                                     "pathToRelativeURI: Internal error")) 
                                   (if (consp pV6237) 
                                       (let ((pV6240 (cdr pV6237))
                                             (pV6239 (car pV6237))) 
                                         (if (null pV6240) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (consp charList) 
                                                   (if (eq #\/ (car charList)) 
                                                       (return 
                                                        (SPECCALC::|!return| 
                                                         (cons 
                                                          :|SpecPath_Relative| 
                                                          (cons 
                                                           '(:|None|) 
                                                           (LIST-SPEC::|!map|-1-1 
                                                            #'STRING-SPEC::implode 
                                                            (LIST-SPEC::|!++| 
                                                             pathPrefix 
                                                             (cons pV6239 nil))))))))) 
                                               (return 
                                                (SPECCALC::|!return| 
                                                 (cons 
                                                  :|URI_Relative| 
                                                  (cons 
                                                   '(:|None|) 
                                                   (LIST-SPEC::|!map|-1-1 
                                                    #'STRING-SPEC::implode 
                                                    (LIST-SPEC::|!++| 
                                                     pathPrefix 
                                                     (cons pV6239 nil))))))))) 
                                             (if (consp pV6240) 
                                                 (let ((pV6242 (car pV6240))) 
                                                   (if (null (cdr pV6240)) 
                                                       (return 
                                                        (block 
                                                         nil 
                                                         (if (consp charList) 
                                                             (if (eq 
                                                                  #\/ 
                                                                  (car charList)) 
                                                                 (return 
                                                                  (SPECCALC::|!return| 
                                                                   (cons 
                                                                    :|SpecPath_Relative| 
                                                                    (cons 
                                                                     (cons 
                                                                      :|Some| 
                                                                      (STRING-SPEC::implode 
                                                                       pV6242)) 
                                                                     (LIST-SPEC::|!map|-1-1 
                                                                      #'STRING-SPEC::implode 
                                                                      (LIST-SPEC::|!++| 
                                                                       pathPrefix 
                                                                       (cons 
                                                                        pV6239 
                                                                        nil))))))))) 
                                                         (return 
                                                          (SPECCALC::|!return| 
                                                           (cons 
                                                            :|URI_Relative| 
                                                            (cons 
                                                             (cons 
                                                              :|Some| 
                                                              (STRING-SPEC::implode 
                                                               pV6242)) 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'STRING-SPEC::implode 
                                                              (LIST-SPEC::|!++| 
                                                               pathPrefix 
                                                               (cons pV6239 nil)))))))))))))))) 
                               (return 
                                (SPECCALC::raise 
                                 (cons 
                                  :|SyntaxError| 
                                  "URI contains two or more # symbols")))))))))))))))))))))


(defparameter SPECCALC::initialSpecwareState 
  (vector 
   POLYMAP::emptyMap 
   POLYMAP::emptyMap 
   (cons :|Some| (cons '(:|None|) (cons "/" nil))) 
   nil))
        
(defparameter SPECWARE::ignoredState SPECCALC::initialSpecwareState)
                                                                    
(defun SPECCALC::ppURI-1 (uri) 
  (WADLERLINDIG::ppAppend-1-1 
   (WADLERLINDIG::ppString "/") 
   (SPECCALC::ppURIlocal-1 uri)))
                                 
(defun SPECCALC::showURI-1 (uri) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppURI-1 uri)))
                                                   
(defun SPECWARE::printException (except) 
  (block 
   nil 
   (if (eq (car except) :|Fail|) 
       (return (STRING-SPEC::^ "Fail: " (cdr except))) 
       (if (eq (car except) :|SyntaxError|) 
           (return (STRING-SPEC::^ "Syntax error: " (cdr except))) 
           (if (eq (car except) :|ParserError|) 
               (return 
                (STRING-SPEC::^ "Syntax error for filename: " (cdr except))) 
               (if (eq (car except) :|Unsupported|) 
                   (let ((pV8472 (cdr except))) 
                     (return 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ "Unsupported operation: " (cdr pV8472)) 
                        "
  found at ") 
                       (POSITION-SPEC::printAll (car pV8472))))) 
                   (if (eq (car except) :|URINotFound|) 
                       (let ((pV8471 (cdr except))) 
                         (return 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ 
                             "Unknown unit " 
                             (SPECCALC::showRelativeURI (cdr pV8471))) 
                            "
  referenced from ") 
                           (POSITION-SPEC::printAll (car pV8471))))) 
                       (if (eq (car except) :|FileNotFound|) 
                           (let ((pV8470 (cdr except))) 
                             (return 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ 
                                (STRING-SPEC::^ 
                                 "Unknown unit " 
                                 (SPECCALC::showRelativeURI (cdr pV8470))) 
                                "
  referenced from ") 
                               (POSITION-SPEC::printAll (car pV8470))))) 
                           (if (eq (car except) :|SpecError|) 
                               (let ((pV8469 (cdr except))) 
                                 (return 
                                  (STRING-SPEC::^ 
                                   (STRING-SPEC::^ 
                                    (STRING-SPEC::^ 
                                     "Error in specification: " 
                                     (cdr pV8469)) 
                                    "
  found at ") 
                                   (POSITION-SPEC::printAll (car pV8469))))) 
                               (if (eq (car except) :|DiagError|) 
                                   (let ((pV8468 (cdr except))) 
                                     (return 
                                      (STRING-SPEC::^ 
                                       (STRING-SPEC::^ 
                                        (STRING-SPEC::^ 
                                         "Diagram error: " 
                                         (cdr pV8468)) 
                                        "
  found at ") 
                                       (POSITION-SPEC::printAll (car pV8468))))) 
                                   (if (eq (car except) :|TypeCheck|) 
                                       (let ((pV8467 (cdr except))) 
                                         (return 
                                          (STRING-SPEC::^ 
                                           (STRING-SPEC::^ 
                                            (STRING-SPEC::^ 
                                             "Type error: " 
                                             (cdr pV8467)) 
                                            "
  found at ") 
                                           (POSITION-SPEC::printAll (car pV8467))))) 
                                       (if (eq (car except) :|Proof|) 
                                           (let ((pV8466 (cdr except))) 
                                             (return 
                                              (STRING-SPEC::^ 
                                               (STRING-SPEC::^ 
                                                (STRING-SPEC::^ 
                                                 "Proof error: " 
                                                 (cdr pV8466)) 
                                                "
  found at ") 
                                               (POSITION-SPEC::printAll 
                                                (car pV8466))))) 
                                           (if (eq 
                                                (car except) 
                                                :|CircularDefinition|) 
                                               (return 
                                                (STRING-SPEC::^ 
                                                 "Circular definition: " 
                                                 (SPECCALC::showURI-1 
                                                  (cdr except)))) 
                                               (if (eq 
                                                    (car except) 
                                                    :|OldTypeCheck|) 
                                                   (return 
                                                    (STRING-SPEC::^ 
                                                     "Type errors:
" 
                                                     (cdr except))))))))))))))) 
   (return (STRING-SPEC::^ "Unknown exception: " (SYSTEM-SPEC::toString except)))))


(defun SPECWARE::toplevelHandler (except) 
  (SPECCALC::monadSeq 
   #'SPECCALC::cleanupGlobalContext-1 
   (SPECCALC::monadSeq 
    #'SPECWARE::saveSpecwareState-1 
    (SPECCALC::monadBind 
     (SPECCALC::|!return| (SPECWARE::printException except)) 
     #'(lambda (message) 
        (SPECCALC::monadSeq 
         (if SPECCALC::specwareWizard? 
             (SYSTEM-SPEC::fail message) 
             (SPECCALC::|!print| message)) 
         (SPECCALC::|!return| nil)))))))
                                        
(defun SPECCALC::getBaseSpec () 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToRelativeURI "/Library/Base") 
           #'(lambda (base_URI) 
              (SPECCALC::monadBind 
               (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                        base_URI) 
               #'(lambda (x) 
                  (let ((pV5578 (svref x 0))) 
                    (block 
                     nil 
                     (if (eq (car pV5578) :|Spec|) 
                         (return 
                          (SPECCALC::monadSeq 
                           #'SPECWARE::saveSpecwareState-1 
                           (SPECCALC::|!return| (cdr pV5578))))) 
                     (error "Nonexhaustive match failure in getBaseSpec")))))))))) 
    (labels 
      ((myHandler (except) 
        (SPECCALC::monadSeq 
         (SPECWARE::toplevelHandler except) 
         (SPECCALC::|!return| emptySpec)))) 
      (let ((x (SPECCALC::|!catch|-1-1-1 run #'myHandler SPECWARE::ignoredState))) 
        (let ((pV5585 (car x))) 
          (block 
           nil 
           (if (eq (car pV5585) :|Ok|) 
               (return (cdr pV5585)) 
               (if (eq (car pV5585) :|Exception|) 
                   (return (SYSTEM-SPEC::fail "Can't find base spec!")))) 
           (error "Nonexhaustive match failure in getBaseSpec")))))))
                                                                     
(defun SPECCALC::makeMorphism (dom_spec cod_spec sort_map op_map) 
  (vector cod_spec dom_spec op_map sort_map))
                                             
(defun SPECCALC::makeSpecCocone-1-1-1 (dg apex_spec cc_map) 
  (let ((apex_functor (CAT::functor-1 dg))) 
    (let ((cc_nt (NATTRANS::build-1-1-1 (CAT::functor-1 dg) apex_functor cc_map))) 
      (vector apex_spec dg cc_nt))))
                                    
(defun SPECCALC::makeSpecInitialCocone-1-1-1 (dg apex_spec cc_map) 
  (let ((cat (FUNCTOR::cod-1 (CAT::functor-1 dg)))) 
    (cons 
     (SPECCALC::makeSpecCocone-1-1-1 dg apex_spec cc_map) 
     #'(lambda (other_cocone) (CAT::ident-1-1 cat (CAT::initialObject-1 cat))))))


(defun SPECCALC::makeTranslateOpRule (dom_qid cod_qid cod_aliases) 
  (let ((rule_ 
         (cons 
          :|Op| 
          (vector 
           (cons dom_qid '(:|None|)) 
           (cons cod_qid '(:|None|)) 
           cod_aliases)))) (cons rule_ (cons :|Internal| "Colimit Op"))))
                                                                         
(defun SPECCALC::makeTranslateOpRule-1 (x) 
  (SPECCALC::makeTranslateOpRule (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defun SPECCALC::makeTranslateSortRule (dom_qid cod_qid cod_aliases) 
  (cons 
   (cons :|Sort| (vector dom_qid cod_qid cod_aliases)) 
   (cons :|Internal| "Colimit Sort")))
                                      
(defun SPECCALC::makeTranslateSortRule-1 (x) 
  (SPECCALC::makeTranslateSortRule (svref x 0) (svref x 1) (svref x 2)))
                                                                        
(defun SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1
 (dg vqid_to_apex_qid_and_aliases extract_non_base_items make_translate_rule) 
  (CAT::foldOverVertices-1-1-1 
   #'(lambda (vertex_to_translation) 
      #'(lambda (vertex) 
         (let ((spc (CAT::vertexLabel-1-1 dg vertex))) 
           (let ((translate_rules 
                  (LIST-SPEC::foldl-1-1-1 
                   #'(lambda (x) 
                      (let ((pV5966 (car x))) 
                        (block 
                         nil 
                         (return 
                          (let ((vertex_qid 
                                 (cons 
                                  :|Qualified| 
                                  (cons (svref pV5966 0) (svref pV5966 1))))) 
                            (let ((pV5963 
                                   (POLYMAP::|!eval|-1-1 
                                    vqid_to_apex_qid_and_aliases 
                                    (cons vertex vertex_qid)))) 
                              (block 
                               nil 
                               (return 
                                (cons 
                                 (funcall make_translate_rule 
                                          (vector 
                                           vertex_qid 
                                           (car pV5963) 
                                           (cdr pV5963))) 
                                 (cdr x))) 
                               (error 
                                "Nonexhaustive match failure in makeVertexToTranslateRulesMap"))))) 
                         (error 
                          "Nonexhaustive match failure in makeVertexToTranslateRulesMap")))) 
                   nil 
                   (funcall extract_non_base_items spc)))) 
             (POLYMAP::update-1-1-1 vertex_to_translation vertex translate_rules))))) 
   POLYMAP::emptyMap 
   dg))
       
(defun SPECCALC::optSpecUnion (specs) 
  (SPECCALC::monadSeq 
   #'SPECWARE::restoreSavedSpecwareState-1 
   (SPECCALC::monadBind 
    (SPECUNION::specUnion specs) 
    #'(lambda (spc) 
       (SPECCALC::|!return| 
        (cons 
         :|Some| 
         (vector (svref spc 0) (svref spc 1) (svref spc 2) (svref spc 3))))))))
                                                                               
(defun STANDARDSPEC::findAllOps (pV9301 pV9302) 
  (block 
   nil 
   (if (eq (car pV9302) :|Qualified|) 
       (let ((pV9303 (cdr pV9302))) 
         (let ((pV9305 (cdr pV9303))
               (pV9304 (car pV9303))) 
           (return 
            (if (string=  pV9304 METASLANG::UnQualified) 
                (STANDARDSPEC::wildFindUnQualified (svref pV9301 1) pV9305) 
                (let ((pV9299 (findAQualifierMap (svref pV9301 1) pV9304 pV9305))) 
                  (block 
                   nil 
                   (if (eq (car pV9299) :|Some|) 
                       (return (cons (cdr pV9299) nil)) 
                       (if (eq (car pV9299) :|None|) (return nil))) 
                   (error "Nonexhaustive match failure in findAllOps")))))))) 
   (error "Nonexhaustive match failure in findAllOps")))
                                                        
(defun SPECCALC::makeTranslationMaps-1 (dom_spec) 
  #'(lambda (x) 
     (let ((translation_rules (car x))) 
       (labels 
         ((insert (translation_op_map translation_sort_map) 
           #'(lambda (x1) 
              (let ((rule_pos (cdr x1))
                    (translation_rule (car x1))) 
                (block 
                 nil 
                 (if (eq (car translation_rule) :|Sort|) 
                     (let ((pV5940 (cdr translation_rule))) 
                       (let ((pV5957 (svref pV5940 0))) 
                         (if (eq (car pV5957) :|Qualified|) 
                             (let ((pV5960 (cdr pV5957))) 
                               (let ((pV5962 (cdr pV5960))
                                     (pV5961 (car pV5960))) 
                                 (return 
                                  (let ((pV5860 
                                         (STANDARDSPEC::findAllSorts 
                                          dom_spec 
                                          pV5957))) 
                                    (block 
                                     nil 
                                     (if (consp pV5860) 
                                         (let ((pV5864 (svref (car pV5860) 0))) 
                                           (if (consp pV5864) 
                                               (let ((pV5868 (car pV5864))) 
                                                 (if (eq 
                                                      (car pV5868) 
                                                      :|Qualified|) 
                                                     (return 
                                                      (if (lisp::or 
                                                           (slang-built-in::slang-term-equals 
                                                            (cdr pV5860) 
                                                            nil) 
                                                           (string=  
                                                            (car (cdr pV5868)) 
                                                            METASLANG::UnQualified)) 
                                                          (let ((pV5858 
                                                                 (findAQualifierMap 
                                                                  translation_sort_map 
                                                                  pV5961 
                                                                  pV5962))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV5858) 
                                                                  :|None|) 
                                                                 (return 
                                                                  (SPECCALC::|!return| 
                                                                   (cons 
                                                                    translation_op_map 
                                                                    (insertAQualifierMap 
                                                                     translation_sort_map 
                                                                     pV5961 
                                                                     pV5962 
                                                                     (cons 
                                                                      (svref 
                                                                       pV5940 
                                                                       1) 
                                                                      (svref 
                                                                       pV5940 
                                                                       2))))))) 
                                                             (return 
                                                              (SPECCALC::raise 
                                                               (cons 
                                                                :|SpecError| 
                                                                (cons 
                                                                 rule_pos 
                                                                 (STRING-SPEC::^ 
                                                                  "translate: Duplicate rules for source sort " 
                                                                  (METASLANG::printQualifiedId 
                                                                   pV5957)))))))) 
                                                          (SPECCALC::raise 
                                                           (cons 
                                                            :|SpecError| 
                                                            (cons 
                                                             rule_pos 
                                                             (STRING-SPEC::^ 
                                                              "translate: Ambiguous source sort " 
                                                              (METASLANG::printQualifiedId 
                                                               pV5957)))))))))))) 
                                     (return 
                                      (SPECCALC::raise 
                                       (cons 
                                        :|SpecError| 
                                        (cons 
                                         rule_pos 
                                         (STRING-SPEC::^ 
                                          "translate: Unrecognized source sort " 
                                          (METASLANG::printQualifiedId pV5957)))))))))))))) 
                     (if (eq (car translation_rule) :|Op|) 
                         (let ((pV5939 (cdr translation_rule))) 
                           (let ((pV5950 (car (svref pV5939 0)))) 
                             (if (eq (car pV5950) :|Qualified|) 
                                 (let ((pV5952 (cdr pV5950))) 
                                   (let ((pV5954 (cdr pV5952))
                                         (pV5953 (car pV5952))) 
                                     (return 
                                      (let ((pV5881 
                                             (STANDARDSPEC::findAllOps 
                                              dom_spec 
                                              pV5950))) 
                                        (block 
                                         nil 
                                         (if (consp pV5881) 
                                             (let ((pV5885 
                                                    (svref (car pV5881) 0))) 
                                               (if (consp pV5885) 
                                                   (let ((pV5890 (car pV5885))) 
                                                     (if (eq 
                                                          (car pV5890) 
                                                          :|Qualified|) 
                                                         (return 
                                                          (if (lisp::or 
                                                               (slang-built-in::slang-term-equals 
                                                                (cdr pV5881) 
                                                                nil) 
                                                               (string=  
                                                                (car 
                                                                 (cdr pV5890)) 
                                                                METASLANG::UnQualified)) 
                                                              (let ((pV5879 
                                                                     (findAQualifierMap 
                                                                      translation_op_map 
                                                                      pV5953 
                                                                      pV5954))) 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car 
                                                                       pV5879) 
                                                                      :|None|) 
                                                                     (return 
                                                                      (SPECCALC::|!return| 
                                                                       (cons 
                                                                        (insertAQualifierMap 
                                                                         translation_op_map 
                                                                         pV5953 
                                                                         pV5954 
                                                                         (cons 
                                                                          (car 
                                                                           (svref 
                                                                            pV5939 
                                                                            1)) 
                                                                          (svref 
                                                                           pV5939 
                                                                           2))) 
                                                                        translation_sort_map)))) 
                                                                 (return 
                                                                  (SPECCALC::raise 
                                                                   (cons 
                                                                    :|SpecError| 
                                                                    (cons 
                                                                     rule_pos 
                                                                     (STRING-SPEC::^ 
                                                                      "translate: Duplicate rules for source op " 
                                                                      (METASLANG::printQualifiedId 
                                                                       pV5950)))))))) 
                                                              (SPECCALC::raise 
                                                               (cons 
                                                                :|SpecError| 
                                                                (cons 
                                                                 rule_pos 
                                                                 (STRING-SPEC::^ 
                                                                  "translate: Ambiguous source op " 
                                                                  (METASLANG::printQualifiedId 
                                                                   pV5950)))))))))))) 
                                         (return 
                                          (SPECCALC::raise 
                                           (cons 
                                            :|SpecError| 
                                            (cons 
                                             rule_pos 
                                             (STRING-SPEC::^ 
                                              "translate: Unrecognized source op " 
                                              (METASLANG::printQualifiedId 
                                               pV5950)))))))))))))) 
                         (if (eq (car translation_rule) :|Ambiguous|) 
                             (let ((pV5938 (cdr translation_rule))) 
                               (let ((pV5943 (svref pV5938 2))
                                     (pV5942 (svref pV5938 1))
                                     (pV5941 (svref pV5938 0))) 
                                 (if (eq (car pV5941) :|Qualified|) 
                                     (let ((pV5944 (cdr pV5941))) 
                                       (let ((pV5946 (cdr pV5944))
                                             (pV5945 (car pV5944))) 
                                         (return 
                                          (let ((dom_sorts 
                                                 (STANDARDSPEC::findAllSorts 
                                                  dom_spec 
                                                  pV5941))) 
                                            (let ((dom_ops 
                                                   (STANDARDSPEC::findAllOps 
                                                    dom_spec 
                                                    pV5941))) 
                                              (block 
                                               nil 
                                               (if (consp dom_sorts) 
                                                   (let ((pV5928 
                                                          (svref 
                                                           (car dom_sorts) 
                                                           0))) 
                                                     (if (consp pV5928) 
                                                         (let ((pV5932 
                                                                (car pV5928))) 
                                                           (if (eq 
                                                                (car pV5932) 
                                                                :|Qualified|) 
                                                               (if (null dom_ops) 
                                                                   (return 
                                                                    (if (lisp::or 
                                                                         (slang-built-in::slang-term-equals 
                                                                          (cdr 
                                                                           dom_sorts) 
                                                                          nil) 
                                                                         (string=  
                                                                          (car 
                                                                           (cdr 
                                                                            pV5932)) 
                                                                          METASLANG::UnQualified)) 
                                                                        (let ((pV5900 
                                                                               (findAQualifierMap 
                                                                                translation_sort_map 
                                                                                pV5945 
                                                                                pV5946))) 
                                                                          (block 
                                                                           nil 
                                                                           (if (eq 
                                                                                (car 
                                                                                 pV5900) 
                                                                                :|None|) 
                                                                               (return 
                                                                                (SPECCALC::|!return| 
                                                                                 (cons 
                                                                                  translation_op_map 
                                                                                  (insertAQualifierMap 
                                                                                   translation_sort_map 
                                                                                   pV5945 
                                                                                   pV5946 
                                                                                   (cons 
                                                                                    pV5942 
                                                                                    pV5943)))))) 
                                                                           (return 
                                                                            (SPECCALC::raise 
                                                                             (cons 
                                                                              :|SpecError| 
                                                                              (cons 
                                                                               rule_pos 
                                                                               (STRING-SPEC::^ 
                                                                                "translate: Duplicate rules for source sort " 
                                                                                (METASLANG::printQualifiedId 
                                                                                 pV5941)))))))) 
                                                                        (SPECCALC::raise 
                                                                         (cons 
                                                                          :|SpecError| 
                                                                          (cons 
                                                                           rule_pos 
                                                                           (STRING-SPEC::^ 
                                                                            "translate: Ambiguous source sort " 
                                                                            (METASLANG::printQualifiedId 
                                                                             pV5941)))))))))))) 
                                                   (if (null dom_sorts) 
                                                       (if (null dom_ops) 
                                                           (return 
                                                            (SPECCALC::raise 
                                                             (cons 
                                                              :|SpecError| 
                                                              (cons 
                                                               rule_pos 
                                                               (STRING-SPEC::^ 
                                                                "translate: Unrecognized source sort/op " 
                                                                (METASLANG::printQualifiedId 
                                                                 pV5941)))))) 
                                                           (if (consp dom_ops) 
                                                               (let ((pV5916 
                                                                      (svref 
                                                                       (car 
                                                                        dom_ops) 
                                                                       0))) 
                                                                 (if (consp 
                                                                      pV5916) 
                                                                     (let ((pV5921 
                                                                            (car 
                                                                             pV5916))) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV5921) 
                                                                            :|Qualified|) 
                                                                           (return 
                                                                            (if (lisp::or 
                                                                                 (slang-built-in::slang-term-equals 
                                                                                  (cdr 
                                                                                   dom_ops) 
                                                                                  nil) 
                                                                                 (string=  
                                                                                  (car 
                                                                                   (cdr 
                                                                                    pV5921)) 
                                                                                  METASLANG::UnQualified)) 
                                                                                (let ((pV5907 
                                                                                       (findAQualifierMap 
                                                                                        translation_op_map 
                                                                                        pV5945 
                                                                                        pV5946))) 
                                                                                  (block 
                                                                                   nil 
                                                                                   (if (eq 
                                                                                        (car 
                                                                                         pV5907) 
                                                                                        :|None|) 
                                                                                       (return 
                                                                                        (SPECCALC::|!return| 
                                                                                         (cons 
                                                                                          (insertAQualifierMap 
                                                                                           translation_op_map 
                                                                                           pV5945 
                                                                                           pV5946 
                                                                                           (cons 
                                                                                            pV5942 
                                                                                            pV5943)) 
                                                                                          translation_sort_map)))) 
                                                                                   (return 
                                                                                    (SPECCALC::raise 
                                                                                     (cons 
                                                                                      :|SpecError| 
                                                                                      (cons 
                                                                                       rule_pos 
                                                                                       (STRING-SPEC::^ 
                                                                                        "translate: Duplicate rules for source op " 
                                                                                        (METASLANG::printQualifiedId 
                                                                                         pV5941)))))))) 
                                                                                (SPECCALC::raise 
                                                                                 (cons 
                                                                                  :|SpecError| 
                                                                                  (cons 
                                                                                   rule_pos 
                                                                                   (STRING-SPEC::^ 
                                                                                    "translate: Ambiguous source op " 
                                                                                    (METASLANG::printQualifiedId 
                                                                                     pV5941))))))))))))))) 
                                               (return 
                                                (SPECCALC::raise 
                                                 (cons 
                                                  :|SpecError| 
                                                  (cons 
                                                   rule_pos 
                                                   (STRING-SPEC::^ 
                                                    "translate: Ambiguous source sort/op " 
                                                    (METASLANG::printQualifiedId 
                                                     pV5941)))))) 
                                               (error 
                                                "Nonexhaustive match failure in makeTranslationMaps"))))))))))))) 
                 (error "Nonexhaustive match failure in makeTranslationMaps")))))) 
         (funcall (funcall (SPECCALC::foldM 
                            #'(lambda (x1) (insert (car x1) (cdr x1)))) 
                           (cons emptyAQualifierMap emptyAQualifierMap)) 
                  translation_rules)))))
                                        
(defun SPECCALC::translateSpec-1 (spc) 
  #'(lambda (expr) 
     (SPECCALC::monadBind 
      (funcall (SPECCALC::makeTranslationMaps-1 spc) expr) 
      #'(lambda (translation_maps) 
         (funcall (funcall (SPECCALC::auxTranslateSpec-1 spc) translation_maps) 
                  (SPECCALC::positionOf-1 expr))))))
                                                    
(defun SPECCALC::optTranslateSpec-1 (vertex_spec) 
  #'(lambda (cocone_translation_expr) 
     (SPECCALC::monadSeq 
      #'SPECWARE::restoreSavedSpecwareState-1 
      (SPECCALC::monadBind 
       (funcall (SPECCALC::translateSpec-1 vertex_spec) cocone_translation_expr) 
       #'(lambda (spc) 
          (SPECCALC::|!return| 
           (cons 
            :|Some| 
            (vector (svref spc 0) (svref spc 1) (svref spc 2) (svref spc 3)))))))))


(defun SPECCALC::localHandler (except) 
  (SPECCALC::monadSeq 
   (SPECWARE::toplevelHandler except) 
   (SPECCALC::|!return| '(:|None|))))
                                     
(defun SPECCALC::run_monad (monad) 
  (let ((x 
         (SPECCALC::|!catch|-1-1-1 
          monad 
          #'SPECCALC::localHandler 
          SPECWARE::ignoredState))) 
    (let ((pV6806 (car x))) 
      (block 
       nil 
       (if (eq (car pV6806) :|Ok|) 
           (return (cdr pV6806)) 
           (if (eq (car pV6806) :|Exception|) 
               (return 
                (SYSTEM-SPEC::fail 
                 "Specware toplevel handler failed within colimit!")))) 
       (error "Nonexhaustive match failure in run_monad")))))
                                                             
(defun SPECCALC::specColimit-1 (dg) 
  (let ((base_spec (SPECCALC::getBaseSpec))) 
    (labels 
      ((extract_non_base_ops (spc) 
        (let ((base_ops (svref base_spec 1))) 
          (foldriAQualifierMap-1-1-1 
           #'(lambda (x) 
              (let ((non_base_ops (svref x 3))
                    (id (svref x 1))
                    (qualifier (svref x 0))) 
                (let ((pV6971 (findAQualifierMap base_ops qualifier id))) 
                  (block 
                   nil 
                   (if (eq (car pV6971) :|None|) 
                       (return 
                        (LIST-SPEC::|!cons| 
                         (vector qualifier id (svref x 2)) 
                         non_base_ops))) 
                   (return non_base_ops))))) 
           nil 
           (svref spc 1))))
       (extract_non_base_sorts (spc) 
        (let ((base_sorts (svref base_spec 3))) 
          (foldriAQualifierMap-1-1-1 
           #'(lambda (x) 
              (let ((non_base_sorts (svref x 3))
                    (id (svref x 1))
                    (qualifier (svref x 0))) 
                (let ((pV6969 (findAQualifierMap base_sorts qualifier id))) 
                  (block 
                   nil 
                   (if (eq (car pV6969) :|None|) 
                       (return 
                        (LIST-SPEC::|!cons| 
                         (vector qualifier id (svref x 2)) 
                         non_base_sorts))) 
                   (return non_base_sorts))))) 
           nil 
           (svref spc 3))))) 
      (let ((sort_qset 
             (SPECCALC::computeQuotientSet-1-1-1 
              dg 
              #'extract_non_base_sorts 
              #'SPECCALC::sortMap-1))) 
        (let ((op_qset 
               (SPECCALC::computeQuotientSet-1-1-1 
                dg 
                #'extract_non_base_ops 
                #'SPECCALC::opMap-1))) 
          (let ((vqid_to_apex_qid_and_aliases_sort_map 
                 (SPECCALC::computeVQidToApexQidAndAliasesMap sort_qset))) 
            (let ((vqid_to_apex_qid_and_aliases_op_map 
                   (SPECCALC::computeVQidToApexQidAndAliasesMap op_qset))) 
              (let ((vertex_to_sm_sort_rules 
                     (SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1 
                      dg 
                      vqid_to_apex_qid_and_aliases_sort_map 
                      #'extract_non_base_sorts 
                      #'SPECCALC::makeTranslateSortRule-1))) 
                (let ((vertex_to_sm_op_rules 
                       (SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1 
                        dg 
                        vqid_to_apex_qid_and_aliases_op_map 
                        #'extract_non_base_ops 
                        #'SPECCALC::makeTranslateOpRule-1))) 
                  (let ((vertex_to_sm_rules 
                         (CAT::foldOverVertices-1-1-1 
                          #'(lambda (cocone_translations) 
                             #'(lambda (vertex) 
                                (let ((cocone_sm_rules 
                                       (LIST-SPEC::|!++| 
                                        (let ((pV6973 
                                               (POLYMAP::evalPartial-1-1 
                                                vertex_to_sm_sort_rules 
                                                vertex))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV6973) :|Some|) 
                                               (return (cdr pV6973))) 
                                           (return nil))) 
                                        (let ((pV6976 
                                               (POLYMAP::evalPartial-1-1 
                                                vertex_to_sm_op_rules 
                                                vertex))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV6976) :|Some|) 
                                               (return (cdr pV6976))) 
                                           (return nil)))))) 
                                  (POLYMAP::update-1-1-1 
                                   cocone_translations 
                                   vertex 
                                   (cons 
                                    cocone_sm_rules 
                                    (cons :|Internal| "Colimit")))))) 
                          POLYMAP::emptyMap 
                          dg))) 
                    (let ((apex_spec 
                           (CAT::foldOverVertices-1-1-1 
                            #'(lambda (apex_spec) 
                               #'(lambda (vertex) 
                                  (let ((vertex_spec 
                                         (CAT::vertexLabel-1-1 dg vertex))) 
                                    (let ((cocone_translation_expr 
                                           (POLYMAP::|!eval|-1-1 
                                            vertex_to_sm_rules 
                                            vertex))) 
                                      (let ((pV6982 
                                             (SPECCALC::run_monad 
                                              (funcall (SPECCALC::optTranslateSpec-1 
                                                        (subtractSpec-1-1 
                                                         vertex_spec 
                                                         base_spec)) 
                                                       cocone_translation_expr)))) 
                                        (block 
                                         nil 
                                         (if (eq (car pV6982) :|Some|) 
                                             (return 
                                              (let ((pV6979 
                                                     (SPECCALC::run_monad 
                                                      (SPECCALC::optSpecUnion 
                                                       (cons 
                                                        apex_spec 
                                                        (cons (cdr pV6982) nil)))))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV6979) :|Some|) 
                                                     (return (cdr pV6979))) 
                                                 (return 
                                                  (SYSTEM-SPEC::fail 
                                                   "Internal error: spec union inside colimit failed.")))))) 
                                         (return 
                                          (SYSTEM-SPEC::fail 
                                           "Internal error: translation inside colimit failed.")))))))) 
                            base_spec 
                            dg))) 
                      (let ((vertex_to_sm_map 
                             (CAT::foldOverVertices-1-1-1 
                              #'(lambda (cc_map) 
                                 #'(lambda (vertex) 
                                    (let ((sm 
                                           (let ((dom_spec 
                                                  (CAT::vertexLabel-1-1 
                                                   dg 
                                                   vertex))) 
                                             (SPECCALC::makeMorphism 
                                              dom_spec 
                                              apex_spec 
                                              (let ((pV6985 
                                                     (POLYMAP::evalPartial-1-1 
                                                      vertex_to_sm_sort_rules 
                                                      vertex))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV6985) :|Some|) 
                                                     (return 
                                                      (SPECCALC::convertSortRules 
                                                       (cdr pV6985)))) 
                                                 (return nil))) 
                                              (let ((pV6988 
                                                     (POLYMAP::evalPartial-1-1 
                                                      vertex_to_sm_op_rules 
                                                      vertex))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV6988) :|Some|) 
                                                     (return 
                                                      (SPECCALC::convertOpRules 
                                                       (cdr pV6988)))) 
                                                 (return nil))))))) 
                                      (POLYMAP::update-1-1-1 cc_map vertex sm)))) 
                              POLYMAP::emptyMap 
                              dg))) 
                        (SPECCALC::makeSpecInitialCocone-1-1-1 
                         dg 
                         apex_spec 
                         vertex_to_sm_map)))))))))))))
                                                      
(defun SPECCALC::specCat () 
  (vector 
   #'(lambda (x) (svref x 0)) 
   #'SPECCALC::specColimit-1 
   #'SPECCALC::compose-1 
   #'(lambda (x) (svref x 1)) 
   #'(lambda (spc) (vector spc spc POLYMAP::emptyMap POLYMAP::emptyMap)) 
   emptySpec 
   #'SPECCALC::ppMorphism-1 
   #'SPECCALC::ppASpec-1))
                          
(defun SPECCALC::evaluateDiag (elems) 
  (SPECCALC::monadBind 
   (funcall (funcall (SPECCALC::foldM #'SPECCALC::evaluateDiagElem-1) 
                     (vector (CAT::emptyDiagram-1 (SPECCALC::specCat)) 0 nil)) 
            elems) 
   #'(lambda (x) 
      (let ((dgm (svref x 0))) 
        (SPECCALC::|!return| 
         (vector 
          (cons :|Diag| (cons (car dgm) (cdr dgm))) 
          (svref x 1) 
          (svref x 2)))))))
                           
(defun SPECCALC::ppColimit (cocone pV6552) 
  (declare (ignore pV6552)) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString "colimit ") 
    (cons 
     WADLERLINDIG::ppNewline 
     (cons (CAT::ppDiagram-1 (CAT::diagram-1 cocone)) nil)))))
                                                              
(defun SPECCALC::ppColimit-1 (x) (SPECCALC::ppColimit (car x) (cdr x)))
                                                                       
(defun SPECCALC::ppValue (value) 
  (block 
   nil 
   (if (eq (car value) :|Spec|) 
       (return 
        (WADLERLINDIG::ppString (ANNSPECPRINTER::printSpec-1 (cdr value)))) 
       (if (eq (car value) :|Morph|) 
           (return (SPECCALC::ppMorphism-1 (cdr value))) 
           (if (eq (car value) :|Diag|) 
               (return (CAT::ppDiagram-1 (cdr value))) 
               (if (eq (car value) :|Colimit|) 
                   (return (SPECCALC::ppColimit-1 (cdr value))) 
                   (if (eq (car value) :|InProcess|) 
                       (return (WADLERLINDIG::ppString "InProcess"))))))) 
   (error "Nonexhaustive match failure in ppValue")))
                                                     
(defun SPECCALC::showValue (value) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppValue value)))
                                                     
(defun SPECCALC::evaluateDiagMorph (domTerm codTerm morphRules) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 domTerm) 
   #'(lambda (domValueInfo) 
      (SPECCALC::monadBind 
       (SPECCALC::evaluateTermInfo-1 codTerm) 
       #'(lambda (codValueInfo) 
          (block 
           nil 
           (return 
            (block 
             nil 
             (return 
              (SPECCALC::raise 
               (cons 
                :|Unsupported| 
                (cons 
                 (SPECCALC::positionOf-1 domTerm) 
                 (STRING-SPEC::^ 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       (STRING-SPEC::^ 
                        (STRING-SPEC::^ 
                         "diagram morphisms not available yet
" 
                         "Dom diagram  = 
") 
                        (SPECCALC::showValue (svref domValueInfo 0))) 
                       "
") 
                      "Cod diagram  = 
") 
                     (SPECCALC::showValue (svref codValueInfo 0))) 
                    "
") 
                   (NAT-SPEC::toString (LIST-SPEC::|!length| morphRules))) 
                  " diagram-morphism rules 
"))))) 
             (error "Nonexhaustive match failure in evaluateDiagMorph"))) 
           (error "Nonexhaustive match failure in evaluateDiagMorph")))))))
                                                                           
(defun SPECCALC::evaluateDiagMorph-1 (x) 
  (SPECCALC::evaluateDiagMorph (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun SPECCALC::evaluateLocalDecls (decls) 
  (labels 
    ((evaluateLocalDecl (name term) 
      (SPECCALC::monadBind 
       (SPECCALC::evaluateTermInfo-1 term) 
       #'(lambda (valueInfo) 
          (SPECCALC::monadSeq 
           (funcall (SPECCALC::bindInLocalContext 
                     (cons :|URI_Relative| (cons '(:|None|) (cons name nil)))) 
                    valueInfo) 
           (SPECCALC::|!return| nil)))))) 
    (funcall (funcall (SPECCALC::foldM 
                       #'(lambda (pV5303) 
                          (declare (ignore pV5303)) 
                          #'(lambda (decl) 
                             (evaluateLocalDecl (car decl) (cdr decl))))) 
                      nil) 
             decls)))
                     
(defun SPECCALC::evaluateLet (decls) 
  #'(lambda (term) 
     (SPECCALC::monadBind 
      #'SPECCALC::getLocalContext-1 
      #'(lambda (context) 
         (SPECCALC::monadSeq 
          (SPECCALC::evaluateLocalDecls decls) 
          (SPECCALC::monadBind 
           (SPECCALC::evaluateTermInfo-1 term) 
           #'(lambda (valueInfo) 
              (SPECCALC::monadSeq 
               (SPECCALC::setLocalContext context) 
               (SPECCALC::|!return| valueInfo)))))))))
                                                      
(defun SPECCALC::getURI-1 (term) 
  (let ((pV5596 (SPECCALC::valueOf-1 term))) 
    (block 
     nil 
     (if (eq (car pV5596) :|URI|) 
         (return 
          (SPECCALC::monadBind 
           (funcall (SPECCALC::evaluateReturnURI (SPECCALC::positionOf-1 term)) 
                    (cdr pV5596)) 
           #'(lambda (x) (SPECCALC::|!return| (cdr x)))))) 
     (return #'SPECCALC::getCurrentURI-1))))
                                            
(defun SPECTOLISP::curryShapeNum (sp srt) 
  (let ((pV7452 (SPECENVIRONMENT::arrowOpt sp srt))) 
    (block 
     nil 
     (if (eq (car pV7452) :|Some|) 
         (return 
          (INTEGER-SPEC::|!+| 
           1 
           (SPECTOLISP::curryShapeNum sp (cdr (cdr pV7452)))))) 
     (return 0))))
                  
(defun SPECTOLISP::genNNames (n) 
  (LIST-SPEC::tabulate 
   n 
   #'(lambda (i) (STRING-SPEC::^ "x" (NAT-SPEC::toString i)))))
                                                               
(defun SPECTOLISP::countOccurrence2 (x |!count| terms) 
  (block 
   nil 
   (if (null terms) 
       (return |!count|) 
       (if (consp terms) 
           (let ((pV7450 (cdr terms))
                 (pV7449 (car terms))) 
             (return 
              (block 
               nil 
               (if (eq (car pV7449) :|Apply|) 
                   (let ((pV7430 (cdr pV7449))) 
                     (return 
                      (SPECTOLISP::countOccurrence2 
                       x 
                       |!count| 
                       (cons (car pV7430) (LIST-SPEC::|!++| (cdr pV7430) pV7450))))) 
                   (if (eq (car pV7449) :|Lambda|) 
                       (let ((pV7429 (cdr pV7449))) 
                         (return 
                          (if (lisp::or 
                               (LIST-SPEC::|!member| x (svref pV7429 0)) 
                               ( =  
                                (SPECTOLISP::countOccurrence2 
                                 x 
                                 0 
                                 (cons (svref pV7429 2) nil)) 
                                0)) 
                              (SPECTOLISP::countOccurrence2 x |!count| pV7450) 
                              2))) 
                       (if (eq (car pV7449) :|Letrec|) 
                           (let ((pV7428 (cdr pV7449))) 
                             (let ((pV7441 (svref pV7428 2))) 
                               (return 
                                (if (lisp::or 
                                     (LIST-SPEC::|!member| x (svref pV7428 0)) 
                                     ( =  
                                      (SPECTOLISP::countOccurrence2 
                                       x 
                                       0 
                                       (cons pV7441 nil)) 
                                      0)) 
                                    (SPECTOLISP::countOccurrence2 
                                     x 
                                     |!count| 
                                     (LIST-SPEC::|!cons| 
                                      pV7441 
                                      (LIST-SPEC::|!++| (svref pV7428 1) pV7450))) 
                                    2)))) 
                           (if (eq (car pV7449) :|Let|) 
                               (let ((pV7427 (cdr pV7449))) 
                                 (return 
                                  (SPECTOLISP::countOccurrence2 
                                   x 
                                   |!count| 
                                   (LIST-SPEC::|!cons| 
                                    (svref pV7427 2) 
                                    (LIST-SPEC::|!++| (svref pV7427 1) pV7450))))) 
                               (if (eq (car pV7449) :|If|) 
                                   (let ((pV7426 (cdr pV7449))) 
                                     (return 
                                      (SPECTOLISP::countOccurrence2 
                                       x 
                                       |!count| 
                                       (LIST-SPEC::|!++| 
                                        (cons 
                                         (svref pV7426 0) 
                                         (cons 
                                          (svref pV7426 1) 
                                          (cons (svref pV7426 2) nil))) 
                                        pV7450)))) 
                                   (if (eq (car pV7449) :|IfThen|) 
                                       (let ((pV7425 (cdr pV7449))) 
                                         (return 
                                          (SPECTOLISP::countOccurrence2 
                                           x 
                                           |!count| 
                                           (LIST-SPEC::|!++| 
                                            (cons 
                                             (car pV7425) 
                                             (cons (cdr pV7425) nil)) 
                                            pV7450)))) 
                                       (if (eq (car pV7449) :|Seq|) 
                                           (return 
                                            (SPECTOLISP::countOccurrence2 
                                             x 
                                             |!count| 
                                             (LIST-SPEC::|!++| 
                                              (cdr pV7449) 
                                              pV7450))) 
                                           (if (eq (car pV7449) :|Var|) 
                                               (return 
                                                (if (string=  x (cdr pV7449)) 
                                                    (if (INTEGER-SPEC::|!>| 
                                                         |!count| 
                                                         0) 
                                                        2 
                                                        (SPECTOLISP::countOccurrence2 
                                                         x 
                                                         (INTEGER-SPEC::|!+| 
                                                          |!count| 
                                                          1) 
                                                         pV7450)) 
                                                    (SPECTOLISP::countOccurrence2 
                                                     x 
                                                     |!count| 
                                                     pV7450))))))))))) 
               (return (SPECTOLISP::countOccurrence2 x |!count| pV7450))))))) 
   (error "Nonexhaustive match failure in countOccurrence2")))
                                                              
(defun SPECTOLISP::pV? (var_name) 
  (let ((pV8074 (STRING-SPEC::explode var_name))) 
    (block 
     nil 
     (if (consp pV8074) 
         (let ((pV8077 (cdr pV8074))) 
           (if (eq #\p (car pV8074)) 
               (if (consp pV8077) 
                   (if (eq #\V (car pV8077)) 
                       (return 
                        (LIST-SPEC::all-1-1 #'CHAR-SPEC::isNum (cdr pV8077)))))))) 
     (return nil))))
                    
(defun SPECTOLISP::pure (term) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (return t) 
       (if (eq (car term) :|Const|) 
           (return t) 
           (if (eq (car term) :|Op|) 
               (return t) 
               (if (eq (car term) :|Lambda|) 
                   (return t) 
                   (if (eq (car term) :|Apply|) 
                       (let ((pV8118 (cdr term))) 
                         (let ((pV8124 (cdr pV8118))
                               (pV8123 (car pV8118))) 
                           (if (eq (car pV8123) :|Op|) 
                               (let ((pV8125 (cdr pV8123))) 
                                 (if (string=  "cdr" pV8125) 
                                     (return 
                                      (LIST-SPEC::all-1-1 
                                       #'SPECTOLISP::pure 
                                       pV8124)) 
                                     (if (string=  "car" pV8125) 
                                         (return 
                                          (LIST-SPEC::all-1-1 
                                           #'SPECTOLISP::pure 
                                           pV8124)) 
                                         (if (string=  "svref" pV8125) 
                                             (return 
                                              (LIST-SPEC::all-1-1 
                                               #'SPECTOLISP::pure 
                                               pV8124)) 
                                             (if (string=  "vector" pV8125) 
                                                 (return 
                                                  (LIST-SPEC::all-1-1 
                                                   #'SPECTOLISP::pure 
                                                   pV8124)) 
                                                 (if (string=  "cons" pV8125) 
                                                     (return 
                                                      (LIST-SPEC::all-1-1 
                                                       #'SPECTOLISP::pure 
                                                       pV8124)))))))))))))))) 
   (return nil)))
                 
(defun SPECTOLISP::simpleTerm (term) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (return t) 
       (if (eq (car term) :|Const|) 
           (return t) 
           (if (eq (car term) :|Op|) (return t)))) 
   (return nil)))
                 
(defun SPECTOLISP::getNames (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV7533 (cdr term))) 
         (return 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) 
              (LIST-SPEC::|!++| (SPECTOLISP::getNames (car x)) (cdr x))) 
           (SPECTOLISP::getNames (car pV7533)) 
           (cdr pV7533)))) 
       (if (eq (car term) :|Lambda|) 
           (let ((pV7532 (cdr term))) 
             (return 
              (LIST-SPEC::|!++| 
               (svref pV7532 0) 
               (SPECTOLISP::getNames (svref pV7532 2))))) 
           (if (eq (car term) :|Op|) 
               (return (cons (cdr term) nil)) 
               (if (eq (car term) :|Var|) 
                   (return (cons (cdr term) nil)) 
                   (if (eq (car term) :|Const|) 
                       (return nil) 
                       (if (eq (car term) :|If|) 
                           (let ((pV7528 (cdr term))) 
                             (return 
                              (LIST-SPEC::|!++| 
                               (LIST-SPEC::|!++| 
                                (SPECTOLISP::getNames (svref pV7528 0)) 
                                (SPECTOLISP::getNames (svref pV7528 1))) 
                               (SPECTOLISP::getNames (svref pV7528 2))))) 
                           (if (eq (car term) :|IfThen|) 
                               (let ((pV7527 (cdr term))) 
                                 (return 
                                  (LIST-SPEC::|!++| 
                                   (SPECTOLISP::getNames (car pV7527)) 
                                   (SPECTOLISP::getNames (cdr pV7527))))) 
                               (if (eq (car term) :|Let|) 
                                   (let ((pV7526 (cdr term))) 
                                     (return 
                                      (LIST-SPEC::|!++| 
                                       (LIST-SPEC::|!++| 
                                        (svref pV7526 0) 
                                        (LIST-SPEC::flatten 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'SPECTOLISP::getNames 
                                          (svref pV7526 1)))) 
                                       (SPECTOLISP::getNames (svref pV7526 2))))) 
                                   (if (eq (car term) :|Letrec|) 
                                       (let ((pV7525 (cdr term))) 
                                         (return 
                                          (LIST-SPEC::|!++| 
                                           (LIST-SPEC::|!++| 
                                            (svref pV7525 0) 
                                            (LIST-SPEC::flatten 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'SPECTOLISP::getNames 
                                              (svref pV7525 1)))) 
                                           (SPECTOLISP::getNames 
                                            (svref pV7525 2))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (return 
                                            (LIST-SPEC::flatten 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'SPECTOLISP::getNames 
                                              (cdr term)))))))))))))) 
   (return (SYSTEM-SPEC::fail "Unexpected term in getNames"))))
                                                               
(defun SPECTOLISP::newName (name names) 
  (labels 
    ((|!loop| (i) 
      (let ((n (STRING-SPEC::^ name (NAT-SPEC::toString i)))) 
        (if (LIST-SPEC::|!exists|-1-1 #'(lambda (m) (string=  n m)) names) 
            (|!loop| (INTEGER-SPEC::|!+| i 1)) 
            n)))) (|!loop| 1)))
                               
(defun SPECTOLISP::rename (pV8170 pV8171) 
  (block 
   nil 
   (let ((pV8174 (svref pV8171 2))
         (pV8173 (svref pV8171 1))
         (pV8172 (svref pV8171 0))) 
     (return 
      (if (LIST-SPEC::|!exists|-1-1 #'(lambda (n) (string=  n pV8170)) pV8173) 
          (let ((n (SPECTOLISP::newName pV8170 pV8173))) 
            (let ((body 
                   (SPECTOLISP::|!substitute|-1-1 
                    (cons pV8170 (LISTADT::mkLVar n)) 
                    pV8174))) 
              (vector 
               (LIST-SPEC::|!cons| n pV8172) 
               (LIST-SPEC::|!cons| n pV8173) 
               body))) 
          (vector (LIST-SPEC::|!cons| pV8170 pV8172) pV8173 pV8174)))) 
   (error "Nonexhaustive match failure in rename")))
                                                    
(defun SPECTOLISP::rename-1 (x) (SPECTOLISP::rename (car x) (cdr x)))
                                                                     
(defun SPECTOLISP::|!substitute|-1 (x1) 
  #'(lambda (x2) (SPECTOLISP::|!substitute|-1-1 x1 x2)))
                                                        
(defun SPECTOLISP::|!substitute| (x0 x1) 
  (SPECTOLISP::|!substitute|-1 (cons x0 x1)))
                                             
(defun SPECTOLISP::rename2 (pV8175 pV8176) 
  (block 
   nil 
   (let ((pV8180 (svref pV8176 3))
         (pV8179 (svref pV8176 2))
         (pV8178 (svref pV8176 1))
         (pV8177 (svref pV8176 0))) 
     (return 
      (if (LIST-SPEC::|!exists|-1-1 #'(lambda (n) (string=  n pV8175)) pV8179) 
          (let ((n (SPECTOLISP::newName pV8175 pV8179))) 
            (let ((body 
                   (SPECTOLISP::|!substitute|-1-1 
                    (cons pV8175 (LISTADT::mkLVar n)) 
                    pV8180))) 
              (let ((terms 
                     (LIST-SPEC::|!map|-1-1 
                      (SPECTOLISP::|!substitute| pV8175 (LISTADT::mkLVar n)) 
                      pV8178))) 
                (vector 
                 (LIST-SPEC::|!cons| n pV8177) 
                 terms 
                 (LIST-SPEC::|!cons| n pV8179) 
                 body)))) 
          (vector (LIST-SPEC::|!cons| pV8175 pV8177) pV8178 pV8179 pV8180)))) 
   (error "Nonexhaustive match failure in rename2")))
                                                     
(defun SPECTOLISP::rename2-1 (x) (SPECTOLISP::rename2 (car x) (cdr x)))
                                                                       
(defun SPECTOLISP::|!substitute|-1-1 (!x1 body) 
  (let ((arg (cdr !x1))
        (x (car !x1))) 
    (block 
     nil 
     (if (eq (car body) :|Apply|) 
         (let ((pV8230 (cdr body))) 
           (return 
            (cons 
             :|Apply| 
             (cons 
              (SPECTOLISP::|!substitute|-1-1 (cons x arg) (car pV8230)) 
              (LIST-SPEC::|!map|-1-1 
               (SPECTOLISP::|!substitute| x arg) 
               (cdr pV8230)))))) 
         (if (eq (car body) :|Lambda|) 
             (let ((pV8229 (cdr body))) 
               (let ((pV8242 (svref pV8229 0))
                     (pV8243 (svref pV8229 1))
                     (pV8244 (svref pV8229 2))) 
                 (return 
                  (if (LIST-SPEC::|!exists|-1-1 
                       #'(lambda (v) (string=  x v)) 
                       pV8242) 
                      (LISTADT::mkLLambda pV8242 pV8243 pV8244) 
                      (let ((names (SPECTOLISP::getNames arg))) 
                        (let ((pV8208 
                               (LIST-SPEC::foldr-1-1-1 
                                #'SPECTOLISP::rename-1 
                                (vector nil names pV8244) 
                                pV8242))) 
                          (block 
                           nil 
                           (return 
                            (LISTADT::mkLLambda 
                             (svref pV8208 0) 
                             pV8243 
                             (SPECTOLISP::|!substitute|-1-1 
                              (cons x arg) 
                              (svref pV8208 2)))) 
                           (error "Nonexhaustive match failure in substitute")))))))) 
             (if (eq (car body) :|Var|) 
                 (let ((pV8228 (cdr body))) 
                   (return (if (string=  x pV8228) arg (LISTADT::mkLVar pV8228)))) 
                 (if (eq (car body) :|Let|) 
                     (let ((pV8227 (cdr body))) 
                       (let ((pV8239 (svref pV8227 0))
                             (pV8240 (svref pV8227 1))
                             (pV8241 (svref pV8227 2))) 
                         (return 
                          (if (LIST-SPEC::|!exists|-1-1 
                               #'(lambda (v) (string=  x v)) 
                               pV8239) 
                              (LISTADT::mkLLet 
                               pV8239 
                               (LIST-SPEC::|!map|-1-1 
                                (SPECTOLISP::|!substitute| x arg) 
                                pV8240) 
                               pV8241) 
                              (let ((terms 
                                     (LIST-SPEC::|!map|-1-1 
                                      (SPECTOLISP::|!substitute| x arg) 
                                      pV8240))) 
                                (let ((names (SPECTOLISP::getNames arg))) 
                                  (let ((pV8212 
                                         (LIST-SPEC::foldr-1-1-1 
                                          #'SPECTOLISP::rename-1 
                                          (vector nil names pV8241) 
                                          pV8239))) 
                                    (block 
                                     nil 
                                     (return 
                                      (LISTADT::mkLLet 
                                       (svref pV8212 0) 
                                       terms 
                                       (SPECTOLISP::|!substitute|-1-1 
                                        (cons x arg) 
                                        (svref pV8212 2)))) 
                                     (error 
                                      "Nonexhaustive match failure in substitute"))))))))) 
                     (if (eq (car body) :|Letrec|) 
                         (let ((pV8226 (cdr body))) 
                           (let ((pV8236 (svref pV8226 0))
                                 (pV8237 (svref pV8226 1))
                                 (pV8238 (svref pV8226 2))) 
                             (return 
                              (if (LIST-SPEC::|!exists|-1-1 
                                   #'(lambda (v) (string=  x v)) 
                                   pV8236) 
                                  (LISTADT::mkLLetRec pV8236 pV8237 pV8238) 
                                  (let ((names (SPECTOLISP::getNames arg))) 
                                    (let ((terms 
                                           (LIST-SPEC::|!map|-1-1 
                                            (SPECTOLISP::|!substitute| x arg) 
                                            pV8237))) 
                                      (let ((pV8216 
                                             (LIST-SPEC::foldr-1-1-1 
                                              #'SPECTOLISP::rename2-1 
                                              (vector nil terms names pV8238) 
                                              pV8236))) 
                                        (block 
                                         nil 
                                         (return 
                                          (LISTADT::mkLLetRec 
                                           (svref pV8216 0) 
                                           (svref pV8216 1) 
                                           (SPECTOLISP::|!substitute|-1-1 
                                            (cons x arg) 
                                            (svref pV8216 3)))) 
                                         (error 
                                          "Nonexhaustive match failure in substitute"))))))))) 
                         (if (eq (car body) :|If|) 
                             (let ((pV8225 (cdr body))) 
                               (return 
                                (LISTADT::mkLIf 
                                 (SPECTOLISP::|!substitute|-1-1 
                                  (cons x arg) 
                                  (svref pV8225 0)) 
                                 (SPECTOLISP::|!substitute|-1-1 
                                  (cons x arg) 
                                  (svref pV8225 1)) 
                                 (SPECTOLISP::|!substitute|-1-1 
                                  (cons x arg) 
                                  (svref pV8225 2))))) 
                             (if (eq (car body) :|IfThen|) 
                                 (let ((pV8224 (cdr body))) 
                                   (return 
                                    (cons 
                                     :|IfThen| 
                                     (cons 
                                      (SPECTOLISP::|!substitute|-1-1 
                                       (cons x arg) 
                                       (car pV8224)) 
                                      (SPECTOLISP::|!substitute|-1-1 
                                       (cons x arg) 
                                       (cdr pV8224)))))) 
                                 (if (eq (car body) :|Seq|) 
                                     (return 
                                      (LISTADT::mkLSeq 
                                       (LIST-SPEC::|!map|-1-1 
                                        (SPECTOLISP::|!substitute| x arg) 
                                        (cdr body)))))))))))) 
     (return body))))
                     
(defun SPECTOLISP::reduceTerm (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV8149 (cdr term))) 
         (let ((pV8165 (cdr pV8149))
               (pV8164 (car pV8149))) 
           (progn (if (eq (car pV8164) :|Lambda|) 
                      (let ((pV8166 (cdr pV8164))) 
                        (return 
                         (SPECTOLISP::reduceTerm 
                          (cons 
                           :|Let| 
                           (vector (svref pV8166 0) pV8165 (svref pV8166 2))))))) 
                  (return 
                   (let ((term1 (SPECTOLISP::reduceTerm pV8164))) 
                     (let ((terms 
                            (LIST-SPEC::|!map|-1-1 
                             #'SPECTOLISP::reduceTerm 
                             pV8165))) (LISTADT::mkLApply term1 terms))))))) 
       (if (eq (car term) :|Lambda|) 
           (let ((pV8148 (cdr term))) 
             (let ((pV8162 (svref pV8148 1))
                   (pV8161 (svref pV8148 0))) 
               (return 
                (let ((reduced_body (SPECTOLISP::reduceTerm (svref pV8148 2)))) 
                  (let ((unused_pv_vars 
                         (LIST-SPEC::foldr-1-1-1 
                          #'(lambda (x) 
                             (let ((unused_vars (cdr x))
                                   (var_name (car x))) 
                               (if (lisp::and 
                                    (SPECTOLISP::pV? var_name) 
                                    ( =  
                                     (SPECTOLISP::countOccurrence2 
                                      var_name 
                                      0 
                                      (cons reduced_body nil)) 
                                     0)) 
                                   (LIST-SPEC::|!cons| var_name unused_vars) 
                                   unused_vars))) 
                          nil 
                          pV8161))) 
                    (let ((augmented_decls 
                           (block 
                            nil 
                            (if (null unused_pv_vars) (return pV8162)) 
                            (return 
                             (LIST-SPEC::|!cons| 
                              (cons :|Ignore| unused_pv_vars) 
                              pV8162))))) 
                      (LISTADT::mkLLambda pV8161 augmented_decls reduced_body))))))) 
           (if (eq (car term) :|Let|) 
               (let ((pV8147 (cdr term))) 
                 (return 
                  (let ((body (SPECTOLISP::reduceTerm (svref pV8147 2)))) 
                    (let ((args 
                           (LIST-SPEC::|!map|-1-1 
                            #'SPECTOLISP::reduceTerm 
                            (svref pV8147 1)))) 
                      (let ((xArgs (LISTPAIR::zip (svref pV8147 0) args))) 
                        (let ((terms (LIST-SPEC::|!cons| body args))) 
                          (let ((xNumArgs 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x) 
                                     (let ((arg (cdr x))
                                           (x1 (car x))) 
                                       (if (SPECTOLISP::simpleTerm arg) 
                                           (vector 
                                            x1 
                                            (SPECTOLISP::countOccurrence2 
                                             x1 
                                             0 
                                             args) 
                                            nil 
                                            arg) 
                                           (if (SPECTOLISP::pure arg) 
                                               (vector 
                                                x1 
                                                (SPECTOLISP::countOccurrence2 
                                                 x1 
                                                 0 
                                                 terms) 
                                                nil 
                                                arg) 
                                               (if (INTEGER-SPEC::|!>| 
                                                    (SPECTOLISP::countOccurrence2 
                                                     x1 
                                                     0 
                                                     terms) 
                                                    0) 
                                                   (vector x1 2 nil arg) 
                                                   (vector x1 2 t arg)))))) 
                                  xArgs))) 
                            (let ((pV8138 
                                   (LIST-SPEC::foldr-1-1-1 
                                    #'(lambda (x) 
                                       (let ((pV8130 (cdr x))
                                             (pV8129 (car x))) 
                                         (block 
                                          nil 
                                          (let ((pV8134 (svref pV8129 3))
                                                (pV8131 (svref pV8129 0))) 
                                            (let ((pV8137 (svref pV8130 2))
                                                  (pV8136 (svref pV8130 1))
                                                  (pV8135 (svref pV8130 0))) 
                                              (return 
                                               (if (INTEGER-SPEC::|!<| 
                                                    (svref pV8129 1) 
                                                    2) 
                                                   (vector 
                                                    pV8135 
                                                    pV8136 
                                                    (SPECTOLISP::|!substitute|-1-1 
                                                     (cons pV8131 pV8134) 
                                                     pV8137)) 
                                                   (if (svref pV8129 2) 
                                                       (vector 
                                                        pV8135 
                                                        pV8136 
                                                        (LISTADT::mkLSeq 
                                                         (cons 
                                                          pV8134 
                                                          (cons pV8137 nil)))) 
                                                       (vector 
                                                        (LIST-SPEC::|!cons| 
                                                         pV8131 
                                                         pV8135) 
                                                        (LIST-SPEC::|!cons| 
                                                         pV8134 
                                                         pV8136) 
                                                        pV8137)))))) 
                                          (error 
                                           "Nonexhaustive match failure in reduceTerm")))) 
                                    (vector nil nil body) 
                                    xNumArgs))) 
                              (block 
                               nil 
                               (return 
                                (LISTADT::mkLLet 
                                 (LIST-SPEC::rev (svref pV8138 0)) 
                                 (LIST-SPEC::rev (svref pV8138 1)) 
                                 (svref pV8138 2))) 
                               (error 
                                "Nonexhaustive match failure in reduceTerm")))))))))) 
               (if (eq (car term) :|Letrec|) 
                   (let ((pV8146 (cdr term))) 
                     (return 
                      (LISTADT::mkLLetRec 
                       (svref pV8146 0) 
                       (LIST-SPEC::|!map|-1-1 
                        #'SPECTOLISP::reduceTerm 
                        (svref pV8146 1)) 
                       (SPECTOLISP::reduceTerm (svref pV8146 2))))) 
                   (if (eq (car term) :|If|) 
                       (let ((pV8145 (cdr term))) 
                         (return 
                          (LISTADT::mkLIf 
                           (SPECTOLISP::reduceTerm (svref pV8145 0)) 
                           (SPECTOLISP::reduceTerm (svref pV8145 1)) 
                           (SPECTOLISP::reduceTerm (svref pV8145 2))))) 
                       (if (eq (car term) :|IfThen|) 
                           (let ((pV8144 (cdr term))) 
                             (return 
                              (cons 
                               :|IfThen| 
                               (cons 
                                (SPECTOLISP::reduceTerm (car pV8144)) 
                                (SPECTOLISP::reduceTerm (cdr pV8144)))))) 
                           (if (eq (car term) :|Seq|) 
                               (return 
                                (LISTADT::mkLSeq 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'SPECTOLISP::reduceTerm 
                                  (cdr term))))))))))) 
   (return term)))
                  
(defun SPECTOLISP::defAliasFn (name n) 
  (let ((vnames (SPECTOLISP::genNNames n))) 
    (SPECTOLISP::reduceTerm 
     (LISTADT::mkLLambda 
      vnames 
      nil 
      (LISTADT::mkLApply 
       (LISTADT::mkLOp name) 
       (LIST-SPEC::|!map|-1-1 #'LISTADT::mkLVar vnames))))))
                                                            
(defun SPECTOLISP::defCurryByUncurry (name n) 
  (labels 
    ((auxRec (i args) 
      (if (INTEGER-SPEC::|!>| i n) 
          (LISTADT::mkLApply (LISTADT::mkLOp name) args) 
          (let ((vn (STRING-SPEC::^ "x" (NAT-SPEC::toString i)))) 
            (SPECTOLISP::reduceTerm 
             (LISTADT::mkLLambda 
              (cons vn nil) 
              nil 
              (auxRec 
               (INTEGER-SPEC::|!+| i 1) 
               (LIST-SPEC::|!++| args (cons (LISTADT::mkLVar vn) nil))))))))) 
    (auxRec 1 nil)))
                    
(defun SPECTOLISP::mkLispTuple (valTms) 
  (block 
   nil 
   (if (null valTms) 
       (return (LISTADT::mkLBool nil)) 
       (if (consp valTms) 
           (let ((pV8068 (cdr valTms))) 
             (if (consp pV8068) 
                 (if (null (cdr pV8068)) 
                     (return (LISTADT::mkLApply (LISTADT::mkLOp "cons") valTms))))))) 
   (return (LISTADT::mkLApply (LISTADT::mkLOp "vector") valTms))))
                                                                  
(defun SPECTOLISP::defNaryByUnary (name n) 
  (let ((vnames (SPECTOLISP::genNNames n))) 
    (SPECTOLISP::reduceTerm 
     (LISTADT::mkLLambda 
      vnames 
      nil 
      (LISTADT::mkLApply 
       (LISTADT::mkLOp name) 
       (cons 
        (SPECTOLISP::mkLispTuple 
         (LIST-SPEC::|!map|-1-1 #'LISTADT::mkLVar vnames)) 
        nil))))))
                 
(defun SPECTOLISP::nTupleDerefs (n vr) 
  (if ( =  n 2) 
      (cons 
       (LISTADT::mkLApply (LISTADT::mkLOp "car") (cons vr nil)) 
       (cons (LISTADT::mkLApply (LISTADT::mkLOp "cdr") (cons vr nil)) nil)) 
      (LIST-SPEC::tabulate 
       n 
       #'(lambda (i) 
          (LISTADT::mkLApply 
           (LISTADT::mkLOp "svref") 
           (cons vr (cons (LISTADT::mkLNat i) nil)))))))
                                                        
(defun SPECTOLISP::defUnaryByNary (name n) 
  (SPECTOLISP::reduceTerm 
   (LISTADT::mkLLambda 
    (cons (if ( =  n 0) "ignore" "x") nil) 
    (if ( =  n 0) (cons (cons :|Ignore| (cons "ignore" nil)) nil) nil) 
    (LISTADT::mkLApply 
     (LISTADT::mkLOp name) 
     (SPECTOLISP::nTupleDerefs n (LISTADT::mkLVar "x"))))))
                                                           
(defun SPECTOLISP::defUncurryByUnary (name n) 
  (labels 
    ((auxRec (i args bod) 
      (if (INTEGER-SPEC::|!>| i n) 
          (SPECTOLISP::reduceTerm (LISTADT::mkLLambda args nil bod)) 
          (let ((vn (STRING-SPEC::^ "x" (NAT-SPEC::toString i)))) 
            (auxRec 
             (INTEGER-SPEC::|!+| i 1) 
             (LIST-SPEC::|!++| args (cons vn nil)) 
             (LISTADT::mkLApply bod (cons (LISTADT::mkLVar vn) nil))))))) 
    (auxRec 1 nil (LISTADT::mkLOp name))))
                                          
(defparameter SPECTOLISP::defaultSpecwarePackage "SW-USER")
                                                           
(defun SPECTOLISP::functionSort? (sp srt) 
  (let ((pV7514 (SPECENVIRONMENT::unfoldBase sp srt))) 
    (block 
     nil 
     (if (eq (car pV7514) :|Arrow|) 
         (return t) 
         (if (eq (car pV7514) :|Subsort|) 
             (return (SPECTOLISP::functionSort? sp (svref (cdr pV7514) 0))))) 
     (return nil))))
                    
(defparameter SPECTOLISP::userStrings (cons :|Ref| STRINGSET::empty))
                                                                     
(defparameter SPECTOLISP::userUpper (cons :|Ref| STRINGSET::empty))
                                                                   
(defun SPECTOLISP::initializeSpecId () 
  (progn (STATE::|:=| SPECTOLISP::userStrings STRINGSET::empty) 
         (STATE::|:=| SPECTOLISP::userUpper STRINGSET::empty)))
                                                               
(defun SPECTOLISP::flattenFailWith (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV7467 (cdr term))) 
         (let ((pV7469 (svref pV7467 1))
               (pV7468 (svref pV7467 0))) 
           (if (eq (car pV7468) :|Fun|) 
               (let ((pV7472 (svref (cdr pV7468) 0))) 
                 (if (eq (car pV7472) :|Op|) 
                     (let ((pV7476 (car (cdr pV7472)))) 
                       (if (eq (car pV7476) :|Qualified|) 
                           (let ((pV7478 (cdr pV7476))) 
                             (if (string=  "TranslationBuiltIn" (car pV7478)) 
                                 (if (string=  "failWith" (cdr pV7478)) 
                                     (if (eq (car pV7469) :|Record|) 
                                         (let ((pV7482 (car (cdr pV7469)))) 
                                           (if (consp pV7482) 
                                               (let ((pV7486 (cdr pV7482))) 
                                                 (if (consp pV7486) 
                                                     (if (null (cdr pV7486)) 
                                                         (return 
                                                          (LIST-SPEC::|!++| 
                                                           (SPECTOLISP::flattenFailWith 
                                                            (cdr (car pV7482))) 
                                                           (SPECTOLISP::flattenFailWith 
                                                            (cdr (car pV7486)))))))))))))))))))))) 
   (return (cons term nil))))
                             
(defun SPECTOLISP::lispBlock (sp dpn vars term) 
  (let ((terms (SPECTOLISP::flattenFailWith term))) 
    (let ((terms 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (term) (SPECTOLISP::blockAtom sp dpn vars term)) 
            terms))) (LISTADT::mkLSeq terms))))
                                               
(defun SPECTOLISP::patternName (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) (return (car (car (cdr pattern))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      "SpecToLisp.patternName " 
      (ANNSPECPRINTER::printPattern pattern))))))
                                                 
(defparameter SPECTOLISP::lispStrings 
  (STRINGSET::fromList 
   (cons 
    "NIL" 
    (cons 
     "T" 
     (cons 
      "CONS" 
      (cons 
       "NULL" 
       (cons 
        "CAR" 
        (cons 
         "CDR" 
         (cons 
          "LIST" 
          (cons 
           "LISP" 
           (cons 
            "APPEND" 
            (cons 
             "REVAPPEND" 
             (cons 
              "REVERSE" 
              (cons 
               "COMPILE" 
               (cons 
                "REDUCE" 
                (cons 
                 "SUBSTITUTE" 
                 (cons 
                  "COUNT" 
                  (cons 
                   "ENCLOSE" 
                   (cons 
                    "EVAL" 
                    (cons 
                     "ERROR" 
                     (cons 
                      "FIRST" 
                      (cons 
                       "LAST" 
                       (cons 
                        "SECOND" 
                        (cons 
                         "THIRD" 
                         (cons 
                          "FOURTH" 
                          (cons 
                           "FIFTH" 
                           (cons 
                            "SIXTH" 
                            (cons 
                             "SEVENTH" 
                             (cons 
                              "EIGHTH" 
                              (cons 
                               "NINTH" 
                               (cons 
                                "TENTH" 
                                (cons 
                                 "UNION" 
                                 (cons 
                                  "INTERSECTION" 
                                  (cons 
                                   "SET" 
                                   (cons 
                                    "SETQ" 
                                    (cons 
                                     "SOME" 
                                     (cons 
                                      "ARRAY" 
                                      (cons 
                                       "POP" 
                                       (cons 
                                        "PUSH" 
                                        (cons 
                                         "TOP" 
                                         (cons 
                                          "REMOVE" 
                                          (cons 
                                           "GET" 
                                           (cons 
                                            "REPLACE" 
                                            (cons 
                                             "PI" 
                                             (cons 
                                              "DELETE" 
                                              (cons 
                                               "IDENTITY" 
                                               (cons 
                                                "REM" 
                                                (cons 
                                                 "NTH" 
                                                 (cons 
                                                  "EQ" 
                                                  (cons 
                                                   "EQL" 
                                                   (cons 
                                                    "EQUAL" 
                                                    (cons 
                                                     "ZEROP" 
                                                     (cons 
                                                      "ODDP" 
                                                      (cons 
                                                       "EVENP" 
                                                       (cons 
                                                        "SEARCH" 
                                                        (cons 
                                                         "COMPILE" 
                                                         (cons 
                                                          "MERGE" 
                                                          (cons 
                                                           "RETURN" 
                                                           (cons 
                                                            "VECTOR" 
                                                            (cons 
                                                             "SVREF" 
                                                             (cons 
                                                              "FORALL" 
                                                              (cons 
                                                               "EXISTS" 
                                                               (cons 
                                                                "SETF" 
                                                                (cons 
                                                                 "LOOP" 
                                                                 (cons 
                                                                  "OR" 
                                                                  (cons 
                                                                   "AND" 
                                                                   (cons 
                                                                    "NOT" 
                                                                    (cons 
                                                                     "LENGTH" 
                                                                     (cons 
                                                                      "MAP" 
                                                                      (cons 
                                                                       "MEMBER" 
                                                                       (cons 
                                                                        "TIME" 
                                                                        (cons 
                                                                         "CHAR" 
                                                                         (cons 
                                                                          "STRING" 
                                                                          (cons 
                                                                           "SYMBOL" 
                                                                           (cons 
                                                                            "NAT" 
                                                                            (cons 
                                                                             "MAKE-STRING" 
                                                                             (cons 
                                                                              "CONST" 
                                                                              (cons 
                                                                               "IF" 
                                                                               (cons 
                                                                                "APPLY" 
                                                                                (cons 
                                                                                 "QUOTE" 
                                                                                 (cons 
                                                                                  "MIN" 
                                                                                  (cons 
                                                                                   "GO" 
                                                                                   (cons 
                                                                                    "PRINT" 
                                                                                    (cons 
                                                                                     "READ" 
                                                                                     (cons 
                                                                                      "WRITE" 
                                                                                      (cons 
                                                                                       "LOAD" 
                                                                                       (cons 
                                                                                        ".." 
                                                                                        (cons 
                                                                                         "BLOCK" 
                                                                                         (cons 
                                                                                          "FORMAT" 
                                                                                          (cons 
                                                                                           "BREAK" 
                                                                                           (cons 
                                                                                            "SUBST" 
                                                                                            (cons 
                                                                                             "FIND" 
                                                                                             (cons 
                                                                                              "CLASS" 
                                                                                              (cons 
                                                                                               "+" 
                                                                                               (cons 
                                                                                                "++" 
                                                                                                (cons 
                                                                                                 "**" 
                                                                                                 (cons 
                                                                                                  "-" 
                                                                                                  (cons 
                                                                                                   "*" 
                                                                                                   (cons 
                                                                                                    ">" 
                                                                                                    (cons 
                                                                                                     "<" 
                                                                                                     (cons 
                                                                                                      "<=" 
                                                                                                      (cons 
                                                                                                       ">= " 
                                                                                                       (cons 
                                                                                                        "\\=" 
                                                                                                        (cons 
                                                                                                         "BOOLEAN" 
                                                                                                         (cons 
                                                                                                          "INTEGER" 
                                                                                                          (cons 
                                                                                                           "SHADOW" 
                                                                                                           (cons 
                                                                                                            "TRACE" 
                                                                                                            (cons 
                                                                                                             "WHEN" 
                                                                                                             (cons 
                                                                                                              "SYSTEM" 
                                                                                                              (cons 
                                                                                                               "IO" 
                                                                                                               (cons 
                                                                                                                "BOOTSTRAP" 
                                                                                                                nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))


(defun SPECTOLISP::isLispString (id) 
  (lisp::or 
   (STRINGSET::|!member| SPECTOLISP::lispStrings id) 
   (LISP-SPEC::uncell 
    (LISP-SPEC::|!apply| 
     (LISP-SPEC::|!symbol| "LISP" "FIND-SYMBOL") 
     (cons 
      (LISP-SPEC::|!string| id) 
      (cons (LISP-SPEC::|!string| "COMMON-LISP") nil))))))
                                                          
(defun SPECTOLISP::lookupSpecId (id |!ID|) 
  (if (STRINGSET::|!member| (STATE::|!!| SPECTOLISP::userUpper) |!ID|) 
      (if (STRINGSET::|!member| (STATE::|!!| SPECTOLISP::userStrings) id) 
          id 
          (STRING-SPEC::^ (STRING-SPEC::^ "|!" id) "|")) 
      (progn (STATE::|:=| 
              SPECTOLISP::userUpper 
              (STRINGSET::add (STATE::|!!| SPECTOLISP::userUpper) |!ID|)) 
             (STATE::|:=| 
              SPECTOLISP::userStrings 
              (STRINGSET::add (STATE::|!!| SPECTOLISP::userStrings) id)) 
             id)))
                  
(defun SPECTOLISP::specId (id) 
  (let ((id 
         (STRING-SPEC::translate-1-1 
          #'(lambda (pV8207) 
             (block 
              nil 
              (if (eq #\| pV8207) 
                  (return "\\|") 
                  (if (eq #\# pV8207) (return "\\#"))) 
              (return (CHAR-SPEC::toString pV8207)))) 
          id))) 
    (let ((|!ID| (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase id))) 
      (if (lisp::or 
           (SPECTOLISP::isLispString |!ID|) 
           (eq (STRING-SPEC::sub id 0) #\!)) 
          (STRING-SPEC::^ (STRING-SPEC::^ "|!" id) "|") 
          (if (LIST-SPEC::|!exists|-1-1 
               #'(lambda (ch) (eq ch #\:)) 
               (STRING-SPEC::explode id)) 
              (STRING-SPEC::^ (STRING-SPEC::^ "|" id) "|") 
              (SPECTOLISP::lookupSpecId id |!ID|))))))
                                                      
(defun STRINGSET::addList (x0 x) (SPLAYSET::addList x0 x))
                                                          
(defun SPECTOLISP::blockAtom (sp dpn vars term) 
  (block 
   nil 
   (if (eq (car term) :|IfThenElse|) 
       (let ((pV7384 (cdr term))) 
         (let ((pV7408 (svref pV7384 2))
               (pV7407 (svref pV7384 1))
               (pV7406 (svref pV7384 0))) 
           (progn (if (eq (car pV7408) :|Fun|) 
                      (let ((pV7411 (svref (cdr pV7408) 0))) 
                        (if (eq (car pV7411) :|Op|) 
                            (let ((pV7415 (car (cdr pV7411)))) 
                              (if (eq (car pV7415) :|Qualified|) 
                                  (let ((pV7417 (cdr pV7415))) 
                                    (if (string=  
                                         "TranslationBuiltIn" 
                                         (car pV7417)) 
                                        (if (string=  "mkBreak" (cdr pV7417)) 
                                            (return 
                                             (cons 
                                              :|IfThen| 
                                              (cons 
                                               (SPECTOLISP::mkLTerm 
                                                sp 
                                                dpn 
                                                vars 
                                                pV7406) 
                                               (SPECTOLISP::blockAtom 
                                                sp 
                                                dpn 
                                                vars 
                                                pV7407)))))))))))) 
                  (return 
                   (cons 
                    :|If| 
                    (vector 
                     (SPECTOLISP::mkLTerm sp dpn vars pV7406) 
                     (SPECTOLISP::blockAtom sp dpn vars pV7407) 
                     (SPECTOLISP::blockAtom sp dpn vars pV7408))))))) 
       (if (eq (car term) :|Let|) 
           (let ((pV7383 (cdr term))) 
             (return 
              (let ((pV7362 (LISTPAIR::unzip (svref pV7383 0)))) 
                (block 
                 nil 
                 (return 
                  (let ((names 
                         (LIST-SPEC::|!map|-1-1 
                          #'SPECTOLISP::patternName 
                          (car pV7362)))) 
                    (let ((names 
                           (LIST-SPEC::|!map|-1-1 #'SPECTOLISP::specId names))) 
                      (LISTADT::mkLLet 
                       names 
                       (LIST-SPEC::|!map|-1-1 
                        #'(lambda (|!t|) (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                        (cdr pV7362)) 
                       (SPECTOLISP::blockAtom 
                        sp 
                        dpn 
                        (STRINGSET::addList vars names) 
                        (svref pV7383 1)))))) 
                 (error "Nonexhaustive match failure in blockAtom"))))) 
           (if (eq (car term) :|Apply|) 
               (let ((pV7382 (cdr term))) 
                 (let ((pV7386 (svref pV7382 1))
                       (pV7385 (svref pV7382 0))) 
                   (if (eq (car pV7385) :|Fun|) 
                       (let ((pV7389 (svref (cdr pV7385) 0))) 
                         (if (eq (car pV7389) :|Op|) 
                             (let ((pV7393 (car (cdr pV7389)))) 
                               (if (eq (car pV7393) :|Qualified|) 
                                   (let ((pV7395 (cdr pV7393))) 
                                     (let ((pV7397 (cdr pV7395))) 
                                       (if (string=  
                                            "TranslationBuiltIn" 
                                            (car pV7395)) 
                                           (if (string=  "mkSuccess" pV7397) 
                                               (return 
                                                (LISTADT::mkLApply 
                                                 (LISTADT::mkLOp "return") 
                                                 (cons 
                                                  (SPECTOLISP::mkLTerm 
                                                   sp 
                                                   dpn 
                                                   vars 
                                                   pV7386) 
                                                  nil))) 
                                               (if (string=  "mkFail" pV7397) 
                                                   (if (eq (car pV7386) :|Fun|) 
                                                       (let ((pV7399 
                                                              (svref 
                                                               (cdr pV7386) 
                                                               0))) 
                                                         (if (eq 
                                                              (car pV7399) 
                                                              :|String|) 
                                                             (return 
                                                              (LISTADT::mkLApply 
                                                               (LISTADT::mkLOp 
                                                                "error") 
                                                               (cons 
                                                                (LISTADT::mkLString 
                                                                 (cdr pV7399)) 
                                                                nil)))))) 
                                                   (if (string=  
                                                        "failWith" 
                                                        pV7397) 
                                                       (return 
                                                        (SPECTOLISP::lispBlock 
                                                         sp 
                                                         dpn 
                                                         vars 
                                                         term)))))))))))))))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ "Unexpected atom " (ANNSPECPRINTER::printTerm term))))))
                                                                             
(defun SPECTOLISP::mkLPackageId (id) 
  (if (string=  id METASLANG::UnQualified) 
      SPECTOLISP::defaultSpecwarePackage 
      (let ((id (STRING-SPEC::|!map|-1-1 #'CHAR-SPEC::toUpperCase id))) 
        (if (SPECTOLISP::isLispString id) (STRING-SPEC::^ id "-SPEC") id))))
                                                                            
(defun SPECTOLISP::printPackageId (id defPkgNm) 
  (block 
   nil 
   (if (eq (car id) :|Qualified|) 
       (let ((pV8105 (cdr id))) 
         (let ((pV8107 (cdr pV8105))
               (pV8106 (car pV8105))) 
           (progn (if (string=  "System" pV8106) 
                      (if (string=  "time" pV8107) (return "time"))) 
                  (return 
                   (let ((pkg (SPECTOLISP::mkLPackageId pV8106))) 
                     (if (string=  pkg defPkgNm) 
                         (SPECTOLISP::specId pV8107) 
                         (STRING-SPEC::^ 
                          (STRING-SPEC::^ pkg "::") 
                          (SPECTOLISP::specId pV8107))))))))) 
   (error "Nonexhaustive match failure in printPackageId")))
                                                            
(defun SPECTOLISP::duplicateString (n s) 
  (block 
   nil 
   (if ( =  0 n) (return "")) 
   (return 
    (STRING-SPEC::^ s (SPECTOLISP::duplicateString (INTEGER-SPEC::|!-| n 1) s)))))


(defun SPECTOLISP::unCurryName (name n) 
  (STRING-SPEC::^ name (SPECTOLISP::duplicateString n "-1")))
                                                             
(defun SPECTOLISP::fullCurriedApplication (sp dpn vars term) 
  (labels 
    ((aux (term i args) 
      (block 
       nil 
       (if (eq (car term) :|Fun|) 
           (let ((pV7500 (cdr term))) 
             (let ((pV7504 (svref pV7500 0))) 
               (if (eq (car pV7504) :|Op|) 
                   (return 
                    (if (lisp::and 
                         (INTEGER-SPEC::|!>| i 1) 
                         ( =  i (SPECTOLISP::curryShapeNum sp (svref pV7500 1)))) 
                        (cons 
                         :|Some| 
                         (LISTADT::mkLApply 
                          (LISTADT::mkLOp 
                           (SPECTOLISP::unCurryName 
                            (SPECTOLISP::printPackageId (car (cdr pV7504)) dpn) 
                            i)) 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (|!t|) 
                              (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                           args))) 
                        '(:|None|)))))) 
           (if (eq (car term) :|Apply|) 
               (let ((pV7499 (cdr term))) 
                 (return 
                  (aux 
                   (svref pV7499 0) 
                   (INTEGER-SPEC::|!+| i 1) 
                   (LIST-SPEC::|!cons| (svref pV7499 1) args)))))) 
       (return '(:|None|))))) (aux term 0 nil)))
                                                
(defun SPECENVIRONMENT::arrow (sp srt) 
  (let ((pV7051 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7051) :|Arrow|) 
         (let ((pV7052 (cdr pV7051))) 
           (return (cons (svref pV7052 0) (svref pV7052 1))))) 
     (return (SYSTEM-SPEC::fail "Could not get function space sort")))))
                                                                        
(defun SPECENVIRONMENT::domain (sp srt) 
  (let ((pV7076 (SPECENVIRONMENT::arrow sp srt))) 
    (block 
     nil 
     (return (car pV7076)) 
     (error "Nonexhaustive match failure in domain"))))
                                                       
(defun SPECENVIRONMENT::range (sp srt) 
  (let ((pV7191 (SPECENVIRONMENT::arrow sp srt))) 
    (block 
     nil 
     (return (cdr pV7191)) 
     (error "Nonexhaustive match failure in range"))))
                                                      
(defparameter SPECTOLISP::compareSymbols (LISTADT::mkLOp "eq"))
                                                               
(defun SPECTOLISP::isConsDataType (sp srt) 
  (labels 
    ((isTwoTuple (srt) 
      (let ((pV7577 (SPECENVIRONMENT::stripSubsorts sp srt))) 
        (block 
         nil 
         (if (eq (car pV7577) :|Product|) 
             (let ((pV7579 (car (cdr pV7577)))) 
               (if (consp pV7579) 
                   (let ((pV7583 (cdr pV7579))) 
                     (if (consp pV7583) (if (null (cdr pV7583)) (return t))))))) 
         (return nil))))) 
    (let ((pV7592 (SPECENVIRONMENT::stripSubsorts sp srt))) 
      (block 
       nil 
       (if (eq (car pV7592) :|CoProduct|) 
           (let ((pV7594 (car (cdr pV7592)))) 
             (if (consp pV7594) 
                 (let ((pV7598 (cdr pV7594))
                       (pV7597 (car pV7594))) 
                   (let ((pV7600 (cdr pV7597))
                         (pV7599 (car pV7597))) 
                     (progn (if (string=  "None" pV7599) 
                                (if (eq (car pV7600) :|None|) 
                                    (if (consp pV7598) 
                                        (let ((pV7614 (car pV7598))) 
                                          (if (string=  "Some" (car pV7614)) 
                                              (if (eq (car (cdr pV7614)) :|Some|) 
                                                  (if (null (cdr pV7598)) 
                                                      (return '(:|None|))))))))) 
                            (if (eq (car pV7600) :|None|) 
                                (if (consp pV7598) 
                                    (let ((pV7608 (car pV7598))) 
                                      (let ((pV7611 (cdr pV7608))) 
                                        (if (eq (car pV7611) :|Some|) 
                                            (if (null (cdr pV7598)) 
                                                (return 
                                                 (if (isTwoTuple (cdr pV7611)) 
                                                     (cons 
                                                      :|Some| 
                                                      (cons pV7599 (car pV7608))) 
                                                     '(:|None|)))))))) 
                                (if (eq (car pV7600) :|Some|) 
                                    (if (consp pV7598) 
                                        (let ((pV7603 (car pV7598))) 
                                          (if (eq (car (cdr pV7603)) :|None|) 
                                              (if (null (cdr pV7598)) 
                                                  (return 
                                                   (if (isTwoTuple (cdr pV7600)) 
                                                       (cons 
                                                        :|Some| 
                                                        (cons 
                                                         (car pV7603) 
                                                         pV7599)) 
                                                       '(:|None|))))))))))))))) 
       (return '(:|None|))))))
                              
(defun SPECTOLISP::hasConsDomain (sp id srt) 
  (let ((pV7557 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7557) :|Arrow|) 
         (return 
          (let ((pV7552 (SPECTOLISP::isConsDataType sp (svref (cdr pV7557) 0)))) 
            (block 
             nil 
             (if (eq (car pV7552) :|Some|) 
                 (return 
                  (cons 
                   :|Some| 
                   (if (string=  id (car (cdr pV7552))) "null" "consp"))) 
                 (if (eq (car pV7552) :|None|) (return '(:|None|)))) 
             (error "Nonexhaustive match failure in hasConsDomain"))))) 
     (return '(:|None|)))))
                           
(defun SPECTOLISP::isConsIdentifier (sp id srt) 
  (let ((pV7619 (SPECTOLISP::isConsDataType sp srt))) 
    (block 
     nil 
     (if (eq (car pV7619) :|Some|) 
         (return 
          (cons :|Some| (if (string=  id (car (cdr pV7619))) "null" "consp"))) 
         (if (eq (car pV7619) :|None|) (return '(:|None|)))) 
     (error "Nonexhaustive match failure in isConsIdentifier"))))
                                                                 
(defun SPECTOLISP::isPairProjection (sp srt id) 
  (let ((pV7644 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7644) :|Arrow|) 
         (return 
          (let ((pV7629 (SPECENVIRONMENT::unfoldBase sp (svref (cdr pV7644) 0)))) 
            (block 
             nil 
             (if (eq (car pV7629) :|Product|) 
                 (let ((pV7631 (car (cdr pV7629)))) 
                   (if (consp pV7631) 
                       (let ((pV7635 (cdr pV7631))) 
                         (if (consp pV7635) 
                             (if (null (cdr pV7635)) 
                                 (return 
                                  (if (string=  (car (car pV7631)) id) 
                                      (cons :|Some| "car") 
                                      (cons :|Some| "cdr"))))))))) 
             (return '(:|None|)))))) 
     (return '(:|None|)))))
                           
(defun SPECTOLISP::unaryName (nm) (STRING-SPEC::^ nm "-1"))
                                                           
(defun SPECTOLISP::mkLApplyArity (id arity vars args) 
  (let ((rator 
         (if (STRINGSET::|!member| vars id) 
             (LISTADT::mkLVar id) 
             (block 
              nil 
              (if (eq (car arity) :|Some|) 
                  (return 
                   (if ( =  (LIST-SPEC::|!length| args) 1) 
                       (LISTADT::mkLOp (SPECTOLISP::unaryName id)) 
                       (LISTADT::mkLOp id)))) 
              (return (LISTADT::mkLOp id)))))) (LISTADT::mkLApply rator args)))
                                                                               
(defun SPECTOLISP::mkLEqualityOp (sp srt) 
  (let ((pV7758 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7758) :|Arrow|) 
         (return 
          (let ((pV7745 (SPECENVIRONMENT::unfoldBase sp (svref (cdr pV7758) 0)))) 
            (block 
             nil 
             (if (eq (car pV7745) :|Product|) 
                 (let ((pV7747 (car (cdr pV7745)))) 
                   (if (consp pV7747) 
                       (let ((pV7751 (cdr pV7747))) 
                         (let ((pV7753 (cdr (car pV7747)))) 
                           (if (consp pV7751) 
                               (if (null (cdr pV7751)) 
                                   (return 
                                    (if (METASLANG::natSort? pV7753) 
                                        " = " 
                                        (let ((pV7736 
                                               (SPECENVIRONMENT::stripSubsorts 
                                                sp 
                                                pV7753))) 
                                          (block 
                                           nil 
                                           (if (eq (car pV7736) :|Base|) 
                                               (let ((pV7738 
                                                      (svref (cdr pV7736) 0))) 
                                                 (if (eq 
                                                      (car pV7738) 
                                                      :|Qualified|) 
                                                     (let ((pV7741 (cdr pV7738))) 
                                                       (let ((pV7743 
                                                              (cdr pV7741))
                                                             (pV7742 
                                                              (car pV7741))) 
                                                         (if (string=  
                                                              "Boolean" 
                                                              pV7742) 
                                                             (if (string=  
                                                                  "Boolean" 
                                                                  pV7743) 
                                                                 (return "eq")) 
                                                             (if (string=  
                                                                  "Nat" 
                                                                  pV7742) 
                                                                 (if (string=  
                                                                      "Nat" 
                                                                      pV7743) 
                                                                     (return 
                                                                      " = ")) 
                                                                 (if (string=  
                                                                      "Integer" 
                                                                      pV7742) 
                                                                     (if (string=  
                                                                          "Integer" 
                                                                          pV7743) 
                                                                         (return 
                                                                          " = ")) 
                                                                     (if (string=  
                                                                          "String" 
                                                                          pV7742) 
                                                                         (if (string=  
                                                                              "String" 
                                                                              pV7743) 
                                                                             (return 
                                                                              "string= ")) 
                                                                         (if (string=  
                                                                              "Char" 
                                                                              pV7742) 
                                                                             (if (string=  
                                                                                  "Char" 
                                                                                  pV7743) 
                                                                                 (return 
                                                                                  "eq")))))))))))) 
                                           (return 
                                            "slang-built-in::slang-term-equals")))))))))))) 
             (return "slang-built-in::slang-term-equals"))))) 
     (return "slang-built-in::slang-term-equals"))))
                                                    
(defun SPECTOLISP::mkLTermList (sp dpn vars term) 
  (block 
   nil 
   (if (eq (car term) :|Record|) 
       (return 
        (LIST-SPEC::|!map|-1-1 
         #'(lambda (x) (SPECTOLISP::mkLTerm sp dpn vars (cdr x))) 
         (car (cdr term))))) 
   (return (cons (SPECTOLISP::mkLTerm sp dpn vars term) nil))))
                                                               
(defun SPECTOLISP::mkLUnaryFnRef (id arity vars) 
  (if (STRINGSET::|!member| vars id) 
      (LISTADT::mkLVar id) 
      (block 
       nil 
       (if (eq (car arity) :|Some|) 
           (return (LISTADT::mkLOp (SPECTOLISP::unaryName id)))) 
       (return (LISTADT::mkLOp id)))))
                                      
(defun SPECTOLISP::opArity (sp idf srt) 
  (let ((pV8072 (ARITYNORMALIZE::sortArity sp srt))) 
    (block 
     nil 
     (if (eq (car pV8072) :|None|) (return '(:|None|))) 
     (return 
      (if (ARITYNORMALIZE::polymorphicDomainOp? sp idf) '(:|None|) pV8072)))))
                                                                              
(defun SPECTOLISP::ith (n id ids) 
  (block 
   nil 
   (if (null ids) 
       (return (SYSTEM-SPEC::fail (STRING-SPEC::|!++| "No such index " id))) 
       (if (consp ids) 
           (return 
            (if (string=  id (car (car ids))) 
                n 
                (SPECTOLISP::ith (INTEGER-SPEC::|!+| n 1) id (cdr ids)))))) 
   (error "Nonexhaustive match failure in ith")))
                                                 
(defun SPECTOLISP::projectionIndex (sp id srt) 
  (let ((pV8109 (SPECENVIRONMENT::arrow sp srt))) 
    (block 
     nil 
     (return 
      (let ((row (SPECENVIRONMENT::product sp (car pV8109)))) 
        (SPECTOLISP::ith 0 id row))) 
     (error "Nonexhaustive match failure in projectionIndex"))))
                                                                
(defun SPECTOLISP::mkLTermOp (sp dpn vars termOp optArgs) 
  (let ((pV8034 (svref termOp 1))
        (pV8033 (svref termOp 0))) 
    (block 
     nil 
     (if (eq (car pV8033) :|Project|) 
         (let ((pV8044 (cdr pV8033))) 
           (return 
            (let ((pV7906 (SPECTOLISP::isPairProjection sp pV8034 pV8044))) 
              (block 
               nil 
               (if (eq (car pV7906) :|Some|) 
                   (let ((pV7908 (cdr pV7906))) 
                     (if (eq (car optArgs) :|None|) 
                         (return 
                          (LISTADT::mkLLambda 
                           (cons "!x" nil) 
                           nil 
                           (LISTADT::mkLApply 
                            (LISTADT::mkLOp pV7908) 
                            (cons (LISTADT::mkLVar "!x") nil)))) 
                         (if (eq (car optArgs) :|Some|) 
                             (return 
                              (LISTADT::mkLApply 
                               (LISTADT::mkLOp pV7908) 
                               (cons 
                                (SPECTOLISP::mkLTerm sp dpn vars (cdr optArgs)) 
                                nil)))))) 
                   (if (eq (car pV7906) :|None|) 
                       (if (eq (car optArgs) :|Some|) 
                           (return 
                            (let ((id 
                                   (SPECTOLISP::projectionIndex sp pV8044 pV8034))) 
                              (LISTADT::mkLApply 
                               (LISTADT::mkLOp "svref") 
                               (cons 
                                (SPECTOLISP::mkLTerm sp dpn vars (cdr optArgs)) 
                                (cons (LISTADT::mkLNat id) nil))))) 
                           (if (eq (car optArgs) :|None|) 
                               (return 
                                (let ((id 
                                       (SPECTOLISP::projectionIndex 
                                        sp 
                                        pV8044 
                                        pV8034))) 
                                  (LISTADT::mkLLambda 
                                   (cons "!x" nil) 
                                   nil 
                                   (LISTADT::mkLApply 
                                    (LISTADT::mkLOp "svref") 
                                    (cons 
                                     (LISTADT::mkLVar "!x") 
                                     (cons (LISTADT::mkLNat id) nil)))))))))) 
               (error "Nonexhaustive match failure in mkLTermOp"))))) 
         (if (eq (car pV8033) :|Equals|) 
             (return 
              (let ((oper (LISTADT::mkLOp (SPECTOLISP::mkLEqualityOp sp pV8034)))) 
                (block 
                 nil 
                 (if (eq (car optArgs) :|None|) 
                     (return oper) 
                     (if (eq (car optArgs) :|Some|) 
                         (return 
                          (LISTADT::mkLApply 
                           oper 
                           (SPECTOLISP::mkLTermList sp dpn vars (cdr optArgs)))))) 
                 (error "Nonexhaustive match failure in mkLTermOp")))) 
             (if (eq (car pV8033) :|Select|) 
                 (return 
                  (let ((pV7915 
                         (SPECTOLISP::hasConsDomain sp (cdr pV8033) pV8034))) 
                    (block 
                     nil 
                     (if (eq (car pV7915) :|Some|) 
                         (if (eq (car optArgs) :|None|) 
                             (return 
                              (LISTADT::mkLLambda 
                               (cons "!x" nil) 
                               nil 
                               (LISTADT::mkLVar "!x"))) 
                             (if (eq (car optArgs) :|Some|) 
                                 (return 
                                  (SPECTOLISP::mkLTerm sp dpn vars (cdr optArgs))))) 
                         (if (eq (car pV7915) :|None|) 
                             (if (eq (car optArgs) :|None|) 
                                 (return (LISTADT::mkLOp "cdr")) 
                                 (if (eq (car optArgs) :|Some|) 
                                     (return 
                                      (LISTADT::mkLApply 
                                       (LISTADT::mkLOp "cdr") 
                                       (cons 
                                        (SPECTOLISP::mkLTerm 
                                         sp 
                                         dpn 
                                         vars 
                                         (cdr optArgs)) 
                                        nil))))))) 
                     (error "Nonexhaustive match failure in mkLTermOp")))) 
                 (if (eq (car pV8033) :|Embedded|) 
                     (let ((pV8042 (cdr pV8033))) 
                       (return 
                        (let ((dom (SPECENVIRONMENT::domain sp pV8034))) 
                          (let ((pV7921 
                                 (SPECTOLISP::isConsIdentifier sp pV8042 dom))) 
                            (block 
                             nil 
                             (if (eq (car pV7921) :|Some|) 
                                 (let ((pV7923 (cdr pV7921))) 
                                   (if (eq (car optArgs) :|None|) 
                                       (return 
                                        (LISTADT::mkLLambda 
                                         (cons "!x" nil) 
                                         nil 
                                         (LISTADT::mkLApply 
                                          (LISTADT::mkLOp pV7923) 
                                          (cons (LISTADT::mkLVar "!x") nil)))) 
                                       (if (eq (car optArgs) :|Some|) 
                                           (return 
                                            (LISTADT::mkLApply 
                                             (LISTADT::mkLOp pV7923) 
                                             (cons 
                                              (SPECTOLISP::mkLTerm 
                                               sp 
                                               dpn 
                                               vars 
                                               (cdr optArgs)) 
                                              nil)))))) 
                                 (if (eq (car pV7921) :|None|) 
                                     (if (eq (car optArgs) :|None|) 
                                         (return 
                                          (LISTADT::mkLLambda 
                                           (cons "!x" nil) 
                                           nil 
                                           (LISTADT::mkLApply 
                                            SPECTOLISP::compareSymbols 
                                            (cons 
                                             (LISTADT::mkLApply 
                                              (LISTADT::mkLOp "car") 
                                              (cons (LISTADT::mkLVar "!x") nil)) 
                                             (cons 
                                              (LISTADT::mkLIntern pV8042) 
                                              nil))))) 
                                         (if (eq (car optArgs) :|Some|) 
                                             (return 
                                              (LISTADT::mkLApply 
                                               SPECTOLISP::compareSymbols 
                                               (cons 
                                                (LISTADT::mkLApply 
                                                 (LISTADT::mkLOp "car") 
                                                 (cons 
                                                  (SPECTOLISP::mkLTerm 
                                                   sp 
                                                   dpn 
                                                   vars 
                                                   (cdr optArgs)) 
                                                  nil)) 
                                                (cons 
                                                 (LISTADT::mkLIntern pV8042) 
                                                 nil)))))))) 
                             (error "Nonexhaustive match failure in mkLTermOp")))))) 
                     (if (eq (car pV8033) :|Nat|) 
                         (return (LISTADT::mkLInt (cdr pV8033))) 
                         (if (eq (car pV8033) :|String|) 
                             (return (LISTADT::mkLString (cdr pV8033))) 
                             (if (eq (car pV8033) :|Bool|) 
                                 (return (LISTADT::mkLBool (cdr pV8033))) 
                                 (if (eq (car pV8033) :|Char|) 
                                     (return (LISTADT::mkLChar (cdr pV8033))) 
                                     (if (eq (car pV8033) :|Op|) 
                                         (let ((pV8047 (car (cdr pV8033)))) 
                                           (progn (if (eq 
                                                       (car pV8047) 
                                                       :|Qualified|) 
                                                      (let ((pV8055 (cdr pV8047))) 
                                                        (if (string=  
                                                             "Boolean" 
                                                             (car pV8055)) 
                                                            (if (string=  
                                                                 "&" 
                                                                 (cdr pV8055)) 
                                                                (return 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        optArgs) 
                                                                       :|Some|) 
                                                                      (let ((pV7936 
                                                                             (cdr 
                                                                              optArgs))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV7936) 
                                                                             :|Record|) 
                                                                            (let ((pV7938 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV7936)))) 
                                                                              (if (consp 
                                                                                   pV7938) 
                                                                                  (let ((pV7942 
                                                                                         (cdr 
                                                                                          pV7938))) 
                                                                                    (if (consp 
                                                                                         pV7942) 
                                                                                        (if (null 
                                                                                             (cdr 
                                                                                              pV7942)) 
                                                                                            (return 
                                                                                             (LISTADT::mkLApply 
                                                                                              (LISTADT::mkLOp 
                                                                                               "lisp::and") 
                                                                                              (cons 
                                                                                               (SPECTOLISP::mkLTerm 
                                                                                                sp 
                                                                                                dpn 
                                                                                                vars 
                                                                                                (cdr 
                                                                                                 (car 
                                                                                                  pV7938))) 
                                                                                               (cons 
                                                                                                (SPECTOLISP::mkLTerm 
                                                                                                 sp 
                                                                                                 dpn 
                                                                                                 vars 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV7942))) 
                                                                                                nil))))))))))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            optArgs) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (LISTADT::mkLOp 
                                                                            (SPECTOLISP::printPackageId 
                                                                             pV8047 
                                                                             dpn))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in mkLTermOp"))))))) 
                                                  (if (eq 
                                                       (car pV8047) 
                                                       :|Qualified|) 
                                                      (let ((pV8052 (cdr pV8047))) 
                                                        (if (string=  
                                                             "Boolean" 
                                                             (car pV8052)) 
                                                            (if (string=  
                                                                 "or" 
                                                                 (cdr pV8052)) 
                                                                (return 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        optArgs) 
                                                                       :|Some|) 
                                                                      (let ((pV7956 
                                                                             (cdr 
                                                                              optArgs))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV7956) 
                                                                             :|Record|) 
                                                                            (let ((pV7958 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV7956)))) 
                                                                              (if (consp 
                                                                                   pV7958) 
                                                                                  (let ((pV7962 
                                                                                         (cdr 
                                                                                          pV7958))) 
                                                                                    (if (consp 
                                                                                         pV7962) 
                                                                                        (if (null 
                                                                                             (cdr 
                                                                                              pV7962)) 
                                                                                            (return 
                                                                                             (LISTADT::mkLApply 
                                                                                              (LISTADT::mkLOp 
                                                                                               "lisp::or") 
                                                                                              (cons 
                                                                                               (SPECTOLISP::mkLTerm 
                                                                                                sp 
                                                                                                dpn 
                                                                                                vars 
                                                                                                (cdr 
                                                                                                 (car 
                                                                                                  pV7958))) 
                                                                                               (cons 
                                                                                                (SPECTOLISP::mkLTerm 
                                                                                                 sp 
                                                                                                 dpn 
                                                                                                 vars 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV7962))) 
                                                                                                nil))))))))))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            optArgs) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (LISTADT::mkLOp 
                                                                            (SPECTOLISP::printPackageId 
                                                                             pV8047 
                                                                             dpn))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in mkLTermOp"))))))) 
                                                  (if (eq 
                                                       (car pV8047) 
                                                       :|Qualified|) 
                                                      (let ((pV8049 (cdr pV8047))) 
                                                        (if (string=  
                                                             "Boolean" 
                                                             (car pV8049)) 
                                                            (if (string=  
                                                                 " =>" 
                                                                 (cdr pV8049)) 
                                                                (return 
                                                                 (block 
                                                                  nil 
                                                                  (if (eq 
                                                                       (car 
                                                                        optArgs) 
                                                                       :|Some|) 
                                                                      (let ((pV7976 
                                                                             (cdr 
                                                                              optArgs))) 
                                                                        (if (eq 
                                                                             (car 
                                                                              pV7976) 
                                                                             :|Record|) 
                                                                            (let ((pV7978 
                                                                                   (car 
                                                                                    (cdr 
                                                                                     pV7976)))) 
                                                                              (if (consp 
                                                                                   pV7978) 
                                                                                  (let ((pV7982 
                                                                                         (cdr 
                                                                                          pV7978))) 
                                                                                    (if (consp 
                                                                                         pV7982) 
                                                                                        (if (null 
                                                                                             (cdr 
                                                                                              pV7982)) 
                                                                                            (return 
                                                                                             (LISTADT::mkLApply 
                                                                                              (LISTADT::mkLOp 
                                                                                               "lisp::or") 
                                                                                              (cons 
                                                                                               (LISTADT::mkLApply 
                                                                                                (LISTADT::mkLOp 
                                                                                                 "lisp::not") 
                                                                                                (cons 
                                                                                                 (SPECTOLISP::mkLTerm 
                                                                                                  sp 
                                                                                                  dpn 
                                                                                                  vars 
                                                                                                  (cdr 
                                                                                                   (car 
                                                                                                    pV7978))) 
                                                                                                 nil)) 
                                                                                               (cons 
                                                                                                (SPECTOLISP::mkLTerm 
                                                                                                 sp 
                                                                                                 dpn 
                                                                                                 vars 
                                                                                                 (cdr 
                                                                                                  (car 
                                                                                                   pV7982))) 
                                                                                                nil))))))))))) 
                                                                      (if (eq 
                                                                           (car 
                                                                            optArgs) 
                                                                           :|None|) 
                                                                          (return 
                                                                           (LISTADT::mkLOp 
                                                                            (SPECTOLISP::printPackageId 
                                                                             pV8047 
                                                                             dpn))))) 
                                                                  (error 
                                                                   "Nonexhaustive match failure in mkLTermOp"))))))) 
                                                  (return 
                                                   (let ((pid 
                                                          (SPECTOLISP::printPackageId 
                                                           pV8047 
                                                           dpn))) 
                                                     (let ((arity 
                                                            (SPECTOLISP::opArity 
                                                             sp 
                                                             pV8047 
                                                             pV8034))) 
                                                       (block 
                                                        nil 
                                                        (if (eq 
                                                             (car optArgs) 
                                                             :|None|) 
                                                            (return 
                                                             (if (SPECTOLISP::functionSort? 
                                                                  sp 
                                                                  pV8034) 
                                                                 (SPECTOLISP::mkLUnaryFnRef 
                                                                  pid 
                                                                  arity 
                                                                  vars) 
                                                                 (cons 
                                                                  :|Const| 
                                                                  (cons 
                                                                   :|Parameter| 
                                                                   pid)))) 
                                                            (if (eq 
                                                                 (car optArgs) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (SPECTOLISP::mkLApplyArity 
                                                                  pid 
                                                                  arity 
                                                                  vars 
                                                                  (SPECTOLISP::mkLTermList 
                                                                   sp 
                                                                   dpn 
                                                                   vars 
                                                                   (cdr optArgs)))))) 
                                                        (error 
                                                         "Nonexhaustive match failure in mkLTermOp"))))))) 
                                         (if (eq (car pV8033) :|Embed|) 
                                             (let ((pV8036 (cdr pV8033))) 
                                               (let ((pV8046 (cdr pV8036))
                                                     (pV8045 (car pV8036))) 
                                                 (if (eq t pV8046) 
                                                     (return 
                                                      (let ((rng 
                                                             (SPECENVIRONMENT::range 
                                                              sp 
                                                              pV8034))) 
                                                        (let ((pV8000 
                                                               (SPECTOLISP::isConsDataType 
                                                                sp 
                                                                rng))) 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car pV8000) 
                                                                :|Some|) 
                                                               (return 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car 
                                                                       optArgs) 
                                                                      :|None|) 
                                                                     (return 
                                                                      (LISTADT::mkLLambda 
                                                                       (cons 
                                                                        "!x" 
                                                                        nil) 
                                                                       nil 
                                                                       (LISTADT::mkLVar 
                                                                        "!x"))) 
                                                                     (if (eq 
                                                                          (car 
                                                                           optArgs) 
                                                                          :|Some|) 
                                                                         (return 
                                                                          (SPECTOLISP::mkLTerm 
                                                                           sp 
                                                                           dpn 
                                                                           vars 
                                                                           (cdr 
                                                                            optArgs))))) 
                                                                 (error 
                                                                  "Nonexhaustive match failure in mkLTermOp"))) 
                                                               (if (eq 
                                                                    (car pV8000) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (let ((id 
                                                                           (LISTADT::mkLIntern 
                                                                            pV8045))) 
                                                                      (block 
                                                                       nil 
                                                                       (if (eq 
                                                                            (car 
                                                                             optArgs) 
                                                                            :|None|) 
                                                                           (return 
                                                                            (LISTADT::mkLLambda 
                                                                             (cons 
                                                                              "!x" 
                                                                              nil) 
                                                                             nil 
                                                                             (LISTADT::mkLApply 
                                                                              (LISTADT::mkLOp 
                                                                               "cons") 
                                                                              (cons 
                                                                               id 
                                                                               (cons 
                                                                                (LISTADT::mkLVar 
                                                                                 "!x") 
                                                                                nil))))) 
                                                                           (if (eq 
                                                                                (car 
                                                                                 optArgs) 
                                                                                :|Some|) 
                                                                               (return 
                                                                                (LISTADT::mkLApply 
                                                                                 (LISTADT::mkLOp 
                                                                                  "cons") 
                                                                                 (cons 
                                                                                  id 
                                                                                  (cons 
                                                                                   (SPECTOLISP::mkLTerm 
                                                                                    sp 
                                                                                    dpn 
                                                                                    vars 
                                                                                    (cdr 
                                                                                     optArgs)) 
                                                                                   nil)))))) 
                                                                       (error 
                                                                        "Nonexhaustive match failure in mkLTermOp")))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in mkLTermOp"))))) 
                                                     (if (eq nil pV8046) 
                                                         (return 
                                                          (let ((pV8004 
                                                                 (SPECTOLISP::isConsDataType 
                                                                  sp 
                                                                  pV8034))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV8004) 
                                                                  :|Some|) 
                                                                 (return 
                                                                  (LISTADT::mkLBool 
                                                                   nil)) 
                                                                 (if (eq 
                                                                      (car 
                                                                       pV8004) 
                                                                      :|None|) 
                                                                     (return 
                                                                      (LISTADT::mkLApply 
                                                                       (LISTADT::mkLOp 
                                                                        "list") 
                                                                       (cons 
                                                                        (LISTADT::mkLIntern 
                                                                         pV8045) 
                                                                        nil))))) 
                                                             (error 
                                                              "Nonexhaustive match failure in mkLTermOp")))))))) 
                                             (if (eq (car pV8033) :|Quotient|) 
                                                 (return 
                                                  (let ((dom 
                                                         (SPECENVIRONMENT::range 
                                                          sp 
                                                          pV8034))) 
                                                    (let ((pV8011 
                                                           (SPECENVIRONMENT::unfoldBase 
                                                            sp 
                                                            dom))) 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV8011) 
                                                            :|Quotient|) 
                                                           (return 
                                                            (let ((equiv 
                                                                   (SPECTOLISP::mkLTerm 
                                                                    sp 
                                                                    dpn 
                                                                    vars 
                                                                    (svref 
                                                                     (cdr pV8011) 
                                                                     1)))) 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car optArgs) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (LISTADT::mkLApply 
                                                                     (LISTADT::mkLOp 
                                                                      "slang-built-in::quotient") 
                                                                     (cons 
                                                                      equiv 
                                                                      nil))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         optArgs) 
                                                                        :|Some|) 
                                                                       (return 
                                                                        (LISTADT::mkLApply 
                                                                         (LISTADT::mkLApply 
                                                                          (LISTADT::mkLOp 
                                                                           "slang-built-in::quotient") 
                                                                          (cons 
                                                                           equiv 
                                                                           nil)) 
                                                                         (cons 
                                                                          (SPECTOLISP::mkLTerm 
                                                                           sp 
                                                                           dpn 
                                                                           vars 
                                                                           (cdr 
                                                                            optArgs)) 
                                                                          nil))))) 
                                                               (error 
                                                                "Nonexhaustive match failure in mkLTermOp"))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in mkLTermOp"))))) 
                                                 (if (eq (car pV8033) :|Choose|) 
                                                     (return 
                                                      (let ((srt1 
                                                             (SPECENVIRONMENT::range 
                                                              sp 
                                                              pV8034))) 
                                                        (let ((dom 
                                                               (SPECENVIRONMENT::domain 
                                                                sp 
                                                                srt1))) 
                                                          (let ((pV8021 
                                                                 (SPECENVIRONMENT::unfoldBase 
                                                                  sp 
                                                                  dom))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV8021) 
                                                                  :|Quotient|) 
                                                                 (return 
                                                                  (let ((equiv 
                                                                         (SPECTOLISP::mkLTerm 
                                                                          sp 
                                                                          dpn 
                                                                          vars 
                                                                          (svref 
                                                                           (cdr 
                                                                            pV8021) 
                                                                           1)))) 
                                                                    (block 
                                                                     nil 
                                                                     (if (eq 
                                                                          (car 
                                                                           optArgs) 
                                                                          :|None|) 
                                                                         (return 
                                                                          (LISTADT::mkLApply 
                                                                           (LISTADT::mkLOp 
                                                                            "slang-built-in::choose") 
                                                                           (cons 
                                                                            equiv 
                                                                            nil))) 
                                                                         (if (eq 
                                                                              (car 
                                                                               optArgs) 
                                                                              :|Some|) 
                                                                             (return 
                                                                              (LISTADT::mkLApply 
                                                                               (LISTADT::mkLApply 
                                                                                (LISTADT::mkLOp 
                                                                                 "slang-built-in::choose") 
                                                                                (cons 
                                                                                 equiv 
                                                                                 nil)) 
                                                                               (cons 
                                                                                (SPECTOLISP::mkLTerm 
                                                                                 sp 
                                                                                 dpn 
                                                                                 vars 
                                                                                 (cdr 
                                                                                  optArgs)) 
                                                                                nil))))) 
                                                                     (error 
                                                                      "Nonexhaustive match failure in mkLTermOp"))))) 
                                                             (error 
                                                              "Nonexhaustive match failure in mkLTermOp")))))) 
                                                     (if (eq 
                                                          (car pV8033) 
                                                          :|Restrict|) 
                                                         (return 
                                                          (block 
                                                           nil 
                                                           (if (eq 
                                                                (car optArgs) 
                                                                :|None|) 
                                                               (return 
                                                                (LISTADT::mkLLambda 
                                                                 (cons "!x" nil) 
                                                                 nil 
                                                                 (LISTADT::mkLVar 
                                                                  "!x"))) 
                                                               (if (eq 
                                                                    (car optArgs) 
                                                                    :|Some|) 
                                                                   (return 
                                                                    (SPECTOLISP::mkLTerm 
                                                                     sp 
                                                                     dpn 
                                                                     vars 
                                                                     (cdr 
                                                                      optArgs))))) 
                                                           (error 
                                                            "Nonexhaustive match failure in mkLTermOp"))) 
                                                         (if (eq 
                                                              (car pV8033) 
                                                              :|Relax|) 
                                                             (return 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car optArgs) 
                                                                    :|None|) 
                                                                   (return 
                                                                    (LISTADT::mkLLambda 
                                                                     (cons 
                                                                      "!x" 
                                                                      nil) 
                                                                     nil 
                                                                     (LISTADT::mkLVar 
                                                                      "!x"))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         optArgs) 
                                                                        :|Some|) 
                                                                       (return 
                                                                        (SPECTOLISP::mkLTerm 
                                                                         sp 
                                                                         dpn 
                                                                         vars 
                                                                         (cdr 
                                                                          optArgs))))) 
                                                               (error 
                                                                "Nonexhaustive match failure in mkLTermOp"))))))))))))))))) 
     (return (SYSTEM-SPEC::fail "Unexpected termOp")))))
                                                        
(defun SPECTOLISP::patternNames (pattern) 
  (block 
   nil 
   (if (eq (car pattern) :|VarPat|) 
       (return (cons (car (car (cdr pattern))) nil)) 
       (if (eq (car pattern) :|RecordPat|) 
           (return 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (x) (SPECTOLISP::patternName (cdr x))) 
             (car (cdr pattern)))))) 
   (return 
    (SYSTEM-SPEC::fail 
     (STRING-SPEC::^ 
      "SpecToLisp.patternNames " 
      (ANNSPECPRINTER::printPattern pattern))))))
                                                 
(defun STRINGSET::difference (x0 x) (SPLAYSET::difference x0 x))
                                                                
(defun SPECTOLISP::mkLTerm (sp dpn vars term) 
  (let ((pV7896 (SPECTOLISP::fullCurriedApplication sp dpn vars term))) 
    (block 
     nil 
     (if (eq (car pV7896) :|Some|) (return (cdr pV7896))) 
     (return 
      (block 
       nil 
       (if (eq (car term) :|Fun|) 
           (return (SPECTOLISP::mkLTermOp sp dpn vars (cdr term) '(:|None|))) 
           (if (eq (car term) :|Var|) 
               (return 
                (let ((id (SPECTOLISP::specId (car (car (cdr term)))))) 
                  (if (STRINGSET::|!member| vars id) 
                      (cons :|Var| id) 
                      (cons :|Op| id)))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV7830 (cdr term))) 
                     (return 
                      (let ((pV7766 (LISTPAIR::unzip (svref pV7830 0)))) 
                        (block 
                         nil 
                         (return 
                          (let ((names 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'SPECTOLISP::patternName 
                                  (car pV7766)))) 
                            (let ((names 
                                   (LIST-SPEC::|!map|-1-1 
                                    #'SPECTOLISP::specId 
                                    names))) 
                              (LISTADT::mkLLet 
                               names 
                               (LIST-SPEC::|!map|-1-1 
                                #'(lambda (|!t|) 
                                   (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                                (cdr pV7766)) 
                               (SPECTOLISP::mkLTerm 
                                sp 
                                dpn 
                                (STRINGSET::addList vars names) 
                                (svref pV7830 1)))))) 
                         (error "Nonexhaustive match failure in mkLTerm"))))) 
                   (if (eq (car term) :|LetRec|) 
                       (let ((pV7829 (cdr term))) 
                         (let ((pV7887 (svref pV7829 1))
                               (pV7886 (svref pV7829 0))) 
                           (return 
                            (labels 
                              ((unfold (decls names terms) 
                                (block 
                                 nil 
                                 (if (null decls) 
                                     (return (cons names terms)) 
                                     (if (consp decls) 
                                         (let ((pV7772 (car decls))) 
                                           (return 
                                            (unfold 
                                             (cdr decls) 
                                             (LIST-SPEC::|!cons| 
                                              (car pV7772) 
                                              names) 
                                             (LIST-SPEC::|!cons| 
                                              (cdr pV7772) 
                                              terms)))))) 
                                 (error "Nonexhaustive match failure in mkLTerm")))) 
                              (let ((pV7777 (unfold pV7886 nil nil))) 
                                (block 
                                 nil 
                                 (return 
                                  (let ((names 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) 
                                             (SPECTOLISP::specId (car x))) 
                                          (car pV7777)))) 
                                    (let ((vars 
                                           (STRINGSET::difference 
                                            vars 
                                            (STRINGSET::fromList names)))) 
                                      (LISTADT::mkLLetRec 
                                       names 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'(lambda (|!t|) 
                                           (SPECTOLISP::mkLTerm sp dpn vars |!t|)) 
                                        (cdr pV7777)) 
                                       (SPECTOLISP::mkLTerm sp dpn vars pV7887))))) 
                                 (error "Nonexhaustive match failure in mkLTerm"))))))) 
                       (if (eq (car term) :|Apply|) 
                           (let ((pV7828 (cdr term))) 
                             (let ((pV7851 (svref pV7828 2))
                                   (pV7850 (svref pV7828 1))
                                   (pV7849 (svref pV7828 0))) 
                               (progn (if (eq (car pV7850) :|Apply|) 
                                          (let ((pV7878 (cdr pV7850))) 
                                            (let ((pV7880 (svref pV7878 1))
                                                  (pV7879 (svref pV7878 0))) 
                                              (if (eq (car pV7879) :|Fun|) 
                                                  (let ((pV7883 
                                                         (svref (cdr pV7879) 0))) 
                                                    (if (eq 
                                                         (car pV7883) 
                                                         :|Restrict|) 
                                                        (return 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          vars 
                                                          (cons 
                                                           :|Apply| 
                                                           (vector 
                                                            pV7849 
                                                            pV7880 
                                                            pV7851)))) 
                                                        (if (eq 
                                                             (car pV7883) 
                                                             :|Relax|) 
                                                            (return 
                                                             (SPECTOLISP::mkLTerm 
                                                              sp 
                                                              dpn 
                                                              vars 
                                                              (cons 
                                                               :|Apply| 
                                                               (vector 
                                                                pV7849 
                                                                pV7880 
                                                                pV7851))))))))))) 
                                      (if (eq (car pV7849) :|Fun|) 
                                          (let ((pV7856 (svref (cdr pV7849) 0))) 
                                            (if (eq (car pV7856) :|Op|) 
                                                (let ((pV7860 (car (cdr pV7856)))) 
                                                  (if (eq 
                                                       (car pV7860) 
                                                       :|Qualified|) 
                                                      (let ((pV7862 (cdr pV7860))) 
                                                        (let ((pV7864 
                                                               (cdr pV7862))) 
                                                          (if (string=  
                                                               "TranslationBuiltIn" 
                                                               (car pV7862)) 
                                                              (if (string=  
                                                                   "block" 
                                                                   pV7864) 
                                                                  (return 
                                                                   (let ((terms 
                                                                          (SPECTOLISP::flattenFailWith 
                                                                           pV7850))) 
                                                                     (let ((terms 
                                                                            (LIST-SPEC::|!map|-1-1 
                                                                             #'(lambda (term1) 
                                                                                (SPECTOLISP::blockAtom 
                                                                                 sp 
                                                                                 dpn 
                                                                                 vars 
                                                                                 term1)) 
                                                                             terms))) 
                                                                       (LISTADT::mkLApply 
                                                                        (LISTADT::mkLOp 
                                                                         "block") 
                                                                        (LIST-SPEC::|!cons| 
                                                                         (cons 
                                                                          :|Const| 
                                                                          (cons 
                                                                           :|Boolean| 
                                                                           nil)) 
                                                                         terms))))) 
                                                                  (if (string=  
                                                                       "mkTuple" 
                                                                       pV7864) 
                                                                      (return 
                                                                       (SPECTOLISP::mkLTerm 
                                                                        sp 
                                                                        dpn 
                                                                        vars 
                                                                        pV7850)) 
                                                                      (if (string=  
                                                                           "mkApply" 
                                                                           pV7864) 
                                                                          (if (eq 
                                                                               (car 
                                                                                pV7850) 
                                                                               :|Record|) 
                                                                              (let ((pV7866 
                                                                                     (car 
                                                                                      (cdr 
                                                                                       pV7850)))) 
                                                                                (if (consp 
                                                                                     pV7866) 
                                                                                    (let ((pV7870 
                                                                                           (cdr 
                                                                                            pV7866))) 
                                                                                      (if (consp 
                                                                                           pV7870) 
                                                                                          (if (null 
                                                                                               (cdr 
                                                                                                pV7870)) 
                                                                                              (return 
                                                                                               (LISTADT::mkLApply 
                                                                                                (LISTADT::mkLOp 
                                                                                                 "apply") 
                                                                                                (cons 
                                                                                                 (SPECTOLISP::mkLTerm 
                                                                                                  sp 
                                                                                                  dpn 
                                                                                                  vars 
                                                                                                  (cdr 
                                                                                                   (car 
                                                                                                    pV7866))) 
                                                                                                 (cons 
                                                                                                  (SPECTOLISP::mkLTerm 
                                                                                                   sp 
                                                                                                   dpn 
                                                                                                   vars 
                                                                                                   (cdr 
                                                                                                    (car 
                                                                                                     pV7870))) 
                                                                                                  nil))))))))))))))))))))) 
                                      (if (eq (car pV7850) :|Record|) 
                                          (return 
                                           (block 
                                            nil 
                                            (if (eq (car pV7849) :|Fun|) 
                                                (return 
                                                 (SPECTOLISP::mkLTermOp 
                                                  sp 
                                                  dpn 
                                                  vars 
                                                  (cdr pV7849) 
                                                  (cons :|Some| pV7850)))) 
                                            (return 
                                             (let ((terms 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'(lambda (x) 
                                                        (SPECTOLISP::mkLTerm 
                                                         sp 
                                                         dpn 
                                                         vars 
                                                         (cdr x))) 
                                                     (car (cdr pV7850))))) 
                                               (LISTADT::mkLApply 
                                                (SPECTOLISP::mkLTerm 
                                                 sp 
                                                 dpn 
                                                 vars 
                                                 pV7849) 
                                                terms)))))) 
                                      (return 
                                       (block 
                                        nil 
                                        (if (eq (car pV7849) :|Fun|) 
                                            (return 
                                             (SPECTOLISP::mkLTermOp 
                                              sp 
                                              dpn 
                                              vars 
                                              (cdr pV7849) 
                                              (cons :|Some| pV7850))) 
                                            (if (eq (car pV7849) :|Var|) 
                                                (return 
                                                 (let ((id 
                                                        (SPECTOLISP::specId 
                                                         (car (car (cdr pV7849)))))) 
                                                   (if (STRINGSET::|!member| 
                                                        vars 
                                                        id) 
                                                       (LISTADT::mkLApply 
                                                        (SPECTOLISP::mkLTerm 
                                                         sp 
                                                         dpn 
                                                         vars 
                                                         pV7849) 
                                                        (cons 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          vars 
                                                          pV7850) 
                                                         nil)) 
                                                       (LISTADT::mkLApply 
                                                        (LISTADT::mkLOp id) 
                                                        (cons 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          vars 
                                                          pV7850) 
                                                         nil))))))) 
                                        (return 
                                         (LISTADT::mkLApply 
                                          (SPECTOLISP::mkLTerm 
                                           sp 
                                           dpn 
                                           vars 
                                           pV7849) 
                                          (cons 
                                           (SPECTOLISP::mkLTerm 
                                            sp 
                                            dpn 
                                            vars 
                                            pV7850) 
                                           nil)))))))) 
                           (if (eq (car term) :|Record|) 
                               (return 
                                (SPECTOLISP::mkLispTuple 
                                 (LIST-SPEC::|!map|-1-1 
                                  #'(lambda (x) 
                                     (SPECTOLISP::mkLTerm sp dpn vars (cdr x))) 
                                  (car (cdr term))))) 
                               (if (eq (car term) :|IfThenElse|) 
                                   (let ((pV7826 (cdr term))) 
                                     (return 
                                      (LISTADT::mkLIf 
                                       (SPECTOLISP::mkLTerm 
                                        sp 
                                        dpn 
                                        vars 
                                        (svref pV7826 0)) 
                                       (SPECTOLISP::mkLTerm 
                                        sp 
                                        dpn 
                                        vars 
                                        (svref pV7826 1)) 
                                       (SPECTOLISP::mkLTerm 
                                        sp 
                                        dpn 
                                        vars 
                                        (svref pV7826 2))))) 
                                   (if (eq (car term) :|Lambda|) 
                                       (let ((pV7835 (car (cdr term)))) 
                                         (if (consp pV7835) 
                                             (let ((pV7838 (car pV7835))) 
                                               (if (null (cdr pV7835)) 
                                                   (return 
                                                    (let ((names 
                                                           (SPECTOLISP::patternNames 
                                                            (svref pV7838 0)))) 
                                                      (let ((names 
                                                             (LIST-SPEC::|!map|-1-1 
                                                              #'SPECTOLISP::specId 
                                                              names))) 
                                                        (LISTADT::mkLLambda 
                                                         names 
                                                         nil 
                                                         (SPECTOLISP::mkLTerm 
                                                          sp 
                                                          dpn 
                                                          (STRINGSET::addList 
                                                           vars 
                                                           names) 
                                                          (svref pV7838 2)))))))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (return 
                                            (LISTADT::mkLSeq 
                                             (LIST-SPEC::|!map|-1-1 
                                              #'(lambda (|!t|) 
                                                 (SPECTOLISP::mkLTerm 
                                                  sp 
                                                  dpn 
                                                  vars 
                                                  |!t|)) 
                                              (car (cdr term)))))))))))))) 
       (return 
        (SYSTEM-SPEC::fail 
         (STRING-SPEC::^ "Unexpected term " (ANNSPECPRINTER::printTerm term)))))))))


(defun SPECTOLISP::lispTerm (sp dpn term) 
  (SPECTOLISP::reduceTerm (SPECTOLISP::mkLTerm sp dpn STRINGSET::empty term)))
                                                                              
(defun SPECTOLISP::renameDef? (term) 
  (block 
   nil 
   (if (eq (car term) :|Lambda|) 
       (let ((pV8184 (cdr term))) 
         (let ((pV8187 (svref pV8184 2))
               (pV8185 (svref pV8184 0))) 
           (if (consp pV8185) 
               (if (null (cdr pV8185)) 
                   (if (eq (car pV8187) :|Apply|) 
                       (let ((pV8191 (cdr pV8187))) 
                         (let ((pV8193 (cdr pV8191))
                               (pV8192 (car pV8191))) 
                           (if (eq (car pV8192) :|Op|) 
                               (if (consp pV8193) 
                                   (let ((pV8196 (car pV8193))) 
                                     (if (eq (car pV8196) :|Var|) 
                                         (if (null (cdr pV8193)) 
                                             (return 
                                              (if (string=  
                                                   (car pV8185) 
                                                   (cdr pV8196)) 
                                                  (cons :|Some| (cdr pV8192)) 
                                                  '(:|None|)))))))))))))))) 
   (return '(:|None|))))
                        
(defun SPECTOLISP::unCurryDef (term n) 
  (labels 
    ((auxUnCurryDef (term i params let_binds) 
      (if (INTEGER-SPEC::|!>| i n) 
          (cons 
           :|Some| 
           (SPECTOLISP::reduceTerm 
            (LISTADT::mkLLambda 
             params 
             nil 
             (LIST-SPEC::foldl-1-1-1 
              #'(lambda (x) 
                 (let ((pV8247 (car x))) 
                   (block 
                    nil 
                    (return (LISTADT::mkLLet (car pV8247) (cdr pV8247) (cdr x))) 
                    (error "Nonexhaustive match failure in unCurryDef")))) 
              term 
              let_binds)))) 
          (block 
           nil 
           (if (eq (car term) :|Lambda|) 
               (let ((pV8261 (cdr term))) 
                 (let ((pV8267 (svref pV8261 2))
                       (pV8265 (svref pV8261 0))) 
                   (return 
                    (block 
                     nil 
                     (if (consp pV8265) 
                         (if (null (cdr pV8265)) 
                             (return 
                              (auxUnCurryDef 
                               pV8267 
                               (INTEGER-SPEC::|!+| i 1) 
                               (LIST-SPEC::|!++| params pV8265) 
                               let_binds)))) 
                     (return 
                      (let ((newParam 
                             (STRING-SPEC::^ "!x" (NAT-SPEC::toString i)))) 
                        (auxUnCurryDef 
                         pV8267 
                         (INTEGER-SPEC::|!+| i 1) 
                         (LIST-SPEC::|!++| params (cons newParam nil)) 
                         (LIST-SPEC::|!++| 
                          (cons 
                           (cons 
                            pV8265 
                            (SPECTOLISP::nTupleDerefs 
                             (LIST-SPEC::|!length| pV8265) 
                             (LISTADT::mkLVar newParam))) 
                           nil) 
                          let_binds)))))))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV8260 (cdr term))) 
                     (return 
                      (auxUnCurryDef 
                       (svref pV8260 2) 
                       i 
                       params 
                       (LIST-SPEC::|!++| 
                        (cons (cons (svref pV8260 0) (svref pV8260 1)) nil) 
                        let_binds)))))) 
           (return '(:|None|)))))) (auxUnCurryDef term 1 nil nil)))
                                                                   
(defun SPECTOLISP::|!lisp|-1 (spc) 
  (progn (SPECTOLISP::initializeSpecId) 
         (let ((packages 
                (LIST-SPEC::|!map|-1-1 
                 #'SPECTOLISP::mkLPackageId 
                 (qualifiers (svref spc 1))))) 
           (let ((pV7713 
                  (block 
                   nil 
                   (if (consp packages) 
                       (return (cons (car packages) (cdr packages))) 
                       (if (null packages) 
                           (return (cons SPECTOLISP::defaultSpecwarePackage nil)))) 
                   (error "Nonexhaustive match failure in lisp")))) 
             (block 
              nil 
              (let ((pV7715 (cdr pV7713))
                    (pV7714 (car pV7713))) 
                (return 
                 (labels 
                   ((mkLOpDef (qname name decl defs) 
                     (let ((pV7708 (svref decl 3))) 
                       (block 
                        nil 
                        (let ((pV7710 (cdr (svref decl 2)))) 
                          (if (eq (car pV7708) :|Some|) 
                              (return 
                               (let ((term 
                                      (SPECTOLISP::lispTerm 
                                       spc 
                                       pV7714 
                                       (cdr pV7708)))) 
                                 (let ((name 
                                        (SPECTOLISP::printPackageId 
                                         (cons :|Qualified| (cons qname name)) 
                                         pV7714))) 
                                   (if (SPECTOLISP::functionSort? spc pV7710) 
                                       (LIST-SPEC::|!++| 
                                        (let ((pV7697 
                                               (ARITYNORMALIZE::sortArity 
                                                spc 
                                                pV7710))
                                              (pV7696 
                                               (SPECTOLISP::curryShapeNum 
                                                spc 
                                                pV7710))) 
                                          (block 
                                           nil 
                                           (if ( =  1 pV7696) 
                                               (if (eq (car pV7697) :|None|) 
                                                   (return 
                                                    (block 
                                                     nil 
                                                     (if (eq 
                                                          (car term) 
                                                          :|Lambda|) 
                                                         (return 
                                                          (cons 
                                                           (cons name term) 
                                                           nil))) 
                                                     (return 
                                                      (cons 
                                                       (cons 
                                                        name 
                                                        (LISTADT::mkLLambda 
                                                         (cons "!x" nil) 
                                                         nil 
                                                         (LISTADT::mkLApply 
                                                          term 
                                                          (cons 
                                                           (LISTADT::mkLVar "!x") 
                                                           nil)))) 
                                                       nil)))) 
                                                   (if (eq (car pV7697) :|Some|) 
                                                       (let ((pV7703 
                                                              (cdr (cdr pV7697)))) 
                                                         (return 
                                                          (let ((uName 
                                                                 (SPECTOLISP::unaryName 
                                                                  name))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car term) 
                                                                  :|Lambda|) 
                                                                 (return 
                                                                  (let ((n 
                                                                         (LIST-SPEC::|!length| 
                                                                          (svref 
                                                                           (cdr 
                                                                            term) 
                                                                           0)))) 
                                                                    (cons 
                                                                     (cons 
                                                                      name 
                                                                      (if ( =  
                                                                           n 
                                                                           pV7703) 
                                                                          term 
                                                                          (SPECTOLISP::defNaryByUnary 
                                                                           uName 
                                                                           pV7703))) 
                                                                     (cons 
                                                                      (cons 
                                                                       uName 
                                                                       (if ( =  
                                                                            n 
                                                                            pV7703) 
                                                                           (SPECTOLISP::defUnaryByNary 
                                                                            name 
                                                                            n) 
                                                                           term)) 
                                                                      nil))))) 
                                                             (return 
                                                              (cons 
                                                               (cons 
                                                                name 
                                                                (SPECTOLISP::defNaryByUnary 
                                                                 uName 
                                                                 pV7703)) 
                                                               (cons 
                                                                (cons 
                                                                 uName 
                                                                 (LISTADT::mkLLambda 
                                                                  (cons "!x" nil) 
                                                                  nil 
                                                                  (LISTADT::mkLApply 
                                                                   term 
                                                                   (cons 
                                                                    (LISTADT::mkLVar 
                                                                     "!x") 
                                                                    nil)))) 
                                                                nil)))))))))) 
                                           (if (eq (car pV7697) :|None|) 
                                               (return 
                                                (let ((ucName 
                                                       (SPECTOLISP::unCurryName 
                                                        name 
                                                        pV7696))) 
                                                  (let ((pV7682 
                                                         (SPECTOLISP::unCurryDef 
                                                          term 
                                                          pV7696))) 
                                                    (block 
                                                     nil 
                                                     (if (eq 
                                                          (car pV7682) 
                                                          :|Some|) 
                                                         (return 
                                                          (cons 
                                                           (cons 
                                                            name 
                                                            (SPECTOLISP::defCurryByUncurry 
                                                             ucName 
                                                             pV7696)) 
                                                           (cons 
                                                            (cons 
                                                             ucName 
                                                             (cdr pV7682)) 
                                                            nil)))) 
                                                     (return 
                                                      (cons 
                                                       (cons name term) 
                                                       (cons 
                                                        (cons 
                                                         ucName 
                                                         (let ((pV7680 
                                                                (SPECTOLISP::renameDef? 
                                                                 term))) 
                                                           (block 
                                                            nil 
                                                            (if (eq 
                                                                 (car pV7680) 
                                                                 :|Some|) 
                                                                (return 
                                                                 (SPECTOLISP::defAliasFn 
                                                                  (SPECTOLISP::unCurryName 
                                                                   (cdr pV7680) 
                                                                   pV7696) 
                                                                  pV7696))) 
                                                            (return 
                                                             (SPECTOLISP::defUncurryByUnary 
                                                              name 
                                                              pV7696))))) 
                                                        nil))))))) 
                                               (if (eq (car pV7697) :|Some|) 
                                                   (let ((pV7700 
                                                          (cdr (cdr pV7697)))) 
                                                     (return 
                                                      (let ((ucName 
                                                             (SPECTOLISP::unCurryName 
                                                              name 
                                                              pV7696))) 
                                                        (let ((uName 
                                                               (SPECTOLISP::unaryName 
                                                                name))) 
                                                          (let ((pV7694 
                                                                 (SPECTOLISP::unCurryDef 
                                                                  term 
                                                                  pV7696))) 
                                                            (block 
                                                             nil 
                                                             (if (eq 
                                                                  (car pV7694) 
                                                                  :|Some|) 
                                                                 (return 
                                                                  (cons 
                                                                   (cons 
                                                                    name 
                                                                    (SPECTOLISP::defNaryByUnary 
                                                                     uName 
                                                                     pV7700)) 
                                                                   (cons 
                                                                    (cons 
                                                                     uName 
                                                                     (SPECTOLISP::defCurryByUncurry 
                                                                      ucName 
                                                                      pV7696)) 
                                                                    (cons 
                                                                     (cons 
                                                                      ucName 
                                                                      (cdr 
                                                                       pV7694)) 
                                                                     nil))))) 
                                                             (return 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car term) 
                                                                    :|Lambda|) 
                                                                   (return 
                                                                    (let ((n 
                                                                           (LIST-SPEC::|!length| 
                                                                            (svref 
                                                                             (cdr 
                                                                              term) 
                                                                             0)))) 
                                                                      (cons 
                                                                       (cons 
                                                                        name 
                                                                        (if ( =  
                                                                             n 
                                                                             pV7700) 
                                                                            term 
                                                                            (SPECTOLISP::defNaryByUnary 
                                                                             uName 
                                                                             pV7700))) 
                                                                       (cons 
                                                                        (cons 
                                                                         uName 
                                                                         (if ( =  
                                                                              n 
                                                                              pV7700) 
                                                                             (SPECTOLISP::defUnaryByNary 
                                                                              name 
                                                                              n) 
                                                                             term)) 
                                                                        (cons 
                                                                         (cons 
                                                                          ucName 
                                                                          (SPECTOLISP::defUncurryByUnary 
                                                                           uName 
                                                                           pV7696)) 
                                                                         nil)))))) 
                                                               (return 
                                                                (cons 
                                                                 (cons 
                                                                  name 
                                                                  (SPECTOLISP::defNaryByUnary 
                                                                   uName 
                                                                   pV7700)) 
                                                                 (cons 
                                                                  (cons 
                                                                   uName 
                                                                   (LISTADT::mkLLambda 
                                                                    (cons 
                                                                     "!x" 
                                                                     nil) 
                                                                    nil 
                                                                    (LISTADT::mkLApply 
                                                                     term 
                                                                     (cons 
                                                                      (LISTADT::mkLVar 
                                                                       "!x") 
                                                                      nil)))) 
                                                                  (cons 
                                                                   (cons 
                                                                    ucName 
                                                                    (SPECTOLISP::defUncurryByUnary 
                                                                     uName 
                                                                     pV7696)) 
                                                                   nil)))))))))))))) 
                                           (error 
                                            "Nonexhaustive match failure in lisp"))) 
                                        defs) 
                                       (LIST-SPEC::|!cons| (cons name term) defs))))))) 
                        (return defs))))) 
                   (let ((defs 
                          (foldriAQualifierMap-1-1-1 
                           #'(lambda (x) 
                              (mkLOpDef 
                               (svref x 0) 
                               (svref x 1) 
                               (svref x 2) 
                               (svref x 3))) 
                           nil 
                           (svref spc 1)))) 
                     (vector 
                      nil 
                      pV7715 
                      pV7714 
                      defs 
                      (LIST-SPEC::|!map|-1-1 #'(lambda (x) (car x)) defs)))))) 
              (error "Nonexhaustive match failure in lisp"))))))
                                                                
(defun SPECTOLISP::toLispEnv-1 (spc) 
  (let ((spc (PATTERNMATCH::translateMatch-1 spc))) 
    (let ((spc (ARITYNORMALIZE::arityNormalize-1 spc))) 
      (let ((spc (SPECTOLISP::|!lisp|-1 spc))) spc))))
                                                      
(defun SPECTOLISP::toLispFileEnv (spc file preamble) 
  (let ((spc (SPECTOLISP::toLispEnv-1 spc))) 
    (LISTADT::ppSpecToFile spc file preamble)))
                                               
(defun SPECTOLISP::toLispFile (spc file preamble) 
  (SPECTOLISP::toLispFileEnv spc file preamble))
                                                
(defun SPECCALC::evaluateLispCompile (pV5297 pV5298 pV5299) 
  (block 
   nil 
   (return 
    (let ((pV5295 (SPECCALC::coerceToSpec (svref pV5297 0)))) 
      (block 
       nil 
       (if (eq (car pV5295) :|Spec|) 
           (let ((pV5296 (cdr pV5295))) 
             (return 
              (SPECCALC::monadBind 
               (SPECCALC::getURI-1 pV5298) 
               #'(lambda (cURI) 
                  (SPECCALC::monadBind 
                   (SPECCALC::URItoLispFile cURI pV5299) 
                   #'(lambda (lispFileName) 
                      (SPECCALC::monadSeq 
                       (SPECCALC::|!print| 
                        (STRING-SPEC::^ 
                         (STRING-SPEC::^ 
                          ";;; Generating lisp file " 
                          lispFileName) 
                         "
")) 
                       (progn (IO-SPEC::ensureDirectoriesExist lispFileName) 
                              (progn (SPECTOLISP::toLispFile 
                                      pV5296 
                                      lispFileName 
                                      nil) 
                                     (SPECCALC::|!return| pV5297))))))))))) 
       (return 
        (SPECCALC::raise 
         (cons 
          :|TypeCheck| 
          (cons 
           (SPECCALC::positionOf-1 pV5298) 
           "attempting to generate code from an object that is not a specification"))))))) 
   (error "Nonexhaustive match failure in evaluateLispCompile")))
                                                                 
(defun SPECCALC::findUnitIdforUnit (val globalContext) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (result) 
      #'(lambda (uri) 
         #'(lambda (x) 
            (block 
             nil 
             (if (eq (car result) :|Some|) 
                 (return result) 
                 (if (eq (car result) :|None|) 
                     (return 
                      (if (slang-built-in::slang-term-equals val (svref x 0)) 
                          (cons :|Some| (cons (car uri) (cdr uri))) 
                          '(:|None|))))) 
             (error "Nonexhaustive match failure in findUnitIdforUnit"))))) 
   '(:|None|) 
   globalContext))
                  
(defun SPECCALC::translateTerm (tm sortMap opMap) 
  (labels 
    ((translateTerm (trm) 
      (block 
       nil 
       (if (eq (car trm) :|Fun|) 
           (let ((pV7023 (cdr trm))) 
             (let ((pV7024 (svref pV7023 0))) 
               (if (eq (car pV7024) :|Op|) 
                   (let ((pV7027 (cdr pV7024))) 
                     (return 
                      (cons 
                       :|Fun| 
                       (vector 
                        (cons 
                         :|Op| 
                         (cons 
                          (funcall (findName opMap) (car pV7027)) 
                          (cdr pV7027))) 
                        (svref pV7023 1) 
                        (svref pV7023 2))))))))) 
       (return trm)))
     (translateSort (srt) 
      (block 
       nil 
       (if (eq (car srt) :|Base|) 
           (let ((pV7017 (cdr srt))) 
             (return 
              (cons 
               :|Base| 
               (vector 
                (funcall (findName sortMap) (svref pV7017 0)) 
                (svref pV7017 1) 
                (svref pV7017 2)))))) 
       (return srt)))
     (findName (m) 
      #'(lambda (|!QId|) 
         (let ((pV7013 (POLYMAP::evalPartial-1-1 m |!QId|))) 
           (block 
            nil 
            (if (eq (car pV7013) :|Some|) (return (cdr pV7013))) 
            (return |!QId|)))))) 
    (METASLANG::mapTerm-1-1 
     (vector #'translateTerm #'translateSort #'FUNCTIONS::id) 
     tm)))
          
(defun SPECCALC::morphismObligations (pV6201 pV6202) 
  (block 
   nil 
   (let ((pV6206 (svref pV6201 3))
         (pV6205 (svref pV6201 2))
         (pV6203 (svref pV6201 0))) 
     (return 
      (let ((translated_dom_axioms 
             (LIST-SPEC::mapPartial-1-1 
              #'(lambda (prop) 
                 (block 
                  nil 
                  (if (eq (car (svref prop 0)) :|Axiom|) 
                      (return 
                       (cons 
                        :|Some| 
                        (vector 
                         '(:|Conjecture|) 
                         (svref prop 1) 
                         (svref prop 2) 
                         (SPECCALC::translateTerm (svref prop 3) pV6206 pV6205))))) 
                  (return '(:|None|)))) 
              (svref (svref pV6201 1) 2)))) 
        (let ((import_of_cod 
               (vector 
                (cons 
                 :|Some| 
                 (vector 
                  (svref pV6203 0) 
                  (svref pV6203 1) 
                  (svref pV6203 2) 
                  (svref pV6203 3))) 
                (let ((pV6199 
                       (SPECCALC::findUnitIdforUnit 
                        (cons 
                         :|Spec| 
                         (vector 
                          (svref pV6203 0) 
                          (svref pV6203 1) 
                          (svref pV6203 2) 
                          (svref pV6203 3))) 
                        pV6202))) 
                  (block 
                   nil 
                   (if (eq (car pV6199) :|Some|) 
                       (return 
                        (cons 
                         (cons (SPECCALC::showURI-1 (cdr pV6199)) pV6203) 
                         nil))) 
                   (return nil))) 
                emptyOpNames 
                emptySortNames))) 
          (let ((ob_spc 
                 (vector 
                  import_of_cod 
                  (svref pV6203 1) 
                  (LIST-SPEC::|!++| (svref pV6203 2) translated_dom_axioms) 
                  (svref pV6203 3)))) ob_spc))))) 
   (error "Nonexhaustive match failure in morphismObligations")))
                                                                 
(defun TYPEOBLIGATIONS::??-1 (x) x)
                                   
(defun TYPEOBLIGATIONS::?? (x0 x1) (TYPEOBLIGATIONS::??-1 (cons x0 x1)))
                                                                        
(defun STANDARDSPEC::mkFalse () 
  (STANDARDSPEC::mkFun (cons :|Bool| nil) STANDARDSPEC::boolSort))
                                                                  
(defparameter STANDARDSPEC::unaryBoolSort 
  (STANDARDSPEC::mkArrow STANDARDSPEC::boolSort STANDARDSPEC::boolSort))
                                                                        
(defparameter STANDARDSPEC::notOp 
  (STANDARDSPEC::mkOp 
   (cons :|Qualified| (cons "Boolean" "~")) 
   STANDARDSPEC::unaryBoolSort))
                                
(defun STANDARDSPEC::mkNot (trm) 
  (STANDARDSPEC::mkApply STANDARDSPEC::notOp trm))
                                                  
(defparameter STANDARDSPEC::binaryBoolSort 
  (STANDARDSPEC::mkArrow 
   (STANDARDSPEC::mkProduct 
    (cons STANDARDSPEC::boolSort (cons STANDARDSPEC::boolSort nil))) 
   STANDARDSPEC::boolSort))
                           
(defun STANDARDSPEC::mkInfixOp (qid fixity srt) 
  (STANDARDSPEC::mkFun (cons :|Op| (cons qid fixity)) srt))
                                                           
(defparameter STANDARDSPEC::impliesOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "=>")) 
   (cons '(:|Right|) 13) 
   STANDARDSPEC::binaryBoolSort))
                                 
(defun STANDARDSPEC::mkImplies (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::impliesOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))
                                                    
(defun UTILITIES::isPatBound (v pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV11182 (cdr pat))) 
         (return 
          (lisp::or 
           (UTILITIES::isPatBound v (svref pV11182 0)) 
           (UTILITIES::isPatBound v (svref pV11182 1))))) 
       (if (eq (car pat) :|EmbedPat|) 
           (let ((pV11194 (svref (cdr pat) 1))) 
             (if (eq (car pV11194) :|Some|) 
                 (return (UTILITIES::isPatBound v (cdr pV11194))))) 
           (if (eq (car pat) :|VarPat|) 
               (return (slang-built-in::slang-term-equals v (car (cdr pat)))) 
               (if (eq (car pat) :|RecordPat|) 
                   (return 
                    (LIST-SPEC::|!exists|-1-1 
                     #'(lambda (x) (UTILITIES::isPatBound v (cdr x))) 
                     (car (cdr pat)))) 
                   (if (eq (car pat) :|RelaxPat|) 
                       (return (UTILITIES::isPatBound v (svref (cdr pat) 0))) 
                       (if (eq (car pat) :|QuotientPat|) 
                           (return (UTILITIES::isPatBound v (svref (cdr pat) 0))))))))) 
   (return nil)))
                 
(defun UTILITIES::isFree (v term) 
  (block 
   nil 
   (if (eq (car term) :|Var|) 
       (return (slang-built-in::slang-term-equals v (car (cdr term)))) 
       (if (eq (car term) :|Apply|) 
           (let ((pV11139 (cdr term))) 
             (return 
              (lisp::or 
               (UTILITIES::isFree v (svref pV11139 0)) 
               (UTILITIES::isFree v (svref pV11139 1))))) 
           (if (eq (car term) :|Record|) 
               (return 
                (LIST-SPEC::|!exists|-1-1 
                 #'(lambda (x) (UTILITIES::isFree v (cdr x))) 
                 (car (cdr term)))) 
               (if (eq (car term) :|Fun|) 
                   (return nil) 
                   (if (eq (car term) :|Lambda|) 
                       (return 
                        (LIST-SPEC::|!exists|-1-1 
                         #'(lambda (x) 
                            (lisp::and 
                             (BOOLEAN-SPEC::~ 
                              (UTILITIES::isPatBound v (svref x 0))) 
                             (lisp::or 
                              (UTILITIES::isFree v (svref x 1)) 
                              (UTILITIES::isFree v (svref x 2))))) 
                         (car (cdr term)))) 
                       (if (eq (car term) :|Let|) 
                           (let ((pV11135 (cdr term))) 
                             (let ((pV11152 (svref pV11135 0))) 
                               (return 
                                (lisp::or 
                                 (LIST-SPEC::|!exists|-1-1 
                                  #'(lambda (x) (UTILITIES::isFree v (cdr x))) 
                                  pV11152) 
                                 (lisp::and 
                                  (LIST-SPEC::all-1-1 
                                   #'(lambda (x) 
                                      (BOOLEAN-SPEC::~ 
                                       (UTILITIES::isPatBound v (car x)))) 
                                   pV11152) 
                                  (UTILITIES::isFree v (svref pV11135 1))))))) 
                           (if (eq (car term) :|LetRec|) 
                               (let ((pV11134 (cdr term))) 
                                 (let ((pV11149 (svref pV11134 0))) 
                                   (return 
                                    (lisp::and 
                                     (LIST-SPEC::all-1-1 
                                      #'(lambda (x) 
                                         (BOOLEAN-SPEC::~ 
                                          (slang-built-in::slang-term-equals 
                                           v 
                                           (car x)))) 
                                      pV11149) 
                                     (lisp::or 
                                      (LIST-SPEC::|!exists|-1-1 
                                       #'(lambda (x) 
                                          (UTILITIES::isFree v (cdr x))) 
                                       pV11149) 
                                      (UTILITIES::isFree v (svref pV11134 1))))))) 
                               (if (eq (car term) :|Bind|) 
                                   (let ((pV11133 (cdr term))) 
                                     (return 
                                      (lisp::and 
                                       (LIST-SPEC::all-1-1 
                                        #'(lambda (w) 
                                           (BOOLEAN-SPEC::~ 
                                            (slang-built-in::slang-term-equals 
                                             v 
                                             w))) 
                                        (svref pV11133 1)) 
                                       (UTILITIES::isFree v (svref pV11133 2))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV11132 (cdr term))) 
                                         (return 
                                          (lisp::or 
                                           (UTILITIES::isFree 
                                            v 
                                            (svref pV11132 0)) 
                                           (lisp::or 
                                            (UTILITIES::isFree 
                                             v 
                                             (svref pV11132 1)) 
                                            (UTILITIES::isFree 
                                             v 
                                             (svref pV11132 2))))))))))))))) 
   (error "Nonexhaustive match failure in isFree")))
                                                    
(defun TYPEOBLIGATIONS::makeVerificationCondition (pV10524 pV10525) 
  (block 
   nil 
   (let ((pV10529 (svref pV10524 3))
         (pV10527 (svref pV10524 1))
         (pV10526 (svref pV10524 0))) 
     (return 
      (labels 
        ((insert (decl formula) 
          (block 
           nil 
           (if (eq (car decl) :|Var|) 
               (let ((pV10518 (cdr decl))) 
                 (return 
                  (if (UTILITIES::isFree pV10518 formula) 
                      (STANDARDSPEC::mkBind 
                       '(:|Forall|) 
                       (cons pV10518 nil) 
                       formula) 
                      formula))) 
               (if (eq (car decl) :|Cond|) 
                   (let ((pV10517 (cdr decl))) 
                     (progn (if (eq (car pV10517) :|Fun|) 
                                (let ((pV10520 (svref (cdr pV10517) 0))) 
                                  (if (eq (car pV10520) :|Bool|) 
                                      (if (eq t (cdr pV10520)) (return formula))))) 
                            (return (STANDARDSPEC::mkImplies pV10517 formula)))) 
                   (if (eq (car decl) :|Let|) 
                       (return 
                        (cons 
                         :|Let| 
                         (vector (cdr decl) formula POSITION-SPEC::noPos))) 
                       (if (eq (car decl) :|LetRec|) 
                           (return 
                            (cons 
                             :|LetRec| 
                             (vector (cdr decl) formula POSITION-SPEC::noPos))))))) 
           (error "Nonexhaustive match failure in makeVerificationCondition")))) 
        (let ((term 
               (LIST-SPEC::foldl-1-1-1 
                #'(lambda (x) (insert (car x) (cdr x))) 
                pV10525 
                pV10526))) (vector pV10529 pV10527 term))))) 
   (error "Nonexhaustive match failure in makeVerificationCondition")))
                                                                       
(defun TYPEOBLIGATIONS::addCondition (tcc gamma term) 
  (LIST-SPEC::|!cons| 
   (TYPEOBLIGATIONS::makeVerificationCondition gamma term) 
   tcc))
        
(defun TYPEOBLIGATIONS::assertCond (pV10330 pV10331) 
  (block 
   nil 
   (return 
    (vector 
     (LIST-SPEC::|!cons| (cons :|Cond| pV10330) (svref pV10331 0)) 
     (svref pV10331 1) 
     (svref pV10331 2) 
     (svref pV10331 3) 
     (svref pV10331 4))) 
   (error "Nonexhaustive match failure in assertCond")))
                                                        
(defun TYPEOBLIGATIONS::freshName (pV10471 pV10472) 
  (block 
   nil 
   (return 
    (let ((name (STRINGUTILITIES::freshName pV10472 (svref pV10471 4)))) name)) 
   (error "Nonexhaustive match failure in freshName")))
                                                       
(defun TYPEOBLIGATIONS::getSpec (pV10478 pV10479 e pV10480 pV10481) 
  (declare (ignore pV10478 pV10479 pV10480 pV10481)) 
  e)
    
(defun TYPEOBLIGATIONS::getSpec-1 (x) 
  (TYPEOBLIGATIONS::getSpec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPEOBLIGATIONS::mkLetOrApply (fntm arg) 
  (block 
   nil 
   (if (eq (car fntm) :|Lambda|) 
       (let ((pV10544 (car (cdr fntm)))) 
         (if (consp pV10544) 
             (let ((pV10547 (car pV10544))) 
               (let ((pV10550 (svref pV10547 1))
                     (pV10549 (svref pV10547 0))) 
                 (if (eq (car pV10549) :|VarPat|) 
                     (let ((pV10553 (car (cdr pV10549)))) 
                       (if (eq (car pV10550) :|Fun|) 
                           (let ((pV10556 (svref (cdr pV10550) 0))) 
                             (if (eq (car pV10556) :|Bool|) 
                                 (if (eq t (cdr pV10556)) 
                                     (if (null (cdr pV10544)) 
                                         (return 
                                          (METASLANG::mapTerm-1-1 
                                           (vector 
                                            #'(lambda (tm) 
                                               (block 
                                                nil 
                                                (if (eq (car tm) :|Var|) 
                                                    (return 
                                                     (if (slang-built-in::slang-term-equals 
                                                          (car (cdr tm)) 
                                                          pV10553) 
                                                         arg 
                                                         tm))) 
                                                (return tm))) 
                                            #'FUNCTIONS::id 
                                            #'FUNCTIONS::id) 
                                           (svref pV10547 2))))))))))))))) 
   (return (cons :|Apply| (vector fntm arg POSITION-SPEC::noPos)))))
                                                                    
(defun TYPEOBLIGATIONS::assertSubtypeCond (term srt gamma) 
  (block 
   nil 
   (if (eq (car srt) :|Subsort|) 
       (let ((pV10346 (cdr srt))) 
         (return 
          (block 
           nil 
           (return 
            (TYPEOBLIGATIONS::assertSubtypeCond 
             term 
             (svref pV10346 0) 
             (vector 
              (LIST-SPEC::|!cons| 
               (cons 
                :|Cond| 
                (TYPEOBLIGATIONS::mkLetOrApply (svref pV10346 1) term)) 
               (svref gamma 0)) 
              (svref gamma 1) 
              (svref gamma 2) 
              (svref gamma 3) 
              (svref gamma 4)))) 
           (error "Nonexhaustive match failure in assertSubtypeCond"))))) 
   (return gamma)))
                   
(defun TYPEOBLIGATIONS::insert (pV10482 pV10483) 
  (block 
   nil 
   (let ((pV10485 (cdr pV10482))
         (pV10484 (car pV10482))) 
     (return 
      (let ((ds 
             (LIST-SPEC::|!cons| 
              (cons :|Var| (cons pV10484 pV10485)) 
              (svref pV10483 0)))) 
        (let ((gamma 
               (vector 
                ds 
                (svref pV10483 1) 
                (svref pV10483 2) 
                (svref pV10483 3) 
                (svref pV10483 4)))) 
          (let ((gamma 
                 (TYPEOBLIGATIONS::assertSubtypeCond 
                  (cons 
                   :|Var| 
                   (cons (cons pV10484 pV10485) POSITION-SPEC::noPos)) 
                  pV10485 
                  gamma))) gamma))))) 
   (error "Nonexhaustive match failure in insert")))
                                                    
(defun TYPEOBLIGATIONS::unfoldBase (pV10739 pV10740) 
  (block 
   nil 
   (return (SPECENVIRONMENT::unfoldBase (svref pV10739 2) pV10740)) 
   (error "Nonexhaustive match failure in unfoldBase")))
                                                        
(defun TYPEOBLIGATIONS::returnPatternRec (pairs gamma |!M| tau sigma) 
  (if (lisp::or 
       (slang-built-in::slang-term-equals tau sigma) 
       (LIST-SPEC::|!exists|-1-1 
        #'(lambda (p) (slang-built-in::slang-term-equals p (cons tau sigma))) 
        pairs)) 
      (cons gamma |!M|) 
      (let ((pairs (LIST-SPEC::|!cons| (cons tau sigma) pairs))) 
        (let ((tau1 (TYPEOBLIGATIONS::unfoldBase gamma tau))) 
          (let ((sigma1 (TYPEOBLIGATIONS::unfoldBase gamma sigma))) 
            (if (slang-built-in::slang-term-equals tau1 sigma1) 
                (cons gamma |!M|) 
                (block 
                 nil 
                 (if (eq (car tau1) :|Subsort|) 
                     (let ((pV10583 (cdr tau1))) 
                       (return 
                        (let ((gamma 
                               (TYPEOBLIGATIONS::assertCond 
                                (TYPEOBLIGATIONS::mkLetOrApply 
                                 (svref pV10583 1) 
                                 |!M|) 
                                gamma))) 
                          (TYPEOBLIGATIONS::returnPatternRec 
                           pairs 
                           gamma 
                           |!M| 
                           (svref pV10583 0) 
                           sigma1))))) 
                 (return 
                  (block 
                   nil 
                   (if (eq (car sigma1) :|Subsort|) 
                       (let ((pV10578 (cdr sigma1))) 
                         (return 
                          (let ((gamma 
                                 (TYPEOBLIGATIONS::assertCond 
                                  (TYPEOBLIGATIONS::mkLetOrApply 
                                   (svref pV10578 1) 
                                   |!M|) 
                                  gamma))) 
                            (TYPEOBLIGATIONS::returnPatternRec 
                             pairs 
                             gamma 
                             |!M| 
                             tau1 
                             (svref pV10578 0)))))) 
                   (return (cons gamma |!M|)))))))))))
                                                      
(defun TYPEOBLIGATIONS::returnPattern (gamma |!t| tau1 tau2) 
  (TYPEOBLIGATIONS::returnPatternRec nil gamma |!t| tau1 tau2))
                                                               
(defun TYPEOBLIGATIONS::bindPattern (gamma pat tau) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV10413 (cdr pat))) 
         (return 
          (let ((pV10354 
                 (TYPEOBLIGATIONS::bindPattern gamma (svref pV10413 0) tau))) 
            (block 
             nil 
             (let ((pV10356 (cdr pV10354))) 
               (return 
                (let ((pV10351 
                       (TYPEOBLIGATIONS::bindPattern 
                        (car pV10354) 
                        (svref pV10413 1) 
                        tau))) 
                  (block 
                   nil 
                   (return 
                    (let ((gamma 
                           (TYPEOBLIGATIONS::assertCond 
                            (STANDARDSPEC::mkEquality tau pV10356 (cdr pV10351)) 
                            (car pV10351)))) (cons gamma pV10356))) 
                   (error "Nonexhaustive match failure in bindPattern"))))) 
             (error "Nonexhaustive match failure in bindPattern"))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV10437 (car (cdr pat)))) 
             (return 
              (let ((gamma1 (TYPEOBLIGATIONS::insert pV10437 gamma))) 
                (TYPEOBLIGATIONS::returnPattern 
                 gamma1 
                 (cons :|Var| (cons pV10437 POSITION-SPEC::noPos)) 
                 (cdr pV10437) 
                 tau)))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV10411 (cdr pat))) 
                 (let ((pV10434 (svref pV10411 2))
                       (pV10433 (svref pV10411 1))
                       (pV10432 (svref pV10411 0))) 
                   (if (eq (car pV10433) :|Some|) 
                       (let ((pV10436 (cdr pV10433))) 
                         (return 
                          (let ((tau1 (METASLANG::patternSort pV10436))) 
                            (let ((pV10360 
                                   (TYPEOBLIGATIONS::bindPattern 
                                    gamma 
                                    pV10436 
                                    tau1))) 
                              (block 
                               nil 
                               (return 
                                (TYPEOBLIGATIONS::returnPattern 
                                 (car pV10360) 
                                 (cons 
                                  :|Apply| 
                                  (vector 
                                   (cons 
                                    :|Fun| 
                                    (vector 
                                     (cons :|Embed| (cons pV10432 t)) 
                                     (cons 
                                      :|Arrow| 
                                      (vector tau1 pV10434 POSITION-SPEC::noPos)) 
                                     POSITION-SPEC::noPos)) 
                                   (cdr pV10360) 
                                   POSITION-SPEC::noPos)) 
                                 pV10434 
                                 tau)) 
                               (error 
                                "Nonexhaustive match failure in bindPattern")))))) 
                       (if (eq (car pV10433) :|None|) 
                           (return 
                            (TYPEOBLIGATIONS::returnPattern 
                             gamma 
                             (cons 
                              :|Fun| 
                              (vector 
                               (cons :|Embed| (cons pV10432 nil)) 
                               pV10434 
                               POSITION-SPEC::noPos)) 
                             pV10434 
                             tau)))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (return 
                    (let ((fs 
                           (SPECENVIRONMENT::product 
                            (TYPEOBLIGATIONS::getSpec-1 gamma) 
                            tau))) 
                      (let ((fields (LISTPAIR::zip fs (car (cdr pat))))) 
                        (let ((pV10379 
                               (LIST-SPEC::foldr-1-1-1 
                                #'(lambda (x) 
                                   (let ((pV10370 (cdr x))
                                         (pV10369 (car x))) 
                                     (block 
                                      nil 
                                      (let ((pV10372 (cdr pV10369))) 
                                        (return 
                                         (let ((pV10366 
                                                (TYPEOBLIGATIONS::bindPattern 
                                                 (car pV10370) 
                                                 (cdr pV10372) 
                                                 (cdr (car pV10369))))) 
                                           (block 
                                            nil 
                                            (return 
                                             (cons 
                                              (car pV10366) 
                                              (LIST-SPEC::|!cons| 
                                               (cons (car pV10372) (cdr pV10366)) 
                                               (cdr pV10370)))) 
                                            (error 
                                             "Nonexhaustive match failure in bindPattern"))))) 
                                      (error 
                                       "Nonexhaustive match failure in bindPattern")))) 
                                (cons gamma nil) 
                                fields))) 
                          (block 
                           nil 
                           (return 
                            (TYPEOBLIGATIONS::returnPattern 
                             (car pV10379) 
                             (cons 
                              :|Record| 
                              (cons (cdr pV10379) POSITION-SPEC::noPos)) 
                             (METASLANG::patternSort pat) 
                             tau)) 
                           (error "Nonexhaustive match failure in bindPattern")))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (return 
                        (let ((v (TYPEOBLIGATIONS::freshName gamma "v"))) 
                          (let ((v (cons v (car (cdr pat))))) 
                            (let ((gamma1 (TYPEOBLIGATIONS::insert v gamma))) 
                              (cons 
                               gamma1 
                               (cons :|Var| (cons v POSITION-SPEC::noPos))))))) 
                       (if (eq (car pat) :|StringPat|) 
                           (return 
                            (TYPEOBLIGATIONS::returnPattern 
                             gamma 
                             (cons 
                              :|Fun| 
                              (vector 
                               (cons :|String| (car (cdr pat))) 
                               STANDARDSPEC::stringSort 
                               POSITION-SPEC::noPos)) 
                             STANDARDSPEC::stringSort 
                             tau)) 
                           (if (eq (car pat) :|BoolPat|) 
                               (return 
                                (TYPEOBLIGATIONS::returnPattern 
                                 gamma 
                                 (cons 
                                  :|Fun| 
                                  (vector 
                                   (cons :|Bool| (car (cdr pat))) 
                                   STANDARDSPEC::boolSort 
                                   POSITION-SPEC::noPos)) 
                                 STANDARDSPEC::boolSort 
                                 tau)) 
                               (if (eq (car pat) :|CharPat|) 
                                   (return 
                                    (TYPEOBLIGATIONS::returnPattern 
                                     gamma 
                                     (cons 
                                      :|Fun| 
                                      (vector 
                                       (cons :|Char| (car (cdr pat))) 
                                       STANDARDSPEC::charSort 
                                       POSITION-SPEC::noPos)) 
                                     STANDARDSPEC::charSort 
                                     tau)) 
                                   (if (eq (car pat) :|NatPat|) 
                                       (return 
                                        (TYPEOBLIGATIONS::returnPattern 
                                         gamma 
                                         (cons 
                                          :|Fun| 
                                          (vector 
                                           (cons :|Nat| (car (cdr pat))) 
                                           STANDARDSPEC::natSort 
                                           POSITION-SPEC::noPos)) 
                                         STANDARDSPEC::natSort 
                                         tau)) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (let ((pV10404 (cdr pat))) 
                                             (return 
                                              (let ((tau1 
                                                     (cons 
                                                      :|Subsort| 
                                                      (vector 
                                                       tau 
                                                       (svref pV10404 1) 
                                                       POSITION-SPEC::noPos)))) 
                                                (let ((pV10388 
                                                       (TYPEOBLIGATIONS::bindPattern 
                                                        gamma 
                                                        (svref pV10404 0) 
                                                        tau1))) 
                                                  (block 
                                                   nil 
                                                   (return 
                                                    (cons 
                                                     (car pV10388) 
                                                     (cons 
                                                      :|Apply| 
                                                      (vector 
                                                       (cons 
                                                        :|Fun| 
                                                        (vector 
                                                         '(:|Relax|) 
                                                         (cons 
                                                          :|Arrow| 
                                                          (vector 
                                                           tau1 
                                                           tau 
                                                           POSITION-SPEC::noPos)) 
                                                         POSITION-SPEC::noPos)) 
                                                       (cdr pV10388) 
                                                       POSITION-SPEC::noPos)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in bindPattern")))))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (return 
                                                (block 
                                                 nil 
                                                 (if (eq (car tau) :|Quotient|) 
                                                     (let ((pV10399 
                                                            (svref (cdr tau) 0))) 
                                                       (return 
                                                        (let ((pV10394 
                                                               (TYPEOBLIGATIONS::bindPattern 
                                                                gamma 
                                                                (svref 
                                                                 (cdr pat) 
                                                                 0) 
                                                                pV10399))) 
                                                          (block 
                                                           nil 
                                                           (return 
                                                            (cons 
                                                             (car pV10394) 
                                                             (cons 
                                                              :|Apply| 
                                                              (vector 
                                                               (cons 
                                                                :|Fun| 
                                                                (vector 
                                                                 '(:|Quotient|) 
                                                                 (cons 
                                                                  :|Arrow| 
                                                                  (vector 
                                                                   pV10399 
                                                                   tau 
                                                                   POSITION-SPEC::noPos)) 
                                                                 POSITION-SPEC::noPos)) 
                                                               (cdr pV10394) 
                                                               POSITION-SPEC::noPos)))) 
                                                           (error 
                                                            "Nonexhaustive match failure in bindPattern")))))) 
                                                 (error 
                                                  "Nonexhaustive match failure in bindPattern")))))))))))))) 
   (error "Nonexhaustive match failure in bindPattern")))
                                                         
(defun TYPEOBLIGATIONS::checkRule-1-1 (!x1 x) 
  (let ((pV10448 (car x))) 
    (block 
     nil 
     (let ((pV10451 (svref pV10448 1))) 
       (return 
        (let ((pV10445 
               (TYPEOBLIGATIONS::bindPattern 
                (svref !x1 0) 
                (svref pV10448 0) 
                (svref !x1 1)))) 
          (block 
           nil 
           (let ((pV10446 (car pV10445))) 
             (return 
              (let ((tcc 
                     (TYPEOBLIGATIONS::\|- 
                      (cons (cdr x) pV10446) 
                      (TYPEOBLIGATIONS::?? pV10451 STANDARDSPEC::boolSort)))) 
                (let ((gamma2 (TYPEOBLIGATIONS::assertCond pV10451 pV10446))) 
                  (let ((tcc 
                         (TYPEOBLIGATIONS::\|- 
                          (cons tcc gamma2) 
                          (TYPEOBLIGATIONS::?? (svref pV10448 2) (svref !x1 2))))) 
                    tcc))))) 
           (error "Nonexhaustive match failure in checkRule"))))) 
     (error "Nonexhaustive match failure in checkRule"))))
                                                          
(defun TYPEOBLIGATIONS::checkRule-1 (x1) 
  #'(lambda (x2) (TYPEOBLIGATIONS::checkRule-1-1 x1 x2)))
                                                         
(defun TYPEOBLIGATIONS::checkRule (x0 x1 x2) 
  (TYPEOBLIGATIONS::checkRule-1 (vector x0 x1 x2)))
                                                   
(defun TYPEOBLIGATIONS::insert-1 (x) (TYPEOBLIGATIONS::insert (car x) (cdr x)))
                                                                               
(defparameter STANDARDSPEC::andOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "&")) 
   (cons '(:|Right|) 15) 
   STANDARDSPEC::binaryBoolSort))
                                 
(defun STANDARDSPEC::mkAnd (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::andOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))
                                                    
(defun UTILITIES::mkAnd (t1 t2) 
  (block 
   nil 
   (if (eq (car t1) :|Fun|) 
       (let ((pV11344 (svref (cdr t1) 0))) 
         (if (eq (car pV11344) :|Bool|) 
             (let ((pV11347 (cdr pV11344))) 
               (if (eq t pV11347) (return t2) (if (eq nil pV11347) (return t1))))))) 
   (if (eq (car t2) :|Fun|) 
       (let ((pV11339 (svref (cdr t2) 0))) 
         (if (eq (car pV11339) :|Bool|) 
             (let ((pV11342 (cdr pV11339))) 
               (if (eq t pV11342) (return t1) (if (eq nil pV11342) (return t2))))))) 
   (return (STANDARDSPEC::mkAnd t1 t2))))
                                         
(defparameter STANDARDSPEC::orOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "or")) 
   (cons '(:|Right|) 14) 
   STANDARDSPEC::binaryBoolSort))
                                 
(defun STANDARDSPEC::mkOr (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::orOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))
                                                    
(defun UTILITIES::mkOr (t1 t2) 
  (block 
   nil 
   (if (eq (car t1) :|Fun|) 
       (let ((pV11391 (svref (cdr t1) 0))) 
         (if (eq (car pV11391) :|Bool|) 
             (let ((pV11394 (cdr pV11391))) 
               (if (eq t pV11394) (return t1) (if (eq nil pV11394) (return t2))))))) 
   (if (eq (car t2) :|Fun|) 
       (let ((pV11386 (svref (cdr t2) 0))) 
         (if (eq (car pV11386) :|Bool|) 
             (let ((pV11389 (cdr pV11386))) 
               (if (eq t pV11389) (return t2) (if (eq nil pV11389) (return t1))))))) 
   (return (STANDARDSPEC::mkOr t1 t2))))
                                        
(defun UTILITIES::mkIfThenElse (t1 t2 t3) 
  (block 
   nil 
   (if (eq (car t2) :|Fun|) 
       (let ((pV11366 (svref (cdr t2) 0))) 
         (if (eq (car pV11366) :|Bool|) 
             (let ((pV11369 (cdr pV11366))) 
               (if (eq t pV11369) 
                   (return (UTILITIES::mkOr t1 t3)) 
                   (if (eq nil pV11369) 
                       (return (UTILITIES::mkAnd (STANDARDSPEC::mkNot t1) t3)))))))) 
   (return 
    (block 
     nil 
     (if (eq (car t2) :|Fun|) 
         (let ((pV11360 (svref (cdr t2) 0))) 
           (if (eq (car pV11360) :|Bool|) 
               (let ((pV11363 (cdr pV11360))) 
                 (if (eq t pV11363) 
                     (return (UTILITIES::mkOr (STANDARDSPEC::mkNot t1) t2)) 
                     (if (eq nil pV11363) (return (UTILITIES::mkAnd t1 t2)))))))) 
     (return (cons :|IfThenElse| (vector t1 t2 t3 POSITION-SPEC::noPos)))))))
                                                                             
(defun TYPEOBLIGATIONS::simplifyMatch (trm) 
  (block 
   nil 
   (if (eq (car trm) :|IfThenElse|) 
       (let ((pV10610 (cdr trm))) 
         (return 
          (let ((t2 (TYPEOBLIGATIONS::simplifyMatch (svref pV10610 1)))) 
            (let ((t3 (TYPEOBLIGATIONS::simplifyMatch (svref pV10610 2)))) 
              (UTILITIES::mkIfThenElse (svref pV10610 0) t2 t3))))) 
       (if (eq (car trm) :|Apply|) 
           (let ((pV10609 (cdr trm))) 
             (let ((pV10615 (svref pV10609 1))
                   (pV10614 (svref pV10609 0))) 
               (if (eq (car pV10614) :|Fun|) 
                   (let ((pV10618 (svref (cdr pV10614) 0))) 
                     (if (eq (car pV10618) :|Op|) 
                         (let ((pV10622 (car (cdr pV10618)))) 
                           (if (eq (car pV10622) :|Qualified|) 
                               (let ((pV10624 (cdr pV10622))) 
                                 (if (string=  
                                      "TranslationBuiltIn" 
                                      (car pV10624)) 
                                     (if (string=  "failWith" (cdr pV10624)) 
                                         (if (eq (car pV10615) :|Record|) 
                                             (let ((pV10628 (car (cdr pV10615)))) 
                                               (if (consp pV10628) 
                                                   (let ((pV10632 (cdr pV10628))) 
                                                     (if (consp pV10632) 
                                                         (if (null (cdr pV10632)) 
                                                             (return 
                                                              (let ((t1 
                                                                     (TYPEOBLIGATIONS::simplifyMatch 
                                                                      (cdr 
                                                                       (car 
                                                                        pV10628))))) 
                                                                (let ((t2 
                                                                       (TYPEOBLIGATIONS::simplifyMatch 
                                                                        (cdr 
                                                                         (car 
                                                                          pV10632))))) 
                                                                  (UTILITIES::mkOr 
                                                                   t1 
                                                                   t2)))))))))))))))))))) 
           (if (eq (car trm) :|Let|) 
               (let ((pV10608 (cdr trm))) 
                 (return 
                  (let ((trm1 (TYPEOBLIGATIONS::simplifyMatch (svref pV10608 1)))) 
                    (block 
                     nil 
                     (if (eq (car trm1) :|Fun|) 
                         (if (eq (car (svref (cdr trm1) 0)) :|Bool|) 
                             (return trm1))) 
                     (return 
                      (cons 
                       :|Let| 
                       (vector (svref pV10608 0) trm1 POSITION-SPEC::noPos)))))))))) 
   (return trm)))
                 
(defun TYPEOBLIGATIONS::addFailure (pV10322 pV10323 pV10324) 
  (block 
   nil 
   (return 
    (LIST-SPEC::|!cons| 
     (vector 
      (STRING-SPEC::^ (STRING-SPEC::^ (svref pV10323 3) " :") pV10324) 
      nil 
      (STANDARDSPEC::mkFalse)) 
     pV10322)) 
   (error "Nonexhaustive match failure in addFailure")))
                                                        
(defun TYPEOBLIGATIONS::subtypeRec (pairs tcc gamma |!M| tau sigma) 
  (if (lisp::or 
       (slang-built-in::slang-term-equals tau sigma) 
       (LIST-SPEC::|!exists|-1-1 
        #'(lambda (p) (slang-built-in::slang-term-equals p (cons tau sigma))) 
        pairs)) 
      tcc 
      (let ((pairs (LIST-SPEC::|!cons| (cons tau sigma) pairs))) 
        (let ((tau1 (TYPEOBLIGATIONS::unfoldBase gamma tau))) 
          (let ((sigma1 (TYPEOBLIGATIONS::unfoldBase gamma sigma))) 
            (if (slang-built-in::slang-term-equals tau1 sigma1) 
                tcc 
                (block 
                 nil 
                 (if (eq (car tau1) :|Subsort|) 
                     (let ((pV10731 (cdr tau1))) 
                       (return 
                        (let ((gamma 
                               (TYPEOBLIGATIONS::assertCond 
                                (TYPEOBLIGATIONS::mkLetOrApply 
                                 (svref pV10731 1) 
                                 |!M|) 
                                gamma))) 
                          (TYPEOBLIGATIONS::subtypeRec 
                           pairs 
                           tcc 
                           gamma 
                           |!M| 
                           (svref pV10731 0) 
                           sigma))))) 
                 (return 
                  (block 
                   nil 
                   (if (eq (car sigma1) :|Subsort|) 
                       (let ((pV10726 (cdr sigma1))) 
                         (return 
                          (let ((tcc 
                                 (TYPEOBLIGATIONS::subtypeRec 
                                  pairs 
                                  tcc 
                                  gamma 
                                  |!M| 
                                  tau 
                                  (svref pV10726 0)))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::addCondition 
                                    tcc 
                                    gamma 
                                    (TYPEOBLIGATIONS::mkLetOrApply 
                                     (svref pV10726 1) 
                                     |!M|)))) tcc))))) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car tau1) :|Arrow|) 
                         (let ((pV10688 (cdr tau1))) 
                           (if (eq (car sigma1) :|Arrow|) 
                               (let ((pV10721 (cdr sigma1))) 
                                 (let ((pV10722 (svref pV10721 0))) 
                                   (return 
                                    (let ((x 
                                           (TYPEOBLIGATIONS::freshName gamma "x"))) 
                                      (let ((xVar 
                                             (cons 
                                              :|Var| 
                                              (cons 
                                               (cons x pV10722) 
                                               POSITION-SPEC::noPos)))) 
                                        (let ((gamma1 
                                               (TYPEOBLIGATIONS::insert 
                                                (cons x pV10722) 
                                                gamma))) 
                                          (let ((tcc 
                                                 (TYPEOBLIGATIONS::subtypeRec 
                                                  pairs 
                                                  tcc 
                                                  gamma1 
                                                  xVar 
                                                  pV10722 
                                                  (svref pV10688 0)))) 
                                            (let ((tcc 
                                                   (TYPEOBLIGATIONS::subtypeRec 
                                                    pairs 
                                                    tcc 
                                                    gamma1 
                                                    (TYPEOBLIGATIONS::mkLetOrApply 
                                                     |!M| 
                                                     xVar) 
                                                    (svref pV10688 1) 
                                                    (svref pV10721 1)))) tcc)))))))))) 
                         (if (eq (car tau1) :|Product|) 
                             (if (eq (car sigma1) :|Product|) 
                                 (return 
                                  (let ((tcc 
                                         (LISTPAIR::foldr-1-1-1 
                                          #'(lambda (x) 
                                             (let ((pV10654 (svref x 1))) 
                                               (block 
                                                nil 
                                                (let ((pV10657 (cdr (svref x 0)))) 
                                                  (return 
                                                   (TYPEOBLIGATIONS::subtypeRec 
                                                    pairs 
                                                    (svref x 2) 
                                                    gamma 
                                                    (cons 
                                                     :|Apply| 
                                                     (vector 
                                                      (cons 
                                                       :|Fun| 
                                                       (vector 
                                                        (cons 
                                                         :|Project| 
                                                         (car pV10654)) 
                                                        (cons 
                                                         :|Arrow| 
                                                         (vector 
                                                          sigma1 
                                                          pV10657 
                                                          POSITION-SPEC::noPos)) 
                                                        POSITION-SPEC::noPos)) 
                                                      |!M| 
                                                      POSITION-SPEC::noPos)) 
                                                    pV10657 
                                                    (cdr pV10654)))) 
                                                (error 
                                                 "Nonexhaustive match failure in subtypeRec")))) 
                                          tcc 
                                          (cons 
                                           (car (cdr tau1)) 
                                           (car (cdr sigma1)))))) tcc))) 
                             (if (eq (car tau1) :|CoProduct|) 
                                 (if (eq (car sigma1) :|CoProduct|) 
                                     (return 
                                      (let ((tcc 
                                             (LISTPAIR::foldr-1-1-1 
                                              #'(lambda (x) 
                                                 (let ((pV10670 (svref x 2))
                                                       (pV10669 (svref x 1))) 
                                                   (block 
                                                    nil 
                                                    (let ((pV10672 
                                                           (cdr (svref x 0)))) 
                                                      (let ((pV10674 
                                                             (cdr pV10669))
                                                            (pV10673 
                                                             (car pV10669))) 
                                                        (return 
                                                         (block 
                                                          nil 
                                                          (if (eq 
                                                               (car pV10672) 
                                                               :|Some|) 
                                                              (let ((pV10666 
                                                                     (cdr 
                                                                      pV10672))) 
                                                                (if (eq 
                                                                     (car 
                                                                      pV10674) 
                                                                     :|Some|) 
                                                                    (return 
                                                                     (let ((gamma 
                                                                            (TYPEOBLIGATIONS::assertCond 
                                                                             (cons 
                                                                              :|Apply| 
                                                                              (vector 
                                                                               (cons 
                                                                                :|Fun| 
                                                                                (vector 
                                                                                 (cons 
                                                                                  :|Embedded| 
                                                                                  pV10673) 
                                                                                 (cons 
                                                                                  :|Arrow| 
                                                                                  (vector 
                                                                                   sigma 
                                                                                   STANDARDSPEC::boolSort 
                                                                                   POSITION-SPEC::noPos)) 
                                                                                 POSITION-SPEC::noPos)) 
                                                                               |!M| 
                                                                               POSITION-SPEC::noPos)) 
                                                                             gamma))) 
                                                                       (TYPEOBLIGATIONS::subtypeRec 
                                                                        pairs 
                                                                        pV10670 
                                                                        gamma 
                                                                        (cons 
                                                                         :|Apply| 
                                                                         (vector 
                                                                          (cons 
                                                                           :|Fun| 
                                                                           (vector 
                                                                            (cons 
                                                                             :|Select| 
                                                                             pV10673) 
                                                                            (cons 
                                                                             :|Arrow| 
                                                                             (vector 
                                                                              sigma 
                                                                              pV10666 
                                                                              POSITION-SPEC::noPos)) 
                                                                            POSITION-SPEC::noPos)) 
                                                                          |!M| 
                                                                          POSITION-SPEC::noPos)) 
                                                                        pV10666 
                                                                        (cdr 
                                                                         pV10674)))))) 
                                                              (if (eq 
                                                                   (car pV10672) 
                                                                   :|None|) 
                                                                  (if (eq 
                                                                       (car 
                                                                        pV10674) 
                                                                       :|None|) 
                                                                      (return 
                                                                       pV10670)))) 
                                                          (return 
                                                           (SYSTEM-SPEC::fail 
                                                            "CoProduct mismatch")))))) 
                                                    (error 
                                                     "Nonexhaustive match failure in subtypeRec")))) 
                                              tcc 
                                              (cons 
                                               (car (cdr tau1)) 
                                               (car (cdr sigma1)))))) tcc))) 
                                 (if (eq (car tau1) :|Quotient|) 
                                     (if (eq (car sigma1) :|Quotient|) 
                                         (return tcc)) 
                                     (if (eq (car tau1) :|TyVar|) 
                                         (if (eq (car sigma1) :|TyVar|) 
                                             (return tcc)) 
                                         (if (eq (car tau1) :|Base|) 
                                             (let ((pV10683 (cdr tau1))) 
                                               (if (eq (car sigma1) :|Base|) 
                                                   (let ((pV10692 (cdr sigma1))) 
                                                     (return 
                                                      (if (slang-built-in::slang-term-equals 
                                                           (svref pV10683 0) 
                                                           (svref pV10692 0)) 
                                                          (let ((tcc 
                                                                 (LISTPAIR::foldr-1-1-1 
                                                                  #'(lambda (x) 
                                                                     (let ((tcc 
                                                                            (svref 
                                                                             x 
                                                                             2))
                                                                           (s2 
                                                                            (svref 
                                                                             x 
                                                                             1))
                                                                           (s1 
                                                                            (svref 
                                                                             x 
                                                                             0))) 
                                                                       (let ((x1 
                                                                              (TYPEOBLIGATIONS::freshName 
                                                                               gamma 
                                                                               "x"))) 
                                                                         (let ((gamma1 
                                                                                (TYPEOBLIGATIONS::insert 
                                                                                 (cons 
                                                                                  x1 
                                                                                  s1) 
                                                                                 gamma))) 
                                                                           (let ((gamma2 
                                                                                  (TYPEOBLIGATIONS::insert 
                                                                                   (cons 
                                                                                    x1 
                                                                                    s2) 
                                                                                   gamma))) 
                                                                             (let ((tcc 
                                                                                    (TYPEOBLIGATIONS::subtypeRec 
                                                                                     pairs 
                                                                                     tcc 
                                                                                     gamma1 
                                                                                     (cons 
                                                                                      :|Var| 
                                                                                      (cons 
                                                                                       (cons 
                                                                                        x1 
                                                                                        s1) 
                                                                                       POSITION-SPEC::noPos)) 
                                                                                     s1 
                                                                                     s2))) 
                                                                               (let ((tcc 
                                                                                      (TYPEOBLIGATIONS::subtypeRec 
                                                                                       pairs 
                                                                                       tcc 
                                                                                       gamma2 
                                                                                       (cons 
                                                                                        :|Var| 
                                                                                        (cons 
                                                                                         (cons 
                                                                                          x1 
                                                                                          s2) 
                                                                                         POSITION-SPEC::noPos)) 
                                                                                       s2 
                                                                                       s1))) 
                                                                                 tcc))))))) 
                                                                  tcc 
                                                                  (cons 
                                                                   (svref 
                                                                    pV10683 
                                                                    1) 
                                                                   (svref 
                                                                    pV10692 
                                                                    1))))) tcc) 
                                                          (TYPEOBLIGATIONS::addFailure 
                                                           tcc 
                                                           gamma 
                                                           (STRING-SPEC::^ 
                                                            (STRING-SPEC::^ 
                                                             (ANNSPECPRINTER::printSort 
                                                              tau) 
                                                             " could not be made subsort of ") 
                                                            (ANNSPECPRINTER::printSort 
                                                             sigma)))))))))))))) 
                     (error "Nonexhaustive match failure in subtypeRec"))))))))))))


(defun TYPEOBLIGATIONS::|!<=| (tcc gamma |!M| tau sigma) 
  (TYPEOBLIGATIONS::subtypeRec nil tcc gamma |!M| tau sigma))
                                                             
(defun TYPEOBLIGATIONS::\|- (pV10840 pV10841) 
  (block 
   nil 
   (let ((pV10843 (cdr pV10840))
         (pV10842 (car pV10840))) 
     (let ((pV10845 (cdr pV10841))
           (pV10844 (car pV10841))) 
       (return 
        (block 
         nil 
         (if (eq (car pV10844) :|Apply|) 
             (let ((pV10806 (cdr pV10844))) 
               (let ((pV10837 (svref pV10806 0))) 
                 (return 
                  (let ((spc (TYPEOBLIGATIONS::getSpec-1 pV10843))) 
                    (let ((sigma1 (SPECENVIRONMENT::inferType spc pV10837))) 
                      (let ((tcc 
                             (TYPEOBLIGATIONS::\|- 
                              (cons pV10842 pV10843) 
                              (TYPEOBLIGATIONS::?? pV10837 sigma1)))) 
                        (let ((tcc 
                               (TYPEOBLIGATIONS::\|- 
                                (cons tcc pV10843) 
                                (TYPEOBLIGATIONS::?? 
                                 (svref pV10806 1) 
                                 (SPECENVIRONMENT::domain spc sigma1))))) 
                          (let ((tau2 (SPECENVIRONMENT::range spc sigma1))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::|!<=| 
                                    tcc 
                                    pV10843 
                                    pV10844 
                                    tau2 
                                    pV10845))) tcc))))))))) 
             (if (eq (car pV10844) :|Record|) 
                 (let ((pV10835 (car (cdr pV10844)))) 
                   (return 
                    (let ((spc (TYPEOBLIGATIONS::getSpec-1 pV10843))) 
                      (let ((types (SPECENVIRONMENT::product spc pV10845))) 
                        (labels 
                          ((checkField (pV10748 pV10749 pV10750) 
                            (block 
                             nil 
                             (return 
                              (TYPEOBLIGATIONS::\|- 
                               (cons pV10750 pV10843) 
                               (TYPEOBLIGATIONS::?? (cdr pV10748) (cdr pV10749)))) 
                             (error "Nonexhaustive match failure in |-")))) 
                          (let ((tcc 
                                 (LISTPAIR::foldr-1-1-1 
                                  #'(lambda (x) 
                                     (checkField 
                                      (svref x 0) 
                                      (svref x 1) 
                                      (svref x 2))) 
                                  pV10842 
                                  (cons pV10835 types)))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::|!<=| 
                                    tcc 
                                    pV10843 
                                    pV10844 
                                    (cons 
                                     :|Product| 
                                     (cons types POSITION-SPEC::noPos)) 
                                    pV10845))) tcc))))))) 
                 (if (eq (car pV10844) :|Bind|) 
                     (let ((pV10804 (cdr pV10844))) 
                       (return 
                        (let ((gamma 
                               (LIST-SPEC::foldr-1-1-1 
                                #'TYPEOBLIGATIONS::insert-1 
                                pV10843 
                                (svref pV10804 1)))) 
                          (let ((tcc 
                                 (TYPEOBLIGATIONS::\|- 
                                  (cons pV10842 gamma) 
                                  (TYPEOBLIGATIONS::?? 
                                   (svref pV10804 2) 
                                   STANDARDSPEC::boolSort)))) 
                            (let ((tcc 
                                   (TYPEOBLIGATIONS::|!<=| 
                                    tcc 
                                    gamma 
                                    pV10844 
                                    STANDARDSPEC::boolSort 
                                    pV10845))) tcc))))) 
                     (if (eq (car pV10844) :|Let|) 
                         (return pV10842) 
                         (if (eq (car pV10844) :|LetRec|) 
                             (return pV10842) 
                             (if (eq (car pV10844) :|Var|) 
                                 (return 
                                  (let ((tcc 
                                         (TYPEOBLIGATIONS::|!<=| 
                                          pV10842 
                                          pV10843 
                                          pV10844 
                                          (cdr (car (cdr pV10844))) 
                                          pV10845))) tcc)) 
                                 (if (eq (car pV10844) :|Fun|) 
                                     (let ((pV10800 (cdr pV10844))) 
                                       (let ((pV10818 (svref pV10800 0))) 
                                         (return 
                                          (let ((tcc 
                                                 (TYPEOBLIGATIONS::|!<=| 
                                                  pV10842 
                                                  pV10843 
                                                  pV10844 
                                                  (svref pV10800 1) 
                                                  pV10845))) 
                                            (block 
                                             nil 
                                             (if (eq (car pV10818) :|Equals|) 
                                                 (return tcc) 
                                                 (if (eq 
                                                      (car pV10818) 
                                                      :|Quotient|) 
                                                     (return tcc) 
                                                     (if (eq 
                                                          (car pV10818) 
                                                          :|Choose|) 
                                                         (return tcc) 
                                                         (if (eq 
                                                              (car pV10818) 
                                                              :|Restrict|) 
                                                             (return tcc) 
                                                             (if (eq 
                                                                  (car pV10818) 
                                                                  :|Relax|) 
                                                                 (return tcc) 
                                                                 (if (eq 
                                                                      (car 
                                                                       pV10818) 
                                                                      :|Op|) 
                                                                     (return tcc) 
                                                                     (if (eq 
                                                                          (car 
                                                                           pV10818) 
                                                                          :|Project|) 
                                                                         (return 
                                                                          tcc) 
                                                                         (if (eq 
                                                                              (car 
                                                                               pV10818) 
                                                                              :|Embed|) 
                                                                             (return 
                                                                              tcc) 
                                                                             (if (eq 
                                                                                  (car 
                                                                                   pV10818) 
                                                                                  :|Embedded|) 
                                                                                 (return 
                                                                                  tcc) 
                                                                                 (if (eq 
                                                                                      (car 
                                                                                       pV10818) 
                                                                                      :|Select|) 
                                                                                     (return 
                                                                                      tcc) 
                                                                                     (if (eq 
                                                                                          (car 
                                                                                           pV10818) 
                                                                                          :|Nat|) 
                                                                                         (return 
                                                                                          tcc) 
                                                                                         (if (eq 
                                                                                              (car 
                                                                                               pV10818) 
                                                                                              :|Char|) 
                                                                                             (return 
                                                                                              tcc) 
                                                                                             (if (eq 
                                                                                                  (car 
                                                                                                   pV10818) 
                                                                                                  :|String|) 
                                                                                                 (return 
                                                                                                  tcc) 
                                                                                                 (if (eq 
                                                                                                      (car 
                                                                                                       pV10818) 
                                                                                                      :|Bool|) 
                                                                                                     (return 
                                                                                                      tcc))))))))))))))) 
                                             (error 
                                              "Nonexhaustive match failure in |-")))))) 
                                     (if (eq (car pV10844) :|Lambda|) 
                                         (let ((pV10816 (car (cdr pV10844)))) 
                                           (return 
                                            (let ((dom 
                                                   (SPECENVIRONMENT::domain 
                                                    (TYPEOBLIGATIONS::getSpec-1 
                                                     pV10843) 
                                                    pV10845))) 
                                              (let ((rng 
                                                     (SPECENVIRONMENT::range 
                                                      (TYPEOBLIGATIONS::getSpec-1 
                                                       pV10843) 
                                                      pV10845))) 
                                                (let ((tcc 
                                                       (LIST-SPEC::foldr-1-1-1 
                                                        (TYPEOBLIGATIONS::checkRule 
                                                         pV10843 
                                                         dom 
                                                         rng) 
                                                        pV10842 
                                                        pV10816))) 
                                                  (let ((rules 
                                                         (LIST-SPEC::|!map|-1-1 
                                                          #'(lambda (x) 
                                                             (vector 
                                                              (cons 
                                                               (svref x 0) 
                                                               nil) 
                                                              (svref x 1) 
                                                              (STANDARDSPEC::mkTrue))) 
                                                          pV10816))) 
                                                    (let ((x 
                                                           (TYPEOBLIGATIONS::freshName 
                                                            pV10843 
                                                            "x"))) 
                                                      (block 
                                                       nil 
                                                       (return 
                                                        (let ((context 
                                                               (vector 
                                                                (cons :|Ref| 0) 
                                                                (svref pV10843 3) 
                                                                (svref pV10843 2) 
                                                                '(:|None|)))) 
                                                          (let ((trm 
                                                                 (PATTERNMATCH::match 
                                                                  context 
                                                                  (cons 
                                                                   (cons 
                                                                    :|Var| 
                                                                    (cons 
                                                                     (cons x dom) 
                                                                     POSITION-SPEC::noPos)) 
                                                                   nil) 
                                                                  rules 
                                                                  (STANDARDSPEC::mkFalse) 
                                                                  (STANDARDSPEC::mkFalse)))) 
                                                            (let ((pV10780 
                                                                   (TYPEOBLIGATIONS::simplifyMatch 
                                                                    trm))) 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car pV10780) 
                                                                    :|Fun|) 
                                                                   (let ((pV10782 
                                                                          (svref 
                                                                           (cdr 
                                                                            pV10780) 
                                                                           0))) 
                                                                     (if (eq 
                                                                          (car 
                                                                           pV10782) 
                                                                          :|Bool|) 
                                                                         (if (eq 
                                                                              t 
                                                                              (cdr 
                                                                               pV10782)) 
                                                                             (return 
                                                                              tcc))))) 
                                                               (return 
                                                                (TYPEOBLIGATIONS::addCondition 
                                                                 tcc 
                                                                 pV10843 
                                                                 (STANDARDSPEC::mkBind 
                                                                  '(:|Forall|) 
                                                                  (cons 
                                                                   (cons x dom) 
                                                                   nil) 
                                                                  pV10780)))))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in |-"))))))))) 
                                         (if (eq (car pV10844) :|IfThenElse|) 
                                             (let ((pV10798 (cdr pV10844))) 
                                               (let ((pV10812 (svref pV10798 0))) 
                                                 (return 
                                                  (let ((tcc1 
                                                         (TYPEOBLIGATIONS::\|- 
                                                          (cons pV10842 pV10843) 
                                                          (TYPEOBLIGATIONS::?? 
                                                           pV10812 
                                                           STANDARDSPEC::boolSort)))) 
                                                    (let ((gamma1 
                                                           (TYPEOBLIGATIONS::assertCond 
                                                            pV10812 
                                                            pV10843))) 
                                                      (let ((tcc2 
                                                             (TYPEOBLIGATIONS::\|- 
                                                              (cons tcc1 gamma1) 
                                                              (TYPEOBLIGATIONS::?? 
                                                               (svref pV10798 1) 
                                                               pV10845)))) 
                                                        (let ((gamma2 
                                                               (TYPEOBLIGATIONS::assertCond 
                                                                (STANDARDSPEC::mkNot 
                                                                 pV10812) 
                                                                pV10843))) 
                                                          (let ((tcc3 
                                                                 (TYPEOBLIGATIONS::\|- 
                                                                  (cons 
                                                                   tcc2 
                                                                   gamma2) 
                                                                  (TYPEOBLIGATIONS::?? 
                                                                   (svref 
                                                                    pV10798 
                                                                    2) 
                                                                   pV10845)))) 
                                                            tcc3)))))))) 
                                             (if (eq (car pV10844) :|Seq|) 
                                                 (let ((pV10807 
                                                        (car (cdr pV10844)))) 
                                                   (if (null pV10807) 
                                                       (return pV10842) 
                                                       (if (consp pV10807) 
                                                           (let ((pV10811 
                                                                  (cdr pV10807))
                                                                 (pV10810 
                                                                  (car pV10807))) 
                                                             (progn (if (null 
                                                                         pV10811) 
                                                                        (return 
                                                                         (TYPEOBLIGATIONS::\|- 
                                                                          (cons 
                                                                           pV10842 
                                                                           pV10843) 
                                                                          (cons 
                                                                           pV10810 
                                                                           pV10845)))) 
                                                                    (return 
                                                                     (let ((sigma 
                                                                            (SPECENVIRONMENT::inferType 
                                                                             (TYPEOBLIGATIONS::getSpec-1 
                                                                              pV10843) 
                                                                             pV10810))) 
                                                                       (let ((tcc 
                                                                              (TYPEOBLIGATIONS::\|- 
                                                                               (cons 
                                                                                pV10842 
                                                                                pV10843) 
                                                                               (TYPEOBLIGATIONS::?? 
                                                                                pV10810 
                                                                                sigma)))) 
                                                                         (let ((tcc 
                                                                                (TYPEOBLIGATIONS::\|- 
                                                                                 (cons 
                                                                                  tcc 
                                                                                  pV10843) 
                                                                                 (TYPEOBLIGATIONS::?? 
                                                                                  (cons 
                                                                                   :|Seq| 
                                                                                   (cons 
                                                                                    pV10811 
                                                                                    POSITION-SPEC::noPos)) 
                                                                                  pV10845)))) 
                                                                           tcc))))))))))))))))))) 
         (error "Nonexhaustive match failure in |-"))))) 
   (error "Nonexhaustive match failure in |-")))
                                                
(defun TYPEOBLIGATIONS::checkSpec-1 (spc) 
  (let ((localOps (svref (svref spc 0) 2))) 
    (let ((names 
           (STRINGSET::fromList 
            (LIST-SPEC::|!map|-1-1 
             #'(lambda (pV10453) 
                (block 
                 nil 
                 (if (eq (car pV10453) :|Qualified|) 
                     (return (cdr (cdr pV10453)))) 
                 (error "Nonexhaustive match failure in checkSpec"))) 
             localOps)))) 
      (let ((gamma0 
             #'(lambda (tvs) #'(lambda (nm) (vector nil tvs spc nm names))))) 
        (let ((tcc 
               (STRINGMAP::foldriDouble-1-1-1 
                #'(lambda (x) 
                   (let ((pV10462 (svref x 3))
                         (pV10461 (svref x 2))
                         (pV10460 (svref x 1))) 
                     (block 
                      nil 
                      (let ((pV10466 (svref pV10461 3))
                            (pV10465 (svref pV10461 2))) 
                        (return 
                         (if (LIST-SPEC::|!member| 
                              (cons :|Qualified| (cons (svref x 0) pV10460)) 
                              localOps) 
                             (block 
                              nil 
                              (if (eq (car pV10466) :|Some|) 
                                  (return 
                                   (TYPEOBLIGATIONS::\|- 
                                    (cons 
                                     pV10462 
                                     (funcall (funcall gamma0 (car pV10465)) 
                                              pV10460)) 
                                    (TYPEOBLIGATIONS::?? 
                                     (cdr pV10466) 
                                     (cdr pV10465)))) 
                                  (if (eq (car pV10466) :|None|) 
                                      (return pV10462))) 
                              (error "Nonexhaustive match failure in checkSpec")) 
                             pV10462))) 
                      (error "Nonexhaustive match failure in checkSpec")))) 
                nil 
                (svref spc 1)))) tcc)))))
                                         
(defun TYPEOBLIGATIONS::makeTypeCheckObligationSpec (spc spcRef) 
  (let ((tcSpec (addImport (cons spcRef spc) emptySpec))) 
    (addConjectures (TYPEOBLIGATIONS::checkSpec-1 spc) tcSpec)))
                                                                
(defun SPECCALC::specObligations (spc spcTerm) 
  (TYPEOBLIGATIONS::makeTypeCheckObligationSpec 
   spc 
   (SPECCALC::showTerm-1 spcTerm)))
                                   
(defun SPECCALC::evaluateObligations-1 (term) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 term) 
   #'(lambda (x) 
      (let ((dep_URIs (svref x 2))
            (time_stamp (svref x 1))
            (value (svref x 0))) 
        (block 
         nil 
         (if (eq (car value) :|Spec|) 
             (return 
              (let ((ob_spec (SPECCALC::specObligations (cdr value) term))) 
                (SPECCALC::|!return| 
                 (vector 
                  (cons 
                   :|Spec| 
                   (vector 
                    (svref ob_spec 0) 
                    (svref ob_spec 1) 
                    (svref ob_spec 2) 
                    (svref ob_spec 3))) 
                  time_stamp 
                  dep_URIs)))) 
             (if (eq (car value) :|Morph|) 
                 (let ((pV5306 (cdr value))) 
                   (return 
                    (SPECCALC::monadBind 
                     #'SPECCALC::getGlobalContext-1 
                     #'(lambda (globalContext) 
                        (let ((ob_spec 
                               (SPECCALC::morphismObligations 
                                pV5306 
                                globalContext))) 
                          (SPECCALC::|!return| 
                           (vector 
                            (cons 
                             :|Spec| 
                             (vector 
                              (svref ob_spec 0) 
                              (svref ob_spec 1) 
                              (svref ob_spec 2) 
                              (svref ob_spec 3))) 
                            time_stamp 
                            dep_URIs))))))))) 
         (return 
          (SPECCALC::raise 
           (cons 
            :|Unsupported| 
            (cons 
             (SPECCALC::positionOf-1 term) 
             "Can create obligations for Specs and Morphisms only")))))))))
                                                                           
(defun SPECCALC::printSpec-1-1-1 (base_spec reverse_context spc) 
  (PRETTYPRINT::toString 
   (PRETTYPRINT::|!format| 
    80 
    (ANNSPECPRINTER::ppSpecHidingImportedStuff-1-1-1 
     (ANNSPECPRINTER::initialize ANNTERMPRINTER::asciiPrinter nil) 
     base_spec 
     spc))))
            
(defun SPECCALC::printColimit-1-1-1 (base_spec reverse_context col) 
  (SPECCALC::printSpec-1-1-1 
   base_spec 
   reverse_context 
   (CAT::apex-1 (CAT::cocone-1 col))))
                                      
(defun SPECCALC::ppMorphismMap (pV6569 pV6570 opMap sortMap) 
  (declare (ignore pV6569 pV6570)) 
  (labels 
    ((ppAbbrevMap (|!keyword|) 
      #'(lambda (|!map|) 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (lst) 
             #'(lambda (dom) 
                #'(lambda (cod) 
                   (cons 
                    (WADLERLINDIG::ppGroup 
                     (WADLERLINDIG::ppConcat 
                      (cons 
                       (WADLERLINDIG::ppString |!keyword|) 
                       (cons 
                        (SPECCALC::ppQualifiedId dom) 
                        (cons 
                         WADLERLINDIG::ppBreak 
                         (cons 
                          (WADLERLINDIG::ppString "+->") 
                          (cons 
                           WADLERLINDIG::ppBreak 
                           (cons (SPECCALC::ppQualifiedId cod) nil)))))))) 
                    lst)))) 
          nil 
          (abbrevMap |!map|))))
     (abbrevMap (|!map|) 
      (POLYMAP::foldMap-1-1-1 
       #'(lambda (newMap) 
          #'(lambda (d) 
             #'(lambda (c) 
                (if (slang-built-in::slang-term-equals d c) 
                    newMap 
                    (POLYMAP::update-1-1-1 newMap d c))))) 
       POLYMAP::emptyMap 
       |!map|))) 
    (WADLERLINDIG::ppGroup 
     (WADLERLINDIG::ppConcat 
      (let ((pV6571 
             (LIST-SPEC::|!++| 
              (funcall (ppAbbrevMap "sort ") sortMap) 
              (funcall (ppAbbrevMap "op ") opMap)))) 
        (block 
         nil 
         (if (null pV6571) 
             (return 
              (cons 
               WADLERLINDIG::ppBreak 
               (cons (WADLERLINDIG::ppString "{}") nil)))) 
         (return 
          (cons 
           WADLERLINDIG::ppBreak 
           (cons 
            (WADLERLINDIG::ppString "{") 
            (cons 
             (WADLERLINDIG::ppNest-1-1 
              1 
              (WADLERLINDIG::ppSep-1-1 
               (WADLERLINDIG::ppCons-1-1 
                (WADLERLINDIG::ppString ",") 
                WADLERLINDIG::ppBreak) 
               pV6571)) 
             (cons (WADLERLINDIG::ppString "}") nil)))))))))))
                                                              
(defun SPECCALC::ppMorphismMap-1 (x) 
  (SPECCALC::ppMorphismMap (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                            
(defun SPECCALC::uriToString (hashSuffix path) 
  (let ((path (SPECCALC::abbreviatedPath path))) 
    (let ((tildaPath? (string=  (LIST-SPEC::hd path) "~"))) 
      (let ((mainPath 
             (STRING-SPEC::concatList 
              (LIST-SPEC::foldr-1-1-1 
               #'(lambda (x) 
                  (LIST-SPEC::|!cons| "/" (LIST-SPEC::|!cons| (car x) (cdr x)))) 
               nil 
               (if tildaPath? (LIST-SPEC::tl path) path))))) 
        (let ((|!fileName| 
               (if tildaPath? (STRING-SPEC::^ "~" mainPath) mainPath))) 
          (block 
           nil 
           (if (eq (car hashSuffix) :|None|) 
               (return |!fileName|) 
               (if (eq (car hashSuffix) :|Some|) 
                   (let ((pV7032 (cdr hashSuffix))) 
                     (return 
                      (if (string=  |!fileName| "") 
                          pV7032 
                          (STRING-SPEC::^ 
                           (STRING-SPEC::^ |!fileName| "#") 
                           pV7032)))))) 
           (error "Nonexhaustive match failure in uriToString")))))))
                                                                     
(defun SPECCALC::uriToString-1 (x) (SPECCALC::uriToString (car x) (cdr x)))
                                                                           
(defun SPECCALC::relativeURI_ToString (rel_uri) 
  (block 
   nil 
   (if (eq (car rel_uri) :|URI_Relative|) 
       (let ((pV6779 (cdr rel_uri))) 
         (let ((pV6781 (cdr pV6779))
               (pV6780 (car pV6779))) 
           (return 
            (let ((filename 
                   (block 
                    nil 
                    (if (null pV6781) (return "")) 
                    (return 
                     (STRING-SPEC::concatList 
                      (LIST-SPEC::tl 
                       (LIST-SPEC::foldr-1-1-1 
                        #'(lambda (x) 
                           (LIST-SPEC::|!cons| 
                            "/" 
                            (LIST-SPEC::|!cons| (car x) (cdr x)))) 
                        nil 
                        pV6781))))))) 
              (block 
               nil 
               (if (eq (car pV6780) :|None|) 
                   (return filename) 
                   (if (eq (car pV6780) :|Some|) 
                       (let ((pV6776 (cdr pV6780))) 
                         (return 
                          (if (string=  filename "") 
                              pV6776 
                              (STRING-SPEC::^ 
                               (STRING-SPEC::^ filename "#") 
                               pV6776)))))) 
               (error "Nonexhaustive match failure in relativeURI_ToString")))))) 
       (if (eq (car rel_uri) :|SpecPath_Relative|) 
           (return (SPECCALC::uriToString-1 (cdr rel_uri))))) 
   (error "Nonexhaustive match failure in relativeURI_ToString")))
                                                                  
(defun SPECCALC::ppMorphismX-1-1-1 (base_spec reverse_context sm) 
  (let ((dom_spec (SPECCALC::dom-1 sm))) 
    (let ((cod_spec (SPECCALC::cod-1 sm))) 
      (let ((str_1 
             (WADLERLINDIG::ppFormat 
              (WADLERLINDIG::ppGroup 
               (WADLERLINDIG::ppConcat 
                (cons 
                 (WADLERLINDIG::ppString "morphism") 
                 (cons 
                  (WADLERLINDIG::ppNest-1-1 
                   4 
                   (WADLERLINDIG::ppGroup 
                    (WADLERLINDIG::ppConcat 
                     (cons 
                      WADLERLINDIG::ppBreak 
                      (cons 
                       (WADLERLINDIG::ppString 
                        (let ((pV6572 
                               (POLYMAP::evalPartial-1-1 
                                reverse_context 
                                (cons 
                                 :|Spec| 
                                 (vector 
                                  (svref dom_spec 0) 
                                  (svref dom_spec 1) 
                                  (svref dom_spec 2) 
                                  (svref dom_spec 3)))))) 
                          (block 
                           nil 
                           (if (eq (car pV6572) :|Some|) 
                               (return 
                                (SPECCALC::relativeURI_ToString (cdr pV6572))) 
                               (if (eq (car pV6572) :|None|) 
                                   (return 
                                    (SPECCALC::printSpec-1-1-1 
                                     base_spec 
                                     reverse_context 
                                     dom_spec)))) 
                           (error "Nonexhaustive match failure in ppMorphismX")))) 
                       (cons 
                        WADLERLINDIG::ppBreak 
                        (cons 
                         (WADLERLINDIG::ppString "->") 
                         (cons 
                          WADLERLINDIG::ppBreak 
                          (cons 
                           (WADLERLINDIG::ppString 
                            (let ((pV6574 
                                   (POLYMAP::evalPartial-1-1 
                                    reverse_context 
                                    (cons 
                                     :|Spec| 
                                     (vector 
                                      (svref cod_spec 0) 
                                      (svref cod_spec 1) 
                                      (svref cod_spec 2) 
                                      (svref cod_spec 3)))))) 
                              (block 
                               nil 
                               (if (eq (car pV6574) :|Some|) 
                                   (return 
                                    (SPECCALC::relativeURI_ToString (cdr pV6574))) 
                                   (if (eq (car pV6574) :|None|) 
                                       (return 
                                        (SPECCALC::printSpec-1-1-1 
                                         base_spec 
                                         reverse_context 
                                         cod_spec)))) 
                               (error 
                                "Nonexhaustive match failure in ppMorphismX")))) 
                           nil))))))))) 
                  nil))))))) 
        (WADLERLINDIG::ppGroup 
         (WADLERLINDIG::ppConcat 
          (cons 
           (WADLERLINDIG::ppString str_1) 
           (cons (WADLERLINDIG::ppNest-1-1 4 (SPECCALC::ppMorphismMap-1 sm)) nil))))))))


(defun SPECCALC::printDiagram-1-1-1 (base_spec reverse_context dg) 
  (let ((shape (CAT::shape-1 dg))) 
    (let ((vertice_set (SKETCH::vertices-1 shape))) 
      (let ((edge_set (SKETCH::edges-1 shape))) 
        (let ((src_map (SKETCH::src-1 shape))) 
          (let ((target_map (SKETCH::target-1 shape))) 
            (let ((functor (CAT::functor-1 dg))) 
              (let ((vertex_map (FUNCTOR::vertexMap-1 functor))) 
                (let ((edge_map (FUNCTOR::edgeMap-1 functor))) 
                  (let ((linked_vertices 
                         (EDGE::fold-1-1-1 
                          #'(lambda (linked_vertices) 
                             #'(lambda (edge) 
                                (let ((src (SKETCH::|!eval|-1-1 src_map edge))) 
                                  (let ((tgt 
                                         (SKETCH::|!eval|-1-1 target_map edge))) 
                                    (cons src (cons tgt linked_vertices)))))) 
                          nil 
                          edge_set))) 
                    (let ((isolated_vertices 
                           (VERTEX::fold-1-1-1 
                            #'(lambda (isolated_vertices) 
                               #'(lambda (vertice) 
                                  (if (LIST-SPEC::|!member| 
                                       vertice 
                                       linked_vertices) 
                                      isolated_vertices 
                                      (cons vertice isolated_vertices)))) 
                            nil 
                            vertice_set))) 
                      (let ((pp_vertice_entries 
                             (LIST-SPEC::foldl-1-1-1 
                              #'(lambda (x) 
                                 (let ((vertex (car x))) 
                                   (cons 
                                    (WADLERLINDIG::ppGroup 
                                     (WADLERLINDIG::ppConcat 
                                      (cons 
                                       (VERTEX::ppElem vertex) 
                                       (cons 
                                        WADLERLINDIG::ppBreak 
                                        (cons 
                                         (WADLERLINDIG::ppString "+->") 
                                         (cons 
                                          WADLERLINDIG::ppBreak 
                                          (cons 
                                           (let ((spc 
                                                  (POLYMAP::|!eval|-1-1 
                                                   vertex_map 
                                                   vertex))) 
                                             (WADLERLINDIG::ppString 
                                              (let ((pV6705 
                                                     (POLYMAP::evalPartial-1-1 
                                                      reverse_context 
                                                      (cons 
                                                       :|Spec| 
                                                       (vector 
                                                        (svref spc 0) 
                                                        (svref spc 1) 
                                                        (svref spc 2) 
                                                        (svref spc 3)))))) 
                                                (block 
                                                 nil 
                                                 (if (eq (car pV6705) :|Some|) 
                                                     (return 
                                                      (SPECCALC::relativeURI_ToString 
                                                       (cdr pV6705))) 
                                                     (if (eq 
                                                          (car pV6705) 
                                                          :|None|) 
                                                         (return 
                                                          (SPECCALC::printSpec-1-1-1 
                                                           base_spec 
                                                           reverse_context 
                                                           spc)))) 
                                                 (error 
                                                  "Nonexhaustive match failure in printDiagram"))))) 
                                           nil))))))) 
                                    (cdr x)))) 
                              nil 
                              isolated_vertices))) 
                        (let ((pp_edge_entries 
                               (EDGE::fold-1-1-1 
                                #'(lambda (pp_entries) 
                                   #'(lambda (edge) 
                                      (cons 
                                       (WADLERLINDIG::ppGroup 
                                        (WADLERLINDIG::ppConcat 
                                         (cons 
                                          (WADLERLINDIG::ppGroup 
                                           (WADLERLINDIG::ppConcat 
                                            (cons 
                                             (EDGE::ppElem edge) 
                                             (cons 
                                              WADLERLINDIG::ppBreak 
                                              (cons 
                                               (WADLERLINDIG::ppString ":") 
                                               (cons 
                                                WADLERLINDIG::ppBreak 
                                                (cons 
                                                 (VERTEX::ppElem 
                                                  (SKETCH::|!eval|-1-1 
                                                   src_map 
                                                   edge)) 
                                                 (cons 
                                                  WADLERLINDIG::ppBreak 
                                                  (cons 
                                                   (WADLERLINDIG::ppString "->") 
                                                   (cons 
                                                    WADLERLINDIG::ppBreak 
                                                    (cons 
                                                     (VERTEX::ppElem 
                                                      (SKETCH::|!eval|-1-1 
                                                       target_map 
                                                       edge)) 
                                                     nil))))))))))) 
                                          (cons 
                                           WADLERLINDIG::ppBreak 
                                           (cons 
                                            (WADLERLINDIG::ppString "+->") 
                                            (cons 
                                             WADLERLINDIG::ppBreak 
                                             (cons 
                                              (let ((sm 
                                                     (POLYMAP::|!eval|-1-1 
                                                      edge_map 
                                                      edge))) 
                                                (let ((pV6707 
                                                       (POLYMAP::evalPartial-1-1 
                                                        reverse_context 
                                                        (cons 
                                                         :|Morph| 
                                                         (vector 
                                                          (svref sm 0) 
                                                          (svref sm 1) 
                                                          (svref sm 2) 
                                                          (svref sm 3)))))) 
                                                  (block 
                                                   nil 
                                                   (if (eq (car pV6707) :|Some|) 
                                                       (return 
                                                        (WADLERLINDIG::ppString 
                                                         (SPECCALC::relativeURI_ToString 
                                                          (cdr pV6707)))) 
                                                       (if (eq 
                                                            (car pV6707) 
                                                            :|None|) 
                                                           (return 
                                                            (SPECCALC::ppMorphismX-1-1-1 
                                                             base_spec 
                                                             reverse_context 
                                                             sm)))) 
                                                   (error 
                                                    "Nonexhaustive match failure in printDiagram")))) 
                                              nil))))))) 
                                       pp_entries))) 
                                nil 
                                edge_set))) 
                          (WADLERLINDIG::ppFormat 
                           (WADLERLINDIG::ppGroup 
                            (WADLERLINDIG::ppConcat 
                             (cons 
                              (WADLERLINDIG::ppString "diagram {") 
                              (cons 
                               (WADLERLINDIG::ppNest-1-1 
                                9 
                                (WADLERLINDIG::ppSep-1-1 
                                 (WADLERLINDIG::ppCons-1-1 
                                  (WADLERLINDIG::ppString ",") 
                                  WADLERLINDIG::ppBreak) 
                                 (LIST-SPEC::|!++| 
                                  pp_vertice_entries 
                                  pp_edge_entries))) 
                               (cons (WADLERLINDIG::ppString "}") nil)))))))))))))))))))


(defun SPECCALC::printMorphism-1-1-1 (base_spec reverse_context sm) 
  (WADLERLINDIG::ppFormat 
   (SPECCALC::ppMorphismX-1-1-1 base_spec reverse_context sm)))
                                                               
(defun SPECCALC::relativizePath-1-1 (base target) 
  (labels 
    ((removeCommonPrefix (base target) 
      (block 
       nil 
       (if (null base) (return target)) 
       (if (null target) (return (addUpLinks base nil))) 
       (if (consp base) 
           (let ((pV6791 (cdr base))) 
             (if (consp target) 
                 (return 
                  (if (string=  (car base) (car target)) 
                      (removeCommonPrefix pV6791 (cdr target)) 
                      (addUpLinks pV6791 target)))))) 
       (error "Nonexhaustive match failure in relativizePath")))
     (addUpLinks (base target) 
      (block 
       nil 
       (if (null base) 
           (return target) 
           (if (consp base) 
               (return (LIST-SPEC::|!cons| ".." (addUpLinks (cdr base) target))))) 
       (error "Nonexhaustive match failure in relativizePath")))) 
    (removeCommonPrefix base target)))
                                      
(defun SPECCALC::relativizeURI-1-1 (base target) 
  (cons 
   :|URI_Relative| 
   (cons (car target) (SPECCALC::relativizePath-1-1 (cdr base) (cdr target)))))
                                                                               
(defun SPECCALC::evaluatePrint-1 (term) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 term) 
   #'(lambda (x) 
      (let ((dep_URIs (svref x 2))
            (time_stamp (svref x 1))
            (value (svref x 0))) 
        (SPECCALC::monadBind 
         (SPECCALC::pathToRelativeURI "/Library/Base") 
         #'(lambda (base_URI) 
            (SPECCALC::monadBind 
             (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) base_URI) 
             #'(lambda (x1) 
                (let ((pV5315 (svref x1 0))) 
                  (block 
                   nil 
                   (if (eq (car pV5315) :|Spec|) 
                       (let ((pV5318 (cdr pV5315))) 
                         (return 
                          (SPECCALC::monadBind 
                           #'SPECCALC::getGlobalContext-1 
                           #'(lambda (global_context) 
                              (SPECCALC::monadBind 
                               #'SPECCALC::getCurrentURI-1 
                               #'(lambda (current_URI) 
                                  (SPECCALC::monadBind 
                                   (SPECCALC::|!return| 
                                    (LIST-SPEC::foldr-1-1-1 
                                     #'(lambda (x11) 
                                        (let ((uri (car x11))) 
                                          (POLYMAP::update-1-1-1 
                                           (cdr x11) 
                                           (svref 
                                            (POLYMAP::|!eval|-1-1 
                                             global_context 
                                             uri) 
                                            0) 
                                           (SPECCALC::relativizeURI-1-1 
                                            current_URI 
                                            uri)))) 
                                     POLYMAP::emptyMap 
                                     dep_URIs)) 
                                   #'(lambda (reverse_context) 
                                      (SPECCALC::monadSeq 
                                       (SPECCALC::|!print| "
") 
                                       (SPECCALC::monadSeq 
                                        (block 
                                         nil 
                                         (if (eq (car value) :|Spec|) 
                                             (return 
                                              (SPECCALC::|!print| 
                                               (SPECCALC::printSpec-1-1-1 
                                                pV5318 
                                                reverse_context 
                                                (cdr value)))) 
                                             (if (eq (car value) :|Morph|) 
                                                 (return 
                                                  (SPECCALC::|!print| 
                                                   (SPECCALC::printMorphism-1-1-1 
                                                    pV5318 
                                                    reverse_context 
                                                    (cdr value)))) 
                                                 (if (eq (car value) :|Diag|) 
                                                     (return 
                                                      (SPECCALC::|!print| 
                                                       (SPECCALC::printDiagram-1-1-1 
                                                        pV5318 
                                                        reverse_context 
                                                        (cdr value)))) 
                                                     (if (eq 
                                                          (car value) 
                                                          :|Colimit|) 
                                                         (return 
                                                          (SPECCALC::|!print| 
                                                           (SPECCALC::printColimit-1-1-1 
                                                            pV5318 
                                                            reverse_context 
                                                            (cdr value)))) 
                                                         (if (eq 
                                                              (car value) 
                                                              :|InProcess|) 
                                                             (return 
                                                              (SPECCALC::|!print| 
                                                               "No value!"))))))) 
                                         (error 
                                          "Nonexhaustive match failure in evaluatePrint")) 
                                        (SPECCALC::monadSeq 
                                         (SPECCALC::|!print| "
") 
                                         (SPECCALC::|!return| 
                                          (vector value time_stamp dep_URIs)))))))))))))) 
                   (error "Nonexhaustive match failure in evaluatePrint")))))))))))


(defun SPECCALC::makeSnarkProveEvalForm
 (prover_options 
  snarkSortDecl 
  snarkOpDecls 
  snarkBaseHypothesis 
  snarkHypothesis 
  snarkConjecture 
  snarkLogFileName) 
  (LISP-SPEC::|!list| 
   (cons 
    (LISP-SPEC::|!symbol| "CL-USER" "WITH-OPEN-FILE") 
    (cons 
     (LISP-SPEC::|!list| 
      (cons 
       (LISP-SPEC::|!symbol| "CL-USER" "LOGFILE") 
       (cons 
        (LISP-SPEC::|!string| snarkLogFileName) 
        (cons 
         (LISP-SPEC::|!symbol| "KEYWORD" "DIRECTION") 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "OUTPUT") 
          (cons 
           (LISP-SPEC::|!symbol| "KEYWORD" "IF-EXISTS") 
           (cons (LISP-SPEC::|!symbol| "KEYWORD" "SUPERSEDE") nil))))))) 
     (cons 
      (LISP-SPEC::|!++| 
       (LISP-SPEC::|!++| 
        (LISP-SPEC::|!++| 
         (LISP-SPEC::|!++| 
          (LISP-SPEC::|!++| 
           (LISP-SPEC::|!++| 
            (LISP-SPEC::|!++| 
             (LISP-SPEC::|!list| 
              (cons 
               (LISP-SPEC::|!symbol| "LISP" "LET") 
               (cons 
                (LISP-SPEC::|!list| 
                 (cons 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| "CL-USER" "*ERROR-OUTPUT*") 
                    (cons (LISP-SPEC::|!symbol| "CL-USER" "LOGFILE") nil))) 
                  (cons 
                   (LISP-SPEC::|!list| 
                    (cons 
                     (LISP-SPEC::|!symbol| "CL-USER" "*STANDARD-OUTPUT*") 
                     (cons (LISP-SPEC::|!symbol| "CL-USER" "LOGFILE") nil))) 
                   nil))) 
                (cons 
                 (LISP-SPEC::|!list| 
                  (cons (LISP-SPEC::|!symbol| "SNARK" "INITIALIZE") nil)) 
                 (cons 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| "SNARK" "RUN-TIME-LIMIT") 
                    (cons (LISP-SPEC::|!nat| 60) nil))) 
                  (cons 
                   (LISP-SPEC::|!list| 
                    (cons 
                     (LISP-SPEC::|!symbol| "SNARK" "USE-LISP-TYPES-AS-SORTS") 
                     (cons (LISP-SPEC::bool t) nil))) 
                   (cons 
                    (LISP-SPEC::|!list| 
                     (cons 
                      (LISP-SPEC::|!symbol| "SNARK" "USE-CODE-FOR-NUMBERS") 
                      (cons (LISP-SPEC::bool t) nil))) 
                    (cons 
                     (LISP-SPEC::|!list| 
                      (cons 
                       (LISP-SPEC::|!symbol| "SNARK" "USE-RESOLUTION") 
                       (cons (LISP-SPEC::bool t) nil))) 
                     nil)))))))) 
             (LISP-SPEC::|!list| prover_options)) 
            (LISP-SPEC::|!list| snarkSortDecl)) 
           (LISP-SPEC::|!list| snarkOpDecls)) 
          (LISP-SPEC::|!list| snarkBaseHypothesis)) 
         (LISP-SPEC::|!list| SPECCALC::baseAxioms)) 
        (LISP-SPEC::|!list| snarkHypothesis)) 
       (LISP-SPEC::|!list| (cons snarkConjecture nil))) 
      nil)))))
              
(defparameter SPECCALC::newContext (vector (cons :|Ref| 0)))
                                                            
(defun SPECCALC::mkSnarkName (qual id) 
  (block 
   nil 
   (if (string=  "Boolean" qual) 
       (if (string=  "~" id) 
           (return "NOT") 
           (if (string=  "&" id) 
               (return "AND") 
               (if (string=  "or" id) 
                   (return "OR") 
                   (if (string=  "=>" id) 
                       (return "IMPLIES") 
                       (if (string=  "<=>" id) (return "IFF")))))) 
       (if (string=  "Nat" qual) 
           (if (string=  "<=" id) (return "=<")) 
           (if (string=  "Integer" qual) (if (string=  "<=" id) (return "=<"))))) 
   (return id)))
                
(defun SPECCALC::mkNewSnarkOp (context) 
  (let ((num (INTEGER-SPEC::|!+| (STATE::|!!| (svref context 0)) 1))) 
    (progn (STATE::|:=| (svref context 0) num) 
           (LISP-SPEC::|!symbol| 
            "SNARK" 
            (STRING-SPEC::|!++| "sApply" (NAT-SPEC::toString num))))))
                                                                      
(defun UTILITIES::deleteVars (vars1 vars2) 
  (LIST-SPEC::foldr-1-1-1 #'LISTUTILITIES::|!delete|-1 vars1 vars2))
                                                                    
(defun UTILITIES::freeVarsList (|!list|) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (block 
       nil 
       (return (LIST-SPEC::|!++| (cdr x) (UTILITIES::freeVarsRec (cdr (car x))))) 
       (error "Nonexhaustive match failure in freeVarsList"))) 
   nil 
   |!list|))
            
(defun UTILITIES::patVars (pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV11664 (cdr pat))) 
         (return 
          (LIST-SPEC::|!++| 
           (UTILITIES::patVars (svref pV11664 0)) 
           (UTILITIES::patVars (svref pV11664 1))))) 
       (if (eq (car pat) :|VarPat|) 
           (return (cons (car (cdr pat)) nil)) 
           (if (eq (car pat) :|EmbedPat|) 
               (progn (let ((pV11674 (svref (cdr pat) 1))) 
                        (if (eq (car pV11674) :|Some|) 
                            (return (UTILITIES::patVars (cdr pV11674))))) 
                      (return nil)) 
               (if (eq (car pat) :|RecordPat|) 
                   (return 
                    (LIST-SPEC::foldr-1-1-1 
                     #'(lambda (x) 
                        (block 
                         nil 
                         (return 
                          (LIST-SPEC::|!++| 
                           (UTILITIES::patVars (cdr (car x))) 
                           (cdr x))) 
                         (error "Nonexhaustive match failure in patVars"))) 
                     nil 
                     (car (cdr pat)))) 
                   (if (eq (car pat) :|WildPat|) 
                       (return nil) 
                       (if (eq (car pat) :|StringPat|) 
                           (return nil) 
                           (if (eq (car pat) :|BoolPat|) 
                               (return nil) 
                               (if (eq (car pat) :|CharPat|) 
                                   (return nil) 
                                   (if (eq (car pat) :|NatPat|) 
                                       (return nil) 
                                       (if (eq (car pat) :|RelaxPat|) 
                                           (return 
                                            (UTILITIES::patVars 
                                             (svref (cdr pat) 0))) 
                                           (if (eq (car pat) :|QuotientPat|) 
                                               (return 
                                                (UTILITIES::patVars 
                                                 (svref (cdr pat) 0)))))))))))))) 
   (error "Nonexhaustive match failure in patVars")))
                                                     
(defun UTILITIES::freeVarsMatch (pat |!cond| body) 
  (let ((vars (UTILITIES::patVars pat))) 
    (let ((vars1 (UTILITIES::freeVarsRec |!cond|))) 
      (let ((vars2 (UTILITIES::freeVarsRec body))) 
        (UTILITIES::deleteVars (LIST-SPEC::|!++| vars1 vars2) vars)))))
                                                                       
(defun UTILITIES::freeVarsMatch-1 (x) 
  (UTILITIES::freeVarsMatch (svref x 0) (svref x 1) (svref x 2)))
                                                                 
(defun UTILITIES::freeVarsRec (|!M|) 
  (block 
   nil 
   (if (eq (car |!M|) :|Var|) 
       (return (cons (car (cdr |!M|)) nil)) 
       (if (eq (car |!M|) :|Apply|) 
           (let ((pV11059 (cdr |!M|))) 
             (return 
              (LIST-SPEC::|!++| 
               (UTILITIES::freeVarsRec (svref pV11059 0)) 
               (UTILITIES::freeVarsRec (svref pV11059 1))))) 
           (if (eq (car |!M|) :|Record|) 
               (return (UTILITIES::freeVarsList (car (cdr |!M|)))) 
               (if (eq (car |!M|) :|Fun|) 
                   (return nil) 
                   (if (eq (car |!M|) :|Lambda|) 
                       (return 
                        (LIST-SPEC::foldr-1-1-1 
                         #'(lambda (x) 
                            (LIST-SPEC::|!++| 
                             (cdr x) 
                             (UTILITIES::freeVarsMatch-1 (car x)))) 
                         nil 
                         (car (cdr |!M|)))) 
                       (if (eq (car |!M|) :|Let|) 
                           (let ((pV11055 (cdr |!M|))) 
                             (return 
                              (let ((pV11044 
                                     (LIST-SPEC::foldr-1-1-1 
                                      #'(lambda (x) 
                                         (let ((pV11039 (cdr x))
                                               (pV11038 (car x))) 
                                           (block 
                                            nil 
                                            (return 
                                             (cons 
                                              (LIST-SPEC::|!++| 
                                               (UTILITIES::patVars (car pV11038)) 
                                               (car pV11039)) 
                                              (LIST-SPEC::|!++| 
                                               (UTILITIES::freeVarsRec 
                                                (cdr pV11038)) 
                                               (cdr pV11039)))) 
                                            (error 
                                             "Nonexhaustive match failure in freeVarsRec")))) 
                                      (cons nil nil) 
                                      (svref pV11055 0)))) 
                                (block 
                                 nil 
                                 (return 
                                  (let ((mVars 
                                         (UTILITIES::freeVarsRec 
                                          (svref pV11055 1)))) 
                                    (LIST-SPEC::|!++| 
                                     (cdr pV11044) 
                                     (UTILITIES::deleteVars mVars (car pV11044))))) 
                                 (error 
                                  "Nonexhaustive match failure in freeVarsRec"))))) 
                           (if (eq (car |!M|) :|LetRec|) 
                               (let ((pV11054 (cdr |!M|))) 
                                 (let ((pV11069 (svref pV11054 0))) 
                                   (return 
                                    (let ((vars1 
                                           (UTILITIES::freeVarsRec 
                                            (svref pV11054 1)))) 
                                      (let ((vars2 
                                             (UTILITIES::freeVarsList pV11069))) 
                                        (UTILITIES::deleteVars 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) (car x)) 
                                          pV11069) 
                                         (LIST-SPEC::|!++| vars1 vars2))))))) 
                               (if (eq (car |!M|) :|Bind|) 
                                   (let ((pV11053 (cdr |!M|))) 
                                     (return 
                                      (UTILITIES::deleteVars 
                                       (UTILITIES::freeVarsRec (svref pV11053 2)) 
                                       (svref pV11053 1)))) 
                                   (if (eq (car |!M|) :|IfThenElse|) 
                                       (let ((pV11052 (cdr |!M|))) 
                                         (return 
                                          (LIST-SPEC::|!++| 
                                           (LIST-SPEC::|!++| 
                                            (UTILITIES::freeVarsRec 
                                             (svref pV11052 0)) 
                                            (UTILITIES::freeVarsRec 
                                             (svref pV11052 1))) 
                                           (UTILITIES::freeVarsRec 
                                            (svref pV11052 2)))))))))))))) 
   (error "Nonexhaustive match failure in freeVarsRec")))
                                                         
(defun UTILITIES::freeVars (|!M|) 
  (let ((vars (UTILITIES::freeVarsRec |!M|))) 
    (LISTUTILITIES::removeDuplicates vars)))
                                            
(defun SPECCALC::mkNewSnarkTerm (context term) 
  (let ((vars (UTILITIES::freeVars term))) 
    (let ((newFun (SPECCALC::mkNewSnarkOp context))) 
      (let ((snarkVars 
             (LIST-SPEC::|!map|-1-1 
              #'(lambda (v) (LISP-SPEC::|!symbol| "SNARK" (car v))) 
              vars))) 
        (block 
         nil 
         (if (null snarkVars) (return newFun)) 
         (return (LISP-SPEC::|!cons| newFun (LISP-SPEC::|!list| snarkVars))))))))


(defun SPECCALC::mkSnarkTermApp (context sp dpn vars f arg) 
  (let ((args 
         (block 
          nil 
          (if (eq (car arg) :|Record|) 
              (return 
               (LIST-SPEC::|!map|-1-1 #'(lambda (x) (cdr x)) (car (cdr arg))))) 
          (return (cons arg nil))))) 
    (block 
     nil 
     (if (eq (car f) :|Op|) 
         (let ((pV6183 (car (cdr f)))) 
           (if (eq (car pV6183) :|Qualified|) 
               (let ((pV6185 (cdr pV6183))) 
                 (return 
                  (let ((snarkArgs 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (arg) 
                             (SPECCALC::mkSnarkTerm context sp dpn vars arg)) 
                          args))) 
                    (LISP-SPEC::|!cons| 
                     (LISP-SPEC::|!symbol| 
                      "SNARK" 
                      (SPECCALC::mkSnarkName (car pV6185) (cdr pV6185))) 
                     (LISP-SPEC::|!list| snarkArgs)))))))) 
     (error "Nonexhaustive match failure in mkSnarkTermApp"))))
                                                               
(defun SPECCALC::mkSnarkTerm (context sp dpn vars term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV6147 (cdr term))) 
         (let ((pV6166 (svref pV6147 0))) 
           (if (eq (car pV6166) :|Fun|) 
               (return 
                (SPECCALC::mkSnarkTermApp 
                 context 
                 sp 
                 dpn 
                 vars 
                 (svref (cdr pV6166) 0) 
                 (svref pV6147 1)))))) 
       (if (eq (car term) :|IfThenElse|) 
           (let ((pV6146 (cdr term))) 
             (return 
              (LISP-SPEC::|!list| 
               (cons 
                (LISP-SPEC::|!symbol| "SNARK" "IF") 
                (cons 
                 (SPECCALC::mkSnarkTerm context sp dpn vars (svref pV6146 0)) 
                 (cons 
                  (SPECCALC::mkSnarkTerm context sp dpn vars (svref pV6146 1)) 
                  (cons 
                   (SPECCALC::mkSnarkTerm context sp dpn vars (svref pV6146 2)) 
                   nil))))))) 
           (if (eq (car term) :|Fun|) 
               (let ((pV6152 (svref (cdr term) 0))) 
                 (if (eq (car pV6152) :|Op|) 
                     (let ((pV6157 (car (cdr pV6152)))) 
                       (if (eq (car pV6157) :|Qualified|) 
                           (let ((pV6159 (cdr pV6157))) 
                             (return 
                              (LISP-SPEC::|!symbol| 
                               "SNARK" 
                               (SPECCALC::mkSnarkName (car pV6159) (cdr pV6159))))))) 
                     (if (eq (car pV6152) :|Nat|) 
                         (return (LISP-SPEC::|!nat| (cdr pV6152)))))) 
               (if (eq (car term) :|Var|) 
                   (return (LISP-SPEC::|!symbol| "SNARK" (car (car (cdr term))))))))) 
   (return (SPECCALC::mkNewSnarkTerm context term))))
                                                     
(defun SPECCALC::snarkBoolOp (id) 
  (let ((name (SPECCALC::mkSnarkName "Boolean" id))) 
    (LISP-SPEC::|!symbol| "SNARK" name)))
                                         
(defun SPECCALC::mkSnarkFmlaApp (context sp dpn vars f srt arg) 
  (let ((args 
         (block 
          nil 
          (if (eq (car arg) :|Record|) 
              (return 
               (LIST-SPEC::|!map|-1-1 #'(lambda (x) (cdr x)) (car (cdr arg))))) 
          (return (cons arg nil))))) 
    (block 
     nil 
     (if (eq (car f) :|Op|) 
         (let ((pV6126 (car (cdr f)))) 
           (if (eq (car pV6126) :|Qualified|) 
               (let ((pV6128 (cdr pV6126))) 
                 (let ((pV6130 (cdr pV6128))
                       (pV6129 (car pV6128))) 
                   (progn (if (string=  "Boolean" pV6129) 
                              (return 
                               (let ((snarkArgs 
                                      (LIST-SPEC::|!map|-1-1 
                                       #'(lambda (arg) 
                                          (SPECCALC::mkSnarkFmla 
                                           context 
                                           sp 
                                           dpn 
                                           vars 
                                           arg)) 
                                       args))) 
                                 (LISP-SPEC::|!cons| 
                                  (SPECCALC::snarkBoolOp pV6130) 
                                  (LISP-SPEC::|!list| snarkArgs))))) 
                          (return 
                           (let ((snarkArgs 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'(lambda (arg) 
                                      (SPECCALC::mkSnarkTerm 
                                       context 
                                       sp 
                                       dpn 
                                       vars 
                                       arg)) 
                                   args))) 
                             (LISP-SPEC::|!cons| 
                              (LISP-SPEC::|!symbol| 
                               "SNARK" 
                               (SPECCALC::mkSnarkName pV6129 pV6130)) 
                              (LISP-SPEC::|!list| snarkArgs))))))))) 
         (if (eq (car f) :|Embedded|) 
             (let ((pV6124 (cdr f))) 
               (return 
                (labels 
                  ((boolArgp (srt) 
                    (block 
                     nil 
                     (if (eq (car srt) :|Base|) 
                         (let ((pV6069 (svref (cdr srt) 0))) 
                           (if (eq (car pV6069) :|Qualified|) 
                               (let ((pV6072 (cdr pV6069))) 
                                 (return 
                                  (lisp::or 
                                   (string=  (car pV6072) "Boolean") 
                                   (string=  (cdr pV6072) "Boolean"))))))) 
                     (return nil)))) 
                  (block 
                   nil 
                   (if (eq (car srt) :|Arrow|) 
                       (return 
                        (let ((isfmla (boolArgp (svref (cdr srt) 0)))) 
                          (let ((snarkArg 
                                 (if isfmla 
                                     (SPECCALC::mkSnarkFmla 
                                      context 
                                      sp 
                                      dpn 
                                      vars 
                                      arg) 
                                     (SPECCALC::mkSnarkTerm 
                                      context 
                                      sp 
                                      dpn 
                                      vars 
                                      arg)))) 
                            (LISP-SPEC::|!cons| 
                             (LISP-SPEC::|!symbol| "SNARK" "embed?") 
                             (LISP-SPEC::|!list| 
                              (cons 
                               (LISP-SPEC::|!symbol| "SNARK" pV6124) 
                               (cons snarkArg nil)))))))) 
                   (error "Nonexhaustive match failure in mkSnarkFmlaApp"))))) 
             (if (eq (car f) :|Equals|) 
                 (return 
                  (labels 
                    ((boolArgp (srt) 
                      (block 
                       nil 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV6086 (svref (cdr srt) 0))) 
                             (if (eq (car pV6086) :|Qualified|) 
                                 (let ((pV6089 (cdr pV6086))) 
                                   (return 
                                    (lisp::or 
                                     (string=  (car pV6089) "Boolean") 
                                     (string=  (cdr pV6089) "Boolean"))))))) 
                       (return nil)))) 
                    (block 
                     nil 
                     (if (consp args) 
                         (let ((pV6119 (cdr args))
                               (pV6118 (car args))) 
                           (if (consp pV6119) 
                               (let ((pV6121 (car pV6119))) 
                                 (if (null (cdr pV6119)) 
                                     (return 
                                      (block 
                                       nil 
                                       (if (eq (car srt) :|Arrow|) 
                                           (let ((pV6113 (svref (cdr srt) 0))) 
                                             (return 
                                              (block 
                                               nil 
                                               (if (eq (car pV6113) :|Product|) 
                                                   (let ((pV6109 
                                                          (car (cdr pV6113)))) 
                                                     (return 
                                                      (block 
                                                       nil 
                                                       (if (consp pV6109) 
                                                           (let ((pV6099 
                                                                  (cdr pV6109))) 
                                                             (if (consp pV6099) 
                                                                 (if (null 
                                                                      (cdr 
                                                                       pV6099)) 
                                                                     (return 
                                                                      (let ((isfmla 
                                                                             (lisp::or 
                                                                              (boolArgp 
                                                                               (cdr 
                                                                                (car 
                                                                                 pV6109))) 
                                                                              (boolArgp 
                                                                               (cdr 
                                                                                (car 
                                                                                 pV6099)))))) 
                                                                        (let ((snarkArg1 
                                                                               (if isfmla 
                                                                                   (SPECCALC::mkSnarkFmla 
                                                                                    context 
                                                                                    sp 
                                                                                    dpn 
                                                                                    vars 
                                                                                    pV6118) 
                                                                                   (SPECCALC::mkSnarkTerm 
                                                                                    context 
                                                                                    sp 
                                                                                    dpn 
                                                                                    vars 
                                                                                    pV6118)))) 
                                                                          (let ((snarkArg2 
                                                                                 (if isfmla 
                                                                                     (SPECCALC::mkSnarkFmla 
                                                                                      context 
                                                                                      sp 
                                                                                      dpn 
                                                                                      vars 
                                                                                      pV6121) 
                                                                                     (SPECCALC::mkSnarkTerm 
                                                                                      context 
                                                                                      sp 
                                                                                      dpn 
                                                                                      vars 
                                                                                      pV6121)))) 
                                                                            (if isfmla 
                                                                                (LISP-SPEC::|!cons| 
                                                                                 (LISP-SPEC::|!symbol| 
                                                                                  "SNARK" 
                                                                                  "IFF") 
                                                                                 (LISP-SPEC::|!list| 
                                                                                  (cons 
                                                                                   snarkArg1 
                                                                                   (cons 
                                                                                    snarkArg2 
                                                                                    nil)))) 
                                                                                (LISP-SPEC::|!cons| 
                                                                                 (LISP-SPEC::|!symbol| 
                                                                                  "SNARK" 
                                                                                  "=") 
                                                                                 (LISP-SPEC::|!list| 
                                                                                  (cons 
                                                                                   snarkArg1 
                                                                                   (cons 
                                                                                    snarkArg2 
                                                                                    nil))))))))))))) 
                                                       (error 
                                                        "Nonexhaustive match failure in mkSnarkFmlaApp"))))) 
                                               (error 
                                                "Nonexhaustive match failure in mkSnarkFmlaApp"))))) 
                                       (error 
                                        "Nonexhaustive match failure in mkSnarkFmlaApp")))))))) 
                     (error "Nonexhaustive match failure in mkSnarkFmlaApp"))))))) 
     (error "Nonexhaustive match failure in mkSnarkFmlaApp"))))
                                                               
(defun SPECCALC::snarkPBaseSort (s rng?) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV6947 (svref (cdr s) 0))) 
         (if (eq (car pV6947) :|Qualified|) 
             (let ((pV6950 (cdr pV6947))) 
               (let ((pV6952 (cdr pV6950))
                     (pV6951 (car pV6950))) 
                 (progn (if (string=  "Nat" pV6951) 
                            (if (string=  "Nat" pV6952) 
                                (return (LISP-SPEC::|!symbol| "SNARK" "NATURAL"))) 
                            (if (string=  "Integer" pV6951) 
                                (if (string=  "Integer" pV6952) 
                                    (return 
                                     (LISP-SPEC::|!symbol| "SNARK" "INTEGER"))))) 
                        (return 
                         (if rng? 
                             (LISP-SPEC::|!symbol| "SNARK" pV6952) 
                             (LISP-SPEC::|!symbol| "SNARK" pV6952)))))))) 
       (if (eq (car s) :|Product|) 
           (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
           (if (eq (car s) :|Arrow|) 
               (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
               (if (eq (car s) :|TyVar|) 
                   (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")))))) 
   (error "Nonexhaustive match failure in snarkPBaseSort")))
                                                            
(defun SPECCALC::snarkBndVar-1 (var) 
  (block 
   nil 
   (return 
    (LISP-SPEC::|!list| 
     (cons 
      (LISP-SPEC::|!symbol| "SNARK" (car var)) 
      (cons 
       (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
       (cons (SPECCALC::snarkPBaseSort (cdr var) nil) nil))))) 
   (error "Nonexhaustive match failure in snarkBndVar")))
                                                         
(defun SPECCALC::snarkBndVars (vars) 
  (let ((snarkVarList (LIST-SPEC::|!map|-1-1 #'SPECCALC::snarkBndVar-1 vars))) 
    (let ((res (LISP-SPEC::|!list| snarkVarList))) res)))
                                                         
(defun SPECCALC::mkSnarkFmla (context sp dpn vars fmla) 
  (block 
   nil 
   (if (eq (car fmla) :|Bind|) 
       (let ((pV6035 (cdr fmla))) 
         (let ((pV6052 (svref pV6035 1))) 
           (return 
            (let ((snarkBndList (SPECCALC::snarkBndVars pV6052))) 
              (let ((newVars 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x) (SPECTOLISP::specId (car x))) 
                      pV6052))) 
                (let ((snarkFmla 
                       (SPECCALC::mkSnarkFmla 
                        context 
                        sp 
                        dpn 
                        (STRINGSET::addList vars newVars) 
                        (svref pV6035 2)))) 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| 
                     "SNARK" 
                     (SPECCALC::bndrString (svref pV6035 0))) 
                    (cons snarkBndList (cons snarkFmla nil)))))))))) 
       (if (eq (car fmla) :|Apply|) 
           (let ((pV6034 (cdr fmla))) 
             (let ((pV6044 (svref pV6034 0))) 
               (if (eq (car pV6044) :|Fun|) 
                   (let ((pV6047 (cdr pV6044))) 
                     (return 
                      (SPECCALC::mkSnarkFmlaApp 
                       context 
                       sp 
                       dpn 
                       vars 
                       (svref pV6047 0) 
                       (svref pV6047 1) 
                       (svref pV6034 1))))))) 
           (if (eq (car fmla) :|IfThenElse|) 
               (let ((pV6033 (cdr fmla))) 
                 (return 
                  (LISP-SPEC::|!list| 
                   (cons 
                    (LISP-SPEC::|!symbol| "SNARK" "IF") 
                    (cons 
                     (SPECCALC::mkSnarkFmla context sp dpn vars (svref pV6033 0)) 
                     (cons 
                      (SPECCALC::mkSnarkFmla 
                       context 
                       sp 
                       dpn 
                       vars 
                       (svref pV6033 1)) 
                      (cons 
                       (SPECCALC::mkSnarkFmla 
                        context 
                        sp 
                        dpn 
                        vars 
                        (svref pV6033 2)) 
                       nil))))))) 
               (if (eq (car fmla) :|Fun|) 
                   (let ((pV6036 (svref (cdr fmla) 0))) 
                     (if (eq (car pV6036) :|Bool|) 
                         (let ((pV6039 (cdr pV6036))) 
                           (if (eq t pV6039) 
                               (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
                               (if (eq nil pV6039) 
                                   (return 
                                    (LISP-SPEC::|!symbol| "SNARK" "FALSE"))))))))))) 
   (return (SPECCALC::mkSnarkTerm context sp dpn vars fmla))))
                                                              
(defparameter SPECCALC::snark_prove (LISP-SPEC::|!symbol| "SNARK" "PROVE"))
                                                                           
(defun SPECCALC::snarkConjecture (pV6878 pV6879 pV6880) 
  (block 
   nil 
   (return 
    (let ((snarkFmla 
           (SPECCALC::mkSnarkFmla 
            pV6878 
            pV6879 
            "SNARK" 
            STRINGSET::empty 
            (svref pV6880 3)))) 
      (LISP-SPEC::|!list| 
       (cons 
        SPECCALC::snark_prove 
        (cons 
         (LISP-SPEC::|!quote| snarkFmla) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "NAME") 
          (cons (LISP-SPEC::|!symbol| "KEYWORD" (svref pV6880 1)) nil))))))) 
   (error "Nonexhaustive match failure in snarkConjecture")))
                                                             
(defparameter SPECCALC::snarkBaseDecls 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_predicate 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "embed?")) 
      (cons (LISP-SPEC::|!nat| 2) nil)))) 
   nil))
        
(defun SPECCALC::snarkFunctionCurryDecl () (LISP-SPEC::|!nil|))
                                                               
(defun SPECCALC::snarkFunctionNoArityDecl (name srt) 
  (block 
   nil 
   (if (eq (car srt) :|Base|) 
       (let ((pV6900 (svref (cdr srt) 0))) 
         (if (eq (car pV6900) :|Qualified|) 
             (return 
              (LISP-SPEC::|!list| 
               (cons 
                SPECCALC::declare_constant 
                (cons 
                 (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" name)) 
                 (cons 
                  (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
                  (cons 
                   (LISP-SPEC::|!quote| 
                    (LISP-SPEC::|!symbol| "SNARK" (cdr (cdr pV6900)))) 
                   nil))))))))) 
   (return (LISP-SPEC::|!nil|))))
                                 
(defun SPECCALC::snarkFunctionCurryNoArityDecl (name srt) 
  (SPECCALC::snarkFunctionNoArityDecl name srt))
                                                
(defun SPECCALC::snarkBaseSort (s rng?) 
  (block 
   nil 
   (if (eq (car s) :|Base|) 
       (let ((pV6869 (svref (cdr s) 0))) 
         (if (eq (car pV6869) :|Qualified|) 
             (let ((pV6872 (cdr pV6869))) 
               (let ((pV6874 (cdr pV6872))
                     (pV6873 (car pV6872))) 
                 (progn (if (string=  "Nat" pV6873) 
                            (if (string=  "Nat" pV6874) 
                                (return (LISP-SPEC::|!symbol| "SNARK" "NATURAL"))) 
                            (if (string=  "Integer" pV6873) 
                                (if (string=  "Integer" pV6874) 
                                    (return 
                                     (LISP-SPEC::|!symbol| "SNARK" "INTEGER"))))) 
                        (return 
                         (if rng? 
                             (LISP-SPEC::|!symbol| "SNARK" pV6874) 
                             (LISP-SPEC::|!symbol| "SNARK" pV6874)))))))) 
       (if (eq (car s) :|Product|) 
           (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
           (if (eq (car s) :|Arrow|) 
               (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")) 
               (if (eq (car s) :|TyVar|) 
                   (return (LISP-SPEC::|!symbol| "SNARK" "TRUE")))))) 
   (error "Nonexhaustive match failure in snarkBaseSort")))
                                                           
(defun SPECCALC::snarkPredicateDecl (spc name dom arity) 
  (let ((pV6953 (SPECENVIRONMENT::productOpt spc dom))) 
    (block 
     nil 
     (if (eq (car pV6953) :|Some|) 
         (return 
          (let ((domSortList 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x) (SPECCALC::snarkBaseSort (cdr x) nil)) 
                  (cdr pV6953)))) 
            (LISP-SPEC::|!list| 
             (cons 
              SPECCALC::declare_predicate 
              (cons 
               (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" name)) 
               (cons 
                (LISP-SPEC::|!nat| arity) 
                (cons 
                 (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
                 (cons 
                  (LISP-SPEC::|!quote| 
                   (LISP-SPEC::|!cons| 
                    (LISP-SPEC::|!symbol| "SNARK" "BOOLEAN") 
                    (LISP-SPEC::|!list| domSortList))) 
                  nil))))))))) 
     (error "Nonexhaustive match failure in snarkPredicateDecl"))))
                                                                   
(defun SPECCALC::snarkFunctionNoCurryDecl (spc name srt arity) 
  (let ((pV6920 (SPECENVIRONMENT::arrowOpt spc srt))) 
    (block 
     nil 
     (if (eq (car pV6920) :|Some|) 
         (let ((pV6921 (cdr pV6920))) 
           (let ((pV6923 (cdr pV6921))
                 (pV6922 (car pV6921))) 
             (return 
              (block 
               nil 
               (if (eq (car pV6923) :|Base|) 
                   (let ((pV6914 (svref (cdr pV6923) 0))) 
                     (if (eq (car pV6914) :|Qualified|) 
                         (if (string=  "Boolean" (cdr (cdr pV6914))) 
                             (return 
                              (SPECCALC::snarkPredicateDecl 
                               spc 
                               name 
                               pV6922 
                               arity)))))) 
               (return 
                (let ((pV6910 (SPECENVIRONMENT::productOpt spc pV6922))) 
                  (block 
                   nil 
                   (if (eq (car pV6910) :|Some|) 
                       (return 
                        (let ((domSortList 
                               (LIST-SPEC::|!map|-1-1 
                                #'(lambda (x) 
                                   (SPECCALC::snarkBaseSort (cdr x) nil)) 
                                (cdr pV6910)))) 
                          (LISP-SPEC::|!list| 
                           (cons 
                            SPECCALC::declare_function 
                            (cons 
                             (LISP-SPEC::|!quote| 
                              (LISP-SPEC::|!symbol| "SNARK" name)) 
                             (cons 
                              (LISP-SPEC::|!nat| arity) 
                              (cons 
                               (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
                               (cons 
                                (LISP-SPEC::|!quote| 
                                 (LISP-SPEC::|!cons| 
                                  (SPECCALC::snarkBaseSort pV6923 t) 
                                  (LISP-SPEC::|!list| domSortList))) 
                                nil))))))))) 
                   (error 
                    "Nonexhaustive match failure in snarkFunctionNoCurryDecl"))))))))) 
     (error "Nonexhaustive match failure in snarkFunctionNoCurryDecl"))))
                                                                         
(defun SPECCALC::snarkFunctionDecl (spc name srt) 
  (let ((pV6889 (ARITYNORMALIZE::sortArity spc srt))
        (pV6888 (SPECTOLISP::curryShapeNum spc srt))) 
    (block 
     nil 
     (if ( =  1 pV6888) 
         (if (eq (car pV6889) :|None|) 
             (return (SPECCALC::snarkFunctionNoArityDecl name srt)) 
             (if (eq (car pV6889) :|Some|) 
                 (return 
                  (SPECCALC::snarkFunctionNoCurryDecl 
                   spc 
                   name 
                   srt 
                   (cdr (cdr pV6889))))))) 
     (if (eq (car pV6889) :|None|) 
         (return (SPECCALC::snarkFunctionCurryNoArityDecl name srt)) 
         (if (eq (car pV6889) :|Some|) 
             (return (SPECCALC::snarkFunctionCurryDecl)))) 
     (return (SPECCALC::snarkFunctionNoArityDecl name srt)))))
                                                              
(defun SPECCALC::snarkOpDecl (spc name srt) 
  (if (SPECTOLISP::functionSort? spc srt) 
      (SPECCALC::snarkFunctionDecl spc name srt) 
      (SPECCALC::snarkFunctionDecl spc name srt)))
                                                  
(defun SPECCALC::snarkOpDeclPartial (spc name srt) 
  (let ((decl (SPECCALC::snarkOpDecl spc name srt))) 
    (if (LISP-SPEC::|!null| decl) '(:|None|) (cons :|Some| decl))))
                                                                   
(defun SPECCALC::snarkOpDecls-1 (spc) 
  (let ((opsigs (specOps-1 spc))) 
    (let ((snarkOpDecls 
           (LIST-SPEC::mapPartial-1-1 
            #'(lambda (x) 
               (SPECCALC::snarkOpDeclPartial 
                spc 
                (SPECCALC::mkSnarkName (svref x 0) (svref x 1)) 
                (svref x 3))) 
            opsigs))) (LIST-SPEC::|!++| SPECCALC::snarkBaseDecls snarkOpDecls))))


(defun SPECCALC::snarkProperty (pV6955 pV6956 pV6957) 
  (block 
   nil 
   (return 
    (let ((snarkFmla 
           (SPECCALC::mkSnarkFmla 
            pV6955 
            pV6956 
            "SNARK" 
            STRINGSET::empty 
            (svref pV6957 3)))) 
      (LISP-SPEC::|!list| 
       (cons 
        SPECCALC::snark_assert 
        (cons 
         (LISP-SPEC::|!quote| snarkFmla) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "NAME") 
          (cons (LISP-SPEC::|!symbol| "KEYWORD" (svref pV6957 1)) nil))))))) 
   (error "Nonexhaustive match failure in snarkProperty")))
                                                           
(defparameter SPECCALC::logicalSorts 
  (cons 
   (LISP-SPEC::|!list| 
    (cons 
     SPECCALC::declare_function 
     (cons 
      (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "logical-&")) 
      (cons 
       (LISP-SPEC::|!nat| 2) 
       (cons 
        (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
        (cons 
         (LISP-SPEC::|!quote| 
          (LISP-SPEC::|!list| 
           (cons 
            (LISP-SPEC::|!symbol| "SNARK" "logical") 
            (cons 
             (LISP-SPEC::|!symbol| "SNARK" "logical") 
             (cons (LISP-SPEC::|!symbol| "SNARK" "logical") nil))))) 
         (cons 
          (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
          (cons 
           (LISP-SPEC::bool t) 
           (cons 
            (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
            (cons (LISP-SPEC::bool t) nil)))))))))) 
   (cons 
    (LISP-SPEC::|!list| 
     (cons 
      SPECCALC::declare_function 
      (cons 
       (LISP-SPEC::|!quote| (LISP-SPEC::|!symbol| "SNARK" "logical-or")) 
       (cons 
        (LISP-SPEC::|!nat| 2) 
        (cons 
         (LISP-SPEC::|!symbol| "KEYWORD" "SORT") 
         (cons 
          (LISP-SPEC::|!quote| 
           (LISP-SPEC::|!list| 
            (cons 
             (LISP-SPEC::|!symbol| "SNARK" "logical") 
             (cons 
              (LISP-SPEC::|!symbol| "SNARK" "logical") 
              (cons (LISP-SPEC::|!symbol| "SNARK" "logical") nil))))) 
          (cons 
           (LISP-SPEC::|!symbol| "KEYWORD" "ASSOCIATIVE") 
           (cons 
            (LISP-SPEC::bool t) 
            (cons 
             (LISP-SPEC::|!symbol| "KEYWORD" "COMMUTATIVE") 
             (cons (LISP-SPEC::bool t) nil)))))))))) 
    nil)))
          
(defun SPECCALC::snarkBuiltInSorts (useLogicalSorts) 
  (LIST-SPEC::|!++| 
   (LIST-SPEC::|!++| 
    (if useLogicalSorts SPECCALC::logicalSorts nil) 
    SPECCALC::arithmeticSorts) 
   SPECCALC::baseSorts))
                        
(defun SPECCALC::snarkSorts-1 (spc) 
  (let ((sorts (sortsAsList-1 spc))) 
    (let ((snarkSorts 
           (LIST-SPEC::|!map|-1-1 
            #'(lambda (x) 
               (LISP-SPEC::|!list| 
                (cons 
                 SPECCALC::declare_sort 
                 (cons 
                  (LISP-SPEC::|!quote| 
                   (LISP-SPEC::|!symbol| "SNARK" (svref x 1))) 
                  nil)))) 
            sorts))) 
      (LIST-SPEC::|!++| (SPECCALC::snarkBuiltInSorts nil) snarkSorts))))
                                                                        
(defun SPECCALC::proveWithHypothesis
 (proof_name 
  claim 
  hypothesis 
  spc 
  spec_name 
  base_hypothesis 
  base_spc 
  prover_name 
  prover_options 
  snarkLogFileName) 
  (progn (if (BOOLEAN-SPEC::~ (string=  prover_name "Snark")) 
             (STRING-SPEC::writeLine 
              (STRING-SPEC::^ 
               prover_name 
               " is not supported; using Snark instead.")) 
             nil) 
         (block 
          nil 
          (let ((pV6726 (svref claim 1))
                (pV6725 (svref claim 0))) 
            (return 
             (labels 
               ((claimType (ct) 
                 (block 
                  nil 
                  (if (eq (car ct) :|Conjecture|) 
                      (return "Conjecture") 
                      (if (eq (car ct) :|Theorem|) 
                          (return "Theorem") 
                          (if (eq (car ct) :|Axiom|) (return "Axiom")))) 
                  (error "Nonexhaustive match failure in proveWithHypothesis")))) 
               (let ((claim_type (claimType pV6725))) 
                 (let ((snarkSortDecls (SPECCALC::snarkSorts-1 spc))) 
                   (let ((snarkOpDecls (SPECCALC::snarkOpDecls-1 spc))) 
                     (let ((snarkBaseHypothesis 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (prop) 
                                (SPECCALC::snarkProperty 
                                 SPECCALC::newContext 
                                 base_spc 
                                 prop)) 
                             base_hypothesis))) 
                       (let ((snarkHypothesis 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (prop) 
                                  (SPECCALC::snarkProperty 
                                   SPECCALC::newContext 
                                   spc 
                                   prop)) 
                               hypothesis))) 
                         (let ((snarkConjecture 
                                (SPECCALC::snarkConjecture 
                                 SPECCALC::newContext 
                                 spc 
                                 claim))) 
                           (let ((snarkEvalForm 
                                  (SPECCALC::makeSnarkProveEvalForm 
                                   prover_options 
                                   snarkSortDecls 
                                   snarkOpDecls 
                                   snarkBaseHypothesis 
                                   snarkHypothesis 
                                   snarkConjecture 
                                   snarkLogFileName))) 
                             (let ((result 
                                    (LISP-SPEC::|!apply| 
                                     (LISP-SPEC::|!symbol| "LISP" "FUNCALL") 
                                     (cons 
                                      (LISP-SPEC::|!list| 
                                       (cons 
                                        (LISP-SPEC::|!symbol| "SNARK" "LAMBDA") 
                                        (cons 
                                         (LISP-SPEC::|!nil|) 
                                         (cons snarkEvalForm nil)))) 
                                      nil)))) 
                               (let ((proved 
                                      (string=  
                                       ":PROOF-FOUND" 
                                       (SYSTEM-SPEC::toString result)))) 
                                 (progn (SPECCALC::displayProofResult 
                                         proof_name 
                                         claim_type 
                                         pV6726 
                                         spec_name 
                                         proved 
                                         snarkLogFileName) 
                                        proved))))))))))))) 
          (error "Nonexhaustive match failure in proveWithHypothesis"))))
                                                                         
(defun SPECCALC::proveInSpec
 (proof_name 
  claim_name 
  spc 
  spec_name 
  base_spc 
  prover_name 
  assertions 
  prover_options 
  snarkLogFileName 
  pos) 
  (SPECCALC::monadBind 
   (let ((findClaimInSpec 
          (LIST-SPEC::firstUpTo-1-1 
           #'(lambda (x) (string=  claim_name (svref x 1))) 
           (svref spc 2)))) 
     (block 
      nil 
      (if (eq (car findClaimInSpec) :|None|) 
          (return 
           (SPECCALC::raise 
            (cons :|Proof| (cons pos "Claim name is not in spec.")))) 
          (if (eq (car findClaimInSpec) :|Some|) 
              (let ((pV6716 (cdr findClaimInSpec))) 
                (return 
                 (let ((actualHypothesis 
                        (SPECCALC::actualHypothesis (cdr pV6716) assertions))) 
                   (if (block 
                        nil 
                        (if (eq (car assertions) :|All|) 
                            (return t) 
                            (if (eq (car assertions) :|Explicit|) 
                                (return 
                                 ( =  
                                  (LIST-SPEC::|!length| actualHypothesis) 
                                  (LIST-SPEC::|!length| (cdr assertions)))))) 
                        (error "Nonexhaustive match failure in proveInSpec")) 
                       (SPECCALC::|!return| 
                        (SPECCALC::proveWithHypothesis 
                         proof_name 
                         (car pV6716) 
                         actualHypothesis 
                         spc 
                         spec_name 
                         (svref base_spc 2) 
                         base_spc 
                         prover_name 
                         prover_options 
                         snarkLogFileName)) 
                       (SPECCALC::raise 
                        (cons :|Proof| (cons pos "assertion not in spec."))))))))) 
      (error "Nonexhaustive match failure in proveInSpec"))) 
   #'(lambda (result) (SPECCALC::|!return| result))))
                                                     
(defun SPECCALC::evaluateProve
 (claim_name spec_term prover_name assertions possible_options) 
  #'(lambda (pos) 
     (SPECCALC::monadBind 
      (SPECCALC::evaluateTermInfo-1 spec_term) 
      #'(lambda (x) 
         (let ((depURIs (svref x 2))
               (timeStamp (svref x 1))
               (value (svref x 0))) 
           (SPECCALC::monadBind 
            (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                     (cons 
                      :|SpecPath_Relative| 
                      (cons '(:|None|) (cons "Library" (cons "Base" nil))))) 
            #'(lambda (x1) 
               (let ((pV5336 (svref x1 0))) 
                 (block 
                  nil 
                  (if (eq (car pV5336) :|Spec|) 
                      (let ((pV5339 (cdr pV5336))) 
                        (return 
                         (SPECCALC::monadBind 
                          (funcall (SPECCALC::evaluateURI 
                                    (cons :|Internal| "ProverBase")) 
                                   (cons 
                                    :|SpecPath_Relative| 
                                    (cons 
                                     '(:|None|) 
                                     (cons 
                                      "Library" 
                                      (cons "Base" (cons "ProverBase" nil)))))) 
                          #'(lambda (x11) 
                             (let ((pV5332 (svref x11 0))) 
                               (block 
                                nil 
                                (if (eq (car pV5332) :|Spec|) 
                                    (let ((pV5335 (cdr pV5332))) 
                                      (return 
                                       (SPECCALC::monadBind 
                                        #'SPECCALC::getCurrentURI-1 
                                        #'(lambda (|!URI|) 
                                           (SPECCALC::monadBind 
                                            (SPECCALC::URItoSnarkLogFile-1 
                                             |!URI|) 
                                            #'(lambda (snarkLogFileName) 
                                               (SPECCALC::monadBind 
                                                (SPECCALC::|!return| 
                                                 (IO-SPEC::ensureDirectoriesExist 
                                                  snarkLogFileName)) 
                                                #'(lambda (pV5323) 
                                                   (declare (ignore pV5323)) 
                                                   (SPECCALC::monadBind 
                                                    (SPECCALC::|!return| 
                                                     (SPECCALC::URItoProofName-1 
                                                      |!URI|)) 
                                                    #'(lambda (proof_name) 
                                                       (SPECCALC::monadBind 
                                                        (SPECCALC::|!return| 
                                                         (SPECCALC::SpecTermToSpecName-1 
                                                          spec_term)) 
                                                        #'(lambda (spec_name) 
                                                           (SPECCALC::monadBind 
                                                            (let ((pV5325 
                                                                   (SPECCALC::coerceToSpec 
                                                                    value))) 
                                                              (block 
                                                               nil 
                                                               (if (eq 
                                                                    (car pV5325) 
                                                                    :|Spec|) 
                                                                   (return 
                                                                    (SPECCALC::|!return| 
                                                                     (cdr pV5325)))) 
                                                               (return 
                                                                (SPECCALC::raise 
                                                                 (cons 
                                                                  :|Proof| 
                                                                  (cons 
                                                                   pos 
                                                                   "Argument to prove command is not coerceable to a spec.")))))) 
                                                            #'(lambda (uspc) 
                                                               (SPECCALC::monadBind 
                                                                (block 
                                                                 nil 
                                                                 (if (eq 
                                                                      (car 
                                                                       possible_options) 
                                                                      :|Options|) 
                                                                     (return 
                                                                      (SPECCALC::|!return| 
                                                                       (cdr 
                                                                        possible_options))) 
                                                                     (if (eq 
                                                                          (car 
                                                                           possible_options) 
                                                                          :|Error|) 
                                                                         (let ((pV5328 
                                                                                (cdr 
                                                                                 possible_options))) 
                                                                           (return 
                                                                            (SPECCALC::raise 
                                                                             (cons 
                                                                              :|SyntaxError| 
                                                                              (STRING-SPEC::^ 
                                                                               (car 
                                                                                pV5328) 
                                                                               (cdr 
                                                                                pV5328)))))))) 
                                                                 (error 
                                                                  "Nonexhaustive match failure in evaluateProve")) 
                                                                #'(lambda (prover_options) 
                                                                   (SPECCALC::monadBind 
                                                                    (SPECCALC::proveInSpec 
                                                                     proof_name 
                                                                     claim_name 
                                                                     (subtractSpec-1-1 
                                                                      uspc 
                                                                      pV5339) 
                                                                     spec_name 
                                                                     pV5335 
                                                                     prover_name 
                                                                     assertions 
                                                                     prover_options 
                                                                     snarkLogFileName 
                                                                     pos) 
                                                                    #'(lambda (proved) 
                                                                       (SPECCALC::monadBind 
                                                                        (SPECCALC::|!return| 
                                                                         (cons 
                                                                          :|Proof| 
                                                                          (cons 
                                                                           (if proved 
                                                                               '(:|Proved|) 
                                                                               '(:|Unproved|)) 
                                                                           |!URI|))) 
                                                                        #'(lambda (result) 
                                                                           (SPECCALC::|!return| 
                                                                            (vector 
                                                                             result 
                                                                             timeStamp 
                                                                             depURIs))))))))))))))))))))))) 
                                (error 
                                 "Nonexhaustive match failure in evaluateProve")))))))) 
                  (error "Nonexhaustive match failure in evaluateProve"))))))))))


(defun SPECCALC::evaluateProve-1 (x) 
  (SPECCALC::evaluateProve 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun SPECCALC::qualifySpec-1 (spc) 
  #'(lambda (new_qualifier) 
     #'(lambda (|!position|) 
        (labels 
          ((convertSpec (sp) 
            (let ((pV6763 
                   (mapSpec-1-1 
                    (vector #'translateOp #'translateSort #'translatePattern) 
                    sp))) 
              (block 
               nil 
               (let ((pV6766 (svref pV6763 2))
                     (pV6765 (svref pV6763 1))
                     (pV6764 (svref pV6763 0))) 
                 (let ((pV6771 (svref pV6764 3))
                       (pV6770 (svref pV6764 2))
                       (pV6769 (svref pV6764 1))
                       (pV6768 (svref pV6764 0))) 
                   (return 
                    (SPECCALC::monadBind 
                     (convertSortMap (svref pV6763 3)) 
                     #'(lambda (newSorts) 
                        (SPECCALC::monadBind 
                         (convertOpMap pV6765) 
                         #'(lambda (newOps) 
                            (SPECCALC::|!return| 
                             (vector 
                              (vector 
                               pV6768 
                               pV6769 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateQualifiedId 
                                pV6770) 
                               (LIST-SPEC::|!map|-1-1 
                                #'translateQualifiedId 
                                pV6771)) 
                              newOps 
                              pV6766 
                              newSorts))))))))) 
               (error "Nonexhaustive match failure in qualifySpec"))))
           (convertSortMap (sortMap) 
            (labels 
              ((qualifyStep (pV6756 pV6757 pV6758 pV6759) 
                (block 
                 nil 
                 (return 
                  (let ((newSortInfo 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'translateQualifiedId 
                           (svref pV6758 0)) 
                          (svref pV6758 1) 
                          (svref pV6758 2)))) 
                    (let ((newQualifier 
                           (if (string=  pV6756 METASLANG::UnQualified) 
                               new_qualifier 
                               pV6756))) 
                      (let ((oldSortInfo 
                             (findAQualifierMap pV6759 newQualifier pV6757))) 
                        (SPECCALC::monadBind 
                         (funcall (funcall (funcall (funcall (SPECCALC::mergeSortInfo-1 
                                                              newSortInfo) 
                                                             oldSortInfo) 
                                                    newQualifier) 
                                           pV6757) 
                                  |!position|) 
                         #'(lambda (sortInfo) 
                            (SPECCALC::|!return| 
                             (insertAQualifierMap 
                              pV6759 
                              newQualifier 
                              pV6757 
                              sortInfo)))))))) 
                 (error "Nonexhaustive match failure in qualifySpec")))) 
              (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                 #'(lambda (x) 
                                    (qualifyStep 
                                     (svref x 0) 
                                     (svref x 1) 
                                     (svref x 2) 
                                     (svref x 3)))) 
                                emptyAQualifierMap) 
                       sortMap)))
           (convertOpMap (opMap) 
            (labels 
              ((qualifyStep (pV6748 pV6749 pV6750 pV6751) 
                (block 
                 nil 
                 (return 
                  (let ((newOpInfo 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'translateQualifiedId 
                           (svref pV6750 0)) 
                          (svref pV6750 1) 
                          (svref pV6750 2) 
                          (svref pV6750 3)))) 
                    (let ((newQualifier 
                           (if (string=  pV6748 METASLANG::UnQualified) 
                               new_qualifier 
                               pV6748))) 
                      (let ((oldOpInfo 
                             (findAQualifierMap pV6751 newQualifier pV6749))) 
                        (SPECCALC::monadBind 
                         (funcall (funcall (funcall (funcall (SPECCALC::mergeOpInfo-1 
                                                              newOpInfo) 
                                                             oldOpInfo) 
                                                    newQualifier) 
                                           pV6749) 
                                  |!position|) 
                         #'(lambda (|!opInfo|) 
                            (SPECCALC::|!return| 
                             (insertAQualifierMap 
                              pV6751 
                              newQualifier 
                              pV6749 
                              |!opInfo|)))))))) 
                 (error "Nonexhaustive match failure in qualifySpec")))) 
              (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                 #'(lambda (x) 
                                    (qualifyStep 
                                     (svref x 0) 
                                     (svref x 1) 
                                     (svref x 2) 
                                     (svref x 3)))) 
                                emptyAQualifierMap) 
                       opMap)))
           (translatePattern (pat) pat)
           (translateSort (sort_term) 
            (block 
             nil 
             (if (eq (car sort_term) :|Base|) 
                 (let ((pV6744 (cdr sort_term))) 
                   (let ((pV6745 (svref pV6744 0))) 
                     (return 
                      (let ((new_qid (translateQualifiedId pV6745))) 
                        (if (slang-built-in::slang-term-equals new_qid pV6745) 
                            sort_term 
                            (cons 
                             :|Base| 
                             (vector new_qid (svref pV6744 1) (svref pV6744 2))))))))) 
             (return sort_term)))
           (translateOp (op_term) 
            (block 
             nil 
             (if (eq (car op_term) :|Fun|) 
                 (let ((pV6735 (cdr op_term))) 
                   (let ((pV6736 (svref pV6735 0))) 
                     (if (eq (car pV6736) :|Op|) 
                         (let ((pV6739 (cdr pV6736))) 
                           (let ((pV6740 (car pV6739))) 
                             (return 
                              (let ((new_qid (translateQualifiedId pV6740))) 
                                (if (slang-built-in::slang-term-equals 
                                     new_qid 
                                     pV6740) 
                                    op_term 
                                    (cons 
                                     :|Fun| 
                                     (vector 
                                      (cons :|Op| (cons new_qid (cdr pV6739))) 
                                      (svref pV6735 1) 
                                      (svref pV6735 2)))))))))))) 
             (return op_term)))
           (translateQualifiedId (qid) 
            (block 
             nil 
             (if (eq (car qid) :|Qualified|) 
                 (let ((pV6730 (cdr qid))) 
                   (return 
                    (if (string=  (car pV6730) METASLANG::UnQualified) 
                        (cons :|Qualified| (cons new_qualifier (cdr pV6730))) 
                        qid)))) 
             (error "Nonexhaustive match failure in qualifySpec")))) 
          (convertSpec spc)))))
                               
(defun SPECCALC::evaluateQualify-1 (term) 
  #'(lambda (new_qualifier) 
     (SPECCALC::monadBind 
      (SPECCALC::evaluateTermInfo-1 term) 
      #'(lambda (x) 
         (let ((depURIs (svref x 2))
               (timeStamp (svref x 1))) 
           (let ((pV5341 (SPECCALC::coerceToSpec (svref x 0)))) 
             (block 
              nil 
              (if (eq (car pV5341) :|Spec|) 
                  (return 
                   (SPECCALC::monadBind 
                    (funcall (funcall (SPECCALC::qualifySpec-1 (cdr pV5341)) 
                                      new_qualifier) 
                             (SPECCALC::positionOf-1 term)) 
                    #'(lambda (qualified_spec) 
                       (SPECCALC::|!return| 
                        (vector 
                         (cons 
                          :|Spec| 
                          (vector 
                           (svref qualified_spec 0) 
                           (svref qualified_spec 1) 
                           (svref qualified_spec 2) 
                           (svref qualified_spec 3))) 
                         timeStamp 
                         depURIs)))))) 
              (return 
               (SPECCALC::raise 
                (cons 
                 :|TypeCheck| 
                 (cons 
                  (SPECCALC::positionOf-1 term) 
                  "qualifying a term that is not a specification")))))))))))
                                                                            
(defun SPECCALC::ppLispCell (|!t|) 
  (PRETTYPRINT::|!string| (SYSTEM-SPEC::toString |!t|)))
                                                        
(defun SPECCALC::ppSpec-1 (s) 
  (PRETTYPRINT::prettysAll 
   (LIST-SPEC::|!++| 
    (LIST-SPEC::|!++| 
     (LIST-SPEC::|!++| 
      (LISTADT::section 
       (STRING-SPEC::^ ";;; Snark spec: " (svref s 1)) 
       (cons 
        (PRETTYPRINT::|!string| 
         (STRING-SPEC::^ (STRING-SPEC::^ "(in-package \"" "SNARK") "\")")) 
        nil)) 
      (LISTADT::section 
       ";;; Sorts" 
       (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppLispCell (svref s 3)))) 
     (LISTADT::section 
      ";;; Ops" 
      (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppLispCell (svref s 2)))) 
    (LISTADT::section 
     ";;; Assertions" 
     (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppLispCell (svref s 0))))))
                                                                   
(defun SPECCALC::ppSpecToFile (spc file preamble) 
  (let ((p (SPECCALC::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
      (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble)))))
                                                                    
(defun SPECCALC::snarkName-1 (spc) 
  (let ((packages 
         (LIST-SPEC::|!map|-1-1 
          #'SPECTOLISP::mkLPackageId 
          (qualifiers (svref spc 1))))) 
    (let ((pV6928 
           (block 
            nil 
            (if (consp packages) 
                (return (cons (car packages) (cdr packages))) 
                (if (null packages) 
                    (return (cons SPECTOLISP::defaultSpecwarePackage nil)))) 
            (error "Nonexhaustive match failure in snarkName")))) 
      (block 
       nil 
       (return (car pV6928)) 
       (error "Nonexhaustive match failure in snarkName")))))
                                                             
(defun SPECCALC::snarkProperties-1 (spc) 
  (let ((snarkProperties 
         (LIST-SPEC::|!map|-1-1 
          #'(lambda (prop) 
             (SPECCALC::snarkProperty SPECCALC::newContext spc prop)) 
          (svref spc 2)))) snarkProperties))
                                            
(defun SPECCALC::snarkSpec-1 (spc) 
  (vector 
   (SPECCALC::snarkProperties-1 spc) 
   (SPECCALC::snarkName-1 spc) 
   (SPECCALC::snarkOpDecls-1 spc) 
   (SPECCALC::snarkSorts-1 spc)))
                                 
(defun SPECCALC::toSnarkEnv-1 (spc) 
  (let ((spc (SPECCALC::snarkSpec-1 spc))) spc))
                                                
(defun SPECCALC::toSnarkFileEnv (spc file preamble) 
  (progn (STRING-SPEC::writeLine (STRING-SPEC::^ "Writing Snark file " file)) 
         (let ((spc (SPECCALC::toSnarkEnv-1 spc))) 
           (SPECCALC::ppSpecToFile spc file preamble))))
                                                        
(defun SPECCALC::toSnarkFile (spc file preamble) 
  (SPECCALC::toSnarkFileEnv spc file preamble))
                                               
(defun SPECCALC::evaluateSnarkGen (pV5357 pV5358 pV5359) 
  (block 
   nil 
   (let ((pV5360 (svref pV5357 0))) 
     (if (eq (car pV5360) :|Spec|) 
         (let ((pV5363 (cdr pV5360))) 
           (return 
            (SPECCALC::monadBind 
             (SPECCALC::getURI-1 pV5358) 
             #'(lambda (cURI) 
                (SPECCALC::monadBind 
                 (SPECCALC::URItoSnarkFile cURI pV5359) 
                 #'(lambda (snarkFileName) 
                    (SPECCALC::monadBind 
                     (funcall (SPECCALC::evaluateURI (cons :|Internal| "base")) 
                              (cons 
                               :|SpecPath_Relative| 
                               (cons 
                                '(:|None|) 
                                (cons "Library" (cons "Base" nil))))) 
                     #'(lambda (x) 
                        (let ((pV5353 (svref x 0))) 
                          (block 
                           nil 
                           (if (eq (car pV5353) :|Spec|) 
                               (return 
                                (progn (IO-SPEC::ensureDirectoriesExist 
                                        snarkFileName) 
                                       (progn (SPECCALC::toSnarkFile 
                                               (subtractSpec-1-1 
                                                pV5363 
                                                (cdr pV5353)) 
                                               snarkFileName 
                                               nil) 
                                              (SPECCALC::monadSeq 
                                               (SPECCALC::|!print| 
                                                "Translated to Snark") 
                                               (SPECCALC::|!return| pV5357)))))) 
                           (error 
                            "Nonexhaustive match failure in evaluateSnarkGen"))))))))))))) 
   (error "Nonexhaustive match failure in evaluateSnarkGen")))
                                                              
(defun SPECCALC::evaluateSpecElem-1 (spc) 
  #'(lambda (x) 
     (let ((|!position| (cdr x))
           (elem (car x))) 
       (block 
        nil 
        (if (eq (car elem) :|Import|) 
            (return (SPECCALC::|!return| spc)) 
            (if (eq (car elem) :|Sort|) 
                (let ((pV5368 (cdr elem))) 
                  (let ((pV5380 (cdr pV5368))) 
                    (return 
                     (funcall (funcall (funcall (funcall (SPECCALC::addSort 
                                                          (car pV5368)) 
                                                         (car pV5380)) 
                                                (cdr pV5380)) 
                                       spc) 
                              |!position|)))) 
                (if (eq (car elem) :|Op|) 
                    (let ((pV5367 (cdr elem))) 
                      (let ((pV5375 (cdr pV5367))) 
                        (return 
                         (funcall (funcall (funcall (funcall (funcall (SPECCALC::addOp 
                                                                       (car 
                                                                        pV5367)) 
                                                                      (svref 
                                                                       pV5375 
                                                                       0)) 
                                                             (svref pV5375 1)) 
                                                    (svref pV5375 2)) 
                                           spc) 
                                  |!position|)))) 
                    (if (eq (car elem) :|Claim|) 
                        (let ((pV5366 (cdr elem))) 
                          (progn (let ((pV5373 (svref pV5366 3))
                                       (pV5372 (svref pV5366 2))
                                       (pV5371 (svref pV5366 1))
                                       (pV5370 (svref pV5366 0))) 
                                   (if (eq (car pV5370) :|Axiom|) 
                                       (return 
                                        (SPECCALC::|!return| 
                                         (addAxiom 
                                          (vector pV5371 pV5372 pV5373) 
                                          spc))) 
                                       (if (eq (car pV5370) :|Theorem|) 
                                           (return 
                                            (SPECCALC::|!return| 
                                             (addTheorem 
                                              (vector pV5371 pV5372 pV5373) 
                                              spc))) 
                                           (if (eq (car pV5370) :|Conjecture|) 
                                               (return 
                                                (SPECCALC::|!return| 
                                                 (addConjecture 
                                                  (vector pV5371 pV5372 pV5373) 
                                                  spc))))))) 
                                 (return 
                                  (SPECCALC::|!error| 
                                   "evaluateSpecElem: unsupported claim type")))))))) 
        (error "Nonexhaustive match failure in evaluateSpecElem")))))
                                                                     
(defun SPECTOPOSSPEC::convertOpInfoToPOpInfo-1 (info) info)
                                                           
(defun SPECTOPOSSPEC::convertSortInfoToPSortInfo-1 (info) info)
                                                               
(defun SPECCALC::mergeImport-1 (spec_term) 
  #'(lambda (imported_spec) 
     #'(lambda (spec_a) 
        #'(lambda (|!position|) 
           (labels 
             ((mergeSortStep 
               (imported_qualifier 
                imported_id 
                imported_sort_info 
                combined_psorts) 
               (let ((newPSortInfo 
                      (SPECTOPOSSPEC::convertSortInfoToPSortInfo-1 
                       imported_sort_info))) 
                 (let ((oldPSortInfo 
                        (findAQualifierMap 
                         combined_psorts 
                         imported_qualifier 
                         imported_id))) 
                   (SPECCALC::monadBind 
                    (funcall (funcall (funcall (funcall (SPECCALC::mergeSortInfo-1 
                                                         newPSortInfo) 
                                                        oldPSortInfo) 
                                               imported_qualifier) 
                                      imported_id) 
                             |!position|) 
                    #'(lambda (mergedSorts) 
                       (SPECCALC::|!return| 
                        (insertAQualifierMap 
                         combined_psorts 
                         imported_qualifier 
                         imported_id 
                         mergedSorts)))))))) 
             (labels 
               ((mergeOpStep 
                 (imported_qualifier imported_id imported_op_info combined_pops) 
                 (let ((newPOpInfo 
                        (SPECTOPOSSPEC::convertOpInfoToPOpInfo-1 
                         imported_op_info))) 
                   (let ((oldPOpInfo 
                          (findAQualifierMap 
                           combined_pops 
                           imported_qualifier 
                           imported_id))) 
                     (SPECCALC::monadBind 
                      (funcall (funcall (funcall (funcall (SPECCALC::mergeOpInfo-1 
                                                           newPOpInfo) 
                                                          oldPOpInfo) 
                                                 imported_qualifier) 
                                        imported_id) 
                               |!position|) 
                      #'(lambda (mergedOps) 
                         (SPECCALC::|!return| 
                          (insertAQualifierMap 
                           combined_pops 
                           imported_qualifier 
                           imported_id 
                           mergedOps)))))))) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| 
                 (addImport 
                  (cons (SPECCALC::showTerm-1 spec_term) imported_spec) 
                  spec_a)) 
                #'(lambda (spec_b) 
                   (SPECCALC::monadBind 
                    (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                       #'(lambda (x) 
                                          (mergeSortStep 
                                           (svref x 0) 
                                           (svref x 1) 
                                           (svref x 2) 
                                           (svref x 3)))) 
                                      (svref spec_b 3)) 
                             (svref imported_spec 3)) 
                    #'(lambda (sorts_b) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| (setSorts spec_b sorts_b)) 
                        #'(lambda (spec_c) 
                           (SPECCALC::monadBind 
                            (funcall (funcall (SPECCALC::foldOverQualifierMap 
                                               #'(lambda (x) 
                                                  (mergeOpStep 
                                                   (svref x 0) 
                                                   (svref x 1) 
                                                   (svref x 2) 
                                                   (svref x 3)))) 
                                              (svref spec_c 1)) 
                                     (svref imported_spec 1)) 
                            #'(lambda (ops_c) 
                               (SPECCALC::monadBind 
                                (SPECCALC::|!return| (setOps spec_c ops_c)) 
                                #'(lambda (spec_d) 
                                   (SPECCALC::monadBind 
                                    (SPECCALC::|!return| 
                                     (setProperties 
                                      spec_d 
                                      (LISTUTILITIES::listUnion 
                                       (svref spec_d 2) 
                                       (svref imported_spec 2)))) 
                                    #'(lambda (spec_e) 
                                       (SPECCALC::|!return| spec_e)))))))))))))))))))


(defun SPECCALC::evaluateSpecImport-1 (val) 
  (let ((cDepURIs (svref val 2))
        (cTS (svref val 1))
        (spc (svref val 0))) 
    #'(lambda (x) 
       (let ((|!position| (cdr x))
             (elem (car x))) 
         (block 
          nil 
          (if (eq (car elem) :|Import|) 
              (let ((pV5388 (cdr elem))) 
                (return 
                 (SPECCALC::monadBind 
                  (SPECCALC::evaluateTermInfo-1 pV5388) 
                  #'(lambda (x1) 
                     (let ((depURIs (svref x1 2))
                           (iTS (svref x1 1))) 
                       (let ((pV5384 (SPECCALC::coerceToSpec (svref x1 0)))) 
                         (block 
                          nil 
                          (if (eq (car pV5384) :|Spec|) 
                              (return 
                               (SPECCALC::monadBind 
                                (funcall (funcall (funcall (SPECCALC::mergeImport-1 
                                                            pV5388) 
                                                           (cdr pV5384)) 
                                                  spc) 
                                         |!position|) 
                                #'(lambda (newSpc) 
                                   (SPECCALC::|!return| 
                                    (vector 
                                     newSpc 
                                     (INTEGER-SPEC::|!max| cTS iTS) 
                                     (LISTUTILITIES::listUnion cDepURIs depURIs))))))) 
                          (return 
                           (SPECCALC::raise (cons :|Fail| "Import not a spec"))))))))))) 
          (return (SPECCALC::|!return| val)))))))
                                                 
(defun SPECTOPOSSPEC::convertSpecToPosSpec-1 (spc) spc)
                                                       
(defun SPECCALC::maybeAddBaseImport (spc initialSpec) 
  (if (BOOLEAN-SPEC::~ (slang-built-in::slang-term-equals spc initialSpec)) 
      (SPECCALC::|!return| spc) 
      (SPECCALC::monadBind 
       #'SPECCALC::getCurrentURI-1 
       #'(lambda (uri) 
          (if (SPECCALC::baseSpecURI?-1 uri) 
              (SPECCALC::|!return| spc) 
              (SPECCALC::monadBind 
               (funcall (SPECCALC::evaluateURI 
                         (cons :|Internal| "adding base import")) 
                        (cons 
                         :|SpecPath_Relative| 
                         (cons '(:|None|) (cons "Library" (cons "Base" nil))))) 
               #'(lambda (x) 
                  (let ((pV5981 (svref x 0))) 
                    (block 
                     nil 
                     (if (eq (car pV5981) :|Spec|) 
                         (return 
                          (SPECCALC::|!return| 
                           (SPECTOPOSSPEC::convertSpecToPosSpec-1 (cdr pV5981))))) 
                     (error "Nonexhaustive match failure in maybeAddBaseImport"))))))))))


(defun SPECCALC::evaluateSpecElems-1 (initialSpec) 
  #'(lambda (specElems) 
     (SPECCALC::monadBind 
      (funcall (funcall (SPECCALC::foldM #'SPECCALC::evaluateSpecImport-1) 
                        (vector initialSpec 0 nil)) 
               specElems) 
      #'(lambda (x) 
         (let ((depURIs (svref x 2))
               (|!TS| (svref x 1))) 
           (SPECCALC::monadBind 
            (SPECCALC::maybeAddBaseImport (svref x 0) initialSpec) 
            #'(lambda (spcWithImports) 
               (SPECCALC::monadBind 
                (funcall (funcall (SPECCALC::foldM 
                                   #'SPECCALC::evaluateSpecElem-1) 
                                  spcWithImports) 
                         specElems) 
                #'(lambda (fullSpec) 
                   (SPECCALC::|!return| (vector fullSpec |!TS| depURIs)))))))))))


(defun SPECCALC::evaluateSpec (spec_elements) 
  (SPECCALC::monadBind 
   (funcall (SPECCALC::evaluateSpecElems-1 emptySpec) spec_elements) 
   #'(lambda (x) 
      (let ((depURIs (svref x 2))
            (|!TS| (svref x 1))) 
        (SPECCALC::monadBind 
         (SPECCALC::elaborateSpecM-1 (svref x 0)) 
         #'(lambda (elaborated_spec) 
            (SPECCALC::|!return| 
             (vector 
              (cons 
               :|Spec| 
               (vector 
                (svref elaborated_spec 0) 
                (svref elaborated_spec 1) 
                (svref elaborated_spec 2) 
                (svref elaborated_spec 3))) 
              |!TS| 
              depURIs))))))))
                             
(defun SPECCALC::makeResolvedMapping (dom_spec cod_spec sm_rules) 
  (labels 
    ((insert (pV5849 pV5850) 
      (block 
       nil 
       (let ((pV5852 (cdr pV5850))
             (pV5851 (car pV5850))) 
         (return 
          (block 
           nil 
           (if (eq (car pV5849) :|Sort|) 
               (let ((pV5835 (cdr pV5849))) 
                 (let ((pV5846 (svref pV5835 0))) 
                   (return 
                    (let ((pV5758 (STANDARDSPEC::findAllSorts dom_spec pV5846))) 
                      (block 
                       nil 
                       (if (consp pV5758) 
                           (let ((pV5762 (svref (car pV5758) 0))) 
                             (if (consp pV5762) 
                                 (let ((pV5766 (car pV5762))) 
                                   (if (eq (car pV5766) :|Qualified|) 
                                       (let ((pV5768 (cdr pV5766))) 
                                         (let ((pV5770 (cdr pV5768))
                                               (pV5769 (car pV5768))) 
                                           (return 
                                            (progn (if (lisp::or 
                                                        (slang-built-in::slang-term-equals 
                                                         (cdr pV5758) 
                                                         nil) 
                                                        (string=  
                                                         pV5769 
                                                         METASLANG::UnQualified)) 
                                                       nil 
                                                       (SYSTEM-SPEC::fail 
                                                        (STRING-SPEC::^ 
                                                         "morphism: Ambiguous source sort " 
                                                         (METASLANG::printQualifiedId 
                                                          pV5846)))) 
                                                   (let ((pV5756 
                                                          (findAQualifierMap 
                                                           pV5852 
                                                           pV5769 
                                                           pV5770))) 
                                                     (block 
                                                      nil 
                                                      (if (eq 
                                                           (car pV5756) 
                                                           :|None|) 
                                                          (return 
                                                           (cons 
                                                            pV5851 
                                                            (insertAQualifierMap 
                                                             pV5852 
                                                             pV5769 
                                                             pV5770 
                                                             (findCodSort 
                                                              (svref pV5835 1)))))) 
                                                      (return 
                                                       (SYSTEM-SPEC::fail 
                                                        (STRING-SPEC::^ 
                                                         "morphism: Multiple rules for source sort " 
                                                         (METASLANG::printQualifiedId 
                                                          pV5846))))))))))))))) 
                       (return 
                        (SYSTEM-SPEC::fail 
                         (STRING-SPEC::^ 
                          "morphism: Unrecognized source sort " 
                          (METASLANG::printQualifiedId pV5846))))))))) 
               (if (eq (car pV5849) :|Op|) 
                   (let ((pV5834 (cdr pV5849))) 
                     (let ((pV5842 (car (svref pV5834 0)))) 
                       (return 
                        (let ((pV5778 (STANDARDSPEC::findAllOps dom_spec pV5842))) 
                          (block 
                           nil 
                           (if (consp pV5778) 
                               (let ((pV5782 (svref (car pV5778) 0))) 
                                 (if (consp pV5782) 
                                     (let ((pV5787 (car pV5782))) 
                                       (if (eq (car pV5787) :|Qualified|) 
                                           (let ((pV5789 (cdr pV5787))) 
                                             (let ((pV5791 (cdr pV5789))
                                                   (pV5790 (car pV5789))) 
                                               (return 
                                                (progn (if (lisp::or 
                                                            (slang-built-in::slang-term-equals 
                                                             (cdr pV5778) 
                                                             nil) 
                                                            (string=  
                                                             pV5790 
                                                             METASLANG::UnQualified)) 
                                                           nil 
                                                           (SYSTEM-SPEC::fail 
                                                            (STRING-SPEC::^ 
                                                             "morphism: Ambiguous source op " 
                                                             (METASLANG::printQualifiedId 
                                                              pV5842)))) 
                                                       (let ((pV5776 
                                                              (findAQualifierMap 
                                                               pV5851 
                                                               pV5790 
                                                               pV5791))) 
                                                         (block 
                                                          nil 
                                                          (if (eq 
                                                               (car pV5776) 
                                                               :|None|) 
                                                              (return 
                                                               (cons 
                                                                (insertAQualifierMap 
                                                                 pV5851 
                                                                 pV5790 
                                                                 pV5791 
                                                                 (findCodOp 
                                                                  (car 
                                                                   (svref 
                                                                    pV5834 
                                                                    1)))) 
                                                                pV5852))) 
                                                          (return 
                                                           (SYSTEM-SPEC::fail 
                                                            (STRING-SPEC::^ 
                                                             "morphism: Multiple rules for source op " 
                                                             (METASLANG::printQualifiedId 
                                                              pV5842))))))))))))))) 
                           (return 
                            (SYSTEM-SPEC::fail 
                             (STRING-SPEC::^ 
                              "morphism: Unrecognized source op " 
                              (METASLANG::printQualifiedId pV5842))))))))) 
                   (if (eq (car pV5849) :|Ambiguous|) 
                       (let ((pV5833 (cdr pV5849))) 
                         (let ((pV5837 (svref pV5833 1))
                               (pV5836 (svref pV5833 0))) 
                           (return 
                            (let ((dom_sorts 
                                   (STANDARDSPEC::findAllSorts dom_spec pV5836))) 
                              (let ((dom_ops 
                                     (STANDARDSPEC::findAllOps dom_spec pV5836))) 
                                (block 
                                 nil 
                                 (if (consp dom_sorts) 
                                     (let ((pV5823 (svref (car dom_sorts) 0))) 
                                       (if (consp pV5823) 
                                           (let ((pV5827 (car pV5823))) 
                                             (if (eq (car pV5827) :|Qualified|) 
                                                 (let ((pV5829 (cdr pV5827))) 
                                                   (let ((pV5831 (cdr pV5829))
                                                         (pV5830 (car pV5829))) 
                                                     (if (null dom_ops) 
                                                         (return 
                                                          (progn (if (lisp::or 
                                                                      (slang-built-in::slang-term-equals 
                                                                       (cdr 
                                                                        dom_sorts) 
                                                                       nil) 
                                                                      (string=  
                                                                       pV5830 
                                                                       METASLANG::UnQualified)) 
                                                                     nil 
                                                                     (SYSTEM-SPEC::fail 
                                                                      (STRING-SPEC::^ 
                                                                       "morphism: Ambiguous source sort " 
                                                                       (METASLANG::printQualifiedId 
                                                                        pV5836)))) 
                                                                 (let ((pV5796 
                                                                        (findAQualifierMap 
                                                                         pV5852 
                                                                         pV5830 
                                                                         pV5831))) 
                                                                   (block 
                                                                    nil 
                                                                    (if (eq 
                                                                         (car 
                                                                          pV5796) 
                                                                         :|None|) 
                                                                        (return 
                                                                         (cons 
                                                                          pV5851 
                                                                          (insertAQualifierMap 
                                                                           pV5852 
                                                                           pV5830 
                                                                           pV5831 
                                                                           (findCodSort 
                                                                            pV5837))))) 
                                                                    (return 
                                                                     (SYSTEM-SPEC::fail 
                                                                      (STRING-SPEC::^ 
                                                                       "morphism: Multiple rules for source sort " 
                                                                       (METASLANG::printQualifiedId 
                                                                        pV5836))))))))))))))) 
                                     (if (null dom_sorts) 
                                         (if (null dom_ops) 
                                             (return 
                                              (SYSTEM-SPEC::fail 
                                               (STRING-SPEC::^ 
                                                "morphism: Unrecognized source sort/op identifier " 
                                                (METASLANG::printQualifiedId 
                                                 pV5836)))) 
                                             (if (consp dom_ops) 
                                                 (let ((pV5811 
                                                        (svref (car dom_ops) 0))) 
                                                   (if (consp pV5811) 
                                                       (let ((pV5816 
                                                              (car pV5811))) 
                                                         (if (eq 
                                                              (car pV5816) 
                                                              :|Qualified|) 
                                                             (let ((pV5818 
                                                                    (cdr pV5816))) 
                                                               (let ((pV5820 
                                                                      (cdr 
                                                                       pV5818))
                                                                     (pV5819 
                                                                      (car 
                                                                       pV5818))) 
                                                                 (return 
                                                                  (progn (if (lisp::or 
                                                                              (slang-built-in::slang-term-equals 
                                                                               (cdr 
                                                                                dom_ops) 
                                                                               nil) 
                                                                              (string=  
                                                                               pV5819 
                                                                               METASLANG::UnQualified)) 
                                                                             nil 
                                                                             (SYSTEM-SPEC::fail 
                                                                              (STRING-SPEC::^ 
                                                                               "morphism: Ambiguous source op " 
                                                                               (METASLANG::printQualifiedId 
                                                                                pV5836)))) 
                                                                         (let ((pV5802 
                                                                                (findAQualifierMap 
                                                                                 pV5851 
                                                                                 pV5819 
                                                                                 pV5820))) 
                                                                           (block 
                                                                            nil 
                                                                            (if (eq 
                                                                                 (car 
                                                                                  pV5802) 
                                                                                 :|None|) 
                                                                                (return 
                                                                                 (cons 
                                                                                  (insertAQualifierMap 
                                                                                   pV5851 
                                                                                   pV5819 
                                                                                   pV5820 
                                                                                   (findCodOp 
                                                                                    pV5837)) 
                                                                                  pV5852))) 
                                                                            (return 
                                                                             (SYSTEM-SPEC::fail 
                                                                              (STRING-SPEC::^ 
                                                                               "morphism: Multiple rules for source op " 
                                                                               (METASLANG::printQualifiedId 
                                                                                pV5836)))))))))))))))))) 
                                 (return 
                                  (SYSTEM-SPEC::fail 
                                   (STRING-SPEC::^ 
                                    "morphism: Ambiguous source sort/op identifier " 
                                    (METASLANG::printQualifiedId pV5836)))) 
                                 (error 
                                  "Nonexhaustive match failure in makeResolvedMapping")))))))))) 
           (error "Nonexhaustive match failure in makeResolvedMapping")))) 
       (error "Nonexhaustive match failure in makeResolvedMapping")))
     (findCodSort (qid) 
      (let ((pV5739 (STANDARDSPEC::findAllSorts cod_spec qid))) 
        (block 
         nil 
         (if (consp pV5739) 
             (let ((pV5743 (svref (car pV5739) 0))) 
               (if (consp pV5743) 
                   (let ((pV5747 (car pV5743))) 
                     (if (eq (car pV5747) :|Qualified|) 
                         (return 
                          (progn (if (lisp::or 
                                      (slang-built-in::slang-term-equals 
                                       (cdr pV5739) 
                                       nil) 
                                      (string=  
                                       (car (cdr pV5747)) 
                                       METASLANG::UnQualified)) 
                                     nil 
                                     (SYSTEM-SPEC::fail 
                                      (STRING-SPEC::^ 
                                       "morphism: Ambiguous target sort " 
                                       (METASLANG::printQualifiedId qid)))) 
                                 pV5747))))))) 
         (return 
          (SYSTEM-SPEC::fail 
           (STRING-SPEC::^ 
            "morphism: Unrecognized target sort " 
            (METASLANG::printQualifiedId qid)))))))
     (findCodOp (qid) 
      (let ((pV5720 (STANDARDSPEC::findAllOps cod_spec qid))) 
        (block 
         nil 
         (if (consp pV5720) 
             (let ((pV5724 (svref (car pV5720) 0))) 
               (if (consp pV5724) 
                   (let ((pV5729 (car pV5724))) 
                     (if (eq (car pV5729) :|Qualified|) 
                         (return 
                          (progn (if (lisp::or 
                                      (slang-built-in::slang-term-equals 
                                       (cdr pV5720) 
                                       nil) 
                                      (string=  
                                       (car (cdr pV5729)) 
                                       METASLANG::UnQualified)) 
                                     nil 
                                     (SYSTEM-SPEC::fail 
                                      (STRING-SPEC::^ 
                                       "morphism: Ambiguous target op " 
                                       (METASLANG::printQualifiedId qid)))) 
                                 pV5729))))))) 
         (return 
          (SYSTEM-SPEC::fail 
           (STRING-SPEC::^ 
            "morphism: Unrecognized target op " 
            (METASLANG::printQualifiedId qid)))))))) 
    (LIST-SPEC::foldr-1-1-1 
     #'(lambda (x) (insert (car x) (cdr x))) 
     (cons emptyAQualifierMap emptyAQualifierMap) 
     sm_rules)))
                
(defun SPECCALC::makeSpecMorphism (domSpec codSpec rawMapping) 
  (SPECCALC::|!return| 
   (SPECCALC::buildSpecMorphism 
    domSpec 
    codSpec 
    (SPECCALC::makeResolvedMapping domSpec codSpec rawMapping))))
                                                                 
(defun SPECCALC::evaluateSpecMorph (domTerm codTerm morphRules) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 domTerm) 
   #'(lambda (x) 
      (let ((domDepURIs (svref x 2))
            (domTimeStamp (svref x 1))
            (domValue (svref x 0))) 
        (SPECCALC::monadBind 
         (SPECCALC::evaluateTermInfo-1 codTerm) 
         #'(lambda (x1) 
            (let ((codDepURIs (svref x1 2))
                  (codTimeStamp (svref x1 1))) 
              (let ((pV5396 (SPECCALC::coerceToSpec (svref x1 0)))
                    (pV5395 (SPECCALC::coerceToSpec domValue))) 
                (block 
                 nil 
                 (if (eq (car pV5395) :|Spec|) 
                     (progn (if (eq (car pV5396) :|Spec|) 
                                (return 
                                 (SPECCALC::monadBind 
                                  (SPECCALC::makeSpecMorphism 
                                   (cdr pV5395) 
                                   (cdr pV5396) 
                                   morphRules) 
                                  #'(lambda (morph) 
                                     (SPECCALC::|!return| 
                                      (vector 
                                       (cons 
                                        :|Morph| 
                                        (vector 
                                         (svref morph 0) 
                                         (svref morph 1) 
                                         (svref morph 2) 
                                         (svref morph 3))) 
                                       (INTEGER-SPEC::|!max| 
                                        domTimeStamp 
                                        codTimeStamp) 
                                       (LISTUTILITIES::listUnion 
                                        domDepURIs 
                                        codDepURIs))))))) 
                            (return 
                             (SPECCALC::raise 
                              (cons 
                               :|TypeCheck| 
                               (cons 
                                (SPECCALC::positionOf-1 domTerm) 
                                "domain of spec morphism is not a spec")))))) 
                 (if (eq (car pV5396) :|Spec|) 
                     (return 
                      (SPECCALC::raise 
                       (cons 
                        :|TypeCheck| 
                        (cons 
                         (SPECCALC::positionOf-1 codTerm) 
                         "codomain of spec morphism is not a spec"))))) 
                 (return 
                  (SPECCALC::raise 
                   (cons 
                    :|TypeCheck| 
                    (cons 
                     (SPECCALC::positionOf-1 domTerm) 
                     "domain and codomain of spec morphism are not specs")))) 
                 (error "Nonexhaustive match failure in evaluateSpecMorph"))))))))))


(defun SPECCALC::evaluateSpecMorph-1 (x) 
  (SPECCALC::evaluateSpecMorph (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun SPECCALC::evaluateSubstitute (spec_tm sm_tm) 
  #'(lambda (term_pos) 
     (SPECCALC::monadBind 
      (SPECCALC::evaluateTermInfo-1 spec_tm) 
      #'(lambda (x) 
         (let ((spec_dep_URIs (svref x 2))
               (spec_timestamp (svref x 1))
               (spec_value (svref x 0))) 
           (SPECCALC::monadBind 
            (SPECCALC::evaluateTermInfo-1 sm_tm) 
            #'(lambda (x1) 
               (let ((sm_value (svref x1 0))) 
                 (let ((pV5406 (SPECCALC::coerceToSpec spec_value))) 
                   (block 
                    nil 
                    (if (eq (car pV5406) :|Spec|) 
                        (if (eq (car sm_value) :|Morph|) 
                            (return 
                             (let ((timeStamp 
                                    (INTEGER-SPEC::|!max| 
                                     spec_timestamp 
                                     (svref x1 1)))) 
                               (let ((dep_URIs 
                                      (LISTUTILITIES::listUnion 
                                       spec_dep_URIs 
                                       (svref x1 2)))) 
                                 (SPECCALC::monadBind 
                                  (funcall (funcall (funcall (SPECCALC::attemptSubstitution-1 
                                                              (cdr pV5406)) 
                                                             (cdr sm_value)) 
                                                    sm_tm) 
                                           term_pos) 
                                  #'(lambda (new_spec) 
                                     (SPECCALC::|!return| 
                                      (vector 
                                       (cons 
                                        :|Spec| 
                                        (vector 
                                         (svref new_spec 0) 
                                         (svref new_spec 1) 
                                         (svref new_spec 2) 
                                         (svref new_spec 3))) 
                                       timeStamp 
                                       dep_URIs))))))))) 
                    (if (eq (car sm_value) :|Morph|) 
                        (return 
                         (SPECCALC::raise 
                          (cons 
                           :|TypeCheck| 
                           (cons 
                            (SPECCALC::positionOf-1 spec_tm) 
                            "substitution attempted on a non-spec"))))) 
                    (if (eq (car pV5406) :|Spec|) 
                        (return 
                         (SPECCALC::raise 
                          (cons 
                           :|TypeCheck| 
                           (cons 
                            (SPECCALC::positionOf-1 sm_tm) 
                            "substitution is not a morphism"))))) 
                    (return 
                     (SPECCALC::raise 
                      (cons 
                       :|TypeCheck| 
                       (cons 
                        term_pos 
                        "substitution is not a morphism, and is attempted on a non-spec")))) 
                    (error "Nonexhaustive match failure in evaluateSubstitute")))))))))))


(defun SPECCALC::evaluateSubstitute-1 (x) 
  (SPECCALC::evaluateSubstitute (car x) (cdr x)))
                                                 
(defun SPECCALC::evaluateTranslate-1 (term) 
  #'(lambda (translation) 
     (SPECCALC::monadBind 
      (SPECCALC::evaluateTermInfo-1 term) 
      #'(lambda (x) 
         (let ((depURIs (svref x 2))
               (timeStamp (svref x 1))) 
           (let ((pV5461 (SPECCALC::coerceToSpec (svref x 0)))) 
             (block 
              nil 
              (if (eq (car pV5461) :|Spec|) 
                  (return 
                   (SPECCALC::monadBind 
                    (funcall (SPECCALC::translateSpec-1 (cdr pV5461)) 
                             translation) 
                    #'(lambda (spcTrans) 
                       (SPECCALC::|!return| 
                        (vector 
                         (cons 
                          :|Spec| 
                          (vector 
                           (svref spcTrans 0) 
                           (svref spcTrans 1) 
                           (svref spcTrans 2) 
                           (svref spcTrans 3))) 
                         timeStamp 
                         depURIs)))))) 
              (return 
               (SPECCALC::raise 
                (cons 
                 :|TypeCheck| 
                 (cons 
                  (SPECCALC::positionOf-1 term) 
                  "translating a term that is not a specification")))))))))))
                                                                             
(defun SPECCALC::evaluateTermInfo-1 (term) 
  (let ((pos (SPECCALC::positionOf-1 term))) 
    (let ((pV5425 (SPECCALC::valueOf-1 term))) 
      (block 
       nil 
       (if (eq (car pV5425) :|Print|) 
           (return (SPECCALC::evaluatePrint-1 (cdr pV5425))) 
           (if (eq (car pV5425) :|URI|) 
               (return 
                (funcall (SPECCALC::evaluateURI (SPECCALC::positionOf-1 term)) 
                         (cdr pV5425))) 
               (if (eq (car pV5425) :|Spec|) 
                   (return (SPECCALC::evaluateSpec (cdr pV5425))) 
                   (if (eq (car pV5425) :|SpecMorph|) 
                       (return (SPECCALC::evaluateSpecMorph-1 (cdr pV5425))) 
                       (if (eq (car pV5425) :|Diag|) 
                           (return (SPECCALC::evaluateDiag (cdr pV5425))) 
                           (if (eq (car pV5425) :|Colimit|) 
                               (return 
                                (SPECCALC::evaluateColimit-1 (cdr pV5425))) 
                               (if (eq (car pV5425) :|Subst|) 
                                   (return 
                                    (funcall (SPECCALC::evaluateSubstitute-1 
                                              (cdr pV5425)) 
                                             pos)) 
                                   (if (eq (car pV5425) :|DiagMorph|) 
                                       (return 
                                        (SPECCALC::evaluateDiagMorph-1 
                                         (cdr pV5425))) 
                                       (if (eq (car pV5425) :|Qualify|) 
                                           (let ((pV5434 (cdr pV5425))) 
                                             (return 
                                              (funcall (SPECCALC::evaluateQualify-1 
                                                        (car pV5434)) 
                                                       (cdr pV5434)))) 
                                           (if (eq (car pV5425) :|Let|) 
                                               (let ((pV5433 (cdr pV5425))) 
                                                 (return 
                                                  (funcall (SPECCALC::evaluateLet 
                                                            (car pV5433)) 
                                                           (cdr pV5433)))) 
                                               (if (eq (car pV5425) :|Where|) 
                                                   (let ((pV5432 (cdr pV5425))) 
                                                     (return 
                                                      (funcall (SPECCALC::evaluateLet 
                                                                (car pV5432)) 
                                                               (cdr pV5432)))) 
                                                   (if (eq (car pV5425) :|Hide|) 
                                                       (return 
                                                        (SPECCALC::monadSeq 
                                                         (SPECCALC::|!print| 
                                                          "hide request ignored
") 
                                                         (SPECCALC::evaluateTermInfo-1 
                                                          (cdr (cdr pV5425))))) 
                                                       (if (eq 
                                                            (car pV5425) 
                                                            :|Export|) 
                                                           (return 
                                                            (SPECCALC::monadSeq 
                                                             (SPECCALC::|!print| 
                                                              "export request ignored
") 
                                                             (SPECCALC::evaluateTermInfo-1 
                                                              (cdr (cdr pV5425))))) 
                                                           (if (eq 
                                                                (car pV5425) 
                                                                :|Translate|) 
                                                               (let ((pV5429 
                                                                      (cdr 
                                                                       pV5425))) 
                                                                 (return 
                                                                  (funcall (SPECCALC::evaluateTranslate-1 
                                                                            (car 
                                                                             pV5429)) 
                                                                           (cdr 
                                                                            pV5429)))) 
                                                               (if (eq 
                                                                    (car pV5425) 
                                                                    :|Obligations|) 
                                                                   (return 
                                                                    (SPECCALC::evaluateObligations-1 
                                                                     (cdr pV5425))) 
                                                                   (if (eq 
                                                                        (car 
                                                                         pV5425) 
                                                                        :|Prove|) 
                                                                       (return 
                                                                        (funcall (SPECCALC::evaluateProve-1 
                                                                                  (cdr 
                                                                                   pV5425)) 
                                                                                 pos)) 
                                                                       (if (eq 
                                                                            (car 
                                                                             pV5425) 
                                                                            :|Generate|) 
                                                                           (let ((pV5426 
                                                                                  (cdr 
                                                                                   pV5425))) 
                                                                             (let ((pV5445 
                                                                                    (svref 
                                                                                     pV5426 
                                                                                     2))
                                                                                   (pV5444 
                                                                                    (svref 
                                                                                     pV5426 
                                                                                     1))
                                                                                   (pV5443 
                                                                                    (svref 
                                                                                     pV5426 
                                                                                     0))) 
                                                                               (return 
                                                                                (SPECCALC::monadBind 
                                                                                 (SPECCALC::evaluateTermInfo-1 
                                                                                  pV5444) 
                                                                                 #'(lambda (x) 
                                                                                    (let ((depURIs 
                                                                                           (svref 
                                                                                            x 
                                                                                            2))
                                                                                          (timeStamp 
                                                                                           (svref 
                                                                                            x 
                                                                                            1))
                                                                                          (value 
                                                                                           (svref 
                                                                                            x 
                                                                                            0))) 
                                                                                      (SPECCALC::monadBind 
                                                                                       (SPECCALC::pathToRelativeURI 
                                                                                        "/Library/Base") 
                                                                                       #'(lambda (baseURI) 
                                                                                          (SPECCALC::monadBind 
                                                                                           (funcall (SPECCALC::evaluateURI 
                                                                                                     (cons 
                                                                                                      :|Internal| 
                                                                                                      "base")) 
                                                                                                    baseURI) 
                                                                                           #'(lambda (x1) 
                                                                                              (let ((pV5421 
                                                                                                     (svref 
                                                                                                      x1 
                                                                                                      0))) 
                                                                                                (block 
                                                                                                 nil 
                                                                                                 (if (eq 
                                                                                                      (car 
                                                                                                       pV5421) 
                                                                                                      :|Spec|) 
                                                                                                     (return 
                                                                                                      (let ((pV5419 
                                                                                                             (SPECCALC::coerceToSpec 
                                                                                                              value))) 
                                                                                                        (block 
                                                                                                         nil 
                                                                                                         (if (eq 
                                                                                                              (car 
                                                                                                               pV5419) 
                                                                                                              :|Spec|) 
                                                                                                             (return 
                                                                                                              (block 
                                                                                                               nil 
                                                                                                               (if (string=  
                                                                                                                    "lisp" 
                                                                                                                    pV5443) 
                                                                                                                   (return 
                                                                                                                    (SPECCALC::evaluateLispCompile 
                                                                                                                     (vector 
                                                                                                                      pV5419 
                                                                                                                      timeStamp 
                                                                                                                      depURIs) 
                                                                                                                     pV5444 
                                                                                                                     pV5445)) 
                                                                                                                   (if (string=  
                                                                                                                        "snark" 
                                                                                                                        pV5443) 
                                                                                                                       (return 
                                                                                                                        (SPECCALC::evaluateSnarkGen 
                                                                                                                         (vector 
                                                                                                                          pV5419 
                                                                                                                          timeStamp 
                                                                                                                          depURIs) 
                                                                                                                         pV5444 
                                                                                                                         pV5445)) 
                                                                                                                       (if (string=  
                                                                                                                            "spec" 
                                                                                                                            pV5443) 
                                                                                                                           (return 
                                                                                                                            (SPECCALC::monadSeq 
                                                                                                                             (SPECCALC::|!print| 
                                                                                                                              (SPECCALC::showValue 
                                                                                                                               pV5419)) 
                                                                                                                             (SPECCALC::|!return| 
                                                                                                                              (vector 
                                                                                                                               pV5419 
                                                                                                                               timeStamp 
                                                                                                                               depURIs)))) 
                                                                                                                           (if (string=  
                                                                                                                                "c" 
                                                                                                                                pV5443) 
                                                                                                                               (return 
                                                                                                                                (progn (CGEN::specToC-1 
                                                                                                                                        (subtractSpec-1-1 
                                                                                                                                         (cdr 
                                                                                                                                          pV5419) 
                                                                                                                                         (cdr 
                                                                                                                                          pV5421))) 
                                                                                                                                       (SPECCALC::|!return| 
                                                                                                                                        (vector 
                                                                                                                                         pV5419 
                                                                                                                                         timeStamp 
                                                                                                                                         depURIs)))))))) 
                                                                                                               (return 
                                                                                                                (SPECCALC::raise 
                                                                                                                 (cons 
                                                                                                                  :|Unsupported| 
                                                                                                                  (cons 
                                                                                                                   (SPECCALC::positionOf-1 
                                                                                                                    pV5444) 
                                                                                                                   (STRING-SPEC::^ 
                                                                                                                    (STRING-SPEC::^ 
                                                                                                                     "no generation for language " 
                                                                                                                     pV5443) 
                                                                                                                    " yet")))))))) 
                                                                                                         (return 
                                                                                                          (SPECCALC::raise 
                                                                                                           (cons 
                                                                                                            :|TypeCheck| 
                                                                                                            (cons 
                                                                                                             (SPECCALC::positionOf-1 
                                                                                                              pV5444) 
                                                                                                             "attempting to generate code from an object that is not a specification")))))))) 
                                                                                                 (error 
                                                                                                  "Nonexhaustive match failure in evaluateTermInfo")))))))))))))))))))))))))))))) 
       (error "Nonexhaustive match failure in evaluateTermInfo")))))
                                                                    
(defun SPECCALC::evaluateColimit-1 (term) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 term) 
   #'(lambda (x) 
      (let ((value (svref x 0))) 
        (SPECCALC::monadSeq 
         #'SPECWARE::saveSpecwareState-1 
         (block 
          nil 
          (if (eq (car value) :|Diag|) 
              (let ((pV5261 (cdr value))) 
                (return 
                 (let ((colimit_fn 
                        (CAT::colimit-1 (FUNCTOR::cod-1 (CAT::functor-1 pV5261))))) 
                   (let ((initial_cocone (funcall colimit_fn pV5261))) 
                     (SPECCALC::|!return| 
                      (vector 
                       (cons 
                        :|Colimit| 
                        (cons (car initial_cocone) (cdr initial_cocone))) 
                       (svref x 1) 
                       (svref x 2)))))))) 
          (return 
           (SPECCALC::raise 
            (cons 
             :|TypeCheck| 
             (cons 
              (SPECCALC::positionOf-1 term) 
              "argument of colimit is not a diagram"))))))))))
                                                              
(defun SPECCALC::evaluateColimit (x0 x1) 
  (SPECCALC::evaluateColimit-1 (cons x0 x1)))
                                             
(defun SPECCALC::evaluateColimit-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateColimit-1 x1) x2))
                                                
(defun SPECCALC::evaluateDiag-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateDiag x1) x2))
                                           
(defun SPECCALC::evaluateDiagElem-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateDiagElem-1 x1) x2) x3))
                                                              
(defun SPECCALC::evaluateDiagMorph-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateDiagMorph-1 x1) x2))
                                                  
(defun SPECCALC::evaluateGlobalDecls-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::evaluateGlobalDecls-1 x1) x2) x3) x4))
                                                                              
(defun SPECCALC::evaluateLet-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateLet x1) x2) x3))
                                                       
(defun SPECCALC::evaluateLispCompile-1 (x) 
  (SPECCALC::evaluateLispCompile (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defun SPECCALC::evaluateLispCompile-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateLispCompile-1 x1) x2))
                                                    
(defun SPECCALC::evaluateLocalDecls-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateLocalDecls x1) x2))
                                                 
(defun SPECCALC::evaluateObligations (x0 x1) 
  (SPECCALC::evaluateObligations-1 (cons x0 x1)))
                                                 
(defun SPECCALC::evaluateObligations-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateObligations-1 x1) x2))
                                                    
(defun SPECCALC::evaluatePrint (x0 x1) (SPECCALC::evaluatePrint-1 (cons x0 x1)))
                                                                                
(defun SPECCALC::evaluatePrint-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluatePrint-1 x1) x2))
                                              
(defun SPECCALC::evaluateProve-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateProve-1 x1) x2) x3))
                                                           
(defun SPECCALC::evaluateQualify (x0 x1) 
  (SPECCALC::evaluateQualify-1 (cons x0 x1)))
                                             
(defun SPECCALC::evaluateQualify-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateQualify-1 x1) x2) x3))
                                                             
(defun SPECCALC::evaluateReturnURI-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateReturnURI x1) x2) x3))
                                                             
(defun SPECCALC::evaluateSnarkGen-1 (x) 
  (SPECCALC::evaluateSnarkGen (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun SPECCALC::evaluateSnarkGen-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateSnarkGen-1 x1) x2))
                                                 
(defun SPECCALC::evaluateSpec-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateSpec x1) x2))
                                           
(defun SPECCALC::evaluateSpecElem (x0 x1 x2 x3) 
  (SPECCALC::evaluateSpecElem-1 (vector x0 x1 x2 x3)))
                                                      
(defun SPECCALC::evaluateSpecElem-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSpecElem-1 x1) x2) x3))
                                                              
(defun SPECCALC::evaluateSpecElems (x0 x1 x2 x3) 
  (SPECCALC::evaluateSpecElems-1 (vector x0 x1 x2 x3)))
                                                       
(defun SPECCALC::evaluateSpecElems-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSpecElems-1 x1) x2) x3))
                                                               
(defun SPECCALC::evaluateSpecImport (x0 x1 x2) 
  (SPECCALC::evaluateSpecImport-1 (vector x0 x1 x2)))
                                                     
(defun SPECCALC::evaluateSpecImport-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSpecImport-1 x1) x2) x3))
                                                                
(defun SPECCALC::evaluateSpecMorph-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateSpecMorph-1 x1) x2))
                                                  
(defun SPECCALC::evaluateSubstitute-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateSubstitute-1 x1) x2) x3))
                                                                
(defun SPECCALC::evaluateTerm-1 (term) 
  (SPECCALC::monadBind 
   (SPECCALC::evaluateTermInfo-1 term) 
   #'(lambda (x) (SPECCALC::|!return| (svref x 0)))))
                                                     
(defun SPECCALC::evaluateTerm (x0 x1) (SPECCALC::evaluateTerm-1 (cons x0 x1)))
                                                                              
(defun SPECCALC::evaluateTerm-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateTerm-1 x1) x2))
                                             
(defun SPECCALC::evaluateTermInfo (x0 x1) 
  (SPECCALC::evaluateTermInfo-1 (cons x0 x1)))
                                              
(defun SPECCALC::evaluateTermInfo-1-1 (x1 x2) 
  (funcall (SPECCALC::evaluateTermInfo-1 x1) x2))
                                                 
(defun SPECCALC::evaluateTranslate (x0 x1) 
  (SPECCALC::evaluateTranslate-1 (cons x0 x1)))
                                               
(defun SPECCALC::evaluateTranslate-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateTranslate-1 x1) x2) x3))
                                                               
(defun SPECCALC::evaluateURI-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::evaluateURI x1) x2) x3))
                                                       
(defun SPECCALC::fileExistsAndReadable?-1-1 (x1 x2) 
  (funcall (SPECCALC::fileExistsAndReadable? x1) x2))
                                                     
(defun SPECCALC::findDefiningURIforOp (opId spc uri depURIs globalContext rec?) 
  (labels 
    ((findLocalURI (opId) 
      (if (localOp? opId spc) 
          (cons (cons "Op" (SPECCALC::uriToPath-1 uri)) nil) 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) 
              (LIST-SPEC::|!++| 
               (SPECCALC::findDefiningURIforOpInContext 
                opId 
                (car x) 
                globalContext 
                t) 
               (cdr x))) 
           nil 
           depURIs)))) 
    (if rec? 
        (let ((pV5471 (STANDARDSPEC::findTheOp spc opId))) 
          (block 
           nil 
           (if (eq (car pV5471) :|Some|) 
               (return (findLocalURI opId)) 
               (if (eq (car pV5471) :|None|) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car opId) :|Qualified|) 
                         (let ((pV5468 (cdr opId))) 
                           (return 
                            (if (string=  (car pV5468) METASLANG::UnQualified) 
                                nil 
                                (SPECCALC::findDefiningURIforOp 
                                 (cons 
                                  :|Qualified| 
                                  (cons METASLANG::UnQualified (cdr pV5468))) 
                                 spc 
                                 uri 
                                 depURIs 
                                 globalContext 
                                 t))))) 
                     (return nil))))) 
           (error "Nonexhaustive match failure in findDefiningURIforOp"))) 
        (let ((pV5486 (STANDARDSPEC::findAllOps spc opId))) 
          (block 
           nil 
           (if (null pV5486) (return nil)) 
           (return 
            (LIST-SPEC::foldr-1-1-1 
             #'(lambda (x) 
                (block 
                 nil 
                 (let ((pV5479 (svref (car x) 0))) 
                   (if (consp pV5479) 
                       (return 
                        (LIST-SPEC::|!++| (findLocalURI (car pV5479)) (cdr x))))) 
                 (error "Nonexhaustive match failure in findDefiningURIforOp"))) 
             nil 
             pV5486)))))))
                          
(defun SPECCALC::findDefiningURIforOpInContext (opId uri globalContext rec?) 
  (let ((pV5488 (POLYMAP::evalPartial-1-1 globalContext uri))) 
    (block 
     nil 
     (if (eq (car pV5488) :|None|) 
         (return nil) 
         (if (eq (car pV5488) :|Some|) 
             (let ((pV5489 (cdr pV5488))) 
               (let ((pV5490 (svref pV5489 0))) 
                 (if (eq (car pV5490) :|Spec|) 
                     (return 
                      (SPECCALC::findDefiningURIforOp 
                       opId 
                       (cdr pV5490) 
                       uri 
                       (svref pV5489 2) 
                       globalContext 
                       rec?))))))) 
     (error "Nonexhaustive match failure in findDefiningURIforOpInContext"))))
                                                                              
(defun SPECCALC::findDefiningURIforSort
 (sortId spc uri depURIs globalContext rec?) 
  (labels 
    ((findLocalURI (sortId) 
      (if (localSort? sortId spc) 
          (cons (cons "Sort" (SPECCALC::uriToPath-1 uri)) nil) 
          (LIST-SPEC::foldr-1-1-1 
           #'(lambda (x) 
              (LIST-SPEC::|!++| 
               (SPECCALC::findDefiningURIforSortInContext 
                sortId 
                (car x) 
                globalContext 
                t) 
               (cdr x))) 
           nil 
           depURIs)))) 
    (if rec? 
        (let ((pV5500 (STANDARDSPEC::findTheSort spc sortId))) 
          (block 
           nil 
           (if (eq (car pV5500) :|Some|) 
               (return (findLocalURI sortId)) 
               (if (eq (car pV5500) :|None|) 
                   (return 
                    (block 
                     nil 
                     (if (eq (car sortId) :|Qualified|) 
                         (let ((pV5497 (cdr sortId))) 
                           (return 
                            (if (string=  (car pV5497) METASLANG::UnQualified) 
                                nil 
                                (SPECCALC::findDefiningURIforSort 
                                 (cons 
                                  :|Qualified| 
                                  (cons METASLANG::UnQualified (cdr pV5497))) 
                                 spc 
                                 uri 
                                 depURIs 
                                 globalContext 
                                 t))))) 
                     (return nil))))) 
           (error "Nonexhaustive match failure in findDefiningURIforSort"))) 
        (let ((pV5513 (STANDARDSPEC::findAllSorts spc sortId))) 
          (block 
           nil 
           (if (null pV5513) (return nil)) 
           (return 
            (LIST-SPEC::foldr-1-1-1 
             #'(lambda (x) 
                (block 
                 nil 
                 (let ((pV5507 (svref (car x) 0))) 
                   (if (consp pV5507) 
                       (return 
                        (LIST-SPEC::|!++| (findLocalURI (car pV5507)) (cdr x))))) 
                 (error "Nonexhaustive match failure in findDefiningURIforSort"))) 
             nil 
             pV5513)))))))
                          
(defun SPECCALC::findDefiningURIforSortInContext
 (sortId uri globalContext rec?) 
  (let ((pV5515 (POLYMAP::evalPartial-1-1 globalContext uri))) 
    (block 
     nil 
     (if (eq (car pV5515) :|None|) 
         (return nil) 
         (if (eq (car pV5515) :|Some|) 
             (let ((pV5516 (cdr pV5515))) 
               (let ((pV5517 (svref pV5516 0))) 
                 (if (eq (car pV5517) :|Spec|) 
                     (return 
                      (SPECCALC::findDefiningURIforSort 
                       sortId 
                       (cdr pV5517) 
                       uri 
                       (svref pV5516 2) 
                       globalContext 
                       rec?))))))) 
     (error "Nonexhaustive match failure in findDefiningURIforSortInContext"))))
                                                                                
(defun SPECCALC::searchForDefiningURIforOp (opId globalContext rec?) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (result) 
      #'(lambda (uri) 
         #'(lambda (x) 
            (let ((val (svref x 0))) 
              (block 
               nil 
               (if (consp result) 
                   (return result) 
                   (if (null result) 
                       (return 
                        (block 
                         nil 
                         (if (eq (car val) :|Spec|) 
                             (return 
                              (SPECCALC::findDefiningURIforOp 
                               opId 
                               (cdr val) 
                               uri 
                               (svref x 2) 
                               globalContext 
                               rec?))) 
                         (return nil))))) 
               (error "Nonexhaustive match failure in searchForDefiningURIforOp")))))) 
   nil 
   globalContext))
                  
(defun SPECCALC::searchForDefiningURIforSort (sortId globalContext rec?) 
  (POLYMAP::foldMap-1-1-1 
   #'(lambda (result) 
      #'(lambda (uri) 
         #'(lambda (x) 
            (let ((val (svref x 0))) 
              (block 
               nil 
               (if (consp result) 
                   (return result) 
                   (if (null result) 
                       (return 
                        (block 
                         nil 
                         (if (eq (car val) :|Spec|) 
                             (return 
                              (SPECCALC::findDefiningURIforSort 
                               sortId 
                               (cdr val) 
                               uri 
                               (svref x 2) 
                               globalContext 
                               rec?))) 
                         (return nil))))) 
               (error 
                "Nonexhaustive match failure in searchForDefiningURIforSort")))))) 
   nil 
   globalContext))
                  
(defun SPECCALC::searchForDefiningURI (|!qId| globalContext) 
  (LISTUTILITIES::removeDuplicates 
   (LIST-SPEC::|!++| 
    (SPECCALC::searchForDefiningURIforOp |!qId| globalContext nil) 
    (SPECCALC::searchForDefiningURIforSort |!qId| globalContext nil))))
                                                                       
(defun SPECCALC::findDefiningURI (|!qId| uriStr globalContext) 
  (let ((uri (SPECCALC::pathStringToCanonicalURI uriStr))) 
    (let ((pV5464 
           (LIST-SPEC::|!++| 
            (SPECCALC::findDefiningURIforOpInContext 
             |!qId| 
             uri 
             globalContext 
             nil) 
            (SPECCALC::findDefiningURIforSortInContext 
             |!qId| 
             uri 
             globalContext 
             nil)))) 
      (block 
       nil 
       (if (null pV5464) 
           (return 
            (LISTUTILITIES::removeDuplicates 
             (SPECCALC::searchForDefiningURI |!qId| globalContext)))) 
       (return (LISTUTILITIES::removeDuplicates pV5464))))))
                                                            
(defun SPECCALC::findDefiningURI-1 (x) 
  (SPECCALC::findDefiningURI (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun SPECCALC::findDefiningURIforOp-1 (x) 
  (SPECCALC::findDefiningURIforOp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun SPECCALC::findDefiningURIforOpInContext-1 (x) 
  (SPECCALC::findDefiningURIforOpInContext 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECCALC::findDefiningURIforSort-1 (x) 
  (SPECCALC::findDefiningURIforSort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun SPECCALC::findDefiningURIforSortInContext-1 (x) 
  (SPECCALC::findDefiningURIforSortInContext 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECCALC::findUnitIdforUnit-1 (x) 
  (SPECCALC::findUnitIdforUnit (car x) (cdr x)))
                                                
(defun SPECCALC::|!first|-1-1 (x1 x2) (funcall (SPECCALC::|!first| x1) x2))
                                                                           
(defun SPECCALC::fold (f) 
  #'(lambda (a) 
     #'(lambda (l) 
        (block 
         nil 
         (if (null l) 
             (return (SPECCALC::|!return| a)) 
             (if (consp l) 
                 (let ((pV5534 (cdr l))) 
                   (return 
                    (SPECCALC::monadBind 
                     (funcall (funcall f a) (car l)) 
                     #'(lambda (y) 
                        (funcall (funcall (SPECCALC::fold f) y) pV5534))))))) 
         (error "Nonexhaustive match failure in fold")))))
                                                          
(defun SPECCALC::fold-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::fold x1) x2) x3) x4))
                                                             
(defun SPECCALC::foldDoubleMap-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::foldDoubleMap x1) x2) x3) x4))
                                                                      
(defun SPECCALC::foldM-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::foldM x1) x2) x3) x4))
                                                              
(defun SPECCALC::foldMap-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::foldMap x1) x2) x3) x4))
                                                                
(defun SPECCALC::foldMapAp-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::foldMapAp x1) x2) x3))
                                                     
(defun SPECCALC::foldOverQualifierMap-1-1-1-1 (x0 x1 x2 x3) 
  (SPECCALC::foldDoubleMap-1-1-1-1 x0 x1 x2 x3))
                                                
(defun SPECCALC::garbageCollect-1-1 (full? state) 
  (progn (SYSTEM-SPEC::garbageCollect full?) (cons (cons :|Ok| nil) state)))
                                                                            
(defun SPECCALC::garbageCollect (x1) 
  #'(lambda (x2) (SPECCALC::garbageCollect-1-1 x1 x2)))
                                                       
(defun SPECCALC::generateFileList (x0 x1) 
  (SPECCALC::generateFileList-1 (cons x0 x1)))
                                              
(defun SPECCALC::generateFileList-1-1 (x1 x2) 
  (funcall (SPECCALC::generateFileList-1 x1) x2))
                                                 
(defun SPECCALC::generateURIList-1-1 (x1 x2) 
  (funcall (SPECCALC::generateURIList x1) x2))
                                              
(defun SPECCALC::getBaseSpec-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECCALC::getBaseSpec))
                          
(defun SPECCALC::getCurrentURI (x0 x1 x2 x3) 
  (SPECCALC::getCurrentURI-1 (vector x0 x1 x2 x3)))
                                                   
(defun SPECCALC::getURI (x0 x1) (SPECCALC::getURI-1 (cons x0 x1)))
                                                                  
(defun SPECCALC::getURI-1-1 (x1 x2) (funcall (SPECCALC::getURI-1 x1) x2))
                                                                         
(defun SPECCALC::inSameFile?-1 (x) (SPECCALC::inSameFile? (car x) (cdr x)))
                                                                           
(defun SPECCALC::|!last|-1-1 (x1 x2) (funcall (SPECCALC::|!last| x1) x2))
                                                                         
(defun SPECCALC::lastElem-1-1 (x1 x2) (funcall (SPECCALC::lastElem x1) x2))
                                                                           
(defun SPECCALC::loadFile (x0 x1) (SPECCALC::loadFile-1 (cons x0 x1)))
                                                                      
(defun SPECCALC::loadFile-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::loadFile-1 x1) x2) x3))
                                                      
(defun SPECCALC::localHandler-1-1 (x1 x2) 
  (funcall (SPECCALC::localHandler x1) x2))
                                           
(defun SPECCALC::lookupInGlobalContext (x0 x1) 
  (SPECCALC::lookupInGlobalContext-1 (cons x0 x1)))
                                                   
(defun SPECCALC::mFail-1-1 (str state) 
  (progn (SYSTEM-SPEC::fail str) 
         (cons (cons :|Exception| (cons :|Fail| str)) state)))
                                                              
(defun SPECCALC::mFail (x1) #'(lambda (x2) (SPECCALC::mFail-1-1 x1 x2)))
                                                                        
(defun SPECCALC::makeMorphism-1 (x) 
  (SPECCALC::makeMorphism (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                           
(defun SPECCALC::makeResolvedMapping-1 (x) 
  (SPECCALC::makeResolvedMapping (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defun SPECCALC::makeSnarkProveEvalForm-1 (x) 
  (SPECCALC::makeSnarkProveEvalForm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))
                
(defun SPECCALC::makeSpecCocone-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::makeSpecCocone-1-1-1 x1 x2 x3))))
                                                                            
(defun SPECCALC::makeSpecCocone (x0 x1) 
  (SPECCALC::makeSpecCocone-1 (cons x0 x1)))
                                            
(defun SPECCALC::makeSpecInitialCocone-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (SPECCALC::makeSpecInitialCocone-1-1-1 x1 x2 x3))))
                                                                       
(defun SPECCALC::makeSpecInitialCocone (x0 x1) 
  (SPECCALC::makeSpecInitialCocone-1 (cons x0 x1)))
                                                   
(defun SPECCALC::makeSpecMorphism-1 (x) 
  (SPECCALC::makeSpecMorphism (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun SPECCALC::makeSpecMorphism-1-1 (x1 x2) 
  (funcall (SPECCALC::makeSpecMorphism-1 x1) x2))
                                                 
(defun SPECCALC::makeTranslationMaps (x0 x1 x2 x3) 
  (SPECCALC::makeTranslationMaps-1 (vector x0 x1 x2 x3)))
                                                         
(defun SPECCALC::makeTranslationMaps-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::makeTranslationMaps-1 x1) x2) x3))
                                                                 
(defun SPECCALC::makeVertexToTranslateRulesMap-1 (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) 
        #'(lambda (x4) 
           (SPECCALC::makeVertexToTranslateRulesMap-1-1-1-1 x1 x2 x3 x4)))))
                                                                            
(defun SPECCALC::makeVertexToTranslateRulesMap (x0 x1) 
  (SPECCALC::makeVertexToTranslateRulesMap-1 (cons x0 x1)))
                                                           
(defun SPECCALC::|!map| (f) 
  #'(lambda (l) 
     (block 
      nil 
      (if (null l) 
          (return (SPECCALC::|!return| nil)) 
          (if (consp l) 
              (let ((pV5974 (cdr l))) 
                (return 
                 (SPECCALC::monadBind 
                  (funcall f (car l)) 
                  #'(lambda (xNew) 
                     (SPECCALC::monadBind 
                      (funcall (SPECCALC::|!map| f) pV5974) 
                      #'(lambda (xsNew) (SPECCALC::|!return| (cons xNew xsNew)))))))))) 
      (error "Nonexhaustive match failure in map"))))
                                                     
(defun SPECCALC::|!map|-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::|!map| x1) x2) x3))
                                                  
(defun SPECCALC::mapM-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::mapM x1) x2) x3))
                                                
(defun SPECCALC::maybeAddBaseImport-1 (x) 
  (SPECCALC::maybeAddBaseImport (car x) (cdr x)))
                                                 
(defun SPECCALC::maybeAddBaseImport-1-1 (x1 x2) 
  (funcall (SPECCALC::maybeAddBaseImport-1 x1) x2))
                                                   
(defun SPECCALC::mergeImport (x0 x1) (SPECCALC::mergeImport-1 (cons x0 x1)))
                                                                            
(defun SPECCALC::mergeImport-1-1-1-1-1 (x1 x2 x3 x4 x5) 
  (funcall (funcall (funcall (funcall (SPECCALC::mergeImport-1 x1) x2) x3) x4) 
           x5))
               
(defun SPECCALC::mergeOpInfo (x0 x1 x2 x3) 
  (SPECCALC::mergeOpInfo-1 (vector x0 x1 x2 x3)))
                                                 
(defun SPECCALC::mergeOpInfo-1-1-1-1-1-1 (x1 x2 x3 x4 x5 x6) 
  (funcall (funcall (funcall (funcall (funcall (SPECCALC::mergeOpInfo-1 x1) x2) 
                                      x3) 
                             x4) 
                    x5) 
           x6))
               
(defun SPECCALC::mergeSortInfo (x0 x1 x2) 
  (SPECCALC::mergeSortInfo-1 (vector x0 x1 x2)))
                                                
(defun SPECCALC::mergeSortInfo-1-1-1-1-1-1 (x1 x2 x3 x4 x5 x6) 
  (funcall (funcall (funcall (funcall (funcall (SPECCALC::mergeSortInfo-1 x1) x2) 
                                      x3) 
                             x4) 
                    x5) 
           x6))
               
(defun SPECCALC::mkNewSnarkTerm-1 (x) 
  (SPECCALC::mkNewSnarkTerm (car x) (cdr x)))
                                             
(defun SPECCALC::mkSnarkFmla-1 (x) 
  (SPECCALC::mkSnarkFmla 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun SPECCALC::mkSnarkFmlaApp-1 (x) 
  (SPECCALC::mkSnarkFmlaApp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6)))
                
(defun SPECCALC::mkSnarkName-1 (x) (SPECCALC::mkSnarkName (car x) (cdr x)))
                                                                           
(defun SPECCALC::mkSnarkTerm-1 (x) 
  (SPECCALC::mkSnarkTerm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun SPECCALC::mkSnarkTermApp-1 (x) 
  (SPECCALC::mkSnarkTermApp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun SPECCALC::monadSeq-1 (x) (SPECCALC::monadSeq (car x) (cdr x)))
                                                                     
(defun SPECCALC::monadSeq-1-1 (x1 x2) (funcall (SPECCALC::monadSeq-1 x1) x2))
                                                                             
(defun SPECCALC::morphismObligations-1 (x) 
  (SPECCALC::morphismObligations (car x) (cdr x)))
                                                  
(defun SPECCALC::normalizeURI-1 (x) (SPECCALC::normalizeURI (car x) (cdr x)))
                                                                             
(defun SPECCALC::opMap (x0 x1 x2 x3) (SPECCALC::opMap-1 (vector x0 x1 x2 x3)))
                                                                              
(defun SPECCALC::optSpecUnion-1-1 (x1 x2) 
  (funcall (SPECCALC::optSpecUnion x1) x2))
                                           
(defun SPECCALC::optTranslateSpec (x0 x1 x2 x3) 
  (SPECCALC::optTranslateSpec-1 (vector x0 x1 x2 x3)))
                                                      
(defun SPECCALC::optTranslateSpec-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::optTranslateSpec-1 x1) x2) x3))
                                                              
(defun SPECCALC::pathToCanonicalURI-1-1 (x1 x2) 
  (funcall (SPECCALC::pathToCanonicalURI x1) x2))
                                                 
(defun SPECCALC::pathToRelativeURI-1-1 (x1 x2) 
  (funcall (SPECCALC::pathToRelativeURI x1) x2))
                                                
(defun SPECCALC::ppAOpInfo (x0 x1 x2 x3) 
  (SPECCALC::ppAOpInfo-1 (vector x0 x1 x2 x3)))
                                               
(defun SPECCALC::ppASortInfo (x0 x1 x2) 
  (SPECCALC::ppASortInfo-1 (vector x0 x1 x2)))
                                              
(defun SPECCALC::ppASpec (x0 x1 x2 x3) 
  (SPECCALC::ppASpec-1 (vector x0 x1 x2 x3)))
                                             
(defun SPECCALC::ppAVar (id srt) 
  (WADLERLINDIG::ppConcat 
   (cons 
    (WADLERLINDIG::ppString id) 
    (cons (WADLERLINDIG::ppString ":") (cons (SPECCALC::ppASort srt) nil)))))
                                                                             
(defun SPECCALC::ppAVar-1 (x) (SPECCALC::ppAVar (car x) (cdr x)))
                                                                 
(defun SPECCALC::ppMorphismX-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::ppMorphismX-1-1-1 x1 x2 x3))))
                                                                         
(defun SPECCALC::ppMorphismX (x0 x1 x2 x3) 
  (SPECCALC::ppMorphismX-1 (vector x0 x1 x2 x3)))
                                                 
(defun SPECCALC::showQid-1-1 (qualifier id) 
  (if (string=  qualifier METASLANG::UnQualified) 
      id 
      (STRING-SPEC::^ (STRING-SPEC::^ qualifier ".") id)))
                                                          
(defun SPECCALC::ppQid (pV6577) 
  (block 
   nil 
   (if (eq (car pV6577) :|Qualified|) 
       (let ((pV6578 (cdr pV6577))) 
         (return 
          (WADLERLINDIG::ppString 
           (SPECCALC::showQid-1-1 (car pV6578) (cdr pV6578)))))) 
   (error "Nonexhaustive match failure in ppQid")))
                                                   
(defun SPECCALC::ppSpec (x0 x1 x2 x3) (SPECCALC::ppSpec-1 (vector x0 x1 x2 x3)))
                                                                                
(defun SPECCALC::ppSpecFile-1 (specFile) 
  (let ((term (car specFile))) 
    (block 
     nil 
     (if (eq (car term) :|Term|) 
         (return (SPECCALC::ppTerm-1 (cdr term))) 
         (if (eq (car term) :|Decls|) (return (SPECCALC::ppDecls (cdr term))))) 
     (error "Nonexhaustive match failure in ppSpecFile"))))
                                                           
(defun SPECCALC::ppSpecFile (x0 x1) (SPECCALC::ppSpecFile-1 (cons x0 x1)))
                                                                          
(defun SPECCALC::ppSpecToFile-1 (x) 
  (SPECCALC::ppSpecToFile (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun SPECCALC::ppSpecToTerminal-1 (spc) 
  (let ((p (SPECCALC::ppSpec-1 spc))) 
    (let ((|!t| (PRETTYPRINT::|!format| 80 p))) (PRETTYPRINT::toTerminal |!t|))))


(defun SPECCALC::ppSpecToTerminal (x0 x1 x2 x3) 
  (SPECCALC::ppSpecToTerminal-1 (vector x0 x1 x2 x3)))
                                                      
(defun SPECCALC::ppSpecsToFile (specs file preamble) 
  (let ((ps (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppSpec-1 specs))) 
    (let ((p (PRETTYPRINT::prettysAll ps))) 
      (let ((|!t| (PRETTYPRINT::|!format| 80 p))) 
        (PRETTYPRINT::toFile file (LIST-SPEC::|!++| |!t| preamble))))))
                                                                       
(defun SPECCALC::ppSpecsToFile-1 (x) 
  (SPECCALC::ppSpecsToFile (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun SPECCALC::ppTranslateExpr (translate_rules pV6658) 
  (declare (ignore pV6658)) 
  (labels 
    ((ppTranslateRule (rule pV6659) 
      (declare (ignore pV6659)) 
      (block 
       nil 
       (if (eq (car rule) :|Sort|) 
           (let ((pV6665 (cdr rule))) 
             (return 
              (WADLERLINDIG::ppConcat 
               (cons 
                (SPECCALC::ppQid (svref pV6665 0)) 
                (cons 
                 (WADLERLINDIG::ppString " -> ") 
                 (cons (SPECCALC::ppQid (svref pV6665 1)) nil)))))) 
           (if (eq (car rule) :|Op|) 
               (let ((pV6664 (cdr rule))) 
                 (return 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (SPECCALC::ppQid (car (svref pV6664 0))) 
                    (cons 
                     (WADLERLINDIG::ppString " -> ") 
                     (cons (SPECCALC::ppQid (car (svref pV6664 1))) nil)))))) 
               (if (eq (car rule) :|Ambiguous|) 
                   (let ((pV6663 (cdr rule))) 
                     (return 
                      (WADLERLINDIG::ppConcat 
                       (cons 
                        (SPECCALC::ppQid (svref pV6663 0)) 
                        (cons 
                         (WADLERLINDIG::ppString " -> ") 
                         (cons (SPECCALC::ppQid (svref pV6663 1)) nil))))))))) 
       (error "Nonexhaustive match failure in ppTranslateExpr")))) 
    (WADLERLINDIG::ppConcat 
     (cons 
      (WADLERLINDIG::ppString "{") 
      (cons 
       (WADLERLINDIG::ppSep-1-1 
        (WADLERLINDIG::ppString ", ") 
        (LIST-SPEC::|!map|-1-1 
         #'(lambda (x) (ppTranslateRule (car x) (cdr x))) 
         translate_rules)) 
       (cons (WADLERLINDIG::ppString "}") nil))))))
                                                   
(defun SPECCALC::ppTranslateExpr-1 (x) 
  (SPECCALC::ppTranslateExpr (car x) (cdr x)))
                                              
(defun SPECCALC::ppURI (x0 x1) (SPECCALC::ppURI-1 (cons x0 x1)))
                                                                
(defun SPECCALC::ppVQid (pV6681 pV6682) 
  (block 
   nil 
   (if (eq (car pV6682) :|Qualified|) 
       (let ((pV6683 (cdr pV6682))) 
         (return 
          (WADLERLINDIG::ppString 
           (STRING-SPEC::^ 
            (STRING-SPEC::^ 
             (STRING-SPEC::^ "[" (SPECCALC::vertexName pV6681)) 
             "]") 
            (SPECCALC::showQid-1-1 (car pV6683) (cdr pV6683))))))) 
   (error "Nonexhaustive match failure in ppVQid")))
                                                    
(defun SPECCALC::ppVQid-1 (x) (SPECCALC::ppVQid (car x) (cdr x)))
                                                                 
(defun SPECCALC::ppVQidQuotientSet (qset) 
  (labels 
    ((ppClass (|!class|) 
      (WADLERLINDIG::ppConcat 
       (cons 
        (WADLERLINDIG::ppString "{  ") 
        (cons 
         (WADLERLINDIG::ppSep-1-1 
          (WADLERLINDIG::ppString ", ") 
          (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppVQid-1 |!class|)) 
         (cons (WADLERLINDIG::ppString "  }") nil)))))) 
    (WADLERLINDIG::ppConcat 
     (cons 
      (WADLERLINDIG::ppString "
") 
      (cons 
       (WADLERLINDIG::ppSep-1-1 
        (WADLERLINDIG::ppString "
") 
        (LIST-SPEC::|!map|-1-1 #'ppClass qset)) 
       (cons (WADLERLINDIG::ppString "

") nil))))))
                                                    
(defun SPECCALC::ppValueInfo (value timeStamp depURIs) 
  (WADLERLINDIG::ppConcat 
   (LIST-SPEC::|!++| 
    (cons 
     (SPECCALC::ppValue value) 
     (cons (WADLERLINDIG::ppString (NAT-SPEC::toString timeStamp)) nil)) 
    (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppURI-1 depURIs))))
                                                          
(defun SPECCALC::ppValueInfo-1 (x) 
  (SPECCALC::ppValueInfo (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun SPECCALC::ppdASortInfo (x0 x1) (SPECCALC::ppdASortInfo-1 (cons x0 x1)))
                                                                              
(defun SPECCALC::printColimit-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printColimit-1-1-1 x1 x2 x3))))
                                                                          
(defun SPECCALC::printColimit (x0 x1 x2 x3) 
  (SPECCALC::printColimit-1 (vector x0 x1 x2 x3)))
                                                  
(defun SPECCALC::printDiagram-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printDiagram-1-1-1 x1 x2 x3))))
                                                                          
(defun SPECCALC::printDiagram (x0 x1 x2 x3) 
  (SPECCALC::printDiagram-1 (vector x0 x1 x2 x3)))
                                                  
(defun SPECCALC::showGlobalContext-1 (state) 
  (cons 
   (cons 
    :|Ok| 
    (WADLERLINDIG::ppFormat 
     (POLYMAP::ppMap-1-1-1 
      #'(lambda (uri) (WADLERLINDIG::ppString (SPECCALC::showURI-1 uri))) 
      #'SPECCALC::ppValueInfo-1 
      (svref state 0)))) 
   state))
          
(defun SPECCALC::printGlobalContext (x2 x1 x0 x) 
  (SPECCALC::monadBind-1-1 
   (cons 
    #'SPECCALC::showGlobalContext-1 
    #'(lambda (str) 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ (STRING-SPEC::^ "global context: " str) "
")))) 
   (vector x2 x1 x0 x)))
                        
(defun SPECCALC::printGlobalContext-1 (x) 
  (SPECCALC::printGlobalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))


(defun SPECCALC::showLocalContext-1 (state) 
  (cons 
   (cons 
    :|Ok| 
    (WADLERLINDIG::ppFormat 
     (POLYMAP::ppMap-1-1-1 
      #'SPECCALC::ppRelativeURI 
      #'SPECCALC::ppValueInfo-1 
      (svref state 1)))) 
   state))
          
(defun SPECCALC::printLocalContext (x2 x1 x0 x) 
  (SPECCALC::monadBind-1-1 
   (cons 
    #'SPECCALC::showLocalContext-1 
    #'(lambda (str) 
       (SPECCALC::|!print| 
        (STRING-SPEC::^ (STRING-SPEC::^ "local context: " str) "
")))) 
   (vector x2 x1 x0 x)))
                        
(defun SPECCALC::printLocalContext-1 (x) 
  (SPECCALC::printLocalContext (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                                
(defun SPECCALC::printMorphism-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printMorphism-1-1-1 x1 x2 x3))))
                                                                           
(defun SPECCALC::printMorphism (x0 x1 x2 x3) 
  (SPECCALC::printMorphism-1 (vector x0 x1 x2 x3)))
                                                   
(defun SPECCALC::printSpec-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPECCALC::printSpec-1-1-1 x1 x2 x3))))
                                                                       
(defun SPECCALC::printSpec (x0 x1 x2 x3) 
  (SPECCALC::printSpec-1 (vector x0 x1 x2 x3)))
                                               
(defun SPECCALC::proveInSpec-1 (x) 
  (SPECCALC::proveInSpec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6) 
   (svref x 7) 
   (svref x 8) 
   (svref x 9)))
                
(defun SPECCALC::proveInSpec-1-1 (x1 x2) 
  (funcall (SPECCALC::proveInSpec-1 x1) x2))
                                            
(defun SPECCALC::proveWithHypothesis-1 (x) 
  (SPECCALC::proveWithHypothesis 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5) 
   (svref x 6) 
   (svref x 7) 
   (svref x 8) 
   (svref x 9)))
                
(defun SPECCALC::qualifySpec (x0 x1 x2 x3) 
  (SPECCALC::qualifySpec-1 (vector x0 x1 x2 x3)))
                                                 
(defun SPECCALC::qualifySpec-1-1-1-1 (x1 x2 x3 x4) 
  (funcall (funcall (funcall (SPECCALC::qualifySpec-1 x1) x2) x3) x4))
                                                                      
(defun SPECCALC::relativizePath (x1) 
  #'(lambda (x2) (SPECCALC::relativizePath-1-1 x1 x2)))
                                                       
(defun SPECCALC::relativizeURI-1 (x1) 
  #'(lambda (x2) (SPECCALC::relativizeURI-1-1 x1 x2)))
                                                      
(defun SPECCALC::relativizeURI (x0 x1) (SPECCALC::relativizeURI-1 (cons x0 x1)))
                                                                                
(defun SPECCALC::removeFromGlobalContext (x0 x1) 
  (SPECCALC::removeFromGlobalContext-1 (cons x0 x1)))
                                                     
(defun SPECCALC::removeLast-1-1 (x1 x2) (funcall (SPECCALC::removeLast x1) x2))
                                                                               
(defun SPECCALC::removeLastElem-1-1 (x1 x2) 
  (funcall (SPECCALC::removeLastElem x1) x2))
                                             
(defun SPECCALC::reviseQId-1 (x) 
  (SPECCALC::reviseQId (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                        
(defun SPECCALC::searchContextForURI-1-1 (x1 x2) 
  (funcall (SPECCALC::searchContextForURI x1) x2))
                                                  
(defun SPECCALC::searchFileSystemForURI-1 (x) 
  (SPECCALC::searchFileSystemForURI 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECCALC::searchFileSystemForURI-1-1 (x1 x2) 
  (funcall (SPECCALC::searchFileSystemForURI-1 x1) x2))
                                                       
(defun SPECCALC::searchForDefiningURI-1 (x) 
  (SPECCALC::searchForDefiningURI (car x) (cdr x)))
                                                   
(defun SPECCALC::searchForDefiningURIforOp-1 (x) 
  (SPECCALC::searchForDefiningURIforOp (svref x 0) (svref x 1) (svref x 2)))
                                                                            
(defun SPECCALC::searchForDefiningURIforSort-1 (x) 
  (SPECCALC::searchForDefiningURIforSort (svref x 0) (svref x 1) (svref x 2)))
                                                                              
(defun SPECCALC::setCurrentURI (x0 x1) (SPECCALC::setCurrentURI-1 (cons x0 x1)))
                                                                                
(defun SPECCALC::setValidatedURI (x0 x1) 
  (SPECCALC::setValidatedURI-1 (cons x0 x1)))
                                             
(defun SPECCALC::showGlobalContext (x0 x1 x2 x3) 
  (SPECCALC::showGlobalContext-1 (vector x0 x1 x2 x3)))
                                                       
(defun SPECCALC::showIdToQualifiers (id_to_qualifiers) 
  (STRING-SPEC::toScreen 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     "
Id => Qualifiers:

" 
     (WADLERLINDIG::ppFormat 
      (WADLERLINDIG::ppConcat 
       (POLYMAP::foldMap-1-1-1 
        #'(lambda (result) 
           #'(lambda (id) 
              #'(lambda (qualifiers) 
                 (LIST-SPEC::|!cons| 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (WADLERLINDIG::ppString (STRING-SPEC::^ id " => ")) 
                    (cons 
                     (WADLERLINDIG::ppSep-1-1 
                      (WADLERLINDIG::ppString ", ") 
                      (LIST-SPEC::|!map|-1-1 #'WADLERLINDIG::ppString qualifiers)) 
                     (cons (WADLERLINDIG::ppString "
") nil)))) 
                  result)))) 
        nil 
        id_to_qualifiers)))) 
    "------------------------------------------
")))
                                                    
(defun SPECCALC::showLocalContext (x0 x1 x2 x3) 
  (SPECCALC::showLocalContext-1 (vector x0 x1 x2 x3)))
                                                      
(defun SPECCALC::showQid (x1) #'(lambda (x2) (SPECCALC::showQid-1-1 x1 x2)))
                                                                            
(defun SPECCALC::showQidToClassIndices (qid_to_class_indices) 
  (STRING-SPEC::toScreen 
   (STRING-SPEC::^ 
    "
QualifiedId => <Number of Classes>:

" 
    (WADLERLINDIG::ppFormat 
     (WADLERLINDIG::ppConcat 
      (POLYMAP::foldMap-1-1-1 
       #'(lambda (result) 
          #'(lambda (qid) 
             #'(lambda (class_indices) 
                (LIST-SPEC::|!cons| 
                 (WADLERLINDIG::ppConcat 
                  (cons 
                   (SPECCALC::ppQid qid) 
                   (cons 
                    (WADLERLINDIG::ppString 
                     (STRING-SPEC::^ 
                      (STRING-SPEC::^ 
                       " => " 
                       (NAT-SPEC::toString (LIST-SPEC::|!length| class_indices))) 
                      " classes
")) 
                    nil))) 
                 result)))) 
       nil 
       qid_to_class_indices))))))
                                 
(defun SPECCALC::showSpecFile-1 (specFile) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppSpecFile-1 specFile)))
                                                             
(defun SPECCALC::showSpecFile (x0 x1) (SPECCALC::showSpecFile-1 (cons x0 x1)))
                                                                              
(defun SPECCALC::showTerm (x0 x1) (SPECCALC::showTerm-1 (cons x0 x1)))
                                                                      
(defun SPECCALC::showURI (x0 x1) (SPECCALC::showURI-1 (cons x0 x1)))
                                                                    
(defun SPECCALC::showVQidToQidAliasesMap (vqid_to_qid_and_aliases_map) 
  (STRING-SPEC::toScreen 
   (STRING-SPEC::^ 
    (STRING-SPEC::^ 
     "
VQid => QualifiedId * Aliases:

" 
     (WADLERLINDIG::ppFormat 
      (WADLERLINDIG::ppConcat 
       (POLYMAP::foldMap-1-1-1 
        #'(lambda (result) 
           #'(lambda (vqid) 
              #'(lambda (x) 
                 (LIST-SPEC::|!cons| 
                  (WADLERLINDIG::ppConcat 
                   (cons 
                    (SPECCALC::ppVQid-1 vqid) 
                    (cons 
                     (WADLERLINDIG::ppString " => ") 
                     (cons 
                      (SPECCALC::ppQid (car x)) 
                      (cons 
                       (WADLERLINDIG::ppString " * ") 
                       (cons 
                        (WADLERLINDIG::ppSep-1-1 
                         (WADLERLINDIG::ppString ", ") 
                         (LIST-SPEC::|!map|-1-1 #'SPECCALC::ppQid (cdr x))) 
                        (cons (WADLERLINDIG::ppString "
") nil))))))) 
                  result)))) 
        nil 
        vqid_to_qid_and_aliases_map)))) 
    "------------------------------------------
")))
                                                    
(defun SPECCALC::showVQidMaps (map_info) 
  (progn (STRING-SPEC::toScreen "==========================================
") 
         (LIST-SPEC::app-1-1 
          #'(lambda (x) 
             (progn (STRING-SPEC::toScreen (STRING-SPEC::^ (car x) " rules:

")) 
                    (SPECCALC::showVQidToQidAliasesMap (cdr x)) 
                    (STRING-SPEC::toScreen "

"))) 
          map_info) 
         (STRING-SPEC::toScreen "==========================================
")))
                                                                                
(defun SPECCALC::showVQidQuotientSet (qset) 
  (WADLERLINDIG::ppFormat (SPECCALC::ppVQidQuotientSet qset)))
                                                              
(defun SPECCALC::showVQidQuotientSets (qsets_data) 
  (progn (STRING-SPEC::toScreen "------------------------------------------

") 
         (LIST-SPEC::app-1-1 
          #'(lambda (x) 
             (progn (STRING-SPEC::toScreen 
                     (STRING-SPEC::^ (car x) " quotients:
")) 
                    (STRING-SPEC::toScreen 
                     (SPECCALC::showVQidQuotientSet (cdr x))))) 
          qsets_data) 
         (STRING-SPEC::toScreen "------------------------------------------

")))


(defun SPECCALC::showVertexToTranslateExprMaps (vertex_to_sm_rules) 
  (progn (STRING-SPEC::toScreen "==========================================
") 
         (POLYMAP::foldMap-1-1-1 
          #'(lambda (|!ignore|) 
             #'(lambda (vertex) 
                #'(lambda (translate_expr) 
                   (progn (STRING-SPEC::toScreen 
                           (STRING-SPEC::^ 
                            (STRING-SPEC::^ "Translation for " vertex) 
                            "

")) 
                          (STRING-SPEC::toScreen 
                           (WADLERLINDIG::ppFormat 
                            (SPECCALC::ppTranslateExpr-1 translate_expr))) 
                          (STRING-SPEC::toScreen "

"))))) 
          nil 
          vertex_to_sm_rules) 
         (STRING-SPEC::toScreen "==========================================
")))
                                                                                
(defun SPECCALC::snarkBaseSort-1 (x) (SPECCALC::snarkBaseSort (car x) (cdr x)))
                                                                               
(defun SPECCALC::snarkBndVar (x0 x1) (SPECCALC::snarkBndVar-1 (cons x0 x1)))
                                                                            
(defparameter SPECCALC::snarkBuiltInOps SPECCALC::arithmeticFunctions)
                                                                      
(defun SPECCALC::snarkConjecture-1 (x) 
  (SPECCALC::snarkConjecture (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun SPECCALC::snarkFunctionCurryDecl-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECCALC::snarkFunctionCurryDecl))
                                     
(defun SPECCALC::snarkFunctionCurryNoArityDecl-1 (x) 
  (SPECCALC::snarkFunctionCurryNoArityDecl (car x) (cdr x)))
                                                            
(defun SPECCALC::snarkFunctionDecl-1 (x) 
  (SPECCALC::snarkFunctionDecl (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun SPECCALC::snarkFunctionNoArityDecl-1 (x) 
  (SPECCALC::snarkFunctionNoArityDecl (car x) (cdr x)))
                                                       
(defun SPECCALC::snarkFunctionNoCurryDecl-1 (x) 
  (SPECCALC::snarkFunctionNoCurryDecl 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECCALC::snarkName (x0 x1 x2 x3) 
  (SPECCALC::snarkName-1 (vector x0 x1 x2 x3)))
                                               
(defun SPECCALC::snarkOpDecl-1 (x) 
  (SPECCALC::snarkOpDecl (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun SPECCALC::snarkOpDeclPartial-1 (x) 
  (SPECCALC::snarkOpDeclPartial (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun SPECCALC::snarkOpDecls (x0 x1 x2 x3) 
  (SPECCALC::snarkOpDecls-1 (vector x0 x1 x2 x3)))
                                                  
(defun SPECCALC::snarkPBaseSort-1 (x) 
  (SPECCALC::snarkPBaseSort (car x) (cdr x)))
                                             
(defun SPECCALC::snarkPredicateDecl-1 (x) 
  (SPECCALC::snarkPredicateDecl (svref x 0) (svref x 1) (svref x 2) (svref x 3)))


(defun SPECCALC::snarkProperties (x0 x1 x2 x3) 
  (SPECCALC::snarkProperties-1 (vector x0 x1 x2 x3)))
                                                     
(defun SPECCALC::snarkProperty-1 (x) 
  (SPECCALC::snarkProperty (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun SPECCALC::snarkSorts (x0 x1 x2 x3) 
  (SPECCALC::snarkSorts-1 (vector x0 x1 x2 x3)))
                                                
(defun SPECCALC::snarkSpec (x0 x1 x2 x3) 
  (SPECCALC::snarkSpec-1 (vector x0 x1 x2 x3)))
                                               
(defun SPECCALC::sortMap (x0 x1 x2 x3) 
  (SPECCALC::sortMap-1 (vector x0 x1 x2 x3)))
                                             
(defun SPECCALC::specCat-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECCALC::specCat))
                      
(defun SPECCALC::specColimit (x0 x1) (SPECCALC::specColimit-1 (cons x0 x1)))
                                                                            
(defun SPECCALC::specObligations-1 (x) 
  (SPECCALC::specObligations (car x) (cdr x)))
                                              
(defun SPECCALC::splitAtChar (x1) 
  #'(lambda (x2) (SPECCALC::splitAtChar-1-1 x1 x2)))
                                                    
(defun SPECCALC::splitStringAtChar (x1) 
  #'(lambda (x2) (SPECCALC::splitStringAtChar-1-1 x1 x2)))
                                                          
(defun SPECCALC::takeWhile (x1) 
  #'(lambda (x2) (SPECCALC::takeWhile-1-1 x1 x2)))
                                                  
(defun SPECCALC::toSnark-1 (spc) (SPECCALC::toSnarkEnv-1 spc))
                                                              
(defun SPECCALC::toSnark (x0 x1 x2 x3) 
  (SPECCALC::toSnark-1 (vector x0 x1 x2 x3)))
                                             
(defun SPECCALC::toSnarkEnv (x0 x1 x2 x3) 
  (SPECCALC::toSnarkEnv-1 (vector x0 x1 x2 x3)))
                                                
(defun SPECCALC::toSnarkFile-1 (x) 
  (SPECCALC::toSnarkFile (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun SPECCALC::toSnarkFileEnv-1 (x) 
  (SPECCALC::toSnarkFileEnv (svref x 0) (svref x 1) (svref x 2)))
                                                                 
(defun SPECCALC::|!trace| (str) (SPECCALC::|!print| str))
                                                         
(defun SPECCALC::|!trace|-1-1 (x0 x1) (SPECCALC::|!print|-1-1 x0 x1))
                                                                     
(defun SPECCALC::translateSpec (x0 x1 x2 x3) 
  (SPECCALC::translateSpec-1 (vector x0 x1 x2 x3)))
                                                   
(defun SPECCALC::translateSpec-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::translateSpec-1 x1) x2) x3))
                                                           
(defun SPECCALC::translateTerm-1 (x) 
  (SPECCALC::translateTerm (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun SPECCALC::upToDate?-1 (x) (SPECCALC::upToDate? (car x) (cdr x)))
                                                                       
(defun SPECCALC::validateCache (x0 x1) (SPECCALC::validateCache-1 (cons x0 x1)))
                                                                                
(defun SPECCALC::validateCache-1-1 (x1 x2) 
  (funcall (SPECCALC::validateCache-1 x1) x2))
                                              
(defun SPECCALC::validatedURI? (x0 x1) (SPECCALC::validatedURI?-1 (cons x0 x1)))
                                                                                
(defun SPECCALC::warnAboutMissingItems (x0 x1 x2 x3) 
  (SPECCALC::warnAboutMissingItems-1 (vector x0 x1 x2 x3)))
                                                           
(defun SPECCALC::|!when|-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECCALC::|!when| x1) x2) x3))
                                                   
(defun SPECENVIRONMENT::arrow-1 (x) (SPECENVIRONMENT::arrow (car x) (cdr x)))
                                                                             
(defun SPECENVIRONMENT::arrowOpt-1 (x) 
  (SPECENVIRONMENT::arrowOpt (car x) (cdr x)))
                                              
(defun SPECENVIRONMENT::coproduct (sp srt) 
  (let ((pV7065 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7065) :|CoProduct|) (return (car (cdr pV7065)))) 
     (return (SYSTEM-SPEC::fail "Could not extract co-product sort")))))
                                                                        
(defun SPECENVIRONMENT::coproduct-1 (x) 
  (SPECENVIRONMENT::coproduct (car x) (cdr x)))
                                               
(defun SPECENVIRONMENT::coproductOpt (sp srt) 
  (let ((pV7071 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7071) :|CoProduct|) 
         (return (cons :|Some| (car (cdr pV7071))))) 
     (return '(:|None|)))))
                           
(defun SPECENVIRONMENT::coproductOpt-1 (x) 
  (SPECENVIRONMENT::coproductOpt (car x) (cdr x)))
                                                  
(defun SPECENVIRONMENT::domain-1 (x) (SPECENVIRONMENT::domain (car x) (cdr x)))
                                                                               
(defun SPECENVIRONMENT::getSortOfOp (spc qid opName) 
  (let ((pV7079 (STRINGMAP::find2 (svref spc 1) qid opName))) 
    (block 
     nil 
     (if (eq (car pV7079) :|None|) 
         (return 
          (progn (ANNSPECPRINTER::printSpecToTerminal-1 spc) 
                 (SYSTEM-SPEC::fail 
                  (STRING-SPEC::^ 
                   (STRING-SPEC::^ 
                    (STRING-SPEC::^ (STRING-SPEC::^ "Operator " qid) ".") 
                    opName) 
                   " has not been declared")))) 
         (if (eq (car pV7079) :|Some|) 
             (let ((pV7083 (svref (cdr pV7079) 2))) 
               (return (cons (car pV7083) (cdr pV7083)))))) 
     (error "Nonexhaustive match failure in getSortOfOp"))))
                                                            
(defun SPECENVIRONMENT::getSortOfOp-1 (x) 
  (SPECENVIRONMENT::getSortOfOp (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun SPECENVIRONMENT::inferType-1 (x) 
  (SPECENVIRONMENT::inferType (car x) (cdr x)))
                                               
(defun SPLAYMAP::foldliAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV8661 (cdr sp))) 
               (let ((pV8664 (svref pV8661 2))) 
                 (return 
                  (SPLAYMAP::foldliAp-1-1 
                   abf 
                   (cons 
                    (svref pV8661 1) 
                    (funcall abf 
                             (vector 
                              (car pV8664) 
                              (cdr pV8664) 
                              (SPLAYMAP::foldliAp-1-1 
                               abf 
                               (cons (svref pV8661 0) b))))))))))) 
     (error "Nonexhaustive match failure in foldliAp"))))
                                                         
(defun SPLAYMAP::foldli-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldliAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldli")))
                                                    
(defun STRINGMAP::foldli-1-1-1 (x0 x1 x2) (SPLAYMAP::foldli-1-1-1 x0 x1 x2))
                                                                            
(defun SPECENVIRONMENT::lookupSpec (env spcname) 
  (STRINGMAP::foldli-1-1-1 
   #'(lambda (x) 
      (let ((pV7159 (svref x 2))
            (pV7158 (svref x 1))) 
        (block 
         nil 
         (if (eq (car pV7159) :|Some|) 
             (let ((pV7160 (cdr pV7159))) 
               (return 
                (cons 
                 :|Some| 
                 (vector 
                  (svref pV7160 0) 
                  (svref pV7160 1) 
                  (svref pV7160 2) 
                  (svref pV7160 3))))) 
             (if (eq (car pV7159) :|None|) 
                 (return 
                  (if (string=  (svref x 0) spcname) 
                      (cons 
                       :|Some| 
                       (vector 
                        (svref pV7158 0) 
                        (svref pV7158 1) 
                        (svref pV7158 2) 
                        (svref pV7158 3))) 
                      '(:|None|))))) 
         (error "Nonexhaustive match failure in lookupSpec")))) 
   '(:|None|) 
   env))
        
(defun SPECENVIRONMENT::lookupSpec-1 (x) 
  (SPECENVIRONMENT::lookupSpec (car x) (cdr x)))
                                                
(defun SPECENVIRONMENT::mkProjectTerm-1 (x) 
  (SPECENVIRONMENT::mkProjectTerm (svref x 0) (svref x 1) (svref x 2)))
                                                                       
(defun SPECENVIRONMENT::mkRestrict-1 (x) 
  (SPECENVIRONMENT::mkRestrict (car x) (cdr x)))
                                                
(defun SPECENVIRONMENT::mkSelectTerm (sp id term) 
  (let ((srt (SPECENVIRONMENT::inferType sp term))) 
    (let ((fields (SPECENVIRONMENT::coproduct sp srt))) 
      (let ((pV7173 
             (LIST-SPEC::|!find|-1-1 
              #'(lambda (x) (string=  id (car x))) 
              fields))) 
        (block 
         nil 
         (if (eq (car pV7173) :|Some|) 
             (let ((pV7176 (cdr (cdr pV7173)))) 
               (if (eq (car pV7176) :|Some|) 
                   (return 
                    (STANDARDSPEC::mkApply 
                     (cons 
                      :|Fun| 
                      (vector 
                       (cons :|Select| id) 
                       (STANDARDSPEC::mkArrow srt (cdr pV7176)) 
                       POSITION-SPEC::noPos)) 
                     term))))) 
         (return (SYSTEM-SPEC::fail "Selection index not found in product")))))))


(defun SPECENVIRONMENT::mkSelectTerm-1 (x) 
  (SPECENVIRONMENT::mkSelectTerm (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defparameter SPECENVIRONMENT::primitiveSpecNames 
  (cons 
   "Nat" 
   (cons 
    "Integer" 
    (cons 
     "String" 
     (cons 
      "Char" 
      (cons 
       "Boolean" 
       (cons "General" (cons "List" (cons "TranslationBuiltIn" nil)))))))))
                                                                           
(defun SPECENVIRONMENT::product-1 (x) 
  (SPECENVIRONMENT::product (car x) (cdr x)))
                                             
(defun SPECENVIRONMENT::productOpt-1 (x) 
  (SPECENVIRONMENT::productOpt (car x) (cdr x)))
                                                
(defun SPECENVIRONMENT::range-1 (x) (SPECENVIRONMENT::range (car x) (cdr x)))
                                                                             
(defun SPECENVIRONMENT::rangeOpt-1 (x) 
  (SPECENVIRONMENT::rangeOpt (car x) (cdr x)))
                                              
(defun SPECENVIRONMENT::stripSubsorts-1 (x) 
  (SPECENVIRONMENT::stripSubsorts (car x) (cdr x)))
                                                   
(defun SPECENVIRONMENT::substSort-1 (x) 
  (SPECENVIRONMENT::substSort (car x) (cdr x)))
                                               
(defun SPECENVIRONMENT::unfoldToArrow (sp srt) 
  (labels 
    ((unfoldRec (srt) 
      (let ((usrt (SPECENVIRONMENT::unfoldBase sp srt))) 
        (if (slang-built-in::slang-term-equals usrt srt) srt (unfoldRec usrt))))) 
    (let ((usrt (unfoldRec srt))) 
      (block nil (if (eq (car usrt) :|Arrow|) (return usrt)) (return srt)))))
                                                                             
(defun SPECENVIRONMENT::termSortEnv (sp term) 
  (let ((res 
         (block 
          nil 
          (if (eq (car term) :|Apply|) 
              (return 
               (let ((pV7243 
                      (SPECENVIRONMENT::termSortEnv sp (svref (cdr term) 0)))) 
                 (block 
                  nil 
                  (if (eq (car pV7243) :|Arrow|) (return (svref (cdr pV7243) 1))) 
                  (return 
                   (SYSTEM-SPEC::fail 
                    (STRING-SPEC::^ 
                     "Cannot extract sort of application " 
                     (SYSTEM-SPEC::toString term))))))) 
              (if (eq (car term) :|Bind|) 
                  (return STANDARDSPEC::boolSort) 
                  (if (eq (car term) :|Record|) 
                      (return 
                       (cons 
                        :|Product| 
                        (cons 
                         (LIST-SPEC::|!map|-1-1 
                          #'(lambda (x) 
                             (cons 
                              (car x) 
                              (SPECENVIRONMENT::termSortEnv sp (cdr x)))) 
                          (car (cdr term))) 
                         POSITION-SPEC::noPos))) 
                      (if (eq (car term) :|Let|) 
                          (return 
                           (SPECENVIRONMENT::termSortEnv sp (svref (cdr term) 1))) 
                          (if (eq (car term) :|LetRec|) 
                              (return 
                               (SPECENVIRONMENT::termSortEnv 
                                sp 
                                (svref (cdr term) 1))) 
                              (if (eq (car term) :|Var|) 
                                  (return 
                                   (SPECENVIRONMENT::unfoldToArrow 
                                    sp 
                                    (cdr (car (cdr term))))) 
                                  (if (eq (car term) :|Fun|) 
                                      (return 
                                       (SPECENVIRONMENT::unfoldToArrow 
                                        sp 
                                        (svref (cdr term) 1))) 
                                      (if (eq (car term) :|Lambda|) 
                                          (let ((pV7279 (car (cdr term)))) 
                                            (if (consp pV7279) 
                                                (let ((pV7282 (car pV7279))) 
                                                  (return 
                                                   (STANDARDSPEC::mkArrow 
                                                    (METASLANG::patternSort 
                                                     (svref pV7282 0)) 
                                                    (SPECENVIRONMENT::termSortEnv 
                                                     sp 
                                                     (svref pV7282 2))))) 
                                                (if (null pV7279) 
                                                    (return 
                                                     (SYSTEM-SPEC::fail 
                                                      "Ill formed lambda abstraction"))))) 
                                          (if (eq (car term) :|IfThenElse|) 
                                              (return 
                                               (SPECENVIRONMENT::termSortEnv 
                                                sp 
                                                (svref (cdr term) 1))) 
                                              (if (eq (car term) :|Seq|) 
                                                  (return 
                                                   (STANDARDSPEC::mkProduct nil)))))))))))) 
          (return (SYSTEM-SPEC::fail "Non-exhaustive match"))))) res))
                                                                      
(defun SPECENVIRONMENT::termSortEnv-1 (x) 
  (SPECENVIRONMENT::termSortEnv (car x) (cdr x)))
                                                 
(defun SPECENVIRONMENT::unfoldBase-1 (x) 
  (SPECENVIRONMENT::unfoldBase (car x) (cdr x)))
                                                
(defun SPECENVIRONMENT::unfoldBaseV-1 (x) 
  (SPECENVIRONMENT::unfoldBaseV (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun SPECENVIRONMENT::unfoldStripSort1 (sp srt vsrts verbose) 
  (if (LIST-SPEC::|!member| srt vsrts) 
      srt 
      (block 
       nil 
       (if (eq (car srt) :|Arrow|) 
           (let ((pV7333 (cdr srt))) 
             (return 
              (cons 
               :|Arrow| 
               (vector 
                (SPECENVIRONMENT::unfoldStripSort1 
                 sp 
                 (svref pV7333 0) 
                 vsrts 
                 verbose) 
                (SPECENVIRONMENT::unfoldStripSort1 
                 sp 
                 (svref pV7333 1) 
                 vsrts 
                 verbose) 
                (svref pV7333 2))))) 
           (if (eq (car srt) :|Product|) 
               (let ((pV7332 (cdr srt))) 
                 (return 
                  (cons 
                   :|Product| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (cons 
                         (car x) 
                         (SPECENVIRONMENT::unfoldStripSort1 
                          sp 
                          (cdr x) 
                          vsrts 
                          verbose))) 
                     (car pV7332)) 
                    (cdr pV7332))))) 
               (if (eq (car srt) :|CoProduct|) 
                   (let ((pV7331 (cdr srt))) 
                     (return 
                      (cons 
                       :|CoProduct| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (let ((pV7321 (cdr x))
                                  (pV7320 (car x))) 
                              (block 
                               nil 
                               (if (eq (car pV7321) :|None|) 
                                   (return (cons pV7320 '(:|None|))) 
                                   (if (eq (car pV7321) :|Some|) 
                                       (return 
                                        (cons 
                                         pV7320 
                                         (cons 
                                          :|Some| 
                                          (SPECENVIRONMENT::unfoldStripSort1 
                                           sp 
                                           (cdr pV7321) 
                                           vsrts 
                                           verbose)))))) 
                               (error 
                                "Nonexhaustive match failure in unfoldStripSort1")))) 
                         (car pV7331)) 
                        (cdr pV7331))))) 
                   (if (eq (car srt) :|Quotient|) 
                       (return 
                        (SPECENVIRONMENT::unfoldStripSort1 
                         sp 
                         (svref (cdr srt) 0) 
                         vsrts 
                         verbose)) 
                       (if (eq (car srt) :|Subsort|) 
                           (return 
                            (SPECENVIRONMENT::unfoldStripSort1 
                             sp 
                             (svref (cdr srt) 0) 
                             vsrts 
                             verbose)) 
                           (if (eq (car srt) :|Base|) 
                               (let ((pV7328 (cdr srt))) 
                                 (return 
                                  (let ((srts 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (s) 
                                             (SPECENVIRONMENT::unfoldStripSort1 
                                              sp 
                                              s 
                                              vsrts 
                                              verbose)) 
                                          (svref pV7328 1)))) 
                                    (let ((srt0 
                                           (cons 
                                            :|Base| 
                                            (vector 
                                             (svref pV7328 0) 
                                             srts 
                                             (svref pV7328 2))))) 
                                      (let ((srt1 
                                             (SPECENVIRONMENT::unfoldBaseV 
                                              sp 
                                              srt0 
                                              verbose))) 
                                        (if (slang-built-in::slang-term-equals 
                                             srt1 
                                             srt0) 
                                            srt1 
                                            (SPECENVIRONMENT::unfoldStripSort1 
                                             sp 
                                             srt1 
                                             (LIST-SPEC::|!cons| srt0 vsrts) 
                                             verbose))))))) 
                               (if (eq (car srt) :|TyVar|) (return srt)))))))) 
       (error "Nonexhaustive match failure in unfoldStripSort1"))))
                                                                   
(defun SPECENVIRONMENT::unfoldStripSort (spc srt verbose) 
  (SPECENVIRONMENT::unfoldStripSort1 spc srt nil verbose))
                                                          
(defun SPECENVIRONMENT::unfoldStripSort-1 (x) 
  (SPECENVIRONMENT::unfoldStripSort (svref x 0) (svref x 1) (svref x 2)))
                                                                         
(defun SPECENVIRONMENT::unfoldStripSort1-1 (x) 
  (SPECENVIRONMENT::unfoldStripSort1 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECENVIRONMENT::unfoldToArrow-1 (x) 
  (SPECENVIRONMENT::unfoldToArrow (car x) (cdr x)))
                                                   
(defun SPECTOLISP::blockAtom-1 (x) 
  (SPECTOLISP::blockAtom (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                          
(defun SPECTOLISP::countOccurrence2-1 (x) 
  (SPECTOLISP::countOccurrence2 (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun SPECTOLISP::curryShapeNum-1 (x) 
  (SPECTOLISP::curryShapeNum (car x) (cdr x)))
                                              
(defun SPECTOLISP::defAliasFn-1 (x) (SPECTOLISP::defAliasFn (car x) (cdr x)))
                                                                             
(defun SPECTOLISP::defCurryByUncurry-1 (x) 
  (SPECTOLISP::defCurryByUncurry (car x) (cdr x)))
                                                  
(defun SPECTOLISP::defNaryByUnary-1 (x) 
  (SPECTOLISP::defNaryByUnary (car x) (cdr x)))
                                               
(defun SPECTOLISP::defUnaryByNary-1 (x) 
  (SPECTOLISP::defUnaryByNary (car x) (cdr x)))
                                               
(defun SPECTOLISP::defUncurryByUnary-1 (x) 
  (SPECTOLISP::defUncurryByUnary (car x) (cdr x)))
                                                  
(defun SPECTOLISP::duplicateString-1 (x) 
  (SPECTOLISP::duplicateString (car x) (cdr x)))
                                                
(defun SPECTOLISP::fullCurriedApplication-1 (x) 
  (SPECTOLISP::fullCurriedApplication 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun SPECTOLISP::functionSort?-1 (x) 
  (SPECTOLISP::functionSort? (car x) (cdr x)))
                                              
(defun SPECTOLISP::hasConsDomain-1 (x) 
  (SPECTOLISP::hasConsDomain (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun SPECTOLISP::hasConsEmbed (sp srt) 
  (let ((pV7568 (SPECENVIRONMENT::stripSubsorts sp srt))) 
    (block 
     nil 
     (if (eq (car pV7568) :|Arrow|) 
         (return 
          (let ((pV7565 (SPECTOLISP::isConsDataType sp (svref (cdr pV7568) 1)))) 
            (block 
             nil 
             (if (eq (car pV7565) :|Some|) 
                 (return t) 
                 (if (eq (car pV7565) :|None|) (return nil))) 
             (error "Nonexhaustive match failure in hasConsEmbed"))))) 
     (return nil))))
                    
(defun SPECTOLISP::hasConsEmbed-1 (x) 
  (SPECTOLISP::hasConsEmbed (car x) (cdr x)))
                                             
(defun SPECTOLISP::initializeSpecId-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECTOLISP::initializeSpecId))
                                 
(defun SPECTOLISP::isConsDataType-1 (x) 
  (SPECTOLISP::isConsDataType (car x) (cdr x)))
                                               
(defun SPECTOLISP::isConsIdentifier-1 (x) 
  (SPECTOLISP::isConsIdentifier (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun SPECTOLISP::isPairProjection-1 (x) 
  (SPECTOLISP::isPairProjection (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun SPECTOLISP::ith-1 (x) 
  (SPECTOLISP::ith (svref x 0) (svref x 1) (svref x 2)))
                                                        
(defun SPECTOLISP::|!lisp| (x0 x1 x2 x3) 
  (SPECTOLISP::|!lisp|-1 (vector x0 x1 x2 x3)))
                                               
(defun SPECTOLISP::lispBlock-1 (x) 
  (SPECTOLISP::lispBlock (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                          
(defun SPECTOLISP::lispTerm-1 (x) 
  (SPECTOLISP::lispTerm (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun SPECTOLISP::lookupSpecId-1 (x) 
  (SPECTOLISP::lookupSpecId (car x) (cdr x)))
                                             
(defun SPECTOLISP::mkLApplyArity-1 (x) 
  (SPECTOLISP::mkLApplyArity (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                              
(defun SPECTOLISP::mkLEqualityOp-1 (x) 
  (SPECTOLISP::mkLEqualityOp (car x) (cdr x)))
                                              
(defun SPECTOLISP::mkLTerm-1 (x) 
  (SPECTOLISP::mkLTerm (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                        
(defun SPECTOLISP::mkLTermList-1 (x) 
  (SPECTOLISP::mkLTermList (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                            
(defun SPECTOLISP::mkLTermOp-1 (x) 
  (SPECTOLISP::mkLTermOp 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun SPECTOLISP::mkLUnaryFnRef-1 (x) 
  (SPECTOLISP::mkLUnaryFnRef (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun SPECTOLISP::nTupleDerefs-1 (x) 
  (SPECTOLISP::nTupleDerefs (car x) (cdr x)))
                                             
(defun SPECTOLISP::newName-1 (x) (SPECTOLISP::newName (car x) (cdr x)))
                                                                       
(defun SPECTOLISP::opArity-1 (x) 
  (SPECTOLISP::opArity (svref x 0) (svref x 1) (svref x 2)))
                                                            
(defun SPECTOLISP::printPackageId-1 (x) 
  (SPECTOLISP::printPackageId (car x) (cdr x)))
                                               
(defun SPECTOLISP::projectionIndex-1 (x) 
  (SPECTOLISP::projectionIndex (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun SPECTOLISP::toLisp-1 (spc) (SPECTOLISP::toLispEnv-1 spc))
                                                                
(defun SPECTOLISP::toLisp (x0 x1 x2 x3) 
  (SPECTOLISP::toLisp-1 (vector x0 x1 x2 x3)))
                                              
(defun SPECTOLISP::toLispEnv (x0 x1 x2 x3) 
  (SPECTOLISP::toLispEnv-1 (vector x0 x1 x2 x3)))
                                                 
(defun SPECTOLISP::toLispFile-1 (x) 
  (SPECTOLISP::toLispFile (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun SPECTOLISP::toLispFileEnv-1 (x) 
  (SPECTOLISP::toLispFileEnv (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun SPECTOLISP::toLispText-1 (spc) 
  (let ((lSpc (SPECTOLISP::toLispEnv-1 spc))) 
    (let ((p (LISTADT::ppSpec-1 lSpc))) (PRETTYPRINT::|!format| 80 p))))
                                                                        
(defun SPECTOLISP::toLispText (x0 x1 x2 x3) 
  (SPECTOLISP::toLispText-1 (vector x0 x1 x2 x3)))
                                                  
(defun SPECTOLISP::unCurryDef-1 (x) (SPECTOLISP::unCurryDef (car x) (cdr x)))
                                                                             
(defun SPECTOLISP::unCurryName-1 (x) (SPECTOLISP::unCurryName (car x) (cdr x)))
                                                                               
(defun SPECTOPOSSPEC::convertFunToPFun (f) 
  (block 
   nil 
   (if (eq (car f) :|Equals|) 
       (return '(:|Equals|)) 
       (if (eq (car f) :|Op|) 
           (let ((pV8278 (cdr f))) 
             (return (cons :|Op| (cons (car pV8278) (cdr pV8278))))) 
           (if (eq (car f) :|Project|) 
               (return (cons :|Project| (cdr f))) 
               (if (eq (car f) :|Embed|) 
                   (let ((pV8276 (cdr f))) 
                     (return (cons :|Embed| (cons (car pV8276) (cdr pV8276))))) 
                   (if (eq (car f) :|Embedded|) 
                       (return (cons :|Embedded| (cdr f))) 
                       (if (eq (car f) :|Nat|) 
                           (return (cons :|Nat| (cdr f))) 
                           (if (eq (car f) :|Char|) 
                               (return (cons :|Char| (cdr f))) 
                               (if (eq (car f) :|String|) 
                                   (return (cons :|String| (cdr f))) 
                                   (if (eq (car f) :|Bool|) 
                                       (return (cons :|Bool| (cdr f))) 
                                       (if (eq (car f) :|Quotient|) 
                                           (return '(:|Quotient|)) 
                                           (if (eq (car f) :|Choose|) 
                                               (return '(:|Choose|)) 
                                               (if (eq (car f) :|Restrict|) 
                                                   (return '(:|Restrict|)) 
                                                   (if (eq (car f) :|Relax|) 
                                                       (return '(:|Relax|)) 
                                                       (if (eq 
                                                            (car f) 
                                                            :|OneName|) 
                                                           (let ((pV8270 (cdr f))) 
                                                             (return 
                                                              (cons 
                                                               :|OneName| 
                                                               (cons 
                                                                (car pV8270) 
                                                                (cdr pV8270))))) 
                                                           (if (eq 
                                                                (car f) 
                                                                :|TwoNames|) 
                                                               (let ((pV8269 
                                                                      (cdr f))) 
                                                                 (return 
                                                                  (cons 
                                                                   :|TwoNames| 
                                                                   (vector 
                                                                    (svref 
                                                                     pV8269 
                                                                     0) 
                                                                    (svref 
                                                                     pV8269 
                                                                     1) 
                                                                    (svref 
                                                                     pV8269 
                                                                     2)))))))))))))))))))) 
   (error "Nonexhaustive match failure in convertFunToPFun")))
                                                              
(defun SPECTOPOSSPEC::convertOpInfoToPOpInfo (x0 x1 x2 x3) 
  (SPECTOPOSSPEC::convertOpInfoToPOpInfo-1 (vector x0 x1 x2 x3)))
                                                                 
(defun SPECTOPOSSPEC::convertVarToPVar (n s) 
  (cons n (SPECTOPOSSPEC::convertSortToPSort s)))
                                                 
(defun SPECTOPOSSPEC::convertVarToPVar-1 (x) 
  (SPECTOPOSSPEC::convertVarToPVar (car x) (cdr x)))
                                                    
(defun SPECTOPOSSPEC::convertVarsToPVars (vars) 
  (LIST-SPEC::|!map|-1-1 #'SPECTOPOSSPEC::convertVarToPVar-1 vars))
                                                                   
(defun SPECTOPOSSPEC::convertTermToPTerm (term) 
  (let ((pos (cons :|Internal| "converted from linked term"))) 
    (block 
     nil 
     (if (eq (car term) :|Apply|) 
         (let ((pV8388 (cdr term))) 
           (return 
            (cons 
             :|ApplyN| 
             (cons 
              (cons 
               (SPECTOPOSSPEC::convertTermToPTerm (svref pV8388 0)) 
               (cons (SPECTOPOSSPEC::convertTermToPTerm (svref pV8388 1)) nil)) 
              pos)))) 
         (if (eq (car term) :|Record|) 
             (return 
              (cons 
               :|Record| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (SPECTOPOSSPEC::convertTermToPTerm (cdr x)))) 
                 (car (cdr term))) 
                pos))) 
             (if (eq (car term) :|Bind|) 
                 (let ((pV8386 (cdr term))) 
                   (return 
                    (cons 
                     :|Bind| 
                     (vector 
                      (svref pV8386 0) 
                      (SPECTOPOSSPEC::convertVarsToPVars (svref pV8386 1)) 
                      (SPECTOPOSSPEC::convertTermToPTerm (svref pV8386 2)) 
                      pos)))) 
                 (if (eq (car term) :|Let|) 
                     (let ((pV8385 (cdr term))) 
                       (return 
                        (cons 
                         :|Let| 
                         (vector 
                          (LIST-SPEC::|!map|-1-1 
                           #'(lambda (x) 
                              (cons 
                               (SPECTOPOSSPEC::convertPatternToPPattern (car x)) 
                               (SPECTOPOSSPEC::convertTermToPTerm (cdr x)))) 
                           (svref pV8385 0)) 
                          (SPECTOPOSSPEC::convertTermToPTerm (svref pV8385 1)) 
                          pos)))) 
                     (if (eq (car term) :|LetRec|) 
                         (let ((pV8384 (cdr term))) 
                           (return 
                            (cons 
                             :|LetRec| 
                             (vector 
                              (LIST-SPEC::|!map|-1-1 
                               #'(lambda (x) 
                                  (cons 
                                   (SPECTOPOSSPEC::convertVarToPVar-1 (car x)) 
                                   (SPECTOPOSSPEC::convertTermToPTerm (cdr x)))) 
                               (svref pV8384 0)) 
                              (SPECTOPOSSPEC::convertTermToPTerm 
                               (svref pV8384 1)) 
                              pos)))) 
                         (if (eq (car term) :|Var|) 
                             (let ((pV8400 (car (cdr term)))) 
                               (return 
                                (cons 
                                 :|Var| 
                                 (cons 
                                  (cons 
                                   (car pV8400) 
                                   (SPECTOPOSSPEC::convertSortToPSort 
                                    (cdr pV8400))) 
                                  pos)))) 
                             (if (eq (car term) :|Fun|) 
                                 (let ((pV8382 (cdr term))) 
                                   (return 
                                    (let ((srt 
                                           (SPECTOPOSSPEC::convertSortToPSort 
                                            (svref pV8382 1)))) 
                                      (cons 
                                       :|Fun| 
                                       (vector 
                                        (SPECTOPOSSPEC::convertFunToPFun 
                                         (svref pV8382 0)) 
                                        srt 
                                        pos))))) 
                                 (if (eq (car term) :|Lambda|) 
                                     (return 
                                      (cons 
                                       :|Lambda| 
                                       (cons 
                                        (LIST-SPEC::|!map|-1-1 
                                         #'(lambda (x) 
                                            (vector 
                                             (SPECTOPOSSPEC::convertPatternToPPattern 
                                              (svref x 0)) 
                                             (SPECTOPOSSPEC::convertTermToPTerm 
                                              (svref x 1)) 
                                             (SPECTOPOSSPEC::convertTermToPTerm 
                                              (svref x 2)))) 
                                         (car (cdr term))) 
                                        pos))) 
                                     (if (eq (car term) :|IfThenElse|) 
                                         (let ((pV8380 (cdr term))) 
                                           (return 
                                            (cons 
                                             :|IfThenElse| 
                                             (vector 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV8380 0)) 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV8380 1)) 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV8380 2)) 
                                              pos)))) 
                                         (if (eq (car term) :|Seq|) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'SPECTOPOSSPEC::convertTermToPTerm 
                                                 (car (cdr term))) 
                                                pos))))))))))))) 
     (error "Nonexhaustive match failure in convertTermToPTerm"))))
                                                                   
(defun SPECTOPOSSPEC::convertSortToPSort (s) 
  (let ((pos (cons :|Internal| "converted from linked sort"))) 
    (block 
     nil 
     (if (eq (car s) :|Arrow|) 
         (let ((pV8349 (cdr s))) 
           (return 
            (cons 
             :|Arrow| 
             (vector 
              (SPECTOPOSSPEC::convertSortToPSort (svref pV8349 0)) 
              (SPECTOPOSSPEC::convertSortToPSort (svref pV8349 1)) 
              pos)))) 
         (if (eq (car s) :|Product|) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (SPECTOPOSSPEC::convertSortToPSort (cdr x)))) 
                 (car (cdr s))) 
                pos))) 
             (if (eq (car s) :|CoProduct|) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((s1 (cdr x))) 
                          (cons 
                           (car x) 
                           (block 
                            nil 
                            (if (eq (car s1) :|None|) 
                                (return '(:|None|)) 
                                (if (eq (car s1) :|Some|) 
                                    (return 
                                     (cons 
                                      :|Some| 
                                      (SPECTOPOSSPEC::convertSortToPSort 
                                       (cdr s1)))))) 
                            (error 
                             "Nonexhaustive match failure in convertSortToPSort"))))) 
                     (car (cdr s))) 
                    pos))) 
                 (if (eq (car s) :|Quotient|) 
                     (let ((pV8346 (cdr s))) 
                       (return 
                        (cons 
                         :|Quotient| 
                         (vector 
                          (SPECTOPOSSPEC::convertSortToPSort (svref pV8346 0)) 
                          (SPECTOPOSSPEC::convertTermToPTerm (svref pV8346 1)) 
                          pos)))) 
                     (if (eq (car s) :|Subsort|) 
                         (let ((pV8345 (cdr s))) 
                           (return 
                            (cons 
                             :|Subsort| 
                             (vector 
                              (SPECTOPOSSPEC::convertSortToPSort 
                               (svref pV8345 0)) 
                              (SPECTOPOSSPEC::convertTermToPTerm 
                               (svref pV8345 1)) 
                              pos)))) 
                         (if (eq (car s) :|Base|) 
                             (let ((pV8344 (cdr s))) 
                               (return 
                                (cons 
                                 :|Base| 
                                 (vector 
                                  (svref pV8344 0) 
                                  (LIST-SPEC::|!map|-1-1 
                                   #'SPECTOPOSSPEC::convertSortToPSort 
                                   (svref pV8344 1)) 
                                  pos)))) 
                             (if (eq (car s) :|TyVar|) 
                                 (return 
                                  (cons :|TyVar| (cons (car (cdr s)) pos)))))))))) 
     (error "Nonexhaustive match failure in convertSortToPSort"))))
                                                                   
(defun SPECTOPOSSPEC::convertPatternToPPattern (p) 
  (let ((pos (cons :|Internal| "converted from linked pattern"))) 
    (block 
     nil 
     (if (eq (car p) :|StringPat|) 
         (return (cons :|StringPat| (cons (car (cdr p)) pos))) 
         (if (eq (car p) :|BoolPat|) 
             (return (cons :|BoolPat| (cons (car (cdr p)) pos))) 
             (if (eq (car p) :|CharPat|) 
                 (return (cons :|CharPat| (cons (car (cdr p)) pos))) 
                 (if (eq (car p) :|NatPat|) 
                     (return (cons :|NatPat| (cons (car (cdr p)) pos))) 
                     (if (eq (car p) :|VarPat|) 
                         (return 
                          (cons 
                           :|VarPat| 
                           (cons 
                            (SPECTOPOSSPEC::convertVarToPVar-1 (car (cdr p))) 
                            pos))) 
                         (if (eq (car p) :|WildPat|) 
                             (return 
                              (cons 
                               :|WildPat| 
                               (cons 
                                (SPECTOPOSSPEC::convertSortToPSort (car (cdr p))) 
                                pos))) 
                             (if (eq (car p) :|AliasPat|) 
                                 (let ((pV8299 (cdr p))) 
                                   (return 
                                    (cons 
                                     :|AliasPat| 
                                     (vector 
                                      (SPECTOPOSSPEC::convertPatternToPPattern 
                                       (svref pV8299 0)) 
                                      (SPECTOPOSSPEC::convertPatternToPPattern 
                                       (svref pV8299 1)) 
                                      pos)))) 
                                 (if (eq (car p) :|RelaxPat|) 
                                     (let ((pV8298 (cdr p))) 
                                       (return 
                                        (cons 
                                         :|RelaxPat| 
                                         (vector 
                                          (SPECTOPOSSPEC::convertPatternToPPattern 
                                           (svref pV8298 0)) 
                                          (SPECTOPOSSPEC::convertTermToPTerm 
                                           (svref pV8298 1)) 
                                          pos)))) 
                                     (if (eq (car p) :|QuotientPat|) 
                                         (let ((pV8297 (cdr p))) 
                                           (return 
                                            (cons 
                                             :|QuotientPat| 
                                             (vector 
                                              (SPECTOPOSSPEC::convertPatternToPPattern 
                                               (svref pV8297 0)) 
                                              (SPECTOPOSSPEC::convertTermToPTerm 
                                               (svref pV8297 1)) 
                                              pos)))) 
                                         (if (eq (car p) :|RecordPat|) 
                                             (return 
                                              (cons 
                                               :|RecordPat| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (x) 
                                                    (cons 
                                                     (car x) 
                                                     (SPECTOPOSSPEC::convertPatternToPPattern 
                                                      (cdr x)))) 
                                                 (car (cdr p))) 
                                                pos))) 
                                             (if (eq (car p) :|EmbedPat|) 
                                                 (let ((pV8295 (cdr p))) 
                                                   (let ((pV8307 
                                                          (svref pV8295 1))) 
                                                     (return 
                                                      (cons 
                                                       :|EmbedPat| 
                                                       (vector 
                                                        (svref pV8295 0) 
                                                        (block 
                                                         nil 
                                                         (if (eq 
                                                              (car pV8307) 
                                                              :|None|) 
                                                             (return '(:|None|)) 
                                                             (if (eq 
                                                                  (car pV8307) 
                                                                  :|Some|) 
                                                                 (return 
                                                                  (cons 
                                                                   :|Some| 
                                                                   (SPECTOPOSSPEC::convertPatternToPPattern 
                                                                    (cdr pV8307)))))) 
                                                         (error 
                                                          "Nonexhaustive match failure in convertPatternToPPattern")) 
                                                        (SPECTOPOSSPEC::convertSortToPSort 
                                                         (svref pV8295 2)) 
                                                        pos)))))))))))))))) 
     (error "Nonexhaustive match failure in convertPatternToPPattern"))))
                                                                         
(defun SPECTOPOSSPEC::convertSortInfoToPSortInfo (x0 x1 x2) 
  (SPECTOPOSSPEC::convertSortInfoToPSortInfo-1 (vector x0 x1 x2)))
                                                                  
(defun SPECTOPOSSPEC::convertSpecToPosSpec (x0 x1 x2 x3) 
  (SPECTOPOSSPEC::convertSpecToPosSpec-1 (vector x0 x1 x2 x3)))
                                                               
(defun SPECUNION::opsUnion-1-1 (x1 x2) (funcall (SPECUNION::opsUnion x1) x2))
                                                                             
(defun SPECUNION::propertiesUnion-1-1 (x1 x2) 
  (funcall (SPECUNION::propertiesUnion x1) x2))
                                               
(defun SPECUNION::sortsUnion-1-1 (x1 x2) 
  (funcall (SPECUNION::sortsUnion x1) x2))
                                          
(defun SPECUNION::specUnion-1-1 (x1 x2) (funcall (SPECUNION::specUnion x1) x2))
                                                                               
(defun SPECUNION::unionOpMaps-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECUNION::unionOpMaps x1) x2) x3))
                                                        
(defun SPECUNION::unionSortMaps-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECUNION::unionSortMaps x1) x2) x3))
                                                          
(defun SPECWARE::maybeAddSuffix-1-1 (path suffix) 
  (if (LIST-SPEC::|!member| #\. (STRING-SPEC::explode path)) 
      path 
      (STRING-SPEC::^ path suffix)))
                                    
(defun SPECWARE::removeSWsuffix (path) 
  (let ((pV8491 (LIST-SPEC::rev (STRING-SPEC::explode path)))) 
    (block 
     nil 
     (if (consp pV8491) 
         (let ((pV8494 (cdr pV8491))) 
           (if (eq #\w (car pV8491)) 
               (if (consp pV8494) 
                   (let ((pV8497 (cdr pV8494))) 
                     (if (eq #\s (car pV8494)) 
                         (if (consp pV8497) 
                             (if (eq #\. (car pV8497)) 
                                 (return 
                                  (STRING-SPEC::implode 
                                   (LIST-SPEC::rev (cdr pV8497)))))))))))) 
     (return path))))
                     
(defun SPECWARE::evaluateLispCompile_fromLisp (path targetFile) 
  (let ((target 
         (block 
          nil 
          (if (eq (car targetFile) :|None|) 
              (return '(:|None|)) 
              (if (eq (car targetFile) :|Some|) 
                  (return 
                   (cons 
                    :|Some| 
                    (SPECWARE::maybeAddSuffix-1-1 (cdr targetFile) ".lisp"))))) 
          (error "Nonexhaustive match failure in evaluateLispCompile_fromLisp")))) 
    (let ((run 
           (SPECCALC::monadSeq 
            #'SPECWARE::restoreSavedSpecwareState-1 
            (SPECCALC::monadBind 
             (SPECCALC::pathToCanonicalURI ".") 
             #'(lambda (currentURI) 
                (SPECCALC::monadSeq 
                 (SPECCALC::setCurrentURI-1 currentURI) 
                 (SPECCALC::monadBind 
                  (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                  #'(lambda (path_body) 
                     (SPECCALC::monadBind 
                      (SPECCALC::pathToRelativeURI path_body) 
                      #'(lambda (uri) 
                         (SPECCALC::monadBind 
                          (SPECCALC::|!return| 
                           (cons 
                            :|String| 
                            (vector 
                             path 
                             POSITION-SPEC::startLineColumnByte 
                             (POSITION-SPEC::endLineColumnByte path_body)))) 
                          #'(lambda (|!position|) 
                             (SPECCALC::monadBind 
                              (funcall (SPECCALC::evaluateURI |!position|) uri) 
                              #'(lambda (spcInfo) 
                                 (SPECCALC::monadSeq 
                                  (SPECCALC::evaluateLispCompile 
                                   spcInfo 
                                   (cons (cons :|URI| uri) |!position|) 
                                   target) 
                                  (SPECCALC::monadSeq 
                                   #'SPECWARE::saveSpecwareState-1 
                                   (SPECCALC::|!return| t))))))))))))))))) 
      (let ((x 
             (SPECCALC::|!catch|-1-1-1 
              run 
              #'SPECWARE::toplevelHandler 
              SPECWARE::ignoredState))) 
        (let ((pV8424 (car x))) 
          (block 
           nil 
           (if (eq (car pV8424) :|Ok|) 
               (return (cdr pV8424)) 
               (if (eq (car pV8424) :|Exception|) 
                   (return 
                    (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
           (error "Nonexhaustive match failure in evaluateLispCompile_fromLisp")))))))


(defun SPECWARE::evaluateLispCompile_fromLisp-1 (x) 
  (SPECWARE::evaluateLispCompile_fromLisp (car x) (cdr x)))
                                                           
(defun SPECWARE::evaluatePrint_fromLisp (path) 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToCanonicalURI ".") 
           #'(lambda (currentURI) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 currentURI) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                #'(lambda (path_body) 
                   (SPECCALC::monadBind 
                    (SPECCALC::pathToRelativeURI path_body) 
                    #'(lambda (uri) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| 
                         (cons 
                          :|String| 
                          (vector 
                           path 
                           POSITION-SPEC::startLineColumnByte 
                           (POSITION-SPEC::endLineColumnByte path_body)))) 
                        #'(lambda (|!position|) 
                           (SPECCALC::monadSeq 
                            (SPECCALC::evaluatePrint 
                             (cons :|URI| uri) 
                             |!position|) 
                            (SPECCALC::monadSeq 
                             #'SPECWARE::saveSpecwareState-1 
                             (SPECCALC::|!return| t))))))))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECWARE::ignoredState))) 
      (let ((pV8431 (car x))) 
        (block 
         nil 
         (if (eq (car pV8431) :|Ok|) 
             (return (cdr pV8431)) 
             (if (eq (car pV8431) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in evaluatePrint_fromLisp"))))))
                                                                             
(defun SPECWARE::fileNameHandler (unitId) 
  #'(lambda (except) 
     (block 
      nil 
      (if (eq (car except) :|URINotFound|) 
          (return 
           (if (slang-built-in::slang-term-equals (cdr (cdr except)) unitId) 
               (SPECCALC::|!return| nil) 
               (SPECCALC::raise except)))) 
      (return (SPECCALC::raise except)))))
                                          
(defun SPECWARE::evaluateURI_fromLisp (path) 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           (SPECCALC::pathToCanonicalURI ".") 
           #'(lambda (currentURI) 
              (SPECCALC::monadSeq 
               (SPECCALC::setCurrentURI-1 currentURI) 
               (SPECCALC::monadBind 
                (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
                #'(lambda (path_body) 
                   (SPECCALC::monadBind 
                    (SPECCALC::pathToRelativeURI path_body) 
                    #'(lambda (uri) 
                       (SPECCALC::monadBind 
                        (SPECCALC::|!return| 
                         (cons 
                          :|String| 
                          (vector 
                           path 
                           POSITION-SPEC::startLineColumnByte 
                           (POSITION-SPEC::endLineColumnByte path_body)))) 
                        #'(lambda (|!position|) 
                           (SPECCALC::monadSeq 
                            (funcall (SPECCALC::|!catch| 
                                      (SPECCALC::monadSeq 
                                       (funcall (SPECCALC::evaluateURI 
                                                 |!position|) 
                                                uri) 
                                       (SPECCALC::|!return| nil))) 
                                     (SPECWARE::fileNameHandler uri)) 
                            (SPECCALC::monadSeq 
                             #'SPECWARE::saveSpecwareState-1 
                             (SPECCALC::|!return| t))))))))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECWARE::ignoredState))) 
      (let ((pV8438 (car x))) 
        (block 
         nil 
         (if (eq (car pV8438) :|Ok|) 
             (return (cdr pV8438)) 
             (if (eq (car pV8438) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in evaluateURI_fromLisp"))))))
                                                                           
(defun SPECWARE::fileNameHandler-1-1-1 (x1 x2 x3) 
  (funcall (funcall (SPECWARE::fileNameHandler x1) x2) x3))
                                                           
(defparameter SPECWARE::initializeSavedSpecwareState 
  (let ((x (SPECWARE::saveSpecwareState-1 SPECCALC::initialSpecwareState))) 
    (let ((pV8450 (car x))) 
      (block 
       nil 
       (if (eq (car pV8450) :|Ok|) 
           (return (STRING-SPEC::toScreen "Initializing Specware state ...")) 
           (if (eq (car pV8450) :|Exception|) 
               (return (SYSTEM-SPEC::fail "initializeSavedSpecwareState failed")))) 
       (error "Nonexhaustive match failure in initializeSavedSpecwareState")))))
                                                                                
(defun SPECWARE::listLoadedUnits () 
  (let ((run 
         (SPECCALC::monadSeq 
          #'SPECWARE::restoreSavedSpecwareState-1 
          (SPECCALC::monadBind 
           #'SPECCALC::getGlobalContext-1 
           #'(lambda (globalContext) 
              (SPECCALC::monadBind 
               (SPECCALC::|!return| 
                (POLYMAP::foldMap-1-1-1 
                 #'(lambda (lst) 
                    #'(lambda (dom) 
                       #'(lambda (pV8454) 
                          (declare (ignore pV8454)) 
                          (cons dom lst)))) 
                 nil 
                 globalContext)) 
               #'(lambda (uriList) 
                  (SPECCALC::monadSeq 
                   (SPECCALC::|!print| 
                    (WADLERLINDIG::ppFormat 
                     (WADLERLINDIG::ppSep-1-1 
                      WADLERLINDIG::ppNewline 
                      (LIST-SPEC::|!map|-1-1 
                       #'(lambda (uri) 
                          (WADLERLINDIG::ppString (SPECCALC::uriToString-1 uri))) 
                       uriList)))) 
                   (SPECCALC::monadSeq 
                    #'SPECWARE::saveSpecwareState-1 
                    (SPECCALC::|!return| t)))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECWARE::ignoredState))) 
      (let ((pV8458 (car x))) 
        (block 
         nil 
         (if (eq (car pV8458) :|Ok|) 
             (return (cdr pV8458)) 
             (if (eq (car pV8458) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in listLoadedUnits"))))))
                                                                      
(defun SPECWARE::listLoadedUnits-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECWARE::listLoadedUnits))
                              
(defun SPECWARE::maybeAddSuffix (x1) 
  #'(lambda (x2) (SPECWARE::maybeAddSuffix-1-1 x1 x2)))
                                                       
(defun SPECWARE::toplevelLoop (x2 x1 x0 x) 
  (SPECCALC::|!return|-1-1 t (vector x2 x1 x0 x)))
                                                  
(defun SPECWARE::toplevelLoop-1 (x) 
  (SPECWARE::toplevelLoop (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                           
(defun SPECWARE::runSpecware () 
  (let ((x 
         (SPECCALC::|!catch|-1-1-1 
          #'SPECWARE::toplevelLoop-1 
          #'SPECWARE::toplevelHandler 
          SPECCALC::initialSpecwareState))) 
    (let ((pV8504 (car x))) 
      (block 
       nil 
       (if (eq (car pV8504) :|Ok|) 
           (return 
            (SYSTEM-SPEC::fail "Specware toplevel loop terminated unexpectedly")) 
           (if (eq (car pV8504) :|Exception|) 
               (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
       (error "Nonexhaustive match failure in runSpecware")))))
                                                               
(defun SPECWARE::runSpecware-1 (ignore) 
  (declare (ignore ignore)) 
  (SPECWARE::runSpecware))
                          
(defun SPECWARE::runSpecwareURI (path) 
  (let ((run 
         (SPECCALC::monadBind 
          (SPECCALC::pathToCanonicalURI ".") 
          #'(lambda (currentURI) 
             (SPECCALC::monadSeq 
              (SPECCALC::setCurrentURI-1 currentURI) 
              (SPECCALC::monadBind 
               (SPECCALC::|!return| (SPECWARE::removeSWsuffix path)) 
               #'(lambda (path_body) 
                  (SPECCALC::monadBind 
                   (SPECCALC::pathToRelativeURI path_body) 
                   #'(lambda (uri) 
                      (SPECCALC::monadBind 
                       (SPECCALC::|!return| 
                        (cons 
                         :|String| 
                         (vector 
                          path 
                          POSITION-SPEC::startLineColumnByte 
                          (POSITION-SPEC::endLineColumnByte path_body)))) 
                       #'(lambda (|!position|) 
                          (SPECCALC::monadSeq 
                           (funcall (SPECCALC::evaluateURI |!position|) uri) 
                           (SPECCALC::|!return| t))))))))))))) 
    (let ((x 
           (SPECCALC::|!catch|-1-1-1 
            run 
            #'SPECWARE::toplevelHandler 
            SPECCALC::initialSpecwareState))) 
      (let ((pV8511 (car x))) 
        (block 
         nil 
         (if (eq (car pV8511) :|Ok|) 
             (return (cdr pV8511)) 
             (if (eq (car pV8511) :|Exception|) 
                 (return (SYSTEM-SPEC::fail "Specware toplevel handler failed")))) 
         (error "Nonexhaustive match failure in runSpecwareURI"))))))
                                                                     
(defun SPECWARE::toplevelHandler-1-1 (x1 x2) 
  (funcall (SPECWARE::toplevelHandler x1) x2))
                                              
(defun SPLAYMAP::all-1-1 (p? m) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (lisp::and (svref x 2) (funcall p? (cons (svref x 0) (svref x 1))))) 
   t 
   m))
      
(defun SPLAYMAP::all (x1) #'(lambda (x2) (SPLAYMAP::all-1-1 x1 x2)))
                                                                    
(defun SPLAYMAP::ap (x1) #'(lambda (x2) (SPLAYMAP::ap-1-1 x1 x2)))
                                                                  
(defun SPLAYMAP::api (x1) #'(lambda (x2) (SPLAYMAP::api-1-1 x1 x2)))
                                                                    
(defun SPLAYMAP::app (x1) #'(lambda (x2) (SPLAYMAP::app-1-1 x1 x2)))
                                                                    
(defun SPLAYMAP::|!apply| (x1) 
  #'(lambda (x2) (SPLAYMAP::|!apply|-1-1 x1 x2)))
                                                 
(defun SPLAYMAP::applyi (x1) #'(lambda (x2) (SPLAYMAP::applyi-1-1 x1 x2)))
                                                                          
(defun SPLAYMAP::compOf (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return (cdr |!map|)) 
       (if (eq (car |!map|) :|MAP|) (return (svref (cdr |!map|) 0)))) 
   (error "Nonexhaustive match failure in compOf")))
                                                    
(defun SPLAYMAP::compOf-1-1 (x1 x2) (funcall (SPLAYMAP::compOf x1) x2))
                                                                       
(defun SPLAYMAP::left (sp |!rest|) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) 
       (return |!rest|) 
       (if (eq (car sp) :|SplayObj|) 
           (return 
            (SPLAYMAP::left (svref (cdr sp) 0) (LIST-SPEC::|!cons| sp |!rest|))))) 
   (error "Nonexhaustive match failure in left")))
                                                  
(defun SPLAYMAP::next (splays) 
  (block 
   nil 
   (if (consp splays) 
       (let ((pV8780 (car splays))) 
         (if (eq (car pV8780) :|SplayObj|) 
             (return 
              (cons pV8780 (SPLAYMAP::left (svref (cdr pV8780) 1) (cdr splays))))))) 
   (return (cons '(:|SplayNil|) nil))))
                                       
(defun SPLAYMAP::compare-1-1 (cmpRng x) 
  (let ((map1 (car x))
        (map2 (cdr x))) 
    (block 
     nil 
     (if (eq (car map1) :|EMPTY|) 
         (progn (if (eq (car map2) :|EMPTY|) (return '(:|Equal|))) 
                (return '(:|Less|)))) 
     (if (eq (car map2) :|EMPTY|) (return '(:|Greater|))) 
     (if (eq (car map1) :|MAP|) 
         (let ((pV8607 (cdr map1))) 
           (let ((pV8608 (svref pV8607 0))
                 (pV8610 (svref pV8607 2))) 
             (if (eq (car map2) :|MAP|) 
                 (let ((pV8614 (svref (cdr map2) 2))) 
                   (return 
                    (labels 
                      ((cmp (t1 t2) 
                        (let ((pV8581 (SPLAYMAP::next t1))
                              (pV8582 (SPLAYMAP::next t2))) 
                          (block 
                           nil 
                           (if (eq (car (car pV8581)) :|SplayNil|) 
                               (progn (if (eq (car (car pV8582)) :|SplayNil|) 
                                          (return '(:|Equal|))) 
                                      (return '(:|Less|)))) 
                           (if (eq (car (car pV8582)) :|SplayNil|) 
                               (return '(:|Greater|))) 
                           (let ((pV8583 (car pV8581))) 
                             (if (eq (car pV8583) :|SplayObj|) 
                                 (let ((pV8588 (svref (cdr pV8583) 2))) 
                                   (let ((pV8591 (car pV8582))) 
                                     (if (eq (car pV8591) :|SplayObj|) 
                                         (let ((pV8596 (svref (cdr pV8591) 2))) 
                                           (return 
                                            (let ((pV8580 
                                                   (funcall pV8608 
                                                            (cons 
                                                             (car pV8588) 
                                                             (car pV8596))))) 
                                              (block 
                                               nil 
                                               (if (eq (car pV8580) :|Equal|) 
                                                   (return 
                                                    (let ((pV8579 
                                                           (funcall cmpRng 
                                                                    (cons 
                                                                     (cdr pV8588) 
                                                                     (cdr pV8596))))) 
                                                      (block 
                                                       nil 
                                                       (if (eq 
                                                            (car pV8579) 
                                                            :|Equal|) 
                                                           (return 
                                                            (cmp 
                                                             (cdr pV8581) 
                                                             (cdr pV8582)))) 
                                                       (return pV8579))))) 
                                               (return pV8580)))))))))) 
                           (error "Nonexhaustive match failure in compare"))))) 
                      (cmp 
                       (SPLAYMAP::left (STATE::|!!| pV8610) nil) 
                       (SPLAYMAP::left (STATE::|!!| pV8614) nil))))))))) 
     (error "Nonexhaustive match failure in compare"))))
                                                        
(defun SPLAYMAP::compare (x1) #'(lambda (x2) (SPLAYMAP::compare-1-1 x1 x2)))
                                                                            
(defun SPLAYMAP::compose-1 (x) (SPLAYMAP::compose (car x) (cdr x)))
                                                                   
(defun SPLAYMAP::|!exists|-1-1 (p? m) 
  (SPLAYMAP::foldri-1-1-1 
   #'(lambda (x) 
      (lisp::or (svref x 2) (funcall p? (cons (svref x 0) (svref x 1))))) 
   nil 
   m))
      
(defun SPLAYMAP::|!exists| (x1) 
  #'(lambda (x2) (SPLAYMAP::|!exists|-1-1 x1 x2)))
                                                  
(defun SPLAYMAP::filter-1-1 (predFn m) 
  (labels 
    ((f (key item m) (if (funcall predFn item) (SPLAYMAP::insert m key item) m))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (f (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))
         
(defun SPLAYMAP::filter (x1) #'(lambda (x2) (SPLAYMAP::filter-1-1 x1 x2)))
                                                                          
(defun SPLAYMAP::filteri-1-1 (predFn m) 
  (labels 
    ((f (key item m) 
      (if (funcall predFn (cons key item)) (SPLAYMAP::insert m key item) m))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (f (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))
         
(defun SPLAYMAP::filteri (x1) #'(lambda (x2) (SPLAYMAP::filteri-1-1 x1 x2)))
                                                                            
(defun SPLAYMAP::|!find|-1 (x) (SPLAYMAP::|!find| (car x) (cdr x)))
                                                                   
(defun SPLAYMAP::findR-1 (x) 
  (SPLAYMAP::findR (svref x 0) (svref x 1) (svref x 2)))
                                                        
(defun SPLAYMAP::foldlAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV8647 (cdr sp))) 
               (return 
                (SPLAYMAP::foldlAp-1-1 
                 abf 
                 (cons 
                  (svref pV8647 1) 
                  (funcall abf 
                           (cons 
                            (cdr (svref pV8647 2)) 
                            (SPLAYMAP::foldlAp-1-1 abf (cons (svref pV8647 0) b)))))))))) 
     (error "Nonexhaustive match failure in foldlAp"))))
                                                        
(defun SPLAYMAP::foldl-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldlAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldl")))
                                                   
(defun SPLAYMAP::foldl (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldl-1-1-1 x1 x2 x3))))
                                                                   
(defun SPLAYMAP::foldlAp (x1) #'(lambda (x2) (SPLAYMAP::foldlAp-1-1 x1 x2)))
                                                                            
(defun SPLAYMAP::foldli (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldli-1-1-1 x1 x2 x3))))
                                                                    
(defun SPLAYMAP::foldliAp (x1) 
  #'(lambda (x2) (SPLAYMAP::foldliAp-1-1 x1 x2)))
                                                 
(defun SPLAYMAP::foldrAp-1-1 (abf x) 
  (let ((sp (car x))
        (b (cdr x))) 
    (block 
     nil 
     (if (eq (car sp) :|SplayNil|) 
         (return b) 
         (if (eq (car sp) :|SplayObj|) 
             (let ((pV8675 (cdr sp))) 
               (return 
                (SPLAYMAP::foldrAp-1-1 
                 abf 
                 (cons 
                  (svref pV8675 0) 
                  (funcall abf 
                           (cons 
                            (cdr (svref pV8675 2)) 
                            (SPLAYMAP::foldrAp-1-1 abf (cons (svref pV8675 1) b)))))))))) 
     (error "Nonexhaustive match failure in foldrAp"))))
                                                        
(defun SPLAYMAP::foldr-1-1-1 (abf b |!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return b) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::foldrAp-1-1 
             abf 
             (cons (STATE::|!!| (svref (cdr |!map|) 2)) b))))) 
   (error "Nonexhaustive match failure in foldr")))
                                                   
(defun SPLAYMAP::foldr (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYMAP::foldr-1-1-1 x1 x2 x3))))
                                                                   
(defun SPLAYMAP::foldrAp (x1) #'(lambda (x2) (SPLAYMAP::foldrAp-1-1 x1 x2)))
                                                                            
(defun SPLAYMAP::foldriAp (x1) 
  #'(lambda (x2) (SPLAYMAP::foldriAp-1-1 x1 x2)))
                                                 
(defun SPLAYMAP::fromList-1-1 (comp l) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (let ((pV8695 (car x))) 
        (block 
         nil 
         (return (SPLAYMAP::insert (cdr x) (car pV8695) (cdr pV8695))) 
         (error "Nonexhaustive match failure in fromList")))) 
   (SPLAYMAP::empty comp) 
   l))
      
(defun SPLAYMAP::fromList (x1) 
  #'(lambda (x2) (SPLAYMAP::fromList-1-1 x1 x2)))
                                                 
(defun SPLAYMAP::inDomain-1 (x) (SPLAYMAP::inDomain (car x) (cdr x)))
                                                                     
(defun SPLAYMAP::insert-1 (x) 
  (SPLAYMAP::insert (svref x 0) (svref x 1) (svref x 2)))
                                                         
(defun SPLAYMAP::intersectWith-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((intersect (f) 
        #'(lambda (x1) 
           (let ((|!m1| (car x1))
                 (|!m2| (cdr x1))) 
             (labels 
               ((ins (key x11 m) 
                 (let ((pV8724 (SPLAYMAP::|!find| |!m2| key))) 
                   (block 
                    nil 
                    (if (eq (car pV8724) :|None|) 
                        (return m) 
                        (if (eq (car pV8724) :|Some|) 
                            (return 
                             (SPLAYMAP::insert 
                              m 
                              key 
                              (funcall f (cons x11 (cdr pV8724))))))) 
                    (error "Nonexhaustive match failure in intersectWith"))))) 
               (SPLAYMAP::foldli-1-1-1 
                #'(lambda (x11) (ins (svref x11 0) (svref x11 1) (svref x11 2))) 
                (SPLAYMAP::empty (SPLAYMAP::compOf |!m1|)) 
                |!m1|)))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (funcall (intersect f) (cons |!m1| |!m2|)) 
          (funcall (intersect 
                    #'(lambda (x1) (funcall f (cons (cdr x1) (car x1))))) 
                   (cons |!m2| |!m1|))))))
                                          
(defun SPLAYMAP::intersectWith (x1) 
  #'(lambda (x2) (SPLAYMAP::intersectWith-1-1 x1 x2)))
                                                      
(defun SPLAYMAP::intersectWithi-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((intersect (f) 
        #'(lambda (x1) 
           (let ((|!m1| (car x1))
                 (|!m2| (cdr x1))) 
             (labels 
               ((ins (key x11 m) 
                 (let ((pV8726 (SPLAYMAP::|!find| |!m2| key))) 
                   (block 
                    nil 
                    (if (eq (car pV8726) :|None|) 
                        (return m) 
                        (if (eq (car pV8726) :|Some|) 
                            (return 
                             (SPLAYMAP::insert 
                              m 
                              key 
                              (funcall f (vector key x11 (cdr pV8726))))))) 
                    (error "Nonexhaustive match failure in intersectWithi"))))) 
               (SPLAYMAP::foldli-1-1-1 
                #'(lambda (x11) (ins (svref x11 0) (svref x11 1) (svref x11 2))) 
                (SPLAYMAP::empty (SPLAYMAP::compOf |!m1|)) 
                |!m1|)))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (funcall (intersect f) (cons |!m1| |!m2|)) 
          (funcall (intersect 
                    #'(lambda (x1) 
                       (funcall f 
                                (vector (svref x1 0) (svref x1 2) (svref x1 1))))) 
                   (cons |!m2| |!m1|))))))
                                          
(defun SPLAYMAP::intersectWithi (x1) 
  #'(lambda (x2) (SPLAYMAP::intersectWithi-1-1 x1 x2)))
                                                       
(defun SPLAYMAP::left-1 (x) (SPLAYMAP::left (car x) (cdr x)))
                                                             
(defun SPLAYMAP::listItemsf-1 (x) 
  (SPLAYMAP::listItemsf (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun SPLAYMAP::listItemsi (|!map|) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return nil) 
       (if (eq (car |!map|) :|MAP|) 
           (return 
            (SPLAYMAP::listItemsf 
             #'(lambda (v) v) 
             (STATE::|!!| (svref (cdr |!map|) 2)) 
             nil)))) 
   (error "Nonexhaustive match failure in listItemsi")))
                                                        
(defun SPLAYMAP::mapPartial-1-1 (f m) 
  (labels 
    ((g (key item m) 
      (let ((pV8767 (funcall f item))) 
        (block 
         nil 
         (if (eq (car pV8767) :|None|) 
             (return m) 
             (if (eq (car pV8767) :|Some|) 
                 (return (SPLAYMAP::insert m key (cdr pV8767))))) 
         (error "Nonexhaustive match failure in mapPartial"))))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (g (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))
         
(defun SPLAYMAP::mapPartial (x1) 
  #'(lambda (x2) (SPLAYMAP::mapPartial-1-1 x1 x2)))
                                                   
(defun SPLAYMAP::mapPartiali-1-1 (f m) 
  (labels 
    ((g (key item m) 
      (let ((pV8769 (funcall f (cons key item)))) 
        (block 
         nil 
         (if (eq (car pV8769) :|None|) 
             (return m) 
             (if (eq (car pV8769) :|Some|) 
                 (return (SPLAYMAP::insert m key (cdr pV8769))))) 
         (error "Nonexhaustive match failure in mapPartiali"))))) 
    (SPLAYMAP::foldli-1-1-1 
     #'(lambda (x) (g (svref x 0) (svref x 1) (svref x 2))) 
     (SPLAYMAP::empty (SPLAYMAP::compOf m)) 
     m)))
         
(defun SPLAYMAP::mapPartiali (x1) 
  #'(lambda (x2) (SPLAYMAP::mapPartiali-1-1 x1 x2)))
                                                    
(defun SPLAYMAP::|!remove| (|!map| key) 
  (block 
   nil 
   (if (eq (car |!map|) :|EMPTY|) 
       (return |!map|) 
       (if (eq (car |!map|) :|MAP|) 
           (let ((pV8803 (cdr |!map|))) 
             (let ((pV8807 (svref pV8803 2))
                   (pV8806 (svref pV8803 1))
                   (pV8805 (svref pV8803 0))) 
               (return 
                (let ((x 
                       (SPLAYTREE::splay 
                        #'(lambda (x) (funcall pV8805 (cons (car x) key))) 
                        (STATE::|!!| pV8807)))) 
                  (let ((pV8794 (cdr x))) 
                    (block 
                     nil 
                     (if (eq (car (car x)) :|Equal|) 
                         (if (eq (car pV8794) :|SplayObj|) 
                             (let ((pV8795 (cdr pV8794))) 
                               (return 
                                (if ( =  pV8806 1) 
                                    (cons :|EMPTY| pV8805) 
                                    (cons 
                                     :|MAP| 
                                     (vector 
                                      pV8805 
                                      (INTEGER-SPEC::|!-| pV8806 1) 
                                      (cons 
                                       :|Ref| 
                                       (SPLAYTREE::join 
                                        (svref pV8795 0) 
                                        (svref pV8795 1)))))))))) 
                     (return (progn (STATE::|:=| pV8807 pV8794) |!map|)) 
                     (error "Nonexhaustive match failure in remove"))))))))) 
   (error "Nonexhaustive match failure in remove")))
                                                    
(defun SPLAYMAP::|!remove|-1 (x) (SPLAYMAP::|!remove| (car x) (cdr x)))
                                                                       
(defun SPLAYMAP::subset? (|!m1| |!m2|) 
  (SPLAYMAP::all-1-1 
   #'(lambda (x) 
      (let ((pV8808 (SPLAYMAP::|!find| |!m2| (car x)))) 
        (block 
         nil 
         (if (eq (car pV8808) :|None|) 
             (return nil) 
             (if (eq (car pV8808) :|Some|) 
                 (return 
                  (slang-built-in::slang-term-equals (cdr x) (cdr pV8808))))) 
         (error "Nonexhaustive match failure in subset?")))) 
   |!m1|))
          
(defun SPLAYMAP::subset?-1 (x) (SPLAYMAP::subset? (car x) (cdr x)))
                                                                   
(defun SPLAYMAP::toList (x) (SPLAYMAP::listItemsi x))
                                                     
(defun SPLAYMAP::unionWith-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((ins (f) 
        #'(lambda (x1) 
           (let ((key (svref x1 0))
                 (x11 (svref x1 1))
                 (m (svref x1 2))) 
             (let ((pV8810 (SPLAYMAP::|!find| m key))) 
               (block 
                nil 
                (if (eq (car pV8810) :|None|) 
                    (return (SPLAYMAP::insert m key x11)) 
                    (if (eq (car pV8810) :|Some|) 
                        (return 
                         (SPLAYMAP::insert 
                          m 
                          key 
                          (funcall f (cons x11 (cdr pV8810))))))) 
                (error "Nonexhaustive match failure in unionWith"))))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (SPLAYMAP::foldli-1-1-1 
           (ins #'(lambda (x1) (funcall f (cons (cdr x1) (car x1))))) 
           |!m1| 
           |!m2|) 
          (SPLAYMAP::foldli-1-1-1 (ins f) |!m2| |!m1|)))))
                                                          
(defun SPLAYMAP::unionWith (x1) 
  #'(lambda (x2) (SPLAYMAP::unionWith-1-1 x1 x2)))
                                                  
(defun SPLAYMAP::unionWithi-1-1 (f x) 
  (let ((|!m1| (car x))
        (|!m2| (cdr x))) 
    (labels 
      ((ins (f) 
        #'(lambda (x1) 
           (let ((key (svref x1 0))
                 (x11 (svref x1 1))
                 (m (svref x1 2))) 
             (let ((pV8812 (SPLAYMAP::|!find| m key))) 
               (block 
                nil 
                (if (eq (car pV8812) :|None|) 
                    (return (SPLAYMAP::insert m key x11)) 
                    (if (eq (car pV8812) :|Some|) 
                        (return 
                         (SPLAYMAP::insert 
                          m 
                          key 
                          (funcall f (vector key x11 (cdr pV8812))))))) 
                (error "Nonexhaustive match failure in unionWithi"))))))) 
      (if (INTEGER-SPEC::|!>| 
           (SPLAYMAP::numItems |!m1|) 
           (SPLAYMAP::numItems |!m2|)) 
          (SPLAYMAP::foldli-1-1-1 
           (ins 
            #'(lambda (x1) 
               (funcall f (vector (svref x1 0) (svref x1 2) (svref x1 1))))) 
           |!m1| 
           |!m2|) 
          (SPLAYMAP::foldli-1-1-1 (ins f) |!m2| |!m1|)))))
                                                          
(defun SPLAYMAP::unionWithi (x1) 
  #'(lambda (x2) (SPLAYMAP::unionWithi-1-1 x1 x2)))
                                                   
(defun SPLAYSET::add-1 (x) (SPLAYSET::add (car x) (cdr x)))
                                                           
(defun SPLAYSET::addList-1 (x) (SPLAYSET::addList (car x) (cdr x)))
                                                                   
(defun SPLAYSET::add_ (s x) (SPLAYSET::add x s))
                                                
(defun SPLAYSET::add_-1 (x) (SPLAYSET::add_ (car x) (cdr x)))
                                                             
(defun SPLAYSET::appSplay (x1) 
  #'(lambda (x2) (SPLAYSET::appSplay-1-1 x1 x2)))
                                                 
(defun SPLAYSET::left (sp |!rest|) 
  (block 
   nil 
   (if (eq (car sp) :|SplayNil|) (return |!rest|)) 
   (if (eq (car sp) :|SplayObj|) 
       (return 
        (SPLAYSET::left (svref (cdr sp) 0) (LIST-SPEC::|!cons| sp |!rest|)))) 
   (error "Nonexhaustive match failure in left")))
                                                  
(defun SPLAYSET::next (splays) 
  (block 
   nil 
   (if (consp splays) 
       (let ((pV9161 (car splays))) 
         (if (eq (car pV9161) :|SplayObj|) 
             (return 
              (cons pV9161 (SPLAYSET::left (svref (cdr pV9161) 1) (cdr splays))))))) 
   (return (cons '(:|SplayNil|) nil))))
                                       
(defun SPLAYSET::cmp (comp t1 t2) 
  (let ((pV8858 (SPLAYSET::next t2))
        (pV8857 (SPLAYSET::next t1))) 
    (block 
     nil 
     (if (eq (car (car pV8857)) :|SplayNil|) 
         (progn (if (eq (car (car pV8858)) :|SplayNil|) (return '(:|Equal|))) 
                (return '(:|Less|)))) 
     (if (eq (car (car pV8858)) :|SplayNil|) (return '(:|Greater|))) 
     (let ((pV8859 (car pV8857))) 
       (if (eq (car pV8859) :|SplayObj|) 
           (let ((pV8862 (car pV8858))) 
             (if (eq (car pV8862) :|SplayObj|) 
                 (return 
                  (let ((pV8856 
                         (funcall comp 
                                  (cons 
                                   (svref (cdr pV8859) 2) 
                                   (svref (cdr pV8862) 2))))) 
                    (block 
                     nil 
                     (if (eq (car pV8856) :|Equal|) 
                         (return (SPLAYSET::cmp comp (cdr pV8857) (cdr pV8858)))) 
                     (return pV8856)))))))) 
     (error "Nonexhaustive match failure in cmp"))))
                                                    
(defun SPLAYSET::cmp-1 (x) (SPLAYSET::cmp (svref x 0) (svref x 1) (svref x 2)))
                                                                               
(defun SPLAYSET::compOf (|!set|) 
  (block 
   nil 
   (if (eq (car |!set|) :|EMPTY|) 
       (return (cdr |!set|)) 
       (if (eq (car |!set|) :|SET|) (return (svref (cdr |!set|) 0)))) 
   (error "Nonexhaustive match failure in compOf")))
                                                    
(defun SPLAYSET::compOf-1-1 (x1 x2) (funcall (SPLAYSET::compOf x1) x2))
                                                                       
(defun SPLAYSET::compare (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|EMPTY|) 
       (progn (if (eq (car set2) :|EMPTY|) (return '(:|Equal|))) 
              (return '(:|Less|)))) 
   (if (eq (car set2) :|EMPTY|) (return '(:|Greater|))) 
   (if (eq (car set1) :|SET|) 
       (let ((pV8885 (cdr set1))) 
         (if (eq (car set2) :|SET|) 
             (return 
              (SPLAYSET::cmp 
               (svref pV8885 0) 
               (SPLAYSET::left (STATE::|!!| (svref pV8885 2)) nil) 
               (SPLAYSET::left (STATE::|!!| (svref (cdr set2) 2)) nil)))))) 
   (error "Nonexhaustive match failure in compare")))
                                                     
(defun SPLAYSET::compare-1 (x) (SPLAYSET::compare (car x) (cdr x)))
                                                                   
(defun SPLAYSET::|!count|-1 (x) (SPLAYSET::|!count| (car x) (cdr x)))
                                                                     
(defun SPLAYSET::|!delete|-1 (x) (SPLAYSET::|!delete| (car x) (cdr x)))
                                                                       
(defun SPLAYSET::diffSplay-1 (x) 
  (SPLAYSET::diffSplay (svref x 0) (svref x 1) (svref x 2)))
                                                            
(defun SPLAYSET::difference-1 (x) (SPLAYSET::difference (car x) (cdr x)))
                                                                         
(defun SPLAYSET::|!equal|-1 (x) (SPLAYSET::|!equal| (car x) (cdr x)))
                                                                     
(defun SPLAYSET::existsSplay (x1) 
  #'(lambda (x2) (SPLAYSET::existsSplay-1-1 x1 x2)))
                                                    
(defun SPLAYSET::filterSplay (x1) 
  #'(lambda (x2) (SPLAYSET::filterSplay-1-1 x1 x2)))
                                                    
(defun SPLAYSET::findSplay (x1) 
  #'(lambda (x2) (SPLAYSET::findSplay-1-1 x1 x2)))
                                                  
(defun SPLAYSET::foldlSplay (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldlSplay-1-1-1 x1 x2 x3))))
                                                                        
(defun SPLAYSET::foldrSplay (x1) 
  #'(lambda (x2) #'(lambda (x3) (SPLAYSET::foldrSplay-1-1-1 x1 x2 x3))))
                                                                        
(defun SPLAYSET::|!intersection|-1 (x) 
  (SPLAYSET::|!intersection| (car x) (cdr x)))
                                              
(defun SPLAYSET::intersectionSplay-1 (x) 
  (SPLAYSET::intersectionSplay (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun SPLAYSET::isSubset (set1 set2) 
  (block 
   nil 
   (if (eq (car set1) :|SET|) 
       (let ((pV9107 (cdr set1))) 
         (if (eq (car set2) :|SET|) 
             (let ((pV9111 (cdr set2))) 
               (return 
                (lisp::and 
                 (INTEGER-SPEC::|!<=| (svref pV9107 1) (svref pV9111 1)) 
                 (SPLAYSET::treeIn 
                  (svref pV9107 0) 
                  (STATE::|!!| (svref pV9107 2)) 
                  (STATE::|!!| (svref pV9111 2)))))))) 
       (if (eq (car set1) :|EMPTY|) (return t))) 
   (return nil)))
                 
(defun SPLAYSET::isSubset-1 (x) (SPLAYSET::isSubset (car x) (cdr x)))
                                                                     
(defun SPLAYSET::left-1 (x) (SPLAYSET::left (car x) (cdr x)))
                                                             
(defun SPLAYSET::listItemsApp-1 (x) (SPLAYSET::listItemsApp (car x) (cdr x)))
                                                                             
(defun SPLAYSET::mapf-1 (x) 
  (SPLAYSET::mapf (svref x 0) (svref x 1) (svref x 2)))
                                                       
(defun SPLAYSET::|!member|-1 (x) (SPLAYSET::|!member| (car x) (cdr x)))
                                                                       
(defun SPLAYSET::memberT-1 (x) 
  (SPLAYSET::memberT (svref x 0) (svref x 1) (svref x 2)))
                                                          
(defun SPLAYSET::singleton-1 (x) (SPLAYSET::singleton (car x) (cdr x)))
                                                                       
(defun SPLAYSET::split-1 (x) 
  (SPLAYSET::split (svref x 0) (svref x 1) (svref x 2)))
                                                        
(defun SPLAYSET::treeIn-1 (x) 
  (SPLAYSET::treeIn (svref x 0) (svref x 1) (svref x 2)))
                                                         
(defun SPLAYSET::|!union|-1 (x) (SPLAYSET::|!union| (car x) (cdr x)))
                                                                     
(defun SPLAYSET::unionSplay-1 (x) 
  (SPLAYSET::unionSplay (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun SPLAYTREE::adj (x1) #'(lambda (x2) (SPLAYTREE::adj-1-1 x1 x2)))
                                                                      
(defun SPLAYTREE::join-1 (x) (SPLAYTREE::join (car x) (cdr x)))
                                                               
(defun SPLAYTREE::mkSplayObj-1 (x) 
  (SPLAYTREE::mkSplayObj (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun SPLAYTREE::splay-1 (x) (SPLAYTREE::splay (car x) (cdr x)))
                                                                 
(defparameter SPLAYTREE::splayEmpty '(:|SplayNil|))
                                                   
(defun SPLAYTREE::splayJoin (x0 x) (SPLAYTREE::join x0 x))
                                                          
(defun SPLAYTREE::splayJoin-1 (x) (SPLAYTREE::splayJoin (car x) (cdr x)))
                                                                         
(defun SPLAYTREE::splayNode (a l r) (cons :|SplayObj| (vector l r a)))
                                                                      
(defun SPLAYTREE::splayNode-1 (x) 
  (SPLAYTREE::splayNode (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun SPLAYTREE::splaySingleton (a) 
  (SPLAYTREE::splayNode a SPLAYTREE::splayEmpty SPLAYTREE::splayEmpty))
                                                                       
(defun STANDARDSPEC::findAllOps-1 (x) 
  (STANDARDSPEC::findAllOps (car x) (cdr x)))
                                             
(defun STANDARDSPEC::findAllSorts-1 (x) 
  (STANDARDSPEC::findAllSorts (car x) (cdr x)))
                                               
(defun STANDARDSPEC::findTheOp-1 (x) (STANDARDSPEC::findTheOp (car x) (cdr x)))
                                                                               
(defun STANDARDSPEC::findTheSort-1 (x) 
  (STANDARDSPEC::findTheSort (car x) (cdr x)))
                                              
(defparameter STANDARDSPEC::iffOp 
  (STANDARDSPEC::mkInfixOp 
   (cons :|Qualified| (cons "Boolean" "<=>")) 
   (cons '(:|Right|) 12) 
   STANDARDSPEC::binaryBoolSort))
                                 
(defun STANDARDSPEC::mkAnd-1 (x) (STANDARDSPEC::mkAnd (car x) (cdr x)))
                                                                       
(defun STANDARDSPEC::mkAppl (t1 tms) 
  (cons :|Apply| (vector t1 (STANDARDSPEC::mkTuple tms) POSITION-SPEC::noPos)))
                                                                               
(defun STANDARDSPEC::mkAppl-1 (x) (STANDARDSPEC::mkAppl (car x) (cdr x)))
                                                                         
(defun STANDARDSPEC::mkApply-1 (x) (STANDARDSPEC::mkApply (car x) (cdr x)))
                                                                           
(defun STANDARDSPEC::mkArrow-1 (x) (STANDARDSPEC::mkArrow (car x) (cdr x)))
                                                                           
(defun STANDARDSPEC::mkBase-1 (x) (STANDARDSPEC::mkBase (car x) (cdr x)))
                                                                         
(defun STANDARDSPEC::mkBind-1 (x) 
  (STANDARDSPEC::mkBind (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun STANDARDSPEC::mkBoolPat (b) 
  (cons :|BoolPat| (cons b POSITION-SPEC::noPos)))
                                                  
(defun STANDARDSPEC::mkCharPat (c) 
  (cons :|CharPat| (cons c POSITION-SPEC::noPos)))
                                                  
(defun STANDARDSPEC::mkChoose (srt equiv) 
  (STANDARDSPEC::mkFun 
   '(:|Choose|) 
   (STANDARDSPEC::mkArrow (STANDARDSPEC::mkQuotientSort srt equiv) srt)))
                                                                         
(defun STANDARDSPEC::mkChoice (term equiv srt) 
  (STANDARDSPEC::mkApply (STANDARDSPEC::mkChoose srt equiv) term))
                                                                  
(defun STANDARDSPEC::mkChoice-1 (x) 
  (STANDARDSPEC::mkChoice (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun STANDARDSPEC::mkChoose-1 (x) (STANDARDSPEC::mkChoose (car x) (cdr x)))
                                                                             
(defun STANDARDSPEC::mkChooseFun-1 (x) 
  (STANDARDSPEC::mkChooseFun (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                              
(defun STANDARDSPEC::mkCoProduct (fields) 
  (cons :|CoProduct| (cons fields POSITION-SPEC::noPos)))
                                                         
(defun STANDARDSPEC::mkConj (cjs) 
  (block 
   nil 
   (if (null cjs) 
       (return (STANDARDSPEC::mkTrue)) 
       (if (consp cjs) 
           (let ((pV9326 (cdr cjs))
                 (pV9325 (car cjs))) 
             (progn (if (null pV9326) (return pV9325)) 
                    (return 
                     (STANDARDSPEC::mkAnd pV9325 (STANDARDSPEC::mkConj pV9326))))))) 
   (error "Nonexhaustive match failure in mkConj")))
                                                    
(defun STANDARDSPEC::mkEmbed0 (id srt) 
  (STANDARDSPEC::mkFun (cons :|Embed| (cons id nil)) srt))
                                                          
(defun STANDARDSPEC::mkEmbed0-1 (x) (STANDARDSPEC::mkEmbed0 (car x) (cdr x)))
                                                                             
(defun STANDARDSPEC::mkEmbed1 (id srt) 
  (STANDARDSPEC::mkFun (cons :|Embed| (cons id t)) srt))
                                                        
(defun STANDARDSPEC::mkEmbed1-1 (x) (STANDARDSPEC::mkEmbed1 (car x) (cdr x)))
                                                                             
(defun STANDARDSPEC::mkEmbedded-1 (x) 
  (STANDARDSPEC::mkEmbedded (car x) (cdr x)))
                                             
(defun STANDARDSPEC::mkEquality-1 (x) 
  (STANDARDSPEC::mkEquality (svref x 0) (svref x 1) (svref x 2)))
                                                                 
(defun STANDARDSPEC::mkFalse-1 (ignore) 
  (declare (ignore ignore)) 
  (STANDARDSPEC::mkFalse))
                          
(defun STANDARDSPEC::mkFun-1 (x) (STANDARDSPEC::mkFun (car x) (cdr x)))
                                                                       
(defun STANDARDSPEC::mkIfThenElse-1 (x) 
  (STANDARDSPEC::mkIfThenElse (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun STANDARDSPEC::mkIff (t1 t2) 
  (STANDARDSPEC::mkApply 
   STANDARDSPEC::iffOp 
   (STANDARDSPEC::mkTuple (cons t1 (cons t2 nil)))))
                                                    
(defun STANDARDSPEC::mkIff-1 (x) (STANDARDSPEC::mkIff (car x) (cdr x)))
                                                                       
(defun STANDARDSPEC::mkImplies-1 (x) (STANDARDSPEC::mkImplies (car x) (cdr x)))
                                                                               
(defun STANDARDSPEC::mkInfixOp-1 (x) 
  (STANDARDSPEC::mkInfixOp (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun STANDARDSPEC::mkLambda-1 (x) (STANDARDSPEC::mkLambda (car x) (cdr x)))
                                                                             
(defun STANDARDSPEC::mkLet-1 (x) (STANDARDSPEC::mkLet (car x) (cdr x)))
                                                                       
(defun STANDARDSPEC::mkLetRec-1 (x) (STANDARDSPEC::mkLetRec (car x) (cdr x)))
                                                                             
(defun STANDARDSPEC::mkNatPat (n) 
  (cons :|NatPat| (cons n POSITION-SPEC::noPos)))
                                                 
(defun STANDARDSPEC::mkOp-1 (x) (STANDARDSPEC::mkOp (car x) (cdr x)))
                                                                     
(defun STANDARDSPEC::mkOr-1 (x) (STANDARDSPEC::mkOr (car x) (cdr x)))
                                                                     
(defun STANDARDSPEC::mkOrs (cjs) 
  (block 
   nil 
   (if (null cjs) 
       (return (STANDARDSPEC::mkTrue)) 
       (if (consp cjs) 
           (let ((pV9330 (cdr cjs))
                 (pV9329 (car cjs))) 
             (progn (if (null pV9330) (return pV9329)) 
                    (return 
                     (STANDARDSPEC::mkOr pV9329 (STANDARDSPEC::mkOrs pV9330))))))) 
   (error "Nonexhaustive match failure in mkOrs")))
                                                   
(defun STANDARDSPEC::mkProject (id super sub) 
  (STANDARDSPEC::mkFun (cons :|Project| id) (STANDARDSPEC::mkArrow super sub)))
                                                                               
(defun STANDARDSPEC::mkProject-1 (x) 
  (STANDARDSPEC::mkProject (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun STANDARDSPEC::mkProjection (id term) 
  (let ((super_sort (METASLANG::termSort term))) 
    (block 
     nil 
     (if (eq (car super_sort) :|Product|) 
         (return 
          (let ((pV9338 
                 (LIST-SPEC::|!find|-1-1 
                  #'(lambda (x) (string=  id (car x))) 
                  (car (cdr super_sort))))) 
            (block 
             nil 
             (if (eq (car pV9338) :|Some|) 
                 (return 
                  (STANDARDSPEC::mkApply 
                   (STANDARDSPEC::mkProject id super_sort (cdr (cdr pV9338))) 
                   term))) 
             (return (SYSTEM-SPEC::fail "Projection index not found in product")))))) 
     (return (SYSTEM-SPEC::fail "Product sort expected for mkProjectTerm")))))
                                                                              
(defun STANDARDSPEC::mkProjection-1 (x) 
  (STANDARDSPEC::mkProjection (car x) (cdr x)))
                                               
(defun STANDARDSPEC::mkQuotientSort-1 (x) 
  (STANDARDSPEC::mkQuotientSort (car x) (cdr x)))
                                                 
(defun STANDARDSPEC::mkRelax-1 (x) (STANDARDSPEC::mkRelax (car x) (cdr x)))
                                                                           
(defun STANDARDSPEC::mkRestrict-1 (x) 
  (STANDARDSPEC::mkRestrict (car x) (cdr x)))
                                             
(defun STANDARDSPEC::mkRestriction-1 (x) 
  (STANDARDSPEC::mkRestriction (car x) (cdr x)))
                                                
(defun STANDARDSPEC::mkSelect (id super field) 
  (STANDARDSPEC::mkFun (cons :|Project| id) (STANDARDSPEC::mkArrow super field)))


(defun STANDARDSPEC::mkSelect-1 (x) 
  (STANDARDSPEC::mkSelect (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun STANDARDSPEC::mkSelection (id term) 
  (let ((srt (METASLANG::termSort term))) 
    (block 
     nil 
     (if (eq (car srt) :|CoProduct|) 
         (return 
          (let ((pV9351 
                 (LIST-SPEC::|!find|-1-1 
                  #'(lambda (x) (string=  id (car x))) 
                  (car (cdr srt))))) 
            (block 
             nil 
             (if (eq (car pV9351) :|Some|) 
                 (let ((pV9354 (cdr (cdr pV9351)))) 
                   (if (eq (car pV9354) :|Some|) 
                       (return 
                        (STANDARDSPEC::mkApply 
                         (STANDARDSPEC::mkSelect id srt (cdr pV9354)) 
                         term))))) 
             (return (SYSTEM-SPEC::fail "Selection index not found in product")))))) 
     (return 
      (SYSTEM-SPEC::fail 
       (STRING-SPEC::^ 
        "CoProduct sort expected for mkSelectTerm " 
        (SYSTEM-SPEC::toString srt)))))))
                                         
(defun STANDARDSPEC::mkSelection-1 (x) 
  (STANDARDSPEC::mkSelection (car x) (cdr x)))
                                              
(defun STANDARDSPEC::mkStringPat (s) 
  (cons :|StringPat| (cons s POSITION-SPEC::noPos)))
                                                    
(defun STANDARDSPEC::mkSubsort-1 (x) (STANDARDSPEC::mkSubsort (car x) (cdr x)))
                                                                               
(defun STANDARDSPEC::mkTrue-1 (ignore) 
  (declare (ignore ignore)) 
  (STANDARDSPEC::mkTrue))
                         
(defun STANDARDSPEC::mkTuplePat (pats) 
  (cons :|RecordPat| (cons (STANDARDSPEC::tagTuple pats) POSITION-SPEC::noPos)))
                                                                                
(defun STANDARDSPEC::mkTyVar (name) 
  (cons :|TyVar| (cons name POSITION-SPEC::noPos)))
                                                   
(defun STANDARDSPEC::mkWildPat (s) 
  (cons :|WildPat| (cons s POSITION-SPEC::noPos)))
                                                  
(defun STANDARDSPEC::negateTerm (tm) 
  (block 
   nil 
   (if (eq (car tm) :|Apply|) 
       (let ((pV9373 (cdr tm))) 
         (let ((pV9374 (svref pV9373 0))) 
           (if (eq (car pV9374) :|Fun|) 
               (let ((pV9378 (svref (cdr pV9374) 0))) 
                 (if (eq (car pV9378) :|Op|) 
                     (let ((pV9382 (car (cdr pV9378)))) 
                       (if (eq (car pV9382) :|Qualified|) 
                           (let ((pV9384 (cdr pV9382))) 
                             (if (string=  "Boolean" (car pV9384)) 
                                 (if (string=  "~" (cdr pV9384)) 
                                     (return (svref pV9373 1))))))))))))) 
   (return (STANDARDSPEC::mkApply STANDARDSPEC::notOp tm))))
                                                            
(defun STANDARDSPEC::wildFindUnQualified-1 (x) 
  (STANDARDSPEC::wildFindUnQualified (car x) (cdr x)))
                                                      
(defun STRINGMAP::app (x) (SPLAYMAP::app x))
                                            
(defun STRINGMAP::appi (x) (SPLAYMAP::appi x))
                                              
(defun STRINGMAP::appi-1-1 (x0 x1) (SPLAYMAP::appi-1-1 x0 x1))
                                                              
(defun STRINGMAP::appiDouble-1-1 (f m) 
  (STRINGMAP::appi-1-1 
   #'(lambda (x) 
      (let ((x1 (car x))) 
        (STRINGMAP::appi-1-1 
         #'(lambda (x01) (funcall f (vector x1 (car x01) (cdr x01)))) 
         (cdr x)))) 
   m))
      
(defun STRINGMAP::appiDouble (x1) 
  #'(lambda (x2) (STRINGMAP::appiDouble-1-1 x1 x2)))
                                                    
(defun STRINGMAP::compose (x0 x) (SPLAYMAP::compose x0 x))
                                                          
(defun STRINGMAP::compose-1 (x) (STRINGMAP::compose (car x) (cdr x)))
                                                                     
(defun STRINGMAP::filter (x) (SPLAYMAP::filter x))
                                                  
(defun STRINGMAP::filter-1-1 (x0 x1) (SPLAYMAP::filter-1-1 x0 x1))
                                                                  
(defun STRINGMAP::|!find|-1 (x) (STRINGMAP::|!find| (car x) (cdr x)))
                                                                     
(defun STRINGMAP::find2-1 (x) 
  (STRINGMAP::find2 (svref x 0) (svref x 1) (svref x 2)))
                                                         
(defun STRINGMAP::foldli (x) (SPLAYMAP::foldli x))
                                                  
(defun STRINGMAP::foldri (x) (SPLAYMAP::foldri x))
                                                  
(defun STRINGMAP::fromList (x) 
  (SPLAYMAP::fromList-1-1 #'STRING-SPEC::compare-1 x))
                                                      
(defun STRINGMAP::inDomain (x0 x) (SPLAYMAP::inDomain x0 x))
                                                            
(defun STRINGMAP::inDomain-1 (x) (STRINGMAP::inDomain (car x) (cdr x)))
                                                                       
(defun STRINGMAP::insert-1 (x) 
  (STRINGMAP::insert (svref x 0) (svref x 1) (svref x 2)))
                                                          
(defun STRINGMAP::insert2-1 (x) 
  (STRINGMAP::insert2 (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                       
(defun STRINGMAP::intersectWith (x) (SPLAYMAP::intersectWith x))
                                                                
(defun STRINGMAP::intersectWith-1-1 (x0 x1) (SPLAYMAP::intersectWith-1-1 x0 x1))
                                                                                
(defun STRINGMAP::listItems (x) (SPLAYMAP::listItems x))
                                                        
(defun STRINGMAP::listItemsi (x) (SPLAYMAP::listItemsi x))
                                                          
(defun STRINGMAP::|!map| (x) (SPLAYMAP::|!map| x))
                                                  
(defun STRINGMAP::mapPartial (x) (SPLAYMAP::mapPartial x))
                                                          
(defun STRINGMAP::mapPartial-1-1 (x0 x1) (SPLAYMAP::mapPartial-1-1 x0 x1))
                                                                          
(defun STRINGMAP::mapPartiali (x) (SPLAYMAP::mapPartiali x))
                                                            
(defun STRINGMAP::mapPartiali-1-1 (x0 x1) (SPLAYMAP::mapPartiali-1-1 x0 x1))
                                                                            
(defun STRINGMAP::mapi (x) (SPLAYMAP::mapi x))
                                              
(defun STRINGMAP::numItems (x) (SPLAYMAP::numItems x))
                                                      
(defun STRINGMAP::|!remove| (x0 x) (SPLAYMAP::|!remove| x0 x))
                                                              
(defun STRINGMAP::|!remove|-1 (x) (STRINGMAP::|!remove| (car x) (cdr x)))
                                                                         
(defun STRINGMAP::subset? (x0 x) (SPLAYMAP::subset? x0 x))
                                                          
(defun STRINGMAP::subset?-1 (x) (STRINGMAP::subset? (car x) (cdr x)))
                                                                     
(defun STRINGMAP::toList (x) (SPLAYMAP::toList x))
                                                  
(defun STRINGMAP::unionWith-1-1 (x0 x1) (SPLAYMAP::unionWith-1-1 x0 x1))
                                                                        
(defun STRINGMAP::union2With-1-1 (f x) 
  (STRINGMAP::foldri-1-1-1 
   #'(lambda (x1) 
      (let ((x11 (svref x1 0))
            (sm2 (svref x1 1))
            (resm (svref x1 2))) 
        (let ((pV9398 (STRINGMAP::|!find| resm x11))) 
          (block 
           nil 
           (if (eq (car pV9398) :|None|) 
               (return (STRINGMAP::insert resm x11 sm2)) 
               (if (eq (car pV9398) :|Some|) 
                   (return 
                    (STRINGMAP::insert 
                     resm 
                     x11 
                     (STRINGMAP::unionWith-1-1 f (cons (cdr pV9398) sm2)))))) 
           (error "Nonexhaustive match failure in union2With"))))) 
   (car x) 
   (cdr x)))
            
(defun STRINGMAP::union2With (x1) 
  #'(lambda (x2) (STRINGMAP::union2With-1-1 x1 x2)))
                                                    
(defun STRINGMAP::unionWith (x) (SPLAYMAP::unionWith x))
                                                        
(defun STRINGSET::add-1 (x) (STRINGSET::add (car x) (cdr x)))
                                                             
(defun STRINGSET::addList-1 (x) (STRINGSET::addList (car x) (cdr x)))
                                                                     
(defun STRINGSET::app (x) (SPLAYSET::app x))
                                            
(defun STRINGSET::app-1-1 (x0 x1) (SPLAYSET::app-1-1 x0 x1))
                                                            
(defun STRINGSET::difference-1 (x) (STRINGSET::difference (car x) (cdr x)))
                                                                           
(defun STRINGSET::|!intersection| (x0 x) (SPLAYSET::|!intersection| x0 x))
                                                                          
(defun STRINGSET::|!intersection|-1 (x) 
  (STRINGSET::|!intersection| (car x) (cdr x)))
                                               
(defun STRINGSET::isEmpty (x) (SPLAYSET::isEmpty x))
                                                    
(defun STRINGSET::|!map| (x) (SPLAYSET::|!map| x))
                                                  
(defun STRINGSET::|!map|-1-1 (x0 x1) (SPLAYSET::|!map|-1-1 x0 x1))
                                                                  
(defun STRINGSET::|!member|-1 (x) (STRINGSET::|!member| (car x) (cdr x)))
                                                                         
(defun STRINGSET::toList (x) (SPLAYSET::listItems x))
                                                     
(defun STRINGSET::|!union| (x0 x) (SPLAYSET::|!union| x0 x))
                                                            
(defun STRINGSET::|!union|-1 (x) (STRINGSET::|!union| (car x) (cdr x)))
                                                                       
(defun STRINGUTILITIES::freshName-1 (x) 
  (STRINGUTILITIES::freshName (car x) (cdr x)))
                                               
(defun STRINGUTILITIES::tokens (x1) 
  #'(lambda (x2) (STRINGUTILITIES::tokens-1-1 x1 x2)))
                                                      
(defun TOPSORT::dfs-1 (x) (TOPSORT::dfs (svref x 0) (svref x 1) (svref x 2)))
                                                                             
(defun TOPSORT::inorderL-1 (x) (TOPSORT::inorderL (car x) (cdr x)))
                                                                   
(defun TOPSORT::topSort-1 (x) 
  (TOPSORT::topSort (svref x 0) (svref x 1) (svref x 2)))
                                                         
(defun TYPECHECKER::adjustEqualitySort-1 (x) 
  (TYPECHECKER::adjustEqualitySort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun TYPECHECKER::aux_elaborateTerm-1 (x) 
  (TYPECHECKER::aux_elaborateTerm (svref x 0) (svref x 1) (svref x 2)))
                                                                       
(defun TYPECHECKER::checkDifferent-1 (x) 
  (TYPECHECKER::checkDifferent (car x) (cdr x)))
                                                
(defun TYPECHECKER::checkSort-1 (x) (TYPECHECKER::checkSort (car x) (cdr x)))
                                                                             
(defun TYPECHECKER::consistentInfixPTerms-1 (x) 
  (TYPECHECKER::consistentInfixPTerms (car x) (cdr x)))
                                                       
(defun TYPECHECKER::elaborateCheckSortForTerm-1 (x) 
  (TYPECHECKER::elaborateCheckSortForTerm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun TYPECHECKER::elaboratePattern-1 (x) 
  (TYPECHECKER::elaboratePattern (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defun TYPECHECKER::elaboratePosSpec-1 (x) 
  (TYPECHECKER::elaboratePosSpec (car x) (cdr x)))
                                                  
(defun TYPECHECKER::elaborateSort-1 (x) 
  (TYPECHECKER::elaborateSort (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun TYPECHECKER::elaborateSortForTerm-1 (x) 
  (TYPECHECKER::elaborateSortForTerm 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun TYPECHECKER::elaborateTerm-1 (x) 
  (TYPECHECKER::elaborateTerm (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun TYPECHECKER::isArrowCoProduct-1 (x) 
  (TYPECHECKER::isArrowCoProduct (car x) (cdr x)))
                                                  
(defun TYPECHECKER::isCoproduct-1 (x) 
  (TYPECHECKER::isCoproduct (car x) (cdr x)))
                                             
(defun TYPECHECKER::lookupEmbedId-1 (x) 
  (TYPECHECKER::lookupEmbedId (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun TYPECHECKER::mkEmbed0-1 (x) 
  (TYPECHECKER::mkEmbed0 (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun TYPECHECKER::mkEmbed1-1 (x) 
  (TYPECHECKER::mkEmbed1 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPECHECKER::mkProject-1 (x) 
  (TYPECHECKER::mkProject (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                           
(defun TYPECHECKER::pass2Error-1 (x) 
  (TYPECHECKER::pass2Error (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                            
(defun TYPECHECKER::selectTermWithConsistentSort-1 (x) 
  (TYPECHECKER::selectTermWithConsistentSort 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPECHECKER::undeclared-1 (x) 
  (TYPECHECKER::undeclared 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPECHECKER::undeclared2-1 (x) 
  (TYPECHECKER::undeclared2 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun TYPECHECKER::undeclaredResolving-1 (x) 
  (TYPECHECKER::undeclaredResolving 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPECHECKER::uniqueConstr-1 (x) 
  (TYPECHECKER::uniqueConstr (svref x 0) (svref x 1) (svref x 2) (svref x 3)))
                                                                              
(defun TYPEOBLIGATIONS::|!<=|-1 (x) 
  (TYPEOBLIGATIONS::|!<=| 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPEOBLIGATIONS::addCondition-1 (x) 
  (TYPEOBLIGATIONS::addCondition (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defun TYPEOBLIGATIONS::addFailure-1 (x) 
  (TYPEOBLIGATIONS::addFailure (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun TYPEOBLIGATIONS::assertCond-1 (x) 
  (TYPEOBLIGATIONS::assertCond (car x) (cdr x)))
                                                
(defun TYPEOBLIGATIONS::assertSubtypeCond-1 (x) 
  (TYPEOBLIGATIONS::assertSubtypeCond (svref x 0) (svref x 1) (svref x 2)))
                                                                           
(defun TYPEOBLIGATIONS::bindPattern-1 (x) 
  (TYPEOBLIGATIONS::bindPattern (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun TYPEOBLIGATIONS::checkSpec (x0 x1 x2 x3) 
  (TYPEOBLIGATIONS::checkSpec-1 (vector x0 x1 x2 x3)))
                                                      
(defun TYPEOBLIGATIONS::freshName-1 (x) 
  (TYPEOBLIGATIONS::freshName (car x) (cdr x)))
                                               
(defun TYPEOBLIGATIONS::insertLet (pV10491 pV10492) 
  (block 
   nil 
   (return 
    (vector 
     (LIST-SPEC::|!cons| (cons :|Let| pV10491) (svref pV10492 0)) 
     (svref pV10492 1) 
     (svref pV10492 2) 
     (svref pV10492 3) 
     (svref pV10492 4))) 
   (error "Nonexhaustive match failure in insertLet")))
                                                       
(defun TYPEOBLIGATIONS::insertLet-1 (x) 
  (TYPEOBLIGATIONS::insertLet (car x) (cdr x)))
                                               
(defun TYPEOBLIGATIONS::insertLetRec (pV10504 pV10505) 
  (block 
   nil 
   (return 
    (vector 
     (LIST-SPEC::|!cons| (cons :|LetRec| pV10504) (svref pV10505 0)) 
     (svref pV10505 1) 
     (svref pV10505 2) 
     (svref pV10505 3) 
     (STRINGSET::addList 
      (svref pV10505 4) 
      (LIST-SPEC::|!map|-1-1 
       #'(lambda (x) 
          (block 
           nil 
           (return (car (car x))) 
           (error "Nonexhaustive match failure in insertLetRec"))) 
       pV10504)))) 
   (error "Nonexhaustive match failure in insertLetRec")))
                                                          
(defun TYPEOBLIGATIONS::insertLetRec-1 (x) 
  (TYPEOBLIGATIONS::insertLetRec (car x) (cdr x)))
                                                  
(defun TYPEOBLIGATIONS::makeTypeCheckObligationSpec-1 (x) 
  (TYPEOBLIGATIONS::makeTypeCheckObligationSpec (car x) (cdr x)))
                                                                 
(defun TYPEOBLIGATIONS::makeVerificationCondition-1 (x) 
  (TYPEOBLIGATIONS::makeVerificationCondition (car x) (cdr x)))
                                                               
(defun TYPEOBLIGATIONS::mkLetOrApply-1 (x) 
  (TYPEOBLIGATIONS::mkLetOrApply (car x) (cdr x)))
                                                  
(defun TYPEOBLIGATIONS::printDecl (d) 
  (block 
   nil 
   (if (eq (car d) :|Var|) 
       (let ((pV10564 (cdr d))) 
         (return 
          (STRING-SPEC::^ 
           (STRING-SPEC::^ (car pV10564) ":") 
           (ANNSPECPRINTER::printSort (cdr pV10564))))) 
       (if (eq (car d) :|Cond|) 
           (return 
            (STRING-SPEC::^ "assert " (ANNSPECPRINTER::printTerm (cdr d)))) 
           (if (eq (car d) :|LetRec|) 
               (return 
                (ANNSPECPRINTER::printTerm 
                 (cons 
                  :|LetRec| 
                  (vector 
                   (cdr d) 
                   (cons :|Record| (cons nil POSITION-SPEC::noPos)) 
                   POSITION-SPEC::noPos)))) 
               (if (eq (car d) :|Let|) 
                   (return 
                    (ANNSPECPRINTER::printTerm 
                     (cons 
                      :|Let| 
                      (vector 
                       (cdr d) 
                       (cons :|Record| (cons nil POSITION-SPEC::noPos)) 
                       POSITION-SPEC::noPos)))))))) 
   (error "Nonexhaustive match failure in printDecl")))
                                                       
(defun TYPEOBLIGATIONS::printGamma (decls pV10567 pV10568 pV10569 pV10570) 
  (declare (ignore pV10567 pV10568 pV10569 pV10570)) 
  (progn (LIST-SPEC::app-1-1 
          #'(lambda (decl) 
             (progn (STRING-SPEC::toScreen (TYPEOBLIGATIONS::printDecl decl)) 
                    (STRING-SPEC::toScreen "; "))) 
          (LIST-SPEC::rev decls)) 
         (progn (STRING-SPEC::writeLine "") nil)))
                                                  
(defun TYPEOBLIGATIONS::printGamma-1 (x) 
  (TYPEOBLIGATIONS::printGamma 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPEOBLIGATIONS::returnPattern-1 (x) 
  (TYPEOBLIGATIONS::returnPattern 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun TYPEOBLIGATIONS::returnPatternRec-1 (x) 
  (TYPEOBLIGATIONS::returnPatternRec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defun TYPEOBLIGATIONS::subtypeRec-1 (x) 
  (TYPEOBLIGATIONS::subtypeRec 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun TYPEOBLIGATIONS::unfoldBase-1 (x) 
  (TYPEOBLIGATIONS::unfoldBase (car x) (cdr x)))
                                                
(defun TYPEOBLIGATIONS::\|--1 (x) (TYPEOBLIGATIONS::\|- (car x) (cdr x)))
                                                                         
(defun UTILITIES::addConstrsEnv-1 (x) 
  (UTILITIES::addConstrsEnv (car x) (cdr x)))
                                             
(defun UTILITIES::addVariable-1 (x) 
  (UTILITIES::addVariable (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defparameter UTILITIES::baseSpec 
  (vector 
   emptyImportInfo 
   emptyAQualifierMap 
   STANDARDSPEC::emptyProperties 
   emptyAQualifierMap))
                       
(defun UTILITIES::initPrimitiveSpec-1-1-1 (qualifier id tyvars) 
  (vector 
   emptyImportInfo 
   emptyAQualifierMap 
   STANDARDSPEC::emptyProperties 
   (insertAQualifierMap 
    emptyAQualifierMap 
    qualifier 
    id 
    (vector (cons (cons :|Qualified| (cons qualifier id)) nil) tyvars '(:|None|)))))


(defparameter UTILITIES::boolSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Boolean" "Boolean" nil))
                                                               
(defparameter UTILITIES::cgeninfohead ";;;CGEN-INFO ")
                                                      
(defparameter UTILITIES::charSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Char" "Char" nil))
                                                         
(defun UTILITIES::checkErrors (x0 x1 x2 x3 x4 x5 x6) 
  (UTILITIES::checkErrors-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                           
(defun UTILITIES::computeConstrMap (x0 x1 x2 x3) 
  (UTILITIES::computeConstrMap-1 (vector x0 x1 x2 x3)))
                                                       
(defun UTILITIES::consistentSorts?-1 (x) 
  (UTILITIES::consistentSorts? (svref x 0) (svref x 1) (svref x 2)))
                                                                    
(defun UTILITIES::convertConjecturesToAxioms-1 (spc) 
  (setProperties 
   spc 
   (LIST-SPEC::|!map|-1-1 
    #'(lambda (x) 
       (let ((ty (svref x 0))) 
         (vector 
          (block 
           nil 
           (if (eq (car ty) :|Conjecture|) (return '(:|Axiom|))) 
           (return ty)) 
          (svref x 1) 
          (svref x 2) 
          (svref x 3)))) 
    (svref spc 2))))
                    
(defun UTILITIES::convertConjecturesToAxioms (x0 x1 x2 x3) 
  (UTILITIES::convertConjecturesToAxioms-1 (vector x0 x1 x2 x3)))
                                                                 
(defun UTILITIES::deleteVar (v sub sub2) 
  (block 
   nil 
   (if (null sub) 
       (return sub2) 
       (if (consp sub) 
           (let ((pV10930 (cdr sub))
                 (pV10929 (car sub))) 
             (let ((pV10931 (car pV10929))) 
               (return 
                (if (slang-built-in::slang-term-equals v pV10931) 
                    (LIST-SPEC::|!++| pV10930 sub2) 
                    (UTILITIES::deleteVar 
                     v 
                     pV10930 
                     (LIST-SPEC::|!cons| (cons pV10931 (cdr pV10929)) sub2)))))))) 
   (error "Nonexhaustive match failure in deleteVar")))
                                                       
(defun UTILITIES::deleteVar-1 (x) 
  (UTILITIES::deleteVar (svref x 0) (svref x 1) (svref x 2)))
                                                             
(defun UTILITIES::deleteVars-1 (x) (UTILITIES::deleteVars (car x) (cdr x)))
                                                                           
(defun UTILITIES::filterWithIndex-1-1 (p l) 
  (labels 
    ((fRec (n l) 
      (block 
       nil 
       (if (null l) 
           (return nil) 
           (if (consp l) 
               (let ((pV10982 (car l))
                     (pV10983 (cdr l))) 
                 (return 
                  (if (funcall p (cons n pV10982)) 
                      (LIST-SPEC::|!cons| 
                       pV10982 
                       (fRec (INTEGER-SPEC::|!+| n 1) pV10983)) 
                      (fRec (INTEGER-SPEC::|!+| n 1) pV10983)))))) 
       (error "Nonexhaustive match failure in filterWithIndex")))) (fRec 0 l)))
                                                                               
(defun UTILITIES::disableProperties (indices spc) 
  (if (INTEGERSET::isEmpty indices) 
      spc 
      (let ((idx (cons :|Ref| 0))) 
        (let ((revised_ops 
               (STRINGMAP::|!map|-1-1 
                #'(lambda (m) 
                   (STRINGMAP::|!map|-1-1 
                    #'(lambda (x) 
                       (let ((srt (svref x 2))
                             (fixity (svref x 1))
                             (op_names (svref x 0))) 
                         (progn (STATE::|:=| 
                                 idx 
                                 (INTEGER-SPEC::|!-| (STATE::|!!| idx) 1)) 
                                (if (INTEGERSET::|!member| 
                                     indices 
                                     (STATE::|!!| idx)) 
                                    (vector op_names fixity srt '(:|None|)) 
                                    (vector op_names fixity srt (svref x 3)))))) 
                    m)) 
                (svref spc 1)))) 
          (vector 
           (svref spc 0) 
           revised_ops 
           (UTILITIES::filterWithIndex-1-1 
            #'(lambda (x) 
               (BOOLEAN-SPEC::~ (INTEGERSET::|!member| indices (car x)))) 
            (svref spc 2)) 
           (svref spc 3))))))
                             
(defun UTILITIES::disableProperties-1 (x) 
  (UTILITIES::disableProperties (car x) (cdr x)))
                                                 
(defun UTILITIES::|!error|-1 (x) 
  (UTILITIES::|!error| (svref x 0) (svref x 1) (svref x 2)))
                                                            
(defun UTILITIES::externalopshfile (specname) 
  (STRING-SPEC::^ specname "_extops.h"))
                                        
(defun UTILITIES::extractAssignment (variables arguments) 
  (block 
   nil 
   (if (eq (car variables) :|Var|) 
       (let ((pV10969 (cdr variables))) 
         (progn (let ((pV10975 (car pV10969))) 
                  (if (eq (car arguments) :|Var|) 
                      (return 
                       (if (slang-built-in::slang-term-equals 
                            pV10975 
                            (car (cdr arguments))) 
                           nil 
                           (cons 
                            (cons 
                             (cons :|VarPat| (cons pV10975 (cdr pV10969))) 
                             arguments) 
                            nil))))) 
                (return 
                 (cons 
                  (cons 
                   (cons :|VarPat| (cons (car pV10969) (cdr pV10969))) 
                   arguments) 
                  nil)))) 
       (if (eq (car variables) :|Record|) 
           (if (eq (car arguments) :|Record|) 
               (return 
                (LISTPAIR::foldr-1-1-1 
                 #'(lambda (x) 
                    (let ((pV10958 (svref x 2))) 
                      (block 
                       nil 
                       (let ((pV10960 (cdr (svref x 0)))) 
                         (if (eq (car pV10960) :|Var|) 
                             (let ((pV10962 (car (cdr pV10960)))) 
                               (let ((pV10965 (cdr (svref x 1)))) 
                                 (return 
                                  (block 
                                   nil 
                                   (if (eq (car pV10965) :|Var|) 
                                       (return 
                                        (if (slang-built-in::slang-term-equals 
                                             pV10962 
                                             (car (cdr pV10965))) 
                                            pV10958 
                                            (LIST-SPEC::|!cons| 
                                             (cons 
                                              (STANDARDSPEC::mkVarPat-1 pV10962) 
                                              pV10965) 
                                             pV10958)))) 
                                   (return 
                                    (LIST-SPEC::|!cons| 
                                     (cons 
                                      (STANDARDSPEC::mkVarPat-1 pV10962) 
                                      pV10965) 
                                     pV10958)))))))) 
                       (error "Nonexhaustive match failure in extractAssignment")))) 
                 nil 
                 (cons (car (cdr variables)) (car (cdr arguments)))))))) 
   (error "Nonexhaustive match failure in extractAssignment")))
                                                               
(defun UTILITIES::extractAssignment-1 (x) 
  (UTILITIES::extractAssignment (car x) (cdr x)))
                                                 
(defun UTILITIES::filterWithIndex (x1) 
  #'(lambda (x2) (UTILITIES::filterWithIndex-1-1 x1 x2)))
                                                         
(defun UTILITIES::findTheOp2-1 (x) 
  (UTILITIES::findTheOp2 (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun UTILITIES::findTheSort2 (env qualifier id) 
  (findAQualifierMap (svref (svref env 5) 3) qualifier id))
                                                           
(defun UTILITIES::findTheSort2-1 (x) 
  (UTILITIES::findTheSort2 (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun UTILITIES::findVarOrOps-1 (x) 
  (UTILITIES::findVarOrOps (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defparameter UTILITIES::generalSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "General" "General" (cons "a" nil)))
                                                                          
(defun UTILITIES::initPrimitiveSpec (x1) 
  #'(lambda (x2) 
     #'(lambda (x3) (UTILITIES::initPrimitiveSpec-1-1-1 x1 x2 x3))))
                                                                    
(defun UTILITIES::initialEnv-1 (x) (UTILITIES::initialEnv (car x) (cdr x)))
                                                                           
(defun UTILITIES::initializeMetaTyVar-1 (ignore) 
  (declare (ignore ignore)) 
  (UTILITIES::initializeMetaTyVar))
                                   
(defun UTILITIES::instantiateScheme-1 (x) 
  (UTILITIES::instantiateScheme 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4)))
                
(defparameter UTILITIES::intSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Integer" "Integer" nil))
                                                               
(defun UTILITIES::isFree-1 (x) (UTILITIES::isFree (car x) (cdr x)))
                                                                   
(defun UTILITIES::isPatBound-1 (x) (UTILITIES::isPatBound (car x) (cdr x)))
                                                                           
(defun UTILITIES::letRecToLetTermFun (fun) fun)
                                               
(defun UTILITIES::letRecToLetTermVar (id srt) 
  (cons id (UTILITIES::letRecToLetTermSort srt)))
                                                 
(defun UTILITIES::letRecToLetTermVar-1 (x) 
  (UTILITIES::letRecToLetTermVar (car x) (cdr x)))
                                                  
(defun UTILITIES::letRecToLetTermPattern (pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV11219 (cdr pat))) 
         (return 
          (cons 
           :|AliasPat| 
           (vector 
            (UTILITIES::letRecToLetTermPattern (svref pV11219 0)) 
            (UTILITIES::letRecToLetTermPattern (svref pV11219 1)) 
            (svref pV11219 2))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV11218 (cdr pat))) 
             (return 
              (cons 
               :|VarPat| 
               (cons 
                (UTILITIES::letRecToLetTermVar-1 (car pV11218)) 
                (cdr pV11218))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV11217 (cdr pat))) 
                 (let ((pV11231 (svref pV11217 1))) 
                   (return 
                    (cons 
                     :|EmbedPat| 
                     (vector 
                      (svref pV11217 0) 
                      (block 
                       nil 
                       (if (eq (car pV11231) :|None|) 
                           (return '(:|None|)) 
                           (if (eq (car pV11231) :|Some|) 
                               (return 
                                (cons 
                                 :|Some| 
                                 (UTILITIES::letRecToLetTermPattern 
                                  (cdr pV11231)))))) 
                       (error 
                        "Nonexhaustive match failure in letRecToLetTermPattern")) 
                      (UTILITIES::letRecToLetTermSort (svref pV11217 2)) 
                      (svref pV11217 3)))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (let ((pV11216 (cdr pat))) 
                     (return 
                      (cons 
                       :|RecordPat| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (UTILITIES::letRecToLetTermPattern (cdr x)))) 
                         (car pV11216)) 
                        (cdr pV11216))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (let ((pV11215 (cdr pat))) 
                         (return 
                          (cons 
                           :|WildPat| 
                           (cons 
                            (UTILITIES::letRecToLetTermSort (car pV11215)) 
                            (cdr pV11215))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV11214 (cdr pat))) 
                             (return 
                              (cons 
                               :|RelaxPat| 
                               (vector 
                                (UTILITIES::letRecToLetTermPattern 
                                 (svref pV11214 0)) 
                                (UTILITIES::letRecToLetTermTerm 
                                 (svref pV11214 1)) 
                                (svref pV11214 2))))) 
                           (if (eq (car pat) :|QuotientPat|) 
                               (let ((pV11213 (cdr pat))) 
                                 (return 
                                  (cons 
                                   :|QuotientPat| 
                                   (vector 
                                    (UTILITIES::letRecToLetTermPattern 
                                     (svref pV11213 0)) 
                                    (UTILITIES::letRecToLetTermTerm 
                                     (svref pV11213 1)) 
                                    (svref pV11213 2)))))))))))) 
   (return pat)))
                 
(defun UTILITIES::letRecToLetTermTerm (term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV11284 (cdr term))) 
         (return 
          (cons 
           :|Apply| 
           (vector 
            (UTILITIES::letRecToLetTermTerm (svref pV11284 0)) 
            (UTILITIES::letRecToLetTermTerm (svref pV11284 1)) 
            (svref pV11284 2))))) 
       (if (eq (car term) :|Record|) 
           (let ((pV11283 (cdr term))) 
             (return 
              (cons 
               :|Record| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::letRecToLetTermTerm (cdr x)))) 
                 (car pV11283)) 
                (cdr pV11283))))) 
           (if (eq (car term) :|Bind|) 
               (let ((pV11282 (cdr term))) 
                 (return 
                  (cons 
                   :|Bind| 
                   (vector 
                    (svref pV11282 0) 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (v) (UTILITIES::letRecToLetTermVar-1 v)) 
                     (svref pV11282 1)) 
                    (UTILITIES::letRecToLetTermTerm (svref pV11282 2)) 
                    (svref pV11282 3))))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV11281 (cdr term))) 
                     (return 
                      (cons 
                       :|Let| 
                       (vector 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (UTILITIES::letRecToLetTermPattern (car x)) 
                             (UTILITIES::letRecToLetTermTerm (cdr x)))) 
                         (svref pV11281 0)) 
                        (UTILITIES::letRecToLetTermTerm (svref pV11281 1)) 
                        (svref pV11281 2))))) 
                   (if (eq (car term) :|LetRec|) 
                       (let ((pV11280 (cdr term))) 
                         (let ((pV11300 (svref pV11280 2))) 
                           (return 
                            (let ((vts 
                                   (LIST-SPEC::|!map|-1-1 
                                    #'(lambda (x) 
                                       (cons 
                                        (UTILITIES::letRecToLetTermVar-1 (car x)) 
                                        (UTILITIES::letRecToLetTermTerm (cdr x)))) 
                                    (svref pV11280 0)))) 
                              (let ((|!t| 
                                     (UTILITIES::letRecToLetTermTerm 
                                      (svref pV11280 1)))) 
                                (let ((pts 
                                       (LIST-SPEC::|!map|-1-1 
                                        #'(lambda (x) 
                                           (cons 
                                            (cons 
                                             :|VarPat| 
                                             (cons (car x) POSITION-SPEC::noPos)) 
                                            (cdr x))) 
                                        vts))) 
                                  (let ((dummyterm (STANDARDSPEC::mkTrue))) 
                                    (let ((dummypts 
                                           (LIST-SPEC::|!map|-1-1 
                                            #'(lambda (x) 
                                               (let ((|!t| (cdr x))
                                                     (pat (car x))) 
                                                 (block 
                                                  nil 
                                                  (if (eq (car |!t|) :|Lambda|) 
                                                      (let ((pV11270 (cdr |!t|))) 
                                                        (return 
                                                         (let ((newmatch 
                                                                (LIST-SPEC::|!map|-1-1 
                                                                 #'(lambda (x1) 
                                                                    (vector 
                                                                     (svref x1 0) 
                                                                     (svref x1 1) 
                                                                     dummyterm)) 
                                                                 (car pV11270)))) 
                                                           (cons 
                                                            pat 
                                                            (cons 
                                                             :|Lambda| 
                                                             (cons 
                                                              newmatch 
                                                              (cdr pV11270)))))))) 
                                                  (return (cons pat dummyterm))))) 
                                            pts))) 
                                      (cons 
                                       :|Let| 
                                       (vector 
                                        dummypts 
                                        (cons 
                                         :|Let| 
                                         (vector 
                                          pts 
                                          (cons :|Let| (vector pts |!t| pV11300)) 
                                          pV11300)) 
                                        pV11300)))))))))) 
                       (if (eq (car term) :|Var|) 
                           (let ((pV11279 (cdr term))) 
                             (return 
                              (cons 
                               :|Var| 
                               (cons 
                                (UTILITIES::letRecToLetTermVar-1 (car pV11279)) 
                                (cdr pV11279))))) 
                           (if (eq (car term) :|Fun|) 
                               (let ((pV11278 (cdr term))) 
                                 (return 
                                  (cons 
                                   :|Fun| 
                                   (vector 
                                    (UTILITIES::letRecToLetTermFun 
                                     (svref pV11278 0)) 
                                    (UTILITIES::letRecToLetTermSort 
                                     (svref pV11278 1)) 
                                    (svref pV11278 2))))) 
                               (if (eq (car term) :|Lambda|) 
                                   (let ((pV11277 (cdr term))) 
                                     (return 
                                      (cons 
                                       :|Lambda| 
                                       (cons 
                                        (LIST-SPEC::|!map|-1-1 
                                         #'(lambda (x) 
                                            (vector 
                                             (UTILITIES::letRecToLetTermPattern 
                                              (svref x 0)) 
                                             (UTILITIES::letRecToLetTermTerm 
                                              (svref x 1)) 
                                             (UTILITIES::letRecToLetTermTerm 
                                              (svref x 2)))) 
                                         (car pV11277)) 
                                        (cdr pV11277))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV11276 (cdr term))) 
                                         (return 
                                          (cons 
                                           :|IfThenElse| 
                                           (vector 
                                            (UTILITIES::letRecToLetTermTerm 
                                             (svref pV11276 0)) 
                                            (UTILITIES::letRecToLetTermTerm 
                                             (svref pV11276 1)) 
                                            (UTILITIES::letRecToLetTermTerm 
                                             (svref pV11276 2)) 
                                            (svref pV11276 3))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (let ((pV11275 (cdr term))) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (|!t|) 
                                                    (UTILITIES::letRecToLetTermTerm 
                                                     |!t|)) 
                                                 (car pV11275)) 
                                                (cdr pV11275))))))))))))))) 
   (return term)))
                  
(defun UTILITIES::letRecToLetTermSort (srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV11248 (cdr srt))) 
         (return 
          (cons 
           :|Arrow| 
           (vector 
            (UTILITIES::letRecToLetTermSort (svref pV11248 0)) 
            (UTILITIES::letRecToLetTermSort (svref pV11248 1)) 
            (svref pV11248 2))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV11247 (cdr srt))) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::letRecToLetTermSort (cdr x)))) 
                 (car pV11247)) 
                (cdr pV11247))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV11246 (cdr srt))) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((optsrt (cdr x))) 
                          (cons 
                           (car x) 
                           (block 
                            nil 
                            (if (eq (car optsrt) :|Some|) 
                                (return 
                                 (cons 
                                  :|Some| 
                                  (UTILITIES::letRecToLetTermSort (cdr optsrt)))) 
                                (if (eq (car optsrt) :|None|) 
                                    (return '(:|None|)))) 
                            (error 
                             "Nonexhaustive match failure in letRecToLetTermSort"))))) 
                     (car pV11246)) 
                    (cdr pV11246))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV11245 (cdr srt))) 
                     (return 
                      (cons 
                       :|Quotient| 
                       (vector 
                        (UTILITIES::letRecToLetTermSort (svref pV11245 0)) 
                        (UTILITIES::letRecToLetTermTerm (svref pV11245 1)) 
                        (svref pV11245 2))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV11244 (cdr srt))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector 
                            (UTILITIES::letRecToLetTermSort (svref pV11244 0)) 
                            (UTILITIES::letRecToLetTermTerm (svref pV11244 1)) 
                            (svref pV11244 2))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV11243 (cdr srt))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector 
                                (svref pV11243 0) 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (s) 
                                    (UTILITIES::letRecToLetTermSort s)) 
                                 (svref pV11243 1)) 
                                (svref pV11243 2))))))))))) 
   (return srt)))
                 
(defun UTILITIES::letRecToLetTermOpInfo (pV11203 pV11204 pV11205 pV11206) 
  (block 
   nil 
   (return 
    (vector 
     pV11203 
     pV11204 
     (cons (car pV11205) (UTILITIES::letRecToLetTermSort (cdr pV11205))) 
     (block 
      nil 
      (if (eq (car pV11206) :|Some|) 
          (return (cons :|Some| (UTILITIES::letRecToLetTermTerm (cdr pV11206)))) 
          (if (eq (car pV11206) :|None|) (return '(:|None|)))) 
      (error "Nonexhaustive match failure in letRecToLetTermOpInfo")))) 
   (error "Nonexhaustive match failure in letRecToLetTermOpInfo")))
                                                                   
(defun UTILITIES::letRecToLetTermOpInfo-1 (x) 
  (UTILITIES::letRecToLetTermOpInfo 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3)))
                
(defun UTILITIES::letRecToLetTermSortInfo (sort_names tyvars opt_def) 
  (vector 
   sort_names 
   tyvars 
   (block 
    nil 
    (if (eq (car opt_def) :|Some|) 
        (return (cons :|Some| (UTILITIES::letRecToLetTermSort (cdr opt_def)))) 
        (if (eq (car opt_def) :|None|) (return '(:|None|)))) 
    (error "Nonexhaustive match failure in letRecToLetTermSortInfo"))))
                                                                       
(defun UTILITIES::letRecToLetTermSortInfo-1 (x) 
  (UTILITIES::letRecToLetTermSortInfo (svref x 0) (svref x 1) (svref x 2)))
                                                                           
(defun UTILITIES::letRecToLetTermSpec-1 (spc) 
  (vector 
   (svref spc 0) 
   (STRINGMAP::mapDouble-1-1 #'UTILITIES::letRecToLetTermOpInfo-1 (svref spc 1)) 
   (svref spc 2) 
   (STRINGMAP::mapDouble-1-1 
    #'UTILITIES::letRecToLetTermSortInfo-1 
    (svref spc 3))))
                    
(defun UTILITIES::letRecToLetTermSpec (x0 x1 x2 x3) 
  (UTILITIES::letRecToLetTermSpec-1 (vector x0 x1 x2 x3)))
                                                          
(defun UTILITIES::linkMetaTyVar (x1) 
  #'(lambda (x2) (UTILITIES::linkMetaTyVar-1-1 x1 x2)))
                                                       
(defparameter UTILITIES::listSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "List" "List" (cons "a" nil)))
                                                                    
(defun UTILITIES::lookup (desired_key? association_list) 
  (block 
   nil 
   (if (null association_list) 
       (return '(:|None|)) 
       (if (consp association_list) 
           (let ((pV11319 (car association_list))) 
             (return 
              (if (funcall desired_key? (car pV11319)) 
                  (cons :|Some| (cdr pV11319)) 
                  (UTILITIES::lookup desired_key? (cdr association_list))))))) 
   (error "Nonexhaustive match failure in lookup")))
                                                    
(defun UTILITIES::lookup-1 (x) (UTILITIES::lookup (car x) (cdr x)))
                                                                   
(defun UTILITIES::mkAnd-1 (x) (UTILITIES::mkAnd (car x) (cdr x)))
                                                                 
(defun UTILITIES::mkIfThenElse-1 (x) 
  (UTILITIES::mkIfThenElse (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun UTILITIES::mkOr-1 (x) (UTILITIES::mkOr (car x) (cdr x)))
                                                               
(defun UTILITIES::modifyNamesFun (pV11395 mOp fun) 
  (declare (ignore pV11395)) 
  (block 
   nil 
   (if (eq (car fun) :|Op|) 
       (let ((pV11398 (cdr fun))) 
         (return (cons :|Op| (cons (funcall mOp (car pV11398)) (cdr pV11398)))))) 
   (return fun)))
                 
(defun UTILITIES::modifyNamesFun-1 (x) 
  (UTILITIES::modifyNamesFun (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun UTILITIES::modifyNamesVar (pV11516 pV11517 pV11518) 
  (block 
   nil 
   (return 
    (cons 
     (car pV11518) 
     (UTILITIES::modifyNamesSort pV11516 pV11517 (cdr pV11518)))) 
   (error "Nonexhaustive match failure in modifyNamesVar")))
                                                            
(defun UTILITIES::modifyNamesPattern (mSrt mOp pat) 
  (block 
   nil 
   (if (eq (car pat) :|AliasPat|) 
       (let ((pV11422 (cdr pat))) 
         (return 
          (cons 
           :|AliasPat| 
           (vector 
            (UTILITIES::modifyNamesPattern mSrt mOp (svref pV11422 0)) 
            (UTILITIES::modifyNamesPattern mSrt mOp (svref pV11422 1)) 
            (svref pV11422 2))))) 
       (if (eq (car pat) :|VarPat|) 
           (let ((pV11421 (cdr pat))) 
             (return 
              (cons 
               :|VarPat| 
               (cons 
                (UTILITIES::modifyNamesVar mSrt mOp (car pV11421)) 
                (cdr pV11421))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV11420 (cdr pat))) 
                 (let ((pV11434 (svref pV11420 1))) 
                   (return 
                    (cons 
                     :|EmbedPat| 
                     (vector 
                      (svref pV11420 0) 
                      (block 
                       nil 
                       (if (eq (car pV11434) :|None|) 
                           (return '(:|None|)) 
                           (if (eq (car pV11434) :|Some|) 
                               (return 
                                (cons 
                                 :|Some| 
                                 (UTILITIES::modifyNamesPattern 
                                  mSrt 
                                  mOp 
                                  (cdr pV11434)))))) 
                       (error 
                        "Nonexhaustive match failure in modifyNamesPattern")) 
                      (UTILITIES::modifyNamesSort mSrt mOp (svref pV11420 2)) 
                      (svref pV11420 3)))))) 
               (if (eq (car pat) :|RecordPat|) 
                   (let ((pV11419 (cdr pat))) 
                     (return 
                      (cons 
                       :|RecordPat| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (car x) 
                             (UTILITIES::modifyNamesPattern mSrt mOp (cdr x)))) 
                         (car pV11419)) 
                        (cdr pV11419))))) 
                   (if (eq (car pat) :|WildPat|) 
                       (let ((pV11418 (cdr pat))) 
                         (return 
                          (cons 
                           :|WildPat| 
                           (cons 
                            (UTILITIES::modifyNamesSort mSrt mOp (car pV11418)) 
                            (cdr pV11418))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV11417 (cdr pat))) 
                             (return 
                              (cons 
                               :|RelaxPat| 
                               (vector 
                                (UTILITIES::modifyNamesPattern 
                                 mSrt 
                                 mOp 
                                 (svref pV11417 0)) 
                                (UTILITIES::modifyNamesTerm 
                                 mSrt 
                                 mOp 
                                 (svref pV11417 1)) 
                                (svref pV11417 2))))) 
                           (if (eq (car pat) :|QuotientPat|) 
                               (let ((pV11416 (cdr pat))) 
                                 (return 
                                  (cons 
                                   :|QuotientPat| 
                                   (vector 
                                    (UTILITIES::modifyNamesPattern 
                                     mSrt 
                                     mOp 
                                     (svref pV11416 0)) 
                                    (UTILITIES::modifyNamesTerm 
                                     mSrt 
                                     mOp 
                                     (svref pV11416 1)) 
                                    (svref pV11416 2)))))))))))) 
   (return pat)))
                 
(defun UTILITIES::modifyNamesTerm (mSrt mOp term) 
  (block 
   nil 
   (if (eq (car term) :|Apply|) 
       (let ((pV11487 (cdr term))) 
         (return 
          (cons 
           :|Apply| 
           (vector 
            (UTILITIES::modifyNamesTerm mSrt mOp (svref pV11487 0)) 
            (UTILITIES::modifyNamesTerm mSrt mOp (svref pV11487 1)) 
            (svref pV11487 2))))) 
       (if (eq (car term) :|Record|) 
           (let ((pV11486 (cdr term))) 
             (return 
              (cons 
               :|Record| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::modifyNamesTerm mSrt mOp (cdr x)))) 
                 (car pV11486)) 
                (cdr pV11486))))) 
           (if (eq (car term) :|Bind|) 
               (let ((pV11485 (cdr term))) 
                 (return 
                  (cons 
                   :|Bind| 
                   (vector 
                    (svref pV11485 0) 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (v) (UTILITIES::modifyNamesVar mSrt mOp v)) 
                     (svref pV11485 1)) 
                    (UTILITIES::modifyNamesTerm mSrt mOp (svref pV11485 2)) 
                    (svref pV11485 3))))) 
               (if (eq (car term) :|Let|) 
                   (let ((pV11484 (cdr term))) 
                     (return 
                      (cons 
                       :|Let| 
                       (vector 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) 
                            (cons 
                             (UTILITIES::modifyNamesPattern mSrt mOp (car x)) 
                             (UTILITIES::modifyNamesTerm mSrt mOp (cdr x)))) 
                         (svref pV11484 0)) 
                        (UTILITIES::modifyNamesTerm mSrt mOp (svref pV11484 1)) 
                        (svref pV11484 2))))) 
                   (if (eq (car term) :|LetRec|) 
                       (let ((pV11483 (cdr term))) 
                         (return 
                          (cons 
                           :|LetRec| 
                           (vector 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (UTILITIES::modifyNamesVar mSrt mOp (car x)) 
                                 (UTILITIES::modifyNamesTerm mSrt mOp (cdr x)))) 
                             (svref pV11483 0)) 
                            (UTILITIES::modifyNamesTerm 
                             mSrt 
                             mOp 
                             (svref pV11483 1)) 
                            (svref pV11483 2))))) 
                       (if (eq (car term) :|Var|) 
                           (let ((pV11482 (cdr term))) 
                             (return 
                              (cons 
                               :|Var| 
                               (cons 
                                (UTILITIES::modifyNamesVar 
                                 mSrt 
                                 mOp 
                                 (car pV11482)) 
                                (cdr pV11482))))) 
                           (if (eq (car term) :|Fun|) 
                               (let ((pV11481 (cdr term))) 
                                 (return 
                                  (cons 
                                   :|Fun| 
                                   (vector 
                                    (UTILITIES::modifyNamesFun 
                                     mSrt 
                                     mOp 
                                     (svref pV11481 0)) 
                                    (UTILITIES::modifyNamesSort 
                                     mSrt 
                                     mOp 
                                     (svref pV11481 1)) 
                                    (svref pV11481 2))))) 
                               (if (eq (car term) :|Lambda|) 
                                   (let ((pV11480 (cdr term))) 
                                     (return 
                                      (cons 
                                       :|Lambda| 
                                       (cons 
                                        (LIST-SPEC::|!map|-1-1 
                                         #'(lambda (x) 
                                            (vector 
                                             (UTILITIES::modifyNamesPattern 
                                              mSrt 
                                              mOp 
                                              (svref x 0)) 
                                             (UTILITIES::modifyNamesTerm 
                                              mSrt 
                                              mOp 
                                              (svref x 1)) 
                                             (UTILITIES::modifyNamesTerm 
                                              mSrt 
                                              mOp 
                                              (svref x 2)))) 
                                         (car pV11480)) 
                                        (cdr pV11480))))) 
                                   (if (eq (car term) :|IfThenElse|) 
                                       (let ((pV11479 (cdr term))) 
                                         (return 
                                          (cons 
                                           :|IfThenElse| 
                                           (vector 
                                            (UTILITIES::modifyNamesTerm 
                                             mSrt 
                                             mOp 
                                             (svref pV11479 0)) 
                                            (UTILITIES::modifyNamesTerm 
                                             mSrt 
                                             mOp 
                                             (svref pV11479 1)) 
                                            (UTILITIES::modifyNamesTerm 
                                             mSrt 
                                             mOp 
                                             (svref pV11479 2)) 
                                            (svref pV11479 3))))) 
                                       (if (eq (car term) :|Seq|) 
                                           (let ((pV11478 (cdr term))) 
                                             (return 
                                              (cons 
                                               :|Seq| 
                                               (cons 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (|!t|) 
                                                    (UTILITIES::modifyNamesTerm 
                                                     mSrt 
                                                     mOp 
                                                     |!t|)) 
                                                 (car pV11478)) 
                                                (cdr pV11478))))))))))))))) 
   (return term)))
                  
(defun UTILITIES::modifyNamesSort (mSrt mOp srt) 
  (block 
   nil 
   (if (eq (car srt) :|Arrow|) 
       (let ((pV11451 (cdr srt))) 
         (return 
          (cons 
           :|Arrow| 
           (vector 
            (UTILITIES::modifyNamesSort mSrt mOp (svref pV11451 0)) 
            (UTILITIES::modifyNamesSort mSrt mOp (svref pV11451 1)) 
            (svref pV11451 2))))) 
       (if (eq (car srt) :|Product|) 
           (let ((pV11450 (cdr srt))) 
             (return 
              (cons 
               :|Product| 
               (cons 
                (LIST-SPEC::|!map|-1-1 
                 #'(lambda (x) 
                    (cons (car x) (UTILITIES::modifyNamesSort mSrt mOp (cdr x)))) 
                 (car pV11450)) 
                (cdr pV11450))))) 
           (if (eq (car srt) :|CoProduct|) 
               (let ((pV11449 (cdr srt))) 
                 (return 
                  (cons 
                   :|CoProduct| 
                   (cons 
                    (LIST-SPEC::|!map|-1-1 
                     #'(lambda (x) 
                        (let ((optsrt (cdr x))) 
                          (cons 
                           (car x) 
                           (block 
                            nil 
                            (if (eq (car optsrt) :|Some|) 
                                (return 
                                 (cons 
                                  :|Some| 
                                  (UTILITIES::modifyNamesSort 
                                   mSrt 
                                   mOp 
                                   (cdr optsrt)))) 
                                (if (eq (car optsrt) :|None|) 
                                    (return '(:|None|)))) 
                            (error 
                             "Nonexhaustive match failure in modifyNamesSort"))))) 
                     (car pV11449)) 
                    (cdr pV11449))))) 
               (if (eq (car srt) :|Quotient|) 
                   (let ((pV11448 (cdr srt))) 
                     (return 
                      (cons 
                       :|Quotient| 
                       (vector 
                        (UTILITIES::modifyNamesSort mSrt mOp (svref pV11448 0)) 
                        (UTILITIES::modifyNamesTerm mSrt mOp (svref pV11448 1)) 
                        (svref pV11448 2))))) 
                   (if (eq (car srt) :|Subsort|) 
                       (let ((pV11447 (cdr srt))) 
                         (return 
                          (cons 
                           :|Subsort| 
                           (vector 
                            (UTILITIES::modifyNamesSort 
                             mSrt 
                             mOp 
                             (svref pV11447 0)) 
                            (UTILITIES::modifyNamesTerm 
                             mSrt 
                             mOp 
                             (svref pV11447 1)) 
                            (svref pV11447 2))))) 
                       (if (eq (car srt) :|Base|) 
                           (let ((pV11446 (cdr srt))) 
                             (return 
                              (cons 
                               :|Base| 
                               (vector 
                                (funcall mSrt (svref pV11446 0)) 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (s) 
                                    (UTILITIES::modifyNamesSort mSrt mOp s)) 
                                 (svref pV11446 1)) 
                                (svref pV11446 2))))))))))) 
   (return srt)))
                 
(defun UTILITIES::modifyNamesOpInfo (pV11403 pV11404 pV11405) 
  (block 
   nil 
   (let ((pV11409 (svref pV11405 3))
         (pV11408 (svref pV11405 2))) 
     (return 
      (vector 
       (LIST-SPEC::rev 
        (LIST-SPEC::foldl-1-1-1 
         #'(lambda (x) (LIST-SPEC::|!cons| (funcall pV11404 (car x)) (cdr x))) 
         LIST-SPEC::|!nil| 
         (svref pV11405 0))) 
       (svref pV11405 1) 
       (cons 
        (car pV11408) 
        (UTILITIES::modifyNamesSort pV11403 pV11404 (cdr pV11408))) 
       (block 
        nil 
        (if (eq (car pV11409) :|Some|) 
            (return 
             (cons 
              :|Some| 
              (UTILITIES::modifyNamesTerm pV11403 pV11404 (cdr pV11409)))) 
            (if (eq (car pV11409) :|None|) (return '(:|None|)))) 
        (error "Nonexhaustive match failure in modifyNamesOpInfo"))))) 
   (error "Nonexhaustive match failure in modifyNamesOpInfo")))
                                                               
(defun UTILITIES::modifyNamesOpInfo-1 (x) 
  (UTILITIES::modifyNamesOpInfo (svref x 0) (svref x 1) (svref x 2)))
                                                                     
(defun UTILITIES::modifyNamesPattern-1 (x) 
  (UTILITIES::modifyNamesPattern (svref x 0) (svref x 1) (svref x 2)))
                                                                      
(defun UTILITIES::modifyNamesSort-1 (x) 
  (UTILITIES::modifyNamesSort (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun UTILITIES::modifyNamesSortInfo (pV11470 pV11471 pV11472) 
  (block 
   nil 
   (let ((pV11475 (svref pV11472 2))) 
     (return 
      (vector 
       (LIST-SPEC::rev 
        (LIST-SPEC::foldl-1-1-1 
         #'(lambda (x) (LIST-SPEC::|!cons| (funcall pV11470 (car x)) (cdr x))) 
         LIST-SPEC::|!nil| 
         (svref pV11472 0))) 
       (svref pV11472 1) 
       (block 
        nil 
        (if (eq (car pV11475) :|Some|) 
            (return 
             (cons 
              :|Some| 
              (UTILITIES::modifyNamesSort pV11470 pV11471 (cdr pV11475)))) 
            (if (eq (car pV11475) :|None|) (return '(:|None|)))) 
        (error "Nonexhaustive match failure in modifyNamesSortInfo"))))) 
   (error "Nonexhaustive match failure in modifyNamesSortInfo")))
                                                                 
(defun UTILITIES::modifyNamesSortInfo-1 (x) 
  (UTILITIES::modifyNamesSortInfo (svref x 0) (svref x 1) (svref x 2)))
                                                                       
(defun UTILITIES::modifyNamesTerm-1 (x) 
  (UTILITIES::modifyNamesTerm (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun UTILITIES::modifyNamesVar-1 (x) 
  (UTILITIES::modifyNamesVar (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defparameter UTILITIES::natSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "Nat" "Nat" nil))
                                                       
(defun UTILITIES::occurs-1 (x) (UTILITIES::occurs (car x) (cdr x)))
                                                                   
(defun UTILITIES::occursT-1 (x) (UTILITIES::occursT (car x) (cdr x)))
                                                                     
(defun UTILITIES::patternVars (p) 
  (labels 
    ((loopP (p vs) 
      (block 
       nil 
       (if (eq (car p) :|VarPat|) 
           (return (LIST-SPEC::|!cons| (car (cdr p)) vs)) 
           (if (eq (car p) :|RecordPat|) 
               (return 
                (LIST-SPEC::foldr-1-1-1 
                 #'(lambda (x) 
                    (block 
                     nil 
                     (return (loopP (cdr (car x)) (cdr x))) 
                     (error "Nonexhaustive match failure in patternVars"))) 
                 vs 
                 (car (cdr p)))) 
               (if (eq (car p) :|EmbedPat|) 
                   (let ((pV11719 (svref (cdr p) 1))) 
                     (if (eq (car pV11719) :|None|) 
                         (return vs) 
                         (if (eq (car pV11719) :|Some|) 
                             (return (loopP (cdr pV11719) vs))))) 
                   (if (eq (car p) :|QuotientPat|) 
                       (return (loopP (svref (cdr p) 0) vs)) 
                       (if (eq (car p) :|RelaxPat|) 
                           (return (loopP (svref (cdr p) 0) vs)) 
                           (if (eq (car p) :|AliasPat|) 
                               (let ((pV11703 (cdr p))) 
                                 (return 
                                  (loopP 
                                   (svref pV11703 0) 
                                   (loopP (svref pV11703 1) vs)))))))))) 
       (return vs)))) (loopP p nil)))
                                     
(defun UTILITIES::removeDefinitions-1 (spc) 
  (vector 
   (svref spc 0) 
   (STRINGMAP::|!map|-1-1 
    #'(lambda (m) 
       (STRINGMAP::|!map|-1-1 
        #'(lambda (x) (vector (svref x 0) (svref x 1) (svref x 2) '(:|None|))) 
        m)) 
    (svref spc 1)) 
   STANDARDSPEC::emptyProperties 
   (svref spc 3)))
                  
(defun UTILITIES::removeDefinitions (x0 x1 x2 x3) 
  (UTILITIES::removeDefinitions-1 (vector x0 x1 x2 x3)))
                                                        
(defun UTILITIES::repBoundVar (pV11727 pV11728 pV11729) 
  (block 
   nil 
   (let ((pV11731 (cdr pV11727))
         (pV11730 (car pV11727))) 
     (return 
      (if (STRINGSET::|!member| pV11729 pV11730) 
          (let ((id2 (STRINGUTILITIES::freshName pV11730 pV11729))) 
            (let ((sub2 
                   (LIST-SPEC::|!cons| 
                    (cons 
                     (STANDARDSPEC::mkVar pV11730 pV11731) 
                     (STANDARDSPEC::mkVar id2 pV11731)) 
                    pV11728))) (vector (cons id2 pV11731) sub2 pV11729))) 
          (vector (cons pV11730 pV11731) pV11728 pV11729)))) 
   (error "Nonexhaustive match failure in repBoundVar")))
                                                         
(defun UTILITIES::repBoundVar-1 (x) 
  (UTILITIES::repBoundVar (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun UTILITIES::repBoundVars (vars sub freeNames) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (let ((pV11737 (cdr x))) 
        (block 
         nil 
         (return 
          (let ((pV11732 
                 (UTILITIES::repBoundVar 
                  (car x) 
                  (svref pV11737 1) 
                  (svref pV11737 2)))) 
            (block 
             nil 
             (return 
              (vector 
               (LIST-SPEC::|!cons| (svref pV11732 0) (svref pV11737 0)) 
               (svref pV11732 1) 
               (svref pV11732 2))) 
             (error "Nonexhaustive match failure in repBoundVars")))) 
         (error "Nonexhaustive match failure in repBoundVars")))) 
   (vector nil sub freeNames) 
   vars))
         
(defun UTILITIES::repBoundVars-1 (x) 
  (UTILITIES::repBoundVars (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun UTILITIES::repPattern (pat sub freeNames) 
  (block 
   nil 
   (if (eq (car pat) :|VarPat|) 
       (let ((pV11788 (cdr pat))) 
         (return 
          (let ((pV11741 (UTILITIES::repBoundVar (car pV11788) sub freeNames))) 
            (block 
             nil 
             (return 
              (vector 
               (cons :|VarPat| (cons (svref pV11741 0) (cdr pV11788))) 
               (svref pV11741 1) 
               (svref pV11741 2))) 
             (error "Nonexhaustive match failure in repPattern"))))) 
       (if (eq (car pat) :|RecordPat|) 
           (let ((pV11787 (cdr pat))) 
             (return 
              (let ((pV11756 
                     (LIST-SPEC::foldr-1-1-1 
                      #'(lambda (x) 
                         (let ((pV11750 (cdr x))
                               (pV11749 (car x))) 
                           (block 
                            nil 
                            (return 
                             (let ((pV11745 
                                    (UTILITIES::repPattern 
                                     (cdr pV11749) 
                                     (svref pV11750 1) 
                                     (svref pV11750 2)))) 
                               (block 
                                nil 
                                (return 
                                 (vector 
                                  (LIST-SPEC::|!cons| 
                                   (cons (car pV11749) (svref pV11745 0)) 
                                   (svref pV11750 0)) 
                                  (svref pV11745 1) 
                                  (svref pV11745 2))) 
                                (error 
                                 "Nonexhaustive match failure in repPattern")))) 
                            (error "Nonexhaustive match failure in repPattern")))) 
                      (vector nil sub freeNames) 
                      (car pV11787)))) 
                (block 
                 nil 
                 (return 
                  (vector 
                   (cons :|RecordPat| (cons (svref pV11756 0) (cdr pV11787))) 
                   (svref pV11756 1) 
                   (svref pV11756 2))) 
                 (error "Nonexhaustive match failure in repPattern"))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV11786 (cdr pat))) 
                 (let ((pV11799 (svref pV11786 1))) 
                   (if (eq (car pV11799) :|Some|) 
                       (return 
                        (let ((pV11760 
                               (UTILITIES::repPattern 
                                (cdr pV11799) 
                                sub 
                                freeNames))) 
                          (block 
                           nil 
                           (return 
                            (vector 
                             (cons 
                              :|EmbedPat| 
                              (vector 
                               (svref pV11786 0) 
                               (cons :|Some| (svref pV11760 0)) 
                               (svref pV11786 2) 
                               (svref pV11786 3))) 
                             (svref pV11760 1) 
                             (svref pV11760 2))) 
                           (error "Nonexhaustive match failure in repPattern")))) 
                       (if (eq (car pV11799) :|None|) 
                           (return (vector pat sub freeNames)))))) 
               (if (eq (car pat) :|AliasPat|) 
                   (let ((pV11785 (cdr pat))) 
                     (return 
                      (let ((pV11769 
                             (UTILITIES::repPattern 
                              (svref pV11785 0) 
                              sub 
                              freeNames))) 
                        (block 
                         nil 
                         (return 
                          (let ((pV11765 
                                 (UTILITIES::repPattern 
                                  (svref pV11785 1) 
                                  (svref pV11769 1) 
                                  (svref pV11769 2)))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|AliasPat| 
                                (vector 
                                 (svref pV11769 0) 
                                 (svref pV11765 0) 
                                 (svref pV11785 2))) 
                               (svref pV11765 1) 
                               (svref pV11765 2))) 
                             (error "Nonexhaustive match failure in repPattern")))) 
                         (error "Nonexhaustive match failure in repPattern"))))) 
                   (if (eq (car pat) :|QuotientPat|) 
                       (let ((pV11784 (cdr pat))) 
                         (return 
                          (let ((pV11773 
                                 (UTILITIES::repPattern 
                                  (svref pV11784 0) 
                                  sub 
                                  freeNames))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|QuotientPat| 
                                (vector 
                                 (svref pV11773 0) 
                                 (svref pV11784 1) 
                                 (svref pV11784 2))) 
                               (svref pV11773 1) 
                               (svref pV11773 2))) 
                             (error "Nonexhaustive match failure in repPattern"))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV11783 (cdr pat))) 
                             (return 
                              (let ((pV11777 
                                     (UTILITIES::repPattern 
                                      (svref pV11783 0) 
                                      sub 
                                      freeNames))) 
                                (block 
                                 nil 
                                 (return 
                                  (vector 
                                   (cons 
                                    :|RelaxPat| 
                                    (vector 
                                     (svref pV11777 0) 
                                     (svref pV11783 1) 
                                     (svref pV11783 2))) 
                                   (svref pV11777 1) 
                                   (svref pV11777 2))) 
                                 (error 
                                  "Nonexhaustive match failure in repPattern"))))))))))) 
   (return (vector pat sub freeNames))))
                                        
(defun UTILITIES::repPattern-1 (x) 
  (UTILITIES::repPattern (svref x 0) (svref x 1) (svref x 2)))
                                                              
(defun UTILITIES::replace2 (|!M| sub freeNames) 
  (labels 
    ((repLet (pV11869 pV11870) 
      (block 
       nil 
       (return 
        (let ((pV11865 
               (UTILITIES::repPattern 
                (car pV11869) 
                (svref pV11870 2) 
                (svref pV11870 1)))) 
          (block 
           nil 
           (return 
            (vector 
             (LIST-SPEC::|!cons| 
              (cons (svref pV11865 0) (cdr pV11869)) 
              (svref pV11870 0)) 
             (svref pV11865 2) 
             (svref pV11865 1))) 
           (error "Nonexhaustive match failure in replace2")))) 
       (error "Nonexhaustive match failure in replace2")))
     (repRule (pat |!cond| term) 
      (let ((pV11861 (UTILITIES::repPattern pat sub freeNames))) 
        (block 
         nil 
         (let ((pV11864 (svref pV11861 2))
               (pV11863 (svref pV11861 1))
               (pV11862 (svref pV11861 0))) 
           (return 
            (if (LIST-SPEC::|!null| pV11863) 
                (vector pV11862 |!cond| term) 
                (vector 
                 pV11862 
                 (UTILITIES::replace2 |!cond| pV11863 pV11864) 
                 (UTILITIES::replace2 term pV11863 pV11864))))) 
         (error "Nonexhaustive match failure in replace2"))))
     (rep (|!M|) 
      (let ((pV11859 
             (UTILITIES::lookup 
              #'(lambda (|!N|) (slang-built-in::slang-term-equals |!N| |!M|)) 
              sub))) 
        (block 
         nil 
         (if (eq (car pV11859) :|Some|) 
             (return (cdr pV11859)) 
             (if (eq (car pV11859) :|None|) 
                 (return 
                  (block 
                   nil 
                   (if (eq (car |!M|) :|Apply|) 
                       (let ((pV11835 (cdr |!M|))) 
                         (return 
                          (cons 
                           :|Apply| 
                           (vector 
                            (rep (svref pV11835 0)) 
                            (rep (svref pV11835 1)) 
                            (svref pV11835 2))))) 
                       (if (eq (car |!M|) :|Record|) 
                           (let ((pV11834 (cdr |!M|))) 
                             (return 
                              (cons 
                               :|Record| 
                               (cons 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (x) (cons (car x) (rep (cdr x)))) 
                                 (car pV11834)) 
                                (cdr pV11834))))) 
                           (if (eq (car |!M|) :|Let|) 
                               (let ((pV11833 (cdr |!M|))) 
                                 (return 
                                  (let ((decls 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) 
                                             (cons (car x) (rep (cdr x)))) 
                                          (svref pV11833 0)))) 
                                    (let ((pV11813 
                                           (LIST-SPEC::foldr-1-1-1 
                                            #'(lambda (x) 
                                               (repLet (car x) (cdr x))) 
                                            (vector nil freeNames sub) 
                                            decls))) 
                                      (block 
                                       nil 
                                       (return 
                                        (cons 
                                         :|Let| 
                                         (vector 
                                          (svref pV11813 0) 
                                          (UTILITIES::replace2 
                                           (svref pV11833 1) 
                                           (svref pV11813 2) 
                                           (svref pV11813 1)) 
                                          (svref pV11833 2)))) 
                                       (error 
                                        "Nonexhaustive match failure in replace2")))))) 
                               (if (eq (car |!M|) :|LetRec|) 
                                   (let ((pV11832 (cdr |!M|))) 
                                     (let ((pV11848 (svref pV11832 0))) 
                                       (return 
                                        (let ((pV11819 
                                               (UTILITIES::repBoundVars 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (x) (car x)) 
                                                 pV11848) 
                                                sub 
                                                freeNames))) 
                                          (block 
                                           nil 
                                           (let ((pV11822 (svref pV11819 2))
                                                 (pV11821 (svref pV11819 1))) 
                                             (return 
                                              (let ((terms 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (UTILITIES::replace2 
                                                          (cdr x) 
                                                          pV11821 
                                                          pV11822)) 
                                                      pV11848))) 
                                                (let ((decls 
                                                       (LISTPAIR::zip 
                                                        (svref pV11819 0) 
                                                        terms))) 
                                                  (cons 
                                                   :|LetRec| 
                                                   (vector 
                                                    decls 
                                                    (UTILITIES::replace2 
                                                     (svref pV11832 1) 
                                                     pV11821 
                                                     pV11822) 
                                                    (svref pV11832 2))))))) 
                                           (error 
                                            "Nonexhaustive match failure in replace2")))))) 
                                   (if (eq (car |!M|) :|Lambda|) 
                                       (let ((pV11831 (cdr |!M|))) 
                                         (return 
                                          (cons 
                                           :|Lambda| 
                                           (cons 
                                            (LIST-SPEC::|!map|-1-1 
                                             #'(lambda (x) 
                                                (repRule 
                                                 (svref x 0) 
                                                 (svref x 1) 
                                                 (svref x 2))) 
                                             (car pV11831)) 
                                            (cdr pV11831))))) 
                                       (if (eq (car |!M|) :|Bind|) 
                                           (let ((pV11830 (cdr |!M|))) 
                                             (return 
                                              (let ((pV11823 
                                                     (UTILITIES::repBoundVars 
                                                      (svref pV11830 1) 
                                                      sub 
                                                      freeNames))) 
                                                (block 
                                                 nil 
                                                 (return 
                                                  (cons 
                                                   :|Bind| 
                                                   (vector 
                                                    (svref pV11830 0) 
                                                    (svref pV11823 0) 
                                                    (UTILITIES::replace2 
                                                     (svref pV11830 2) 
                                                     (svref pV11823 1) 
                                                     (svref pV11823 2)) 
                                                    (svref pV11830 3)))) 
                                                 (error 
                                                  "Nonexhaustive match failure in replace2"))))) 
                                           (if (eq (car |!M|) :|Seq|) 
                                               (let ((pV11829 (cdr |!M|))) 
                                                 (return 
                                                  (cons 
                                                   :|Seq| 
                                                   (cons 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'rep 
                                                     (car pV11829)) 
                                                    (cdr pV11829))))) 
                                               (if (eq (car |!M|) :|IfThenElse|) 
                                                   (let ((pV11828 (cdr |!M|))) 
                                                     (return 
                                                      (cons 
                                                       :|IfThenElse| 
                                                       (vector 
                                                        (rep (svref pV11828 0)) 
                                                        (rep (svref pV11828 1)) 
                                                        (rep (svref pV11828 2)) 
                                                        (svref pV11828 3))))))))))))) 
                   (return |!M|))))) 
         (error "Nonexhaustive match failure in replace2"))))) (rep |!M|)))
                                                                           
(defun UTILITIES::|!replace| (|!M| sub) 
  (if (LIST-SPEC::|!null| sub) 
      |!M| 
      (let ((freeNames 
             (LIST-SPEC::foldr-1-1-1 
              #'(lambda (x) 
                 (block 
                  nil 
                  (return 
                   (STRINGSET::|!union| 
                    (STRINGSET::fromList 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x1) (car x1)) 
                      (UTILITIES::freeVars (cdr (car x))))) 
                    (cdr x))) 
                  (error "Nonexhaustive match failure in replace"))) 
              STRINGSET::empty 
              sub))) (UTILITIES::replace2 |!M| sub freeNames))))
                                                                
(defun UTILITIES::|!replace|-1 (x) (UTILITIES::|!replace| (car x) (cdr x)))
                                                                           
(defun UTILITIES::replace2-1 (x) 
  (UTILITIES::replace2 (svref x 0) (svref x 1) (svref x 2)))
                                                            
(defparameter UTILITIES::report_unimplemented_for_cgen nil)
                                                           
(defun UTILITIES::sameCPSort?-1 (x) (UTILITIES::sameCPSort? (car x) (cdr x)))
                                                                             
(defun UTILITIES::specEqual? (s1 s2) 
  (lisp::and 
   (slang-built-in::slang-term-equals (svref s1 2) (svref s2 2)) 
   (lisp::and 
    (slang-built-in::slang-term-equals 
     (STRINGMAP::toList (svref s1 3)) 
     (STRINGMAP::toList (svref s2 3))) 
    (slang-built-in::slang-term-equals 
     (STRINGMAP::toList (svref s1 1)) 
     (STRINGMAP::toList (svref s2 1))))))
                                         
(defun UTILITIES::specEqual?-1 (x) (UTILITIES::specEqual? (car x) (cdr x)))
                                                                           
(defparameter UTILITIES::stringSpec 
  (UTILITIES::initPrimitiveSpec-1-1-1 "String" "String" nil))
                                                             
(defun UTILITIES::subspec? (s1 s2) 
  (lisp::and 
   (LISTUTILITIES::subset? (svref s1 2) (svref s2 2)) 
   (lisp::and 
    (STRINGMAP::subset? (svref s1 3) (svref s2 3)) 
    (STRINGMAP::subset? (svref s1 1) (svref s2 1)))))
                                                     
(defun UTILITIES::subspec?-1 (x) (UTILITIES::subspec? (car x) (cdr x)))
                                                                       
(defun UTILITIES::substBoundVar (pV11888 pV11889 pV11890) 
  (block 
   nil 
   (let ((pV11892 (cdr pV11888))
         (pV11891 (car pV11888))) 
     (return 
      (if (STRINGSET::|!member| pV11890 pV11891) 
          (let ((id2 (STRINGUTILITIES::freshName pV11891 pV11890))) 
            (let ((sub2 
                   (LIST-SPEC::|!cons| 
                    (cons 
                     (cons pV11891 pV11892) 
                     (STANDARDSPEC::mkVar id2 pV11892)) 
                    pV11889))) (vector (cons id2 pV11892) sub2 pV11890))) 
          (vector 
           (cons pV11891 pV11892) 
           (UTILITIES::deleteVar (cons pV11891 pV11892) pV11889 nil) 
           pV11890)))) 
   (error "Nonexhaustive match failure in substBoundVar")))
                                                           
(defun UTILITIES::substBoundVar-1 (x) 
  (UTILITIES::substBoundVar (svref x 0) (svref x 1) (svref x 2)))
                                                                 
(defun UTILITIES::substBoundVars (vars sub freeNames) 
  (LIST-SPEC::foldr-1-1-1 
   #'(lambda (x) 
      (let ((pV11898 (cdr x))) 
        (block 
         nil 
         (return 
          (let ((pV11893 
                 (UTILITIES::substBoundVar 
                  (car x) 
                  (svref pV11898 1) 
                  (svref pV11898 2)))) 
            (block 
             nil 
             (return 
              (vector 
               (LIST-SPEC::|!cons| (svref pV11893 0) (svref pV11898 0)) 
               (svref pV11893 1) 
               (svref pV11893 2))) 
             (error "Nonexhaustive match failure in substBoundVars")))) 
         (error "Nonexhaustive match failure in substBoundVars")))) 
   (vector nil sub freeNames) 
   vars))
         
(defun UTILITIES::substBoundVars-1 (x) 
  (UTILITIES::substBoundVars (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun UTILITIES::substPattern (pat sub freeNames) 
  (block 
   nil 
   (if (eq (car pat) :|VarPat|) 
       (let ((pV11949 (cdr pat))) 
         (return 
          (let ((pV11902 (UTILITIES::substBoundVar (car pV11949) sub freeNames))) 
            (block 
             nil 
             (return 
              (vector 
               (cons :|VarPat| (cons (svref pV11902 0) (cdr pV11949))) 
               (svref pV11902 1) 
               (svref pV11902 2))) 
             (error "Nonexhaustive match failure in substPattern"))))) 
       (if (eq (car pat) :|RecordPat|) 
           (let ((pV11948 (cdr pat))) 
             (return 
              (let ((pV11917 
                     (LIST-SPEC::foldr-1-1-1 
                      #'(lambda (x) 
                         (let ((pV11911 (cdr x))
                               (pV11910 (car x))) 
                           (block 
                            nil 
                            (return 
                             (let ((pV11906 
                                    (UTILITIES::substPattern 
                                     (cdr pV11910) 
                                     (svref pV11911 1) 
                                     (svref pV11911 2)))) 
                               (block 
                                nil 
                                (return 
                                 (vector 
                                  (LIST-SPEC::|!cons| 
                                   (cons (car pV11910) (svref pV11906 0)) 
                                   (svref pV11911 0)) 
                                  (svref pV11906 1) 
                                  (svref pV11906 2))) 
                                (error 
                                 "Nonexhaustive match failure in substPattern")))) 
                            (error "Nonexhaustive match failure in substPattern")))) 
                      (vector nil sub freeNames) 
                      (car pV11948)))) 
                (block 
                 nil 
                 (return 
                  (vector 
                   (cons :|RecordPat| (cons (svref pV11917 0) (cdr pV11948))) 
                   (svref pV11917 1) 
                   (svref pV11917 2))) 
                 (error "Nonexhaustive match failure in substPattern"))))) 
           (if (eq (car pat) :|EmbedPat|) 
               (let ((pV11947 (cdr pat))) 
                 (let ((pV11960 (svref pV11947 1))) 
                   (if (eq (car pV11960) :|Some|) 
                       (return 
                        (let ((pV11921 
                               (UTILITIES::substPattern 
                                (cdr pV11960) 
                                sub 
                                freeNames))) 
                          (block 
                           nil 
                           (return 
                            (vector 
                             (cons 
                              :|EmbedPat| 
                              (vector 
                               (svref pV11947 0) 
                               (cons :|Some| (svref pV11921 0)) 
                               (svref pV11947 2) 
                               (svref pV11947 3))) 
                             (svref pV11921 1) 
                             (svref pV11921 2))) 
                           (error "Nonexhaustive match failure in substPattern")))) 
                       (if (eq (car pV11960) :|None|) 
                           (return (vector pat sub freeNames)))))) 
               (if (eq (car pat) :|AliasPat|) 
                   (let ((pV11946 (cdr pat))) 
                     (return 
                      (let ((pV11930 
                             (UTILITIES::substPattern 
                              (svref pV11946 0) 
                              sub 
                              freeNames))) 
                        (block 
                         nil 
                         (return 
                          (let ((pV11926 
                                 (UTILITIES::substPattern 
                                  (svref pV11946 1) 
                                  (svref pV11930 1) 
                                  (svref pV11930 2)))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|AliasPat| 
                                (vector 
                                 (svref pV11930 0) 
                                 (svref pV11926 0) 
                                 (svref pV11946 2))) 
                               (svref pV11926 1) 
                               (svref pV11926 2))) 
                             (error 
                              "Nonexhaustive match failure in substPattern")))) 
                         (error "Nonexhaustive match failure in substPattern"))))) 
                   (if (eq (car pat) :|QuotientPat|) 
                       (let ((pV11945 (cdr pat))) 
                         (return 
                          (let ((pV11934 
                                 (UTILITIES::substPattern 
                                  (svref pV11945 0) 
                                  sub 
                                  freeNames))) 
                            (block 
                             nil 
                             (return 
                              (vector 
                               (cons 
                                :|QuotientPat| 
                                (vector 
                                 (svref pV11934 0) 
                                 (svref pV11945 1) 
                                 (svref pV11945 2))) 
                               (svref pV11934 1) 
                               (svref pV11934 2))) 
                             (error 
                              "Nonexhaustive match failure in substPattern"))))) 
                       (if (eq (car pat) :|RelaxPat|) 
                           (let ((pV11944 (cdr pat))) 
                             (return 
                              (let ((pV11938 
                                     (UTILITIES::substPattern 
                                      (svref pV11944 0) 
                                      sub 
                                      freeNames))) 
                                (block 
                                 nil 
                                 (return 
                                  (vector 
                                   (cons 
                                    :|RelaxPat| 
                                    (vector 
                                     (svref pV11938 0) 
                                     (svref pV11944 1) 
                                     (svref pV11944 2))) 
                                   (svref pV11938 1) 
                                   (svref pV11938 2))) 
                                 (error 
                                  "Nonexhaustive match failure in substPattern"))))))))))) 
   (return (vector pat sub freeNames))))
                                        
(defun UTILITIES::substPattern-1 (x) 
  (UTILITIES::substPattern (svref x 0) (svref x 1) (svref x 2)))
                                                                
(defun UTILITIES::substitute2 (|!M| sub freeNames) 
  (labels 
    ((substLet (pV12039 pV12040) 
      (block 
       nil 
       (return 
        (let ((pV12035 
               (UTILITIES::substPattern 
                (car pV12039) 
                (svref pV12040 2) 
                (svref pV12040 1)))) 
          (block 
           nil 
           (return 
            (vector 
             (LIST-SPEC::|!cons| 
              (cons (svref pV12035 0) (cdr pV12039)) 
              (svref pV12040 0)) 
             (svref pV12035 2) 
             (svref pV12035 1))) 
           (error "Nonexhaustive match failure in substitute2")))) 
       (error "Nonexhaustive match failure in substitute2")))
     (substRule (pat |!cond| term) 
      (let ((pV12031 (UTILITIES::substPattern pat sub freeNames))) 
        (block 
         nil 
         (let ((pV12034 (svref pV12031 2))
               (pV12033 (svref pV12031 1))
               (pV12032 (svref pV12031 0))) 
           (return 
            (if (LIST-SPEC::|!null| pV12033) 
                (vector pV12032 |!cond| term) 
                (vector 
                 pV12032 
                 (UTILITIES::substitute2 |!cond| pV12033 pV12034) 
                 (UTILITIES::substitute2 term pV12033 pV12034))))) 
         (error "Nonexhaustive match failure in substitute2"))))
     (|!subst| (|!M|) 
      (block 
       nil 
       (if (eq (car |!M|) :|Var|) 
           (let ((pV12029 (car (car (cdr |!M|))))) 
             (return 
              (let ((pV11975 
                     (UTILITIES::lookup 
                      #'(lambda (x) (string=  pV12029 (car x))) 
                      sub))) 
                (block 
                 nil 
                 (if (eq (car pV11975) :|None|) 
                     (return |!M|) 
                     (if (eq (car pV11975) :|Some|) (return (cdr pV11975)))) 
                 (error "Nonexhaustive match failure in substitute2"))))) 
           (if (eq (car |!M|) :|Apply|) 
               (let ((pV12002 (cdr |!M|))) 
                 (return 
                  (cons 
                   :|Apply| 
                   (vector 
                    (|!subst| (svref pV12002 0)) 
                    (|!subst| (svref pV12002 1)) 
                    (svref pV12002 2))))) 
               (if (eq (car |!M|) :|Record|) 
                   (let ((pV12001 (cdr |!M|))) 
                     (return 
                      (cons 
                       :|Record| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) (cons (car x) (|!subst| (cdr x)))) 
                         (car pV12001)) 
                        (cdr pV12001))))) 
                   (if (eq (car |!M|) :|Fun|) 
                       (return |!M|) 
                       (if (eq (car |!M|) :|Lambda|) 
                           (let ((pV11999 (cdr |!M|))) 
                             (return 
                              (cons 
                               :|Lambda| 
                               (cons 
                                (LIST-SPEC::|!map|-1-1 
                                 #'(lambda (x) 
                                    (substRule 
                                     (svref x 0) 
                                     (svref x 1) 
                                     (svref x 2))) 
                                 (car pV11999)) 
                                (cdr pV11999))))) 
                           (if (eq (car |!M|) :|Let|) 
                               (let ((pV11998 (cdr |!M|))) 
                                 (return 
                                  (let ((decls 
                                         (LIST-SPEC::|!map|-1-1 
                                          #'(lambda (x) 
                                             (cons (car x) (|!subst| (cdr x)))) 
                                          (svref pV11998 0)))) 
                                    (let ((pV11979 
                                           (LIST-SPEC::foldr-1-1-1 
                                            #'(lambda (x) 
                                               (substLet (car x) (cdr x))) 
                                            (vector nil freeNames sub) 
                                            decls))) 
                                      (block 
                                       nil 
                                       (return 
                                        (cons 
                                         :|Let| 
                                         (vector 
                                          (svref pV11979 0) 
                                          (UTILITIES::substitute2 
                                           (svref pV11998 1) 
                                           (svref pV11979 2) 
                                           (svref pV11979 1)) 
                                          (svref pV11998 2)))) 
                                       (error 
                                        "Nonexhaustive match failure in substitute2")))))) 
                               (if (eq (car |!M|) :|LetRec|) 
                                   (let ((pV11997 (cdr |!M|))) 
                                     (let ((pV12014 (svref pV11997 0))) 
                                       (return 
                                        (let ((pV11985 
                                               (UTILITIES::substBoundVars 
                                                (LIST-SPEC::|!map|-1-1 
                                                 #'(lambda (x) (car x)) 
                                                 pV12014) 
                                                sub 
                                                freeNames))) 
                                          (block 
                                           nil 
                                           (let ((pV11988 (svref pV11985 2))
                                                 (pV11987 (svref pV11985 1))) 
                                             (return 
                                              (let ((terms 
                                                     (LIST-SPEC::|!map|-1-1 
                                                      #'(lambda (x) 
                                                         (UTILITIES::substitute2 
                                                          (cdr x) 
                                                          pV11987 
                                                          pV11988)) 
                                                      pV12014))) 
                                                (let ((decls 
                                                       (LISTPAIR::zip 
                                                        (svref pV11985 0) 
                                                        terms))) 
                                                  (cons 
                                                   :|LetRec| 
                                                   (vector 
                                                    decls 
                                                    (UTILITIES::substitute2 
                                                     (svref pV11997 1) 
                                                     pV11987 
                                                     pV11988) 
                                                    (svref pV11997 2))))))) 
                                           (error 
                                            "Nonexhaustive match failure in substitute2")))))) 
                                   (if (eq (car |!M|) :|Bind|) 
                                       (let ((pV11996 (cdr |!M|))) 
                                         (return 
                                          (let ((pV11989 
                                                 (UTILITIES::substBoundVars 
                                                  (svref pV11996 1) 
                                                  sub 
                                                  freeNames))) 
                                            (block 
                                             nil 
                                             (return 
                                              (cons 
                                               :|Bind| 
                                               (vector 
                                                (svref pV11996 0) 
                                                (svref pV11989 0) 
                                                (UTILITIES::substitute2 
                                                 (svref pV11996 2) 
                                                 (svref pV11989 1) 
                                                 (svref pV11989 2)) 
                                                (svref pV11996 3)))) 
                                             (error 
                                              "Nonexhaustive match failure in substitute2"))))) 
                                       (if (eq (car |!M|) :|IfThenElse|) 
                                           (let ((pV11995 (cdr |!M|))) 
                                             (return 
                                              (cons 
                                               :|IfThenElse| 
                                               (vector 
                                                (|!subst| (svref pV11995 0)) 
                                                (|!subst| (svref pV11995 1)) 
                                                (|!subst| (svref pV11995 2)) 
                                                (svref pV11995 3))))) 
                                           (if (eq (car |!M|) :|Seq|) 
                                               (let ((pV11994 (cdr |!M|))) 
                                                 (return 
                                                  (cons 
                                                   :|Seq| 
                                                   (cons 
                                                    (LIST-SPEC::|!map|-1-1 
                                                     #'|!subst| 
                                                     (car pV11994)) 
                                                    (cdr pV11994))))))))))))))) 
       (error "Nonexhaustive match failure in substitute2")))) 
    (let ((M1 (|!subst| |!M|))) M1)))
                                     
(defun UTILITIES::|!substitute| (|!M| sub) 
  (if (LIST-SPEC::|!null| sub) 
      |!M| 
      (let ((freeNames 
             (LIST-SPEC::foldr-1-1-1 
              #'(lambda (x) 
                 (block 
                  nil 
                  (return 
                   (STRINGSET::|!union| 
                    (STRINGSET::fromList 
                     (LIST-SPEC::|!map|-1-1 
                      #'(lambda (x1) (car x1)) 
                      (UTILITIES::freeVars (cdr (car x))))) 
                    (cdr x))) 
                  (error "Nonexhaustive match failure in substitute"))) 
              STRINGSET::empty 
              sub))) (UTILITIES::substitute2 |!M| sub freeNames))))
                                                                   
(defun UTILITIES::|!substitute|-1 (x) 
  (UTILITIES::|!substitute| (car x) (cdr x)))
                                             
(defun UTILITIES::substitute2-1 (x) 
  (UTILITIES::substitute2 (svref x 0) (svref x 1) (svref x 2)))
                                                               
(defun UTILITIES::substituteType2 (srt |!S| freeNames) 
  (labels 
    ((|!subst| (s) 
      (block 
       nil 
       (if (eq (car s) :|Base|) 
           (let ((pV12058 (cdr s))) 
             (return 
              (cons 
               :|Base| 
               (vector 
                (svref pV12058 0) 
                (LIST-SPEC::|!map|-1-1 #'|!subst| (svref pV12058 1)) 
                (svref pV12058 2))))) 
           (if (eq (car s) :|Arrow|) 
               (let ((pV12057 (cdr s))) 
                 (return 
                  (cons 
                   :|Arrow| 
                   (vector 
                    (|!subst| (svref pV12057 0)) 
                    (|!subst| (svref pV12057 1)) 
                    (svref pV12057 2))))) 
               (if (eq (car s) :|Product|) 
                   (let ((pV12056 (cdr s))) 
                     (return 
                      (cons 
                       :|Product| 
                       (cons 
                        (LIST-SPEC::|!map|-1-1 
                         #'(lambda (x) (cons (car x) (|!subst| (cdr x)))) 
                         (car pV12056)) 
                        (cdr pV12056))))) 
                   (if (eq (car s) :|CoProduct|) 
                       (let ((pV12055 (cdr s))) 
                         (return 
                          (cons 
                           :|CoProduct| 
                           (cons 
                            (LIST-SPEC::|!map|-1-1 
                             #'(lambda (x) 
                                (cons 
                                 (car x) 
                                 (OPTION::mapOption-1-1 #'|!subst| (cdr x)))) 
                             (car pV12055)) 
                            (cdr pV12055))))) 
                       (if (eq (car s) :|Subsort|) 
                           (let ((pV12054 (cdr s))) 
                             (return 
                              (cons 
                               :|Subsort| 
                               (vector 
                                (|!subst| (svref pV12054 0)) 
                                (UTILITIES::substitute2 
                                 (svref pV12054 1) 
                                 |!S| 
                                 freeNames) 
                                (svref pV12054 2))))) 
                           (if (eq (car s) :|Quotient|) 
                               (let ((pV12053 (cdr s))) 
                                 (return 
                                  (cons 
                                   :|Quotient| 
                                   (vector 
                                    (|!subst| (svref pV12053 0)) 
                                    (UTILITIES::substitute2 
                                     (svref pV12053 1) 
                                     |!S| 
                                     freeNames) 
                                    (svref pV12053 2))))) 
                               (if (eq (car s) :|TyVar|) 
                                   (let ((pV12052 (cdr s))) 
                                     (return 
                                      (cons 
                                       :|TyVar| 
                                       (cons (car pV12052) (cdr pV12052)))))))))))) 
       (error "Nonexhaustive match failure in substituteType2")))) 
    (|!subst| srt)))
                    
(defun UTILITIES::substituteType (srt |!S|) 
  (let ((freeNames 
         (LIST-SPEC::foldr-1-1-1 
          #'(lambda (x) 
             (block 
              nil 
              (return 
               (STRINGSET::|!union| 
                (STRINGSET::fromList 
                 (LIST-SPEC::|!map|-1-1 
                  #'(lambda (x1) (car x1)) 
                  (UTILITIES::freeVars (cdr (car x))))) 
                (cdr x))) 
              (error "Nonexhaustive match failure in substituteType"))) 
          STRINGSET::empty 
          |!S|))) (UTILITIES::substituteType2 srt |!S| freeNames)))
                                                                   
(defun UTILITIES::substituteType-1 (x) 
  (UTILITIES::substituteType (car x) (cdr x)))
                                              
(defun UTILITIES::substituteType2-1 (x) 
  (UTILITIES::substituteType2 (svref x 0) (svref x 1) (svref x 2)))
                                                                   
(defun UTILITIES::unfoldPSort-1 (x) (UTILITIES::unfoldPSort (car x) (cdr x)))
                                                                             
(defun UTILITIES::unfoldPSortRec-1 (x) 
  (UTILITIES::unfoldPSortRec (svref x 0) (svref x 1) (svref x 2)))
                                                                  
(defun UTILITIES::unifyL-1 (x) 
  (UTILITIES::unifyL 
   (svref x 0) 
   (svref x 1) 
   (svref x 2) 
   (svref x 3) 
   (svref x 4) 
   (svref x 5)))
                
(defun UTILITIES::unifySorts-1 (x1) 
  #'(lambda (x2) #'(lambda (x3) (UTILITIES::unifySorts-1-1-1 x1 x2 x3))))
                                                                         
(defun UTILITIES::unifySorts (x0 x1 x2 x3 x4 x5 x6) 
  (UTILITIES::unifySorts-1 (vector x0 x1 x2 x3 x4 x5 x6)))
                                                          
(defun UTILITIES::unlinkMetaTyVar (tv) 
  (let ((x (STATE::|!!| tv))) 
    (let ((pV12222 (svref x 0))) 
      (block 
       nil 
       (if (eq (car pV12222) :|Some|) 
           (let ((pV12225 (cdr pV12222))) 
             (if (eq (car pV12225) :|MetaTyVar|) 
                 (return (UTILITIES::unlinkMetaTyVar (car (cdr pV12225))))))) 
       (return tv)))))
                      
(defun UTILITIES::unlinkRec (srt) 
  (METASLANG::mapSort-1-1 
   (vector 
    #'(lambda (x) x) 
    #'(lambda (s) (UTILITIES::unlinkPSort s)) 
    #'(lambda (x) x)) 
   srt))
        
(defun VERTEX::|!delete| (x) (POLYSET::|!delete| x))
                                                    
(defun VERTEX::|!delete|-1-1 (x0 x1) (POLYSET::|!delete|-1-1 x0 x1))
                                                                    
(defun VERTEX::empty? (x) (POLYSET::empty? x))
                                              
(defun VERTEX::fold (x) (POLYSET::fold x))
                                          
(defun VERTEX::insert (x) (POLYSET::insert x))
                                              
(defun VERTEX::|!map| (x) (POLYSET::|!map| x))
                                              
(defun VERTEX::|!map|-1-1 (x0 x1) (POLYSET::|!map|-1-1 x0 x1))
                                                              
(defun VERTEX::member? (x) (POLYSET::member? x))
                                                
(defun VERTEX::singleton (x) (POLYSET::singleton x))
                                                    
(defun VERTEX::toList (x) (POLYSET::toList x))
                                              
(defun VERTEX::|!union| (x) (POLYSET::|!union| x))
                                                  
(defun VERTEX::|!union|-1-1 (x0 x1) (POLYSET::|!union|-1-1 x0 x1))
                                                                  
(defun WADLERLINDIG::breakWith (s) (cons :|DocBreak| s))
                                                        
(defun WADLERLINDIG::ppAppend (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppAppend-1-1 x1 x2)))
                                                     
(defun WADLERLINDIG::ppBest (x1) 
  #'(lambda (x2) #'(lambda (x3) (WADLERLINDIG::ppBest-1-1-1 x1 x2 x3))))
                                                                        
(defun WADLERLINDIG::ppCons (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppCons-1-1 x1 x2)))
                                                   
(defun WADLERLINDIG::ppFits (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppFits-1-1 x1 x2)))
                                                   
(defun WADLERLINDIG::ppFormatWidth (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppFormatWidth-1-1 x1 x2)))
                                                          
(defun WADLERLINDIG::ppNest (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppNest-1-1 x1 x2)))
                                                   
(defun WADLERLINDIG::ppSep (x1) 
  #'(lambda (x2) (WADLERLINDIG::ppSep-1-1 x1 x2)))
                                                  