If we have
  sort List.List a
in the primitive types, then the typechecker complains.

Right now String.sw imports List. Perhaps it shouldn't.

There are many places in Nat and Integer where we must qualify
things where we shouldn't have to

In List.length we have to qualify + with "Nat." but the type of 
length should remove any ambiguity

Suppose List contains a reference to Lift but the latter doesn't exist.
.../Base/Lift resolves to Base.sw followed by #Lift decl but now Base.sw
loads List.sw which in turn causes things to go bad. Why is it trying
Base/Base .. because when it tries Base.sw, it doesn't have a correct
URI .. what is the URI for a file containing a collection of specs? Can
we load such a file or should we name all the objects?


Sketches imports mono maps unqualified.
functors imports poly maps qualified.
typechecking fails inside functors because it says the instantiation
of the type Poly.Maps (and Poly) aren't appropriate.
solution was to qualify the maps in Sketches.
