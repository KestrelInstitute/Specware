SPECWARE SHELL
==============


Core functionality
------------------

Specware and its shell constitute an automaton (i.e. state machine) that
processes commands by updating its internal state and producing responses:

 op swsh : State * Command -> State * Response

Besides the internal Specware state, the shell includes the following state
components:
- the `current directory', which is an (OS-dependent) path;
- the `current context', which is a spec-term;
- the `last processed unit', which is either a unit-term or absent;
- the `last evaluated expression', which is either an expression or absent.

These state components are initialized as follows:
- the current directory depends on how the shell is started (e.g. if started
  from an OS shell, the Specware shell inherits the current directory of the
  OS shell);
- the current context is the unit-identifier of the base library spec;
- the last processed unit is absent;
- the last evaluated expression is absent.

The following commands are featured (whose form is an extension of the
MetaSlang grammar):

 help
 cd [dir]
 dir
 dirr
 path [dirseq]
 proc [unit-term]
 show [unit-term]
 gen-lisp [spec-term [string-literal]]
 lgen-lisp [spec-term [string-literal]]
 punits [spec-term [string-literal]]
 lpunits [spec-term [string-literal]]
 clist
 cinit
 ctext [spec-term]
 eval [expression]
 eval-lisp [expression]
 exit

The commands have the following semantics:

* help

Prints a list of the shell commands with a short explanation for each.

* cd [dir]

Without an argument, displays the current directory.

With an argument, sets the current directory to the argument. The argument
`dir' is an (OS-dependent) directory, e.g. `c:\programs\specware\projects' for
Windows and `/usr/local/specware/projects' for Unix/Linux.

* dir

Displays the .sw files in the current directory.

* dirr

Displays the .sw files in the current directory and recursively in the
subdirectories of the current directory.

* path [dirseq]

Without an argument, displays the current Specware path.

With an argument, sets the Specware path to the argument. The argument
`dirseq' is an (OS-dependent) directory sequence,
e.g. `c:\programs\specware\libs;d:\home\sw' for Windows and
`/usr/local/specware/libs:/home/sw' for Unix/Linux.

* proc [unit-term]

Without an argument, processes the last processed unit. If the last processed
unit is absent, an error occurs.

With an argument, sets the last processed unit to the argument and processes
it.

* show [unit-term]

Like command `proc' but in addition displays the value of the processed
unit-term (whether it is given explicitly with the command or implicitly as
the last processed unit).

* gen-lisp [spec-term [string-literal]]

Without arguments, generates Lisp code from the last processed unit, provided
the last processed unit is a spec-term. If the last processed unit is absent
or is not a spec-term, an error occurs. It is essentially equivalent to `proc
generate lisp spec-term', where spec-term is the last processed unit, except
that the last processed unit is not set to `generate lisp spec-term'.

With one argument (spec-term), sets the last processed unit to spec-term and
generates Lisp code from it. It is essentially equivalent to `proc generate
lisp spec-term', except that the last processed unit is set to spec-term and
not to `generate lisp spec-term'.

With two arguments (spec-term and string-literal), sets the last processed
unit to spec-term and generates Lisp code from it, depositing the generated
Lisp code into the file whose path is the string-literal. It is essentially
equivalent to `proc generate lisp spec-term in string-literal', except that
the last processed unit is set to spec-term and not to `generate lisp
spec-term in string-literal'.

* lgen-lisp [spec-term [string-literal]]

Like command `gen-lisp' except that it only generates Lisp code for sorts and
ops locally declared in the spec-term. (Typically used for incremental
development.)

* punits [spec-term [string-literal]]

Without arguments, generates proof unit definitions for all conjectures in the
last processed unit, provided the last processed unit is a spec-term that is a
unit-identifier. The generated proof unit definitions are deposited into a
file <name>.sw in the current directory, where <name> is generated from the
unit-identifier.

With one argument (spec-term), generates proof unit definitions for all
conjectures in the last processed unit, provided the last processed unit is a
spec-term that is a unit-identifier. The generated proof unit definitions are
deposited into a file <name>.sw in the current directory, where <name> is
generated from the unit-identifier.

With two arguments (spec-term and string-literal), generates proof unit
definitions for all conjectures in spec-term and deposits the generated proof
unit definitions into the file whose path is the string-literal. Thus, the
string-literal should end in ".sw".

* lpunits [spec-term [string-literal]]

Like command `punits' except that it only generates proof unit definitions for
the conjectures locally present in the spec-term (e.g. not from imported
specs).

* clist

Displays the current Specware unit cache.

* cinit

Clears the Specware unit cache.

* ctext [spec-term]

Without an argument, displays the current context.

With an argument, sets the current context to the argument.

* eval [expression]

Without an argument, evaluates the last evaluated expression within the
current context and displays the result. If the last evaluated expression is
absent, an error occurs.

With an argument, sets the last evaluated expression to the argument,
evaluates it within the current context, and displays the result.

Evaluation takes place via the MetaSlang interpreter that is part of Specware.

* eval-lisp [expression]

Like command `eval', except that the expression is compiled to Lisp and then
evaluated in Lisp.

* exit

Terminates the shell.


User interface
--------------

The shell has a textual interface. Each command is entered at the prompt as a
single line of text (no multi-line commands). When the RETURN key is hit, the
command is "sent" to Specware for processing. While and after the command is
processed the response is displayed beneath the command, possibly on multiple
lines. So, commands are provided by the user and processed by the system one
at a time.

The shell includes a command history mechanism, which remembers the sequence
of commands since the shell was started. In other words, the shell includes a
state component consisting of a finite sequence of commands. Every command
entered by the user extends the sequence. There is no a priori limit on the
length of the sequence (aside from memory and disk size). The history is
discarded when the shell is terminated.

The commands in the history are accessed by two keystrokes `UP' and `DOWN'
(e.g. up/down arrows). UP moves to earlier commands in the history, while DOWN
moves to later commands. At an "empty" prompt, UP moves to the latest command
in the history, displaying it at the prompt. As history commands are displayed
at the prompt, they can be edited.

This interface is similar to typical OS shells.
