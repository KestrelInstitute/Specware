\section{Proof theory}
\label{proofth}

The proof theory of the \MS\ logic includes not only rules to derive formulas
(theorems), but also rules to derive typing and other judgements. The rules to
derive such judgements are mutually recursive; even though they are presented
separately in the following subsections, the rules are inductively defined all
together.

\subsection{Well-formed contexts}
\label{wfcx-rules}

We define a unary relation $\unarel{\cxwfY}{\Cx}$ to capture well-formed
contexts as

\[
\rruleO
 {\cxwf{\mtcx}}
 {\Rcxmt}
\]

\[
\rruleII
 {\cxwfO}
 {\tnam\not\in\cxtnam{\cx}}
 {\cxwf{\snoc{\cx}{\tdecO}}}
 {\Rcxtdec}
\]

\[
\rruleIII
 {\cxwfO}
 {\onam\not\in\cxonam{\cx}}
 {\isty{\snoc{\cx}{\tvdec{\tvarS}}}{\typ}}
 {\cxwf{\snoc{\cx}{\odecO}}}
 {\Rcxodec}
\]

\[
\rruleII
 {\cxwfO}
 {\hasty{\snoc{\cx}{\tvdec{\tvarS}}}{\expr}{\bool}}
 {\cxwf{\snoc{\cx}{\axO}}}
 {\Rcxax}
\]

\[
\rruleII
 {\cxwfO}
 {\tvar\not\in\cxtvar{\cx}}
 {\cxwf{\snoc{\cx}{\tvdecO}}}
 {\Rcxtvdec}
\]

\[
\rruleIII
 {\cxwfO}
 {\var\not\in\cxvar{\cx}}
 {\isty{\cx}{\typ}}
 {\cxwf{\snoc{\cx}{\vdecO}}}
 {\Rcxvdec}
\]

Eplanation:
\begin{itemize}
\item
The empty context $\mtcx$ is well-formed. All the other rules add context
elements to well-formed contexts. Thus, a well-formed context is constructed
incrementally starting with the empty one and adding elements.
\item
A type declaration $\tdecO$ can be added to $\cx$ if $\tnam$ is not already
declared in $\cx$.
\item
An op declaration $\odecO$ can be added to $\cx$ if $\onam$ is not already
declared in $\cx$. The op's type $\typ$ must be well-formed (defined later) in
$\cx$ extended with the type variables $\tvarS$, which must be distinct. Note
that we do not require that all the type variables in $\typ$ are among $\tvarS$,
because there is no need for that restriction.
\item
A formula $\expr$ can be added to $\cx$ as an axiom if $\expr$ has type $\bool$
(defined later). In general, the axiom may be polymorphic in (distinct) type
variables $\tvarS$.
\item
A type variable declaration $\tvdecO$ can be added to $\cx$ if $\tvar$ is not
already declared in $\cx$.
\item
A variable declaration $\vdecO$ can be added to $\cx$ if $\var$ is not already
declared in $\cx$ and $\typ$ is well-formed type in $\cx$.
\end{itemize}

\subsection{Well-formed types}

We define a binary relation $\binrel{\istyY}{\Cx}{\Typ}$ to capture well-formed
types as

\[
\rruleI
 {\cxwfO}
 {\istyO{\bool}}
 {\Rtbool}
\]

\[
\rruleII
 {\cxwfO}
 {\tvar\in\cxtvarO}
 {\istyO{\tvar}}
 {\Rtvar}
\]

\[
\rruleIV
 {\cxwfO}
 {\tdecO\in\cx}
 {\seqlen{\typS}=n}
 {\FORALL{i}{\istyO{\typ_i}}}
 {\istyO{\tinstO}}
 {\Rtinst}
\]

\[
\rruleI
 {\isty{\snoc{\cx}{\vdec{\var}{\typ_1}}}{\typ_2}}
 {\istyO{\tarrO}}
 {\Rtarr}
\]

\[
\rruleII
 {\cxwfO}
 {\FORALL{i}{\istyO{\typ_i}}}
 {\istyO{\trecO}}
 {\Rtrec}
\]

\[
\rruleII
 {\hastyO{\tspred}{\tarr{\typ}{\bool}}}
 {\efvar{\tspred}=\emptyset}
 {\istyO{\tsubO}}
 {\Rtsub}
\]

Explanation:
\begin{itemize}
\item
The type $\bool$ is well-formed in any well-formed context.
\item
A type variable is a well-formed type in any well-formed context that declares
it.
\item
A type instance $\tinstO$ is well-formed in any well-formed context $\cx$ that
declares $\tnam$ if the argument types are well-formed in $\cx$ and their number
matches the arity of $\tnam$.
\item
An arrow type $\tarrO$ is well-formed in a context $\cx$ if its domain type
$\typ_1$ is well-formed in $\cx$ and its range type $\typ_2$ is well-formed in
$\cx$ extended with a variable $\var$ of type $\typ_1$. The judgement
$\istyO{\typ_1}$ is not an explicit premise of the rule because, as proved
later, it is a consequence of the existing premise
$\isty{\snoc{\cx}{\vdec{\var}{\typ_1}}}{\typ_2}$. Allowing $\cx$ to be extended
with $\vdec{\var}{\typ_1}$ for the well-formedness of $\typ_2$ makes sense
because if $\typ_1$ is empty then $\tarrO$ contains just the empty function
(i.e.\ the function with empty domain) and the well-formedness of $\typ_2$ is
irrelevant.\footnote{The declaration $\vdec{\var}{\typ_1}$ enables the
derivation of the formula $\ex{\var}{\typ_1}{\true}$, which is not otherwise
derivable in general, because $\typ_1$ may be empty. Thus, $\typ_2$ may be
well-formed in $\snoc{\cx}{\vdec{\var}{\typ_1}}$ without necessarily being
well-formed in $\cx$. An example is a type $\typ_2$ that contains an expression
$\iif{(\ex{\var}{\typ_1}{\true})}{\expr_1}{\expr_2}$ where $\expr_2$ is not
well-typed in a consistent context because some theorem does not hold (e.g.\
that the divisor of a division is not 0); if $\ex{\var}{\typ_1}{\true}$ is a
theorem, then the context of the else branch is inconsistent (see rule \Reif\
later) and therefore $\expr_2$ is well-typed in that inconsistent context.} Even
though $\typ_2$ cannot contain $\var$ (because well-formed types have no free
variables), if \MS\ were extended with dependent arrow types\footnote{Such an
extension is indeed planned.} then $\typ_2$ would be allowed to contain $\var$
and the form of the rule would seem more natural than it does now. If we used a
more restrictive rule with premises $\istyO{\typ_1}$ and $\istyO{\typ_2}$, then
\thmref{thm-exty-wf} would not hold (see explanation near that theorem).
\item
The rule for record types is straightforward.
\item
For restriction types, we require the predicate to have type
$\tarr{\typ}{\bool}$, which implies that $\typ$ is a well-formed type (as proved
later). We also require that $\tspred$ has no free variables.
\end{itemize}

\subsection{Subtyping}

We define a quaternary relation $\quatrel{\issubY}{\Cx}{\Typ}{\Expr}{\Typ}$ to
capture subtyping as

\[
\rruleI
 {\istyO{\tsubO}}
 {\issubO{\tsubO}{\tspred}{\typ}}
 {\Rstsub}
\]

\[
\rruleII
 {\istyO{\typ}}
 {\tspred=\abs{\var}{\typ}{\true}}
 {\issubO{\typ}{\tspred}{\typ}}
 {\Rstrefl}
\]

\[
\rruleIII
 {\issub{\snoc{\cx}{\vdecO}}{\typ_1}{\tspred}{\typ_2}}
 {\var'\neq\var''}
 {\tspred'=\abs{\var'}
               {\tarr{\typ}{\typ_2}}
               {\fa{\var''}{\typ}{\app{\tspred}{(\app{\var'}{\var''})}}}}
 {\issubO{\tarr{\typ}{\typ_1}}{\tspred'}{\tarr{\typ}{\typ_2}}}
 {\Rstarr}
\]

\[
\rruleIV
 {\istyO{\trecO}}
 {\FORALL{i}{\issubO{\typ_i}{\tspred_i}{\typ_i'}}}
 {\funcinj{\perm}{\setFT{1}{n}}{\setFT{1}{n}}}
 {\tspred=\abs{\var}
              {\trec{i}{\fnam_{\perm(i)}}{\typ_{\perm(i)}'}}
              {\conjI{i}{\app{\tspred_i}{\proj{\var}{\fnam_i}}}}}
 {\issubO{\trecO}{\tspred}{\trec{i}{\fnam_{\perm(i)}}{\typ_{\perm(i)}'}}}
 {\Rstrec}
\]

Explanation:
\begin{itemize}
\item
Unsurprisingly, a restriction type $\tsubO$ is a subtype of $\typ$, with
$\tspred$ being the predicate over the supertype $\typ$ that identifies the
values that are also in the subtype $\tsubO$.
\item
Subtyping is reflexive, i.e.\ a (well-formed) type $\typ$ is a subtype of itself
and the associated subtype predicate is always true.
\item
Arrow types are monotonic in their range types with respect to subtyping. The
associated predicate holds when all the values of the function satisfy the
predicate associated to the range subtype. Note that the domain must be the
same; while domain contravariance is used in some type systems with subtypes, it
would violate extensionality (see explanation in \cite{pvs-seman}). The
extension of $\cx$ with $\vdecO$ mirrors rule \Rtarr: if $\typ$ is empty, then
both $\tarr{\typ}{\typ_1}$ and $\tarr{\typ}{\typ_2}$ contain just the empty
function and the former is trivially a subtype of the latter.
\item
Record types are monotonic in their component types with respect to
subtyping. The record subtype predicate holds when all the component subtype
predicates hold on the record components. The components can be re-ordered,
i.e.\ the order of record components is irrelevant. In the rule, the permutation
is captured by a bijective function $\perm$ on the field indices $\setFT{1}{n}$
(the rule explicitly says that $\perm$ is injective only, but since domain and
codomain are finite and equal, it follows that $\perm$ is also surjective, hence
bijective).
\end{itemize}

We do not need a transitivity rule for subtyping. As defined later, subtyping
judgements are only used to assign types to expressions, e.g.\ to assign a
supertype to an expression of a subtype. So, instead of using transitivity of
subtyping, rules for well-typed expressions can be applied multiple times,
achieving the same effect.

\subsection{Well-typed expressions}

We define a ternary relation $\ternrel{\hastyY}{\Cx}{\Expr}{\Typ}$ to capture
well-typed expressions as

\[
\rruleII
 {\cxwfO}
 {\vdecO\in\cx}
 {\hastyO{\var}{\typ}}
 {\Revar}
\]

\[
\rruleIII
 {\cxwfO}
 {\odecO\in\cx}
 {\FORALL{i}{\istyO{\typ_i}}}
 {\hastyO{\opO}{\tsbslash{\typ}{\tvarS}{\typS}}}
 {\Reop}
\]

\[
\rruleII
 {\hastyO{\expr_1}{\tarrO}}
 {\hastyO{\expr_2}{\typ_1}}
 {\hastyO{\appO}{\typ_2}}
 {\Reapp}
\]

\[
\rruleI
 {\hasty{\snoc{\cx}{\vdecO}}{\expr}{\typ'}}
 {\hastyO{\absO}{\tarr{\typ}{\typ'}}}
 {\Reabs}
\]

\[
\rruleII
 {\hastyO{\expr_1}{\typ}}
 {\hastyO{\expr_2}{\typ}}
 {\hastyO{\eqO}{\bool}}
 {\Reeq}
\]

\[
\rruleIV
 {\hastyO{\expr_0}{\bool}}
 {\hasty{\snoc{\cx}{\axM{\expr_0}}}{\expr_1}{\typ}}
 {\hasty{\snoc{\cx}{\axM{\nega{\expr_0}}}}{\expr_2}{\typ}}
 {\istyO{\typ}}
 {\hastyO{\iifO}{\typ}}
 {\Reif}
\]

\[
\rruleI
 {\istyO{\typ}}
 {\hastyO{\descopO}{\tarr{\tsub{(\tarr{\typ}{\bool})}{\exIopO}}{\typ}}}
 {\Redesc}
\]

\[
\rruleI
 {\istyO{\trecO}}
 {\hastyO{\pjopO}{\tarr{\trecO}{\typ_j}}}
 {\Reproj}
\]

\[
\rruleII
 {\hastyO{\expr}{\typ}}
 {\issubO{\typ}{\tspred}{\typ'}}
 {\hastyO{\expr}{\typ'}}
 {\Resuper}
\]

\[
\rruleIII
 {\hastyO{\expr}{\typ'}}
 {\issubO{\typ}{\tspred}{\typ'}}
 {\theoO{\app{\tspred}{\expr}}}
 {\hastyO{\expr}{\typ}}
 {\Resub}
\]

\[
\rruleII
 {\hastyO{\absO}{\typ'}}
 {\var'\not\in\efvar{\expr}\cup\cvarv{\expr}{\var}}
 {\hastyO{\abs{\var'}{\typ}{\esbs{\expr}{\var}{\var'}}}{\typ'}}
 {\Reabsalpha}
\]

Explanation:
\begin{itemize}
\item
A variable $\var$ declared in a well-formed context is a well-typed expression
with the type $\typ$ given in its declaration.
\item
An op $\onam$ declared in a well-formed context can be instantiated via
well-formed types $\typS$ whose number matches the number of type variables
$\tvarS$. The result is a well-formed expression whose type is obtained by
substituting $\tvarS$ with $\typS$ in the declared type $\typ$ of $\onam$.
\item
An application is well-typed if the function has an arrow type and the argument
has the domain type of the arrow type. The type of the application is the range
type of the arrow type.
\item
An abstraction is well-typed if the body is well-typed in the context extended
with the declaration of the variable bound by the abstraction. The type of the
abstraction is the arrow type that has the type of the variable as domain and
the type of the body as range.
\item
An equality is well-typed with type $\bool$ if the left- and right-hand sides
are both well-typed with a common type $\typ$.
\item
In the rule $\Reif$ for conditionals, the two branches must be well-typed, with
a common type, in the context where the condition holds and does not hold,
respectively. The additional assumption about the condition holding or not is
realized by adding an axiom to the context. The premise $\istyO{\typ}$ in \Reif\
may be redundant, i.e.\ derivable from the others, but this fact has not been
established yet and so for now we have it as an explicit premise, which is
needed to prove \thmref{thm-exty-wf}.
\item
The description operator for a well-formed type is well-typed and denotes a
function from the predicates over the type that are satisfied by a unique value
to the type itself.
\item
A projector for a well-formed record type is well-typed and denotes a function
from the record type to the corresponding component type.
\item
Rules $\Resuper$ and $\Resub$ link the notion of well-typed expressions to the
notion of subtyping. If an expression $\expr$ has a subtype $\typ$, it also has
any supertype $\typ'$. If an expression $\expr$ has a supertype $\typ'$, it also
has any subtype $\typ$ such that the associated predicate holds on $\expr$.
\item
The last rule amounts to treating expressions up to alpha equivalence, allowing
to rename bound variables maintaining well-typedness. Without this rule, the
\MS\ logic would be non-monotonic, because extending a context with variable
declarations may invalidate conclusions about the well-typedness of expressions
that bind those variables (e.g.\ if $\hastyO{\absO}{\typ'}$ were provable then
$\hasty{\snoc{\cx}{\vdecO}}{\absO}{\typ'}$ would not be provable).
\end{itemize}

\subsection{Theorems}

We define a binary relation $\binrel{\theoY}{\Cx}{\Expr}$ to capture theorems as

\[
\rruleIII
 {\cxwfO}
 {\axO\in\cx}
 {\FORALL{i}{\istyO{\typ_i}}}
 {\theoO{\tsbslash{\expr}{\tvarS}{\typS}}}
 {\Rthax}
\]

\[
\rruleI
 {\hastyOany{\expr}}
 {\theoO{\eq{\expr}{\expr}}}
 {\Rthrefl}
\]

\[
\rruleI
 {\theoO{\eq{\expr_1}{\expr_2}}}
 {\theoO{\eq{\expr_2}{\expr_1}}}
 {\Rthsymm}
\]

\[
\rruleII
 {\theoO{\eq{\expr_1}{\expr_2}}}
 {\theoO{\eq{\expr_2}{\expr_3}}}
 {\theoO{\eq{\expr_1}{\expr_3}}}
 {\Rthtrans}
\]

\[
\rruleIII
 {\hastyOany{\appO}}
 {\theoO{\eq{\expr_1}{\expr_1'}}}
 {\theoO{\eq{\expr_2}{\expr_2'}}}
 {\theoO{\eq{\appO}{\app{\expr_1'}{\expr_2'}}}}
 {\Rthappsbs}
\]

\[
\rruleIII
 {\hastyOany{\eqO}}
 {\theoO{\eq{\expr_1}{\expr_1'}}}
 {\theoO{\eq{\expr_2}{\expr_2'}}}
 {\theoO{\eq{(\eqO)}{(\eq{\expr_1'}{\expr_2'})}}}
 {\Rtheqsbs}
\]

\[
\rruleIV
 {\hastyOany{\iifO}}
 {\theo{\cx}{\eq{\expr_0}{\expr_0'}}}
 {\theo{\snoc{\cx}{\axM{\expr_0}}}{\eq{\expr_1}{\expr_1'}}}
 {\theo{\snoc{\cx}{\axM{\nega{\expr_0}}}}{\eq{\expr_2}{\expr_2'}}}
 {\theoO{\eq{\iifO}{\iif{\expr_0'}{\expr_1'}{\expr_2'}}}}
 {\Rthifsbs}
\]

\[
\rruleII
 {\theoO{\expr}}
 {\theoO{\eq{\expr}{\expr'}}}
 {\theoO{\expr'}}
 {\Rthsbs}
\]

\[
\rruleII
 {\cxwfO}
 {\var\neq\var'}
 {\theoO{\fa{\var}{\tarr{\bool}{\bool}}
            {(\iiff{\conj{\app{\var}{\true}}{\app{\var}{\false}}}
                   {(\fa{\var'}{\bool}{\app{\var}{\var'}})})}}}
 {\Rthbool}
\]

\[
\rruleII
 {\istyO{\tarr{\typ}{\typ'}}}
 {\var\neq\var'\AND\var'\neq\var''\AND\var''\neq\var}
 {\theoO{\faS{\seqII{\bnd{\var}{\tarr{\typ}{\typ'}}}
                    {\bnd{\var'}{\tarr{\typ}{\typ'}}}}
             {(\iiff{\eq{\var}{\var'}}
                    {(\fa{\var''}{\typ}
                         {\eq{\app{\var}{\var''}}
                             {\app{\var'}{\var''}}})})}}}
 {\Rthext}
\]

\[
\rruleII
 {\hastyOany{\app{(\absO)}{\expr'}}}
 {\esbsok{\expr}{\var}{\expr'}}
 {\theoO{\eq{\app{(\absO)}{\expr'}}{\esbs{\expr}{\var}{\expr'}}}}
 {\Rthabs}
\]

\[
\rruleIII
 {\hastyOany{\iifO}}
 {\theo{\snoc{\cx}{\axM{\expr_0}}}{\eq{\expr_1}{\expr}}}
 {\theo{\snoc{\cx}{\axM{\nega{\expr_0}}}}{\eq{\expr_2}{\expr}}}
 {\theoO{\eq{\iifO}{\expr}}}
 {\Rthif}
\]

\[
\rruleI
 {\hastyO{\app{\descopO}{\expr}}{\typ}}
 {\theoO{\app{\expr}{(\app{\descopO}{\expr})}}}
 {\Rthdesc}
\]

\[
\rruleII
 {\istyO{\trecO}}
 {\var\neq\var'}
 {\theoO
  {\faS{\seqII{\bnd{\var}{\trecO}}{\bnd{\var'}{\trecO}}}
       {(\impl{(\conjI{i}{\eq{\proj{\var}{\fnam_i}}{\proj{\var'}{\fnam_i}}})}
              {\eq{\var}{\var'}})}}}
 {\Rthrec}
\]

\[
\rruleI
 {\issubO{\trecO}{\tspred}{\trec{i}{\fnam_i}{\typ_i'}}}
 {\theoO{\fa{\var}{\trecO}
            {\eq{\app{\projopO}{\var}}
                {\app{\projop{\trec{i}{\fnam_i}{\typ_i'}}{\fnam_j}}{\var}}}}}
 {\Rthprojsub}
\]

\[
\rruleII
 {\issubO{\typ}{\tspred}{\typ'}}
 {\hastyO{\expr}{\typ}}
 {\theoO{\app{\tspred}{\expr}}}
 {\Rthsub}
\]

Explanation:
\begin{itemize}
\item
Axioms in a well-formed context are readily instantiated into theorems, via rule
$\Rthax$. More precisely, the type variables over which the axiom is polymorphic
are replaced with well-formed types.
\item
Rules \Rthrefl, \Rthsymm, and \Rthtrans\ say that equality is an equivalence,
i.e.\ reflexive, symmetric, and transitive.
\item
Rules \Rthappsbs, \Rtheqsbs, and \Rthifsbs\ state the substitutivity of
equalities in expressions. Note that in rule $\Rthifsbs$ the context is extended
with an axiom saying that the condition is true or false.
\item
Rule \Rthsbs\ says that anything equal to a theorem is itself a theorem.
\item
Rule \Rthbool\ asserts that $\true$ and $\false$ are the only values of type
$\bool$.
\item
Rule \Rthext\ says that a function is characterized by its values over all the
values of its domain, i.e.\ by extensionality.
\item
Rule \Rthabs\ defines the semantics of lambda abstraction: the bound variable
$\var$ is replaced with the argument $\expr'$ in the body $\expr$. The premise
of the rule says that the application is well-typed.
\item
Rule \Rthif\ defines the semantics of conditionals: a conditional equals an
expression if both branches do, in the contexts extended with the assumption
that the condition is true and false, respectively. Note the premise that
requires the conditional to be well-typed.
\item
Rule \Rthdesc\ says that a description satisfies the predicate associated to the
description.
\item
Rule \Rthrec\ says that a record is characterized by the values of its
components.
\item
Rule \Rthprojsub\ says that projectors for record subtypes agree with projectors
for record supertypes.
\item
Rule \Rthsub\ says that every value of a subtype satisfies the predicate that
characterizes the subtype with respect to a supertype.
\end{itemize}

\subsection{Proofs}

The previous subsections have defined judgements of the forms
\[
\begin{array}{l}
\cxwfO \\
\istyO{\typ} \\
\issubO{\typ_1}{\tspred}{\typ_2} \\
\hastyO{\expr}{\typ} \\
\theoO{\expr}
\end{array}
\]
by means of a set of inductive rules.

A proof of a judgement is a finite sequence of judgements that ends with the
proved judgement and where each judgement in the sequence is derived from
preceding judgements using some rule.

\

\noindent
[[[TO DO: Make sure that the rules for theorems are ``sufficient'', i.e.\ all
truths ``of interest'' are indeed theorems derivable from the rules. Even though
higher-order logic is notoriously incomplete, in practice theorem provers like
PVS and HOL are sufficient to prove desired properties of formalized concepts
without running into theoretical limitations. Perhaps the requirement boils down
to prove completeness with respect to so-called ``general models'' (cf.\
\cite{andrews}).]]]
