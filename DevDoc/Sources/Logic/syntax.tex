\section{Syntax}
\label{syntax}

\subsection{Names}

We postulate the existence of an infinite set of names
\[
\Nam
\]

\subsection{Types}

We inductively define the set of types as
\[
\setdefVI
 {\Typ}
 {+}
 {\setI{\bool}}
 {\setST{\tvar}{\tvar\in\Nam}}
 {\setST{\tinstO}{\tnam\in\Nam\AND\typS\in\Seq{\Typ}}}
 {\setST{\tarr{\typ_1}{\typ_2}}{\typ_1,\typ_2\in\Typ}}
 {\setST{\trecFTO}{\fnamS\in\SeqNR{\Nam}\AND\typS\in\Seq{\Typ}}}
 {\setST{\tsubO}{\typ\in\Typ\AND\tspred\in\Expr}}
\]
where $\Expr$ is defined later.\footnote{Types depend on expressions, which
depend on types. Thus, types and expressions are inductively defined together,
not separately. Their definitions are presented separately only for
readability.}

Explanation:
\begin{itemize}
\item
There is a type $\bool$ for boolean (i.e.\ truth) values.
\item
A name $\tvar$ is a type variable.
\item
A type instance $\tinstO$ is obtained by combining a type name $\tnam$ with zero
or more argument types $\typS$. We may write $\tinst{\tnam}{\seqO}$ as just
$\tnam$.
\item
An arrow type $\tarrO$ consists of a domain $\typ_1$ and a range $\typ_2$.
\item
A record type $\trecO$ consists of typed fields $\fnam_i$. There is one record
type that has no fields (i.e.\ $n=0$), denoted $\trecmt$, whose only inhabitant
is the empty record. All the fields of a record type are distinct names.
\item
A restriction type $\tsubO$ is obtained by combining a type $\typ$ with an
expression $\tspred$ (meant to be a predicate on $\typ$). Restriction types
create the dependency of types on expressions.
\end{itemize}

\subsection{Expressions}

We inductively define the set of expressions as
\[
\setdefVIIIoI
 {\Expr}
 {+}
 {\setST{\var}{\var\in\Nam}}
 {\setST{\opO}{\onam\in\Nam\AND\typS\in\Seq{\Typ}}}
 {\setST{\appO}{\expr_1,\expr_2\in\Expr}}
 {\setST{\absO}{\var\in\Nam\AND\typ\in\Typ\AND\expr\in\Expr}}
 {\setST{\eqO}{\expr_1,\expr_2\in\Expr}}
 {\setST{\iifO}{\expr_0,\expr_1,\expr_2\in\Expr}}
 {\setST{\descopO}{\typ\in\Typ}}
\setdefVIIIoII
 {+}
 {\setST{\projopO}{\trecO\in\Typ}}
\]

Explanation:
\begin{itemize}
\item
A name $\var$ is a variable.
\item
An op(eration) instance $\opO$ consists of an op name $\onam$ and zero or more
types $\typS$ that instantiate the (generally, polymorphic) type of the op. We
may write $\op{\onam}{\seqO}$ as just $\onam$.
\item
An application $\appO$ consists of a function $\expr_1$ juxtaposed to an
argument $\expr_2$.
\item
A (lambda) abstraction $\absO$ consists of an argument $\var$ with an explicit
type $\typ$ and a body $\expr$.
\item
An equality $\eqO$ consists of a left-hand side $\expr_1$ and a right-hand side
$\expr_2$.
\item
A conditional $\iifO$ consists of a condition $\expr_0$, a ``then'' branch
$\expr_1$, and an ``else'' branch $\expr_2$.
\item
The description operator $\descopO$ is tagged by a type. It operates on
predicates over $\typ$ (i.e.\ over values of type $\tarr{\typ}{\bool}$) that are
satisfied by a unique value of $\typ$, and its result is \emph{the} value that
satisfies the predicate.
\item
A projector $\projopO$ is tagged by a record type and by a field of that record
type. We may write $\projopO$ as just $\pjopO$ when the record type is
inferrable or irrelevant.
\end{itemize}

We introduce the abbreviations
\[
\begin{abblist}
\abbitem{\true}
        {\eq{\abs{\varfx}{\bool}{\varfx}}{\abs{\varfx}{\bool}{\varfx}}}
\abbitem{\false}
        {\eq{\abs{\varfx}{\bool}{\varfx}}{\abs{\varfx}{\bool}{\true}}}
\abbitem{\negaop}
        {\abs{\varfx}{\bool}{(\eq{\varfx}{\false})}}
\abbitem{\conjO}
        {\iif{\expr_1}{\expr_2}{\false}}
\abbitem{\disjO}
        {\iif{\expr_1}{\true}{\expr_2}}
\abbitem{\implO}
        {\iif{\expr_1}{\expr_2}{\true}}
\abbitem{\iiffop}
        {\abs{\varfx}{\bool}{\abs{\varfx'}{\bool}{(\eq{\varfx}{\varfx'})}}}
\abbitem{\iiffO}
        {\app{\app{\iiffop}{\expr_1}}{\expr_2}}
\abbitem{\neeqO}
        {\nega{(\eqO)}}
\abbitem{\descO}
        {\app{\descopO}{(\absO)}}
\abbitem{\faopO}
        {\abs{\varfxpred}{\tarr{\typ}{\bool}}
             {(\eq{\varfxpred}{\abs{\varfx}{\typ}{\true}})}}
\abbitem{\faO}
        {\app{\faopO}{(\absO)}}
\abbitem{\faS{\seqFT{\bnd{\var_1}{\typ_1}}{\bnd{\var_n}{\typ_n}}}{\expr}}
        {\fa{\var_1}{\typ_1}{\ldots\fa{\var_n}{\typ_n}{\expr}}}
\abbitem{\fa{\varS}{\typS}{\expr}}
        {\faS{\seqFT{\bnd{\var_1}{\typ_1}}{\bnd{\var_n}{\typ_n}}}{\expr}}
\abbitem{\exopO}
        {\abs{\varfxpred}{\tarr{\typ}{\bool}}
             {\nega{(\fa{\varfx}{\typ}{\nega{(\app{\varfxpred}{\varfx})}})}}}
\abbitem{\exO}
        {\app{\exopO}{(\absO)}}
\abbitem{\exS{\seqFT{\bnd{\var_1}{\typ_1}}{\bnd{\var_n}{\typ_n}}}{\expr}}
        {\ex{\var_1}{\typ_1}{\ldots\ex{\var_n}{\typ_n}{\expr}}}
\abbitem{\ex{\varS}{\typS}{\expr}}
        {\exS{\seqFT{\bnd{\var_1}{\typ_1}}{\bnd{\var_n}{\typ_n}}}{\expr}}
\abbitem{\exIopO}
        {\abs{\varfxpred}{\tarr{\typ}{\bool}}
             {(\ex{\varfx}{\typ}
                  {(\conj{\app{\varfxpred}{\varfx}}
                         {\fa{\varfx'}{\typ}
                             {(\impl{\app{\varfxpred}{\varfx'}}
                                    {\eq{\varfx'}{\varfx}})}})})}}
\abbitem{\exIO}
        {\app{\exIopO}{(\absO)}}
\abbitem{\projO}
        {\app{\pjop{\fnam}}{\expr}}
\end{abblist}
\]
where $\varfx$, $\varfx'$, and $\varfxpred$ are fixed but unspecified names in
$\Nam$ that are all distinct.

Explanation:
\begin{itemize}
\item
The abbreviations $\true$ and $\false$ stand for logical truth and falsehood,
respectively.
\item
Negation is defined as equality with $\false$.
\item
The logical connectives for conjunction, disjunction, and implication are
defined in terms of conditionals.
\item
Coimplication is a synonym for equality, but only for booleans.
\item
Inequality is negation of equality.
\item
Stand-alone quantifiers are higher-order functions, but they can be written in
binder form. Also the description operator can be written in binder form. Note
that both $\faS{\seqO}{\expr}$ and $\exS{\seqO}{\expr}$ stand for $\expr$.
\item
A dotted projection $\projO$ abbreviates an applied projection whose record type
is left implicit.
\end{itemize}

The function $\func{\efvarY}{\Expr}{\Setf{\Nam}}$ returns the free variables of
an expression
\[
\begin{eqlist}
\eqitem{\efvar{\var}}        {\setI{\var}}
\eqitem{\efvar{\opO}}        {\emptyset}
\eqitem{\efvar{\appO}}       {\efvar{\expr_1}\cup\efvar{\expr_2}}
\eqitem{\efvar{\absO}}       {\efvar{\expr}-\setI{\var}}
\eqitem{\efvar{\eqO}}        {\efvar{\expr_1}\cup\efvar{\expr_2}}
\eqitem{\efvar{\iifO}}       {\efvar{\expr_0}\cup
                              \efvar{\expr_1}\cup\efvar{\expr_2}}
\eqitem{\efvar{\descopO}}    {\emptyset}
\eqitem{\efvar{\pjop{\fnam}}}{\emptyset}
\end{eqlist}
\]
Note that we do not consider the free variables in expressions contained in
types contained in expressions (e.g.\ we do not consider the free variables in
$\tspred$ as part of the free variables of $\op{\onam}{\tsubO}$). The reason is
that, as will be apparent later, all the expressions contained in well-formed
types have no free variables.

\subsection{Contexts}

We define the set of context elements as
\[
\setdefV
 {\Cxel}
 {+}
 {\setST{\tdecO}{\tnam\in\Nam\AND n\in\N}}
 {\setST{\tvdecO}{\tvar\in\Nam}}
 {\setST{\odecO}{\onam\in\Nam\AND\tvarS\in\SeqNR{\Nam}\AND\typ\in\Typ}}
 {\setST{\vdecO}{\var\in\Nam\AND\typ\in\Typ}}
 {\setST{\axO}{\tvarS\in\SeqNR{\Nam}\AND\expr\in\Expr}}
\]

Explanation:
\begin{itemize}
\item
A type declaration $\tdecO$ introduces a type name with an associated arity.
\item
A type variable declaration $\tvdecO$ introduces a type variable. We may write
$\seqFT{\tvdec{\tvar_1}}{\tvdec{\tvar_n}}$ as just
$\tvdec{\seqFT{\tvar_1}{\tvar_n}}$.
\item
An op(eration) declaration $\odecO$ introduces an op name with an associated
type, polymorphic in the explicit type variables.
\item
A variable declaration $\vdecO$ introduces a variable with a type.
\item
An axiom $\axO$ introduces an expression (with type $\bool$, as defined later),
polymorphic in the explicit type variables. We may write $\ax{\seqO}{\expr}$ as
just $\axM{\expr}$.
\end{itemize}

We define the set of contexts as
\[
\Cx = \Seq{\Cxel}
\]
In other words, a context is a finite sequence of context elements.

The function $\func{\cxtnamY}{\Cx}{\Setf{\Nam}}$ returns the type names declared
in a context
\[
\begin{eqlist}
\eqitem{\cxtnam{\mtcx}}
       {\emptyset}
\eqitem{\cxtnam{\cons{\cxel}{\cx}}}
       {\cond{\cxel=\tdecO}
             {\cxtnam{\cx}\cup\setI{\tnam}}
             {\cxtnam{\cx}}}
\end{eqlist}
\]

The function $\func{\cxtvarY}{\Cx}{\Setf{\Nam}}$ returns the type variables
declared in a context
\[
\begin{eqlist}
\eqitem{\cxtvar{\mtcx}}
       {\emptyset}
\eqitem{\cxtvar{\cons{\cxel}{\cx}}}
       {\cond{\cxel=\tvdecO}
             {\cxtvar{\cx}\cup\setI{\tvar}}
             {\cxtvar{\cx}}}
\end{eqlist}
\]

The function $\func{\cxonamY}{\Cx}{\Setf{\Nam}}$ returns the op names declared
in a context
\[
\begin{eqlist}
\eqitem{\cxonam{\mtcx}}
       {\emptyset}
\eqitem{\cxonam{\cons{\cxel}{\cx}}}
       {\cond{\cxel=\odecO}
             {\cxonam{\cx}\cup\setI{\onam}}
             {\cxonam{\cx}}}
\end{eqlist}
\]

The function $\func{\cxvarY}{\Cx}{\Setf{\Nam}}$ returns the variables declared
in a context
\[
\begin{eqlist}
\eqitem{\cxvar{\mtcx}}
       {\emptyset}
\eqitem{\cxvar{\cons{\cxel}{\cx}}}
       {\cond{\cxel=\vdecO}
             {\cxvar{\cx}\cup\setI{\var}}
             {\cxvar{\cx}}}
\end{eqlist}
\]

\subsection{Substitutions}

\subsubsection{Type substitutions}

The function $\func{\tsbsY}{(\Typ+\Expr)\times(\Funcp{\Nam}{\Typ})}{\Typ+\Expr}$
substitutes each type variable $\tvar\in\dom{\tsbsmap}$, where
$\funcp{\tsbsmap}{\Nam}{\Typ}$, with the type $\tsbsmap(\tvar)$ in a type or
expression $x$ (written $\tsbsO{x}$)
\[
\begin{eqlistC}
\eqitem{\tsbsO{\bool}}
       {\bool}
\eqitem{\tsbsO{\tvar}}
       {\cond{\tvar\in\dom{\tsbsmap}}{\tsbsmap(\tvar)}{\tvar}}
\eqitem{\tsbsO{\tinstO}}
       {\tinst{\tnam}{\tsbsO{\typS}}}
\eqitem{\tsbsO{(\tarrO)}}
       {\tarr{\tsbsO{\typ_1}}{\tsbsO{\typ_2}}}
\eqitem{\tsbsO{(\trecO)}}
       {\trec{i}{\fnam_i}{\tsbsO{\typ_i}}}
\eqitem{\tsbsO{(\tsubO)}}
       {\tsub{\tsbsO{\typ}}{\tsbsO{\tspred}}}
\end{eqlistC}
\]
\[
\begin{eqlistC}
\eqitem{\tsbsO{\var}}
       {\var}
\eqitem{\tsbsO{\opO}}
       {\op{\onam}{\tsbsO{\typS}}}
\eqitem{\tsbsO{(\appO)}}
       {\app{\tsbsO{\expr_1}}{\tsbsO{\expr_2}}}
\eqitem{\tsbsO{(\absO)}}
       {\abs{\var}{\tsbsO{\typ}}{\tsbsO{\expr}}}
\eqitem{\tsbsO{(\eqO)}}
       {\eq{\tsbsO{\expr_1}}{\tsbsO{\expr_2}}}
\eqitem{\tsbsO{(\iifO)}}
       {\iif{\tsbsO{\expr_0}}{\tsbsO{\expr_1}}{\tsbsO{\expr_2}}}
\eqitem{\tsbsO{\descopO}}
       {\descop{\tsbsO{\typ}}}
\eqitem{\tsbsO{\left(\projopO\right)}}
       {\projop{\tsbsO{\left(\trecO\right)}}{\fnam_j}}
\end{eqlistC}
\]
where of course
$\tsbsO{(\seqFT{\typ_1}{\typ_n})}=\seqFT{\tsbsO{\typ_1}}{\tsbsO{\typ_n}}$. Given
$\tvarS\in\SeqNR{\Nam}$ and $\typS\in\Seq{\Typ}$ such that
$\seqlen{\tvarS}=\seqlen{\typS}$, we may write
$\tsbs{\typ}{\setST{\tupII{\tvar_i}{\typ_i}}{1\leq i\leq n}}$ as just
$\tsbslash{\typ}{\tvarS}{\typS}$.

\subsubsection{Expression substitutions}

The function $\func{\esbsY}{\Expr\times\Nam\times\Expr}{\Expr}$ substitutes a
variable $\varI$ with an expression $\exprI$ in an expression $\expr$ (written
$\esbsO{\expr}$)
\[
\begin{eqlistC}
\eqitem{\esbsO{\var}}
       {\cond{\varI=\var}{\exprI}{\var}}
\eqitem{\esbsO{\opO}}
       {\opO}
\eqitem{\esbsO{(\appO)}}
       {\app{\esbsO{\expr_1}}{\esbsO{\expr_2}}}
\eqitem{\esbsO{(\absO)}}
       {\cond{\varI=\var}{\absO}{\abs{\var}{\typ}{\esbsO{\expr}}}}
\eqitem{\esbsO{(\eqO)}}
       {\eq{\esbsO{\expr_1}}{\esbsO{\expr_2}}}
\eqitem{\esbsO{(\iifO)}}
       {\iif{\esbsO{\expr_0}}{\esbsO{\expr_1}}{\esbsO{\expr_2}}}
\eqitem{\esbsO{\descopO}}
       {\descopO}
\eqitem{\esbsO{(\pjop{\fnam})}}
       {\pjop{\fnam}}
\end{eqlistC}
\]
No substitution is performed in the expressions contained in types contained in
expressions because, as already mentioned, such inner expressions have no free
variables in well-formed types.

The function $\func{\cvarvY}{\Expr\times\Nam}{\Setf{\Nam}}$ returns the
variables that would be captured if a variable $\varI$ were substituted with
those variables in an expression $\expr$ (i.e.\ all the variables bound in
$\expr$ at the free occurrences of $\varI$ in $\expr$)
\[
\begin{eqlist}
\eqitem{\cvarvO{\var}}
       {\emptyset}
\eqitem{\cvarvO{\opO}}
       {\emptyset}
\eqitem{\cvarvO{\appO}}
       {\cvarvO{\expr_1}\cup\cvarvO{\expr_2}}
\eqitem{\cvarvO{\absO}}
       {\cond{\varI\in\efvar{\expr}-\setI{\var}}
             {\setI{\var}\cup\cvarvO{\expr}}
             {\emptyset}}
\eqitem{\cvarvO{\eqO}}
       {\cvarvO{\expr_1}\cup\cvarvO{\expr_2}}
\eqitem{\cvarvO{\iifO}}
       {\cvarvO{\expr_0}\cup\cvarvO{\expr_1}\cup\cvarvO{\expr_2}}
\eqitem{\cvarvO{\descopO}}
       {\emptyset}
\eqitem{\cvarvO{\pjop{\fnam}}}
       {\emptyset}
\end{eqlist}
\]
If we view an expression $\expr$ as a tree, each free occurrence of $\varI$ in
$\expr$ is reachable via a path in the tree that starts from the root. That path
contains zero or more lambda binders, each with its own variable. Then
$\cvarvO{\expr}$ is the set of all lambda-bound variables along all paths of all
free occurrences of $\varI$ in $\expr$.

The relation $\ternrel{\esbsokY}{\Expr}{\Nam}{\Expr}$ captures the condition
that the substitution $\esbsO{\expr}$ causes no free variables in $\exprI$ to be
captured
\[
\esbsok{\expr}{\varI}{\exprI}\IFF\efvar{\exprI}\cap\cvarvO{\expr}=\emptyset
\]
