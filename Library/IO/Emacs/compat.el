(defvar lisp-emacs-interface-type 'franz)

(when (or (eq lisp-emacs-interface-type 'franz))
  (define-function 'switch-to-lisp 'fi:toggle-to-lisp)
  (define-function 'extract-sexp 'fi:extract-list)
  (define-function 'sw:eval-in-lisp 'fi:eval-in-lisp)
  (define-function 'inferior-lisp-newline 'fi:inferior-lisp-newline)
  (define-function 'inferior-lisp-running-p 'fi::lep-open-connection-p)
  (defvar *specware-buffer-name* fi:common-lisp-buffer-name)
  (when (and (boundp 'fi:lisp-mode-syntax-table)
	     fi:lisp-mode-syntax-table)
    (modify-syntax-entry ?. "." fi:lisp-mode-syntax-table)))

(when (eq lisp-emacs-interface-type 'ilisp)
  (defun extract-sexp ()
    "Delete the S-expression containing the S-expression that starts at point
              and replace it with the S-expression that starts at the point."
    (interactive)
    (let ((start (point))
	  (end nil)
	  (mine nil))
      (forward-sexp 1)
      (setq end (point))
      (setq mine (buffer-substring start end))
      (up-list -1)
      (setq start (point))
      (forward-sexp 1)
      (delete-region start (point))
      (insert mine)
      (backward-sexp)))
  (defun sw:eval-in-lisp (&rest args)
    (ilisp-send (apply 'format args) nil nil 'dispatch))
  (define-function 'inferior-lisp-newline 'return-ilisp)
  (defvar *specware-buffer-name* "*lispworks*")
  (defun inferior-lisp-running-p ()
    (with-current-buffer *specware-buffer-name*
      (not (equal comint-status " :exit")))))

