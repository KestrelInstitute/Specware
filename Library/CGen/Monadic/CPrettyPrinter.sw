PP qualifying spec

import C


(* We define an executable pretty printer for programs in our C subset. The
pretty printer turns the formalized abstract syntax into concrete syntax. The
concrete syntax is described in [ISO].

The pretty printer may be improved in the future as needed.

We model the pretty-printed text as a string. The new-line characters mark the
lines of the text. Specware strings have no preset limit, conceptually. In
practice, Specware may run out of memory when processing excessively long
strings. Lisp does not have any preset limit on strings either; in practice, if
Lisp code is generated for this pretty printer, the Lisp runtime may run out of
memory if the generated strings is excessively long. A similar observation
applies to Haskell, C, and Java (these, together with Lisp, are all the
languages that can be generated by Specware). Given the memory size of modern
computers, the odds of Specware or Lisp or Haskell or C or Java running out of
memory due to an excessively long string are sufficiently low that we do not
impose any maximum length requirements on a string that represents
pretty-printed text. *)

type Text = String

(* Given the above definition, the empty text is just the empty string. *)

op emptyText : Text = ""

(* We introduce a state monad whose state consists of the text printed so far,
the current level of indentation (0, 1, 2, ..., where 0 means no indentation,
i.e. at the left marging), and the size of each indentation level (measured in
number of space characters). We use spaces to indent text, not tabs because they
are not "portable". The size of the indentation is immutable throughout the
printing, but it is convenient to make it part of the state so it can be
supplied as a parameter to the pretty printer top-level op and after that it
needs not be passed to the other pretty-printing ops.

We define an op to initialize the state given an identation size. The text is
empty, the indentation level 0, and the indentation size is the one supplied as
argument.

The definition of the bind operator is standard for a state monad. The use of
the name 'monadBind' enables the use of Metaslang's monadic syntax. *)

type State =
  {text        : Text,
   indentLevel : Nat,
   indentSize  : Nat}

op initState (indSize:Nat) : State =
  {text        = emptyText,
   indentLevel = 0,
   indentSize  = indSize}

type PP a = State -> State * a

op [a,b] monadBind (m:PP a, f: a -> PP b) : PP b =
  fn st:State -> let (st', x) = m st in f x st'

(* We introduce an abbreviation for PP (), which is used a lot below, by ops
that only side-effect the state without returning a value. *)

type PP0 = PP ()

(* The "run" combinator for the PP monad, which converts a PP0 to a string *)
op runPP0 (pp : PP0) : Text =
  (pp (initState 2)).1.text


(* The following op extends the text printed so far with a new piece of text,
which is appended to the text. If string concatenation is linear in the length
of the first string, the performance may degrade too much as the text grows
larger. But we will worry about that only after we found that to be an actual
problem, following the old adage "avoid premature optimization". *)

op print (s:String) : PP0 =
  fn st:State -> (st << {text = st.text ^ s}, ())

(* The following ops increase and decrease the indentation level, i.e. they move
the start of the non-blank text "in" and "out". If the level is 0, decreasing it
has no effect. Maybe in the future we should extend the monad to also be an
exception monad, and raise an exception when attempting to decrease indentation
level 0 -- this would ease debugging. *)

op indentIn : PP0 =
  fn st:State -> (st << {indentLevel = st.indentLevel + 1}, ())

op indentOut : PP0 =
  fn st:State -> (st << {indentLevel = if st.indentLevel = 0 then 0
                                       else st.indentLevel - 1},
                  ())

(* The following ops return the indentation level and size from the state. *)

op indentationLevel : PP Nat =
  fn st:State -> (st, st.indentLevel)

op indentationSize : PP Nat =
  fn st:State -> (st, st.indentSize)

(* We introduce an abbreviation for printing nothing. *)

op printNothing : PP0 =
  print ""

(* The following ops print white space. *)

op printSpace : PP0 =
  print " "

op printSpaces (n:Nat) : PP0 =
  if n = 0 then printNothing
  else {printSpace; printSpaces (n - 1)}

op printNewline : PP0 =
  print newline

(* When starting a line, we must print spaces corresponding to the indentation
level. Note that in the degenerate case of 0 as indentation size, no spaces are
printed, regardless of the indentation level. *)

op startLine : PP0 =
  {lev <- indentationLevel;
   siz <- indentationSize;
   printSpaces (lev * siz)}

(* Since identifiers and constants are strings (satisfying certain conditions),
printing them is straightforward. *)

op printIdentifier (id:Identifier) : PP0 =
  print id

op printConstant (c:IntegerConstant) : PP0 =
  print (intToString (integerConstantValue c))

(* Unary and binary operators are printed by printing their corresponding
symbols. *)

op printUnaryOp (uop:UnaryOp) : PP0 =
  case uop of
  | UOp_ADDR  -> print "&"
  | UOp_STAR  -> print "*"
  | UOp_PLUS  -> print "+"
  | UOp_MINUS -> print "-"
  | UOp_NOT   -> print "~"
  | UOp_NEG   -> print "!"

op printBinaryOp (bop:BinaryOp) : PP0 =
  case bop of
  | BinOp_MUL  -> print "*"
  | BinOp_DIV  -> print "/"
  | BinOp_REM  -> print "%"
  | BinOp_ADD  -> print "+"
  | BinOp_SUB  -> print "-"
  | BinOp_SHL  -> print "<<"
  | BinOp_SHR  -> print ">>"
  | BinOp_LT   -> print "<"
  | BinOp_GT   -> print ">"
  | BinOp_LE   -> print "<="
  | BinOp_GE   -> print ">="
  | BinOp_EQ   -> print "=="
  | BinOp_NE   -> print "!="
  | BinOp_AND  -> print "&"
  | BinOp_XOR  -> print "^"
  | BinOp_IOR  -> print "|"
  | BinOp_LAND -> print "&&"
  | BinOp_LOR  -> print "||"

(* In order to minimize the number of parenthesized expressions generated by the
pretty printer, we follow the grammar of expressions in [ISO 6.5], which, as
stated in [ISO 6.5/3], indicates the grouping of operators and operands.

We start by defining an enumeration whose elements correspond to the kinds of
expressions in the grammar in [ISO 6.5]. We only have elements for the kinds of
expressions that are part of our C subset. Thus, we do not have any element for
assignment expressions [ISO 6.5.16], because in our C subset we regard
assignments as statements. Even though our C subset does not feature cast
expressions [ISO 6.5.4] in general, as explained in our C formalization the null
constant is regarded as a cast of 0 to 'void*'. Thus, we do have a (restricted)
kind of cast expressions. *)

type ExpressionKind =
  | EXPR   % top-level      expressions [ISO 6.5.17]
  | COND   % conditional    expressions [ISO 6.5.15]
  | LOR    % logical OR     expressions [ISO 6.5.14]
  | LAND   % logical AND    expressions [ISO 6.5.13]
  | IOR    % inclusive OR   expressions [ISO 6.5.12]
  | XOR    % exclusive OR   expressions [ISO 6.5.11]
  | AND    % AND            expressions [ISO 6.5.10]
  | EQ     % equality       expressions [ISO 6.5.9]
  | REL    % relational     expressions [ISO 6.5.8]
  | SHIFT  % shift          expressions [ISO 6.5.7]
  | ADD    % additive       expressions [ISO 6.5.6]
  | MUL    % multiplicative expressions [ISO 6.5.5]
  | CAST   % cast           expressions [ISO 6.5.4]
  | UNARY  % unary          expressions [ISO 6.5.3]
  | POST   % postfix        expressions [ISO 6.5.2]
  | PRIM   % primary        expressions [ISO 6.5.1]

(* The grammar in [ISO 6.5] orders the relative precedences of the various kinds
of expressions according to the inverse order in which those are introduced in
the subsections of [ISO 6.5], e.g. the precedence of unary expressions is higher
than the precedence of additive expressions, so that for instance the text '! x
+ y' parses as '(! x) + y' and not as '! (x + y)'.

The elements of the enumeration above are listed in order of increasing
precedence. To enable the pretty printer to compare the relative precedences of
the different kinds of expressions, we assign increasing natural numbers to the
enumeration elements. *)

op kindPrec : ExpressionKind -> Nat = fn
  | EXPR  ->  0
  | COND  ->  1
  | LOR   ->  2
  | LAND  ->  3
  | IOR   ->  4
  | XOR   ->  5
  | AND   ->  6
  | EQ    ->  7
  | REL   ->  8
  | SHIFT ->  9
  | ADD   -> 10
  | MUL   -> 11
  | CAST  -> 12
  | UNARY -> 13
  | POST  -> 14
  | PRIM  -> 15

(* We map the expressions in our abstract syntax to their kinds and to their
numeric precedences. *)

op exprKind (expr:Expression) : ExpressionKind =
  case expr of
  | E_ident _             -> PRIM
  | E_const _             -> PRIM
  | E_unary _             -> UNARY
  | E_binary (_, BinOp_MUL,  _) -> MUL
  | E_binary (_, BinOp_DIV,  _) -> MUL
  | E_binary (_, BinOp_REM,  _) -> MUL
  | E_binary (_, BinOp_ADD,  _) -> ADD
  | E_binary (_, BinOp_SUB,  _) -> ADD
  | E_binary (_, BinOp_SHL,  _) -> SHIFT
  | E_binary (_, BinOp_SHR,  _) -> SHIFT
  | E_binary (_, BinOp_LT,   _) -> REL
  | E_binary (_, BinOp_GT,   _) -> REL
  | E_binary (_, BinOp_LE,   _) -> REL
  | E_binary (_, BinOp_GE,   _) -> REL
  | E_binary (_, BinOp_EQ,   _) -> EQ
  | E_binary (_, BinOp_NE,   _) -> EQ
  | E_binary (_, BinOp_AND,  _) -> AND
  | E_binary (_, BinOp_XOR,  _) -> XOR
  | E_binary (_, BinOp_IOR,  _) -> IOR
  | E_binary (_, BinOp_LAND, _) -> LAND
  | E_binary (_, BinOp_LOR,  _) -> LOR
  | E_cond _              -> COND
  | E_member _            -> POST
  | E_memberp _           -> POST
  | E_subscript _         -> POST
  | E_nullconst           -> CAST

op exprPrec (expr:Expression) : Nat =
  kindPrec (exprKind expr)

(* The following op maps each binary operator in our C subset to the expression
kinds required for each operand (the op returns a pair). This is derived
straight from the grammar in [ISO 6.5]. *)

op binaryExpected : BinaryOp -> ExpressionKind * ExpressionKind = fn
  | BinOp_MUL  -> (MUL,   CAST)
  | BinOp_DIV  -> (MUL,   CAST)
  | BinOp_REM  -> (MUL,   CAST)
  | BinOp_ADD  -> (ADD,   MUL)
  | BinOp_SUB  -> (ADD,   MUL)
  | BinOp_SHL  -> (SHIFT, ADD)
  | BinOp_SHR  -> (SHIFT, ADD)
  | BinOp_LT   -> (REL,   SHIFT)
  | BinOp_GT   -> (REL,   SHIFT)
  | BinOp_LE   -> (REL,   SHIFT)
  | BinOp_GE   -> (REL,   SHIFT)
  | BinOp_EQ   -> (EQ,    REL)
  | BinOp_NE   -> (EQ,    REL)
  | BinOp_AND  -> (AND,   EQ)
  | BinOp_XOR  -> (XOR,   AND)
  | BinOp_IOR  -> (IOR,   XOR)
  | BinOp_LAND -> (LAND,  IOR)
  | BinOp_LOR  -> (LOR,   LAND)

(* The following op prints an expression.

The auxiliary argument indicates the kind of expression expected. It is set to
'EXPR' when a top-level expression (e.g. the condition of an 'if' statement) is
printed. As the following op is recursively called to print subexpressions, the
auxiliary argument is changed to the kind of expressions needed as
subexpressions, according to the op defined just above. For instance, when
printing an additive expression, the left subexpression is printed with the
'ADD' auxiliary argument, while the right subexpression is printed with the
'MUL' auxiliary argument.

As the first thing, the following op compares the precedence of the expression
to be printed with the precedence of the expected kind of expression: if the
former is lower than the latter, a parenthesized primary expression [ISO 6.5.1]
is printed.

We leave one space between a binary operator and both of its operands. We leave
no space between a unary operator and its operand. We leave one space around the
'?' and ':' of a conditional expression.

As explained in the comments in the C formalization, nullconst in the abstract
syntax stands for 0 cast to 'void*'. *)

op printExpression (expr:Expression, expect:ExpressionKind) : PP0 =
  if exprPrec expr < kindPrec expect then
    {print "(";
     printExpression (expr, EXPR);
     print ")"}
  else
    case expr of
    | E_ident id ->
      printIdentifier id
    | E_const c ->
      printConstant c
    | E_unary (uop, expr) ->
      {printUnaryOp uop;
       printExpression (expr, UNARY)}
    | E_binary (expr1, bop, expr2) ->
      let (expect1, expect2) = binaryExpected bop in
      {printExpression (expr1, expect1);
       printSpace;
       printBinaryOp bop;
       printSpace;
       printExpression (expr2, expect2)}
    | E_cond (expr1, expr2, expr3, _) ->
      {printExpression (expr1, LOR);
       print " ? ";
       printExpression (expr2, EXPR);
       print " : ";
       printExpression (expr3, COND)}
    | E_member (expr, mem) ->
      {printExpression (expr, POST);
       print ".";
       printIdentifier mem}
    | E_memberp (expr, mem) ->
      {printExpression (expr, POST);
       print "->";
       printIdentifier mem}
    | E_subscript (expr, expr') ->
      {printExpression (expr, POST);
       print "[";
       printExpression (expr', EXPR);
       print "]"}
    | E_cast (tp, e) ->
      print "(void*) 0"

(* We introduce an abbreviation for printing a top-level expression. *)

op printTopExpression (expr:Expression) : PP0 =
  printExpression (expr, EXPR)

(* As discussed in the comments for type 'TypeName' in our C formalization, the
concrete syntax of C declarations is complicated by the fact that the declared
type is indicated by syntax "around" the identifier, e.g. 'int x[3]'. While in
the abstract syntax we have avoided the problem by using the notion of type
name, in the pretty printer we have to deal with the problem.

In order to do that, we introduce an abstract notion of declarator [ISO 6.7.6],
built out of identifiers, '*', and '[...]'. For instance, a declarator written
as '*x' is represented as 'pointer x', a declarator written as 'x[4]' is
represented as 'array (x, 4)', a declarator written as '*x[4]' (which is the
same as '*(x[4])', according to the grammar) is represented as 'pointer (array
(x, 4))', and a declarator written as '( *x)[4]' (the space between '(' and '*'
avoids opening a new comment, since comments do not nest in Specware) is
represented as 'array (pointer x, 5)'.

In the last two examples, note that the relative order of 'pointer and 'array'
is swapped w.r.t. the type of 'x'. In the case of '*x[4]', 'x' is an array of
pointers, i.e. its type is 'array (pointer ..., 4)', but the declarator is
'pointer (array (..., 4))'. In the case of '( *x)[4]', x is a pointer to an
array, i.e. its type is 'pointer (array (..., 4))', but the declarator is 'array
(pointer x, 4)'. *)

type Declarator =
  | ident Identifier
  | pointer Declarator
  | array Declarator * Nat

(* Then we introduce an op to turn a (type name, identifier) pair into a (type
name, declarator) pair, where the resulting type name is one that does not get
split in a declaration, i.e. that is any type name but a pointer or array. We
recursively traverse the type name until we have exhausted the 'pointer' and
'array' constructors, at the same time adding those constructors to the
declarator, which starts as the single identifier. Recall that, as remarked
above, the order of 'pointer' and 'array' is swapped in a declarator w.r.t. the
type. *)

op nonSplitTypeName? (tyn:TypeName) : Bool =
  ~ (embed? TN_pointer tyn) && ~ (embed? TN_array tyn)

type NonSplitTypeName = (TypeName | nonSplitTypeName?)

op splitTypeName (tyn:TypeName, id:Identifier) : NonSplitTypeName * Declarator =
  let def loop (tyn:TypeName, dcl:Declarator) : NonSplitTypeName * Declarator =
    case tyn of
    | TN_pointer tyn0 -> loop (tyn0, pointer dcl)
    | TN_array (tyn0, n) -> loop (tyn0, array (dcl, n))
    | _ -> (tyn, dcl)
  in
  loop (tyn, ident id)

(* To print an integer type, we use the shortest list of type specifiers,
i.e. we omit 'signed' and 'int' for signed 'short's, 'int's, 'long's, and 'long
long's and we omit 'int' for unsigned 'short's, 'int's, 'long's, and 'long
long's. Printing a typedef name, a structure type, and the 'void' type is
straightforward. *)

op printNonSplitTypeName (nstyn:NonSplitTypeName) : PP0 =
  case nstyn of
  | TN_char   -> print          "char"
  | TN_uchar  -> print "unsigned char"
  | TN_schar  -> print   "signed char"
  | TN_ushort -> print "unsigned short"
  | TN_sshort -> print          "short"
  | TN_uint   -> print "unsigned int"
  | TN_sint   -> print          "int"
  | TN_ulong  -> print "unsigned long"
  | TN_slong  -> print          "long"
  | TN_ullong -> print "unsigned long long"
  | TN_sllong -> print          "long long"
  | TN_void   -> print "void"
  | TN_typedef name -> printIdentifier name
  | TN_struct tag -> {print "struct "; printIdentifier tag}

(* According to the grammar in [ISO 6.7.6], identifier and array declarators are
direct declarators, while pointer declarators are just declarators. So, a
declarator '*x[4]' is parsed as '*(x[4])', i.e. 'x' is an array of pointers.
Thus, we need to parenthesize pointer declarators when they are used inside
array declarators. In this way we minimize the number of parentheses in
declarators. *)

op printDeclarator (dcl:Declarator) : PP0 =
  case dcl of
  | ident id -> printIdentifier id
  | pointer dcl ->
    {print "*";
     printDeclarator dcl}
  | array (dcl, n) ->
    {if embed? pointer dcl then print "(" else printNothing;
     printDeclarator dcl;
     if embed? pointer dcl then print ")" else printNothing;
     print "[";
     print (natToString n);
     print "]"}

(* To print a type name and a name (i.e. identifier), we first split the type
name, then print the resulting non-split type name and declarator, separated by
a space. *)

op printTypeNameAndName (tyn:TypeName, name:Identifier) : PP0 =
  let (nstyn, dcl) = splitTypeName (tyn, name) in
  {printNonSplitTypeName nstyn;
   printSpace;
   printDeclarator dcl}

(* With the above ops in hand, it is easy to print an object declaration. We
terminate it with a semicolon and with a new line. So, each object declaration
is on its own line. *)

op printObjectDeclaration (odecl:ObjectDeclaration) : PP0 =
  {startLine;
   if odecl.ObjDecl_isExtern then print "extern " else print "";
   printTypeNameAndName (odecl.ObjDecl_type, odecl.ObjDecl_name);
   print ";";
   printNewline}

(* We print a structure specifier by printing the tag with an open curly brace
on the first line, followed by a line for each member, followed by a closing
curly brace on its own line, followed by a semicolon. The member declarations
are separated by commas and indented by one level w.r.t. the struct specifier.

To print a non-empty list of member declarations, we first print the first
member in the list, then there are two cases: if there is no subsequent member,
that must be the last member and so we just move to the next line (where the
closing curly brace will go); if there are subsequent members, we print a comma,
move to the next line, and print the remaining members. Note that when op
'printMemberDeclarations' is called on a non-empty list, it never recursively
calls itself on an empty list. If the op is called on an empty list, no member
is printed. Note also that we are not indenting the member declarations
w.r.t. the structure specifier; we will do that in future extensions. *)

op printMemberDeclaration (mdecl:MemberDeclaration) : PP0 =
  printTypeNameAndName (mdecl.MemDecl_type, mdecl.MemDecl_name)

op printMemberDeclarations (mdecls:List MemberDeclaration) : PP0 =
  case mdecls of
  | [] -> printNothing
  | mdecl::mdecls ->
    {startLine;
     printMemberDeclaration mdecl;
     if empty? mdecls then
       printNewline
     else
       {print ",";
        printNewline;
        printMemberDeclarations mdecls}}

op printStructSpecifier (sspec:StructSpecifier) : PP0 =
  {startLine;
   print "struct ";
   printIdentifier sspec.StructSpec_tag;
   print " {";
   printNewline;
   indentIn;
   printMemberDeclarations sspec.StructSpec_members;
   indentOut;
   startLine;
   print "};";
   printNewline}

(* Printing a type definition is like printing an object declaration, with the
addition of the keyword 'typedef' at the beginning. *)

op printTypeDefinition (tdef:TypeDefinition) : PP0 =
  {startLine;
   print "typedef ";
   printTypeNameAndName (tdef.Typedef_type, tdef.Typedef_name);
   print ";";
   printNewline}

(* Printing a declaration is done by cases on the kind of declaration. *)

op printDeclaration (decl:Declaration) : PP0 =
  case decl of
  | Decl_struct  sspec -> printStructSpecifier   sspec
  | Decl_object  odecl -> printObjectDeclaration odecl
  | Decl_typedef tdef  -> printTypeDefinition    tdef

(* When printing a function call, the argument expressions must be printed,
separated by commas. The following op does that. Nothing is printed if there are
no arguments. If there is at least one argument, it is printed; then, if there
are no more arguments, nothing else is printed, otherwise a comma and a space
are printed, followed by the remaining arguments. The structure of this op is
similar to op printMemberDeclarations above. *)

op printArguments (exprs:List Expression) : PP0 =
  case exprs of
  | [] -> printNothing
  | expr::exprs ->
    {printTopExpression expr;
     if empty? exprs then
       printNothing
     else
       {print ", ";
        printArguments exprs}}

(* We print an assignment on its own line by printing the left expression, the
assignment operator '=' surrounded by spaces, the right expression, and a
semicolon.

A function call is printed also on its own line, with the arguments surrounded
by parentheses; depending on whether the function result is assigned to an
expression, we follow the same pattern as assignments.

To print an 'if' statement, we print the test on its own line, followed by the
'then' branch, optionally followed by the 'else' branch. If the ('then' or
'else' branch is not a block, we indent it by one level. If the ('then' or
'else') branch is a block, we print the opening curly brace at the end of the
line where the 'if' or 'else' appears, then we print the block items indented by
one level, and then we close the curly brace at the beginning of the line. If
the 'then' branch is a block and there is an 'else' branch, the 'else keyword
follows the closing curly brace of the then block, separated by a space. In the
op below, the 'case thenBranch ...' Specware expression prints all the needed
text up to the 'else' keyword, in order to deal with the various cases.

When printing nested 'if' statements, care must be taken to maintain the correct
association of the 'else' branch with its 'if' statement. A statement of the
form

  [*]  iF (..., iF (..., ..., None), Some ...)

is an 'if-then-else' that has an 'if-then' as its 'then' branch. So the 'else'
branch is associated to the outer 'if'. If this statement is printed following
the general rules described above, the result is something like

  if (...)
    if (...)
      ...
  else
    ...

Despite the indentation, this C text associates the 'else' to the inner 'if'
[ISO 6.8.4.1/3], which in general is not equivalent to the original statement
[*] above. To avoid this problem, when printing a statement of the form [*] we
put the inner 'if-else' into a block, producing something like

  if (...) {
    if (...)
      ...
  } else
    ...

which associates the 'else' to the outer 'if', as intended.

Return statements are also printed on their own lines, in a straightforward way.

To print a 'while' statement, we print the test on its own line, followed by the
body. If the body is not a block, we indent it by one level. If the body is a
block, we print the opening curly brace at the end of the line where the 'while'
appears, then we print the block items indented by one level, and then we close
the curly brace at the beginning of a new line.

To print a 'do' statement, we print the keyword 'do' on its own line, followed
by the body, followed by the test on its own line. If the body is not a block,
we indent it by one level. If the body is a block, we print the opening curly
brace at the end of the line where the 'do' appears, then we print the block
items indented by one level, and then we close the curly brace just before the
'while' part.

To print a 'for' statement, we print the parenthesized (optional) expressions on
their own line, followed by the body. If the body is not a block, we indent it
by one level. If the body is a block, we print the opening curly brace at the
end of the line where the 'for' appears, then we print the block items indented
by one level, and then we close the curly brace at the beginning of a new line.

To print a block that is not a branch of an 'if' or 'while' statement, we open
with a curly brace in its own line, we print the items indented by one level,
and we close with a curly brace in its own line. The items of a block are
printed one after the other. Since there is no separator needed between them,
the structure of op 'printBlockItems' is a little simpler than ops
'printMemberDeclarations' and 'printArguments' above. Printing a block item is
straightforward. *)

% print assignment as expression (i.e. inline, without ending ';'):
op printAssignmentAsExpression (expr:Expression) (expr':Expression) : PP0 =
  {printTopExpression expr;
   print " = ";
   printTopExpression expr'}

% print function call as expression (i.e. inline, without ending ';'):
op printCallAsExpression
   (expr?:Option Expression) (fun:Expression) (exprs:List Expression) : PP0 =
  {case expr? of
   | Some expr ->
     {printTopExpression expr;
      print " = "}
   | None ->
     printNothing;
   printExpression (fun, POST);
   print "(";
   printArguments exprs;
   print ")"}

% print statement used as (first or third) parenthesized expression of 'for':
op printStatementAsForExpression (stmt:Statement) : PP0 =
  case stmt of
  | S_assign (expr, expr') -> printAssignmentAsExpression expr expr'
  | S_call (expr?, fun, exprs) -> printCallAsExpression expr? fun exprs
  | _ -> printNothing % FIXME: this should be some sort of error...


op printStatement (stmt:Statement) : PP0 =
  case stmt of
  | S_assign (expr, expr') ->
    {startLine;
     printAssignmentAsExpression expr expr';
     print ";";
     printNewline}
  | S_call (expr?, fun, exprs) ->
    {startLine;
     printCallAsExpression expr? fun exprs;
     print ";";
     printNewline}
  | S_if (expr, thenBranch, elseBranch?) ->
    {startLine;
     print "if (";
     printTopExpression expr;
     print ")";
     case thenBranch of
     | S_block items ->
       {print " {";
        printNewline;
        indentIn;
        printBlockItems items;
        indentOut;
        startLine;
        print "}";
        if elseBranch? = None then printNewline
        else printSpace}
     | S_if (_, _, None) ->
       if elseBranch? ~= None then
         % put 'then' branch into block, to associate 'else' to outer 'if':
         {print " {";
          printNewline;
          indentIn;
          printBlockItems [BlockItem_statement thenBranch];
          indentOut;
          startLine;
          print "}";
          if elseBranch? = None then printNewline
          else printSpace}
       else
         {printNewline;
          indentIn;
          printStatement thenBranch;
          indentOut;
          if elseBranch? = None then printNothing
          else startLine}
     | _ ->
       {printNewline;
        indentIn;
        printStatement thenBranch;
        indentOut;
        if elseBranch? = None then printNothing
        else startLine};
     case elseBranch? of
     | Some elseBranch ->
       {print "else";
        case elseBranch of
        | S_block items ->
          {print " {";
           printNewline;
           indentIn;
           printBlockItems items;
           indentOut;
           startLine;
           print "}";
           printNewline}
        | _ ->
          {printNewline;
           indentIn;
           printStatement elseBranch;
           indentOut}}
     | None ->
       printNothing}
  | S_return expr? ->
    {startLine;
     print "return";
     case expr? of
     | Some expr ->
       {printSpace;
        printTopExpression expr;
        print ";";
        printNewline}
     | None ->
       {print ";";
        printNewline}}
  | S_while (expr, body) ->
    {startLine;
     print "while (";
     printTopExpression expr;
     print ")";
     case body of
     | S_block items ->
       {print " {";
        printNewline;
        indentIn;
        printBlockItems items;
        indentOut;
        startLine;
        print "}";
        printNewline}
     | _ ->
       {printNewline;
        indentIn;
        printStatement body;
        indentOut}}
  | S_do (body, expr) ->
    {startLine;
     print "do";
     case body of
     | S_block items ->
       {print " {";
        printNewline;
        indentIn;
        printBlockItems items;
        indentOut;
        startLine;
        print "} "}
     | _ ->
       {printNewline;
        indentIn;
        printStatement body;
        indentOut;
        startLine};
     print "while (";
     printTopExpression expr;
     print ");";
     printNewline}
  | S_for (first, expr, third, body) ->
    {startLine;
     print "for (";
     printStatementAsForExpression first;
     print "; ";
     printTopExpression expr;
     print "; ";
     printStatementAsForExpression third;
     print ")";
     case body of
     | S_block items ->
       {print " {";
        printNewline;
        indentIn;
        printBlockItems items;
        indentOut;
        startLine;
        print "}";
        printNewline}
     | _ ->
       {printNewline;
        indentIn;
        printStatement body;
        indentOut}}
  | S_block items ->
    {startLine;
     print "{";
     printNewline;
     indentIn;
     printBlockItems items;
     indentOut;
     startLine;
     print "}";
     printNewline}

op printBlockItems (items:List BlockItem) : PP0 =
  case items of
  | [] -> printNothing
  | item::items ->
    {printBlockItem item;
     printBlockItems items}

op printBlockItem (item:BlockItem) : PP0 =
  case item of
  | BlockItem_declaration (tp_name, ident) ->
    printObjectDeclaration {ObjDecl_type = tp_name,
                            ObjDecl_name = ident,
                            ObjDecl_isExtern = false}
  | BlockItem_statement stmt -> printStatement stmt

(* Printing a function definition involves printing its parameter list, which we
do similarly to lists of member declarations, except that the parameters are
separated by a comma and a space. *)

op printParameterDeclaration (pdecl:ParameterDeclaration) : PP0 =
  printTypeNameAndName (pdecl.1, pdecl.2)

op printParameterList (plist:ParameterList) : PP0 =
  case plist of
  | [] -> printNothing
  | pdecl::pdecls ->
    {printParameterDeclaration pdecl;
     if empty? pdecls then
       printNothing
     else
       {print ",";
        printSpace;
        printParameterList pdecls}}

(* The return type of a function definition could be a pointer or an array, in
which case we need to split it, as we do with other declarations. Actually,
[ISO] prohibits the return type of a function to be an array, but for
completeness we define our printing ops also for that case. To print a function
definition, all we have to do is print the function's return type and the
function's name as a non-split type and a declarator, then add a parenthesized
parameter list. The are all on one line. Then we print the function's body. If
the function's body is a block (as it should), we print the opening curly brace
on the same line as the name/arguments/etc., then we print the block items
(indented by one level), and finally the closing curly brace in its own line. If
the body is not a block, we just print it after the function's
name/arguments/etc.; we include this case for completeness, but it never happens
for code that satisfies the compile-time constraints in [ISO], which require the
body of a function to be a block. *)

op printFunctionDeclaration (fdef:FunctionDeclaration) : PP0 =
  {startLine;
   if fdef.FDef_isExtern then print "extern " else printNothing;
   printTypeNameAndName (fdef.FDef_retType, fdef.FDef_name);
   print "(";
   printParameterList fdef.FDef_params;
   print ")";
   case fdef.FDef_body of
   | Some (S_block items) ->
     {print "{";
      printNewline;
      indentIn;
      printBlockItems items;
      indentOut;
      startLine;
      print "}";
      printNewline}
   | Some stmt ->
     {print "{";
      printNewline;
      indentIn;
      printStatement stmt;
      indentOut;
      startLine;
      print "}";
      printNewline}
   | None -> print ";"}

(* Printing an external declaration is straightforward, by cases. *)

op printExternalDeclaration (xdecl:ExternalDeclaration) : PP0 =
  case xdecl of
  | EDecl_function fdef -> printFunctionDeclaration fdef
  | EDecl_declaration decl -> printDeclaration decl

(* We print a translation unit by printing all its external declarations in
order, separated by a blank line for improved readability. The structure of the
following op is the same as the other ops that print lists with separators (in
this case, the separators are the blank lines). *)

op printTranslationUnit (tunit:TranslationUnit) : PP0 =
  case tunit of
  | [] -> printNothing
  | xdecl::xdecls ->
    {printExternalDeclaration xdecl;
     if empty? xdecls then
       printNothing
     else
       {printNewline;
        printTranslationUnit xdecls}}


(* Top-level entrypoints for printing translation units *)

op printTranslationUnitToString (tunit:TranslationUnit) : Text =
  runPP0 (printTranslationUnit tunit)

end-spec
