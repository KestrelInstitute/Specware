
% Defines a proof language for Specware. This language is not meant to
% be complete for everything it needs to do, but instead can include
% calls to tactics in an underlying proof assistant (i.e., Isabelle)
% to prove the really difficult theorems.
%
% README: scroll down to the "external interface" to see how to use
% this library

Proof qualifying spec
  import MSTerm
  import ../AbstractSyntax/PathTerm
  import /Library/Structures/Data/Monad/ErrorMonad

  % The internal form of proofs
  type ProofInternal =
    %% General proof constructs

    % Proof_Cut (P, Q, pf1, pf2) takes pf1 : P=>Q and pf2 : P
    % and creates a proof of Q
    | Proof_Cut (MSTerm * MSTerm * ProofInternal * ProofInternal)

    % Proof_ForallE (x,T,M,N,pf) is a proof of [N/x]M from a proof
    % pf : fa(x:T)M and a proof tppf : N:T
    | Proof_ForallE (Id * MSType * MSTerm * MSTerm
                       * ProofInternal * TypingProofInternal)

    % Proof_EqTrue(M,pf) is a proof of M given a proof pf :: M=true
    | Proof_EqTrue (MSTerm * ProofInternal)

    % Proof_Theorem(x,P) is a proof of P assuming that x is the
    % name of an axiom or theorem that proves P
    | Proof_Theorem (QualifiedId * MSTerm)

    % ProofInternal by an external tactic, along with the predicate it proves
    | Proof_Tactic (String * MSTerm)

    %% Equality proofs

    % ProofInternal that a variable x equals its definition
    | Proof_UnfoldDef (MSType * QualifiedId * MSTerm)

    % Proof_EqSubterm(M,N,T,p,pf) is a proof that M = N : T from a
    % proof pf : M.p = N.p, where M.p is the subterm of M at path p
    | Proof_EqSubterm (MSTerm * MSTerm * MSType * Path * ProofInternal)

    % Proof_EqSym(pf) is a proof that N=M from pf : M=N
    | Proof_EqSym ProofInternal

    % ProofInternal by transitivity of equality: proves x0 = x1 = ... = xn,
    % all at type T, where each (pf, t) pair in the list is an xi
    % along with the proof that x(i-1) = xi
    | Proof_EqTrans (MSType * MSTerm * List (ProofInternal * MSTerm))

    %% Implication proofs

    % Proof_ImplTrans(P,pf1,Q,pf2,R) is a proof of P => R from
    % proofs pf1: P=>Q and pf2: Q=>R
    | Proof_ImplTrans (MSTerm * ProofInternal * MSTerm * ProofInternal * MSTerm)

    % Proof_ImplEq(pf) is a proof that P=>Q from pf: P=Q
    | Proof_ImplEq ProofInternal

    % Proof_MergeRules(P,Q,tree,ids1,ids2) is a proof that P=>Q
    % generated by MergeRules
    | Proof_MergeRules (MSTerm * MSTerm * TraceTree * List QualifiedId * List QualifiedId)


  % Return the predicate proved by a proof
  op proofPredicate_Internal (p : ProofInternal) : MSTerm =
    case p of
      | Proof_Cut (P, Q, pf1, pf2) -> Q
      | Proof_ForallE (x,T,M,N,pf,tp_pf) -> substitute (M, [((x,T),N)])
      | Proof_EqTrue (M, pf) -> M
      | Proof_Theorem (id, P) -> P
      | Proof_Tactic (tact, P) -> P
      | Proof_EqSubterm(M,N,T,p,pf) -> mkEquality (T,M,N)
      | Proof_UnfoldDef (T, qid, M) -> mkEquality (T, mkOp (qid, T), M)
      | Proof_EqSym(pf) ->
        (case matchEquality (proofPredicate_Internal pf) of
           | Some (T,M,N) -> mkEquality (T,N,M)
           | _ -> fail "Malformed proof: in proofPredicate applied to Proof_EqSym")
      | Proof_EqTrans (T, M1, pfs) ->
        let def getLast Mprev pfs' =
          (case pfs' of
            | [] -> Mprev
            | (_, M) :: pfs'' -> getLast M pfs'')
        in
        mkEquality (T, M1, getLast M1 pfs)
      | Proof_ImplTrans(P,pf1,Q,pf2,R) -> mkImplies (P, R)
      | Proof_ImplEq pf ->
        (case matchEquality (proofPredicate_Internal pf) of
           | Some (T, M, N) -> mkImplies (M, N)
           | _ -> fail "Malformed proof: in proofPredicate applied to Proof_ImplEq")
      | Proof_MergeRules(P,Q,tree,ids1,ids2) -> mkImplies (P, Q)

  % Print out a representation of a proof
  op showProof_Internal (p : ProofInternal) : String =
    "(FIXME: write Proof.showProof_Internal!)"


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % External interface starts here!!
  %
  % The prove_* commands below should be the *only* way proofs are
  % built. The idea of the Proof type here is that you don't have to
  % check for errors at each point, but can instead just write your
  % proof completely ignoring the possibility of errors. (This should
  % look familiar to those familiar with the error monad...)

  % The type of proofs that might have been built incorrectly
  type Proof = Monad ProofInternal

  % The type of typing proofs that might have been built incorrectly
  type TypingProof = Monad TypingProofInternal

  % Print out a representation of a proof
  op showProof (p : Proof) : String =
  case p of
    | ErrorOk p_int -> showProof_Internal p_int
    | ErrorFail str -> "(proof error: " ^ str ^ ")"

  % Return the predicate proved by a proof, or None if there is an
  % error in the proof
  op proofPredicate (p : Proof) : Option MSTerm =
    case p of
      | ErrorOk p -> Some (proofPredicate_Internal p)
      | ErrorFail _ -> None


  % prove_implElim (pf1, pf2) takes a proof pf1:P=>Q and a proof pf2:P
  % and builds a proof of Q
  op prove_implElim (p1 : Proof, p2 : Proof) : Proof =
    { p1_int <- p1; p2_int <- p2;
      p1_pred <- return (proofPredicate_Internal p1_int);
      p2_pred <- return (proofPredicate_Internal p2_int);
      case matchImplication p1_pred of
        | Some (P, Q) | equalTerm? (P, p2_pred) ->
          return (Proof_Cut (P, Q, p1_int, p2_int))
        | _ -> ErrorFail ("Implication elimination of (" ^ printTerm p1_pred
                            ^ ") against (" ^ printTerm p2_pred ^ ")") }

  % prove_forallElim (pf, N, tp_pf) takes a proof pf1:fa(x:T)M, a term
  % N of type T, and a proof tp_pf that N does indeed have type T, and
  % builds a proof of [N/x]M.
  op prove_forallElim (p : Proof, N : MSTerm, tp_pf : TypingProof) : Proof =
    { p_int <- p;
      p_pred <- return (proofPredicate_Internal p_int);
      tp_int <- tp_pf;
      (tp_M, tp_T) <- return (typingProofPredicate tp_int);
      case matchForall1 p_pred of
        | Some (x, T, M) | equalTerm? (M, tp_M) && equalType? (T, tp_T) ->
          return (Proof_ForallE (x, T, M, N, p_int, tp_pf_int))
        | _ -> ErrorFail ("Forall elimination of (" ^ printTerm p_pred
                            ^ ") against term (" ^ printTerm N ^ ")") }

  % build a proof of M given a proof of M=true
  op prove_fromEqualTrue (M : MSTerm, pf : Proof) : Proof =
    { p_int <- p;
      p_pred <- return (proofPredicate_Internal p_int);
      case matchEquality pf_pred of
        | Some (_, M', N) | equalTerm? (M,M') && equalTerm? (N,mkTrue()) ->
          return (Proof_EqTrue (M, p_int))
        | _ -> ErrorFail ("Attempt to prove (" ^ printTerm M
                            ^ ") from a proof of (" ^ printTerm pf_pred ^ ")") }

  % build a proof of true
  op prove_true : Proof =
    prove_fromEqualTrue (mkTrue(), prove_equalRefl (mkTrue()))

  % build a proof by applying a theorem or axiom for predicate P
  op prove_withTheorem (qid : QualifiedId, P : MSTerm) : Proof =
    return (Proof_Theorem (qid, P))

  % build a proof by applying a tactic
  op prove_withTactic (tactic : String, P : MSTerm) : Proof =
    return (Proof_Tactic (tactic, P))

  % build an equality proof with a tactic
  op prove_equalWithTactic (tactic : String, M : MSTerm, N : MSTerm, T : MSType) : Proof =
    return (Proof_Tactic (tactic, mkEquality (T,M,N)))

  % build a proof of qid=M, assuming qid has definition M and type T
  % in the current spec; NOTE: this assumption is not checked
  op prove_equalUnfold (qid : QualifiedId, M : MSTerm, T : MSType) : Proof =
    return (Proof_UnfoldDef (T, qid, M))

  % prove_equalSubTerm(M,N,T,p,pf) proves that M=N at type T using a
  % proof pf that the subterms of M and N at path p are equal. NOTE:
  % we assume that M and N both have type T
  op prove_equalSubTerm (M : MSTerm, N : MSTerm, T : MSType, p : Path, pf : Proof) : Proof =
    { pf_int <- pf;
      pf_pred <- return (proofPredicate_Internal pf_int);
      let (varsM, M_sub) = fromPathTermWithBindings (M, p) in
      let (varsN, N_sub_orig) = fromPathTermWithBindings (N, p) in
      let N_sub = if varsM = varsN then N_sub_orig else
                    substitute (N_sub_orig, zip (varsN, map mkVar varsM)) in
      case matchEquality pf_pred of
        | Some (_, M', N') | equalTerm? (M', M_sub) && equalTerm? (N', N_sub) ->
          return (Proof_EqSubterm(M,N,T,p,pf_int))
        | _ -> ErrorFail ("Attempt to prove equality of subterms (" ^
                            printTerm (fromPathTerm (M,p)) ^
                            ") and (" ^ printTerm (fromPathTerm (N,p)) ^
                            ") from a proof of: " ^ printTerm pf_pred) }

  % build a proof of M=M
  op prove_equalRefl (M : MSTerm) : Proof =
    return (Proof_EqTrans (termType M, M, []))

  % build a proof of N=M from a proof of M=N
  %
  % FIXME: do proof simplification, pushing the symmetry into
  % transitivity and subterm proofs
  op prove_equalSym (pf : Proof) : Proof =
    { pf_int <- pf;
      let pf_pred = proofPredicate_Internal pf_int in
      case matchEquality pf_pred of
        | Some (T, M, N) -> return (Proof_EqSym pf_int)
        | _ -> ErrorFail ("Attempt to apply symmetry of equality to a non-equality proof: "
                            ^ printTerm pf_pred) }

  % prove M=P from a proof pf1 of M=N and a proof pf2 of N=P
  %
  % NOTE: both equality proofs must be at the same type (it might be
  % ok to take the meet of two different types, but I'm not sure...)
  op prove_equalTrans (pf1 : Proof, pf2 : Proof) : Proof =
    { pf1_int <- pf1; pf2_int <- pf2;
      pf1_pred <- return (proofPredicate_Internal pf1_int);
      pf2_pred <- return (proofPredicate_Internal pf2_int);
      case (matchEquality pf1_pred, matchEquality pf2_pred) of
        | (Some (T1, M, N1), Some (T2, N2, P)) | equalTerm? (N1, N2) && equalType? (T1, T2) ->
          (case (pf1_int, pf2_int) of
             | (Proof_EqTrans (T, M1, pfs1), Proof_EqTrans (_, _, pfs2)) ->
               return (Proof_EqTrans (T, M1, pfs1 ++ pfs2))
             | (Proof_EqTrans (T, M1, pfs1), _) ->
               return (Proof_EqTrans (T, M1, pfs1 ++ [(pf2_int, P)]))
             | (_, Proof_EqTrans (T, _, pfs2)) ->
               return (Proof_EqTrans (T, M, (pf1_int, N1)::pfs2))
             | _ -> return (Proof_EqTrans (T1, M, [(pf1_int, N1),(pf2_int, P)])))
        | _ ->
          ErrorFail ("Attempt to apply transitivity of equality to proofs of ("
                            ^ printTerm pf1_pred ^ ") and (" ^ printTerm pf2_pred ^ ")")
          }

  % prove P=>R from proof pf1 of P=>Q and pf2 of Q=>R
  op prove_implTrans (pf1 : Proof, pf2 : Proof) : Proof =
    { pf1_int <- pf1; pf2_int <- pf2;
      pf1_pred <- return (proofPredicate_Internal pf1_int);
      pf2_pred <- return (proofPredicate_Internal pf2_int);
      case (matchImplication pf1_pred, matchImplication pf2_pred) of
        | (Some (P, Q1), Some (Q2, R)) | equalTerm? (Q1, Q2) ->
          return (Proof_ImplTrans (P, pf1_int, Q1, pf2_int, R))
        | _ ->
          ErrorFail ("Attempt to apply transitivity of implication to proofs of ("
                            ^ printTerm pf1_pred ^ ") and (" ^ printTerm pf2_pred ^ ")")
          }

  % prove P=>Q from a proof of P=Q
  op prove_implEq (pf : Proof) : Proof =
    { pf_int <- pf;
      let pf_pred = proofPredicate_Internal pf_int in
      case matchEquality pf_pred of
        | Some _ -> return (Proof_ImplEq pf_int)
        | _ ->
          ErrorFail ("Attempt to prove implication by equality from a non-equality proof of " ^
                     printTerm pf_pred) }

  % prove P=>Q using MergeRules
  op prove_MergeRules (P,Q,tree,ids1,ids2) : Proof =
    return (Proof_MergeRules (P,Q,tree,ids1,ids2))

end-spec
