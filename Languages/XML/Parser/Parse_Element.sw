
XML qualifying spec

  import Parse_References         % parse_Reference   [redundant, given Parse_Character_Strings]
  import Parse_ElementTag         % parse_Option_ElementTag
  import Parse_Character_Strings  % parse_Comment, parse_CDSect
  import Parse_PI                 % parse_PI

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%          Element                                                                             %%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% 
  %%  [39]  element  ::=  EmptyElemTag | STag content ETag 
  %%
  %%                                                             [WFC: Element Type Match] 
  %%                                                             [VC:  Element Valid]
  %%
  %% *[40]  STag          ::=  '<' Name (S Attribute)* S? '>' 
  %%
  %%                                                             [WFC: Unique Att Spec]
  %%   ==>
  %% [K27]  STag          ::=  ElementTag                            
  %%
  %%                                                             [KC:  Proper Start Tag]
  %%                                                             [WFC: Unique Att Spec]
  %% 
  %% *[41]  Attribute     ::=  Name Eq AttValue 
  %%   ==>
  %%  [K8]  ElementAttribute   ::=  S NmToken S? '=' S? QuotedText
  %%
  %%                                                             [VC:  Attribute Value Type]
  %%                                                             [WFC: No External Entity References]
  %%                                                             [WFC: No < in Attribute Values]
  %%
  %% *[42]  ETag          ::=  '</' Name S? '>'
  %%   ==>
  %% [K28]  ETag          ::=  ElementTag                   
  %%
  %%                                                             [KC:  Proper End Tag]
  %%
  %%  Since the chardata in [43] is typically used for indentation, 
  %%  it makes more sense to group it as in [K18]:
  %%
  %% *[43]  content       ::=  CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*
  %%   ==>
  %% [K29]  content       ::=  content_item* CharData?
  %% [K30]  content_item  ::=  CharData? (element | Reference | CDSect | PI | Comment
  %% 
  %% *[44]  EmptyElemTag  ::=  '<' Name (S Attribute)* S? '/>' 60]
  %%
  %%                                                             [WFC: Unique Att Spec]
  %%   ==>
  %% [K31]  EmptyElemTag  ::=  ElementTag
  %%
  %%                                                             [KC:  Proper Empty Tag]
  %%                                                             [WFC: Unique Att Spec]
  %%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %% -------------------------------------------------------------------------------------------------
  %%
  %%  [39]  element  ::=  EmptyElemTag | STag content ETag 
  %%
  %%                                                             [WFC: Element Type Match] 
  %%                                                             [VC:  Element Valid]
  %%
  %% -------------------------------------------------------------------------------------------------
  %%
  %%  [WFC: Element Type Match]                     [39]  -- element_types_match?
  %% 
  %%    The Name in an element's end-tag must match the element type in the start-tag.
  %% 
  %% -------------------------------------------------------------------------------------------------
  %% 
  %%  [VC: Element Valid]                           [39]
  %%
  %%    An element is valid if there is a declaration matching elementdecl where the Name matches the 
  %%    element type, and one of the following holds:
  %%    
  %%      1.  The declaration matches EMPTY and the element has no content.
  %%    
  %%      2.  The declaration matches children and the sequence of child elements belongs to the 
  %%          language generated by the regular expression in the content model, with optional white 
  %%          space (characters matching the nonterminal S) between the start-tag and the first child
  %%          element, between child elements, or between the last child element and the end-tag.
  %%          Note that a CDATA section containing only white space does not match the nonterminal S, 
  %%          and hence cannot appear in these positions.
  %%    
  %%      3.  The declaration matches Mixed and the content consists of character data and child 
  %%          elements whose types match names in the content model.
  %%    
  %%      4.  The declaration matches ANY, and the types of any child elements have been declared.
  %% 
  %% -------------------------------------------------------------------------------------------------

  def parse_Element (start : UChars, pending_open_tags : List (ElementTag)) : Required Element =
    {
     (possible_open_tag, tail) <- parse_OpenTag start;
     case possible_open_tag of
       | Some open_tag ->
         %% open_tag will be one of EmptyElemTag or STag
         (if well_formed_empty_tag? open_tag then
	    return ((Empty open_tag), 
		    tail)
	  else
	    {
	     (content, tail) <- parse_Content (tail, cons (open_tag, pending_open_tags));
	     (etag,    tail) <- parse_ETag    (tail, cons (open_tag, pending_open_tags));
	     return ((Full {stag    = open_tag, 
			    content = content, 
			    etag    = etag}),
		     tail)
	    })
       | _ ->
	 hard_error {kind        = WFC,
		requirement = "A document must have a root element.",
		start       = start,
		tail        = tail,
		peek        = 10,
		we_expected = [("<foo ..>",    "Start Tag"),
			       ("<foo .../> ", "Empty Element Tag")],
		but         = "we saw something else instead",
		so_we       = "fail immediately"}
	}

  %% -------------------------------------------------------------------------------------------------
  %%
  %% [K27]  STag          ::=  ElementTag                            
  %%
  %%                                                             [KC:  Proper Start Tag]
  %%                                                             [WFC: Unique Att Spec]
  %%
  %% [K31]  EmptyElemTag  ::=  ElementTag
  %%
  %%                                                             [KC:  Proper Empty Tag]
  %%                                                             [WFC: Unique Att Spec]
  %%
  %% -------------------------------------------------------------------------------------------------
  %%
  %%  [KC: Proper Start Tag]                       [K27] -- start_tag?
  %%
  %%    prefix     = ''
  %%    name       not 'xml'
  %%    postfix    = ''
  %%
  %%  [KC: Proper Empty Tag]                       [K31] -- empty_tag?
  %%
  %%    prefix     = ''
  %%    name       not 'xml'
  %%    postfix    = '/'
  %%
  %%  [WFC: Unique Att Spec]                       *[40] *[44] [K27] [K31] -- unique_attributes?
  %%
  %%    No attribute name may appear more than once in the same start-tag or empty-element tag.
  %%
  %% -------------------------------------------------------------------------------------------------

  def parse_OpenTag (start : UChars) : Possible ElementTag =
    { (possible_tag, tail) <- parse_Option_ElementTag start;
      case possible_tag of
	| Some tag ->
	  {
	   (when (~ ((well_formed_start_tag? tag) or (well_formed_empty_tag? tag)))
	    (error {kind        = WFC,
		    requirement = "Each element must begin with a start tag or be an empty element tag.",
		    start       = start,
		    tail        = tail,
		    peek        = 10,
		    we_expected = [("<foo ..>",    "Start Tag"),
				   ("<foo .../> ", "Empty Element Tag")],
		    but         = ("an unexpected "
				   ^ (if well_formed_end_tag? tag then "closing" else "unrecognized") 
				   ^ " tag: '</" 
				   ^ (string tag.name)
				   ^ ">' was seen instead"),
		    so_we       = "proceed as if that were a start tag"}));
	   return (possible_tag, tail)}
	| _ -> return (None, start)
     }

  %% -------------------------------------------------------------------------------------------------
  %%
  %% [K29]  content       ::=  content_item* CharData?
  %%
  %% -------------------------------------------------------------------------------------------------

  def parse_Content (start : UChars, pending_open_tags : List (ElementTag)) : Required Content =
    let 
       def parse_items (tail, rev_items) =
	 let (char_data, tail) = parse_CharData tail in
	 {
	  (possible_item, scout) <- parse_Content_Item (tail, pending_open_tags);
	  case possible_item of
	    | Some item ->
	      parse_items (scout,
			   cons ((char_data, item),
				 rev_items))
	    | _ -> 
	      return ({items   = rev rev_items, 
		       trailer = char_data},
		      tail)
	     }
    in
      parse_items (start, [])

  %% -------------------------------------------------------------------------------------------------
  %%
  %% [K30]  content_item  ::=  CharData? (element | Reference | CDSect | PI | Comment
  %%
  %% -------------------------------------------------------------------------------------------------

  def parse_Content_Item (start : UChars, pending_open_tags : List (ElementTag)) : Possible Content_Item =
    %% All the options are readily distinguishable:
    %%
    %% Reference  -- "&" ...
    %% Element    -- "<" Letter ...
    %% PI         -- "<?"
    %% CDSect     -- "<![CDATA[" ...
    %% Comment    -- "<!--"
    %%
    %% So do a little lookahead to avoid needless backtracking...
    %%
    case start of
      | 60 (* '<' *) :: tail ->
        (case tail of
	   | 33 :: 45 :: 45 (* '!--' *) :: tail -> 
 	     %% "<!--"
	     {
	      %% parse_Comment assumes we're past "<!--"
	      (comment, tail) <- parse_Comment tail; 
	      return (Some (Comment comment),
		      tail)
	     }
	   | 33 :: 91  :: 67 :: 68 :: 65 :: 84 :: 65 :: 91 (* '![CDATA[' *) :: tail ->
	     %% "<![CDATA["
	     {
	      %% parse_CDSECT assumes we're past "<![CDATA["
	      (cdsect, tail) <- parse_CDSect tail;   
	      return (Some (CDSect cdsect),
		      tail)
	     }
	   | 47 (* '/' *) :: _ -> 
	     %% "</"
	     %% start of an ETag, so not something we're looking for
	     return (None, start)
	   | 63 (* '?' *) :: _ -> 
	     %% "<?"
	     %% parse_PI assumes we're past '<?'
	     {
	      (pi, tail) <-  parse_PI tail;
	      return (Some (PI pi),
		      tail)
	      }
	   | _ ->
	     {
	      %% parse_Element assumes we're back at the original "<"
	      (element, tail) <- parse_Element (start, pending_open_tags); 
	      return (Some (Element element),
		      tail)
	     })
      | [] ->
	hard_error {kind        = EOF,
		    requirement = "Each item in the element contents must be one of the options below.",
		    start       = start,
		    tail        = [],
		    peek        = 0,
		    we_expected = [("'<!--' ...",      "comment"),
				   ("'<![CDATA[' ...", "unparsed character data"),				   
				   ("'</' ...",        "end tag"),				   
				   ("'<?' ...",        "PI"),
				   ("'<' Name ...",    "start tag or empty element tag"),				   
				   ("'&' ...",         "reference")],
		    but          = "EOF occcurred first",
		    so_we        = "fail immediately"}
      | 38  (* '&' *)   :: tail -> 
	{
	 %% parse_Reference assumes we're just past the ampersand.
	 (ref, tail) <- parse_Reference start;
	 return (Some (Reference ref),
		 tail)
	}
      | _ ->
	return (None, start)


  %% -------------------------------------------------------------------------------------------------
  %%
  %% [K28]  ETag          ::=  ElementTag                   
  %%
  %%                                                             [KC:  Proper End Tag]
  %%
  %% -------------------------------------------------------------------------------------------------
  %%
  %%  [KC: Proper End   Tag]                       [K28] -- well_formed_end_tag?
  %%
  %%    prefix     = '/'
  %%    name       not 'xml'
  %%    postfix    = ''
  %%
  %% -------------------------------------------------------------------------------------------------

  def parse_ETag (start : UChars, pending_open_tags : List (STag)) : Required ETag =
    let stag = hd pending_open_tags in
    let name = string stag.name     in
    { (possible_tag, tail) <- parse_Option_ElementTag start;
      case possible_tag of
	| Some etag ->
	  {
	   (when (~ (well_formed_end_tag? etag))
	    (error {kind        = Syntax,
		    requirement = "An element must terminate with an end tag.",
		    start       = start,
		    tail        = tail,
		    peek        = 10,
		    we_expected = [("'</" ^ name ^ ">'", "ETag to close earlier STag with that name")],
		    but         = "the tag named " ^ (string etag.name) ^ " seen instead was not an end tag",
		    so_we       = "pretend that tag is an end tag"}));
	   if stag.name = etag.name then
	     return (etag, tail)
	   else
	     {
	      error {kind        = WFC,
		     requirement = "Element Type Match : The Name in an element's end-tag must match the element type in the start-tag.",
		     start       = start,
		     tail        = tail,
		     peek        = 0,
		     we_expected = [("'</" ^ name ^ ">'", "ETag to close earlier STag with that name")],
		     but         = "the unexpected end tag: '</" ^ (string etag.name) ^ ">' was seen instead",
		     so_we       = "pretend an interpolated close tag for " ^ name ^ " was seen"};
	      return ({prefix     = [47],
		       name       = stag.name,
		       attributes = [],
		       whitespace = [],
		       postfix    = []},
		      start)
	     }}
	| _ -> 
	  hard_error {kind        = Syntax,
		      requirement = "An element must terminate with an end tag.",
		      start       = start,
		      tail        = tail,
		      peek        = 10,
		      we_expected = [("'</" ^ name ^ ">'", "ETag to close earlier STag with that name")],
		      but         = "the element content terminated without a following end tag", 
		      so_we       = "fail immediately"}
	 }

endspec