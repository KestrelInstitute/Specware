(* Copyright 2015 Kestrel Institute. See file LICENSE.text for license details *)

XML qualifying spec

  import translate (translate /Library/Structures/Data/Monad/Base
    by {Monad +-> Env})
    by {Monad._ +-> Env._}

  import XML_Exceptions
  import ../XML_Sig     % For Name, Content
  import /Library/Legacy/Utilities/System

  type Env a = State -> (Result a) * State

  type Result a =
    | Ok        a
    | Exception XML_Exception

  %%  ================================================================================
  %%  monadBind and monadSeq expressions are generated by the MetaSlang parser
  %%  for the "<-" and ";" in forms such as { y <- f x ; z <- g y ; return z }
  %%  ================================================================================

  %op monadBind : [a,b] (Env a) * (a -> Env b) -> Env b
  def monadBind (f, g) =
    fn state ->
      case (f state) of

        %% In the normal case, y is the value that would have been returned
        %%  by f if it had not been written monadically but rather dealt with
        %%  exceptions via side effects or a non-local flow of control.
        %% g accepts that obvious value and produces a new Env (see above),
	%%  which is applied to the hidden state created by the monadic f,
	%%  to produce a new value and state...
	| (Ok        y,      newState) -> (g y newState)

        %%
        %% In the exceptional case, f is not returning a normal value,
        %%  so we stop processing and simply return the exception, along
	%%  with its associated state, without ever looking at g.
        %%
	%% We can't do obvious optimization of | x -> x
        %%  because lhs is Env a and rhs is Env b
	| (Exception except, newState) -> (Exception except, newState)

  %op monadSeq : [a,b] (Env a) * (Env b) -> Env b
  def monadSeq (f, g) = monadBind (f, (fn _ -> g))

  %% ================================================================================
  %%  catch is used at outer levels to process exceptions.
  %%  so that processing can resume normally after the catch.
  %% ================================================================================

   op catch : [a] Env a -> (XML_Exception -> Env a) -> Env a
  def catch f handler =
    fn state ->
      (case (f state) of

        %% For the normal csses, catch is a no-op
        | (Ok        x, newState) -> (Ok x, newState)

	%% In exceptional cases, the handler might be a no-op,
	%% might generate an 'Ok' value with associatd state,
        %% or might return a completely new exception.
        | (Exception x, newState) -> handler x {exceptions =  x::newState.exceptions,
						messages   = newState.messages,
						utext      = newState.utext,
						ge_defs    = newState.ge_defs,
						pe_defs    = newState.pe_defs,
						context    = newState.context})


  %% ================================================================================
  %% Used throughout parser
  %% ================================================================================

  %% Normal control flow -- proceed to next application

  %op return : [a] a -> Env a
  def return x = fn state -> (Ok x, state)

   op when : Bool -> Env () -> Env ()
  def when p command = if p then (fn s -> (command s)) else return ()

   op foldM : [a,b] (a -> b -> Env a) -> a -> List b -> Env a
  def foldM f a l =
    case l of
      | [] -> return a
      | x::xs -> {
            y <- f a x;
            foldM f y xs
          }
   op mapM : [a,b] (a -> Env b) -> (List a) -> Env (List b)
  def mapM f l =
    case l of
      | [] -> return []
      | x::xs -> {
            xNew <- f x;
            xsNew <- mapM f xs;
            return (Cons (xNew,xsNew))
          }

  %% --------------------------------------------------------------------------------
  %%  State -- record global values for entities

  %% The replacement text for parameter entities is only mildly
  %% restricted.  You cannot split tags, comments, etc., but you
  %% could have the first half of an element, or part of an
  %% attribute value, etc.
   op define_parameter_entity : Name * UChars -> Env ()
  def define_parameter_entity (name, uchars) =
    fn state ->
     (Ok (),
      {exceptions = state.exceptions,
       messages   = state.messages,
       utext      = state.utext,
       ge_defs    = state.ge_defs,
       pe_defs    = update (state.pe_defs, name, uchars),
       context    = state.context})

   op get_pe_replacement_text : Name -> Env (Option UChars)
  def get_pe_replacement_text name =
    fn state ->
     (Ok (eval (state.pe_defs, name)),
      state)

  %% The replacement text for general entities must match the
  %% production for "content", so we can store the result of
  %% such a parse.
   op define_general_entity : Name * Content -> Env ()
  def define_general_entity (name, content) =
    fn state ->
     (Ok (),
      {exceptions = state.exceptions,
       messages   = state.messages,
       utext      = state.utext,
       ge_defs    = update (state.ge_defs, name, content),
       pe_defs    = state.pe_defs,
       context    = state.context})

   op get_ge_replacement_content : Name -> Env (Option Content)
  def get_ge_replacement_content name =
    fn state ->
     (Ok (eval (state.ge_defs, name)),
      state)

  %% --------------------------------------------------------------------------------
  %%  Debugging -- normal control flow, but print message as immediate side effect

   op print : String -> Env ()
  def print str =
    fn state ->
      let _ = toScreen str in
      (Ok (), state)

  %% --------------------------------------------------------------------------------
  %%  Debugging -- normal control flow, but print message as immediate side effect
  %%               if tracing flag has been set.

   op start_tracing : () -> Env ()
  def start_tracing _ =
    fn state ->
     (Ok (),
      {exceptions = state.exceptions,
       messages   = state.messages,
       utext      = state.utext,
       ge_defs    = state.ge_defs,
       pe_defs    = state.pe_defs,
       context    = {tracing? = true}})

   op stop_tracing  : () -> Env ()
  def stop_tracing _ =
    fn state ->
     (Ok (),
       {exceptions = state.exceptions,
	messages   = state.messages,
	utext      = state.utext,
	ge_defs    = state.ge_defs,
	pe_defs    = state.pe_defs,
	context    = {tracing? = false}})

   op trace : String -> Env ()
  def trace str =
    fn state ->
      let _ = (if state.context.tracing? then
		 toScreen str
	       else
		 ())
      in
	(Ok (), state)

  %% --------------------------------------------------------------------------------
  %%  Error reporting -- normal control flow, up to a point, but record message for
  %%  delayed processing

   op raise_later : XML_Exception -> Env ()
  def raise_later except =
    fn state ->
     let _ = (if Wizard_Fail_Hard? then
		fail (anyToString except) % under Wizard_Fail_Hard? 
	      else
		())
     in
       (Ok (),
	{exceptions = Cons (except, state.exceptions),
	 messages   = state.messages,
	 utext      = state.utext,
	 ge_defs    = state.ge_defs,
	 pe_defs    = state.pe_defs,
	 context    = state.context})

  %% --------------------------------------------------------------------------------
  %%  Exception handling -- do not process following applications

   op raise_now : [a] XML_Exception -> Env a
  def raise_now except = fn state ->
    let _ =
      if  Wizard_Fail_Hard? then
        fail (anyToString except) % under Wizard_Fail_Hard? 
      else
        ()
    in
      (Exception except, state)

  %% --------------------------------------------------------------------------------

  def         error (x : XML_Exception) : Env () = raise_later x
  def[a] hard_error (x : XML_Exception) : Env a  = raise_now   x

  %% --------------------------------------------------------------------------------

  def Wizard_Fail_Hard? : Bool = false

#translate Haskell -instance Monad XML.Env
  XML.monadBind -> >>=  Left 1
  XML.return -> return
#end

#translate Haskell -morphism Monad
  XML.monadSeq  -> >>   Left 1
  XML.mapM -> mapM
  XML.foldM -> foldM
  XML.when -> when
#end

endspec
