XML qualifying spec

  import ../Utilities/XML_Unicode

  import translate (translate /Library/Structures/Data/Monad/Base
    by {Monad +-> Env})
    by {Monad._ +-> Env._}

  sort Env a = State -> (Result a) * State

  sort Result a =
    | Ok        a
    | Exception XML_Exception

  sort State = {exceptions : List XML_Exception, % for deferred processing
		messages   : List String,
		context    : Processing_Environment}

  def initialState : State =
    {exceptions = [], 
     messages   = [], 
     context    = default_processing_environment}

  sort XML_Exception =
    | EOF         EOF_Error
    | Surprise    Surprise_Error
    | WFC         WFC_Error        % well-formedness condition
    | VC          VC_Error         % validity condition
    | KC          KC_Error         % kestrel well-formedness condition

  def print_XML_Exception (except : XML_Exception) : String =
    "\n\nXML Error: " ^    
    (case except of
       | EOF      x -> print_EOF_Error      x
       | Surprise x -> print_Surprise_Error x
       | WFC      x -> print_WFC_Error      x
       | VC       x -> print_VC_Error       x
       | KC       x -> print_KC_Error       x
       ) ^
       "\n\n"
       
  %% --------------------------------------------------------------------------------

  sort EOF_Error = {context : String,
		    start   : UChars}

  def print_EOF_Error x : String =
    "EOF error" ^ x.context

  %% --------------------------------------------------------------------------------

  sort Surprise_Error = {context  : String,
			 action   : String,
			 expected : List (String * String),
			 start    : UChars,
			 tail     : UChars,
			 peek     : Nat}

  def print_Surprise_Error surprise : String =
    surprise.context ^ ", expected one of" ^
    (foldl (fn (pair, result) -> result ^ pair.1 ^ "(for " ^ pair.2 ^ ")") "" surprise.expected) ^
    surprise.action

  %% --------------------------------------------------------------------------------

  sort WFC_Error  = {description : String}
  def print_WFC_Error x : String =
       "WFC (Well-Formedness Condition): " ^ x.description

  sort VC_Error   = {description : String}
  def print_VC_Error x : String =
       "VC (Validity Condition): " ^ x.description

  sort KC_Error   = {description : String}
  def print_KC_Error x : String =
       "KC (Kestrel-specific well-formedness condition): " ^ x.description

  %% --------------------------------------------------------------------------------

  sort Processing_Environment = {tracing? : Boolean} % could add verbosity, etc.
  def default_processing_environment : Processing_Environment = 
    {tracing? = Trace_XML_Parser?}

  def Trace_XML_Parser? : Boolean = false

  %%  ================================================================================
  %%  monadBind and monadSeq expressions are generated by the MetaSlang parser
  %%  for the "<-" and ";" in forms such as { y <- f x ; z <- g y ; return z }
  %%  ================================================================================

  % sort Monad a = Env a
  % op monadBind : fa (a,b) (Env a) * (a -> Env b) -> Env b
  def monadBind (f, g) =
    fn state -> 
      case (f state) of

        %% In the normal case, y is the value that would have been returned 
        %%  by f if it had not been written monadically but rather dealt with 
        %%  exceptions via side effects or a non-local flow of control.
        %% g accepts that obvious value and produces a new Env (see above), 
	%%  which is applied to the hidden state created by the monadic f, 
	%%  to produce a new value and state...
	| (Ok        y,      newState) -> (g y newState)

        %%
        %% In the exceptional case, f is not returning a normal value,
        %%  so we stop processing and simply return the exception, along 
	%%  with its associated state, without ever looking at g.
        %%
	%% We can't do obvious optimization of | x -> x 
        %%  because lhs is Env a and rhs is Env b
	| (Exception except, newState) -> (Exception except, newState)

  % op monadSeq : fa (a,b) (Env a) * (Env b) -> Env b
  def monadSeq (f, g) = monadBind (f, (fn _ -> g))

  %% ================================================================================
  %%  catch is used at outer levels to process exceptions.
  %%  so that processing can resume normally after the catch.
  %% ================================================================================

  op catch : fa (a) Env a -> (XML_Exception -> Env a) -> Env a
  def catch f handler =
    fn state ->
      (case (f state) of

        %% For the normal csses, catch is a no-op
        | (Ok        x,      newState) -> (Ok x, newState)

	%% In exceptional cases, the handler might be a no-op,
	%% might generate an 'Ok' value with associatd state,
        %% or might return a completely new exception.
        | (Exception except, newState) -> handler except newState)

  %% ================================================================================
  %% Used throughout parser
  %% ================================================================================

  %% Normal control flow -- proceed to next application

  % op return : fa (a) a -> Env a
  def return x = fn state -> (Ok x, state)

   op when : Boolean -> Env () -> Env ()
  def when p command = if p then (fn s -> (command s)) else return ()

  op foldM : fa (a,b) (a -> b -> Env a) -> a -> List b -> Env a
  def foldM f a l =
    case l of
      | [] -> return a
      | x::xs -> {
            y <- f a x;
            foldM f y xs
          }
  op mapM : fa (a,b) (a -> Env b) -> (List a) -> Env (List b)
  def mapM f l =
    case l of
      | [] -> return []
      | x::xs -> {
            xNew <- f x;
            xsNew <- mapM f xs;
            return (Cons (xNew,xsNew))
          }

  %% --------------------------------------------------------------------------------
  %%  Debugging -- normal control flow, but print message as immediate side effect


   op trace : String -> Env ()
  % def trace str = return ()  % change to print when needed.
  def trace str = 
    fn state ->
      let _ = (if state.context.tracing? then
		 toScreen str 
	       else
		 ())
      in
	(Ok (), state)

  op print : String -> Env ()
  def print str =
    fn state ->
      let _ = toScreen str in
      (Ok (), state)

  %% --------------------------------------------------------------------------------
  %%  Error reporting -- normal control flow, up to a point, but record message for
  %%  delayed processing

   op raise_later : XML_Exception -> Env ()
  def raise_later except = 
    fn state -> 
     let _ = (if Wizard_Fail_Hard? then
		fail (System.toString except)
	      else
		())
     in
       (Ok (),
	{exceptions = cons (except, state.exceptions),
	 messages   = state.messages,
	 context    = state.context})

  %% --------------------------------------------------------------------------------
  %%  Error reporting -- normal control flow, up to a point, but record message for
  %%  delayed processing

  op start_tracing : () -> Env ()
  def start_tracing _ =
    fn state ->
     (Ok (),
      {exceptions = state.exceptions,
       messages   = state.messages,
       context    = {tracing? = true}})

  op stop_tracing  : () -> Env ()
  def stop_tracing _ =
    fn state ->
     (Ok (),
       {exceptions = state.exceptions,
	messages   = state.messages,
	context    = {tracing? = false}})

  %% --------------------------------------------------------------------------------
  %%  Exception handling -- do not process following applications

   op stop_parsing : fa (a) XML_Exception -> Env a
  def stop_parsing except = raise_now except

   op raise_now : fa (a) XML_Exception -> Env a
  def raise_now except = fn state -> 
    let _ =
      if  Wizard_Fail_Hard? then
        fail (System.toString except)
      else
        ()
    in
      (Exception except, state)

  
  def error x : Env () = raise_later x
  def fa(a) hard_error x : Env a  = raise_now   x

  %% --------------------------------------------------------------------------------


  def Wizard_Fail_Hard? : Boolean = false

endspec