XML qualifying spec

  import ../Utilities/XML_Unicode

  import translate (translate /Library/Structures/Data/Monad/Base
    by {Monad +-> Env})
    by {Monad._ +-> Env._}

  sort Env a = State -> (Result a) * State

  sort Result a =
    | Ok        a
    | Exception XML_Exception

  sort State = {exceptions : List XML_Exception, % for deferred processing
		messages   : List String,
		context    : Processing_Environment}

  def initialState : State =
    {exceptions = [], 
     messages   = [], 
     context    = default_processing_environment}

  sort XML_Exception =
    | EOF       String * Region
    | Syntax    String * Region
    | Name      String * Region
    | Value     String * Region
    | Validity  String * Region
    | Style     String * Region
    | Comment   String * Region
    | WFC       String * Region
    | VC        String * Region

  sort Region = {start : UChars,
		 stop  : UChars}

  def print_XML_Exception (except : XML_Exception) : String =
    case except of
      | EOF      (msg, _) -> "Unexpected end of file: "  ^ msg
      | Syntax   (msg, _) -> "Syntax error: "            ^ msg
      | Name     (msg, _) -> "Naming error: "            ^ msg
      | Value    (msg, _) -> "Value error: "             ^ msg
      | Validity (msg, _) -> "Invalid form: "            ^ msg
      | Style    (msg, _) -> "Stylistic issue: "         ^ msg
      | Comment  (msg, _) -> "Note:"                     ^ msg
      | WFC      (msg, _) -> "WFC:"                      ^ msg
      | VC       (msg, _) -> "VC:"                       ^ msg
      | _                 -> "Unknown exception"

  sort Processing_Environment = {tracing? : Boolean} % could add verbosity, etc.
  def default_processing_environment : Processing_Environment = 
    {tracing? = Trace_XML_Parser?}

  def Trace_XML_Parser? : Boolean = false

  %%  ================================================================================
  %%  monadBind and monadSeq expressions are generated by the MetaSlang parser
  %%  for the "<-" and ";" in forms such as { y <- f x ; z <- g y ; return z }
  %%  ================================================================================

  % sort Monad a = Env a
  % op monadBind : fa (a,b) (Env a) * (a -> Env b) -> Env b
  def monadBind (f, g) =
    fn state -> 
      case (f state) of

        %% In the normal case, y is the value that would have been returned 
        %%  by f if it had not been written monadically but rather dealt with 
        %%  exceptions via side effects or a non-local flow of control.
        %% g accepts that obvious value and produces a new Env (see above), 
	%%  which is applied to the hidden state created by the monadic f, 
	%%  to produce a new value and state...
	| (Ok        y,      newState) -> (g y newState)

        %%
        %% In the exceptional case, f is not returning a normal value,
        %%  so we stop processing and simply return the exception, along 
	%%  with its associated state, without ever looking at g.
        %%
	%% We can't do obvious optimization of | x -> x 
        %%  because lhs is Env a and rhs is Env b
	| (Exception except, newState) -> (Exception except, newState)

  % op monadSeq : fa (a,b) (Env a) * (Env b) -> Env b
  def monadSeq (f, g) = monadBind (f, (fn _ -> g))

  %% ================================================================================
  %%  catch is used at outer levels to process exceptions.
  %%  so that processing can resume normally after the catch.
  %% ================================================================================

  op catch : fa (a) Env a -> (XML_Exception -> Env a) -> Env a
  def catch f handler =
    fn state ->
      (case (f state) of

        %% For the normal csses, catch is a no-op
        | (Ok        x,      newState) -> (Ok x, newState)

	%% In exceptional cases, the handler might be a no-op,
	%% might generate an 'Ok' value with associatd state,
        %% or might return a completely new exception.
        | (Exception except, newState) -> handler except newState)

  %% ================================================================================
  %% Used throughout parser
  %% ================================================================================

  %% Normal control flow -- proceed to next application

  % op return : fa (a) a -> Env a
  def return x = fn state -> (Ok x, state)

   op when : Boolean -> Env () -> Env ()
  def when p command = if p then (fn s -> (command s)) else return ()

  op foldM : fa (a,b) (a -> b -> Env a) -> a -> List b -> Env a
  def foldM f a l =
    case l of
      | [] -> return a
      | x::xs -> {
            y <- f a x;
            foldM f y xs
          }
  op mapM : fa (a,b) (a -> Env b) -> (List a) -> Env (List b)
  def mapM f l =
    case l of
      | [] -> return []
      | x::xs -> {
            xNew <- f x;
            xsNew <- mapM f xs;
            return (Cons (xNew,xsNew))
          }

  %% --------------------------------------------------------------------------------
  %%  Debugging -- normal control flow, but print message as immediate side effect


   op trace : String -> Env ()
  % def trace str = return ()  % change to print when needed.
  def trace str = 
    fn state ->
      let _ = (if state.context.tracing? then
		 toScreen str 
	       else
		 ())
      in
	(Ok (), state)

  op print : String -> Env ()
  def print str =
    fn state ->
      let _ = toScreen str in
      (Ok (), state)

  %% --------------------------------------------------------------------------------
  %%  Error reporting -- normal control flow, up to a point, but record message for
  %%  delayed processing

   op raise_later : XML_Exception -> Env ()
  def raise_later except = 
    fn state -> 
     let _ = (if Wizard_Fail_Hard? then
		fail (System.toString except)
	      else
		())
     in
       (Ok (),
	{exceptions = cons (except, state.exceptions),
	 messages   = state.messages,
	 context    = state.context})

  %% --------------------------------------------------------------------------------
  %%  Error reporting -- normal control flow, up to a point, but record message for
  %%  delayed processing

  op start_tracing : () -> Env ()
  def start_tracing _ =
    fn state ->
     (Ok (),
      {exceptions = state.exceptions,
       messages   = state.messages,
       context    = {tracing? = true}})

  op stop_tracing  : () -> Env ()
  def stop_tracing _ =
    fn state ->
     (Ok (),
       {exceptions = state.exceptions,
	messages   = state.messages,
	context    = {tracing? = false}})

  %% --------------------------------------------------------------------------------
  %%  Exception handling -- do not process following applications

   op stop_parsing : fa (a) XML_Exception -> Env a
  def stop_parsing except = raise except

   op raise : fa (a) XML_Exception -> Env a
  def raise except = fn state -> 
    let _ =
      if  Wizard_Fail_Hard? then
        fail (System.toString except)
      else
        ()
    in
      (Exception except, state)


  def fa(a) error (msg : String, start : UChars, stop : UChars) : Env a =
    raise (Syntax (msg, {start = start, stop = stop}))

  %% --------------------------------------------------------------------------------


  def Wizard_Fail_Hard? : Boolean = false

endspec