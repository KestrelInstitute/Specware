XML qualifying spec

  import translate (translate /Library/Structures/Data/Monad/Base
    by {Monad +-> Env})
    by {Monad._ +-> Env._}

  import XML_Exceptions

  sort Env a = State -> (Result a) * State

  sort Result a =
    | Ok        a
    | Exception XML_Exception

  %%  ================================================================================
  %%  monadBind and monadSeq expressions are generated by the MetaSlang parser
  %%  for the "<-" and ";" in forms such as { y <- f x ; z <- g y ; return z }
  %%  ================================================================================

  % sort Monad a = Env a
  % op monadBind : fa (a,b) (Env a) * (a -> Env b) -> Env b
  def monadBind (f, g) =
    fn state -> 
      case (f state) of

        %% In the normal case, y is the value that would have been returned 
        %%  by f if it had not been written monadically but rather dealt with 
        %%  exceptions via side effects or a non-local flow of control.
        %% g accepts that obvious value and produces a new Env (see above), 
	%%  which is applied to the hidden state created by the monadic f, 
	%%  to produce a new value and state...
	| (Ok        y,      newState) -> (g y newState)

        %%
        %% In the exceptional case, f is not returning a normal value,
        %%  so we stop processing and simply return the exception, along 
	%%  with its associated state, without ever looking at g.
        %%
	%% We can't do obvious optimization of | x -> x 
        %%  because lhs is Env a and rhs is Env b
	| (Exception except, newState) -> (Exception except, newState)

  % op monadSeq : fa (a,b) (Env a) * (Env b) -> Env b
  def monadSeq (f, g) = monadBind (f, (fn _ -> g))

  %% ================================================================================
  %%  catch is used at outer levels to process exceptions.
  %%  so that processing can resume normally after the catch.
  %% ================================================================================

  op catch : fa (a) Env a -> (XML_Exception -> Env a) -> Env a
  def catch f handler =
    fn state ->
      (case (f state) of

        %% For the normal csses, catch is a no-op
        | (Ok        x, newState) -> (Ok x, newState)

	%% In exceptional cases, the handler might be a no-op,
	%% might generate an 'Ok' value with associatd state,
        %% or might return a completely new exception.
        | (Exception x, newState) -> handler x {exceptions = cons (x, newState.exceptions),
						messages   = newState.messages,
						utext      = newState.utext,
						context    = newState.context})


  %% ================================================================================
  %% Used throughout parser
  %% ================================================================================

  %% Normal control flow -- proceed to next application

  % op return : fa (a) a -> Env a
  def return x = fn state -> (Ok x, state)

   op when : Boolean -> Env () -> Env ()
  def when p command = if p then (fn s -> (command s)) else return ()

  op foldM : fa (a,b) (a -> b -> Env a) -> a -> List b -> Env a
  def foldM f a l =
    case l of
      | [] -> return a
      | x::xs -> {
            y <- f a x;
            foldM f y xs
          }
  op mapM : fa (a,b) (a -> Env b) -> (List a) -> Env (List b)
  def mapM f l =
    case l of
      | [] -> return []
      | x::xs -> {
            xNew <- f x;
            xsNew <- mapM f xs;
            return (Cons (xNew,xsNew))
          }

  %% --------------------------------------------------------------------------------
  %%  Debugging -- normal control flow, but print message as immediate side effect


   op trace : String -> Env ()
  % def trace str = return ()  % change to print when needed.
  def trace str = 
    fn state ->
      let _ = (if state.context.tracing? then
		 toScreen str 
	       else
		 ())
      in
	(Ok (), state)

  op print : String -> Env ()
  def print str =
    fn state ->
      let _ = toScreen str in
      (Ok (), state)

  %% --------------------------------------------------------------------------------
  %%  Error reporting -- normal control flow, up to a point, but record message for
  %%  delayed processing

   op raise_later : XML_Exception -> Env ()
  def raise_later except = 
    fn state -> 
     let _ = (if Wizard_Fail_Hard? then
		fail (System.toString except)
	      else
		())
     in
       (Ok (),
	{exceptions = cons (except, state.exceptions),
	 messages   = state.messages,
	 utext      = state.utext,
	 context    = state.context})

  %% --------------------------------------------------------------------------------
  %%  Error reporting -- normal control flow, up to a point, but record message for
  %%  delayed processing

  op start_tracing : () -> Env ()
  def start_tracing _ =
    fn state ->
     (Ok (),
      {exceptions = state.exceptions,
       messages   = state.messages,
       utext      = state.utext,
       context    = {tracing? = true}})

  op stop_tracing  : () -> Env ()
  def stop_tracing _ =
    fn state ->
     (Ok (),
       {exceptions = state.exceptions,
	messages   = state.messages,
	utext      = state.utext,
	context    = {tracing? = false}})

  %% --------------------------------------------------------------------------------
  %%  Exception handling -- do not process following applications

   op stop_parsing : fa (a) XML_Exception -> Env a
  def stop_parsing except = raise_now except

   op raise_now : fa (a) XML_Exception -> Env a
  def raise_now except = fn state -> 
    let _ =
      if  Wizard_Fail_Hard? then
        fail (System.toString except)
      else
        ()
    in
      (Exception except, state)

  
  def            error (x : XML_Exception) : Env () = raise_later x
  def fa(a) hard_error (x : XML_Exception) : Env a  = raise_now   x

  %% --------------------------------------------------------------------------------


  def Wizard_Fail_Hard? : Boolean = false

endspec