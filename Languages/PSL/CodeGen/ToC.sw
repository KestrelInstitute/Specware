SpecCalc qualifying spec {
  import Convert
  %import ../../MetaSlang/CodeGen/C/ToC
  import ../../MetaSlang/CodeGen/C/CG
  %import ../../MetaSlang/CodeGen/CodeGenTransforms
  import /Languages/PSL/Semantics/Evaluate/Specs/Op/Legacy
  import CGenUtils

  % sort Spec.Spec = ASpec Position

  op oscarToC : Oscar.Spec -> Spec.Spec -> Env CSpec
  def oscarToC oscSpec base =
    let oscSpec = mapOscarSpec (fn(spc) -> (identifyIntSorts (subtractSpec spc base))) oscSpec in
    %let _ = writeLine("initial envSpec="^(printSpec (specOf oscSpec.modeSpec))) in
    let missing = foldlSpecsOscarSpec (fn(spc,missing) ->
				       let spc = transformSpecForCodeGen base spc in
				       mergeSpecs(spc,missing)
				      ) emptySpec oscSpec in
    %let _ = writeLine("missing from base: "^(printSpec missing)) in
    %let oscSpec = mapOscarSpec (fn(spc) -> transformSpecForCodeGen base spc) oscSpec in
    let cSpec = emptyCSpec("") in
    %let envSpec = specOf oscSpec.modeSpec in
    %let _ = writeLine("envSpec="^printSpec(envSpec)) in
    %let envSpec = subtractSpec (specOf oscSpec.modeSpec) base in
    %let cSpec = generateCSpecFromTransformedSpec envSpec in
    {
      %envSpec <- return (transformSpecForCodeGen base envSpec);
      oscSpec <- return (mapOscarSpec (fn(spc) -> transformSpecForCodeGen base spc) oscSpec);
      envSpec <- return (specOf oscSpec.modeSpec);
      print("envSpec="^(printSpec envSpec));
      cSpec <- generateCSpecFromTransformedSpecEnv envSpec;
      cSpec <- ProcMapEnv.fold (generateCProcedure envSpec) cSpec oscSpec.procedures;
      cSpec <- ProcMapEnv.fold delFnDeclForProc cSpec oscSpec.procedures;
      printToFileEnv(cSpec,None);
      %(fail "success"; % useful during development; forces re-elaboration of any example spec
       return cSpec
      %)
    }

  (**
   * removes the "internal" entries from the mode spec and keeps the ones that have to be
   * add to the cspec.
   *)

  op cleanupModeSpec: Spec.Spec * List Op.Ref -> Spec.Spec
  def cleanupModeSpec(spc,parameters) =
    let
      def filterOut(q,id) =
	if member(Qualified(q,id),parameters) then true
	else
	  let expl = explode(id) in
	  if hd(rev(expl)) = #' then true
	    else q = "#return#"
    in
    let srts = foldriAQualifierMap
               (fn(q,id,sinfo,map) ->
		if filterOut(q,id) then map
		else insertAQualifierMap(map,q,id,sinfo)
	       ) emptyASortMap spc.sorts
    in
    let ops = foldriAQualifierMap
               (fn(q,id,sinfo,map) ->
		if filterOut(q,id) then map
		else insertAQualifierMap(map,q,id,sinfo)
	       ) emptyAOpMap spc.ops
    in
    let spc = setSorts(spc,srts) in
    let spc = setOps(spc,ops) in
    let spc = setProperties(spc,[]) in
    spc

  op delFnDeclForProc : CSpec -> Id.Id -> Procedure -> Env CSpec
  def delFnDeclForProc cspc procId procedure =
    return (delFn(cspc,showQualifiedId procId))

  op generateCProcedure : Spec.Spec -> CSpec -> Id.Id -> Procedure -> Env CSpec
  def generateCProcedure envSpec cSpec procId (procedure as {parameters,varsInScope,returnInfo,modeSpec,bSpec}) =
    let mmspc = mergeModeSpecs procedure in
    %let mmspc = subtractSpec mmspc envSpec in
    let mmspc = cleanupModeSpec(mmspc,parameters) in
    %let _ = writeLine("proc "^(printQualifiedId procId)^", merged mode-spec="^(printSpec mmspc)) in
    let mmspc = transformSpecForCodeGenNoAdd mmspc in
    let mcspc = generateCSpecFromTransformedSpec(mmspc) in
    %let cSpec = mergeCSpecs([cSpec,mcspc]) in
    %let cSpec = delFn(cSpec,showQualifiedId procId) in
    let initSpec = Mode.modeSpec (initial bSpec) in
    let varDecls =
      List.map (fn argRef ->
		let spc = specOf initSpec in
		let (names,fxty,(tyVars,srt),_) = Op.deref (spc, argRef) in
		(OpRef.show argRef, sortToCType cSpec spc srt))
                parameters
    in
    let returnType =
      case returnInfo of
        | None -> Void 
        | Some retRef ->
	    let spc = specOf initSpec in
            let (names,fixity,(tyVars,srt),_) = Op.deref (spc, retRef) in
	    sortToCType cSpec spc srt
    in
    let def handler id procedure except =
      case except of
        | SpecError (pos, msg) -> {
             print ("convertOscarSpec exception:" ^ msg ^ "\n");
             procDoc <- ProcEnv.pp id procedure;
             print (ppFormat procDoc);
             print "\n";
             raise (SpecError (pos, "except : " ^ msg))
           }
        | _ -> raise except
    in {
      print (";;            procedure: " ^ (Id.show procId) ^ "\n");
      graph <- catch (convertBSpec bSpec) (handler procId procedure);
      graph <- catch (structGraph graph) (handler procId procedure);
      %print(printGraph(graph));
      procStmt <- return (graphToC envSpec graph);
      return (addFnDefnOverwrite(cSpec,(showQualifiedId procId,varDecls,returnType,procStmt)))
    }

  op nodeContent : Node -> NodeContent
  def nodeContent (index,content,predecessors) = content
\end{spec}

The following is meant to take a structured graph, as generated by convertBSpec into
a C abstract syntax tree. As far as I know, this does not handle breaks and continues
with a loop or out of a conditional.

\begin{spec}
  op graphToC : Spec.Spec -> Struct.Graph -> Stmt
  def graphToC envSpec graph =
    let cspc = emptyCSpec("") in
    let def consume first last =
      if first = ~1 then
        ReturnVoid
      else if first = last then
        Nop
      else
        % let _ = writeLine ("first = " ^ (Nat.toString first) ^ " last = " ^ (Nat.toString last)) in
          case nodeContent (nth (graph, first)) of
            | Block {statements, next} -> 
                let stmts = map statementToC statements in
                reduceStmt stmts (consume next last) 

            | Return (spc,term) -> termToCStmtNew spc term % Return (termToCExp term)

            | IfThen {condition, trueBranch, cont} ->
		let (spc,condition) = condition in
                let stmt = IfThen (termToCExp cspc spc condition, consume trueBranch cont) in
                let rest = consume cont last in
                reduceStmt [stmt] rest

            | IfThenElse {condition, trueBranch, falseBranch, cont} ->
		let (spc,condition) = condition in
                let trueStmt = consume trueBranch cont in
                let falseStmt = consume falseBranch cont in
                let ifStmt = If (termToCExp cspc spc condition, trueStmt, falseStmt) in
                let rest = consume cont last in
                reduceStmt [ifStmt] rest

            | Loop {condition, preTest?, body, cont} ->
		let (spc,condition) = condition in
                let bodyStmt = consume body first in
                let whileStmt = While (termToCExp cspc spc condition, bodyStmt) in
                let rest = consume cont last in
                reduceStmt [whileStmt] rest

            | Branch {condition, trueBranch, falseBranch} ->
		let (spc,condition) = condition in
                let _ = writeLine ("ignoring branch") in
                Nop

      def reduceStmt stmts s2 =
        case s2 of
          | Block ([],moreStmts) -> Block ([],stmts ++ moreStmts)
          | Nop -> Block ([],stmts)
          | _ -> Block ([],stmts ++ [s2])

      def statementToC stat =
        case stat of
          | Assign (spc,term) -> termToCStmtNew spc term
          | Proc (spc,term) -> termToCStmtNew spc term
          | Return (spc,term) -> termToCStmtNew spc term
    in
      if graph = [] then
        Nop
      else
        consume 0 (length graph)

  op termToCStmtNew : Spec.Spec -> MS.Term -> CStmt
  def termToCStmtNew spc term =
    let cspc = emptyCSpec("") in
    case term of
      | Apply (Fun (Equals,srt,_), Record ([("1",lhs), ("2",rhs)],_), _) ->
          (case lhs of
            | Fun (Op (Qualified (_,"ignore'"),fxty),srt,pos) -> (Exp (termToCExp cspc spc rhs))
            | Fun (Op (Qualified ("#return#",variable),fxty),srt,pos) -> (Return (termToCExp cspc spc rhs))
            | _ ->
              (case rhs of
                | Apply(Apply (Apply (Fun (Op (Qualified (_,"update"),fxty),_,pos), Fun (Op (Qualified (_,"active"),fxty),srt,_),  _), idx,_),expr,_) ->
                      Exp (Binary(Set,ArrayRef (Var ("active",sortToCType cspc spc srt), termToCExp cspc spc idx),termToCExp cspc spc expr))
                | Apply (Fun (Op (Qualified (_,"update"),fxty),srt,pos), Record ([("1",Fun (Op (Qualified (_,"env"),fxty),_,_)), ("2",Fun (Nat n,_,_)), ("3",expr)],_), _) ->
                    if n = 0 then
                      Exp (Binary(Set,Unary(Contents,Var ("sp",sortToCType cspc spc srt)),termToCExp cspc spc expr))
                    else
                      Exp (Binary(Set,Unary(Contents,
                          Binary(Add,Var ("sp",sortToCType cspc spc srt), Const (Int (true,n)))), termToCExp cspc spc expr))
                | _ -> Exp (Binary(Set,termToCExp cspc spc lhs, termToCExp cspc spc rhs))))
      | Apply (Fun (Op (procId,fxty),procSort,pos),(Record ([(_,argTerm),(_,returnTerm),(_,storeTerm)],_)),pos) ->
          % let (Record ([(_,argTerm),(_,returnTerm),(_,storeTerm)],_)) = callArg in
          (case returnTerm of
            | Record ([],_) ->
                (Exp (termToCExp cspc spc (Apply (Fun (Op (procId,fxty),procSort,pos),argTerm,pos))))
            | Fun (Op (Qualified ("#return#",variable),fxty),srt,pos) ->
                (Return (termToCExp cspc spc (Apply (Fun (Op (procId,fxty),procSort,pos),argTerm,pos))))
            | _ -> (Exp (Binary(Set,termToCExp cspc spc returnTerm,
				termToCExp cspc spc (Apply (Fun (Op (procId,fxty),procSort,pos),argTerm,pos))))))
      | _ -> % let _ = writeLine ("termToCStmt: ignoring term: " ^ (printTerm term)) in
         Nop

}
\end{spec}

Note that the second argument to "consume" above is an index greater
beyond the end of the array. This is deliberate. We could used
infinity. We will not get there as we must encounter a Return first. The
point is that the "consume" function will continue up to but not including
the "last" node.
