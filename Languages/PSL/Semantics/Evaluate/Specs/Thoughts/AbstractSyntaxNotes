Idea is to have a different form of abstract syntax that
is amenable to labelling the graph with, fragments of code.

Can we do it now?

Want to label each vertex with the code something like a coalgebra

take exp example

  proc expp (x : Nat, y : Nat) : Nat {
  let
    var z : Nat
  in {
    z := 1;
    do {
        ~(y = 0) ->
            do {
                even y -> 
                  x := x * 2;
                  y := y div 2
            };
            y := y - 1;
            z := z * x
     };
     return z
  }}


first point labeled with entire program but suppose we create a label that records the end
of the scope
second point labelled with

sort CABS = Block * Cont
sort Block = 
  | Let Decls * Body
  | While Alts 
  | If Alts

what would happen if we were to get the vertices by partial evaluation.

So that point is that for psl, it would mean that we could use bits of abstract syntax
for the vertices (and edges?) of the graph and thereby perhaps preserve the
structuring information so that restructuring may become unnecessary.
Also may reduce some of the inlining. Is there two passes to parsing?

It means redoing the code generator once again.

What happens when the language is more like idealized algol with active expressions?

How do we get the abstract syntax in the first place? It must be a map cause
with while loops it will be non-well-founded.

Map Term -> Collection (Step * Term)

The term in the target will typically be a subterm of what we started with

Step is either a guard or an assignment (and a return) or an unconditional jump.
maybe an alloc as well.


So try while

while alts exit

but what if the loop contains a continue its continuation would be a term that contains itself
so we need variables for the loops. Is there a distinction between the end of a loop and a
continue? Is there simply an implicit continue at the end of every alternative?

Do label alts cont
If alts cont
Let decls body 
Nil
Assign term cont
Call procExpr cont
Jump label

Actions:
guard
assign
call
alloc
jump
should there be a dealloc as well?

So what are the successors of the do
alt1 to alt n plus an if otherwise to the cont.

So we don't really need a map but rather just a map for the labels.

what are the successors of let alloc transitions to body each
body already has its successor why does the let need a successor

Yes we want a cont for a let to indicate the scope of the let.
similarly we might the limit for a do and for an if

how do we parse to construct such a thing.

concat prog1 prog2
could be used to traverse the structure and replace prog2 wherever there is nil in prog 1.
So for parsing we need the continuation before we can do a command.

parse (do alts; commands) cont
new var we allocate a var
cont = parse commands cont
parse do-alts with var in the context of the cont

would also probably want to jump out of an outer loop or break as in java

Probably don't need this way of doing the abstract syntax as when we
partial evaluate the vertices will not only be fragments of syntax, but
also context. Eg where did we enter an if or a loop. So the information
that we carry in the syntax that is meant to be there to recover the
structure. Might persist either way.
