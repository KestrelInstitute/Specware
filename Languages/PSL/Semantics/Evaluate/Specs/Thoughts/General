There is an issue of how to handle imports. The point about imports
is that they have been typechecked. Hence, when they are imported,
they need not be checked again. 

One option might be to associate a flag with the opInfo to reflect whether the
op has been typeChecked. This could be a mutable variable. Might be better to associate
the flag with a term.

There is also the question of what to do about multiple definitions.
I have two imports, each with the definition, what should happen?
The point is that the ops have sorts that refer to defined sorts. 
So def1 refers to sort srt1 in spec1 and def2 refers to srt2 in spec2.
Should we check eagerly that the definitions are consistent. Or
do we treat things like we do typechecking where we put everything
in and then run through later on to see if there is an
inconsistency and reduce things as much as possible.

If we do it along the way, then addOp needs to take two specs as arguments

importOp targetSpec impSpec opInfo

then we don't need a flag.

Think about getting rid of resetGlobals in Specware.

The problem with the following os
Think about adding single threaded versions of the
functions for building specs.

sv <- newSpecVar empty
 or just 
sv <- newSpecVar
addOp sv opInfo
addSort sv sortInfo
etc
so they don't return a new spec

alternatively we add a current spec to the state monad

setCurrentSpec (some spec)

addOp opInfo
addSort opInfo

etc.

Perhaps the former way means that all the specs can be implemented with side
effecting operations and hash tables and whatnot.

When outside the monad, then the spec is implemented without side effects
inside, we can use side effects.

Would it also make sense for opInfo and even for terms as we might
want to transform a term in place? Would only make sense for
terms in the absence of sharing of opInfo between different specs.
Otherwise rewriting might have undesirable side-effects. Might work
for type checking when we want to side-effect a term by augmenting it
with more type information.

Perhaps the term type should be

sort Extend a 
op child : Extend a -> a
sort Term =
  Extend
    | ApplyN ..
    | Fun ...

sort Extend a = a
sort Extend a = a * Position
sort Extend a = Var (a * Position)

The latter is so we can do update in place when rewriting terms.

Can we get the effect of Extend by rewriting?
Or by weakening (a sort) in some way?

What about jims idea of mixing .. starting off as assoc lists and
then switching when everything is in place. 
Not sure it works for what we are doing.

There is inconsitency. In some cases there is union that is curried
and in other place it is not.

What is it Env.Env in some places and SpecCalc.Env elsewhere?

There seems to be an import bug.

I mistakenly used the same qualifier (Vertex and Edge) for 
Sets/Monomorphic and Sets/Finite. Some functions refer to Edge.pp 
and Vertex.pp, but these get mapped to the set pp functions rather
than the element functions.

There is excessive qualification of OpInfo and Id in Op, Sort, Spec etc.
This is because we import Env which imports Exception from the SpecCalc
which in turn imports the pretty printer for the SpecCalc (for unitId)
which in turn imports AnnSpec. Hopefully many of these qualifiers can
be eliminated when things get factored a little more cleanly.

Why is it that op refences start out as OneName and TwoName and then
changed to QualifiedId but sort references start out as QualifiedId.

Stephen has made a good point. Even if you want to assign each op an id,
then you might want to ensure that the ids are unique across the
whole session. That way if you import an op, you don't have to
rename or reindex things.

What about rules for qualifying?

Should the writer of a spec or a user of a spec qualify a spec or both?

Id imports Sets qualified Sets imports Elem. Elem is qualified.
are unqualified.
Env imports Collections unqualified. Should really qualify the Collection by
IdSet in the same way that Sets get qualified with IdSet.


Could there be an even more abstract version where instead of
tying ourselves to projection operations we use maps

sort Op

op names : Op -> IdSet.Set

but now we want a map

op names : Map (Op,IdSet.Id)


op names : Spec -> Map (Op,IdSet.Id)

Suppose a term resolves to an operator reference.

So a term contains an Op .. say an identitier. Then by the above, there is one
map from Op to a set of Ids. Updating that map is enough and we don't need the OpRef
stuff.

In the above, there is only one such map. An op must be unique across the entire system.

An alternative is to make it indexed on the spec.

Map (Spec,Map(Op,IdSet)) where the Op should be dependent on the Spec .. that
is we should only be able to look up ops that are in the spec.

Bear in mind that with every Map comes an Eval. I suppose if we have:

op names : Map(Op,IdSet.Id)

then we could define

def Eval.names x : Op -> IdSet.Id = eval names x

This doesn't make sense. Names must be something that gets carried around.


Should I be able to create an OpInfo outside the scope of a spec?

There is an inconsistency .. some things like refOf are monadic and specOf is not.

