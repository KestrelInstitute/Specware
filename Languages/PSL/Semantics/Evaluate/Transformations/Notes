
       procType <- mkBase (makeId "Proc", [argProd,toType procInfo.returnSort,storeProd], position); 
       procId <- return (makeId procName);
       procOp <- makeOp (procId, procType);
       modeSpec <- addOp (modeSpec oscarSpec) procOp position;
       oscarSpec <- return (oscarSpec withModeSpec modeSpec);

       newState <- specializeProcedure oscSpec procId procInfo subst state

       argSortPairs <- zip (argList,paramSortList);

                       so now we want to create the replacement axiom for the state.

                        for now we keep all the global state as it was.
                        so no we look to the initial modeSpec and take all the ops that are
                        not ground.
                        for the return type we look to the final spec and if the
                        returnName is hidden then
                          1) we bind the return term to it and
                              returnTerm' = value bound to return#name
                                the paradox is that it is now hidden?!
                          2) we set the return info to None for the new procedure.

                        if it is not hidden and hence not ground
                          return info remains the same

                        look to the variables in the final modeSpec indexed by the variable
                        names in the mode spec for the procedure. for each of those that is
                        ground construct a x' = ground value equation

                        the arguments to the new procedure are those arguments that were not ground
                        in the initial state of the called procedure. order is important
                        the new call term is the old call are the positions! in the call term
                        corresponding to non-ground terms
                         
we would like to make it easy to create a substitution

the problem is that at this point we may have lost the names of the store data
and can't recover them .. in general if we apply a substitution to a spec
and simplify then a definition with no associated term will not be rewritten!

perhaps it will.

suppose we have the constraint that z' = z, then a substitution for z, does
not give rise to a definition of z' .. the equality is not propagated!

The only time such things come up is in axiom statement and 

what about function bindings? .. we are converting these to updates.

eval f' x = t => f' = update f x t

so can we assume that all simple equality's are expressed as definitions?
But which way do they go? Not a problem.

But suppose I have an axiom denoting a guard?

x = 4

Well I suppose after reduction, the predicate may or may not remain. If it remains
then it is an assumption so we can take it.
                        

                        (case arg of
                           | Record (fields,pos) ->
                           | _ -> ))
             | _ -> return (transSpec,state))
      | _ -> raise (SpecError (noPos, "Transition spec has multiple axioms"))

                    let (Base (procSortId, [paramSort,rtnSort,storeSort])) = procSort in
                    let paramSortList =
                      case paramSort of
                        | Product (fields,_) -> fields
                        | _ -> [paramSort] in
                    

                  add the term as an axiom to the oscar spec (the problem is that these are not
                      immediately imported into the new modeSpecs. should really be added to all specs
                      may need to pull out bindings from the term and make them into rewrites.
                        need to be careful with rewrites not to apply them in a context that
                        captures names. eg x = 4 where there is a local x.
                        should really been deposited in every spec but not practical to do so.
we are carrying a static spec around really just a collection of axioms .. what do we do with it .. it is for
procedures and nothing else at this stage but these constraints really belong in the
mode spec. but if we add it to the transition spec .. then it will persist after!
perhaps we should carry around a collection of rewrite rules instead!
                  
             identify the new and old procedures
             identify the return variable with the return term (if there is on)
             identify the state variables with the state values if any
             construct a new trans spec like the previous one but with the new axiom in place
               of the old one and appropriate things hidden 
             perhaps what is returned is the term in question

             | (Axiom, ) ->

  op projectPostCondition : TransSpec -> Env Subst.Subst
  def projectPostCondition transSpec =
    let changed = changedVars (backMorph transSpec) in
    foldl (fn subst -> fn varRef -> {
        varInfo <-
          if member? (changed,varRef) then
            findTheVariable (modeSpec transSpec) (makePrimedId varRef)
          else
            findTheVariable (modeSpec transSpec) varRef;
        if groundTerm? (term varInfo) then
          return (cons (varInfo,subst))
        else
          return subst}) [] (variables (modeSpec transSpec))
   
we check to see if this is a procedure call
if it is we need to see if there are any arguments to call with
would it be easier to just pass the store with the argument and get it back with the return
maybe it would be better to make the bindings in the calling spec.
declare new variable for each call argument
then when the substitution is applied the values will be rewritten.
the problem is that

if the return term is and the second part of the store term are all ground, then there is
nothing to call.

but how do the values end up as bindings?

The point is that if we rewrite the call to some other term, we don't rewrite the bindings in the post condition.

suppose the caller has the identifiers of the called procedure. This might work because we
have renamed everything .. but suppose we have a recursive procedure

ok so we do the matching ourselves ...

now how do we get the results back and how to assign the arc in the new procedure.

suppose we look at the call term and forget all the sort information.
Suppose we also know the OpRefs for the state in the receiving procedure .. both
the parameters and the other variables in scope that are referenced within the procedure.

now run through the terms and match them to the op references for the arguments and
for the function and likewise for the variables in scope .. why must these be in the term
if they are in scope .. then their names won't change. because the rewrite
doesn't make sense .. leave them in for now.

those become the sub in the called procedure.

coming back

we look at the return name and if it appears free in spec at the final state
we look at global variables and see if they ground


p(x,5) = p_y_5 (x)

z = p(1,2)  

p(1,2,z') = 


the following fold is silly

  sort PE.State = {
      oscSpec : Oscar.Spec,
      bSpec : BSpec,
      static : Constraints
    }

  op withStatic infixl 18 : PE.State * Constraints -> PE.State
  def withStatic (state,static) = {
      oscSpec = state.oscSpec,
      bSpec = state.bSpec,
      static = static
    }


  op withOscSpec infixl 18 : PE.State * Oscar.Spec -> PE.State
  def withOscSpec (state,oscSpec) = {
      oscSpec = oscSpec,
      bSpec = state.bSpec,
      static = state.static
    }

  op withBSpec infixl 17 : PE.State * BSpec -> PE.State
  def withBSpec (state,bSpec) = {
      oscSpec = state.oscSpec,
      bSpec = bSpec,
      static = state.static
    }

  sort PE.Context = {
      bSpec : BSpec,
      coAlg : Vrtx.Vertex -> EdgSet.Set
    }

  op bSpec : PE.Context -> BSpec 
  def bSpec ctxt = ctxt.bSpec

  op coAlg : PE.Context -> Vrtx.Vertex -> EdgSet.Set
  def coAlg ctxt = ctxt.coAlg

