(test-directories ".")

(test 
  ("Bug 0099 : Extra 'let' in generated proof obligation"
   :show   "MinusOb#ONat" 
   :output '((:optional "")
             (:optional "")
             ";;; Elaborating obligator at $TESTDIR/MinusOb#ONat"
             ""
             "spec  "
             "import Compare"
             "import Function"
             " "
             "proof Isa -subtype_constrs -free-theorems -stp-theorems end-proof"
             " "
             "type Int"
             " "
             "type Integer = Int"
             "op zero: Int"
             "op isucc: Function.Bijection(Int, Int)"
             "op ipred: Function.Bijection(Int, Int) = Function.inverse isucc"
             " "
             "proof Isa"
             "  apply(rule ext, rule sym, auto simp add: inv_def)"
             " end-proof"
             " "
             "proof Isa ipred_subtype_constr"
             "  apply(auto simp add: bij_def inj_on_def surj_def)"
             "  apply(rule_tac x=\"y + 1\" in exI, auto)"
             " end-proof"
             " "
             "axiom Integer.infinity is "
             "  ex(f: Int -> Int) Function.injective? f && ~(Function.surjective? f)"
             " "
             "axiom Integer.induction is "
             "  fa(p: Int -> Bool) "
             "   p zero && (fa(i: Int) (p i => p (isucc i) && p (ipred i))) => (fa(i: Int) p i)"
             "op one: Int = isucc zero"
             "op zero? (i: Int): Bool = i = zero"
             " "
             "conjecture Integer.positive?_Obligation_the is "
             "  ex1(positive?: Int -> Bool) "
             "   let def satisfiesInductiveDef? (p?: Int -> Bool): Bool = "
             "         p? one && (fa(i: Int) (p? i => p? (isucc i)))"
             "   in "
             "   satisfiesInductiveDef? positive? "
             "    && (fa(p?_1: Int -> Bool, i_1: Int) "
             "         (satisfiesInductiveDef? p?_1 && positive? i_1 => p?_1 i_1))"
             "op positive?: Int -> Bool"
             "  = the (positive?: Int -> Bool) "
             "     let def satisfiesInductiveDef? (p?: Int -> Bool): Bool = "
             "           p? one && (fa(i: Int) (p? i => p? (isucc i)))"
             "     in "
             "     satisfiesInductiveDef? positive? "
             "      && (fa(p?: Int -> Bool) "
             "           (satisfiesInductiveDef? p? => (fa(i: Int) positive? i => p? i)))"
             "op negative? (i: Int): Bool = ~(positive? i) && ~(zero? i)"
             " "
             "proof Isa -verbatim"
             "theorem Integer__positive_p_alt_def[simp]:"
             "\"Integer__positive_p = (\\<lambda>i. i>0)\""
             "apply(simp add:Integer__positive_p_def)"
             "(************ The following fact is needed twice in the proof   **********)"
             "apply(subgoal_tac"
             "  \"\\<forall>P i. P (1::int) \\<and> (\\<forall>i. P i \\<longrightarrow>"
             "                 P (i + 1)) \\<and> 0<i \\<longrightarrow> P i\")"
             "apply(rule_tac Q=\"\\<lambda>pos. pos=(\\<lambda>i. i>0)\" in the1I2)"
             "apply(rule Integer__positive_p_Obligation_the)"
             "apply(simp add: Integer__positive_p__satisfiesInductiveDef_p_def, clarify)  "
             "(************ Now we essentially have to repeat the above proof **********) "
             "apply(rule ext,drule_tac x=\"x\" in spec, rotate_tac -1, drule_tac x=\"i\" in spec)"
             "apply(rotate_tac 2, drule_tac x=\"\\<lambda>i. 0<i\" in spec, rule iffI, simp_all)"
             "apply(clarify, rule_tac k=\"0\" in int_gr_induct, simp_all)"
             "done"
             ""
             "theorem Integer__negative_p_alt_def[simp]: "
             "\"Integer__negative_p = (\\<lambda>i. i<0)\""
             "apply(rule ext)"
             "apply(auto simp add:Integer__negative_p_def Integer__zero_p_def)"
             "done"
             "end-proof"
             " "
             "theorem Integer.induction_pos_neg is "
             "  fa(p: Int -> Bool) "
             "   p zero "
             "    && (fa(i: Int) (~(negative? i) && p i => p (isucc i))) "
             "    && (fa(i: Int) (~(positive? i) && p i => p (ipred i))) => (fa(i: Int) p i)"
             " "
             "conjecture IntegerAux.-_Obligation_the is "
             "  ex1(minus: Function.Bijection(Int, Int)) "
             "   minus 0 = 0 "
             "    && (fa(i: Int) (positive? i => minus i = ipred(minus (ipred i)))) "
             "    && (fa(i_1: Int) (negative? i_1 => minus i_1 = isucc(minus (isucc i_1))))"
             "op -: Function.Bijection(Int, Int)"
             "  = the (minus: Function.Bijection(Int, Int)) "
             "     minus zero = zero "
             "      && (fa(i: Int) (positive? i => minus i = ipred(minus (ipred i)))) "
             "      && (fa(i: Int) (negative? i => minus i = isucc(minus (isucc i))))"
             " "
             "conjecture Integer.+_Obligation_the is "
             "  ex1(plus: Int * Int -> Int) "
             "   (fa(j: Int) plus (0, j) = j) "
             "    && (fa(i: Int, j_1: Int) "
             "         (positive? i => plus (i, j_1) = isucc(plus (ipred i, j_1)))) "
             "    && (fa(i_1: Int, j_2: Int) "
             "         (negative? i_1 => plus (i_1, j_2) = ipred(plus (isucc i_1, j_2))))"
             "op + infixl 25: Int * Int -> Int"
             "  = the (plus: Int * Int -> Int) "
             "     (fa(j: Int) plus (zero, j) = j) "
             "      && (fa(i: Int, j: Int) (positive? i => plus (i, j) = isucc(plus (ipred i, j)))) "
             "      && (fa(i: Int, j: Int) (negative? i => plus (i, j) = ipred(plus (isucc i, j))))"
             "op - (i: Int, j: Int) infixl 25: Int = i + - j"
             " "
             "conjecture Integer.*_Obligation_the is "
             "  ex1(times: Int * Int -> Int) "
             "   (fa(j: Int) times (0, j) = 0) "
             "    && (fa(i: Int, j_1: Int) "
             "         (positive? i => times (i, j_1) = times (ipred i, j_1) + j_1)) "
             "    && (fa(i_1: Int, j_2: Int) "
             "         (negative? i_1 => times (i_1, j_2) = times (isucc i_1, j_2) - j_2))"
             "op * infixl 27: Int * Int -> Int"
             "  = the (times: Int * Int -> Int) "
             "     (fa(j: Int) times (zero, j) = zero) "
             "      && (fa(i: Int, j: Int) (positive? i => times (i, j) = times (ipred i, j) + j)) "
             "      && (fa(i: Int, j: Int) (negative? i => times (i, j) = times (isucc i, j) - j))"
             " "
             "proof Isa e_ast__def"
             " apply(rule the1_equality [symmetric])"
             " apply(rule Integer__e_ast_Obligation_the)"
             " apply(auto simp add: ring_distribs)"
             "end-proof"
             "op < (i: Int, j: Int) infixl 20: Bool = negative?(i - j)"
             "op > (i: Int, j: Int) infixl 20: Bool = j < i"
             "op <= (i: Int, j: Int) infixl 20: Bool = i < j || i = j"
             "op >= (i: Int, j: Int) infixl 20: Bool = i > j || i = j"
             " "
             "theorem Integer.<=_and_>=_are_converses is fa(i: Int, j: Int) i <= j = (j >= i)"
             " "
             "type Nat = {i: Int | i >= 0}"
             " "
             "conjecture Integer.induction_naturals_Obligation_subtype is "
             "  fa(p: Nat -> Bool, n: Nat) p 0 && p n => n + 1 >= 0"
             " "
             "theorem Integer.induction_naturals is "
             "  fa(p: Nat -> Bool) p 0 && (fa(n: Nat) (p n => p (n + 1))) => (fa(n: Nat) p n)"
             "op posNat? (n: Nat): Bool = n > 0"
             " "
             "proof Isa [simp] end-proof"
             " "
             "type PosNat = (Nat | posNat?)"
             " "
             "conjecture Nat.succ_Obligation_subtype is fa(n: Nat) isucc n >= 0"
             "op succ (n: Nat): Nat = isucc n"
             " "
             "conjecture Nat.pred_Obligation_subtype is fa(n: PosNat) ipred n >= 0"
             "op pred (n: PosNat): Nat = ipred n"
             "op sign (i: Int): {s: Int | s = 0 || s = 1 "
             "                                  || s = - 1}"
             "  = if i > 0 then 1 else if i < 0 then - 1 else 0"
             " "
             "conjecture Integer.abs_Obligation_subtype is fa(i: Int) ~(i >= 0) => - i >= 0"
             "op abs (i: Int): Nat = if i >= 0 then i else - i"
             " "
             "type Int0 = {i: Int | i ~= 0}"
             "op divides (x: Int, y: Int) infixl 20: Bool = ex(z: Int) x * z = y"
             " "
             "theorem Integer.any_divides_zero is fa(x: Int) x divides 0"
             " "
             "theorem Integer.only_zero_is_divided_by_zero is fa(x: Int) 0 divides x => x = 0"
             "op multipleOf (x: Int, y: Int) infixl 20: Bool = y divides x"
             " "
             "proof Isa -verbatim"
             "theorem Integer__multipleOf_is_reversed_dvd[simp]: "
             "\"w multipleOf y = (y dvd w)\""
             "apply(simp add:Integer__multipleOf_def)"
             "done"
             "end-proof"
             " "
             "conjecture Integer.gcd_Obligation_the is "
             "  fa(y: Int, x: Int) "
             "   ex1(z: Nat) "
             "    z divides x && z divides y "
             "                && (fa(w: Int) (w divides x && w divides y => w divides z))"
             "op gcd (x: Int, y: Int): Nat"
             "  = the (z: Nat) "
             "     z divides x && z divides y "
             "                 && (fa(w: Int) (w divides x && w divides y => w divides z))"
             " "
             "conjecture Integer.lcm_Obligation_the is "
             "  fa(y: Int, x: Int) "
             "   ex1(z: Nat) "
             "    z multipleOf x "
             "     && z multipleOf y "
             "     && (fa(w: Int) (w multipleOf x && w multipleOf y => w multipleOf z))"
             "op lcm (x: Int, y: Int): Nat"
             "  = the (z: Nat) "
             "     z multipleOf x "
             "      && z multipleOf y "
             "      && (fa(w: Int) (w multipleOf x && w multipleOf y => w multipleOf z))"
             " "
             "theorem Integer.gcd_of_not_both_zero is "
             "  fa(x: Int, y: Int) "
             "   x ~= 0 || y ~= 0 "
             "    => gcd(x, y) > 0 "
             "        && gcd(x, y) divides x "
             "        && gcd(x, y) divides y "
             "        && (fa(w: Int) (w divides x && w divides y => gcd(x, y) >= w))"
             " "
             "theorem Integer.gcd_of_zero_zero_is_zero is gcd(0, 0) = 0"
             " "
             "theorem Integer.lcm_smallest_abs_multiple is "
             "  fa(x: Int, y: Int, w: Int0) w multipleOf x && w multipleOf y => lcm(x, y) <= abs w"
             " "
             "conjecture Integer./_Obligation_the is "
             "  fa(j: Int0, i: Int) j divides i => (ex1(k: Int) i = j * k)"
             "op / (i: Int, j: Int0 | j divides i) infixl 26: Int = the (k: Int) i = j * k"
             " "
             "proof Isa -verbatim"
             "theorem Integer__e_fsl_equality [simp]:"
             "  \"\\<lbrakk>(j::int) \\<noteq> 0; j zdvd i\\<rbrakk>"
             "   \\<Longrightarrow> (k = i div j) = (i = j * k)\""
             "  apply(auto simp add:Integer__e_fsl__def)"
             "  apply(rule the1I2)"
             "  apply(rule Integer__e_fsl_Obligation_the, auto)"
             "done"
             "end-proof"
             " "
             "proof Isa -verbatim"
             "(******************************************************************"
             " ** The proof obligation below is much easier to prove if we assume"
             " ** i and j to be positive, We state that as a separate lemma"
             " ** which we will use later in the main proof"
             " ******************************************************************)"
             "theorem Integer__divT_unique_pos: "
             "\"\\<lbrakk>i\\<ge>0; (j::int)>0; (j::int) \\<noteq> 0;"
             "          \\<not> (zabs i < zabs j)\\<rbrakk> \\<Longrightarrow> "
             " \\<exists>!(q::int). "
             "   sign q = sign i * sign j "
             "     \\<and> (int (zabs i) - int (zabs j) "
             "          < int (zabs (q * j)) "
             "      \\<and> zabs (q * j) \\<le> zabs i)\""
             "  apply(simp add: not_less nat_le_eq_zle)"
             "  apply(rule_tac a=\"i div j\"in ex1I)   "
             "  apply(frule_tac a=i in div_pos_pos_less, simp)"
             "  apply(simp add: abs_mult div_bounds)"
             "  apply(rule_tac  r=\"i - x*j\" in div_pos_unique [symmetric], auto)"
             "  apply(simp split: split_if_asm add: abs_mult sign_def) "
             "done"
             "end-proof"
             " "
             "conjecture Integer.divT_Obligation_the is "
             "  fa(j: Int0, i: Int) "
             "   ~(abs i < abs j) "
             "    => (ex1(q: Int) "
             "         sign q = sign i * sign j && abs i - abs j < abs(q * j) "
             "                                  && abs(q * j) <= abs i)"
             "op divT (i: Int, j: Int0) infixl 26: Int"
             "  = if abs i < abs j"
             "     then 0 "
             "    else "
             "    the (q: Int) "
             "     sign q = sign i * sign j && abs i - abs j < abs(q * j) "
             "                              && abs(q * j) <= abs i"
             "op modT (i: Int, j: Int0) infixl 26: Int = i - j * (i divT j)"
             " "
             "theorem Integer.exact_divT is fa(i: Int, j: Int0) j divides i => i divT j = i / j"
             " "
             "theorem Integer.divT_is_largest_in_abs is "
             "  fa(i: Int, j: Int0, k: Int) abs(k * j) <= abs i => abs k <= abs(i divT j)"
             " "
             "conjecture Integer.divT_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.divT_of_negated_divisor is fa(i: Int, j: Int0) i divT - j = -(i divT j)"
             " "
             "theorem Integer.divT_of_negated_dividend is fa(i: Int, j: Int0) - i divT j = -(i divT j)"
             " "
             "theorem Integer.divides_iff_modT_0 is fa(i: Int, j: Int0) j divides i <=> i modT j = 0"
             " "
             "theorem Integer.modT_less_than_divisor_in_abs is fa(i: Int, j: Int0) abs(i modT j) < abs j"
             " "
             "conjecture Integer.modT_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.modT_of_negated_divisor is fa(i: Int, j: Int0) i modT - j = i modT j"
             " "
             "theorem Integer.modT_of_negated_dividend is fa(i: Int, j: Int0) - i modT j = -(i modT j)"
             " "
             "theorem Integer.sign_of_non_zero_modT is "
             "  fa(i: Int, j: Int0) i modT j ~= 0 => sign(i modT j) = sign i"
             "op divF (i: Int, j: Int0) infixl 26: Int"
             "  = if i modT j = 0 || sign i = sign j then i divT j else i divT j - 1"
             "op modF (i: Int, j: Int0) infixl 26: Int = i - j * (i divF j)"
             " "
             "theorem Integer.exact_divF is fa(i: Int, j: Int0) j divides i => i divF j = i / j"
             " "
             "theorem Integer.divF_is_largest is "
             "  fa(i: Int, j: Int0, k: Int) k * abs j <= i * sign j => k <= i divF j"
             " "
             "conjecture Integer.divF_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.divF_of_negated_divisor is "
             "  fa(i: Int, j: Int0) i divF - j = -(i divF j) - (if j divides i then 0 else 1)"
             " "
             "theorem Integer.divF_of_negated_dividend is "
             "  fa(i: Int, j: Int0) - i divF j = -(i divF j) - (if j divides i then 0 else 1)"
             " "
             "theorem Integer.divides_iff_modF_0 is fa(i: Int, j: Int0) j divides i <=> i modF j = 0"
             " "
             "theorem Integer.modF_less_than_divisor_in_abs is fa(i: Int, j: Int0) abs(i modF j) < abs j"
             " "
             "conjecture Integer.modF_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.modF_of_negated_divisor is "
             "  fa(i: Int, j: Int0) i modF - j = i modF j - j * (if j divides i then 0 else 1)"
             " "
             "theorem Integer.modF_of_negated_dividend is "
             "  fa(i: Int, j: Int0) "
             "   - i modF j = -(i modF j) + j * (if j divides i then 0 else 1)"
             " "
             "theorem Integer.sign_of_non_zero_modF is "
             "  fa(i: Int, j: Int0) i modF j ~= 0 => sign(i modF j) = sign j"
             "op divC (i: Int, j: Int0) infixl 26: Int"
             "  = if i modT j = 0 || sign i ~= sign j then i divT j else i divT j + 1"
             "op modC (i: Int, j: Int0) infixl 26: Int = i - j * (i divC j)"
             " "
             "theorem Integer.exact_divC is fa(i: Int, j: Int0) j divides i => i divC j = i / j"
             " "
             "theorem Integer.divC_is_smallest is "
             "  fa(i: Int, j: Int0, k: Int) k * abs j >= i * sign j => k >= i divC j"
             " "
             "theorem Integer.divC_divF_relation is "
             "  fa(i: Int, j: Int0) "
             "   if j divides i then i divC j = i divF j else i divC j = i divF j + 1"
             " "
             "conjecture Integer.divC_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.divC_of_negated_divisor is "
             "  fa(i: Int, j: Int0) i divC - j = -(i divC j) + (if j divides i then 0 else 1)"
             " "
             "theorem Integer.divC_of_negated_dividend is "
             "  fa(i: Int, j: Int0) - i divC j = -(i divC j) + (if j divides i then 0 else 1)"
             " "
             "theorem Integer.divides_iff_modC_0 is fa(i: Int, j: Int0) j divides i <=> i modC j = 0"
             " "
             "theorem Integer.modC_less_than_divisor_in_abs is fa(i: Int, j: Int0) abs(i modC j) < abs j"
             " "
             "conjecture Integer.modC_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.modC_of_negated_divisor is "
             "  fa(i: Int, j: Int0) i modC - j = i modC j + j * (if j divides i then 0 else 1)"
             " "
             "theorem Integer.modC_of_negated_dividend is "
             "  fa(i: Int, j: Int0) "
             "   - i modC j = -(i modC j) - j * (if j divides i then 0 else 1)"
             " "
             "theorem Integer.sign_of_non_zero_modC is "
             "  fa(i: Int, j: Int0) i modC j ~= 0 => sign(i modC j) = -(sign j)"
             " "
             "conjecture Integer.divR_Obligation_the is "
             "  fa(j: Int0, i: Int) "
             "   ex1(q: Int) "
             "    2 * abs(abs i - abs(q * j)) <= abs j "
             "     && (~(j divides i) && j divides 2 * i => 2 divides q) "
             "     && (q ~= 0 => sign q = sign(i * j))"
             "op divR (i: Int, j: Int0) infixl 26: Int"
             "  = the (q: Int) "
             "     2 * abs(abs i - abs(q * j)) <= abs j "
             "      && (~(j divides i) && j divides 2 * i => 2 divides q) "
             "      && (q ~= 0 => sign q = sign(i * j))"
             "op modR (i: Int, j: Int0) infixl 26: Int = i - j * (i divR j)"
             " "
             "theorem Integer.exact_divR is fa(i: Int, j: Int0) j divides i => i divR j = i / j"
             " "
             "conjecture Integer.divR_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.divR_of_negated_divisor is fa(i: Int, j: Int0) i divR - j = -(i divR j)"
             " "
             "theorem Integer.divR_of_negated_dividend is fa(i: Int, j: Int0) - i divR j = -(i divR j)"
             " "
             "theorem Integer.divides_iff_modR_0 is fa(i: Int, j: Int0) j divides i <=> i modR j = 0"
             "op euclidianDivision? (i: Int, j: Int0, q: Int, r: Int): Bool"
             "  = i = j * q + r && 0 <= r "
             "                  && r < abs j"
             " "
             "theorem Integer.euclideanDivision is "
             "  fa(i: Int, j: Int0) ex1(qr: Int * Int) euclidianDivision?(i, j, qr.1, qr.2)"
             " "
             "conjecture Integer.divE_Obligation_the is "
             "  fa(j: Int0, i: Int) ex1(q: Int) ex(r: Int) euclidianDivision?(i, j, q, r)"
             "op divE (i: Int, j: Int0) infixl 26: Int"
             "  = the (q: Int) ex(r: Int) euclidianDivision?(i, j, q, r)"
             " "
             "conjecture Integer.modE_Obligation_the is "
             "  fa(j: Int0, i: Int) ex1(r: Int) ex(q: Int) euclidianDivision?(i, j, q, r)"
             "op modE (i: Int, j: Int0) infixl 26: Int"
             "  = the (r: Int) ex(q: Int) euclidianDivision?(i, j, q, r)"
             " "
             "theorem Integer.exact_divE is fa(i: Int, j: Int0) j divides i => i divE j = i / j"
             " "
             "conjecture Integer.divE_of_negated_divisor_Obligation_subtype is fa(j: Int0) - j ~= 0"
             " "
             "theorem Integer.divE_of_negated_divisor is fa(i: Int, j: Int0) i divE - j = -(i divE j)"
             " "
             "theorem Integer.divE_of_negated_dividend is "
             "  fa(i: Int, j: Int0) "
             "   - i divE j = -(i divE j) - sign j * (if j divides i then 0 else 1)"
             " "
             "theorem Integer.modE_alt_def is fa(i: Int, j: Int0) i modE j = i - j * (i divE j)"
             " "
             "theorem Integer.divides_iff_modE_0 is fa(i: Int, j: Int0) j divides i <=> i modE j = 0"
             " "
             "conjecture Integer.divE_equals_divT_on_naturals_Obligation_subtype is "
             "  fa(j: PosNat) j >= 0 => j ~= 0"
             " "
             "conjecture Integer.divE_equals_divT_on_naturals_Obligation_subtype0 is "
             "  fa(j: PosNat) j >= 0 => j ~= 0"
             " "
             "theorem Integer.divE_equals_divT_on_naturals is fa(i: Nat, j: PosNat) i divE j = i divT j"
             " "
             "conjecture Integer.divE_equals_divF_on_naturals_Obligation_subtype is "
             "  fa(j: PosNat) j >= 0 => j ~= 0"
             " "
             "conjecture Integer.divE_equals_divF_on_naturals_Obligation_subtype0 is "
             "  fa(j: PosNat) j >= 0 => j ~= 0"
             " "
             "theorem Integer.divE_equals_divF_on_naturals is fa(i: Nat, j: PosNat) i divE j = i divF j"
             " "
             "conjecture Integer.div_Obligation_subtype is fa(j: PosNat) j >= 0 => j ~= 0"
             " "
             "conjecture Integer.div_Obligation_subtype0 is fa(j: PosNat, i: Nat) i divE j >= 0"
             "op div (i: Nat, j: PosNat) infixl 26: Nat = i divE j"
             " "
             "conjecture Integer.mod_Obligation_subtype is fa(j: PosNat) j >= 0 => j ~= 0"
             " "
             "conjecture Integer.mod_Obligation_subtype0 is fa(j: PosNat, i: Nat) i modE j >= 0"
             "op mod (i: Nat, j: PosNat) infixl 26: Nat = i modE j"
             " "
             "proof Isa -verbatim"
             "consts npower :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" (infixr \"\\<up>\" 80)"
             "defs   npower_def [simp]: \"x \\<up> y \\<equiv> x ^ y\""
             "end-proof"
             " "
             "conjecture Integer.**_Obligation_uniqueness is "
             "  ex1(**: Int * Nat -> Int) "
             "   fa(base: Int, exp: Nat) "
             "    ** (base, exp) = (if exp = 0 then 1 else base * ** (base, exp - 1))"
             " "
             "conjecture Integer.**_Obligation_subtype is fa(exp: Nat) ~(exp = 0) => exp - 1 >= 0"
             "op ** (base: Int, exp: Nat) infixl 30: Int"
             "  = if exp = 0 then 1 else base * base ** (exp - 1)"
             " "
             "conjecture Integer.***_Obligation_subtype is fa(exp: Nat, base: Nat) base ** exp >= 0"
             "op *** (base: Nat, exp: Nat) infixl 30: Nat = base ** exp"
             "op min (i: Int, j: Int): Int = if i < j then i else j"
             "op max (i: Int, j: Int): Int = if i > j then i else j"
             "op compare (i: Int, j: Int): Compare.Comparison"
             "  = if i < j then Less else if i > j then Greater else Equal"
             " "
             "proof Isa Integer__isucc_subtype_constr"
             " apply(auto simp add: bij_def inj_on_def surj_def)"
             " apply(rule_tac x=\"y - 1\" in exI, auto)"
             "end-proof"
             " "
             "proof Isa infinity"
             "  apply(rule_tac x=\"\\<lambda>i. 2*i\" in exI, auto simp add: surj_def inj_on_def)"
             "  apply(rule_tac x=\"1\"               in exI, auto simp add: pos_zmult_eq_1_iff)"
             " end-proof"
             " "
             "proof Isa induction"
             " apply(cases i)"
             " apply(rule_tac k=\"0\" in int_ge_induct,simp_all)"
             " apply(rule_tac k=\"0\" in int_le_induct,simp_all)"
             "end-proof"
             " "
             "proof Isa positive_p_Obligation_the  "
             " apply(simp add:Integer__positive_p__satisfiesInductiveDef_p_def)"
             " (****** The following fact is needed twice in the proof *******)"
             " apply(subgoal_tac"
             "   \"\\<forall>P i. P (1::int) \\<and> (\\<forall>i. P i"
             "    \\<longrightarrow> P (i + 1)) \\<and> 1 \\<le> i \\<longrightarrow> P i\")"
             " apply(rule_tac a=\"\\<lambda>i. i\\<ge>1\" in ex1I,simp_all)"
             " (********* Auto goes off in the wrong direction, so we need to guide ***)"
             " (*** first subgoal is now uniqueness    ***)"
             " apply(clarify, rule ext)"
             " apply(drule_tac x=\"x\" in spec, rotate_tac 3, drule_tac x=\"i\" in spec)"
             " apply(drule_tac x=\"\\<lambda>i. 1 \\<le> i\" in spec,"
             "       rotate_tac 3, drule_tac x=\"i\" in spec)"
             " apply(rule iffI, simp_all)"
             " (*** second subgoal: prove the stated fact by positive induction ***)"
             " apply(clarify, rule_tac k=\"1\" in int_ge_induct, simp)"
             " apply(clarify, drule_tac x=\"ia\" in spec, simp)"
             "end-proof"
             " "
             "proof Isa induction_pos_neg"
             " apply(simp, cases i)"
             " apply(rule_tac k=\"0\" in int_ge_induct, simp_all)"
             " apply(rule_tac k=\"0\" in int_le_induct, simp_all)"
             "end-proof"
             " "
             "proof Isa e_dsh_Obligation_the"
             " apply(rule_tac a=\"zminus\" in ex1I,simp_all)"
             " (*** first subgoal: bijectivity - same proof as below (beware of auto) ***)"
             " apply(simp add: bij_def inj_on_def surj_def, clarify)"
             " apply(rule_tac x =\"-y\" in  exI,simp)"
             " (*** second subgoal: uniqueness ***)"
             " apply(clarify, rule ext)"
             " apply(rule_tac p=\"\\<lambda>i. x i = - i\" in Integer__induction, auto)"
             " apply(subgoal_tac \"i=0 \\<or> i<0 \\<or> i>0\", auto)"
             " apply(subgoal_tac \"i=0 \\<or> i<0 \\<or> i>0\", auto)"
             "end-proof"
             " "
             "proof Isa IntegerAux__e_dsh__def"
             " apply(rule the1_equality [symmetric])"
             " apply(rule IntegerAux__e_dsh_Obligation_the)"
             " apply(simp add: IntegerAux__e_dsh_subtype_constr)"
             "end-proof"
             " "
             "proof Isa e_pls_Obligation_the"
             " apply(rule_tac a=\"\\<lambda>(i,j). i+j\" in ex1I, auto)"
             " apply(rule ext, auto simp add: split_paired_all)"
             " apply(rule_tac p=\"\\<lambda>a. x (a,b)  = a+b\" in Integer__induction, auto)"
             " apply(subgoal_tac \"i=0 \\<or> i<0 \\<or> i>0\", auto)+"
             "end-proof"
             " "
             "proof Isa e_dsh_subtype_constr "
             " apply(auto simp add: bij_def inj_on_def surj_def)"
             " apply(rule_tac x =\"-y\" in  exI, auto)"
             "end-proof"
             " "
             "proof Isa e_pls__def"
             " apply(rule the1_equality [symmetric])"
             " apply(rule Integer__e_pls_Obligation_the)"
             " apply(auto)"
             "end-proof"
             " "
             "proof Isa e_ast_Obligation_the"
             " apply(rule_tac a=\"\\<lambda>(i,j). i*j\" in ex1I, auto simp add: ring_distribs)"
             " apply(rule ext, auto simp add: split_paired_all)"
             " apply(rule_tac p=\"\\<lambda>a. x (a,b)  = a*b\" in Integer__induction, auto)"
             " apply(subgoal_tac \"i=0 \\<or> i<0 \\<or> i>0\", auto simp add: ring_distribs)+"
             "end-proof"
             " "
             "proof Isa induction_naturals "
             "  apply(rule nat_induct, auto)"
             "end-proof"
             " "
             "proof Isa sign_subtype_constr"
             " apply (simp add: sign_def)"
             "end-proof"
             " "
             "proof Isa divides__def"
             "  apply(auto simp add: dvd_def)"
             "end-proof"
             " "
             "proof Isa gcd__def"
             " apply(rule the1_equality [symmetric])"
             " apply(rule Integer__gcd_Obligation_the)"
             " apply(simp add: zgcd_greatest_iff)"
             "end-proof"
             " "
             "proof Isa gcd_Obligation_the"
             "  apply(rule_tac a=\"igcd(x,y)\" in ex1I, auto)"
             "  apply(simp add: zgcd_greatest_iff)"
             "  apply(subgoal_tac \"int xa =zgcd (x,y)\")"
             "  apply(simp only: igcd_to_zgcd [symmetric])"
             "  apply(rule dvd_antisym, auto)"
             "  apply(rule zgcd_geq_zero)"
             "  apply(simp add: zgcd_greatest_iff)"
             "end-proof"
             " "
             "proof Isa lcm__def"
             " apply(rule the1_equality [symmetric])"
             " apply(rule Integer__lcm_Obligation_the)"
             " apply(simp add: zlcm_least)"
             "end-proof"
             " "
             "proof Isa lcm_Obligation_the"
             " apply(rule_tac a=\"ilcm(x,y)\" in ex1I, simp_all)"
             " apply(simp add: zlcm_least)"
             " apply(subgoal_tac \"int xa =zlcm (x,y)\")"
             " apply(simp only: ilcm_to_zlcm [symmetric])"
             " apply(rule dvd_antisym, simp_all)"
             " apply(rule zlcm_geq_zero)"
             " apply(rule zlcm_least, simp_all)"
             "end-proof"
             " "
             "proof Isa gcd_of_not_both_zero"
             "  apply(subgoal_tac \"int 0 < int (igcd(x,y))\", simp (no_asm_simp), clarify)"
             "  apply(metis igcd_to_zgcd int_eq_0_conv zdvd_imp_le zgcd_greatest_iff)"
             "  apply(metis Pls_def_raw gcd_int.commute gcd_pos_int igcd_to_zgcd"
             "              int_eq_0_conv zgcd_specware_def)"
             "end-proof"
             " "
             "proof Isa lcm_smallest_abs_multiple"
             "  apply(subgoal_tac \"int (ilcm (x, y)) \\_le abs w\", simp_all (no_asm_simp))"
             "  apply(rule zdvd_imp_le)"
             "  apply(auto simp add:zlcm_least)"
             "end-proof"
             " "
             "proof Isa /__def"
             " by (rule the1I2, rule Integer__e_fsl_Obligation_the, auto)"
             "end-proof"
             " "
             "proof Isa e_fsl_Obligation_the"
             " apply(rule_tac a=\"i div j\"in ex1I)"
             " apply(auto simp add: dvd_def)"
             "end-proof"
             " "
             "proof Isa divT_Obligation_the"
             " apply(cut_tac i=\"\\<bar>i\\<bar>\" and j=\"\\<bar>j\\<bar>\""
             "         in Integer__divT_unique_pos,"
             "       simp_all add: not_less nat_le_eq_zle) "
             " apply(erule ex1E, clarify)"
             " apply(rule_tac a=\"q * sign (i*j)\" in ex1I, "
             "       simp_all add: abs_mult abs_idempotent)"
             " apply(rule_tac t=q and s=\"x * (sign i * sign j)\" in subst, clarify)"
             " defer apply (simp add: algebra_simps mult_sign_self)"
             " apply (drule_tac x=\"x * (sign i * sign j)\" in spec, erule mp)"
             " apply (subgoal_tac \"i \\<noteq> 0\")"
             " apply (simp add: abs_mul,"
             "        simp only: sign_pos_iff [symmetric],"
             "        simp add: algebra_simps mult_sign_self)"
             " apply (auto)"
             "end-proof"
             " "
             "proof Isa divT__def1"
             "apply(rule the1_equality [symmetric])"
             "apply(rule Integer__divT_Obligation_the, simp_all)"
             "apply(simp only: zero_less_abs_iff [symmetric] not_less)"
             "apply(simp del: zero_less_abs_iff"
             "           add: divT_def abs_mult divT_abs [symmetric] div_bounds div_signs)"
             "end-proof"
             " "
             "proof Isa modT__def"
             "  apply (simp add: modT_alt_def)"
             "end-proof"
             " "
             "proof Isa exact_divT"
             "  apply (simp add: divides_iff_modT_0 modT_alt_def)"
             "end-proof"
             " "
             "proof Isa divT_is_largest_in_abs"
             "  apply (simp add: nat_le_eq_zle,"
             "         simp add: divT_abs [symmetric] divT_pos div_is_largest_pos)"
             "end-proof"
             " "
             "proof Isa divT_of_negated_divisor"
             "  apply(simp add: divT_def)     "
             "end-proof"
             " "
             "proof Isa divT_of_negated_dividend"
             "  apply(simp add: divT_def) "
             "end-proof"
             " "
             "proof Isa divides_iff_modT_0"
             "  apply(auto simp add: modT_0_equals_mod_0 dvd_eq_mod_eq_0)"
             "end-proof"
             " "
             "proof Isa modT_less_than_divisor_in_abs"
             "  apply(simp add: modT_def abs_mult, cases \"i=0\", auto)"
             "end-proof"
             " "
             "proof Isa modT_of_negated_divisor"
             "  apply(simp add: modT_def)"
             "end-proof"
             " "
             "proof Isa modT_of_negated_dividend"
             "  apply(simp add: modT_def)"
             "end-proof"
             " "
             "proof Isa sign_of_non_zero_modT"
             "   apply(auto simp add: modT_def less_le)"
             "end-proof"
             " "
             "proof Isa divF__def"
             "  apply(auto simp add: divides_iff_modT_0 [symmetric] "
             "                      divT_is_div_if_dvd divT_is_div_if_eqsign)"
             "end-proof"
             " "
             "proof Isa divF__def1"
             "  apply(simp add: divides_iff_modT_0 [symmetric] divT_vs_div_else)"
             "end-proof"
             " "
             "proof Isa modF__def"
             "  apply(cut_tac a=i and b=j and k=0 in zdiv_zmod_equality, arith)"
             "end-proof"
             " "
             "proof Isa divF_is_largest  "
             "apply(simp add: abs_if sign_def div_is_largest_pos div_is_largest_neg"
             "           split: split_if_asm)    "
             "end-proof"
             " "
             "proof Isa divF_of_negated_divisor"
             "  apply(simp add: dvd_eq_mod_eq_0 zdiv_zminus2_eq_if)"
             "end-proof"
             " "
             "proof Isa divF_of_negated_dividend"
             "  apply(simp add: dvd_eq_mod_eq_0 zdiv_zminus1_eq_if)"
             "end-proof"
             " "
             "proof Isa divides_iff_modF_0"
             "  apply(simp add: dvd_eq_mod_eq_0)"
             "end-proof"
             " "
             "proof Isa modF_less_than_divisor_in_abs"
             "  apply(auto simp add: abs_if not_less)"
             "  apply(cut_tac a=i and b=j in pos_mod_sign, auto)"
             "  apply(cut_tac a=i and b=j in neg_mod_sign, auto)"
             "end-proof"
             " "
             "proof Isa modF_of_negated_divisor"
             "  apply(simp add: dvd_eq_mod_eq_0 zmod_zminus2_eq_if)"
             "end-proof"
             " "
             "proof Isa modF_of_negated_dividend"
             "  apply(simp add: dvd_eq_mod_eq_0 zmod_zminus1_eq_if)"
             "end-proof"
             " "
             "proof Isa sign_of_non_zero_modF"
             " apply(cases \"j < 0\", auto simp add: sign_def not_less neq_le_trans)"
             "end-proof"
             " "
             "proof Isa divC__def"
             " apply (simp add: divC_def divides_iff_modT_0 [symmetric] divT_is_div_if_dvd)"
             " apply (auto simp add: divT_vs_div_else)"
             "end-proof"
             " "
             "proof Isa divC__def1"
             " apply(simp add: divC_def divides_iff_modT_0 [symmetric] divT_is_div_if_eqsign)"
             "end-proof"
             " "
             "proof Isa modC__def"
             " apply(simp add: modC_def)"
             "end-proof"
             " "
             "proof Isa exact_divC"
             "  by (simp add: divC_def)"
             "end-proof"
             " "
             "proof Isa divC_is_smallest"
             "  apply (auto simp add: neq_iff divC_is_smallest_pos divC_is_smallest_neg)"
             "end-proof"
             " "
             "proof Isa divC_divF_relation"
             " apply(simp add: divC_def)"
             "end-proof"
             " "
             "proof Isa divC_of_negated_divisor"
             " apply(simp add: divC_def zdiv_zminus2_eq_if, simp add: dvd_eq_mod_eq_0)"
             "end-proof"
             " "
             "proof Isa divC_of_negated_dividend"
             " apply(simp add: divC_def zdiv_zminus1_eq_if, simp add: dvd_eq_mod_eq_0)"
             "end-proof"
             " "
             "proof Isa divides_iff_modC_0"
             " apply(auto simp add: modC_def divC_def "
             "                      dvd_eq_mod_eq_0 algebra_simps div_bounds_neq)"
             "end-proof"
             " "
             "proof Isa modC_less_than_divisor_in_abs"
             " apply (auto simp add: modC_def divC_def dvd_eq_mod_eq_0)"
             " apply (cases \"j>0\", auto simp add: algebra_simps not_less_iff_gr_or_eq)"
             " apply (frule_tac i=i in div_pos_low_bound2, "
             "        simp add: div_via_mod pos_mod_sign less_le)"
             " apply (frule_tac i=i in div_neg_up_bound2, "
             "        simp add: div_via_mod pos_mod_sign less_le)"
             "end-proof"
             " "
             "proof Isa modC_of_negated_divisor"
             " apply(auto simp add: modC_def Integer__divC_of_negated_divisor algebra_simps)"
             "end-proof"
             " "
             "proof Isa modC_of_negated_dividend"
             " apply(auto simp add: modC_def Integer__divC_of_negated_dividend algebra_simps)"
             "end-proof"
             " "
             "proof Isa sign_of_non_zero_modC"
             " apply (simp add: Integer__divides_iff_modC_0 [symmetric],"
             "        auto simp add: modC_def divC_def algebra_simps neq_iff div_bounds)"
             "end-proof"
             " "
             "proof Isa divR_Obligation_the"
             " apply (simp add: divR_def_aux1 [symmetric])"
             " apply (rule_tac a=\"i divR j\" in ex1I)"
             " apply (auto simp add: divR_def_lemmas)"
             "end-proof"
             " "
             "proof Isa divR__def"
             "  apply (rule the1_equality [symmetric])"
             "  apply (rule Integer__divR_Obligation_the, "
             "         auto simp add: divR_def_aux1 [symmetric] divR_def_lemmas)"
             "end-proof"
             " "
             "proof Isa modR__def"
             "  apply (simp add: modR_def)"
             "end-proof"
             " "
             "proof Isa exact_divR"
             " apply(simp add: divides_iff_modR_0 modR_def)"
             "end-proof"
             " "
             "proof Isa divR_of_negated_divisor"
             "  apply (simp add: divR_zminus2)"
             "end-proof"
             " "
             "proof Isa divR_of_negated_dividend"
             "   apply (simp add: divR_zminus1)"
             "end-proof"
             " "
             "proof Isa divides_iff_modR_0"
             "  apply (auto simp add: modR_def divR_def algebra_simps div_eq_if_dvd, "
             "         simp_all add: dvd_if_div_eq  dvd_eq_mod_eq_0 div_via_mod)"
             "end-proof"
             " "
             "proof Isa euclideanDivision"
             " apply (simp add: Integer__euclidianDivision_p_def, "
             "        rule_tac a=\"(i divE j, i modE j)\" in ex1I)"
             " apply (auto simp add: modE_sign modE_bound,"
             "        auto simp add: modE_alt_def divE_def div_abs_unique)"
             "end-proof"
             " "
             "proof Isa divE_Obligation_the"
             "  apply (drule Integer__euclideanDivision, auto)"
             "end-proof"
             " "
             "proof Isa divE__def  "
             " apply (rule the1_equality [symmetric],"
             "        rule Integer__divE_Obligation_the, auto)"
             " apply (simp add: Integer__euclidianDivision_p_def, "
             "        rule_tac x=\"i modE j\" in exI)"
             " apply (auto simp add: modE_sign modE_bound,"
             "        auto simp add: modE_alt_def divE_def div_abs_unique)"
             "end-proof"
             " "
             "proof Isa modE_Obligation_the"
             "  apply (drule Integer__euclideanDivision, auto)"
             "end-proof"
             " "
             "proof Isa modE__def  "
             " apply (rule the1_equality [symmetric],"
             "        rule Integer__modE_Obligation_the, auto)"
             " apply (rule_tac x=\"i divE j\" in exI,"
             "        simp add: Integer__euclidianDivision_p_def)"
             " apply (auto simp add: modE_sign modE_bound,"
             "        auto simp add: modE_alt_def divE_def div_abs_unique)"
             "end-proof"
             " "
             "proof Isa exact_divE"
             "  apply (simp add: divides_iff_modE_0 modE_alt_def)"
             "end-proof"
             " "
             "proof Isa divE_of_negated_divisor"
             "  apply (simp add: divE_def) "
             "end-proof"
             " "
             "proof Isa divE_of_negated_dividend"
             "  apply (auto simp add: divE_def abs_if zdiv_zminus1_eq_if,"
             "         auto simp add: zmod_zminus2_eq_if dvd_eq_mod_eq_0)"
             "end-proof"
             " "
             "proof Isa modE_alt_def"
             " apply (simp add: divE_def modE_def sign_def mod_via_div)"
             "end-proof"
             " "
             "proof Isa divides_iff_modE_0"
             "   apply (simp add: modE_def divE_def dvd_eq_mod_eq_0 [symmetric])"
             "end-proof"
             " "
             "proof Isa divE_equals_divT_on_naturals"
             "  apply (simp add: divE_def divT_def sign_def int_mult [symmetric])"
             "end-proof"
             " "
             "proof Isa  divE_equals_divF_on_naturals"
             "  apply (simp add: divE_def sign_def int_mult [symmetric])"
             "end-proof"
             " "
             "proof Isa div_Obligation_subtype0"
             "  apply (simp add: div_signs)"
             "end-proof"
             " "
             "proof Isa div__def"
             "  apply (auto simp add: nat_eq_iff2 zdiv_int div_signs)"
             "end-proof"
             " "
             "proof Isa mod__def"
             "  by (auto simp add: nat_eq_iff2 zmod_int)"
             "end-proof"
             " "
             "proof Isa e_ast_ast__def1"
             " by (cases exp__v, auto)"
             "end-proof"
             " "
             "proof Isa e_ast_ast_ast__def"
             "  by (simp add: zpower_int)"
             "end-proof"
             " "
             "proof Isa -verbatim"
             "(******** Logarithm on natural numbers (\"log\" is defined on real numbers) ********)"
             ""
             "theorem ld_Obligation_the:"
             "  \"\\<lbrakk>(base::nat) \\<ge> 2\\<rbrakk> \\<Longrightarrow> \\<exists>!ld. x < base ^ ld \\<and> (\\<forall>y. x < base ^ y \\<longrightarrow> ld \\<le> y)\""
             " apply (induct x)"
             " apply (rule_tac a=0 in ex1I, simp, clarify, drule_tac x=0 in spec, simp_all)"
             " apply (erule ex1E, clarify)"
             " apply (case_tac \"Suc x < base ^ld \", simp)"
             " (* case Suc x < base ^ ld *)"
             " apply (rule_tac a=ld in ex1I, simp)"
             " apply (drule_tac x=xa in spec, erule mp, clarsimp)"
             " apply (drule_tac x=y  in spec, drule mp, simp)"
             " apply (drule_tac x=ld  in spec, drule mp, simp_all)"
             " (* case Suc x \\<ge> base ^ ld *)"
             " apply (rule_tac a=\"Suc ld\" in ex1I, safe, simp_all add: not_less)"
             " (***** tedious monotonicity ***)"
             " apply (drule_tac Suc_leI, drule_tac k=base and i=\"Suc x\" in mult_le_mono2,"
             "        rule_tac y=\"base * Suc x\" in less_le_trans,"
             "        cut_tac i=1 and j=base and k=\"Suc x\" in mult_less_mono1, simp_all)"
             " apply (drule_tac x=\"base ^ld\" and z=\"base ^y\" and y=\"Suc x\" in le_less_trans,"
             "        simp_all add: power_less_imp_less_exp)"
             " apply (rotate_tac -1, drule_tac x=\"Suc ld\" in spec, drule mp, simp)"
             " apply (drule_tac Suc_leI, drule_tac k=base and i=\"Suc x\" in mult_le_mono2,"
             "        rule_tac y=\"base * Suc x\" in less_le_trans,"
             "        cut_tac i=1 and j=base and k=\"Suc x\" in mult_less_mono1, simp_all)"
             " apply (drule_tac x=\"base ^ld\" and z=\"base ^xa\" and y=\"Suc x\" in le_less_trans,"
             "        simp_all add: power_less_imp_less_exp)"
             "done"
             ""
             "consts ld :: \"nat \\<times> Nat__PosNat \\<Rightarrow> nat\""
             "defs ld_def: \"ld \\<equiv> (\\<lambda> ((x::nat), (base::Nat__PosNat)). Least (\\<lambda>n. x< base ^ n))\""
             ""
             "theorem ld_positive:"
             "  \"\\<lbrakk>2 \\<le> base; 0 < x\\<rbrakk> \\<Longrightarrow> 0 < ld (x, base)\""
             "  by (simp add: ld_def Least_def, rule the1I2, "
             "      erule ld_Obligation_the, rule classical, auto)"
             ""
             "theorem ld_mono:"
             "  \"\\<lbrakk>2 \\<le> base\\<rbrakk> \\<Longrightarrow> x < base ^ ld (x, base)\""
             " by (simp add: ld_def Least_def, rule the1I2,  erule ld_Obligation_the, auto)"
             ""
             "theorem ld_mono2:"
             "  \"\\<lbrakk>2 \\<le> base; 0 < x\\<rbrakk> \\<Longrightarrow> x \\<ge> base ^ (ld (x, base) - 1)\""
             " apply (frule_tac x=x in ld_positive, simp)"
             " apply (rotate_tac -1, erule rev_mp)"
             " apply (simp add: ld_def Least_def, rule the1I2,  erule ld_Obligation_the, clarify)"
             " apply (rule classical, simp add: not_le)"
             " apply (drule_tac x=\"xa - 1\" in spec, drule mp, simp, arith)"
             "done"
             ""
             "end-proof"
             " "
             "proof Isa Thy_Morphism Presburger"
             " type Integer.Int -> int"
             " type Nat.Nat     -> nat (int,nat) [+,*,/,rem,mod,modF,<=,<,>=,>,abs,min,max]"
             " Integer.zero     -> 0"
             " Integer.one      -> 1"
             " Integer.ipred    -> pred"
             " Integer.isucc    -> succ"
             " IntegerAux.-     -> -"
             " Integer.+        -> +     Left 65"
             " Integer.-        -> -     Left 65"
             " Integer.*        -> *     Left 70"
             " Integer.<=       -> \\<le> Left 50"
             " Integer.<        -> <     Left 50"
             " Integer.>=       -> \\<ge> Left 50"
             " Integer.>        -> >     Left 50"
             " Integer.sign     -> sign"
             " Integer.abs      -> zabs"
             " Integer./        -> div   Left 70"
             " Integer.divT     -> divT  Left 70"
             " Integer.divF     -> div   Left 70"
             " Integer.divC     -> divC  Left 70"
             " Integer.divR     -> divR  Left 70"
             " Integer.divE     -> divE  Left 70"
             " Integer.div      -> div   Left 70"
             " Integer.modT     -> modT  Left 70"
             " Integer.modF     -> mod   Left 70"
             " Integer.modC     -> modC  Left 70"
             " Integer.modR     -> modR  Left 70"
             " Integer.modE     -> modE  Left 70"
             " Integer.mod      -> mod   Left 70"
             " Integer.**       -> **    Left 70"
             " Integer.***      -> ***   Left 70"
             " Integer.min      -> min   curried"
             " Integer.max      -> max   curried"
             " Integer.divides  -> zdvd  Left 70 "
             " Integer.gcd      -> igcd"
             " Integer.lcm      -> ilcm"
             " Nat.succ         -> Suc"
             "end-proof"
             " "
             "#translate Haskell -header"
             "{-# OPTIONS -fno-warn-duplicate-exports #-}"
             "#end"
             " "
             "#translate Haskell -morphism"
             " type Integer.Int -> Int"
             " type Nat.Nat     -> Int"
             " Integer.zero     -> 0"
             " Integer.one      -> 1"
             " IntegerAux.-     -> negate"
             " Integer.isucc    -> (+ 1)"
             " Integer.ipred    -> (- 1)"
             " Integer.zero?    -> (== 0)"
             " Integer.positive? -> (> 0)"
             " Integer.negative? -> (< 0)"
             " Nat.succ         -> (1 +)"
             " Nat.pred         -> (-1 +)"
             " Nat.posNat?      -> (> 0)"
             " Integer.+        -> +     Left  6"
             " Integer.-        -> -     Left  6"
             " Integer.*        -> *     Left  7"
             " Integer.<=       -> <=    Infix 4"
             " Integer.<        -> <     Infix 4"
             " Integer.>=       -> >=    Infix 4"
             " Integer.>        -> >     Infix 4"
             " Integer./        -> div   Left  7"
             " Integer.sign     -> signum"
             " Integer.gcd      -> gcd"
             " Integer.lcm      -> lcm"
             " Integer.abs      -> abs"
             " Integer.div      -> div   Left  7"
             " Integer.divF     -> div   Left  7"
             " Integer.divT     -> quot  Left  7"
             " Integer.modF     -> mod   Left  7"
             " Integer.mod      -> mod   Left  7"
             " Integer.modT     -> rem   Left  7"
             " Integer.min      -> min   Left  7"
             " Integer.max      -> max   Left  7"
             " Integer.**       -> ^     Left  8"
             " Integer.***      -> ^     Left  8"
             " Integer.compare \\_rightarrow compare curried"
             "#end"
             "end-spec"
             (:optional "")
             (:optional "")
             )))
