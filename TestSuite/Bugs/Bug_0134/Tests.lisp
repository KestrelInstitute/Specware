(test-directories ".")

(test 

  ("Bug 0134 : Unparseable proof obligation generated"
   :show "fold#O"
   :output '((:optional "")
             (:optional "")
             ";;; Elaborating obligator at $TESTDIR/fold#O"
             ";;; Elaborating spec at $TESTDIR/fold#S"
             ""
             "spec  "
             " "
             "type Predicate(a) = a -> Bool"
             "op [a] uniquelySatisfies?: a * Predicate(a) -> Bool"
             " "
             "axiom uniquelySatisfies?_def is [a] "
             "  fa(x: a, p: Predicate(a)) "
             "   uniquelySatisfies?(x, p) = (p x && (fa(y: a) (p y => y = x)))"
             "op [a] uniquelySatisfied?: Predicate(a) -> Bool"
             " "
             "axiom uniquelySatisfied?_def is [a] "
             "  fa(p: Predicate(a)) uniquelySatisfied? p = (ex(x: a) uniquelySatisfies?(x, p))"
             " "
             "type UniquelySatisfiedPredicate(a) = (Predicate(a) | uniquelySatisfied?)"
             "op [a] The: UniquelySatisfiedPredicate(a) -> a"
             " "
             "axiom The_def is [a] fa(p: UniquelySatisfiedPredicate(a)) uniquelySatisfies?(The p, p)"
             " "
             "type FSet(a)"
             "op [a] in? infixl 20: a * FSet(a) -> Bool"
             "op [a] empty: FSet(a)"
             "op [a] with infixl 30: FSet(a) * a -> FSet(a)"
             "op [a] wout infixl 30: FSet(a) * a -> FSet(a)"
             "op [a, b] foldable?: FSet(a) * b * (b * a -> b) -> Bool"
             "def [a, b] foldable?(s: FSet(a), c: b, f: b * a -> b): Bool"
             "  = fa(x: a, y: a, z: b) x in? s && y in? s => f (f (z, x), y) = f (f (z, y), x)"
             "op [a, b] fold: ((FSet(a) * b * (b * a -> b)) | foldable?) -> b"
             " "
             "conjecture fold_Obligation_subtype1 is [a, b] "
             "  fa(f_1: b * a -> b, c_1: b, s: FSet(a), x: a) "
             "   foldable?(s with x, c_1, f_1) => foldable?(s wout x, c_1, f_1)"
             " "
             "conjecture fold_Obligation_subtype0 is [a, b] fa(c: b, f: b * a -> b) foldable?(empty, c, f)"
             " "
             "conjecture fold_Obligation_subtype is [a, b] "
             "  uniquelySatisfied?"
             "    (fn (fold: ((FSet(a) * b * (b * a -> b)) | foldable?) -> b) -> "
             "        (fa(c: b, f: b * a -> b) fold (empty, c, f) = c) "
             "         && (fa(s: FSet(a), x: a, c_1: b, f_1: b * a -> b) "
             "              (foldable?(s with x, c_1, f_1) "
             "               => fold (s with x, c_1, f_1) = f_1 (fold (s wout x, c_1, f_1), x))))"
             "def [a, b] fold: ((FSet(a) * b * (b * a -> b)) | foldable?) -> b"
             "  = The"
             "      (fn (fold: ((FSet(a) * b * (b * a -> b)) | foldable?) -> b) -> "
             "          (fa(c: b, f: b * a -> b) fold (empty, c, f) = c) "
             "           && (fa(s: FSet(a), x: a, c: b, f: b * a -> b) "
             "                (foldable?(s with x, c, f) "
             "                 => fold (s with x, c, f) = f (fold (s wout x, c, f), x))))"
             "end-spec"
             (:optional "")
             (:optional "")
             ))
  )

