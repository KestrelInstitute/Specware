spec

  (* Here we put types, expressions, and patterns together. *)

  import Types, Expressions, Patterns

  type TypeOrExprOrPatt =
    | typ(*e*) Type
    | expr     Expression
    | patt     Pattern

  (* The (meta) type definitions only express fixpoints, not necessarily least
  ones. We do that by means of a (quite verbose) induction axiom on types,
  expressions, and patterns. *)

  axiom inductionTypesExpressionsPatterns is
    fa (pred : Predicate TypeOrExprOrPatt)
      pred (typ boolean)
   && (fa (tVar:Name) pred (typ (variable tVar)))
   && (fa (tName:Name, types:FSeq Type)
         (fa(t) t in? types => pred (typ t))
      => pred (typ (instance (tName, types))))
   && (fa (t1:Type, t2: Type)
         pred (typ t1) && pred (typ t2)
      => pred (typ (arrow (t1, t2))))
   && (fa (fields:FSeq Name, types:FSeq Type)
         length fields = length types
      && (fa(t) t in? types => pred (typ t))
      => pred (typ (record (zip (fields, types)))))
   && (fa (types:FSeq Type)
         (fa(t) t in? types => pred (typ t))
      => pred (typ (product types)))
   && (fa (constrs:FSeqNE Name, types?:FSeqNE(Option Type))
         length constrs = length types?
      && (fa(t) Some t in? types? => pred (typ t))
      => pred (typ (sum (zip (constrs, types?)))))
   && (fa (t:Type, e:Expression)
         pred (typ t) && pred (expr e)
      => pred (typ (embed sub (t, e)))  % w/o embed, type checker crashes
      && pred (typ (quotien   (t, e))))
   && (fa (var:Name) pred (expr (variable var)))
   && (fa (opp:Name, types:FSeq Type)
         (fa(t) t in? types => pred (typ t))
      => pred (expr (opInstance (opp, types))))
   && (fa (e1:Expression, e2:Expression)
         pred (expr e1) && pred (expr e2)
      => pred (expr (application  (e1, e2)))
      && pred (expr (equation     (e1, e2)))
      && pred (expr (recordUpdate (e1, e2)))
      && pred (expr (restriction  (e1, e2)))
      && pred (expr (choice       (e1, e2)))
      && pred (expr (conjunction  (e1, e2)))
      && pred (expr (disjunction  (e1, e2)))
      && pred (expr (implication  (e1, e2)))
      && pred (expr (equivalence  (e1, e2)))
      && pred (expr (inequation   (e1, e2))))
   && (fa (t:Type, var:Name, e:Expression)
         pred (typ t) && pred (expr e)
      => pred (expr (abstraction ((var, t), e))))
   && (fa (e0:Expression, e1:Expression, e2:Expression)
         pred (expr e0) && pred (expr e1) && pred (expr e2)
      => pred (expr (ifThenElse (e0, e1, e2))))
   && (fa (fields:FSeq Name, exprs:FSeq Expression)
         length fields = length exprs
      && (fa(e) e in? exprs => pred (expr e))
      => pred (expr (record (zip (fields, exprs)))))
   && (fa (e:Expression, field:Name)
         pred (expr e)
      => pred (expr (recordProjection (e, field))))
   && (fa (t:Type, constr:Name)
         pred (typ t)
      => pred (expr (embedder (t, constr))))
   && (fa (e:Expression)
         pred (expr e)
      => pred (expr (relaxator  e))
      && pred (expr (quotienter e))
      && pred (expr (negation   e)))
   && (fa (e:Expression, patts:FSeqNE Pattern, exprs:FSeqNE Expression)
         length patts = length exprs
      && (fa(p) p in? patts => pred (patt p))
      && (fa(e1) e1 in? exprs => pred (expr e1))
      => pred (expr (cas (e, zip (patts, exprs)))))
   && (fa (vars:FSeqNE Name, types:FSeqNE Type, exprs:FSeq Expression,
           e:Expression)
         length vars  = length types
      && length types = length exprs
      && (fa(t) t in? types => pred (typ t))
      && (fa(e1) e1 in? exprs => pred (expr e1))
      && pred (expr e)
      => pred (expr (recursiveLet (zip (zip (vars, types), exprs), e))))
   && pred (expr tru)
   && pred (expr fals)
   && (fa (vars:FSeqNE Name, types:FSeqNE Type, e:Expression)
         (fa(t) t in? types => pred (typ t))
      && pred (expr e)
      => pred (expr (universal   (zip (vars, types), e)))
      && pred (expr (existential (zip (vars, types), e))))
   && (fa (var:Name, t:Type, e:Expression)
         pred (typ t)
      && pred (expr e)
      => pred (expr (existential1 ((var, t), e))))
   && (fa (p:Pattern, e:Expression, e1:Expression)
         pred (patt p)
      && pred (expr e)
      && pred (expr e1)
      => pred (expr (nonRecursiveLet (p, e, e1))))
   && (fa (exprs:FSeqNE Expression)
         (fa(e) e in? exprs => pred (expr e))
      => pred (expr (tuple exprs)))
   && (fa (e:Expression, i:PosNat)
         pred (expr e)
      => pred (expr (tupleProjection (e, i))))
   && (fa (var:Name, t:Type)
         pred (typ t)
      => pred (patt (variable (var, t))))
   && (fa (t:Type, constr:Name, p:Pattern)
         pred (typ t)
      && pred (patt p)
      => pred (patt (embedding (t, constr, p))))
   && (fa (fields:FSeq Name, patts:FSeq Pattern)
         (fa(p) p in? patts => pred (patt p))
      => pred (patt (record (zip (fields, patts)))))
   && (fa (var:Name, t:Type, p:Pattern)
         pred (typ t)
      && pred (patt p)
      => pred (patt (alias (var, t, p))))

endspec
