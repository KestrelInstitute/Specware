%%%%%%%%%% well-formed contexts:

---[cxEmpty]
|- mt : CONTEXT

|- cx : CONTEXT
(type tn) !in cx
---[cxTypeDecl]
|- cx, type tn : CONTEXT

|- cx : CONTEXT
(op o:...) !in cx
cx |- T : TYPE
---[cxOpDecl]
|- cx, op o:T : CONTEXT

|- cx : CONTEXT
(type tn) in cx
(def tn = ...) !in cx
cx |- T : TYPE
---[cxTypeDef]
|- cx, def tn = T : CONTEXT

|- cx : CONTEXT
(op o:T) in cx
(def o = ...) !in cx
cx |- ex1(v:T) v = e
o !in O(e)
---[cxOpDef]
|- cx, def o = e[v/o] : CONTEXT

|- cx : CONTEXT
cx |- e : Bool
(ax[an] ...) !in cx
---[cxAxiom]
|- cx, ax[an] e : CONTEXT

|- cx : CONTEXT
(var v:...) !in cx
cx |- T : TYPE
---[cxVarDecl]
|- cx, var v:T : CONTEXT


%%%%%%%%%% well-formed specs:

|- sp : CONTEXT
FA(v) (var v:...) !in sp
---[speC]
|- sp : SPEC


%%%%%%%%%% well-formed types:

|- cx : CONTEXT
---[tyBoolean]
cx |- Bool : TYPE

|- cx : CONTEXT
(type tn) in cx
---[tyNamed]
cx |- tn : TYPE

cx |- T1 : TYPE
cx |- T2 : TYPE
---[tyArrow]
cx |- T1->T2 : TYPE


%%%%%%%%%% type equivalence:

|- cx : CONTEXT
(def tn = T) in cx
---[tyEqDef]
cx |- tn = T

cx |- T : TYPE
---[tyEqReflexive]
cx |- T = T

cx |- T1 = T2
---[tyEqSymmetric]
cx |- T2 = T1

cx |- T1 = T2
cx |- T2 = T3
---[tyEqTransitive]
cx |- T1 = T3

cx |- T : TYPE
cx |- T1 = T2
T[T1/T2/pos] ~> T'
---[tyEqSubstitution]
cx |- T' : TYPE


%%%%%%%%%% well-typed expressions:

|- cx : CONTEXT
(var v:T) in cx
---[exVariable]
cx |- v : T

|- cx : CONTEXT
(op o:T) in cx
---[exOp]
cx |- o : T

cx |- e1 : T->T'
cx |- e2 : T
---[exApplication]
cx |- e1 e2 : T'

cx, var v:T |- e : T'
---[exAbstraction]
cx |- \v:T.e : T -> T'

cx |- e1 : T
cx |- e2 : T
---[exEquation]
cx |- e1=e2 : Bool

cx |- e : T
cx |- T = T'
---[exEquivalentTypes]
cx |- e : T'

cx |- \v:T.e : T'
v' != v
v' !in FV(e) U CV(v,e)
---[exAlphaAbstraction]
cx |- \v':T.e[v/v'] : T'


%%%%%%%%%% theorems:

|- cx : CONTEXT
(ax[an] e) in cx
---[thAxiom]
cx |- e

|- cx : CONTEXT
(def o = e) in cx
---[thOpDef]
cx |- o = e

cx |- e
cx |- e1 = e2
e[e1/e2/pos] ~> e'
OKsbs(e,e1,e2,pos)
---[thSubstitution]
cx |- e'

cx |- e
cx |- T1 = T2
e[T1/T2/pos] ~> e'
---[thTypeSubstitution]
cx |- e'

cx |- e : Bool -> Bool
v !in FV(e)
---[thBoolean]
cx |- e true && e false <=> fa(v:Bool) e v

cx |- e1 : T
cx |- e2 : T
cx |- e : T -> T'
---[thCongruence]
cx |- e1 = e2 => e e1 = e e2

cx |- e1 : T -> T'
cx |- e2 : T -> T'
v !in FV(e1) U FV(e2)
---[thExtensionality]
cx |- e1 = e2 <=> fa(v:T) e1 v = e2 v

cx |- (\v:T.e) e' : T'
OKsbs(e,v,e')
---[thAbstraction]
cx |- (\v:T.e) e' = e[v/e']
