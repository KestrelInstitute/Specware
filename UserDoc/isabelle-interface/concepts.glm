<chapter id="concepts">
<title>Concepts</title>

<para>
This is the initial experimental release of a &Specware; interface
     that allows the use of &IsabelleHOL; to discharge proof
     obligations that arise in developing &Specware;
     specifications. The interface is essentially just an emacs
     command that converts a &Specware; spec to an &Isabelle; theory,
     along with extensions in the &Specware syntax to allow &Isabelle;
     proof scripts to be embedded in &Specware; specs, and to allow
     the user to specify translation of &Specware; ops and types to
     existing &Isabelle; constants and types. The translation
     translates &Specware; declarations, definitions, axioms and
     theorems to the corresponding &Isabelle; versions. The logics are
     similar so it is usually straightforward to compare the source
     and target of the translations. In addition, &Specware; has
     implicit type obligations, particularly sub-type obligations, that are 
     explicated in the &Isabelle; target.
</para>

<para>
We assume the user is familiar with &IsabelleHOL;. See the tutorial at
<ulink url="http://isabelle.in.tum.de/documentation.html">http://isabelle.in.tum.de/documentation.html</ulink>.
An example Specware spec with Isabelle proofs is given in 
<"Examples/IsabelleInterface/BoolEx.sw">. This spec corresponds to the
Isabelle theory in section 2.2.4 of the &IsabelleHOL; tutorial.
As another example, all of the proof obligations of the specs in
<"Examples/Matching/MatchingSpecs.sw"> can be translated and proved by
&Isabelle; without any user annotation.
</para>

<para>
To see examples of how to specify translation of &Specware; types and
   ops to existing &Isabelle; types and constants, see the bottom of
   the &Specware; Base library specs such as <"Library/Base/Integer.sw"> or
   <"Library/Base/List.sw">.
</para>

<para> A &Specware; definition may translate into one of three
different kinds of Isabelle definitions: [[defs]], [[recdefs]] and
[[primrecs]] (primitive recursions). Simple recursion on coproduct
constructors translates to [[primrec]], but if the function
has multiple arguments, only if the function is curried. Other
recursion translates to [[recdef]] which, in general, requires a
user-supplied measure function to prove termination. Non-recursive
functions are translated to [[defs]], except in some cases they are
translated to [[recdefs]] which allow more pattern matching.
</para>

<para> This initial translator has a number of limitations. It should
translate all &Specware; specs but not all translated definitions and
constructs will be accepted by &IsabelleHOL;. In particular,
only case expressions that involve a single level of pattern-matching
on constructors are accepted. An exception, is that some nesting is
allowed in top-level case expressions that are converted into
definition cases.  Mutual recursion and local recursive functions are
also not currently accepted.
</para>


</chapter>
