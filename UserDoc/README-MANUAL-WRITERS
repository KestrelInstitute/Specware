README-MANUAL-WRITERS
Lambert Meertens

Why glm?
========

To facilitate the creation of documents in the DocBook format -- which
is unpleasantly verbose if you use a plain-text editor -- as well as to
handle various problems concerning the absence of appropriate elements
as well as presentation problems with the standard DocBook tools,
I have devised a terser format, "glm", and written two converters,
glm2dbk and dbk2glm.

How glm?
========

The typical procedure is:

  1) Convert file foobaz.dbk to glm format:

     $ dbk2glm foobaz.dbk > foobaz.glm

  2) Edit file foobaz.glm with your favorite text editor,
     respecting the glm-conventions (see below).

  3) Reconvert file foobaz.glm to dbk format:

     $ glm2dbk -pdf foobaz.glm > foobaz.dbk

     The output produced is slightly different for pdf and
     for html, having to do with suitable fonts as picked by
     default by the standard DocBook tools.  Without the
     -pdf option, html-biased output is produced.

  4) Perform this sanity check (recommended):

     $ dbk2glm foobaz.dbk > @foobaz.glm
     $ diff foobaz.glm @foobaz.glm

     If these are not identical, this might be a bug in the
     X2Y converters, or a sin against the glm conventions.

  5) [Optional] Process the foobaz.dbk file with DocBook tools
     like db2pdf, db2html or jade/pdfjadetex.

Initial creation would normally start with Step 2.

Eventually, I guess, we'll have to have our own DocBook-inspired DTD.
The glm format makes it easy to convert to other (better) element
mappings.

Where glm?
==========

The converter C sources can be found in UserDoc/src/ ,
while executables exist in UserDoc/bin/ARCH/ , for
ARCH ::= sparc | i586.  The sparc files run under Solaris,
the i586 files under Linux on i*86 boxes.

What glm?
=========

The glm format is intended to facilitate, specifically, the inclusion of
listings or fragments of Metaslang text, as well as grammar rules.  For
other stuff, use vanilla DocBook elements.

Metaslang text is enclosed between [[ and ]].

For a listing, put the opening [[ on a line by itself, and start each
line with || as in this example:

    The op [[foo]] can be defined as follows:
    [[
    ||    op foo : Aha * Oho -> Uhu
    ||
    ||    def foo (x : Aha, y : Oho) : Uhu =
    ||        let xy = x(y, y) in
    ||        {aa = y, bb = xy without xy}
    ]]
    The proof that [[foo]], thus defined, satisfies axiom
    [[foo-characterization]] is fairly straightforward and
    left as an exercise to the reader.

Whitespace is handled "verbatim" in listings.  There is no need to
escape "<" and ">" inside [[ ]] enclosures (see "->" in the example).

The role of the || is to make it easier to recover from accidental
reformatting of the text.

For inline Metaslang text, just use [[ ... ]] inline, as above.

If [[:L is used instead of just [[, this signifies that the language is
Lisp rather than Metaslang: [[L:(load "load")]] .

Put a filename between <" and ">, as in <"foobaz.sl">.  This works in
Metaslang text as well as in plain running text, although in
Metaslang text
it has no end-user-visible effect.

Grammar rules are enclosed between << and >>.  Put the opening << on a
line by itself to get a "verbatim" environment, or use << ... >> inline:

    <<
    ||`list-display ::= '[ `list-display-body ']
    ||
    ||`list-display-body ::= [ `expression { , `expression }* ]
    >>

The || is as above.  A backquote ` signifies that a nonterminal follows.
This can also be used in running text, as in:

    With an empty `list-body, the `list-display [[[]]] denotes
    an empty list of the sort determined by the contextual sort
    constraints; it is an error if these constraints do not
    determine the sort uniquely.

(The funny [[[]]] above is, of course, the Metaslang expression
[] enclosed between [[ and ]].)

The following symbols are recognized as special EBNF syntax symbols
inside grammar rules:

    ::=  |  {  }*  [  ]

Note: no space inside }*, and }+ is not recognized.

If any of these symbols is to stand for a terminal symbol, it must be
escaped with a single quote:

    '::=  '|  '{  '}*  '[  ']

See the example above.  Instead of [[[]]], the author could have used
<<'[']>>.

Additionally, a single quote terminal symbol must be escaped, and the
convention is to also escape } as terminal symbol:

    ''  '}

All other text between << and >> is treated as terminal, except for
<...> as noted below.

Many standard DocBook elements can be used inside Metaslang/Lisp program
text and grammar rules, such as the link element, but instead of
<element attr="value">...</element>, use

    \<element attr="value">...\</element>

in which the opening bracket < is escaped with a backslash.  (Recall
that the terminal symbol < need not be escaped here but stands for
itself -- no &lt; translation is needed.)

The existing .glm files should give ample examples.


The following shows the current glm2dbk translation:

glm             dbk
---             ---

\n[[L:\n*]]	\n<programlisting lang="lisp">\n*</programlisting>
\n[[\n*]]	\n<programlisting lang="metaslang">*\n</programlisting>

[[L:*]]		<computeroutput lang="lisp">*</computeroutput>
[[*]]		<computeroutput lang="metaslang">*</computeroutput>

		<![CDATA[
		]]>

<"*">		<filename>*</filename>

\n<<\n*>>	\n<programlistinG lang="syntax">\n*</programlistinG>
<<*>>		<computeroutpuT lang="syntax">*</computeroutpuT>

$$		$
$*$		<replaceable>*</replaceable>

In program displays / syntax only:

\n||*		\n

In program text / syntax only:

<		&lt;
>		&gt;
\<*>		<*>

Anywhere:

`sort-name	<guimenU role="nonterminal">sort-name</guimenU>       for pdf
		<parameteR role="nonterminal">sort-name</parameteR>   for html

In syntax only:

'X		<userinpuT role="terminal">X</userinpuT>
::= | { }* [ ]	unchanged
`sort-name	as above
other stuff	<userinpuT role="terminal">other stuff</userinpuT>

In running text only:

``		<quote>
''		</quote>
