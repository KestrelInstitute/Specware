<chapter id="xshell">
<title>The &XShell;</title>

<section>
<title>Entering and leaving the &XShell;</title>

<para>
The  &XShell; is entered from within the &SShell; by the command
[[
||  transform $spec$
]]
The $spec$ argument is optional; the zero-argument version means: use the last
argument of the kind ``unit'' last used for a &SShell; command.
It must, specifically, be a unit defining a spec.
</para>

<para>
The normal way to leave the &XShell; is the command
[[
||  done
]]
which returns processing to the interactive &SShell; loop.
Before handing back control to the &SShell;, the &XShell; reports the
`transformation-list corresponding to the transformations performed, or
``[[No transformations]]'' if none were performed.
The command [[exit]] and its alias [[quit]] -- actually a &SShell;
commands -- terminates the whole &Specware; session immediately, without
reporting any transformations performed.
</para>
</section>

<section>
<title>Focus and navigation</title>

<para>
Most transformations are only applied to a restricted part of the
spec, called the (transformation) ``focus''.
The focussing command
[[
||  at $op$
]]
puts the focus on the defining `expression for an op.
</para>

<para>
It is possible to navigate by moving the focus around by issuing a move
command
[[
||  move $m1$ $m2$ $m3$ ...
]]
in which each navigation directive $m1$, $m2$, ..., is one of [[first]],
[[last]], [[previous]], [[next]], [[widen]], [[search $token$]],
[[reverse-search $token$]], and [[all]]. The keyword [[move]] is
optional, and each navigation directive may be abbreviated by its first
letter; for example, the command [[p]] is equivalent to [[move
previous]].
</para>

<para>
Assuming the focus has been set [[at x]], where op [[x]] is defined by
[[
||  op x : Nat = (1 + 2) * (if 3 = 4 then 5 else 6)
]]
the subsequent effect of these navigation commands is as follows:
[[
||  (1 + 2) * (if 3 = 4 then 5 else 6)
||  ** first
||  1 + 2
||  ** last
||  2
||  ** previous
||  1
||  ** next
||  2
||  ** widen
||  1 + 2
||  ** search if
||  if 3 = 4 then 5 else 6
||  ** reverse-search +
||  1 + 2
||  ** all
||  (1 + 2) * (if 3 = 4 then 5 else 6)
]]
So [[first]] focusses on the first child of the
<emphasis>current</emphasis> focus that is an `expression, [[last]] focusses on the last child,
[[previous]] and [[next]] on the previous and next sibling, while [[widen]]
widens the focus to the encompassing `expression.
The effect of [[search]] and [[reverse-search]] should be obvious.
Finally, [[all]] widens the focus to the original one.
</para>
</section>

<section id="fold">
<title>Rewrite, unfold, fold</title>

<para>
In the following two &XShell; commands, $claim$ is the name of an axiom
or theorem occurring in the spec, including any imported specs, whose
`expression is a possibly universally quantified equation.
For example, the `expression can be
[[
||  [a] fa (x : List a) x ++ [] = x
]]
In particular, all theorems in the Base library can be used having such
a form.
</para>

<para>
The left-to-right rewrite command
[[
||  lr $claim$
]]
applies the equation, viewed as a rewrite rule, in the left-to-right
direction.
More precisely, the first subexpression of the focus is found that
matches the left-hand side of the equation.
The substitution that made the left-hand side match is applied to the
right-hand side of the equation,and the result replaces the matched
subexpression.
The matching algorithm uses higher-order matching; for example, [[1 +
1]] matches [[f(i, i)]] by the substitution
[[
||  (f, i) := (fn x -> x + x, 1)
]]
The matching algorithm takes account of the types, which should also
match.
</para>

<para>
The right-to-left rewrite command
[[
||  rl $claim$
]]
applies the equation as a rewrite rule in the right-to-left direction: the
first subexpression of the focus is found that matches
the right-hand side of the equation, which then is replaced by the
left-hand side after applying the matching substitution.
</para>

<para>
In the following two &XShell; commands, $op$ is the name of an op that
has a definition in the spec, including any imported specs.
The definition can occur as an `op-definition, as in
[[
||  op [a] twice : (a -> a) -> (a -> a)
||  def twice f x = f(f x)
]]
or in the form of an `op-declaration containing a defining `expression,
as in
[[
||  op [a] twice (f : a -> a) : a -> a = fn x -> f(f( x))
]]
For the purpose of using this in (un)folding transformations, these are
equivalent.
</para>

<para>
The unfold command
[[
||  unfold $op$
]]
``unfolds'' one or more occurrences of `op-name $op$ in the focus,
replacing them by the `expression defining $op$.
So the definition is used very much as if it was an axiom used by an
[[lr]] rewrite command.
For example, in the context of a definition for op [[twice]] as above,
[[unfold twice]] applied to the focus [[posNat? (twice pred n)]]
results in [[posNat? (pred (pred n))]].
</para>

<para>
The fold command
[[
||  fold $op$
]]
``folds'' the first occurrence matching the defining expression for $op$,
replacing it by $op$.
</para>

<para>
Note. Folding may introduce circularity in definitions, and the result
may therefore be an ill-formed spec.
Formally, this means that the proof obligation cannot be discharged
for the requirement that the defining equation have a unique solution.
</para>

</section>

<section id="simp">
<title>Simplification</title>

<para>
The simplify command
[[
||  simplify $r1$ $r2$ $r3$ ...
]]
applies a rewriting simplifier with the supplied rules $r1$ $r2$,
etcetera, which must be given in the form of rewrite commands or
(un)fold commands.
</para>

<para>
For example, instead of giving a sequence of rewrite commands
[[
||  lr commutative_+
||  lr neutral_+_0
]]
a user can issue a single simplify command
[[
||  simplify lr commutative_+ lr neutral_+_0
]]
If any of the rules is found to apply, the simplify command will try to
reapply all rules on the whole resulting new contents of the focus, as
well as its repertoire of some standard simplification rules.
</para>

<para>
The simplify-standard command
[[
||  simp-standard
]]
applies a standard simplifier, without additional rules.
The keyword [[simp-standard]] may be abbreviated to [[ss]].
</para>

<para>
The partial-evaluation command
[[
||  partial-eval
]]
evaluates the closed subexpressions of the focus -- that is, expressions nt
containing unbound variables.
The keyword [[partial-eval]] may be abbreviated to [[pe]].
</para>

<para>
The abstract-common-subexpressions command
[[
||  abstract-cse
]]
abstract common (repeated) subexpressions in the focus expression.
For example, applying it to
[[
||  ("object " ++ obj, "object " ++ obj ++ newline))
]]
results in
[[
||  let cse1 = "object " ++ obj in 
||  (cse1, cse1 ++ newline)
]]
The keyword [[abstract-cse]] may be abbreviated to [[cse]].
</para>

</section>

<section id="diverse">
<title>Diverse</title>

<para>
The undo command
[[
||  undo $n$
]]
undoes the last $n$ commands performed by the &Xshell;
The $n$ parameter is optional, with default 1.
</para>

<para>
The print-current-focus command
[[
||  pc
]]
print the current focus expression.
</para>

<para>
In the course of interactively applying transformations using the
&XShell;, a user may need to modify the spec being processed in order to
proceed, for example by adding a theorem needed for rewriting.
The process command
[[
||  proc $unit-term$
]]
elaborates the $unit-term$ as possibly modified by the user, and
restarts the &XShell; on the processed spec, re-applying any earlier
effectful transformation commands.
The $unit-term$ is optional; the zero-argument version means: use the
same spec as before.
</para>

<para>
The trace-rewrites command
[[
||  trace-rewrites
]]
starts a print trace for individual rewrites.
The keyword [[trace-rewrites]] may be abbreviated to [[trr]].
</para>

<para>
The untrace-rewrites command
[[
||  untrace-rewrites
]]
turns off printing a trace for individual rewrites.
The keyword [[untrace-rewrites]] may be abbreviated to [[untrr]].
</para>
</section>

</chapter>
