<chapter id="debug">
<title>Debugging Generated Lisp Files</title>

<section>
<title>Tracing</title>

<para>
If you need to debug your application, there a number of
useful Lisp facilities you should be aware of.  The simplest
trick is to trace some functions you care about to see what
they are doing.
</para>

[[
||(trace foo)
||  This will display the arguments to foo each time it is 
||  called, and will display the results each time it returns.
||
||(untrace foo)
||  This will turn off any tracing on foo.
]]

</section>
<section>
<title>Breaking</title>

<para>
If you need a more detail view of runtime behavior, you might
want to BREAK some functions you care about.  
</para>

[[
||(trace (foo :break-all t))  
||
||  This will invoke the debugger each time foo is called,                   
||  and upon each exit from foo.
]]

<para>
Once you arrive in the debugger, the following commands are 
most useful:
</para>

[[
|| :down <n>    Move to a deeper frame  <n> is optional
|| :up <n>      Move to a higher frame  <n> is optional
|| :zoom <n>    Display n frames        <n> is optional
||
|| :pri         Enter a dialog that lets you set printer 
||              control variables.  For example, setting depth
||              to 5 and length to 10 will let you see the
||              top level structure of expressions, while 
||              suppressing deep expressions and the tails of
||              long expressions.  Note that you'll need to 
||              specify values for many contexts, but just 
||              hitting return leaves a value unchanged.  You
||              will likely want to modify the trace, debugger,
||              and current values.  
||
|| (pprint *)   Pretty print the expression for the current
||              frame.  Note that this only works immediately
||              after arriving at a frame, e.g. via :down 0
||              if necessary.
||
|| :cont        Continue as if nothing happened.
|| :restart     Resume execution at this frame.
|| :reset       Return to Lisp top level.  (E.g., bail out
||              to try again.)
|| :exit        Exit from Lisp to operating system -- ends
||              session.
||
|| :help        Online documentation.
||
|| (misc ...)   The debugger is is a read/eval/print loop, so
||              arbitrary Lisp forms will be evaluated (in the
||              current dynamic context).
||
|| (untrace foo)  Stop entering debugger when foo is called.
||                Note that you may still enter the debugger
||                for each exit from calls to foo already 
||                recursively in progress.
]]

</section>

<section>
<title>Timing</title>

<para>
If you are curious about the overall performance of your
application, the [[L:time]] macro will provide some quick 
information:
</para>

[[
||(time (foo nil))  
||  This will report the time and space used by foo, e.g.:
||
|| USER(1): (time (list 1 2 3))
|| ; cpu time (non-gc) 0 msec user, 0 msec system
|| ; cpu time (gc)     0 msec user, 0 msec system
|| ; cpu time (total)  0 msec user, 0 msec system
|| ; real time  231 msec
|| ; space allocation:
|| ;  6 cons cells, 0 symbols, 0 other bytes, 0 static bytes
|| (1 2 3)
]]

<para>
Note that [[L:time]] is transparent, i.e., it returns whatever its
argument would return, including multiple values, etc., so
it is safe to intersperse it nearly anywhere.
</para>

<para>
Common Lisp has more facilities for rolling your own timers:
see the generic Common Lisp documentation, or contact Kestrel
Technologies.
</para>
</section>

<section>
<title>Interrupting</title>

<para>
Finally, note that a useful trick in Lisp is to start your
application, e.g. [[L:(foo nil)]], then at an appropriate time
hit Cntrl-C.  This will interrupt your application and put
your into the debugger.  From there you can enter the command
[[L::zoom]] to see the top of the stack.  That can often be quite
revealing.  
</para>

</section>

</chapter>
