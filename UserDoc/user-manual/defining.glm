<chapter id="defining">
<title>Defining Units</title>

<section>
<title>Conceptual Model</title>

<para>A unit definition consists of a unit identifier and a unit term.
The identifier identifies the unit and the term defines how the unit
is constructed.</para>

<para>A project developed with &Specware; consists of a set of
unit definitions, some of which may come from libraries. Units have
unique identifiers within the project.</para>

<section>
<title>Unit Identifiers</title>

<para>A unit identifier is a finite, non-empty sequence of word
symbols (word symbols are defined in the &Metaslang; grammar).  The
sequence of word symbols is essentially a ``path'' in a tree: the
units comprising a project are organized in a tree.</para>

<para>This provides a convenient and simple way to organize the units
comprising a project. Libraries are subtrees of the whole
tree. Parallel development of different parts of a project can be
carried out in different subtrees that can be later put together
without risk of naming clashes.</para>

</section>

<section>
<title>Unit Terms</title>

<para>A unit term is text written in the &Metaslang;
language. &Metaslang; features various ways to construct specs,
morphisms, and all the other kinds of units. For instance, it is
possible to construct a spec by explicitly listing its types, ops, and
axioms.  It is also possible to construct a spec by applying the
colimit operation to a diagram of specs and morphisms.</para>

<para>A unit term may reference other units. For instance, a spec
constructed by extending another one references the spec being
extended.</para>

<para>
References can be ``&swpath;-based'' or ``relative''.
In either case they are
resolved to full unit identifiers of units in the tree,
according to simple rules explained later.
</para>

</section>

</section>  <!-- conceptual model -->

<section>
<title>Realization via the File System</title>

<para>The conceptual model just described is realized by means of the
file system of the underlying operating system. The file system has
essentially a tree structure. The tree of units comprising a
&Specware; project is mapped to subtrees of the file system; the
word symbols comprising a path are mapped to file and directory
names.</para>

<para>Future versions of &Specware; will have a more sophisticated UI
that will realize the conceptual model directly. Users will
graphically see the units organized in a tree and they will be able to
add, remove, move, and edit them. The mapping to the file system may
even be made totally transparent to the user.</para>

<section>
<title>The &swpath; Environment Variable</title>

<para>The mapping of the conceptual unit tree to the file system is
defined by the environment variable &swpath;. Similarly to the
[[PATH]] environment variable in operating systems, &swpath; is a
string consisting of a semicolon-separated list of absolute directory
paths in the file system. See <xref linkend="swpath"> for information
on how to inspect and set &swpath;.</para>

<para>Roughly speaking, the unit tree consists of all the units defined
in <".sw"> files under the directories listed in &swpath;. The
identifier of each unit is its path from the directory in &swpath;
under which the file defining the unit is: if the unit is under
a directory named <"ub2">, its identifier is its absolute path in the file
system ``minus'' the <"ub2"> prefix.  This approximate statement is
made precise and illustrated by examples below.</para>

</section>

<section>
<title>Single Unit in a File</title>

<para>The simplest way to define a unit is to write its term into a
<".sw"> file in the subtree of one of the directories in &swpath;. The
identifier of the unit is the name of the file, without <".sw">,
prefixed by the path from the directory in &swpath; to the
file.</para>

<para>For example, suppose that &swpath; includes the directory
<"C:\users\me\specware">. The user creates a file named <"A.sw">
immediately under the directory <"C:\users\me\specware\one\two">,
containing the following text:</para>

[[
||    spec
||      type X
||    endspec
]]

<para>The absolute path of the file in the file system is
<"C:\users\me\specware\one\two\A.sw">. The unit is a spec containing
just a type [[X]]. The identifier of the unit is [[/one/two/A]]. Note
that the path components are separated by ``/'' (forward slash), even
though the underlying file system uses ``\'' (backward slash). Unit
identifier are sequences of word symbols separated by ``/'',
regardless of the underlying operating system.</para>

</section>

<section>
<title>Multiple Units in a File</title>

<para>It is also possible to put multiple units inside a <".sw">
file. The file must be in the subtree of one of the directories in
&swpath;. Instead of just containing a unit term, the file contains
one or more unit definitions. A unit definition consists of a word
symbol, ``='' (equal), and a unit term.</para>

<para>This case works almost exactly as if the file were replaced by a
directory with the same name (without <".sw">) containing one <".sw">
file for every unit defined therein. Each such file has the word
symbol of the unit as name (plus <".sw">) and the term of the unit as
content.</para>

<para>The only difference between the case of multiple units per file
and the almost equivalent case where the file is replaced by a
directory containing single-unit files, is that in the former case the
last separator is not ``/'' but ``#'' (sharp). (This is reminiscent of
the URI syntax, where subparts of a document are referred to using
``#''.)</para>

<para>Suppose, as in the previous example, that &swpath; includes the
directory <"C:\users\me\specware">. The user creates a file named
<"three.sw"> immediately under the directory
<"C:\users\me\specware\one\two">, containing the following
text:</para>

[[
||    B = spec
||      type Y
||    endspec
||
||    three = spec
||      import B
||      type Z
||    endspec
]]

<para>This file defines two specs, one containing just a type [[Y]],
the other containing just a type [[Z]]. The identifier of the first
spec is [[/one/two/three#B]], the identifier of the second spec is
[[/one/two/three#three]].</para>

<para>As a particular instance of the case of multiple units per file,
it is possible to have just one unit definition in the file. This is
different from just having a unit term in a file. If the file contains
a unit definition, then the word symbol at the left of ``='' is part
of the unit's identifier, together with ``#'' and the file path
(relative to the directory in &swpath;).  If instead the file contains
a unit term, then the identifier of the unit is the file path
(relative to the directory in &swpath;), without any ``#'' and
additional word symbol.</para>

<para>Despite the possibility of having one unit definition in a file,
in this manual we use the term ``multiple-unit file'' to denote a file
that contains one or more unit definitions. The term ``single-unit
file'' is instead used to denote a file that only contains a unit
term.</para>

<para>As a convenience, a unit in a multiple-unit file with
the same name as the file (without the directory and extension) may be
referred to with a URI for the file as a whole. For example, in the
current case, the identifier [[/one/two/three]] refers to the same
spec as [[/one/two/three#three]]. This feature supports a style of
having one primary unit in a file with auxiliary units that are
used to define the primary unit.</para>

</section>

</section>  <!-- realization -->

<section>
<title>Unit Definitions Are Managed Outside of &Specware;</title>

<para>The <".sw"> files are created, deleted, moved, and renamed by
directly interacting with the file system of the underlying operating
system.</para>

<para>The content of the <".sw"> files can be edited with any desired
text editor. A possibility is to use XEmacs, which is started when
&Specware; is started and is used to interact with &Specware;. The
XEmacs-&Specware; combo can be thought of as a (rather limited)
Integrated Development Environment (IDE).</para>

<para>Note that unit definitions can be managed without running
&Specware; at all. As described in the next chapter, &Specware; is
used to process unit definitions. Future versions of &Specware; will
provide true IDE functionality: unit definitions will be also managed
within &Specware;, and the mapping to the file system could be even
made transparent to the user.</para>

</section>  <!-- units definitions are managed outside of specware -->

</chapter>
