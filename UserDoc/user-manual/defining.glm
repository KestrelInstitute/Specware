<chapter id="defining">
<title>Defining Units</title>

<section>
<title>Conceptual Model</title>

<para>A unit definition consists of a name and some defining text.
The name identifies the unit and the text describes how the unit is
constructed.</para>

<para>An application developed with &Specware; consists of a set of
unit definitions, some of which may come from libraries. Units have
unique names within the application.</para>

<section>
<title>Names</title>

<para>A unit name is a finite, non-empty sequence of identifiers
(identifiers are defined in the &Metaslang; grammar). The sequence of
identifiers is essentially a ``path'' in a tree: the units comprising
an application are organized in a tree.</para>

<para>This provides a convenient and mundane way to organize the name
space of the units comprising an application. Libraries are subtrees
of the whole tree. Parallel development of different parts of an
application can be carried out in different subtrees that can be later
put together without any risk of name clashes.</para>

</section>

<section>
<title>Defining Text</title>

<para>The defining text of a unit is written in the &Metaslang;
language. &Metaslang; features various operations to construct specs,
morphisms, and all the other kinds of units. For instance, it is
possible to construct a spec by explicitly listing its sorts, ops, and
axioms.  It is also possible to construct a spec by applying the colimit
operation to a diagram of specs and morphisms.</para>

<para>The defining text of a unit may contain references to other
units. For instance, a spec constructed by extending another one
contains a references to the spec being extended. References can be
absolute or relative, and they are resolved to units in the tree. The
former consist in complete paths in the tree; the latter consist in
partial paths that are combined with the path of the referencing unit
(according to simple rules explained later) to form a complete path in
the tree.</para>

</section>

</section>  <!-- conceptual model -->

<section>
<title>Realization via the File System</title>

<para>The conceptual model just described is realized by means of the
file system of the underlying operating system. The file system has
essentially a tree structure. The tree of units comprising a
&Specware; application is mapped to subtrees of the file system; the
identifiers comprising a path are mapped to file and directory
names.</para>

<para>Future versions of &Specware; will have a more sophisticated UI
that will realize the conceptual model directly. Users will
graphically see the units organized in a tree and they will be able to
add, remove, move, and edit them. The mapping to the file system may
even be made totally transparent to the user.</para>

<section>
<title>The &swpath; Environment Variable</title>

<para>The mapping of the conceptual unit tree to the file system is
defined by the environment variable &swpath;. Similarly to the
``path'' environment variable in operating systems, &swpath; is a
string consisting of a colon-separated list of absolute directory
paths in the file system.</para>

<para>The value of &swpath; can be inspected by means of the following
command (at the Lisp shell):</para>

[[L:
||    :swpath
]]

<para>The value of &swpath; can be changed by means of the following
command:</para>

[[L:
||    :swpath <string>
]]

<para>The [[L:<string>]] must be a colon-separated list of absolute
directory paths, surrounded by double quotes.</para>

<para>Changes to &swpath; only apply to the currently running
&Specware; session. If &Specware; is quit and then restarted, &swpath;
loses the value assigned to it during the previous session, reverting
to its default value.</para>

<para>Roughly speaking, the unit tree consist of all the units defined
in <".sw"> files under the directories listed in &swpath;. The name of
each unit is its path from the directory in &swpath; under which the
file defining the unit is: i.e., if the unit is under directory
<"dir">, its name is its absolute path in the file system ``minus''
the <"dir"> prefix.  This approximate statement is made precise below
and illustrated by examples.</para>

</section>

<section>
<title>Single Unit in a File</title>

<para>The simplest way to define a unit is to write its defining text
into a <".sw"> file under one of the directories in &swpath;. The name
of the unit is the name of the file, without <".sw">, prefixed by the
path from the directory in &swpath; to the file.</para>

<para>For example, suppose that &swpath; includes the directory
<"\users\me\specware"> (in the Windows operating system; currently,
since &swpath; is colon-separated, it is not possible to use drive
identifiers in directories; &Specware; automatically prefixes
directories with <"c:">; this restriction will be removed in future
versions of &Specware;). The user creates a file named <"A.sw">
immediately under the directory <"\users\me\specware\one\two">,
containing the following text:</para>

[[
||    spec
||      sort X
||    endspec
]]

<para>The absolute path of the file in the file system is
<"\users\me\specware\one\two\A.sw">. The unit is a spec containing
just a sort [[X]]. The name of the unit is [[one/two/A]]. Note that
the path components are separated by forward slashes ``/'', even
though the underlying file system uses backward slashes ``\''. Unit
names are sequences of identifiers separated by forward slashes,
regardless of the underlying operating system.</para>

</section>

<section>
<title>Multiple Units in a File</title>

<para>It is also possible to put multiple units inside a <".sw">
file. The file must be under one of the directories in
&swpath;. Instead of just containing the defining text of a unit, the
file contains one or more unit definitions. A unit definition consists
of an identifier, an equal sign ``='', and defining text.</para>

<para>This case works almost exactly as if the file were replaced by a
directory with the same name (without <".sw">) containing one <".sw">
file for every unit defined therein. Each such file has the identifier
of the unit as name (plus <".sw">) and its defining text as
content.</para>

<para>The only difference between the case of multiple units per file
and the almost equivalent case where the file is replaced by a
directory containing single-unit files, is that in the former case the
last separator is not forward slash but the sharp sign ``#''. (This is
reminiscent of the URI syntax, where subparts of a document are
identified using the sharp sign.)</para>

<para>Suppose, as in the previous example, that &swpath; includes the
directory <"\users\me\specware">. The user creates a file named
<"three.sw"> immediately under the directory
<"\users\me\specware\one\two">, containing the following
text:</para>

[[
||    B = spec
||      sort Y
||    endspec
||
||    C = spec
||      sort Z
||    endspec
]]

<para>This file defines two specs, one containing just a sort [[Y]],
the other containing just a sort [[Z]]. The name of the first spec is
[[one/two/three#B]], the name of the second spec is
[[one/two/three#C]].</para>

<para>As a particular instance of the case of multiple units per file,
it is possible to have just one unit definition in the file. This is
different from just having defining text of a unit in a file. If the
file contains a unit definition, then the identifier at the left of
the equal sign is part of the unit's name, together with the sharp
sign and the file path (relative to the directory in &swpath;).  If
instead the file contains defining text for a unit, then the name of
the unit is the file path (relative to the directory in &swpath;),
without any sharp sign and additional identifier.</para>

</section>

</section>  <!-- realization -->

<section>
<title>Unit Definitions Are Managed Outside of &Specware;</title>

<para>The <".sw"> files are created, deleted, moved, and renamed by
directly interacting with the file system of the underlying operating
system.</para>

<para>The content of the <".sw"> files can be edited with any desired
text editor. A possibility is to use XEmacs, which is started when
&Specware; is started and is used to interact with &Specware;. The
XEmacs-&Specware; combo can be thought as a (rather limited)
Integrated Development Environment (IDE).</para>

<para>Note that unit definitions can be managed without starting
&Specware; at all. As described in the next chapter, &Specware; is
used to process unit definitions. Future versions of &Specware; will
provide true IDE functionality: unit definitions will be also managed
within &Specware;, and the mapping to the file system could be even
made transparent to the user.</para>

</section>  <!-- units definitions are managed outside of specware -->

</chapter>
