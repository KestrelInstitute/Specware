<section id="javacodegen">
<title>Generating Java Code</title>

<para> As an experimental feature, Specware provides the possibility
to generate Java code from constructive &Metaslang; specs.  The Java code
generator can either be called from the &SShell; or using the
[[generate]] construct inside a <".sw"> file. In both cases, an
additional ``option'' spec can be supplied, which is used to specify
certain parameters that govern aspects of code generation.
For the format of the option spec, see <xref linkend="optionspec">.
</para>

<para>The command has the form:
[[
||   gen-java $spec-term$ [$option-spec-term$]
]]
where the result of elaborating the spec term gives the spec
to be translated into Java and
the second spec term
gives the option spec (see below).</para>

<!--

<para>Inside a <".sw"> file:

[[
||   generate Java <spec-term> with <option spec-id>
]]

Example contents of a <".sw"> file generating Java code: 

[[
||  let myspec = spec 
||   ...
||  endspec
||  in
||  let myoptions = spec
||      def package = "com.mycompany.myapp"
||      ...
||  endspec
||  in
||  generate java myspec with myoptions
]]
</para>

-->

<section id="optionspec">
<title>The Option Spec</title>

<para>The option spec is used as an attribute store to be
able to control certain parameters used by the Java code generator.
The option spec is a regular &Metaslang; spec.
The parameters are
given by constant ops defined inside the option spec.
The following list
contains the op names and types that are currently
interpreted as parameters by the
Java code generator:</para>

<informaltable frame="sides" colsep="1">
 <tgroup cols="3">
  <colspec colname="op"      colnum="1" colwidth="143" rowsep="1">
  <colspec colname="used"    colnum="2" colwidth="145" rowsep="1">
  <colspec colname="default" colnum="3" colwidth="135" rowsep="1">
  <thead>
   <row>
     <entry colname="op">Op name &amp; type</entry>
     <entry colname="used">Used as</entry>
     <entry colname="default">Default value</entry>
   </row>
  </thead>
  <tbody>
   <row>
    <entry colname="op">[[package : String]]</entry>
    <entry colname="used">Name of the Java package for all generated Java class files. The
      package name also determines the relative path of the generated
      <".java"> files (see the [[basedir]] parameter)
     </entry>
    <entry colname="default">[["specware.generated"]]</entry>
   </row>
   <row>
    <entry colname="op">[[basedir : String]]</entry>
    <entry colname="used">The base directory used for the generated Java class files. The
     full path is determine by this parameter and the relative path
     derived from the package name. For instance, if the value of [[basedir]]
     is the string [["/a/b"]]
     and the package name is <"c.d.e">, then the generated Java class
     files would go into the directory <"/a/b/c/d/e">.
    </entry>
    <entry colname="default">[["."]]</entry>
   </row>
   <row>
    <entry colname="op">[[public : List String]]</entry>
    <entry colname="used">The list of op names that are to be declared as [[public]] in the
     generated Java code. Only unqualified identifiers can be used in
     this list. The ops in this list determine the ``entry points'' into
     the generated Java code, if it is embedded in another Java
     application.
    </entry>
    <entry colname="default">[[[]]]</entry>
   </row>
   <row>
    <entry colname="op">[[imports : List String]]</entry>
    <entry colname="used">The list of imports that are to be used for all generated Java
     class files. Each element of this list has the usual format of
     the argument used by Java's import statement; e.g.,
     [["java.util.*"]]
    </entry>
    <entry colname="default">[[[]]]</entry>
   </row>
  </tbody>
 </tgroup>
</informaltable>



<para>Example option spec:

[[
||  spec
||    def package = "test.sw.gen"
||    def imports = ["java.util.*"]
||    def public = ["test2"]
||    def basedir = "~/myjavaapps"
||  endspec
]]

If no option spec is specified in the [[gen-java]] command, default
values are used for all option parameters.
</para>


</section>

<section>
<title>Translation of Inbuilt Ops</title>

<para>The following table shows the translation of some inbuilt &Metaslang; ops into Java:</para>

<informaltable frame="sides" colsep="1">
 <tgroup cols="2">
  <colspec colname="mtsl" colnum="1" colwidth="200" rowsep="1">
  <colspec colname="java" colnum="2" colwidth="200" rowsep="1">
  <thead>
   <row>
     <entry colname="mtsl">&Metaslang;</entry>
     <entry colname="java">Java</entry>
   </row>
  </thead>
  <tbody>
   <row>
     <entry colname="mtsl">
[[
||String.writeLine(t)
||String.toScreen(t)
]]
     </entry>
     <entry colname="java">[[System.out.println(t)]]</entry>
   </row>
   <row>
     <entry colname="mtsl">
[[
||String.concat(t1,t2),
||t1 ++ t2,
]]
     </entry>
     <entry colname="java">[[t1 + t2]]</entry>
   </row>
   <row>
     <entry colname="mtsl">[[String.newline]]</entry>
     <entry colname="java">
[[
||System.getProperty
||  ("line.separator")
]]
    </entry>
   </row>
   <row>
     <entry colname="mtsl">[[String.length]]</entry>
     <entry colname="java">[[t.length()]]</entry>
   </row>
   <row>
     <entry colname="mtsl">[[String.substring(s,n1,n2)]]</entry>
     <entry colname="java">[[s.substring(n1,n2)]]</entry>
   </row>
   <row>
     <entry colname="mtsl">
[[
||Nat.toString(n)
||Nat.natToString(n)
||Nat.show(n)
||Integer.toString(n)
||Integer.intToString(n)
||Integer.show(n)
]]
</entry>
     <entry colname="java">[[String.valueOf(n)]]</entry>
   </row>
   <row>
     <entry colname="mtsl">
[[
||Nat.stringToNat(s)
||Integer.stringToInt(s)
]]
     </entry>
     <entry colname="java">[[Integer.parseInt(s)]]</entry>
   </row>
   <row>
     <entry colname="mtsl">[[t1 && t2]]</entry>
     <entry colname="java">[[t1 && t2]]</entry>
   </row>
   <row>
     <entry colname="mtsl">[[t1 || t2]]</entry>
     <entry colname="java">[[t1 || t2]]</entry>
   </row>
   <row>
     <entry colname="mtsl">[[t1 => t2]]</entry>
     <entry colname="java">[[t1 ? t2 : true]]</entry>
   </row>
   <row>
     <entry colname="mtsl">[[t1 <=> t2]]</entry>
     <entry colname="java">[[t1 ? t2 : !t2]]</entry>
   </row>
  </tbody>
 </tgroup>
</informaltable>

</section>

<section>
<title>&Metaslang;/Java Interface</title>

<para>In order to use Java methods and classes inside a &Metaslang; spec, the following
conventions are used by the Java code generator:</para>

<itemizedlist>
<listitem>
<para>
Java Classes --
  In order to use Java classes as types inside &Metaslang;, you have to declare the type without
  a definition and add corresponding Java import statements using the option spec (see above).
</para>

  <para>Example: use of the Java class <"java.util.Vector"></para>

     <para>In the spec for which code is generated:

[[
||   ...
||   type Vector
||   ...
||   op myvectorop: Vector -> Nat
||   def myvectorop(v) = ...
||   ...
]]

     In the option spec:

[[
||   ...
||   def imports = [ ..., "java.util.*", ... ]
||   ...
]]

  The code generator interprets all types without a definition as base types,
  so that in this case the op [[myvectorop]] becomes a static method in the
  generated [[Primitive]] class.</para>
</listitem>
<listitem>
  <para>
  Accessing External Java Instance Methods --
  Instance methods as well as static class methods can be accessed from inside
  &Metaslang; specs using
  the following convention:</para>

  <para>
  Assume, we want to use some instance method [[epi(args)]] defined in Java class <"Tecton">.
  First, the class must be made known to &Metaslang; by providing a type declaration
  for the class. Then, an op [[epi]] must be declared with a signature that corresponds
  to the method's signature, but with an additional parameter preceeding the others. The type
  of that parameter must be the class type:

[[
|| type Tecton
|| op epi: Tecton * T1 * ... * Tn -> T
]]

  where [[T1 * ... * Tn -> T]] is the original signature of [[epi]] without the additional parameter.
  The [[Ti]]'s are the translated &Metaslang; types that correspond to the Java types occurring in
  [[epi]]'s signature; see the table below for the type correspondence.
  In the &Metaslang; code,
  a call to the instance method is created by the Java code generator whenever [[epi]] is applied:

[[
||  def mycode(...) =
||    ...
||    let b : Tecton = ... in
||      ...
||      ... epi(b,arg1,...argn) ...
]]

  Note, that a definition term must not be given for [[epi]].
  Limitation: using [[epi]] as a function symbol in higher-order contexts will not yield the
  expected result.</para>
</listitem>
<listitem>
<para>
  Accessing External Java Class Methods --
  Accessing Java class methods is very similar to instance methods, with the difference
  that instead of the type of the first argument, the qualifier of the op declaration is
  used to determine the class name. Therefore, in general, it is not necessary to declare
  the class as a type. Assume we want to access to class method [[Math.abs()]] from the Java
  library. We therefore declare the [[abs]] operator in &Metaslang; as follows:

[[
||   op Math.abs: Integer -> Nat
]]

  The code generator will then generate a call to the static method [[Math.abs()]] whenever
  it is used in the &Metaslang; spec.  The access to static methods has lower priority than
  the access to instance methods: if the first argument is a user type that is not defined
  in the spec, than the instance call is generated. In other words, a static method in
  <emphasis>class</emphasis> <"A"> with a first argument of <emphasis>type</emphasis> [[A]] will not be accessible from &Metaslang;. The latter
  situation is not very common, and in practice this does not constitute a limitation of the
  &Metaslang;-Java interface.</para>
</listitem>
<listitem>
<para>
Accessing Java Constructors --
  Accessing Java constructors follows the same principle as for class
  methods.  The difference is that on the &Metaslang; side, an op with a name having the
  prefix [[new]] and an appropriate result type must be declared.  For instance, the Java
  class [[Vector]] declares a constructor with no arguments.  If we want to use that in
  &Metaslang;, we have to provide the following declarations:

[[
|| type Vector
|| op Vector.new: () -> Vector
]]

  Whenever [[Vector.new()]] is used as a term in the &Metaslang; spec, a call to the
  corresponding Java constructor in the <"Vector"> class is generated.
  If the class has
  multiple constructors with different parameter lists, multiple [[new]] ops can be declared
  in the &Metaslang; spec with different suffixes (e.g., [[new_2]]) The Java code ignores the
  suffixes, but they are essential for &Metaslang;, which does not allow the redefinition of
  ops with different signatures.
</para>


<para>In general, if multiple methods and constructors from a class in the Java library need to
be accessed in a &Metaslang; spec, it is a good idea to structure them using the
[[qualifying]] feature of &Metaslang;. For instance:

[[
|| Vector qualifying spec 
||       type Vector
||       op new: () -> Vector
||       op add: [a] Vector * a -> Vector
||       op size: Vector -> Nat
|| endspec
||
|| Math qualifying spec
||       op max: Integer * Integer -> Integer
||       op min: Integer * Integer -> Integer
||       ....
|| endspec
]]

and then importing the specs into the application spec that uses it. Future versions of the
Specware system will provide a utility to convert a given Java class into a spec following
the above conventions.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>Type Conversion between Java and &Metaslang;</title>

<para>The following table shows the conversion of Java types to &Metaslang;, which can be used
when accessing Java methods from &Metaslang;</para>

<informaltable frame="sides" colsep="1">
 <tgroup cols="2">
  <colspec colname="java" colnum="1" colwidth="200" rowsep="1">
  <colspec colname="mtsl" colnum="2" colwidth="200" rowsep="1">
  <thead>
   <row>
     <entry colname="java">Java</entry>
     <entry colname="mtsl">&Metaslang;</entry>
   </row>
  </thead>
  <tbody>
   <row>
    <entry colname="java">[[int]]</entry>
    <entry colname="mtsl">[[Integer]]</entry>
   </row>
   <row>
    <entry colname="java">[[boolean]]</entry>
    <entry colname="mtsl">[[Boolean]]</entry>
   </row>
   <row>
    <entry colname="java">[[char]]</entry>
    <entry colname="mtsl">[[Char]]</entry>
   </row>
   <row>
    <entry colname="java">[[void]]</entry>
    <entry colname="mtsl">[[()]]</entry>
   </row>
   <row>
    <entry colname="java">
[[
||byte
||short
||float
||double
]]
    </entry>
    <entry colname="mtsl">not implemented</entry>
   </row>
   <row>
    <entry colname="java">Any Java class name</entry>
    <entry colname="mtsl">&Metaslang; type with the same name (type must be declared in the spec)</entry>
   </row>
  </tbody>
 </tgroup>
</informaltable>

</section>
</section>
