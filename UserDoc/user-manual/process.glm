<chapter id="process">
<title>Processing Units</title>

<section>
<title>Overview</title>

<para>Unit definitions are processed by &Specware;. The user instructs
&Specware; to process units by supplying certain commands. &Specware;
has access, via the Lisp run time environment, to the underlying file
system, so it can access the unit definitions contained in <".sw">
files. The environment variable &swpath; determines which <".sw">
files are accessed by &Specware; to find unit definitions.</para>

<para>Processing a unit causes processing of the units referenced in
the defining text of the unit, recursively. For instance, if a spec
[[A]] extends a spec [[B]] which in turns extends a spec [[C]], when
[[A]] is processed also [[B]] and [[C]] are processed. There must be
no circularities in the chain of unit dependencies.</para>

<para>Processing causes progress and/or error messages to be displayed
on the screen, in the XEmacs buffer containing the Lisp shell (where
the user also supplies commands to &Specware;). Progress messages
inform the user that units are processed without error. Error messages
provide information on the cause of errors, so that the user can fix
them by editing the unit definitions. When an error occurs in the
definition of some unit, &Specware; displays the <".sw"> file
containing the definition in an XEmacs buffer, with the cursor at the
point where the erroneous text is.</para>

<para>The processing of certain kinds of units also results in the
creation of new files, as an additional side effect. For instance,
Lisp programs are a kind of unit, constructed by the [[generate]]
operator of &Metaslang;. A side effect of processing one such unit is
that the resulting code is written into a <".lisp"> file.</para>

<para>When &Specware; processes a unit, it saves the processing
results into an internal cache, associating the results to the unit's
name. By using this cache, &Specware; avoid unnecessary
re-computations: it only re-processes the units whose files have
changed since they were processed last time. From the point of view of
the final result, this caching mechanism is completely transparent to
the user. However, it improves the performance and response time of
the system.</para>

</section>  <!-- overview -->

<section>
<title>Resolution of Unit References</title>

<para>References to units may occur in the defining text of units and,
as described later, in &Specware; commands. A unit reference is
resolved to the defining text of the unit, which is contained in a
<".sw"> file. Reference are either absolute or relative; these two
kinds are syntactically distinguished from each other and they are
resolved in slightly different ways.</para>

<section id="absoluteref">
<title>Absolute References</title>

<para>An absolute reference starts with ``/'' (forward slash),
followed by a ``/''-separated sequence of one or more identifiers,
where the last separator can be ``#'' (sharp). Examples are
[[/a/b/c]], [[/d]], and [[/e#f]].

<para>&Specware; resolves an absolute reference in the following
steps:</para>

<orderedlist>

<listitem>If the reference contains ``#'', the ``#'' itself and the
identifier following it are removed, obtaining a ``/''-separated
sequence of one or more identifiers, preceded by ``/''. Otherwise, no
removal takes place. Either way, the result of this first step is a
``/''-separated sequence of identifiers preceded by ``/''.</listitem>

<listitem>If the underlying operating system is Windows, the ``/''
signs of the ``/''-separated sequence of identifiers preceded by
``/'', resulting from the previous step, are turned into ``\''
(backward slash); in addition, <".sw"> is appended at the
end. Otherwise, the ``/'' signs are left unchanged and <".sw"> is
appended at the end. Either way, the result of this second step is a
(partial) path in the file system.</listitem>

<listitem>The path resulting from the previous step is appended after
the first directory of &swpath;. If the resulting absolute path
identifies an existing file, that is the result of this third step.
Otherwise, the same attempt is made with the second directory of
&swpath; (if any). Attempts continue until a directory is found in
&swpath; such that the absolute path obtained by concatenating the
directory with the result of the previous step identifies an existing
file; such a file is the result of this step. If no such directory is
found, the unit reference cannot be resolved and an error is signaled
by &Specware;.</listitem>

<listitem>There are two alternative steps here, depending on whether
the original unit reference contains ``#'' or not.</listitem>

<orderedlist>

<listitem>This is the case that the original unit reference does not
contain ``#''. If the file resulting from the previous step is a
single-unit file, i.e., it contains the defining text for a unit, the
defining text is the final result of resolution. Otherwise, an error
is signaled by &Specware;.</listitem>

<listitem>This is the case that the original unit reference contains
``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit reference cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose identifier (at
the left of ``='') is the same as the identifier that follows ``#'' in
the original unit reference. If no such unit definition is found, the
unit reference cannot be resolved and an error is signaled by
&Specware. If instead such a unit definition is found, its defining
text (at the right of ``='') is the final result of
resolution.</listitem>

</orderedlist>

</orderedlist>

<para>For example, consider a reference [[/a/b/c]]. Since it does not
contain ``#'', the first step does not do anything. Assuming that the
underlying operating system is Windows, the result of the second step
is <"\a\b\c.sw">. Suppose that &swpath; is
<"\users\me\specware:\tmp">, that <"c:\users\me\specware"> does not
contain any <"a"> subdirectory, and that <"c:\tmp\a\b\c.sw"> exists.
The result of the third step is the file <"c:\tmp\a\b\c.sw">.  If such
a file is a single-unit file, its content is the result of the fourth
step.</para>

<para>As another example, consider a reference [[/e#f]]. The result of
the first step is [[/e]]. The result of the second step (still
assuming Windows) is <"\e.sw">. Assuming &swpath; as before and that
<"c:\users\me\specware"> contains a file <"e.sw">, the file
<"c:\users\me\specware\e.sw"> is the result of the third step.  The
file must be a multiple-unit file. Assuming that this is the case and
that it contains a unit definition with identifier [[f]], its defining
text is the result of the fourth step.</para>

<para>The directories in &swpath; are searched in order in the third
step of resolution. So, in the last example if the directory
<"c:\tmp"> also contains a file <"e.sw">, such a file is ignored.
This features can be used, for example, to shadow selected library
units that populate certain file system directories in
&swpath;.</para>

<para>For example, suppose that the first directory in &swpath; is
<"\specware\libs"> and that the directory
<"c:\specware\libs\data-structures"> contains files <"Sets.sw">,
<"Bags.sw">, <"Lists.sw">, etc. defining specs of sets, bags, lists,
etc. The unit reference [[/data-structures/Sets]] resolves to the
content of the file <"c:\specware\libs\data-structures\Sets.sw">. If
the user wanted to experiment with a slightly version of the spec of
sets, it is sufficient to prepend another directory to &swpath;, e.g.,
<"shadow-lib"> and to create the slightly different version of the
spec of sets in <"c:\shadow-lib\data-structures\Sets.sw">. The same
unit reference [[/data-structures/Sets]] will now resolve to the new
version.</para>

</section>  <!-- absolute references -->

<section id="relativeref">
<title>Relative References</title>

<para>A relative reference is a ``/''-separated sequence of one or
more identifiers, where the last separator can be ``#''.  Examples are
[[a/b/c]], [[d]], and [[e#f]]. So, absolute and relative references
can be distinguished by the presence or absence of ``/'' at their
beginning.</para>

<para>The resolution of relative references does not depend on
&swpath;, but on the location of the unit-defining text where the
reference occurs. There are two cases two consider: the reference
occurring in a single-unit file; and the reference occurring in a
multiple-unit file.</para>

<para>Suppose that the relative reference occurs in a single-unit
file. Then &Specware; attempts to resolve the reference in the
following steps:</para>

<orderedlist>

<listitem>If the reference contains ``#'', the ``#'' itself and the
identifier following it are removed, obtaining a ``/''-separated
sequence of one or more identifiers. Otherwise, no removal takes
place. Either way, the result of this first step is a ``/''-separated
sequence of identifiers.</listitem>

<listitem>If the underlying operating system is Windows, the ``/''
signs of the ``/''-separated sequence of identifiers, resulting from
the previous step, are turned into ``\''; in addition, <".sw"> is
appended at the end. Otherwise, the ``/'' signs are left unchanged and
<".sw"> is appended at the end. Either way, the result of this second
step is a (partial) path in the file system.</listitem>

<listitem>The path resulting from the previous step is appended after
the absolute path of the directory of the file containing the relative
reference. If the resulting absolute path identifies an existing file,
that is the result of this third step.  Otherwise, the unit reference
cannot be resolved and an error is signaled by &Specware;.</listitem>

<listitem>There are two alternative steps here, depending on whether
the original unit reference contains ``#'' or not.</listitem>

<orderedlist>

<listitem>This is the case that the original unit reference does not
contain ``#''. If the file resulting from the previous step is a
single-unit file, i.e., it contains the defining text for a unit, the
defining text is the final result of resolution. Otherwise, an error
is signaled by &Specware;.</listitem>

<listitem>This is the case that the original unit reference contains
``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit reference cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose identifier (at
the left of ``='') is the same as the identifier that follows ``#'' in
the original unit reference. If no such unit definition is found, the
unit reference cannot be resolved and an error is signaled by
&Specware. If instead such a unit definition is found, its defining
text (at the right of ``='') is the final result of
resolution.</listitem>

</orderedlist>

</orderedlist>

<para>So, resolution of a relative reference occurring in a
single-unit file is like resolution of an absolute reference, except
that the directory where the reference occurs is used instead of
&swpath;.</para>

<para>Suppose, instead, that the relative reference occurs in a
multiple-unit file.  Then &Specware; attempts to resolve the reference
in the following steps:</para>

<orderedlist>

<listitem>If the relative reference is a single identifier, &Specware;
attempts to find a unit definition with that identifier inside the
file where the reference occurs. If such a unit definition is found,
its defining text is the final result of resolution. Otherwise, the
following steps are carried out.</listitem>

<listitem>If the reference contains ``#'', the ``#'' itself and the
identifier following it are removed, obtaining a ``/''-separated
sequence of one or more identifiers. Otherwise, no removal takes
place. Either way, the result of this first step is a ``/''-separated
sequence of identifiers.</listitem>

<listitem>If the underlying operating system is Windows, the ``/''
signs of the ``/''-separated sequence of identifiers, resulting from
the previous step, are turned into ``\''; in addition, <".sw"> is
appended at the end. Otherwise, the ``/'' signs are left unchanged and
<".sw"> is appended at the end. Either way, the result of this second
step is a (partial) path in the file system.</listitem>

<listitem>The path resulting from the previous step is appended after
the absolute path of the directory of the file containing the relative
reference. If the resulting absolute path identifies an existing file,
that is the result of this third step.  Otherwise, the unit reference
cannot be resolved and an error is signaled by &Specware;.</listitem>

<listitem>There are two alternative steps here, depending on whether
the original unit reference contains ``#'' or not.</listitem>

<orderedlist>

<listitem>This is the case that the original unit reference does not
contain ``#''. If the file resulting from the previous step is a
single-unit file, i.e., it contains the defining text for a unit, the
defining text is the final result of resolution. Otherwise, an error
is signaled by &Specware;.</listitem>

<listitem>This is the case that the original unit reference contains
``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit reference cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose identifier (at
the left of ``='') is the same as the identifier that follows ``#'' in
the original unit reference. If no such unit definition is found, the
unit reference cannot be resolved and an error is signaled by
&Specware. If instead such a unit definition is found, its defining
text (at the right of ``='') is the final result of
resolution.</listitem>

</orderedlist>

</orderedlist>

<para>So, resolution of a relative reference occurring in a
multiple-unit file is like resolution of a relative reference
occurring in a single-unit file, preceded by an attempt to locate the
unit in the file where the reference occurs, only in case such a
reference is a single identifier.</para>

</section>  <!-- relative references -->

</section>  <!-- resolution of unit references -->

<section>
<title>Processing Commands</title>

<para>The &Specware; command to process units is [[L::sw]]. The user
supplies this command in the XEmacs buffer of the Lisp shell, followed
by an argument. The argument is a unit reference, a piece of text
defining an unnamed unit, or the name of a multiple-unit file. The
whole command (including the argument) must fit in one line.</para>

<section>
<title>Processing a Named Unit</title>

<para>The command to process a named unit is:</para>

[[L:
||    :sw <unit-reference>
]]

<para>The unit reference can be absolute or relative. If it is
absolute, &Specware; attempts to resolve it as explained in <xref
linkend="absoluteref">.  If it is relative, &Specware; attempts to
resolve it as explained in <xref linkend="relativeref">, as if the
reference occurred in a single-unit file of the current Lisp
directory. Either way, if resolution fails an error is signaled by
&Specware;.</para>

<para>If instead resolution succeeds, &Specware; parses and evaluates
the unit-defining text that results from resolution. Parsing and
evaluation carry out the computations to construct the unit; they are
&Specware;'s ``core'' functionality. Parsing and evaluation implement
the semantics of the &Metaslang; language.</para>

<para>If the defining text of the unit includes references to other
units. &Specware; recursively resolves the references and parses and
evaluates their defining text.</para>

</section>

<section>
<title>Processing an Unnamed Unit</title>

<para>The command to process an unnamed unit is:</para>

[[L:
||    :sw <unit-defining-text>
]]

<para>The unit defining text is written in the &Metaslang;
language. It can be anything that can appear in a single-unit file or
at the right of ``='' in a unit definition is a multiple-unit file.
The only restriction is that it must fit in one line.  &Specware;
parses and evaluates the text. If it contains references to other
units, &Specware; recursively resolves the references and parses and
evaluates their defining text.</para>

</section>

<section>
<title>Processing a Multiple-Unit File</title>

<para>The command to process a multiple-unit file is:</para>

[[L:
||   :sw <file-reference>
]]

<para>The file reference is syntactically exactly like a unit
reference that does not contain ``#''. &Specware; attempts to resolve
the reference as if it were a unit reference. If it is a relative
reference, it is resolved as if it occurred inside a single-unit file
in the Lisp current directory.  However, the file obtained at the
third step must be a multi-unit file, and not a single-unit file.  If
it is indeed a multi-unit file, &Specware; parses and evaluates all
the unit definitions inside the file.</para>

</section>

<!-- LEFT OUT FOR NOW:

<section>
<title>Repeating the Last Processing Command</title>

<para>If the [[L::sw]] command is given without an argument,
&Specware; re-executes the last [[L::sw]] command that has been
executed. If no [[L::sw]] command has been yet executed in the current
&Specware; session, an error is signaled.</para>

</section>

-->

</section>  <!-- processing commands -->

<section>
<title>Unit-Specific Processing</title>

<para>This section describes what happens when specific kinds of units
are processed.</para>

<section>
<title>Typechecking Specs</title>

<para>The user can define specs by explicitly listing the sorts, ops,
and axioms comprising the spec, possibly after importing one or more
spec. When these spec definitions are processed, &Specware; typechecks
all the expressions that appear in the spec. Typechecking means
checking that the expressions are type-correct, according to the rules
of the &Metaslang; language.</para>

<para>In general, only some of the ops and variables that appear in an
expression have explicit type (i.e., sort) information. Typechecking
also involves reconstructing the types of those ops and variables that
lack explicit type information.</para>

<para>Typechecking is an integrated process that checks the type
correctness of expressions while reconstructing the missing type
information. This is done by deriving and solving type constraints
from the expression. For instance, if it is known that an op [[f]] has
sort [[A -> B]] then the type of the variable [[x]] in the expression
[[f(x)]] must be [[A]], and the type of the whole expression must be
[[B]].</para>

<para>If the missing type information cannot be uniquely reconstructed
and/or if certain constraints are violated, &Specware; signals an
error, indicating the textual position of the problematic
expression.</para>

<para>Since the &Metaslang; type system features subsorts defined by
arbitrary predicates, it is in general undecidable whether an
expression involving subsorts is type-correct or not. When &Specware;
processes a spec, it assumes that the type constraints arising from
subsorts are satisfied, thus making typechecking decidable.</para>

<para>The proof obligations associated with a spec, which are
extracted via the &Metaslang; [[obligations]] operator, include
conjectures derived from the type constraints arising from subsorts.
If all of these conjectures are discharged (using a theorem prover)
then all the expressions in the spec are type-correct.</para>

</section>

&prove; <!-- section on proofs -->

</section>  <!-- unit-specific processing -->

<section>
<title>Auxiliary Commands</title>

<section>
<title>Displaying Unit Values</title>

<para>When a unit definition is processed, a unit value is produced.
For example, a spec is essentially a set of sorts, ops, and axioms.  A
spec can be constructed by means of various operators in the
&Metaslang; language, but the final result is always a spec, i.e., a
set of sorts, ops, and axioms.</para>

<para>The [[L::show]] command is used to display the value of a
unit. Like [[L::sw]], it is also supplied in the XEmacs buffer of the
Lisp shell and it is followed by a one-line argument. The argument
is either a unit reference or a unnamed unit.</para>

<para>The command to display a named unit is:</para>
[[L:
||    :show <unit-reference>
]]

<para>This command first processes the unit, exactly as if it were
[[L::sw <unit-reference>]]. In addition, if processing does not yield
errors, the value of the unit is displayed on screen. Of course, if
the referenced unit has been already processed via a [[L::sw]] command
and its defining text has not been changed after that, the [[L::show]]
command will access the results saved in &Specware;'s internal
cache.</para>

<para>The command to display an unnamed unit is:</para>

[[L:
||    :show <unit-defining-text>
]]

<para>This command first processes the unit, exactly as if it were
[[L::sw <unit-defining-text>]]. In addition, if processing does not
yield errors, the value of the unit is displayed on screen.</para>

<!-- LEFT OUT FOR NOW:

<para>If the [[L::show]] command is given without an argument, it
displays the value of the unit processed by the last [[L::show]]
command that has been executed. If no [[L::sw]] command has been yet
executed in the current &Specware; session, an error is
signaled.</para>

-->

<para>The [[L::show]] command serves to inspect the value of units
constructed via the &Metaslang; operators. This is especially useful
for beginning users as an aid to clarify the semantics of such
operators.</para>

</section>

<section>
<title>Inspecting and Clearing the Cache</title>

<para>As already mentioned, &Specware; maintains an internal cache
that associates processing results to unit references.</para>

<para>A list of the units currently present in the cache is displayed
on screen via the following command:</para>

[[L:
||    :list
]]

<para>The cache is cleared (i.e., re-initialized) via the following
command:</para>

[[L:
||    :sw-init
]]

<para>Normally, there is no need to use these commands.</para>

</section>

<section>
<title>Inspecting and Setting &swpath;</title>

<para>The value of the &swpath; environment variable is displayed on
screen via the following command:</para>

[[L:
||    :swpath
]]

<para>The value of the &swpath; environment variable is changed
via the following command:</para>

[[L:
||    :swpath <string>
]]

<para>As already explained, the string must be a colon-separated list
of absolute directory paths of the underlying operating system,
surrounded by double quotes.</para>

</section>  <!-- auxiliary commands -->

</chapter>
