<chapter id="process">
<title>Processing Units</title>

<section>
<title>Overview</title>

<para>Unit definitions are processed by &Specware;. The user instructs
&Specware; to process units by supplying certain commands. &Specware;
has access, via the Lisp run time environment, to the underlying file
system, so it can access the unit definitions contained in <".sw">
files. The environment variable &swpath; determines which <".sw">
files are accessed by &Specware; to find unit definitions.</para>

<para>Processing a unit causes processing of the units referenced in
the defining text of the unit, recursively. For instance, if a spec
[[A]] extends a spec [[B]] which in turns extends a spec [[C]], when
[[A]] is processed also [[B]] and [[C]] are processed. There must be
no circularities in the chain of unit dependencies.</para>

<para>Processing causes progress and/or error messages to be displayed
on the screen, in the XEmacs buffer containing the Lisp shell (where
the user also supplies commands to &Specware;). Progress messages
inform the user that units are processed without error. Error messages
provide information on the cause of errors, so that the user can fix
them by editing the unit definitions. When an error occurs in the
definition of some unit, &Specware; displays the <".sw"> file
containing the definition in an XEmacs buffer, with the cursor at the
point where the erroneous text is.</para>

<para>The processing of certain kinds of units also results in the
creation of new files, as an additional side effect. For instance,
Lisp programs are a kind of unit, constructed by the [[generate]]
operator of &Metaslang;. A side effect of processing one such unit is
that the resulting code is written into a <".lisp"> file.</para>

<para>When &Specware; processes a unit, it saves the processing
results into an internal cache, associating the results to the unit's
name. By using this cache, &Specware; avoid unnecessary
re-computations: it only re-processes the units whose files have
changed since they were processed last time. From the point of view of
the final result, this caching mechanism is completely transparent to
the user. However, it improves the performance and response time of
the system.</para>

</section>  <!-- overview -->

<section>
<title>Resolution of Unit References</title>

<para>References to units may occur in the defining text of units and,
as described later, in &Specware; commands. A unit reference is
resolved to the defining text of the unit, which is contained in a
<".sw"> file. Reference are either absolute or relative; these two
kinds are syntactically distinguished from each other and they are
resolved in slightly different ways.</para>

<section>
<title>Absolute References</title>

<para>An absolute reference starts with ``/'' (forward slash),
followed by a ``/''-separated sequence of one or more identifiers,
where the last separator can be ``#'' (sharp). Examples are
[[/a/b/c]], [[/d]], and [[/e#f]].

<para>&Specware; resolves an absolute reference in the following
steps:</para>

<orderedlist>

<listitem>If the reference contains ``#'', the ``#'' itself and the
identifier following it are removed, obtaining a ``/''-separated
sequence of one or more identifiers, preceded by ``/''. Otherwise, no
removal takes place. Either way, the result of this first step is a
``/''-separated sequence of identifiers preceded by ``/''.</listitem>

<listitem>If the underlying operating system is Windows, the ``/''
signs of the ``/''-separated sequence of identifiers preceded by
``/'', resulting from the previous step, are turned into ``\''
(backward slash); in addition, <".sw"> is appended at the
end. Otherwise, the ``/'' signs are left unchanged and <".sw"> is
appended at the end. Either way, the result of this second step is a
(partial) path in the file system.</listitem>

<listitem>The path resulting from the previous step is appended after
the first directory of &swpath;. If the resulting absolute path
identifies an existing file, that is the result of this third step.
Otherwise, the same attempt is made with the second directory of
&swpath; (if any). Attempts continue until a directory is found in
&swpath; such that the absolute path obtained by concatenating the
directory with the result of the previous step identifies an existing
file; such a file is the result of this step. If no such directory is
found, the unit reference cannot be resolved and an error is signaled
by &Specware;.</listitem>

<listitem>There are two alternative steps here, depending on whether
the original unit reference contains ``#'' or not.</listitem>

<orderedlist>

<listitem>This is the case that the original unit reference does not
contain ``#''. If the file resulting from the previous step is a
single-unit file, i.e., it contains the defining text for a unit, the
defining text is the final result of resolution. Otherwise, an error
is signaled by &Specware;.</listitem>

<listitem>This is the case that the original unit reference contains
``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit reference cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose identifier (at
the left of ``='') is the same as the identifier that follows ``#'' in
the original unit reference. If no such unit definition is found, the
unit reference cannot be resolved and an error is signaled by
&Specware. If instead such a unit definition is found, its defining
text (at the right of ``='') is the final result of
resolution.</listitem>

</orderedlist>

</orderedlist>

<para>For example, consider a reference [[/a/b/c]]. Since it does not
contain ``#'', the first step does not do anything. Assuming that the
underlying operating system is Windows, the result of the second step
is <"\a\b\c.sw">. Suppose that &swpath; is
<"\users\me\specware:\tmp">, that <"c:\users\me\specware"> does not
contain any <"a"> subdirectory, and that <"c:\tmp\a\b\c.sw"> exists.
The result of the third step is the file <"c:\tmp\a\b\c.sw">.  If such
a file is a single-unit file, its content is the result of the fourth
step.</para>

<para>As another example, consider a reference [[/e#f]]. The result of
the first step is [[/e]]. The result of the second step (still
assuming Windows) is <"\e.sw">. Assuming &swpath; as before and that
<"c:\users\me\specware"> contains a file <"e.sw">, the file
<"c:\users\me\specware\e.sw"> is the result of the third step.  The
file must be a multiple-unit file. Assuming that this is the case and
that it contains a unit definition with identifier [[f]], its defining
text is the result of the fourth step.</para>

</section>  <!-- absolute references -->

<section>
<title>Relative References</title>

<para>A relative reference is a ``/''-separated sequence of one or
more identifiers, where the last separator can be ``#''.  Examples are
[[a/b/c]], [[d]], and [[e#f]]. So, absolute and relative references
can be distinguished by the presence or absence of ``/'' at their
beginning.</para>

<para>The resolution of relative references does not depend on
&swpath;, but on the location of the unit-defining text where the
reference occurs. There are two cases two consider: the reference
occurring in a single-unit file; and the reference occurring in a
multiple-unit file.</para>

<para>Suppose that the relative reference occurs in a single-unit
file. Then &Specware; attempts to resolve the reference in the
following steps:</para>

<orderedlist>

<listitem>If the reference contains ``#'', the ``#'' itself and the
identifier following it are removed, obtaining a ``/''-separated
sequence of one or more identifiers. Otherwise, no removal takes
place. Either way, the result of this first step is a ``/''-separated
sequence of identifiers.</listitem>

<listitem>If the underlying operating system is Windows, the ``/''
signs of the ``/''-separated sequence of identifiers, resulting from
the previous step, are turned into ``\''; in addition, <".sw"> is
appended at the end. Otherwise, the ``/'' signs are left unchanged and
<".sw"> is appended at the end. Either way, the result of this second
step is a (partial) path in the file system.</listitem>

<listitem>The path resulting from the previous step is appended after
the absolute path of the directory of the file containing the relative
reference. If the resulting absolute path identifies an existing file,
that is the result of this third step.  Otherwise, the unit reference
cannot be resolved and an error is signaled by &Specware;.</listitem>

<listitem>There are two alternative steps here, depending on whether
the original unit reference contains ``#'' or not.</listitem>

<orderedlist>

<listitem>This is the case that the original unit reference does not
contain ``#''. If the file resulting from the previous step is a
single-unit file, i.e., it contains the defining text for a unit, the
defining text is the final result of resolution. Otherwise, an error
is signaled by &Specware;.</listitem>

<listitem>This is the case that the original unit reference contains
``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit reference cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose identifier (at
the left of ``='') is the same as the identifier that follows ``#'' in
the original unit reference. If no such unit definition is found, the
unit reference cannot be resolved and an error is signaled by
&Specware. If instead such a unit definition is found, its defining
text (at the right of ``='') is the final result of
resolution.</listitem>

</orderedlist>

</orderedlist>

<para>So, resolution of a relative reference occurring in a
single-unit file is like resolution of an absolute reference, except
that the directory where the reference occurs is used instead of
&swpath;.</para>

<para>Suppose, instead, that the relative reference occurs in a
multiple-unit file.  Then &Specware; attempts to resolve the reference
in the following steps:</para>

<orderedlist>

<listitem>If the relative reference is a single identifier, &Specware;
attempts to find a unit definition with that identifier inside the
file where the reference occurs. If such a unit definition is found,
its defining text is the final result of resolution. Otherwise, the
following steps are carried out.</listitem>

<listitem>If the reference contains ``#'', the ``#'' itself and the
identifier following it are removed, obtaining a ``/''-separated
sequence of one or more identifiers. Otherwise, no removal takes
place. Either way, the result of this first step is a ``/''-separated
sequence of identifiers.</listitem>

<listitem>If the underlying operating system is Windows, the ``/''
signs of the ``/''-separated sequence of identifiers, resulting from
the previous step, are turned into ``\''; in addition, <".sw"> is
appended at the end. Otherwise, the ``/'' signs are left unchanged and
<".sw"> is appended at the end. Either way, the result of this second
step is a (partial) path in the file system.</listitem>

<listitem>The path resulting from the previous step is appended after
the absolute path of the directory of the file containing the relative
reference. If the resulting absolute path identifies an existing file,
that is the result of this third step.  Otherwise, the unit reference
cannot be resolved and an error is signaled by &Specware;.</listitem>

<listitem>There are two alternative steps here, depending on whether
the original unit reference contains ``#'' or not.</listitem>

<orderedlist>

<listitem>This is the case that the original unit reference does not
contain ``#''. If the file resulting from the previous step is a
single-unit file, i.e., it contains the defining text for a unit, the
defining text is the final result of resolution. Otherwise, an error
is signaled by &Specware;.</listitem>

<listitem>This is the case that the original unit reference contains
``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit reference cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose identifier (at
the left of ``='') is the same as the identifier that follows ``#'' in
the original unit reference. If no such unit definition is found, the
unit reference cannot be resolved and an error is signaled by
&Specware. If instead such a unit definition is found, its defining
text (at the right of ``='') is the final result of
resolution.</listitem>

</orderedlist>

</orderedlist>

<para>So, resolution of a relative reference occurring in a
multiple-unit file is like resolution of a relative reference
occurring in a single-unit file, preceded by an attempt to locate the
unit in the file where the reference occurs, only in case such a
reference is a single identifier.</para>

</section>  <!-- relative references -->

</section>  <!-- resolution of unit references -->

<section>
<title>Processing Commands</title>

</section>

<section>
<title>Unit-Specific Processing</title>

</section>

<section>
<title>Auxiliary Commands</title>

<!-- command to clear the cache -->

</section>

</chapter>
