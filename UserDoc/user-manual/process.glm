<chapter id="process">
<title>Processing Units</title>

<section>
<title>Overview</title>

<para>Unit definitions are processed by &Specware;. The user instructs
&Specware; to process units by supplying certain commands. &Specware;
has access, via the Lisp runtime environment, to the underlying file
system, so it can access the <".sw"> files that define units. The
environment variable &swpath; determines which <".sw"> files are
accessed by &Specware; to find unit definitions.</para>

<para>Processing a unit causes the recursive processing of the units
referenced in that unit's term. For instance, if a spec [[A]] extends
a spec [[B]] which in turns extends a spec [[C]], then when [[A]] is
processed, [[B]] and [[C]] are also processed. There must be no
circularities in the chain of unit dependencies.</para>

<para>Processing causes progress and/or error messages to be displayed
in the XEmacs buffer containing the Lisp shell (which is also where
the user supplies commands to &Specware;). Progress messages inform
the user that units were processed without error. Error messages
provide information on the cause of errors, so that the user can fix
them by editing the unit definitions. When an error occurs in the
definition of some unit, &Specware; displays the <".sw"> file
containing the unit term in a separate XEmacs buffer, with the cursor
positioned at the point containing the erroneous text.</para>

<para>The processing of certain kinds of units also results in the
creation of new files as an additional side effect. For instance, Lisp
programs are a kind of unit, constructed by the [[generate]] operation
of &Metaslang;. A side effect of processing one such unit is that the
resulting code is written into a <".lisp"> file.</para>

<para>When &Specware; processes a unit, it saves the processing
results into an internal cache, associating the results with the
unit's identifier. By using this cache, &Specware; avoids unnecessary
re-computations: it only re-processes the units whose files have
changed since the last time they were processed. From the point of
view of the final result, this caching mechanism is completely
transparent to the user. However, it improves the performance and
response time of the system.</para>

</section>  <!-- overview -->

<section>
<title>Resolution of Unit Identifiers</title>

<para>Unit terms may reference units in the form of unit
identifiers. A unit identifier is resolved to the unit's term, which
is contained in a <".sw"> file. Unit identifiers are either
&swpath;-based or relative; these two kinds are syntactically
distinguished from each other and are resolved in slightly different
ways.</para>

<section id="swpathuid">
<title>&swpath;-Based Unit Identifier</title>

<para>A &swpath;-based unit identifier starts with ``/'', followed by
a ``/''-separated sequence of one or more path elements, where the
last separator may be ``#''. Examples are [[/a/b/c]], [[/d]], and
[[/e#f]].</para>

<para>&Specware; resolves a &swpath;-based unit identifier in the
following steps:</para>

<orderedlist>

<listitem><para>If the unit identifier contains ``#'', the ``#''
itself and the path element following it are removed, obtaining a
``/''-separated sequence of one or more path elements, preceded by
``/''. Otherwise, no removal takes place. Either way, the result of
this first step is a ``/''-separated sequence of path elements preceded
by ``/''.</para></listitem>

<listitem><para>The ``/'' signs of the ``/''-separated sequence of
path elements preceded by ``/'', resulting from the previous step, are
turned into ``\''; in addition, <".sw"> is appended at the
end.
<!--
%%Otherwise, the ``/'' signs are left unchanged and <".sw"> is
%%appended at the end. Either way, the
-->
The result of this second step is a
(partial) path in the file system.</para></listitem>

<listitem><para>The path resulting from the previous step is appended
after the first directory of &swpath;. If the resulting absolute path
denotes an existing file, that is the result of this third step.
Otherwise, the same attempt is made with the second directory of
&swpath; (if any). Attempts continue until a directory is found in
&swpath; such that the absolute path obtained by concatenating the
directory with the result of the previous step denotes an existing
file; such a file is the result of this step. If no such directory is
found, the unit identifier cannot be resolved and an error is signaled
by &Specware;.</para></listitem>

<listitem>

<para>There are two alternative steps here, depending on whether or
not the original unit identifier contains ``#''.</para>

<orderedlist>

<listitem><para>This is the case that the original unit identifier
does not contain ``#''. If the file resulting from the previous step
is a single-unit file, i.e., it contains a unit term, that the final
result of resolution. Otherwise, an error is signaled by
&Specware;.</para></listitem>

<listitem><para>This is the case that the original unit identifier
contains ``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit identifier cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose path elements
(to the left of ``='') is the same as the path element that follows
``#'' in the original unit identifier. If no such unit definition is
found, the unit identifier cannot be resolved and an error is signaled
by &Specware;. If such a unit definition is found, its unit term (at
the right of ``='') is the final result of
resolution.</para></listitem>

</orderedlist>

</listitem>

</orderedlist>

<para>For example, consider a unit identifier [[/a/b/c]]. Since it
does not contain ``#'', the first step does not do anything. The
result of the second step is <"\a\b\c.sw">. Suppose that &swpath; is
<"C:\users\me\specware;C:\tmp">, that <"C:\users\me\specware"> does not
contain any <"a"> subdirectory, and that <"C:\tmp\a\b\c.sw"> exists.
The result of the third step is the file <"C:\tmp\a\b\c.sw">.  If such
a file is a single-unit file, its content is the result of the fourth
step.</para>

<para>As another example, consider a unit identifier [[/e#f]]. The
result of the first step is [[/e]]. The result of the second step is
<"\e.sw">. Assuming that &swpath; is as before and that
<"C:\users\me\specware"> contains a file <"e.sw">, the file
<"C:\users\me\specware\e.sw"> is the result of the third step.  The
file must be a multiple-unit file. Assuming that this is the case and
that it contains a unit definition with path element [[f]], its unit
term is the result of the fourth step.</para>

<para>The directories in &swpath; are searched in order during the
third step of resolution. So, in the last example, if the directory
<"C:\tmp"> also contains a file <"e.sw">, such a file is ignored.
This features can be used, for example, to shadow selected library
units that populate certain file system directories in &swpath;.</para>

<para>For example, suppose that the first directory in &swpath; is
<"C:\specware\libs"> and that the directory
<"C:\specware\libs\data-structures"> contains files <"Sets.sw">,
<"Bags.sw">, <"Lists.sw">, etc. defining specs of sets, bags, lists,
etc. The unit identifier [[/data-structures/Sets]] resolves to the
content of the file <"C:\specware\libs\data-structures\Sets.sw">. If
the user wanted to experiment with a slightly different version of the
spec for sets, it is sufficient to prepend another directory to
&swpath;, e.g. <"C:\shadow-lib">, and to create that slightly different
version of the spec for sets in
<"C:\shadow-lib\data-structures\Sets.sw">. The same unit identifier
[[/data-structures/Sets]] will now resolve to the new version.</para>

</section>  <!-- swpath-based unit identifiers -->

<section id="relativeuid">
<title>Relative Unit Identifiers</title>

<para>A relative unit identifier is a ``/''-separated sequence of one
or more path elements, where the last separator can be ``#''.  Examples
are [[a/b/c]], [[d]], and [[e#f]]. So, &swpath;-based and relative unit
identifiers can be distinguished by the presence or absence of ``/''
at the beginning.</para>

<para>The resolution of relative unit identifiers does not depend on
&swpath;, but on the location of the file where the unit identifier
occurs. There are two cases to consider: the unit identifier occurring
in a single-unit file and the unit identifier occurring in a
multiple-unit file.</para>

<para>Suppose that the relative unit identifier occurs in a
single-unit file. Then &Specware; attempts to resolve the unit
identifier in the following steps:</para>

<orderedlist>

<listitem><para>If the unit identifier contains ``#'', the ``#''
itself and the path element following it are removed, obtaining a
``/''-separated sequence of one or more path elements. Otherwise, no
removal takes place. Either way, the result of this first step is a
``/''-separated sequence of path elements.</para></listitem>

<listitem><para>The ``/'' signs of the ``/''-separated sequence of
path elements, resulting from the previous step, are turned into
``\''; in addition, <".sw"> is appended at the end.
<!--
%%Otherwise, the
%%``/'' signs are left unchanged and <".sw"> is appended at the
%%end. Either way, the
-->
The result of this second step is a (partial) path in
the file system.</para></listitem>

<listitem><para>The path resulting from the previous step is appended
after the absolute path of the directory of the file containing the
relative unit identifier. If the resulting absolute path denotes an
existing file, that is the result of this third step.  Otherwise, the
unit identifier cannot be resolved and an error is signaled by
&Specware;.</para></listitem>

<listitem>

<para>There are two alternative steps here, depending on whether the
original unit identifier contains ``#'' or not.</para>

<orderedlist>

<listitem><para>This is the case where the original unit identifier
does not contain ``#''. If the file resulting from the previous step
is a single-unit file, i.e., it contains a unit term, that is the
final result of resolution. Otherwise, an error is signaled by
&Specware;.</para></listitem>

<listitem><para>This is the case that the original unit identifier
contains ``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit identifier cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose path element (at
the left of ``='') is the same as the path element that follows ``#''
in the original unit identifier. If no such unit definition is found,
the unit identifier cannot be resolved and an error is signaled by
&Specware;. If instead such a unit definition is found, its unit term
(to the right of ``='') is the final result of
resolution.</para></listitem>

</orderedlist>

</listitem>

</orderedlist>

<para>So, resolution of a relative unit identifier occurring in a
single-unit file is like resolution of a &swpath;-based unit
identifier, except that the directory where the identifier occurs is
used instead of &swpath;.</para>

<para>Suppose, instead, that the relative unit identifier occurs in a
multiple-unit file.  Then &Specware; attempts to resolve the unit
identifier in the following steps:</para>

<orderedlist>

<listitem><para>If the relative unit identifier is a single path
element, &Specware; attempts to find a unit definition with that path
element inside the file where the unit identifier occurs. If such a
unit definition is found, its unit term is the final result of
resolution.  Otherwise, the following steps are carried
out:</para></listitem>

<listitem><para>If the unit identifier contains ``#'', the ``#''
itself and the path element following it are removed, obtaining a
``/''-separated sequence of one or more path elements. Otherwise, no
removal takes place. Either way, the result of this first step is a
``/''-separated sequence of path elements.</para></listitem>

<listitem><para>The ``/'' signs of the ``/''-separated sequence of
path elements, resulting from the previous step, are turned into
``\''; in addition, <".sw"> is appended at the end.
<!--
%%Otherwise, the
%%``/'' signs are left unchanged and <".sw"> is appended at the
%%end. Either way, the
-->
The result of this second step is a (partial) path in
the file system.</para></listitem>

<listitem><para>The path resulting from the previous step is appended
after the absolute path of the directory of the file containing the
relative unit identifier. If the resulting absolute path denotes an
existing file, that is the result of this third step.  Otherwise, the
unit identifier cannot be resolved and an error is signaled by
&Specware;.</para></listitem>

<listitem>

<para>There are two alternative steps here, depending on whether the
original unit identifier contains ``#'' or not.</para>

<orderedlist>

<listitem><para>This is the case that the original unit identifier
does not contain ``#''. If the file resulting from the previous step
is a single-unit file, i.e., it contains a unit term, that is the
final result of resolution. Otherwise, an error is signaled by
&Specware;.</para></listitem>

<listitem><para>This is the case that the original unit identifier
contains ``#''. The file resulting from the previous step must be a
multiple-unit file, i.e., it must contain a sequence of one or more
unit definitions. If this is not the case, the unit identifier cannot
be resolved and an error is signaled by &Specware;. If that is the
case, a unit definition is searched in the file, whose path element (at
the left of ``='') is the same as the path element that follows ``#''
in the original unit identifier. If no such unit definition is found,
the unit identifier cannot be resolved and an error is signaled by
&Specware;. If instead such a unit definition is found, its unit term
(to the right of ``='') is the final result of
resolution.</para></listitem>

</orderedlist>

</listitem>

</orderedlist>

<para>So, resolution of a relative unit identifier occurring in a
multiple-unit file is like resolution of a relative unit identifier
occurring in a single-unit file, preceded by an attempt to locate the
unit in the file where the identifier occurs, only in case such a unit
identifier is a path element.</para>

</section>  <!-- relative unit identifiers -->

</section>  <!-- resolution of unit identifiers -->

<section>
<title>Processing Commands</title>

<para>The &Specware; command to process units is [[L::sw]]. The user
supplies this command in the XEmacs buffer of the Lisp shell, followed
by an argument. The argument is a unit identifier.</para>

<!-- LEFT OUT FOR NOW:

<para>The &Specware; command to process units is [[L::sw]]. The user
supplies this command in the XEmacs buffer of the Lisp shell, followed
by an argument. The argument is a unit reference, a piece of text
defining an unnamed unit, or the name of a multiple-unit file. The
whole command (including the argument) must fit in one line.</para>

-->

<section>
<title>Processing a Unit</title>

<para>The command to process a unit is:</para>

[[L:
||    :sw <unit-identifier>
]]

<para>The unit identifier can be &swpath;-based or relative. If it is
&swpath;-based, &Specware; attempts to resolve it as explained in
<xref linkend="swpathuid">.  If it is relative, &Specware; attempts to
resolve it as explained in <xref linkend="relativeuid">, as if the
unit identifier occurred in a single-unit file of the current Lisp
directory. Either way, if resolution fails an error is signaled by
&Specware;.</para>

<para>If instead resolution succeeds, &Specware; parses and evaluates
the unit term that results from resolution. Parsing and evaluation
carry out the computations to construct the unit; they are
&Specware;'s ``core'' functionality. Parsing and evaluation implement
the semantics of the &Metaslang; language.</para>

<para>If the unit term references other units, &Specware; recursively
resolves the unit identifiers and parses and evaluates their unit
terms.</para>

</section>

<!-- LEFT OUT FOR NOW:

<section>
<title>Processing an Unnamed Unit</title>

<para>The command to process an unnamed unit is:</para>

[[L:
||    :sw <unit-defining-text>
]]

<para>The unit defining text is written in the &Metaslang;
language. It can be anything that can appear in a single-unit file or
to the right of ``='' in a unit definition is a multiple-unit file.
The only restriction is that it must fit in one line.  &Specware;
parses and evaluates the text. If it references other units, &Specware;
recursively resolves the unit identifiers and parses and evaluates
their unit terms.</para>

</section>

-->

<section>
<title>Processing a Multiple-Unit File</title>

<para>The command to process a multiple-unit file is:</para>

[[L:
||   :sw <unit-identifier>
]]

<para>The unit identifier must not contain ``#'' and the the file must
not contain a unit of the same name as the file (without the directory
and extension). &Specware; attempts to resolve the unit identifier. If
it is a relative unit identifier, it is resolved as if it occurred
inside a single-unit file in the Lisp current directory.  However, the
file obtained at the third step must be a multi-unit file, and not a
single-unit file.  If it is indeed a multi-unit file, &Specware;
parses and evaluates all the unit definitions inside the file.</para>


</section>

<!-- LEFT OUT FOR NOW:

<section>
<title>Repeating the Last Processing Command</title>

<para>If the [[L::sw]] command is given without an argument,
&Specware; re-executes the last [[L::sw]] command that has been
executed. If no [[L::sw]] command has been yet executed in the current
&Specware; session, an error is signaled.</para>

</section>

-->

</section>  <!-- processing commands -->

<section>
<title>Unit-Specific Processing</title>

<para>This section describes what happens when specific kinds of units
are processed.</para>

<section>
<title>Typechecking Specs</title>

<para>The user can construct specs by explicitly listing the types,
ops, and axioms comprising the spec, possibly after importing one or
more spec. When these spec definitions are processed, &Specware;
typechecks all the expressions that appear in the spec. Typechecking
means checking that the expressions are type-correct, according to the
rules of the &Metaslang; language.</para>

<para>In general, only some of the ops and variables that appear in an
expression have explicit type information. Typechecking
also involves reconstructing the types of those ops and variables that
lack explicit type information.</para>

<para>Typechecking is an integrated process that checks the type
correctness of expressions while reconstructing the missing type
information. This is done by deriving and solving type constraints
from the expression. For instance, if it is known that an op [[f]] has
type [[A -> B]] then the type of the variable [[x]] in the expression
[[f(x)]] must be [[A]], and the type of the whole expression must be
[[B]].</para>

<para>If the missing type information cannot be uniquely reconstructed
and/or if certain constraints are violated, &Specware; signals an
error, indicating the textual position of the problematic
expression.</para>

<para>Since the &Metaslang; type system features subsorts defined by
arbitrary predicates, it is in general undecidable whether an
expression involving subsorts is type-correct or not. When &Specware;
processes a spec, it assumes that the type constraints arising from
subsorts are satisfied, thus making typechecking decidable.</para>

<para>The proof obligations associated with a spec, which are
extracted via the &Metaslang; [[obligations]] operation, include
conjectures derived from the type constraints arising from subsorts.
If all of these conjectures are discharged (using a theorem prover)
then all the expressions in the spec are type-correct.</para>

</section>

&prove; <!-- section on proofs -->

<section id="generatelisp">
<title>Generating Lisp Code</title>

<para>The user generates Lisp code from a spec by constructing a Lisp
program unit via the &Metaslang; [[generate]] operation. The optional
string given as argument must be an absolute file path in the file
system. The generated Lisp code is deposited into that file. The
<".lisp"> file extension can be omitted.</para>

<para>The string argument can be omitted if the spec term given as
argument is a unit identifier. In this case, &Specware; deposits the
generated code into the file <"A.lisp">, where [[A]] is the rightmost
path element comprising the unit identifier. The <"A.lisp"> file is
deposited in a <"lisp"> subdirectory immediately under the directory
of the file containing the unit term of the spec identified by the
unit identifier given as argument to [[generate]].</para>

<para>For example, suppose that the first directory in &swpath; is
<"C:\tmp"> and that a spec is defined in the single-unit file
<"C:\tmp\one\two\A.sw">. Suppose that the Lisp program unit is defined
by:</para>

[[
||    generate lisp /one/two/A
]]

<para>Then the code is deposited into the file
<"C:\tmp\one\two\lisp\A.lisp">.</para>

<para>As another example, suppose that &swpath; is as before and that
a spec is defined in the multiple-unit file <"C:\tmp\one\two\f.sw">,
and that [[B]] is the path element associated with the spec. Suppose
that the Lisp program unit is defined by:</para>

[[
||    generate lisp /one/two/f#B
]]

<para>Then the code is deposited into the file
<"C:\tmp\one\two\lisp\B.lisp">.</para>

</section>

&javacodegen; <!-- section on Java code generation -->
&ccodegen; <!-- section on C code generation -->


</section>  <!-- unit-specific processing -->

<section>
<title>Auxiliary Commands</title>

<section>
<title>Displaying Unit Values</title>

<para>When a unit definition is processed, a unit value is produced.
For example, a spec is essentially a set of types, ops, and axioms.  A
spec can be constructed by means of various operations in the
&Metaslang; language, but the final result is always a spec, i.e., a
set of types, ops, and axioms.</para>

<para>The [[L::show]] command is used to display the value of a
unit. Like [[L::sw]], it is also supplied in the XEmacs buffer of the
Lisp shell and it is followed by a one-line argument. The argument
is a unit identifier.</para>

<para>The command to display a unit is:</para>
[[L:
||    :show <unit-identifier>
]]

<para>This command first processes the unit, exactly as if it were
[[L::sw <unit-identifier>]]. In addition, if processing does not yield
errors, the value of the unit is displayed on screen. Of course, if
the unit has been already processed via a [[L::sw]] command and its
unit term has not been changed after that, the [[L::show]] command
will access the results saved in &Specware;'s internal cache.</para>

<!-- LEFT OUT FOR NOW:

<para>The command to display an unnamed unit is:</para>

[[L:
||    :show <unit-defining-text>
]]

<para>This command first processes the unit, exactly as if it were
[[L::sw <unit-defining-text>]]. In addition, if processing does not
yield errors, the value of the unit is displayed on screen.</para>

-->

<!-- LEFT OUT FOR NOW:

<para>If the [[L::show]] command is given without an argument, it
displays the value of the unit processed by the last [[L::show]]
command that has been executed. If no [[L::sw]] command has been yet
executed in the current &Specware; session, an error is
signaled.</para>

-->

<para>The [[L::show]] command serves to inspect the value of units
constructed via the &Metaslang; operations. This is especially useful
for beginning users as an aid to clarify the semantics of such
operations.</para>

</section>

<section>
<title>Inspecting and Clearing the Cache</title>

<para>As already mentioned, &Specware; maintains an internal cache
that associates processing results with unit identifiers.</para>

<para>A list of the units currently present in the cache is displayed
on screen via the following command:</para>

[[L:
||    :list
]]

<para>The cache is cleared (i.e., re-initialized) via the following
command:</para>

[[L:
||    :sw-init
]]

<para>Normally, there is no need to use these commands.</para>

</section>

<section id="swpath">
<title>Inspecting and Setting &swpath;</title>

<para>The value of the &swpath; environment variable is displayed on
screen via the following command:</para>

[[L:
||    :swpath
]]

<para>The value of the &swpath; environment variable is changed
via the following command:</para>

[[L:
||    :swpath <string>
]]

<para>The [[L:<string>]] must be a semicolon-separated list of
absolute directory paths of the underlying operating system. For
example, in order to set &swpath; to <"C:\users\me"> it is necessary
to write [[L::swpath C:\users\me]].</para>

<para>Changes to &swpath; only apply to the currently running
&Specware; session. If &Specware; is quit and then restarted, &swpath;
loses the value assigned to it during the previous session, reverting
to its default value.</para>

</section>

<section>
<title>Generating Lisp Code</title>

<para>Normally, Lisp code is generated by constructing a Lisp program
unit via the &Metaslang; [[generate]] operation and by processing such
unit via the [[L::sw]] command.</para>

<para>&Specware; provides an additional command to accomplish the same
result without actually creating an explicit Lisp program unit. The
command is:</para>

[[L:
||    :swl <unit-identifier> <string>
]]

<para>The unit identifier must resolve to a spec, which is processed
by &Specware;. If the spec is successfully processed, &Specware;
generates Lisp code from it (according to the semantics of [[generate]])
and deposits the resulting code into the file whose path is given by
the string.</para>

<para>The second argument to [[L::swl]], i.e. the string, is optional.
If it is not given, a file name is inferred as explained in <xref
linkend="generatelisp"> for [[generate]].</para>

[[L:
||    :swll <unit-identifier>
]]

<para>This is like [[L::swl]] except it generates code only for the
local definitions of the spec given by the unit identifier and not any
of the imports. It is intended for incremental development, so it
compiles and loads the lisp definitions. Note that if you have not
generated code for the imported specs and loaded them, trying to run
the code generated by this command will give undefined function errors.
Also, if the spec is unqualified but it is imported into a spec that
is qualified, the package used will be [[L::SW-USER]] instead of the
package of the qualifier. To avoid this problem qualification can be
added to the spec.
</para>

<para>
When developing a specware application you generate code for your
application, compile, load and test it. Then if you make a
modification to a single spec you can use the [[L::swll]] to just load
the generated code for the modification.
This command is also useful when you just want to see the
generated code for a particular spec.</para>

[[L:
||    :cl <lisp-file-name>
]]

<para>Compiles and loads a lisp file.</para>
	
</section>

<section> 
<title>Miscellaneous Commands</title>


[[L:
||    :sw-help <command-name>
]]

<para> Prints brief documentation for the specware command
command-name. If command-name is omitted it prints documentation for
all the specware commands.</para>

[[L:
||    :dir <directory>
]]

<para> Gives directory listing of directory. If directory is omitted
it uses the current directory.</para>

[[L:
||    :ls <directory>
]]

<para> Gives directory listing of directory. If directory is omitted
it uses the current directory.</para>

</section>

</section>  <!-- auxiliary commands -->

</chapter>
