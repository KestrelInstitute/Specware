<chapter id="proving">
<title>Proving Properties in Specs</title>

<para> &Specware; provides a mechanism for verifying the correctness
of properties either specified in &Metaslang; specs or automatically
generated as proof obligations arising from refinements or
typechecking.  Currently &Specware; comes packaged with the Snark
first-order theorem prover.  Interaction with Snark is through the
proof unit described below.</para>

<section>
<title>The Proof Unit</title>

<para>
The user invokes the Snark theorem prover by constructing and processing
a proof term.
A typical proof term is of the form: </para>

[[
||    prove f_stable in Stability
||          using stable_charn, f_defn
||          options "(use-paramodulation t)
||                   (use-resolution nil)
||                   (use-hyperresolution t)"
]]

<para>In this proof term, [[Stability]] must be a spec-valued unit
term, and [[f_stable]], [[stable_charn]], and [[f_defn]] must all be
names of claims (i.e. axioms, conjectures, or theorems) that appear in
the spec resulting from elaborating that unit term.
If this proof term is in file <"pruf.sw"> then issuing the command
[[proc pruf]] will result in translating [[stable_charn]],
[[f_defn]] and [[f_stable]] to Snark formulas and then invoking the Snark
prover to try to prove [[f_stable]] from the hypotheses [[stable_charn]]
and [[f_defn]], using the options in the [[options]] list.
Note that the claims used as hypotheses -- [[stable_charn]] and
[[f_defn]] in the example -- are required to appear earlier in that spec
than the claim to be proved -- [[f_stable]] in the example.
Most users will omit the [[options]] part.
Additionally, the [[using]] part can be omitted as well.
In that case all the claims that appear in the spec term before the
claim to be proved will be used as hypotheses in the proof.
</para>

<para> After Snark completes, &Specware; will report on the success or
failure of the Snark proof.  </para>

</section>

<section>
<title>Proof errors</title>

<para> &Specware; will report an error if the claim to be proved
does not occur in the spec, or if not all claims following [[using]]
occur in the spec before the claim to be proved.  </para>

<para> Snark will likely break into Lisp if the user inputs an
incorrect option.  </para>

</section>

<section>
<title>Proof Log Files</title>

<para> In the course of its execution Snark typically outputs a lot of
information as well as a proof when it finds one.  All this output can
be overwhelming to the user, yet invaluable in understanding why the
proofs succeeded or failed.  To deal with all this output &Specware;
redirects all the Snark output to log files. In our example above,
which executed a proof in the file <"pruf.sw">, &Specware; will
create a subdirectory called <"Snark"> at the same level as
<"pruf.sw">.  In that directory a log file called <"pruf.log"> will be
created that contains all the Snark output.</para>

</section>

<section>
<title>Multiple Proofs</title>

<para> As there can be multiple units per file, there can be
multiple proof units in single file.  For example, in file <"pruuf.sw"> we
could include more than one proof unit, as follows: </para>

[[
||    p1  = prove prop1 using ax1, ax2
||    p1a = prove prop1 using ax3
||    p2  = prove prop2
]]

<para> In this case [[proc pruuf]] will invoke Snark three separate times,
writing three different log files.  In this case an additional
subdirectory will be created under <"Snark">, called <"pruuf">.  The
three log files will then be: <"Snark/pruuf/p1.log">,
<"Snark/pruuf/p1a.log">, and <"Snark/pruuf/p2.log">.  </para>

</section>

<section>
<title>Interrupting Snark</title>

<para> As any first-order prover is wont to do, Snark is likely to
either loop forever or run for a longer time than the user can
wait.  The user can provide a time limit for Snark by using an
appropriate option.  However, there are likely to be times when the
user wants to stop Snark in the middle of execution.  The user can do this
by typing Cntrl-[[C]] Cntrl-[[C]] in the *common-lisp* buffer.  This will
then interrupt Snark and place the user in the Lisp debugger.  The user can
exit the debugger by issuing the [[:pop]] command.  A log file will
still be written that can be perused if so desired.  </para>

</section>

<section>
<title>The Prover Base Library</title>

<para> &Specware; has a base library that is implicitly imported by
every spec.  Unfortunately, the axioms in this library are not
necessarily written to be useful by Snark.  Instead of having Snark
use these libraries we have created a separate base library for Snark.
This library is located at <"/Library/Base/ProverBase.sw">.  The
axioms in this spec are automatically sent to Snark as part of any
proof.  </para>

</section>

<section>
<title>The Experimental Nature of the Prover</title>

<para> Our experience with the current prover interface is very new
and as such we are still very much experimenting with it and don't
expect it to be perfect at this point in time.  Many simple theorems
will be provable.  Some that the user thinks should be might not, and
the user will be required to add further hypothesis and lemmas that
may seem unnecessary.  We are currently working on making this
interface as robust and predictable as possible, and welcome any
feedback the user can offer.  </para>

<para> One area where the user can directly experiment is with the
axioms that make up the [[ProverBase]].  The axioms that make up an
effective prover library are best determined by an experimental
evolutionary process.  The user is welcome to play with the axioms in
the [[ProverBase]], by adding new ones or changing or deleting old
ones.  Keep in mind the goal is to have a single library that is
useful for a wide range of proofs.  Axioms that are specific to
different proofs should be created in separate specs and imported
where needed.  </para>

</section>

</chapter>
