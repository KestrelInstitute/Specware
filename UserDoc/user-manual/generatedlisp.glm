<chapter id="generatedlisp">

<title>Lisp Code Generated from Specs</title>

<para>
The translation of executable specs to Lisp code is straightforward
for the most part as Lisp is a higher-order functional
language. Functional expressions go to lambda expressions and most
&Specware sorts are implemented as lisp lists and vectors apart
from the strings, numbers, characters and booleans which are
implemented by the corresponding lisp datatypes. This guide is meant
primarily to help the user in calling and debugging the functions
generated from a spec, so we concentrate on the translation of op
names to Lisp names and the implementation of sorts. The
implementation details of procedural constructs such as
pattern-matching are omitted. The interested user is free to examine
the lisp code itself, which is simple but verbose for pattern-matching
constructs.
</para>

<section>
<title>Translation of &Specware Names to Lisp Names</title>

<para>
&Specware ops are implemented using lisp defuns if they are functions,
defparameter otherwise. Their names are uppercased and put in the
package with the same name as the qualifier, or [[L:SW-SPEC]] if
unqualified. However, if the name is that of a built-in Lisp symbol,
the name is prepended with the character "!" and not uppercased. If
the qualifier of the op is the same as a built-in lisp package then
"[[L:-SPEC]]" is appended to the spec name to get the package name.  For
example, the lisp code for the spec:
</para>

[[
||  A qualifying spec
||    def two: Nat = 2
||    def add1(x:Nat): Nat = x + 1
||  endspec
]]
<para>
is
</para>

[[L:
||  (DEFPACKAGE "A")
||  (IN-PACKAGE "A")
||
||  (DEFPARAMETER TWO 2)
||  (DEFUN ADD1 (X) (NAT-SPEC::|!+| X 1))
]]
</section>


<section>
<title>Arity and Currying Normalization</title>

<para>
All &Specware functions are unary. Multiple argument functions are
modeled using either functions with product domains, or curried
functions. For efficiency we wish to exploit Common Lisp's support of
n-ary functions. Arity normalization aims to minimize unpacking and
packing of products when passing arguments to functions with product
domains, and currying normalization aims to minimize closure creation
when calling curried functions. The saving is particularly important
for recursive functions where there is saving at each recursive call,
and in addition, currying normalization may permit the Common Lisp
compiler to do tail recursion optimization. The naming scheme does not
require knowledge of the definition of a function when generating calls
to the function.
</para>

<para>
For each function whose argument is a product, two entry points are
created: an n-ary function whose name is derived from the op as
described above, and a unary function whose name has "[[L:-1]]"
appended. E.g. for 
</para>
[[
||  op min : Integer * Integer -> Integer
]]
<para>
there are two lisp functions [[L:#'MIN]] and [[L:#'MIN-1]].
A call with an explicit product is translated to the n-ary version,
otherwise the unary version is used. For example, [[min(1,2)]] translates
to [[L:(MIN 1 2)]], and [[ foldr min inf l ]] translates to 
[[L:(FOLDR-1-1-1 #'MIN-1 INF L)]].
When generating lisp for a definition, the form is examined to see whether the
definition is naturally n-ary. If it is, then the primary definition is
n-ary and the unary function is defined in terms of the n-ary function,
otherwise the situation is reversed. For example, given the definition
</para>
[[
||  def min(x,y) = if x <= y then x else y
]]
<para>
we get the two Common Lisp definitions:
</para>
[[L:
||  (DEFUN MIN (X Y) (if (<= x y) x y))
||  (DEFIN MIN-1 (X) (MIN (CAR X) (CDR X)))
]]
<para>
and given the definition
</para>
[[
||  def multFG(x: Nat * Nat) = (F x) * (G x)
]]
<para>
we get the two Common Lisp definitions:
</para>
[[L:
||  (DEFUN MULTFG (X Y) (PAIR1-1 (CONS X Y)))
||  (DEFUN MULTFG-1 (X) (* (F-1 X) (G-1 X)))
]]

<para>
For each curried function (i.e. for each function whose codomain is a
function) there is an additional uncurried version of the function
with "-1" added n times to the name where n is the number of curried
arguments. E.g. for
</para>
[[
||  op foldr: fa(key,a,b) (a * b -> b) -> b -> map(key,a) -> b
]]
<para>
there are two lisp functions [[L:#FOLDR]] and [[L:#FOLDR-1-1-1]].
</para>

<para>
As with arity normalization, the definition of a curried function is
examined to see whether it should be used to generate the curried or the
uncurried version, with the other being defined in terms of this
primary version.
</para>

<para>
As well as producing more efficient code, the currying normalization
makes code easier to debug using the Common Lisp trace facility. For
example if a function has a call of the form [[ foldr x y z]], this
call is implemented as [[L:(FOLDR-1-1-1 x y z)]], so you can trace
[[L:FOLDR-1-1-1]] to find out how it is being called and what it is
returning.
</para>
</section>


<section>
<title>Representation of Other Sorts</title>

<para>
[[Character]] and [[String]] sorts are represented as Lisp characters and
strings, [[Nat]] and [[Integer]] as Lisp integers, lists are represented using
Lisp lists, and [[Boolean]] [[true]] and [[false]] by the symbols [[L:T]] and [[L:NIL]].
</para>

<para>
Sums are represented as the cons of the constructor name in keyword
package and the fields of the constructor.
</para>

<para>
Binary products are implemented as cons cells (except for function
arguments which are described in the previous section): [[L:CONS]] to
construct and [[L:CAR]] and [[L:CDR]] to access the first and second fields.
Non-binary products are implemented as vectors: constructed using
[[L:VECTOR]] and the ith element accessed by [[L:(SVREF x i-1)]]. 
</para>

<para>
Records are implemented the same as products with the order of the
fields being alphabetic in the field names.
</para>

<para>
Restrictions and comprehensions are implemented using their supersort.
</para>

<para>
A quotient is represented as as a vector of three elements: the
quotient tag (which is the value of the lisp variable
[[L:SLANG-BUILT-IN::QUOTIENT-TAG]]), the representation of the quotient
relation, and the actual value in the underlying sort.
</para>
</section>
</chapter>
