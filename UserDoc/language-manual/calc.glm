<section id="Units"><title>Units</title>
<para>
<<
||  `project ::= `unit-definition*
||
||  `specware-file ::=
||       `unit
||     | `unit-definition { `unit-definition }*
||
||  `unit-definition ::= `unit-identifier = `unit
||
||  `unit ::=
||       `spec-term
||     | `morphism-term
||     | `diagram-term
<!--
** ||     | `let-term
** ||     | `where-term
-->
||     | `generate-term
>>
Restriction.
The `unit-identifier in each `unit-definition of a `specware-file
must be a `name that is a `word-symbol.
</para>
<para>
A `project consists of a collection of `unit-definitions.
`Unit-definitions of a `project may use other
`unit-definitions in the `project, including standard
libraries which in &SpecwareVV; are supposed to be part of
each `project.
However, the dependencies between `units must not form a
cycle; it must always be possible to arrange the
`unit-definitions in an order in which later
`unit-definitions only depend on earlier ones.
How `unit-definitions are processed by &Specware; is further
dealt with in the &Specware; User Guide.
</para>
<para>
`Unit-definitions are collected in `specware-files, which in
&SpecwareVV; must have an [[.sw]] extension.
The `specware-files do not directly contain the
`unit-definitions that form the `project.
These are instead determined from the `specware-files using
certain rules.
There are two possibilities here.
The first is that the `specware-file contains a
single unit.
If
<replaceable>P</replaceable>[[/]]<replaceable>N</replaceable>is
the full `path for the
`specware-file but without the [[.sw]] extension, the `unit
being defined has as its full `unit-identifier
<replaceable>P</replaceable>/<replaceable>N</replaceable>.
For example, if file <"/units/Layout/Fixture.sw"> contains a
single `unit <replaceable>U</replaceable>, the full `unit-identifier is
[[/units/Layout/Fixture]], and the `unit-definition it
contributes to the project is
[[
||  /units/Layout/Fixture = \<replaceable>U\</replaceable>
]]
(Note that this is not allowed as a `unit-definition in a
`specware-file, since the `unit-identifier is not a `name.)
</para>
<para>
The second possibility is that the `specware-file contains one or more
`unit-definitions.
If <replaceable>N</replaceable> is that `name, and
<replaceable>P</replaceable> is the full `path for the
`specware-file but without the [[.sw]] extension, the `unit
being defined has as its full `unit-identifier
<replaceable>P</replaceable>#<replaceable>N</replaceable>.
For example, if file <"/units/Layout/Moveable.sw"> contains a
`unit-definition [[Pos = \<replaceable>U\</replaceable>]], the
and the `unit-definition it
contributes to the project is
[[
||  /units/Layout/Moveable#Pos = \<replaceable>U\</replaceable>
]]
</para>
<!-- ***************************************************************** -->
<section><title>Unit Identifiers (`unit-identifiers)</title>
<para>
<<
||  `unit-identifier ::=
||       `specpath-relative-path
||     | `relative-path
||
||  `specpath-relative-path ::= / relative-path
||
||  `relative-path ::=
||      | `name [ # `name ]
||      | `path-element  / `relative-path
||
||  `path-element ::= `name | .. | .
>>
</para>
<formalpara id="Warning0"><title>Warning</title>
Note that `unit-identifiers are processed by the tokenizer like
everything else. This means that whitespace is removed and
marks not allowed in `names, even if otherwise permitted in
filenames, cannot appear in `unit-identifiers. For this reason,
some care must be taken when naming `units. 
</formalpara>
<para>
`Unit-identifiers are used to identify `units in the current
`project.
Typically, only a final part of the full `unit-identifier is
used.  When &Specware bis started with environment variable
<"SWPATH"> set to a colon-separated list of pathnames for files or
directories, the `specware-files are searched for relative
to these pathnames; for example, if <"SWPATH"> is set to
<"/units/Layout:.">, then
[[/units/Layout/Fixture]] may be shortened to [[/Fixture]],
and [[/units/Layout/Moveable#Pos]] to [[/Moveable#Pos]].
As usual, the filename ``<"."> stands for the current
directory; and allows &Specware; to look there for
`unit-definitions.
How `unit-definitions are processed by &Specware; is further
dealt with in the &Specware; User Guide.
</para>
<para>
The `unit-identifier must determine a `unit-definition as
described above; the elaboration of the `unit-identifier is
then the result of elaborating the corresponding `unit,
yielding a `spec, spec morphism, or diagram.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Specs</title>
<para>
<<
||  `spec-term ::=
||       `unit-identifier
||       `spec-form
||     | `spec-qualification
||     | `spec-translation
<!--
||     | `spec-visibility
-->
||     | `diagram-colimit
||
>>
Restriction.
When used as a `spec-term, the elaboration of a
`unit-identifier must yield a `spec.
</para>
<para>
The elaboration of a `spec-term, if defined, yields a
``closed `spec-form as defined in the next subsection.
</para>
<!-- ***************************************************************** -->
<section><title>Spec Forms</title>
<para>
<<
||  `spec-form ::=
||       spec '{ `declaration-sequence '}
||     | spec `declaration-sequence end
>>
Restriction.
`Spec-forms must be sort-correct.
</para>
<!-- ================================================================= -->
<para>
A <emphasis>closed</emphsis>`spec-form is a `spec-form
containing no `import-declarations.
</para>
<para>
The elaboration of a `spec-form yields the &Metaslang; text which is that
`spec itself, after expanding any `import-declarations.
The <emphasis>meaning</emphasis> of that text is the class
of models of the `spec, as described throughout this
Chapter.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Translations</title>
<para>
<<
||  `spec-qualification ::= qualify `spec-term by `qualifier
||
||  `spec-translation ::= translate `spec-term by `name-map
||
||  `name-map ::= '{ [ `name-map-item { , `name-map-item }* ] '}
||
||  `name-map-item :: `qualifiable-name +-> `qualifiable-name
>>
Let <replaceable>R</replaceable> be the result of
elaborating `spec-term <replaceable>S</replaceable>.
Then the elaboration of [[qualify
\<replaceable>S\</replaceable> by
\<replaceable>Q\</replaceable>]], where
<replaceable>Q</replaceable> is a `qualifier, is
<replaceable>R</replaceable> with each unqualified
`sort-name or `op-name <replaceable>N</replaceable> introduced there 
replaced by the `qualified-name
<replaceable>Q</replaceable>[[.]]<replaceable>N</replaceable>.
The same replacement applies to all uses of
<replaceable>N</replaceable> identifying that introduced
`name.
</para>
<para>
For example, the elaboration of
[[
||  qualify spec {
||    op size : Nat
||    axiom LargeSize is size >= 1024
||  } by Buffer
]]
results in:
[[
||  spec {
||    op Buffer.size : Nat
||    axiom LargeSize is Buffer.size >= 1024
||  } by Buffer
]]
</para>
<para>
Further, the elaboration of [[translate
\<replaceable>S\</replaceable> by {
\<replaceable>M\</replaceable>\<subscript>1\</subscript> +->
\<replaceable>N\</heplaceable>\<subscript>1\</subscript>, ...
\<replaceable>M\</replaceable>\<subscript>n\</subscript> +->
\<replaceable>N\</heplaceable>\<subscriptn1\</subscript> }]]
is <replaceable>R</replaceable> with each occurrence of a
`qualifiable-name
<replaceable>M</replaceable><subscript>i</subscript>
replaced by
<replaceable>N</replaceable><subscript>i</subscript>.
</para>
<para>
For example, the elaboration of
[[
||  translate spec {
||    sort E
||    op i : E
||  } by {
||    E +-> Counter
||    i +-> zero
||  }
]]
results in:
[[
||  spec {
||    sort Counter
||    op zero : Counter
||  } by {
]]
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Diagram Colimit</title>
<para>
<<
||  `diagram-colimit ::= colimit `diagram-term
>>
</para>
</section>
The result of elaborating a `diagram-colimit is the `spec
which is the apex of the cocone forming the
colimit in the category of `specs and `spec-morphisms.
See further the &Specware; User Guide.
</section>
<!-- ***************************************************************** -->
<section><title>Morphisms</title>
<para>
<<
||  `morphism-term ::=
||       `unit-identifier
||     | `spec-morphism
||
||  `spec-morphism ::= morphism `spec-term -> `spec-term '{ `name-map '}
>>
A morphism is a formal mapping between two closed `specs
that
describes exactly how one is translated or extended into the
other.
</para>
<para>
Restriction.
When used as a `morphism-term, the elaboration of a
`unit-identifier must yield a spec morphism.
</para>
<para>
Restriction.
Given `spec-morphism [[morphism \<replaceable>S\</replaceable> ->
\<replaceable>T\</replaceable> {
\<replaceable>M\</replaceable> }]],
let <replaceable>S'</replaceable> be the result of
elaborating [[translate \<replaceable>S\</replaceable> by {
<replaceable>M</replaceable> }]], and let
<replaceable>T'</replaceable> be the result of elaborating
<replaceable>T</replaceable>.
Then, first, each `sort-name or `op-name introduced in
<replaceable>S'</replaceable> must also be introduced in
<replaceable>T'</replaceable>.
Further, no `sort-name or `op-name originating from a
library `spec may have been subject to translation.
Finally, each `axiom in
<replaceable>S'</replaceable> must be a theorem that follows
from the `axioms of <replaceable>T'</replaceable>.
</para>
</section>
<!-- ***************************************************************** -->
<!--
<section><title>Spec sort and operator visibility</title>
<para>
<<
||  `spec-visibility ::=
||       hide `name-list in `spec-term
||     | export `name-list from `spec-term
||
||  `name-list ::= '{ `name { , `name }* '}
>>
</para>
</section>
-->
<!-- ***************************************************************** -->
<section><title>Diagrams</title>
<para>
<<
||  `diagram-term ::=
||       `unit-identifier
||     | `diagram-form
||
||  `diagram-form ::= diagram '{ `diagram-element { , `diagram-element }* '}
||
||  `diagram-elem ::
||       `diagram-node
||     | `diagram-edge
||
||  `diagram-node ::= `name +-> `spec-term
||
||  `diagram-edge ::= `name : `name -> `name +-> `morphism-term
||       
>>
Restriction.
When used as a `diagram-term, the elaboration of a
`unit-identifier must yield a diagram.
</para>
<para>
The result of elaborating a `diagram-form is the categorical
diagram whose nodes are labelled with `specs and
whose edges are labelled with `spec-morphisms.
</section>
<!-- ***************************************************************** -->
<!--
** <section><title>Let and Where Expressions</title>
** <para>
** <<
** ||  `let-term ::= let `local-bindings in `unit
** ||
** ||  `where-term ::= `unit where `local-bindings end
** ||
** ||  `local-bindings ::= `name = `unit { `name = `unit }*
** >>
** </para>
** </section>
-->
<!-- ***************************************************************** -->
<section><title>Generate Terms</title>
<para>
<<
||  `generate-term :: generate `string `spec-term [ in `string ]
>>
The elaboration of a `generate-term for a correct `spec-term
generates code; see further the &Specware; User Guide.
</section>
</section>
