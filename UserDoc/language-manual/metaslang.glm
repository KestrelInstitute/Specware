<chapter id="metaslang"><title>&Metaslang;</title>
<!-- ***************************************************************** -->
<para>
This chapter introduces the &Metaslang; specification language.
</para>
<!-- ================================================================= -->
<para>
The following sections give the grammar rules and meaning
for each &Metaslang; language construct.
</para>
<!-- ================================================================= -->
<formalpara id="GrammarDescriptionFormalism"><title>The grammar description formalism</title>
<para>
The grammar rules used to describe the &Metaslang; language
use the conventions of (extended) BNF.
For example, a grammar rule like:
<<
||    `wiffle ::= `waffle [ `waffle-tail ] | `piffle { + `piffle }*
>>
defines a `wiffle to be: either a `waffle optionally
followed by a `waffle-tail, or a sequence of one or more
`piffles separated by terminal `symbols[[ + ]].
(Further rules would be needed for `waffle, `waffle-tail and
`piffle.)
In a grammar rule the left-hand side of <<::=>> shows the kind
of construct being defined, and the right-hand side shows
how it is defined in terms of other constructs.
The sign <<|>> separates alternatives, the
square brackets <<[>> ... <<]>> enclose optional parts, and
the curly braces plus asterisk <<{>> ... <<}*>> enclose a part
that may be repeated any number of times, including zero
times.
All other signs stand for themselves, like the `symbol [[+]]
in the example rule above.
</para>
</formalpara>
<!-- ================================================================= -->
<para>
In the grammar rules terminal `symbols appear in a bold font.
Some of the terminal `symbols used, like [[|]] and [[{]], are
very similar to the grammar signs like <<|>> and <<{>> as
described above.
They can hopefully be distinguished by their bold appearance.
</para>
<!-- ================================================================= -->
<para>
Grammar rules may be <emphasis>recursive</emphasis>: a
construct may be defined in terms of itself, directly or
indirectly.
For example, given the rule:
<<
||    `piffle ::= 1 | M { `piffle }*
>>
here are some possible `piffles:
[[
||      1       M       M1      M111    MMMM    M1M1
]]
Note that the last two examples of `piffles are ambiguous.
For example, [[M1M1]] can be interpreted as:
[[M]] followed by the two `piffles [[1]] and [[M1]],
but also as:
[[M]] followed by the three `piffles [[1]], [[M]], and another
[[1]].
Some of the actual grammar rules allow ambiguities; the
accompanying text will indicate how they are to be resolved.
</para>
<!-- ================================================================= -->
<formalpara id="Models"><title>Models</title>
<para>
<<
||    `spec ::= `spec-form
||
||    `op ::= `op-name
>>
The term `spec is used as short for `spec-form
The <emphasis>semantics</emphasis> of &Metaslang; `specs is given
in terms of classes of <emphasis>models</emphasis>.
A model is an assignment of sorts (sets of values) to all the
`sort-names and of <quote>sorted</quote> values to all the `op-names
declared -- explicitly or implicitly -- in the `spec.
The notion of <emphasis>value</emphasis> includes
numbers, strings, arrays, functions, etcetera.
A sorted value can be thought of as a pair
(<replaceable>S</replaceable>, <replaceable>V</replaceable>),
in which 
<replaceable>S</replaceable> is a sort and
<replaceable>V</replaceable> is a value that is an
inhabitant of 
<replaceable>S</replaceable>.
For example, the `expressions [[0 : Nat]] and [[0 : Integer]]
correspond, semantically, to the sorted values
(<replaceable>N</replaceable>, 0) and
(<replaceable>Z</replaceable>, 0), respectively,
in which
<replaceable>N</replaceable> stands for the set of
natural numbers {0, 1, 2, ...}, and 
<replaceable>Z</replaceable> for the set of
integers {..., -2, -1, 0, 1, 2, ...}.
(For historical reasons, the term <emphasis>sort</emphasis> is
traditionally used in specification languages with
essentially the same meaning as the term
<emphasis>type</emphasis> in programming languages.)
In &Metaslang;, <emphasis>`op</emphasis> is used -- again for
historical reasons -- for declared names representing
values.
The term <quote>`op</quote> is used as an abbreviation for
<quote>`op-name</quote>.
(<emphasis>Op</emphasis> for <emphasis>operator</emphasis>, a
term used, again, for historical reasons, although including
things normally not considered operators.)
For example, given this `spec:
[[
||    spec
||      sort Even
||      op next : Even -> Even
||      axiom nextEffect is
||        fa(x : Even) ~(next x = x)
||    endspec
]]
one possible model (out of many!) is the assignment of
the even integers to [[Even]], and of the function that
increments an even number by 2 to [[next]].
</para>
</formalpara>
<!-- ================================================================= -->
<para>
Each model has to <emphasis>respect sorting</emphasis>; for
example, given the above assignment to [[Even]], the function
that increments a number by 1 does not map all even numbers
to even numbers, and therefore can not -- in the same model
-- be assigned to [[next]].
Additionally, the axioms of the `spec have to be satisfied by
the model.
The axiom qualifiable-claim-nameed [[nextEffect]] above states that
the function assigned to `op-name [[next]]
maps any value of the sort assigned to `sort-name [[Even]]
to a different value.
So the squaring function, although sort-respecting, could not
be assigned to [[next]] since it maps 0 to itself.
</para>
<!-- ================================================================= -->
<para>
If all sort-respecting combinations of assignments of sorts to
`sort-names and `ops to `op-names fail the axioms test, the
`spec has no models and is called
<emphasis>inconsistent</emphasis>.
Although usually undesirable, an inconsistent `spec is not by
itself considered erroneous.
The &Specware; system does not attempt to detect
inconsistencies, but associated provers can sometimes be
used to find them.
Not always; in general it is undecidable whether a
`spec is consistent or not.
</para>
<!-- ================================================================= -->
<para>
In general, the meaning of a construct in a model depends on
the assignments of that model, and more generally on an
<emphasis>environment</emphasis>: a model possibly extended
with assignments to `local-variables.
For example, the meaning of the `claim
[[fa(x : Even) ~(next x = x)]] in the axiom [[nextEffect]]
depends on the meanings of [[Even]] and [[next]],
while the sub-expression [[next x]], for example, also depends on
an assignment (of an <quote>even</quote> value) to [[x]].
To avoid laborious phrasings, the semantic descriptions use
language like <quote>the function [[next]] applied to
[[x]]</quote> as shorthand for this lengthy phrase:
<quote>the function assigned in the environment to [[next]] applied
to the value assigned in the environment to [[x]]</quote>.
</para>
<!-- ================================================================= -->
<para>
When an environment is extended with an assignment to a
`local-variable, any assignments to synonymous
`ops or other `local-variables are superseded by the
new assignment in the new environment.
In terms of &Metaslang; text, within the scope of the binding of
`local-variables, synonymous `ops and earlier introduced
`local-variables (that is, having the same `name) are
<quote>hidden</quote>; any use of the `name in that scope
refers to the textually most recently introduced
`local-variable.
For example, given:
[[
||    def x = "op-x"
||    def y = let v = "let-v" in x
||    def z = let x = "let-x" in x
]]
the value of [[y]] is [["op-x"]] (`op [[x]] is not hidden by the
`local-variable [[v]] of the `let-binding), whereas
the value of [[z]] is [["let-x"]] (`op [[x]]
<emphasis>is</emphasis> hidden by the
`local-variable [[x]] of the `let-binding).
</para>
<!-- ================================================================= -->
<formalpara id="Sort-correctness"><title>Sort-correctness</title>
<para>
If no sort-respecting combinations of assignments exist for a given
`spec, it is considered
<emphasis>incorrect</emphasis>, and is said to have a sort
error (or type error).
This is determined by &Specware; while elaborating the `spec,
and signaled as an error.
Sort-incorrectness differs from inconsistency in that the
meaning of the axioms does not come into play, and the
question whether an incorrect `spec is consistent is moot.
</para>
</formalpara>
<!-- ================================================================= -->
<para>
To be precise, there are subtle and less subtle differences
between sort-incorrectness of a `spec and its having no 
sort-respecting combinations of assignments.
For example, the following `spec is sort-correct but has no
models:
[[
||    spec
||      sort Empty = | Just Empty
||      op IdoNotExist : Empty
||    endspec
]]
The explanation is that the `sort-definition for [[Empty]]
generates an <emphasis>implicit</emphasis> axiom that all
inhabitants of the sort [[Empty]] must satisfy, and for this
recursive definition the axiom effectively states that such
creatures can't exist: the sort [[Empty]] is uninhabited.
That by itself is no problem, but precludes a sort-respecting
assignment of an inhabitant of [[Empty]] to `op [[IdoNotExist]].
So the `spec, while sort-correct, is actually inconsistent.
See further under <link linkend="Sort-definitions"><emphasis>Sort-definitions</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
Here is a sort-incorrect `spec that has sort-respecting
combinations of assignments:
[[
||    spec
||      sort Outcome = | Positive | Negative
||      sort Sign = | Positive | Zero | Negative
||      def whatAmI = Positive
||    endspec
]]
Here there are two constructors [[Positive]]
of different sorts, the sort [[Outcome]] and the sort
[[Sign]].
That by itself is fine, but when such
<quote>overloaded</quote> constructors are used,
the context must give sufficient information which is meant.
Here, the use of [[Positive]] in the `definition for `op
[[whatAmI]] leaves both possibilities open; as used it is
<emphasis>sort-ambiguous</emphasis>.
&Metaslang; allows omitting sort information provided that, given
a sort assignment to all `local-sort-variables in scope, unique
sorts for all sorted constructs, such as `expressions and
`patterns, can be inferred from the context.
If no complete and unambiguous sort-assignment can be made,
the `spec is not accepted by the &Specware; system.
Sort-ambiguous `expressions can be disambiguated by using a
sort annotation, as described under <link
linkend="Annotated-expressions"><emphasis>Annotated-expressions</emphasis></link>.
In the example, the `definition of [[whatAmI]] can be disambiguated in either
of the following ways:
[[
||      def whatAmI : Sign = Positive
||      def whatAmI = Positive : Sign
]]
Also, if the `spec elsewhere contains something along the lines of:
[[
||      op signToNat (s : Sign) : Nat
||      def sw = signToNat whatAmI
]]
that is sufficient to establish that [[whatAmI]] has sort [[Sign]]
and thereby disambiguate the use of [[Positive]].
See further under
<link linkend="Op-definitions"><emphasis>Op-definitions</emphasis></link>
and <link linkend="Structors"><emphasis>Structors</emphasis></link>.
</para>
<!-- ================================================================= -->
<formalpara id="Constructive"><title>Constructive</title>
<para>
When code is generated for a `spec, complete
<quote>self-contained</quote> code is only
generated for `sort-definitions and `op-definitions that are
fully <emphasis>constructive</emphasis>.
Non-constructiveness is <quote>contagious</quote>:
a `definition is only constructive if all components of the
definition are.
The sort of a `sort-name without `definition is not
constructive.
A sort is only constructive if all component sorts are.
An `op without `definition is non-constructive, and so
is an `op whose sort is non-constructive.
A `quantification is non-constructive.
The built-in polymorphic equality predicate [[=]] is only
constructive for <emphasis>discrete sorts</emphasis> (see
below).
</para>
</formalpara>
<!-- ================================================================= -->
<para>
A sort is called discrete if the equality predicate [[=]]
for that sort is constructive.
The built-in sorts [[Integer]], [[Nat]], [[Boolean]],
[[Char]] and [[String]] are all discrete.
Sort [[List]] <replaceable>S</replaceable> is discrete when
<replaceable>S</replaceable> is.
All function sorts are non-discrete (even when the domain
sort is the unit sort).
Sum sorts, product sorts and record sorts are discrete
whenever all component sorts are.
Subsort
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]] is discrete when
supersort <replaceable>S</replaceable> is.
(Predicate <replaceable>P</replaceable> need not be
constructive: the equality test is that of the supersort.)
Quotient sort
<replaceable>S</replaceable> [[/]]
<replaceable>Q</replaceable> is discrete when
predicate <replaceable>Q</replaceable> is
constructive.
(Sort <replaceable>S</replaceable> need not be discrete:
the equality test on the quotient sort is just the predicate
<replaceable>Q</replaceable> applied to pairs of members of the
<replaceable>Q</replaceable>-equivalence classes.)
</para>
<!-- ***************************************************************** -->
<section id="LexicalConventions"><title>Lexical conventions</title>
<para>
A &Metaslang; text consists of a sequence of
`symbols, possibly interspersed with whitespace.
The term <emphasis>whitespace</emphasis> refers to any
non-empty sequence of spaces, tabs, newlines, and `comments
(described below).
A `symbol is presented in the text as a sequence of one or
more <quote>marks</quote> (ASCII characters).
Within a composite (multi-mark) `symbol, no whitespace is
allowed, but whitespace may be needed between two `symbols if
together they could be taken for one `symbol; in particular,
two `names that follow each other should be separated by
whitespace.
<!-- OBSOLETE
More precisely, whitespace is required between two `symbols
unless at least one of the two is a `special-symbol (see
below for the various classes of `symbols).
Additionally, whitespace is required in two other
situations.
The first is after the
`special-symbol [[(]] when immediately followed by a
`non-word-symbol that starts with a `non-word-mark [[*]].
Without such whitespace, [[(*]] introduces a `block-comment.
The second is before or after the `special-symbol [[_]] (the
presentation of a `wildcard-pattern) when immediately followed
or preceded by a `name or another [[_]].
ETELOSBO -->
More precisely, whitespace is required between two adjacent
`symbols for each of the following combinations, in which
<quote>[[abc]]</quote> stands for an arbitrary `word-symbol,
<quote>[[<*>]]</quote> stands for an arbitrary `non-word-symbol,
<quote>[[?:!]]</quote> stands for an arbitrary `non-word-symbol
starting with a [[?]]-mark, and
<quote>[[123]]</quote> stands for an arbitrary `literal
(see below for the definitions of the various classes of
`symbols):
[[
||    abc  abc
||    abc  ?:!
||    abc  123
||    <*>  <*>
||    123  abc
||    123  123
||    abc  _
||      (  *
]]
Apart from the last two cases, no whitespace is ever
needed adjacent to a `special-symbol.
</para>
<!-- ================================================================= -->
<para>
Inside `literals (constant-denotations) whitespace is also
disallowed, except for <quote>`significant-whitespace</quote>
as described under
<link linkend="String-literals"><emphasis>String-literals</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
Other than that, whitespace -- or the lack of it -- has no significance.
Whitespace can be used to lay-out the text for readability, but
as far as only the meaning is concerned, the two following
presentations of the same `spec are entirely equivalent:
[[
||    spec
||      sort Even
||      op next : Even -> Even
||      axiom nextEffect is
||        fa(x : Even) ~(next x = x)
||    endspec
||
||    spec sort   Even op   next : Even -> Even axiom nextEffect
||    is fa(x : Even)~(next     x            = x)endspec
]]
</para>
<!-- ***************************************************************** -->
<section id="Symbols"><title>Symbols and Names</title>
<para>
<<
||`symbol ::= `name | `literal | `special-symbol
||
||`qualifiable-name ::= `unqualified-name | `qualified-name
||
||`unqualified-name ::= `name
||
||`qualified-name ::= `qualifier . `name
||
||`qualifier ::= `word-symbol
||
||`name ::= `word-symbol | `non-word-symbol
||
||`word-symbol ::= `word-start-mark { `word-continue-mark }*
||
||`word-start-mark ::= `letter
||
||`word-continue-mark ::=
||    `letter | `decimal-digit | _ | ?
||
||`letter ::=
||      A | B | C | D | E | F | G | H | I | J | K | L | M
||    | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
||    | a | b | c | d | e | f | g | h | i | j | k | l | m
||    | n | o | p | q | r | s | t | u | v | w | x | y | z
||
||`decimal-digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
||
||`non-word-symbol ::= `non-word-mark { `non-word-mark }*
||
||`non-word-mark ::=
||      ` | ~ | ! | @ | $ | ^ | & | * | -
||    | = | + | \ | '| | : | < | > | / | ?
||
||`special-symbol ::= _ | ( | ) | '[ | '] | '{ | '} | ; | , | .
>>
Example `qualifiable-names:
[[
||    Key
||    $
||    Calendar.Date
||    Monoid.<*>
]]
Example `names:
[[
||    Date                    $$            ?!
||    yymmdd2date             <*>           :=:
||    well_ordered?           ~==           
]]
For convenience, here are the 14 printing ASCII marks that,
next to `letters and `decimal-digits,
can <emphasis>not</emphasis> occur in a `non-word-symbol:
[[
||      #    %    '    "    _    (    )
||      [    ]    {    }    ;    ,    .
]]
Restriction.
As mentioned before, no whitespace is allowed in `symbols:
while [[anode]] is a single `name, both [[a node]] and
[[an ode]] consist of two `names.
Further, the case (lower or upper) of `letters in `names is
significant: [[grandparent]], [[grandParent]] and
[[grandpaRent]] are three different `names.
</para>
<!-- ================================================================= -->
<para>
Restriction.
In general, `names can be chosen freely.
However, the following <emphasis>reserved words</emphasis> have a
special meaning and must not be used for `names:
\<!-- !! (echo COLUMNIZE; cat reservedWords; echo ZeEnd) | abc -w meta -->
[[
||    as            endspec       infixr        restrict
||    axiom         ex            is            sort
||    case          fa            let           spec
||    choose        false         morphism      then
||    colimit       fn            of            theorem
||    conjecture    from          op            translate
||    def           generate      project       true
||    diagram       if            prove         where
||    else          import        qualifying
||    embed         in            quotient
||    embed?        infixl        relax
]]
They each count as a single `symbol, and no whitespace is
allowed inside any reserved word.
Further, a stand-alone colon mark [[:]], a stuttered colon mark
[[::]] and a stand-alone vertical-bar mark [[|]] may not be used
as `names.
In addition, several `names -- for example [[=]] -- are
pre-defined in built-in libraries.
While strictly speaking not reserved, they must not be
redefined.
See further the <link
linkend="libraries"><emphasis>Libraries</emphasis>
Appendix</link>.
</para>
<!-- ================================================================= -->
<para>
The `non-word-symbols can be used to choose convenient `names
for infix operators that, conventionally, are written with
non-alphabetic marks.
</para>
<!-- ================================================================= -->
<para>
Some &Metaslang; users follow the convention of using
`names that start with a capital letter for
`spec- and `sort-names and for `constructors,
while `word-symbols chosen for `op-names and `field-names start with a
lower-case `letter.
Both plain `local-variables and `local-sort-variables are often chosen
to be single lower-case `letters: [[x]], [[y]], [[z]],
[[a]], [[b]], [[c]], with the start of the alphabet
preferred for `local-sort-variables.
`Op-names of predicates (that is, having some sort
<replaceable>S</replaceable> [[-> Boolean]]) often end with
the mark [[?]].
These are just conventions that users are free to follow or
ignore, but in particular some convention distinguishing 
`constructors from `op-names and `local-variables is
recommended.
</para>
<!-- ===================== OBSOLETE  =================================
<formalpara id="Warning1"><title>Warning</title>
<para>
Note that [[Nat->Boolean]], [[n-1]] and [[x=0]], for instance,
are single `names.
If the similar formula is meant, whitespace must be used, as in
[[Nat -> Boolean]], [[n - 1]] and [[x = 0]].
Users are well-advised to use the defensive tactic of surrounding
all <quote>operators</quote> with whitespace.
</para>
</formalpara>
<formalpara id="Warning2"><title>Warning</title>
<para>
The liberal naming policy of &Metaslang; may change in the
future.
To develop <quote>future-proof</quote> `specs,
the safe approach is to use either alphanumeric `names,
starting with a `letter and further using only `letters and
`decimal-digits, or all non-alpha `names, like [[<+>]] or
[[>=>]].
</para>
</formalpara>
     ===================== ETELOSBO ================================== -->
</section>
<!-- ***************************************************************** -->
<section id="Comments"><title>Comments</title>
<para>
<<
||`comment ::= `line-end-comment | `block-comment
||
||`line-end-comment ::= % `line-end-comment-body
||
||`line-end-comment-body ::=
||    `any-text-up-to-end-of-line
||
||`block-comment ::= (* `block-comment-body *)
||
||`block-comment-body ::=
||    `any-text-including-newlines-and-nested-block-comments
>>
Example `comments:
[[
||    % keys must be unique
||    (* op yymmdd2Date : String -> Date *)
]]
&Metaslang; allows two styles of `comments.
The [[%]]-style is light-weight, for adding comment
on a line <emphasis>after</emphasis> the formal text (or
taking a line on its own, but always confined to
a single line).
The [[(*]]...[[*)]]-style can be used for blocks of text,
spanning several lines, or stay within a line.
Any text remaining on the line after the closing [[*)]] is
processed as formal text.
`Block-comments may be nested, so the pairs of brackets
[[(*]] and [[*)]] must be balanced.
</para>
<para>
A `block-comment can not contain a `line-end-comment and
vice versa: whichever starts first has <quote>the right of
way</quote>.
For example, [[(* 100 % or more! *)]] is a `block-comment
with `block-comment-body 
[[ 100 % or more! ]].
The [[%]] here is a mark like any
other; it does not introduce a `line-end-comment.
Conversely, in the `line-end-comment [[% op <*> stands for (*)]]
the [[(*]] is part of the `line-end-comment-body; it does
not introduce a `block-comment.
Note also that [[%]] and [[(*]] have no special significance
in `literals (which may not contain whitespace, including
`comments): [["100 % or more!"]] is a well-formed
`string-literal.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Units"><title>Units</title>
<para>
<<
||`project ::= `unit-definition*
||
||`specware-file ::=
||     `unit
||   | `unit-definition { `unit-definition }*
||
||`unit-definition ::= `unit-identifier = `unit
||
||`unit ::=
||     `spec-term
||   | `morphism-term
||   | `diagram-term
||   | `generate-term
||   | `proof-term
>>
<!--
** ||     | `let-term
** ||     | `where-term
-->
Restriction.
The `unit-identifier in each `unit-definition of a `specware-file
must be a `name that is a `word-symbol.
</para>
<para>
A `project consists of a collection of `unit-definitions.
`Unit-definitions of a `project may use other
`unit-definitions in the `project, including standard
libraries which in &SpecwareV; are supposed to be part of
each `project.
However, the dependencies between `units must not form a
cycle; it must always be possible to arrange the
`unit-definitions in an order in which later
`unit-definitions only depend on earlier ones.
How `unit-definitions are processed by &Specware; is further
dealt with in the &Specware; User Guide.
</para>
<para>
`Unit-definitions are collected in `specware-files, which in
&SpecwareV; must have an [[.sw]] extension.
The `specware-files do not directly contain the
`unit-definitions that form the `project.
These are instead determined from the `specware-files using
certain rules.
There are two possibilities here.
The first is that the `specware-file contains a
single unit.
If
<replaceable>P</replaceable>[[/]]<replaceable>N</replaceable>is
the full `path for the
`specware-file but without the [[.sw]] extension, the `unit
being defined has as its full `unit-identifier
<replaceable>P</replaceable>/<replaceable>N</replaceable>.
For example, if file <"/units/Layout/Fixture.sw"> contains a
single `unit <replaceable>U</replaceable>, the full `unit-identifier is
[[/units/Layout/Fixture]], and the `unit-definition it
contributes to the project is
[[
||  /units/Layout/Fixture = \<replaceable>U\</replaceable>
]]
(Note that this is not allowed as a `unit-definition in a
`specware-file, since the `unit-identifier is not a `name.)
</para>
<para>
The second possibility is that the `specware-file contains one or more
`unit-definitions.
If <replaceable>N</replaceable> is that `name, and
<replaceable>P</replaceable> is the full `path for the
`specware-file but without the [[.sw]] extension, the `unit
being defined has as its full `unit-identifier
<replaceable>P</replaceable>#<replaceable>N</replaceable>.
For example, if file <"/units/Layout/Moveable.sw"> contains a
`unit-definition [[Pos = \<replaceable>U\</replaceable>]], the
and the `unit-definition it
contributes to the project is
[[
||  /units/Layout/Moveable#Pos = \<replaceable>U\</replaceable>
]]
</para>
<!-- ***************************************************************** -->
<section><title>Unit Identifiers</title>
<para>
<<
||`unit-identifier ::=
||     `specpath-relative-path
||   | `relative-path
||
||`specpath-relative-path ::= / `relative-path
||
||`relative-path ::=
||    | `name [ # `name ]
||    | `path-element  / `relative-path
||
||`path-element ::= `name | .. | .
>>
</para>
<formalpara id="Warning0"><title>Warning</title> <para>
Note that `unit-identifiers are processed by the tokenizer like
everything else. This means that whitespace is removed and
marks not allowed in `names, even if otherwise permitted in
filenames, cannot appear in `unit-identifiers. For this reason,
some care must be taken when naming `units. 
</para> </formalpara>
<para>
`Unit-identifiers are used to identify `units in the current
`project.
Typically, only a final part of the full `unit-identifier is
used.  When &Specware bis started with environment variable
<"SWPATH"> set to a colon-separated list of pathnames for files or
directories, the `specware-files are searched for relative
to these pathnames; for example, if <"SWPATH"> is set to
<"/units/Layout:.">, then
[[/units/Layout/Fixture]] may be shortened to [[/Fixture]],
and [[/units/Layout/Moveable#Pos]] to [[/Moveable#Pos]].
As usual, the filename ``<".">'' stands for the current
directory; and allows &Specware; to look there for
`unit-definitions.
How `unit-definitions are processed by &Specware; is further
dealt with in the &Specware; User Guide.
</para>
<para>
The `unit-identifier must determine a `unit-definition as
described above; the elaboration of the `unit-identifier is
then the result of elaborating the corresponding `unit,
yielding a `spec, spec morphism, or diagram.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Specs</title>
<para>
<<
||`spec-term ::=
||     `unit-identifier
||     `spec-form
||   | `spec-qualification
||   | `spec-translation
||   | `spec-substitution
||   | `diagram-colimit
||
>>
<!--
||     | `spec-visibility
-->
Restriction.
When used as a `spec-term, the elaboration of a
`unit-identifier must yield a `spec.
</para>
<para>
The elaboration of a `spec-term, if defined, yields a
``closed'' `spec-form as defined in the next subsection.
</para>
<!-- ***************************************************************** -->
<section><title>Spec Forms</title>
<para>
<<
||`spec-form ::= spec `declaration-sequence endspec
>>
Restriction.
`Spec-forms must be sort-correct.
</para>
<!-- ================================================================= -->
<para>
A <emphasis>closed</emphasis> `spec-form is a `spec-form
containing no `import-declarations.
</para>
<para>
The elaboration of a `spec-form yields the &Metaslang; text which is that
`spec itself, after expanding any `import-declarations.
The <emphasis>meaning</emphasis> of that text is the class
of models of the `spec, as described throughout this
Chapter.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Translations</title>
<para>
<<
||`spec-qualification ::=  `qualifier qualifying `spec-term
||
||`spec-translation ::= translate `spec-term by `name-map
||
||`name-map ::= '{ [ `name-map-item { , `name-map-item }* ] '}
||
||`name-map-item ::= `sort-name-map-item | `op-name-map-item
||
||`sort-name-map-item ::= [ sort ] `qualifiable-name +-> `qualifiable-name
||
||`op-name-map-item ::=
||      [ op ] `annotable-qualifiable-name +-> `annotable-qualifiable-name
||
||`annotable-qualifiable-name ::= `qualifiable-name [ : `sort ]
>>
Let <replaceable>R</replaceable> be the result of
elaborating `spec-term <replaceable>S</replaceable>.
Then the elaboration of [[\<replaceable>Q\</replaceable>
qualifying \<replaceable>S\</replaceable>]], where
<replaceable>Q</replaceable> is a `qualifier, is
<replaceable>R</replaceable> with each unqualified
`sort-name or `op-name <replaceable>N</replaceable> introduced there 
replaced by the `qualified-name
<replaceable>Q</replaceable>[[.]]<replaceable>N</replaceable>.
The same replacement applies to all uses of
<replaceable>N</replaceable> identifying that introduced
`name.
</para>
<para>
For example, the elaboration of
[[
||  Buffer qualifying spec
||    op size : Nat
||    axiom LargeSize is size >= 1024
||  endspec
]]
results in:
[[
||  spec
||    op Buffer.size : Nat
||    axiom LargeSize is Buffer.size >= 1024
||  endspec
]]
</para>
<para>
Further, the elaboration of [[translate
\<replaceable>S\</replaceable> by {
\<replaceable>M\</replaceable>\<subscript>1\</subscript> +->
\<replaceable>N\</replaceable>\<subscript>1\</subscript>, ...
\<replaceable>M\</replaceable>\<subscript>n\</subscript> +->
\<replaceable>N\</replaceable>\<subscript>n\</subscript> }]]
is <replaceable>R</replaceable> with each occurrence of a
`qualifiable-name
<replaceable>M</replaceable><subscript>i</subscript>
replaced by
<replaceable>N</replaceable><subscript>i</subscript>.
</para>
<para>
For example, the elaboration of
[[
||  translate spec
||    sort E
||    op i : E
||  endspec by {
||    E +-> Counter
||    i +-> zero
||  }
]]
results in:
[[
||  spec
||    sort Counter
||    op zero : Counter
||  endspec
]]
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Substitutions</title>
<para>
<<
||`spec-substitution ::= `spec-term '[ `morphism-term ']
>>
Restriction.
@@@ Domain of morphism must be the spec.
</para>
<para>
Let <replaceable>R</replaceable> be the result of
elaborating `spec-term <replaceable>S</replaceable>,
and
<replaceable>N</replaceable> that of
`morphism-term <replaceable>M</replaceable>,
Then the elaboration of [[\<replaceable>S\</replaceable>[qualifying \<replaceable>M\</replaceable>]]] is TODO blabla.
Colimit of this pushout diagram PICTURE but better.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Diagram Colimit</title>
<para>
<<
||`diagram-colimit ::= colimit `diagram-term
>>
The result of elaborating a `diagram-colimit is the `spec
which is the apex of the cocone forming the
colimit in the category of `specs and `spec-morphisms.
See further the &Specware; User Guide.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section><title>Morphisms</title>
<para>
<<
||`morphism-term ::=
||     `unit-identifier
||   | `spec-morphism
||
||`spec-morphism ::= morphism `spec-term -> `spec-term `name-map
>>
A morphism is a formal mapping between two closed `specs
that
describes exactly how one is translated or extended into the
other.
</para>
<para>
Restriction.
When used as a `morphism-term, the elaboration of a
`unit-identifier must yield a spec morphism.
</para>
<para>
Restriction.
Given `spec-morphism [[morphism \<replaceable>S\</replaceable> ->
\<replaceable>T\</replaceable> {
\<replaceable>M\</replaceable> }]],
let <replaceable>S'</replaceable> be the result of
elaborating [[translate \<replaceable>S\</replaceable> by {
\<replaceable>M\</replaceable> }]], and let
<replaceable>T'</replaceable> be the result of elaborating
<replaceable>T</replaceable>.
Then, first, each `sort-name or `op-name introduced in
<replaceable>S'</replaceable> must also be introduced in
<replaceable>T'</replaceable>.
Further, no `sort-name or `op-name originating from a
library `spec may have been subject to translation.
Finally, each `axiom in
<replaceable>S'</replaceable> must be a theorem that follows
from the `axioms of <replaceable>T'</replaceable>.
</para>
</section>
<!-- ***************************************************************** -->
<!--
<section><title>Spec sort and operator visibility</title>
<para>
<<
||`spec-visibility ::=
||     hide `name-list in `spec-term
||   | export `name-list from `spec-term
||
||`name-list ::= '{ `name { , `name }* '}
>>
</para>
</section>
-->
<!-- ***************************************************************** -->
<section><title>Diagrams</title>
<para>
<<
||`diagram-term ::=
||     `unit-identifier
||   | `diagram-form
||
||`diagram-form ::= diagram '{ `diagram-element { , `diagram-element }* '}
||
||`diagram-elem ::
||     `diagram-node
||   | `diagram-edge
||
||`diagram-node ::= `name +-> `spec-term
||
||`diagram-edge ::= `name : `name -> `name +-> `morphism-term
||     
>>
Restriction.
When used as a `diagram-term, the elaboration of a
`unit-identifier must yield a diagram.
</para>
<para>
The result of elaborating a `diagram-form is the categorical
diagram whose nodes are qualifiable-claim-nameled with `specs and
whose edges are qualifiable-claim-nameled with `spec-morphisms.
</para>
</section>
<!-- ***************************************************************** -->
<!--
** <section><title>Let and Where Expressions</title>
** <para>
** <<
** ||`let-term ::= let `local-bindings in `unit
** ||
** ||`where-term ::= `unit where `local-bindings end
** ||
** ||`local-bindings ::= `name = `unit { `name = `unit }*
** >>
** </para>
** </section>
-->
<!-- ***************************************************************** -->
<section><title>Generate Terms</title>
<para>
<<
||`generate-term ::= generate `language-name `spec-term [ in `string ]
||
||`language-name ::= lisp
>>
The elaboration of a `generate-term for a correct `spec-term
generates code in the language suggested by the
`language-name (currently only Common Lisp); see further the
&Specware; User Guide.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Proof Terms</title>
<para>
<<
||`proof-term ::=
||  prove `qualifiable-claim-name in `spec-term { `proof-particular }*
||
||`proof-particular ::=
||      with `prover-name [ `prover-options ]
||    | using '{ `claim-list '}
||
||`prover-name ::= snark
||
||`claim-list ::= `qualifiable-claim-name { , `qualifiable-claim-name }*
>>
The elaboration of a `proof-term BLABLA
using the prover suggested by the
`prover-name (currently only SNARK).
The `prover-options are prover-specific and are not
defined here; see further the
&Specware; User Guide.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Declarations"><title>Declarations</title>
<para>
<<
||`declaration ::=
||      `import-declaration
||    | `sort-declaration
||    | `op-declaration
||    | `definition
||
||`definition ::=
||      `sort-definition
||    | `op-definition
||    | `claim-definition
||
||`equals ::= is | =
>>
Example `declarations:
[[
||    import Lookup
||    sort Key
||    op present : Database * Key -> Boolean
||    sort Key = String
||    def present(db, k) = embed? Some (lookup (db, k))
||    axiom norm-idempotent is fa(x) norm (norm x) = norm x
]]
</para>
<!-- ***************************************************************** -->
<section id="Import-declarations"><title>Import-declarations</title>
<para>
<<
||`import-declaration ::= import `spec-name
>>
Example `import-declarations
[[
||    import Lookup
]]
</para>
<!-- ================================================================= -->
<para>
An `import-declaration has the effect as
if the `declarations of the imported `spec are expanded in
place.
This cascades: if `spec <replaceable>A</replaceable> imports
<replaceable>B</replaceable>, and `spec
<replaceable>B</replaceable> imports
<replaceable>C</replaceable>, then effectively `spec
<replaceable>A</replaceable> also imports
<replaceable>C</replaceable>.
An important difference with earlier versions of &Specware;
is that multiple imports of the same `spec have the same
effect as a single import.
</para>
<!-- ================================================================= -->
<para>
If `spec <replaceable>A</replaceable> imports
<replaceable>B</replaceable>, each model of
<replaceable>A</replaceable> is necessarily a model of
<replaceable>B</replaceable> (after <quote>forgetting</quote>
any `names newly introduced by <replaceable>A</replaceable>).
So <replaceable>A</replaceable> is then a refinement of
<replaceable>B</replaceable>, and the morphism from
<replaceable>B</replaceable> to <replaceable>A</replaceable> is
known as the <quote>import morphism</quote>.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-declarations"><title>Sort-declarations</title>
<para>
<<
||`sort-declaration ::= sort `sort-name [ `formal-sort-parameters ]
||
||`formal-sort-parameters ::= `local-sort-variable | ( `local-sort-variable-list )
||
||`local-sort-variable ::= `name
||
||`local-sort-variable-list ::= `local-sort-variable { , `local-sort-variable }*
||
>>
Restriction.
Each `local-sort-variable of the `formal-sort-parameters must
be a different `name.
</para>
<!-- ================================================================= -->
<para>
Example `sort-declarations:
[[
||    sort Date
||    sort Array a
||    sort Map(a, b)
]]
</para>
<!-- ================================================================= -->
<para>
Every `sort-name used in a `spec must be declared (in the
same `spec or in an imported `spec, included the
<quote>built-in</quote> `specs that are always implicitly imported).
A `sort-name may have <emphasis>sort parameters</emphasis>.
Given the example `sort-declarations above, some valid
`sorts that can be used in this context are [[Array Date]],
[[Array (Array Date)]] and [[Map (Nat, Boolean)]].
</para>
<!-- ================================================================= -->
<para>
In a model of the `spec, a sort is assigned to
each unparameterized `sort-name, while an infinite
<emphasis>family</emphasis> of sorts is assigned to
parameterized `sort-names <quote>indexed</quote> by tuples
of sorts, that is, there is one family member, a sort,
for each possible assignment
of sorts to the `local-sort-variables.
So for the above example `sort-declaration of [[Array]]
one sort must be assigned to [[Array Nat]], one to
[[Array Boolean]], one to [[Array (Array Date)]], and so on.
These assigned sorts could all be the same sort, or perhaps all
different, as long as the model respects sorting.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-definitions"><title>Sort-definitions</title>
<para>
<<
||`sort-definition ::= sort `sort-name [ `formal-sort-parameters ] `equals `sort
>>
Example `sort-definitions:
[[
||    sort Date = {year : Nat, month : Nat, day : Nat}
||    sort Array a = List a
||    sort Map(a, b) = (Array (a * b) | key_uniq?)
]]
In each model, the sort assigned to the
`sort-name must be the same as the right-hand-side `sort.
For parameterized sorts, this extends to all possible
assignments
of sorts to the `local-sort-variables, taking the right-hand `sorts
as interpreted under each of these assignments.
So, for the example, [[Map(Nat, Char)]] is the same sort as
[[(Array (Nat * Char) | key_uniq?)]], and so on.
</para>
<!-- ================================================================= -->
<para>
With <emphasis>recursive</emphasis> `sort-definitions, there
are additional requirements.
For example, consider
[[
||    sort Stack a =
||      | Empty
||      | Push {top : a, pop : Stack a}
]]
This means that for each sort [[a]] there is a value
[[Empty]] of sort [[Stack a]], and further a function
[[Push]] that maps values of sort [[{top : a, pop : Stack
a}]] to [[Stack a]].
Furthermore, the sort assigned to [[Stack a]] must be such
that all its inhabitants can be constructed
<emphasis>exclusively</emphasis> and
<emphasis>uniquely</emphasis> in this way:
there is one inhabitant [[Empty]], and all others are the
result of a [[Push]].
Finally -- this is the point -- the sort in the model must
be such that its inhabitants can be constructed this way in
<emphasis>a finite number of steps</emphasis>.
So there can be no <quote>bottom-less</quote> stacks:
deconstructing a stack using
[[
||    def fa(a) hasBottom? (s : Stack a) : Boolean =
||      case s of
||         | Empty -> true
||         | Push {top, pop = rest} -> hasBottom? rest
]]
is a procedure that is guaranteed to terminate, always
resulting in [[true]].
</para>
<!-- ================================================================= -->
<para>
In general, `sort-definitions generate implicit axioms,
which for recursive definitions imply that the sort is not
<quote>larger</quote> than necessary.
In technical terms, in each model the sort is the least
fixpoint of a recursive domain equation.
</para>
<!-- ================================================================= -->
<!--
** <para>
** Note.  Not all recursive definitions have such least fixpoints,
** in which case the `spec is inconsistent.
** The corresponding axioms are higher-order of a nature that
** the provers that can currently be coupled to the &Specware;
** system can not handle, and are not actually generated.
** For normal cases of <quote>algebraic sorts</quote>
** like [[Stack a]] above, there is a first-order
** characterization, and the appropriate axioms are generated for
** use by provers.
** </para>
-->
</section>
<!-- ***************************************************************** -->
<section id="Op-declarations"><title>Op-declarations</title>
<para>
<<
||`op-declaration ::= op `op-name [ `fixity ] : `sort-scheme
||
||`fixity ::= `associativity `priority
||
||`associativity ::= infixl | infixr
||
||`priority ::= `nat-literal
||
||`sort-scheme ::= [ `sort-variable-binder ] `sort
||
||`sort-variable-binder ::= fa `local-sort-variable-list
||
>>
Example `op-declarations:
[[
||    op usage : String
||
||    op o infixl 24 : fa(a,b,c) (b -> c) * (a -> b) -> a -> c
]]
</para>
<!-- ====================== NOT YET ==================================
<para>
Restriction.
Although `ops may be <quote>overloaded</quote>,
an `op may not be redeclared and/or redefined with overlapping
<emphasis>source sorts</emphasis> (see below), whether in the
same `spec or after having been defined in an imported `spec,
not even when the meaning of both `definitions is the same.
For example, [[op abs : Nat -> Nat]] cannot coexist with
[[op abs : Integer -> Integer]], but either can coexist
with [[op abs : Char -> Nat]].
There may be both an `op-declaration and an `op-definition
for the same `op, provided that the sort information supplied
by the `op-declaration is compatible with the (explicit or
inferred) sort of the `op-definition, and that the
`op-definition is not given in an imported `spec (but in the
current `spec, or in a later `spec importing the current
`spec).
</para>

<para>
Restriction.
When an infix operator (see below) is overloaded,
all `op-declarations for the `op-name must have the same
`fixity.
</para>
     ====================== TEY TON ================================== -->
<!--
<para>
** Restriction.
** User-defined `ops may not be <quote>overloaded</quote>,
** or otherwise be redeclared and/or redefined, whether in the
** same `spec or after having been defined in an imported `spec,
** not even when the meaning of both `definitions is the same.
** </para>
-->
<!-- ================================================================= -->
<para>
An `op-declaration introduces an `op-name with an associated sort.
The sort can be <quote>monomorphic</quote>, like [[String]], or
<quote>polymorphic</quote> (indicated by a `sort-variable-binder).
In the latter case, an indexed family of values is assigned to
parameterized `sort-names <quote>indexed</quote> by tuples of
sorts, that is, there is one family member, a sorted value, for each
possible assignment of sorts to the `local-sort-variables of
the `sort-variable-binder, and the sort of that value is the
result of the corresponding substitution of sorts for
`local-sort-variables on the
polymorphic sort of the `op.
In the example above, the declaration of polymorphic [[o]] can
be thought of as introducing a family of (fictitious) `ops,
one for each possible assignment to the
`local-sort-variables [[a]], [[b]] and [[c]]:
[[
||o\<subscript>Nat,String,Char \</subscript> : (String -> Char) * (Nat -> String) -> Nat -> Char
||
||o\<subscript>Nat,Nat,Boolean \</subscript> : (Nat -> Boolean) * (Nat -> Nat) -> Nat -> Boolean
||
||o\<subscript>Char,Boolean,Nat\</subscript> : (Boolean -> Nat) * (Char -> Boolean) -> Char -> Nat
]]
and so on.
Any `op-definition for [[o]] must be likewise accommodating.
</para>
<!-- ================================================================= -->
<!-- ====================== NOT YET ==================================
<para>
Given a sort <replaceable>S</replaceable>, the sort
super(<replaceable>S</replaceable>) is defined to be
<replaceable>S</replaceable> if <replaceable>S</replaceable>
is not a subsort.
For a subsort [[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]],
super([[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]]) is the sort
super(<replaceable>S</replaceable>).
For example, super([[(Nat | even)]]) is [[Integer]].
</para>

<para>
The source sorts of an `op are the set of sorts determined
as follows.
If the sort of the `op is some monomorphic function sort
<replaceable>S</replaceable> [[->]]
<replaceable>T</replaceable>, the source sorts are the
singleton set {super(<replaceable>S</replaceable>)}.
If the sort of the `op is a polymorphic function sort
corresponding to some `sort-scheme
[[fa(]]<replaceable>V</replaceable>[[)]] <replaceable>S</replaceable> [[->]]
<replaceable>T</replaceable>, the source sorts are the
set of all sorts super(<replaceable>S'</replaceable>)
for the sorts
<replaceable>S'</replaceable> [[->]]
<replaceable>T'</replaceable> of the indexed family of
values,
obtainable by the substitution of sorts for
the `local-sort-variables in
<replaceable>V</replaceable>.
For example, for
[[
||   op f : fa(a) a * a -> a
]]
the source sorts are the set
{[[Integer * Integer]], [[Boolean * Boolean]], [[Char *
Char]], ...}.
</para>

<para>
Finally, if the sort of the `op is not a (monomorphic or
polymorphic) function sort, the source sorts of the `op are
the singleton set {[[()]]}, containing just the unit sort.
</para>
     ====================== TEY TON ================================== -->
<!-- ================================================================= -->
<para>
Only binary `ops (those having some sort
<replaceable>S</replaceable> [[*]]
<replaceable>T</replaceable> [[->]]
<replaceable>U</replaceable>)
may be declared with a `fixity.
When declared with a `fixity, the `op-name may be used in infix
notation, and then it is called an <emphasis>infix operator</emphasis>.
For [[o]] above, this means that [[o(f, g)]] and [[f o g]]
may be used, interchangeably, with no difference in meaning.
If the `associativity is [[infixl]], the infix operator is
called <emphasis>left-associative</emphasis>; otherwise,
if the `associativity is [[infixr]], it is
called <emphasis>right-associative</emphasis>.
If the `priority is [[priority]] <replaceable>N</replaceable>,
the operator is said to have
<emphasis>priority</emphasis> <replaceable>N</replaceable>.
The `nat-literal <replaceable>N</replaceable> stands for a
natural number; if infix operator 
<replaceable>O1</replaceable> has priority
<replaceable>N1</replaceable>,
and <replaceable>O2</replaceable> has priority
<replaceable>N2</replaceable>, with
<replaceable>N1</replaceable> &lt; <replaceable>N2</replaceable>,
we say that <replaceable>O1</replaceable> has
<emphasis>lower priority</emphasis> than
<replaceable>O2</replaceable>,
and that <replaceable>O2</replaceable> has
<emphasis>higher priority</emphasis> than
(or <emphasis>takes priority over</emphasis>)
<replaceable>O1</replaceable>.
For the role of the `associativity and `priority, see further at
<link linkend="metaslang-infix-application"><emphasis>Infix-applications</emphasis></link>.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Op-definitions"><title>Op-definitions</title>
<para>
<<
||`op-definition ::=
||    def [ `sort-variable-binder ] `formal-expression [ : `sort ] `equals
||        `expression
||
||`formal-expression ::= `op-name | `formal-application
||
||`formal-application ::= `formal-application-head `formal-parameter
||
||`formal-application-head ::= `op-name | `formal-application
||
||`formal-parameter ::= `closed-pattern
||
>>
<!-- ====================== NOT YET ==================================
||`formal-application ::= `formal-prefix-application | `formal-infix-application
||
||`formal-prefix-application ::= `formal-application-head `formal-parameter
||
||`formal-application-head ::= `op-name | `formal-prefix-application
||
||`formal-parameter ::= `closed-pattern
||
||`formal-infix-application ::= `formal-parameter `op-name `formal-parameter
>>
</para>
<para>
Restriction.
The `op-name of a `formal-infix-application must be an infix
operator.
</para>
<para>
     ====================== TEY TON ================================== -->
Example `op-definitions:
[[
||    def usage = "Usage: Lookup key [database]"
||
||    def fa(a,b,c) o(f : b -> c, g: a -> b) : a -> c =
||      fn (x : a) -> f(g x)
||
||    def o(f, g) x = f(g x)
]]
Restriction.
See the restriction under <link
linkend="Op-declarations"><emphasis>Op-declarations</emphasis></link>
on redeclaring/redefining
`ops.
</para>
<!-- ================================================================= -->
<!-- ====================== NOT YET ==================================
<para>
Disambiguation.
The grammar for `formal-application is ambiguous for cases
like
<replaceable>M N P</replaceable>, in which
<replaceable>M</replaceable> is any `name, and
<replaceable>N</replaceable> is an infix operator.
The ambiguity is resolved in favor of the reading
as a `formal-infix-application, and then the
`formal-infix-application <replaceable>M N P</replaceable>
is equivalent to the `formal-prefix-application
<replaceable>N</replaceable>
[[(]]<replaceable>M</replaceable>[[,]]
<replaceable>P</replaceable>[[)]].
For example, for infix operator [[o]],
[[
||    def f o g = fn x -> f(g x)
]]
is equivalent to
[[
||    def o (f, g) = fn x -> f(g x)
]]
</para>
     ====================== TEY TON ================================== -->
<para>
Note that a `formal-expression always contains precisely one
`op-name, which is the `op <emphasis>being defined</emphasis> by
the `op-definition.
Note further that the `formal-application of an `op-definition
always uses prefix notation, also for infix operators.
</para>
<!-- ================================================================= -->
<para>
An `op can be defined without having been declared.
In that case the `op-definition
generates an implicit `op-declaration for the `op, as well as
implicit `sort-declarations for <quote>place-holder</quote>
sorts needed for the `op-declaration.
For example, an undeclared `op defined by
[[
||    def f x y = (x, y x)
]]
generates implicit `declarations like:
[[
||    sort s4771
||    sort s4772
||    op f : s4771 -> (s4771 -> s4772) -> (s4771 * s4772)
]]
in which [[s4771]] and [[s4772]] are fresh `names.
Note that this is not polymorphic, but monomorphic with
<emphasis>unspecified</emphasis> sorts.
However, the further uses of [[f]] must uniquely determine
sorts for the place-holders.
In general, sorting information on `ops may be omitted, but sufficient
information must be supplied when used, so that all
`expressions can be assigned a sort in the context in which
they occur while uniquely associating the `ops with
`op-declarations or `op-definitions.
If two different associations both give sort-correct `specs,
the `spec is ambiguous and incorrect.
</para>
<!-- ================================================================= -->
<para>
As for `op-definitions, the presence of a `sort-variable-binder
signals that the `op being defined is polymorphic.
Note that the optional sort annotation in an `op-definition
may not be a polymorphic `sort-scheme, unlike for
`op-declarations.  For example, the following is ungrammatical:
[[
||    def o : fa(a,b,c) (b -> c) * (a -> b) -> a -> c =
||      fn (f, g) -> fn (x) -> f(g x)
]]
The presumably intended effect is achieved by
[[
||    def fa(a,b,c) o : (b -> c) * (a -> b) -> a -> c =
||      fn (f, g) -> fn (x) -> f(g x)
]]
In a model of the `spec, an indexed family of sorted values is
assigned to a polymorphic `op, with one family member for each
possible assignment of sorts to the `local-sort-variables of
the `sort-variable-binder, and the sort of that value is the
result of the corresponding `sort-instantiation for the
polymorphic sort of the `op.
Thus, we can reduce the meaning of a polymorphic
`op-definition to a family of (fictitious) monomorphic
`op-definitions.
</para>
<!-- ================================================================= -->
<para>
An `op-definition with `formal-prefix-application
[[
||    def \<replaceable>H\</replaceable> \<replaceable>P\</replaceable> = \<replaceable>E\</replaceable>
]]
in which
<replaceable>H</replaceable> is a `formal-application-head,
<replaceable>P</replaceable> is a `formal-parameter and
<replaceable>E</replaceable> an `expression,
is equivalent to the `op-definition
[[
||    def \<replaceable>H\</replaceable> = fn \<replaceable>P\</replaceable> -> \<replaceable>E\</replaceable>
]]
For example,
[[
||    def o (f, g) x = f(g x)
]]
is equivalent to
[[
||    def o (f, g) = fn x -> f(g x)
]]
which in turn is equivalent to
[[
||    def o = fn (f, g) -> fn x -> f(g x)
]]
By
<!-- ====================== NOT YET ==================================
using the transformation from infix to prefix if
applicable, and
repeating
     ====================== TEY TON ================================== -->
this deparameterizing transformation for each
`formal-parameter, an equivalent unparameterized `op-definition
is reached.
The semantics is described in terms of such `op-definitions.
</para>
<!-- ================================================================= -->
<para>
In each model, the sorted value assigned to the
`op being defined must be the same as the value of the
right-hand-side `expression.
For polymorphic `op-definitions, this extends to all possible
assignments of sorts to the `local-sort-variables.
</para>
<!-- ================================================================= -->
<para>
An `op-definition can be thought of as a special notation
for an axiom.
For example,
[[
||    def fa(a) double (x : a) = (x, x)
]]
can be thought of as standing for:
[[
||    op double : fa(a) a -> a * a
||
||    axiom double_def is
||      sort fa(a) fa(x : a) double x = (x, x)
]]
In fact, &Specware; generates such axioms for use by
provers.
But in the case of recursive definitions, this form of
axiomatization does not adequately capture the meaning.
For example,
[[
||    def f (n : Nat) : Nat = 0 * f n
]]
is an improper `definition, while
[[
||    axiom f_def is
||        fa(n : Nat) f n = 0 * f n
]]
characterizes the function that maps every natural number to
0.
The issue is the following.
Values in models can not be &undefined; and functions
assigned to `ops must
be <emphasis>total</emphasis>.
But in assigning a meaning to a recursive `op-definition, we
-- temporarily -- allow &undefined; and partial functions
(functions that are not everywhere defined on their domain
sort) to be assigned to recursively defined `ops.
In the thus extended class of models, the recursive `ops must be
the least-defined solution to the <quote>axiomatic</quote>
equation (the least fixpoint as in domain theory), given the
assignment to the other `ops.
For the example of [[f]] above this results in the
everywhere undefined function, since
0 times &undefined; is &undefined;.
If the solution results in an undefined value or a function
that is not total (or for higher-order functions, functions
that may return non-total functions, and so on), the
`op-definition is improper.
&SpecwareV; does not attempt to detect this condition
or generate proof obligations for showing its absence.
</para>
<!-- ================================================================= -->
<para>
Functions that are determined to be the value of an
`expression, but that are not assigned to `ops,
need not be total, but the context must enforce
that the function can not be applied to values for which it
is undefined.
Otherwise, the `spec is incorrect.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Claim-definitions"><title>Claim-definitions</title>
<para>
<<
||`claim-definition ::= `claim-kind `qualifiable-claim-name `equals `claim
||
||`claim-kind ::= axiom | theorem | conjecture
||
||`qualifiable-claim-name ::= `any-text-up-to-equals
||
||`claim ::= [ `sort-quantification ] `expression
||
||`sort-quantification ::= sort `sort-variable-binder
>>
Example `claim-definitions:
[[
||    axiom norm-idempotent is
||      norm o norm = norm
||
||    theorem o-assoc is
||      sort fa(a,b,c,d) fa(f : c -> d, g : b -> c, h : a -> b)
||        f o (g o h) = (f o g) o h
||
||    conjecture pivot<->hold is
||      let p = pivot hold in
||        fa (n : {n : Nat | n < p}) ~(hold n = hold p)
]]
Restriction.
The `qualifiable-claim-name must be a <emphasis>non-empty</emphasis>
sequence of `symbols, none of which is
a presentation of `equals (i.e., [[is]] or [[=]]).
The rule about whitespace being required to separate `symbols
is relaxed <emphasis>inside</emphasis> `qualifiable-claim-names, but the the
first and last `symbols of the `qualifiable-claim-name must be properly
separated from the `claim-kind preceding and `equals following
the `qualifiable-claim-name.
</para>
<!-- ================================================================= -->
<para>
Restriction.
The sort of the `claim must be [[Boolean]].
</para>
<!-- ================================================================= -->
<para>
When a `sort-quantification is present, the `claim is polymorphic.
The `claim may be thought of as standing for an infinite family
of monomorphic `claims, one for each possible assignment of
sorts to the `local-sort-variables.
</para>
<!-- ================================================================= -->
<para>
The `claim-kind [[theorem]] should only be used for `claims
that have actually been proved to follow from the (explicit or
implicit) axioms.
In other words, giving them axiom status should not change
the class of models.
Theorems can be used by provers.
</para>
<!-- ================================================================= -->
<para>
Conjectures are meant to represent proof obligations that should
eventually attain theoremhood.
Like theorems, they can be used by provers.
</para>
<!-- ================================================================= -->
<para>
The &Specware; system passes on the `qualifiable-claim-name of the
`claim-definition with the `claim for purposes of
identification.
Both may be transformed to fit the requirements of the prover,
and appear differently there.
Not all `claims can be faithfully represented in all provers,
and even when they can, the logic of the prover may not be up
to dealing with them.
</para>
<!-- ================================================================= -->
<para>
Remark.
It is a common mistake to omit the part <quote>`qualifiable-claim-name
`equals</quote> from a `claim-definition.
A defensive style against this mistake is to have the `claim always
start on a new text line.
This is additionally recommended because it may become required in
future revisions of Metaslang.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Sorts"><title>Sorts</title>
<para>
<<
||`sort ::=
||      `sort-sum
||    | `sort-arrow
||    | `slack-sort
||
||`slack-sort ::=
||      `sort-product
||    | `tight-sort
||
||`tight-sort ::=
||      `sort-instantiation
||    | `closed-sort
||
||`closed-sort ::=
||      `sort-name
||    | `local-sort-variable
||    | `sort-record
||    | `sort-restriction
||    | `sort-comprehension
||    | `sort-quotient
||    | ( `sort )
||
>>
(The distinctions <quote>`slack-</quote>,
<quote>`tight-</quote> and <quote>`closed-</quote> before
<quote>`sort</quote> have no semantic significance.
The distinction merely serves the purpose of diminishing the
need for parenthesizing in order to avoid grammatical ambiguities.)
</para>
<!-- ================================================================= -->
<para>
Example `sorts:
[[
||    | Point XYpos | Line XYpos * XYpos
||    List String * Nat -> Option String
||    a * Order a * a
||    PartialFunction (Key, Value)
||    Key
||    a
||    {center : XYpos, radius : Length}
||    (Nat | even)
||    {k : Key | present (db, k)}
||    Nat / (fn (m, n) -> m rem 3 = n rem 3)
||    (Nat * Nat)
]]
The meaning of a parenthesized `sort
[[(\<replaceable>S\</replaceable>)]] is the same
as that of the enclosed `sort
<replaceable>S</replaceable>.
</para>
<!-- ================================================================= -->
<para>
The various other kinds of `sorts not defined here are described
each in their following respective sections, with the exception
of `local-sort-variable, whose
(lack of) meaning as a `sort is described below.
</para>
<!-- ================================================================= -->
<para>
Restriction.
A `local-sort-variable may only be used as a `sort if
it occurs in the scope of a `formal-sort-parameters
or `sort-variable-binder in which it is introduced.
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
A single `name used as a `sort is a `local-sort-variable
when it occurs in the scope of a `formal-sort-parameters
or `sort-variable-binder in which it is introduced, and
then it identifies the textually most recent introduction.
Otherwise, the `name is a `sort-name.
</para>
<!-- ================================================================= -->
<para>
A `local-sort-variable used as a `sort has no meaning by
itself, and where relevant to the semantics is either
<quote>indexed away</quote> (for parameterized sorts) or
<quote>instantiated away</quote> (when introduced in a
`formal-sort-parameters or `sort-variable-binder) before a
meaning is ascribed to the construct in which it occurs.
Textually, it has a scope just like a plain `local-variable.
</para>
<!-- ***************************************************************** -->
<section id="Sort-sums"><title>Sort-sums</title>
<para>
<<
||`sort-sum ::= `sort-summand { `sort-summand }*
||
||`sort-summand ::= '| `constructor [ `slack-sort ]
||
||`constructor ::= `name
||
>>
Example `sort-sum:
[[
||    | Point XYpos | Line XYpos * XYpos
]]
Restriction.
The `constructors of a `sort-sum must all be different `names.
</para>
<!-- ================================================================= -->
<para>
The ordering of the `sort-summands has no significance:
[[| Zero | Succ Peano]] denotes the same <quote>sum sort</quote> as
[[| Succ Peano | Zero]].
</para>
<!-- ================================================================= -->
<para>
A `sort-sum denotes a <emphasis>sum sort</emphasis>, which
is a sort that is inhabited by <quote>tagged values</quote>.
A tagged value is a pair
(<replaceable>C</replaceable>, <replaceable>v</replaceable>),
in which 
<replaceable>C</replaceable> is a `constructor and
<replaceable>v</replaceable> is a sorted value.
</para>
<!-- ================================================================= -->
<para>
A `sort-sum introduces a number of `embedders, one for each
`sort-summand.
In the discussion, we omit the optional [[embed]] keyword of
the `embedders.
The `embedders are similar to `ops, and are explained as if
they were `ops, but note the Restriction specified under
<link linkend="Structors"><emphasis>Structors</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
For a `sort-sum
<replaceable>SS</replaceable> with
`sort-summand
<replaceable>C</replaceable> <replaceable>S</replaceable>,
in which
<replaceable>C</replaceable> is a `constructor and
<replaceable>S</replaceable> a `sort,
the corresponding pseudo-`op introduced is sorted as follows:
[[
||    op \<replaceable>C\</replaceable> : \<replaceable>S\</replaceable> -> \<replaceable>SS\</replaceable>
]]
It maps a value <replaceable>v</replaceable> of sort
<replaceable>S</replaceable> to the tagged value
(<replaceable>C</replaceable>,
<replaceable>v</replaceable>).
If the `sort-summand is a single
<emphasis>parameter-less</emphasis> `constructor (the
`slack-sort is missing),
the pseudo-`op introduced is sorted as follows:
[[
||    op \<replaceable>C\</replaceable> : \<replaceable>SS\</replaceable>
]]
It denotes the tagged value
(<replaceable>C</replaceable>, ()), in which () is the
inhabitant of the unit sort (see under <link linkend="Sort-records"><emphasis>Sort-records</emphasis></link>).
</para>
<!-- ================================================================= -->
<para>
The sum sort denoted by the `sort-sum then consists of the
union of the ranges (for parameter-less constructors the
values) of the pseudo-`ops for all constructors.
</para>
<!-- ================================================================= -->
<para>
The `embedders are individually, jointly and severally
<emphasis>injective</emphasis>,
and jointly <emphasis>surjective</emphasis>.
</para>
<!-- ================================================================= -->
<para>
This means, first, that for any pair of `constructors
<replaceable>C1</replaceable> and
<replaceable>C2</replaceable> of
<emphasis>any</emphasis> `sort-sum, and for any pair
of values
<replaceable>v1</replaceable> and
<replaceable>v2</replaceable>
of the appropriate sort
(to be omitted for parameter-less `constructors),
the value of
<replaceable>C1</replaceable> <replaceable>v1</replaceable>
is only equal to
<replaceable>C2</replaceable> <replaceable>v2</replaceable>
when
<replaceable>C1</replaceable>
and
<replaceable>C2</replaceable>
are the same `constructor of the <emphasis>same</emphasis>
sum sort, and
<replaceable>v1</replaceable> and
<replaceable>v2</replaceable>
(which then are either both absent, or else must have the
same sort) are both absent or are the same value.
In other words, whenever the `constructors are different, or are from
different `sort-sums, or the values are different, the
results are different.
(The fact that synonymous `constructors of different sorts
yield different values already follows from the fact that
values in the models are sorted.)
</para>
<!-- ================================================================= -->
<para>
Secondly, for any value <replaceable>u</replaceable> of any sum
sort, there is a `constructor <replaceable>C</replaceable> of
that sum sort and a value
<replaceable>v</replaceable> of the appropriate sort
(to be omitted for parameter-less `constructors),
such that the value of
<replaceable>C</replaceable> <replaceable>v</replaceable>
is
<replaceable>u</replaceable>.
In other words, all values of a sum sort can be constructed
with an `embedder.
</para>
<!-- ================================================================= -->
<para>
For example, consider
[[
||     sort Peano =
||       | Zero
||       | Succ Peano
||
||     sort Unique =
||       | Zero
]]
This means that there is a value
[[Zero]] of sort [[Peano]], and further a function
[[Succ]] that maps values of sort [[Peano]]
to sort [[Peano]].
Then [[Zero]] and [[Succ n]] are guaranteed to be
different, and each value of sort [[Peano]] is either
[[Zero : Peano]], or expressible in the form
[[Succ (n : Peano)]] for a suitable expression [[n]].
The `expressions [[Zero : Peano]] and [[Zero : Unique]]
denote different, entirely unrelated, values.
(Note that [[Unique]] is <emphasis>not</emphasis> a subsort of
[[Peano]].  Subsorts of a sort can only be made with a
`sort-restriction, for instance as in
[[(Peano | embed? Zero)]].)
For recursively defined `sort-sums, see also the discussion
under <link linkend="Sort-definitions"><emphasis>Sort-definitions</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
Note.
Although the sum sorts [[| Mono]] and [[| Mono ()]] have
exactly the same set of inhabitants when considered as
unsorted values, these two sorts are different, and the
pseudo-`ops they introduce have different sorts, only the
second of which is a function sort:
[[
||    Mono : | Mono
||
||    Mono : () -> | Mono ()
]]
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-arrows"><title>Sort-arrows</title>
<para>
<<
||`sort-arrow ::= `arrow-source -> `sort
||
||`arrow-source ::= `sort-sum | `slack-sort
||
>>
Example `sort-arrow:
[[
||    (a -> b) * b -> List a -> List b
]]
In this example, the `arrow-source is [[(a -> b) * b]], and the (target)
`sort [[List a -> List b]].
</para>
<!-- ================================================================= -->
<para>
The <emphasis>function sort</emphasis> <replaceable>S</replaceable> [[->]] <replaceable>T</replaceable> is inhabited by
precisely all <emphasis>partial or total</emphasis> functions from
<replaceable>S</replaceable>
to <replaceable>T</replaceable>.
That is, function <replaceable>f</replaceable> has sort
<replaceable>S</replaceable> [[->]] <replaceable>T</replaceable> if, and only if,
for each value <replaceable>x</replaceable> of sort
<replaceable>S</replaceable> such that the value of
<replaceable>f</replaceable> <replaceable>x</replaceable> is
defined, that value has sort <replaceable>T</replaceable>.
Functions can be constructed with `lambda-forms, and be used
in `applications.
</para>
<!-- ================================================================= -->
<para>
In considering whether two functions (of the same sort) are
equal, only the meaning on the domain sort is relevant.
Whether a function is undefined outside its domain sort, or
might return some value of some sort, is immaterial to the
semantics of &Metaslang;.
(For a sort-correct `spec, the difference is unobservable.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-products"><title>Sort-products</title>
<para>
<<
||`sort-product ::= `tight-sort * `tight-sort { * `tight-sort }*
||
>>
Example `sort-product:
[[
||    (a -> b) * b * List a
]]
Note that a `sort-product contains
at least two constituent `tight-sorts.
</para>
<!--====================================================================-->
<para>
A `sort-product denotes a <emphasis>product sort</emphasis>
that has at least two <quote>component sorts</quote>,
represented by its `tight-sorts.
The ordering of the component sorts is significant: unless
<replaceable>S</replaceable>
and <replaceable>T</replaceable> are the same sort,
the product sort
<replaceable>S</replaceable> [[*]] <replaceable>T</replaceable> is different from the sort
<replaceable>T</replaceable> [[*]] <replaceable>S</replaceable>.
Further, the three sorts
[[(]]<replaceable>S</replaceable> [[*]]
<replaceable>T</replaceable>[[)]] [[*]]
<replaceable>U</replaceable>,
<replaceable>S</replaceable>
[[*]] [[(]]<replaceable>T</replaceable> [[*]]
<replaceable>U</replaceable>[[)]] and
<replaceable>S</replaceable> [[*]]
<replaceable>T</replaceable> [[*]]
<replaceable>U</replaceable> are all different; the first
two have two component sorts, while the last one has three.
The inhabitants of the product sort
<replaceable>S</replaceable><subscript>1</subscript> [[*]]
<replaceable>S</replaceable><subscript>2</subscript> [[*]] ...
[[*]] <replaceable>S<subscript>n</subscript></replaceable>
are precisely all <replaceable>n</replaceable>-tuples
(<replaceable>v<subscript>1</subscript></replaceable>,
<replaceable>v<subscript>2</subscript></replaceable>, ... ,
<replaceable>v<subscript>n</subscript></replaceable>), where each
<replaceable>v<subscript>i</subscript></replaceable> has sort
[[\<replaceable>S\<subscript>i\</subscript>\</replaceable>]], for
<replaceable>i</replaceable> = 1, 2, ... ,
<replaceable>n</replaceable>.
Values of a product sort can be constructed with
`tuple-displays, and component values can be extracted with
`tuple-patterns as well as with `projectors.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-instantiations"><title>Sort-instantiations</title>
<para>
<<
||`sort-instantiation ::= `sort-name `actual-sort-parameters
||
||`actual-sort-parameters ::= `closed-sort | `proper-sort-list
||
||`proper-sort-list ::= ( `sort , `sort { , `sort }* )
||
>>
Example `sort-instantiation:
[[
||    Map (Nat, Boolean)
]]
Restriction.
The `sort-name must have been declared or
defined as a parameterized sort (see <link linkend="Sort-declarations"><emphasis>Sort-declarations</emphasis></link>), and
the number of `sorts in the `actual-sort-parameters must match
the number of `local-sort-variables in the
`formal-sort-parameters of the `sort-declaration and/or `sort-definition.
</para>
<!-- ================================================================= -->
<para>
The `sort represented by a `sort-instantiation is the sort
assigned for the combination of sorts of the `actual-sort-parameters
in the indexed family of sorts for the `sort-name of the
`sort-instantiation.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-names"><title>Sort-names</title>
<para>
<<
||`sort-name ::= `qualifiable-name
>>
Example `sort-names:
[[
||    Key
||    Calendar.Date
]]
Restriction.
At the spec level, a `sort-name may only be used if
there is a `sort-declaration and/or
`sort-definition for it in the current `spec or in some `spec
that is imported (directly or indirectly) in the current `spec.
If there is a unique `qualified-name for a given
`unqualified-ending, the qualification may be omitted for a
`sort-name used as a `sort.
</para>
<!-- ================================================================= -->
<para>
The sort of a `sort-name is the sort assigned to
it in the model.
(In this case, the context can not have superseded the
original assignment.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-records"><title>Sort-records</title>
<para>
<<
||`sort-record ::= '{ [ `field-sorter-list ] '} | ( )
||
||`field-sorter-list ::= `field-sorter { , `field-sorter }*
||
||`field-sorter ::= `field-name : `sort
||
||`field-name ::= `name
||
>>
Example `sort-record:
[[
||    {center : XYpos, radius : Length}
]]
Restriction.
The `field-names of a `sort-record must all be different.
</para>
<!-- ================================================================= -->
<para>
Note that a `sort-record contains either no
constituent `field-sorters, or else at least two.
</para>
<!--====================================================================-->
<para>
A `sort-record is like a `sort-product, except that the
components, called <quote>fields</quote>, are identified by
name instead of by position.
The ordering of the `field-sorters has no significance:
[[{center : XYpos, radius : Length}]]
denotes the same <emphasis>record sort</emphasis> as
[[{radius : Length, center : XYpos}]].
Therefore we assume in the following, without loss of generality, that
the fields are ordered lexicographically according to their
`field-names (as in a dictionary: [[a]] comes
before [[ab]] comes before [[b]]) using some fixed collating
order for all marks that may comprise a name.
Then each field of a record sort with
<replaceable>n</replaceable> fields has a
<emphasis>position</emphasis> in the range 1 to
<replaceable>n</replaceable>.
The inhabitants of the record sort
[[{]]<replaceable>F</replaceable><subscript>1</subscript>
[[:]]
<replaceable>S</replaceable><subscript>1</subscript>[[,]]
<replaceable>F</replaceable><subscript>2</subscript>
[[:]]
<replaceable>S</replaceable><subscript>2</subscript>[[,]]
...
[[,]]
<replaceable>F<subscript>n</subscript></replaceable>
[[:]]
<replaceable>S<subscript>n</subscript></replaceable>[[}]]
are precisely all <replaceable>n</replaceable>-tuples
(<replaceable>v<subscript>1</subscript></replaceable>,
<replaceable>v<subscript>2</subscript></replaceable>, ... ,
<replaceable>v<subscript>n</subscript></replaceable>), where each
<replaceable>v<subscript>i</subscript></replaceable> has sort
<replaceable>S<subscript>i</subscript></replaceable>, for
<replaceable>i</replaceable> = 1, 2, ... ,
<replaceable>n</replaceable>.
The `field-names of that record sort are the `field-names
<replaceable>F</replaceable><subscript>1</subscript>,
... ,
<replaceable>F<subscript>n</subscript></replaceable>,
and, given the lexicographical ordering,
`field-name 
<replaceable>F<subscript>i</subscript></replaceable>
<emphasis>selects</emphasis>
position<replaceable>i</replaceable>, for
<replaceable>i</replaceable> = 1, 2, ... ,
<replaceable>n</replaceable>.
Values of a record sort can be constructed with
`record-displays, and field values can be extracted with
`record-patterns and (as for
product sorts) with `projectors.
</para>
<!--====================================================================-->
<para>
For the `sort-record [[{}]], which may be equivalently
written as [[()]], the record sort it denotes has zero components, and
therefore no `field-names.
This zero-component sort has precisely one
inhabitant, and is called the <emphasis>unit
sort</emphasis>.
The unit sort may equally well be
considered a product sort, and is the only sort that is both
a product and a record sort.
<!--====================================================================-->
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-restrictions"><title>Sort-restrictions</title>
<para>
<<
||`sort-restriction ::= ( `slack-sort '| `expression )
||
>>
Example `sort-restriction:
[[
||    (Nat | even)
]]
Restriction.
In a `sort-restriction
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]], the `expression
<replaceable>P</replaceable> must be a predicate on
the sort
<replaceable>S</replaceable>, that is,
<replaceable>P</replaceable> must be a function of sort
<replaceable>S</replaceable> [[-> Boolean]].
</para>
<!-- ================================================================= -->
<para>
Note that the parentheses in
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]] are mandatory.
</para>
<!-- ================================================================= -->
<para>
The inhabitants of
`sort-restriction
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]] are precisely the
inhabitants of
sort
<replaceable>S</replaceable> that satisfy the
predicate
<replaceable>P</replaceable>, that is, they are
those values
<replaceable>v</replaceable> for which the value of
<replaceable>P</replaceable>
<replaceable>v</replaceable> is [[true]].
</para>
<!-- ================================================================= -->
<para>
If 
<replaceable>P1</replaceable> and
<replaceable>P2</replaceable> are the same 
function, then
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P1</replaceable>[[)]] and
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P2</replaceable>[[)]] are equivalent, that is,
they denote the same sort.
</para>
<!-- ================================================================= -->
<para>
The sort 
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]] is called a
<emphasis>subsort</emphasis> of
<emphasis>supersort</emphasis> <replaceable>S</replaceable>.
Values can be shuttled between a subsort and its supersort
and vice versa with
`relaxators and `restrictors; see also <link
linkend="metaslang-relax-pattern"><emphasis>Relax-patterns</emphasis></link>.
</para>
<!--====================================================================-->
<para>
Metaslang does not require the explicit use of a `relaxator to relax
an `expression from a subsort to its supersort if the
context requires the latter.
Implicit relaxation will take place when needed,
For example, in the `expression [[~1]] the `nat-literal [[1]]
of sort [[Nat]] is implicitly relaxed to sort [[Integer]] to
accommodate the unary negation operator [[~]], which has sort
[[Integer -> Integer]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-comprehensions"><title>Sort-comprehensions</title>
<para>
<<
||`sort-comprehension ::= '{ `annotated-pattern '| `expression '}
||
>>
Example `sort-comprehension:
[[
||    {n : Nat | even n}
]]
Restriction.
In a `sort-comprehension
[[{]]<replaceable>P</replaceable> [[:]]
<replaceable>S</replaceable> [[|]]
<replaceable>E</replaceable>[[}]],
the `expression
<replaceable>E</replaceable> must
have sort [[Boolean]].
</para>
<!-- ================================================================= -->
<para>
`Sort-comprehensions provide an alternative notation for
`sort-restrictions that is akin
to the common mathematical notation for set comprehensions.
The meaning of
`sort-comprehension
[[{]]<replaceable>P</replaceable> [[:]]
<replaceable>S</replaceable> [[|]]
<replaceable>E</replaceable>[[}]]
is the same as that of the `sort-restriction
[[(]]<replaceable>S</replaceable> [[|
fn]] <replaceable>P</replaceable> [[->]]
<replaceable>E</replaceable>[[)]].
So the meaning of the example `sort-comprehension above is
[[(Nat | fn n -> even n)]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sort-quotients"><title>Sort-quotients</title>
<para>
<<
||`sort-quotient ::= `closed-sort / `expression
>>
Example `sort-quotient:
[[
||     Nat / (fn (m, n) -> m rem 3 = n rem 3)
]]
Restriction.
In a `sort-quotient
<replaceable>S</replaceable> [[/]]
<replaceable>Q</replaceable>, the `expression
<replaceable>Q</replaceable> must be a (binary) predicate on
the sort <replaceable>S</replaceable> [[*]]
<replaceable>S</replaceable> that is an equivalence relation,
as explained below.
</para>
<!-- ================================================================= -->
<para>
Equivalence relation.
Call two values <replaceable>x</replaceable> and
<replaceable>y</replaceable> of sort
<replaceable>S</replaceable>
<quote><replaceable>Q</replaceable>-related</quote>
if
(<replaceable>x</replaceable>, <replaceable>y</replaceable>)
satisfies <replaceable>Q</replaceable>.
Then <replaceable>Q</replaceable> is an
<emphasis>equivalence relation</emphasis>
if, for all values <replaceable>x</replaceable>,
<replaceable>y</replaceable> and
<replaceable>z</replaceable> of sort
<replaceable>S</replaceable>,
<replaceable>x</replaceable> is
<replaceable>Q</replaceable>-related
to itself,
<replaceable>y</replaceable> is
<replaceable>Q</replaceable>-related to
<replaceable>x</replaceable> whenever
<replaceable>x</replaceable> is
<replaceable>Q</replaceable>-related to
<replaceable>y</replaceable>, and
<replaceable>x</replaceable> is
<replaceable>Q</replaceable>-related to
<replaceable>z</replaceable> whenever
<replaceable>x</replaceable> is
<replaceable>Q</replaceable>-related to
<replaceable>y</replaceable> and
<replaceable>y</replaceable> is
<replaceable>Q</replaceable>-related to
<replaceable>z</replaceable>.
The equivalence relation <replaceable>Q</replaceable>
then partitions the inhabitants of
<replaceable>S</replaceable> into
<emphasis>equivalence classes</emphasis>, being the maximal
subsets of
<replaceable>S</replaceable> containing
mutually <replaceable>Q</replaceable>-related members.
These equivalence classes will be called
<quote><replaceable>Q</replaceable>-equivalence classes</quote>.
</para>
<!-- ================================================================= -->
<para>
The inhabitants of the <emphasis>quotient
sort</emphasis>
<replaceable>S</replaceable> [[/]] <replaceable>Q</replaceable>
are precisely the <replaceable>Q</replaceable>-equivalence classes
into which the inhabitants of
<replaceable>S</replaceable> are partitioned by
<replaceable>Q</replaceable>.
For the example above, there are three equivalence
classes of natural numbers leaving the same remainder on
division by 3: the sets {0, 3, 6, ...},
{1, 4, 7, ...} and {2, 5, 8, ...}, and so the quotient sort
has three inhabitants.
</para>
<!-- ================================================================= -->
<para>
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Expressions"><title>Expressions</title>
<para>
<<
||`expression ::=
||      `lambda-form
||    | `case-expression
||    | `let-expression
||    | `if-expression
||    | `quantification
||    | `tight-expression
||
||`tight-expression ::=
||      `application
||    | `annotated-expression
||    | `closed-expression
||
||`closed-expression ::=
||      `op-name
||    | `local-variable
||    | `literal
||    | `field-selection
||    | `tuple-display
||    | `record-display
||    | `sequential-expression
||    | `list-display
||    | `structor
||    | ( `expression )
||
>>
(The distinctions `tight- and `closed- for `expressions lack
semantic significance, and merely serve the purpose of avoiding
grammatical ambiguities.)
</para>
<!--====================================================================-->
<para>
Example `expressions:
[[
||    fn (s : String) -> s ^ "."
||    case z of {re = x, im = y} -> {re = x, im = ~y}
||    let x = x + 1 in f(x, x)
||    if x <= y then x else y
||    fa(x,y) (x <= y)  <=>  ((x < y) or (x = y))
||    f(x, x)
||    [] : List Arg
||    <=>
||    x
||    3260
||    z.re
||    ("George", Poodle : Dog, 10)
||    {name = "George", kind = Poodle : Dog, age = 10}
||    (writeLine "key not found"; embed Missing)
||    ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
||    project 2
||    (n + 1)
]]
Restriction.
Like all polymorphic or sort-ambiguous constructs, an `expression
can only be used in a context if its sort can be inferred
uniquely, given the `expression and the context.
This restriction will not be repeated for the various kinds of
`expressions defined in the following subsections.
</para>
<!-- ================================================================= -->
<para>
The meaning of a parenthesized `expression
[[(]]<replaceable>E</replaceable>[[)]] is the same
as that of the enclosed `expression
<replaceable>E</replaceable>.
</para>
<!-- ================================================================= -->
<para>
The various other kinds of `expressions not defined here are described
each in their following respective sections, with the exception
of `local-variable, whose
meaning as an `expression is described below.
</para>
<!-- ================================================================= -->
<para>
Restriction.
A `local-variable may only be used as an `expression if
it occurs in the scope of the `local-variable-list of a
`quantification or of a `variable-pattern in which it is
introduced.
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
A single `name used as an `expression is a `local-variable
when it occurs in the scope of a `local-variable-list
or `variable-pattern in which a synonymous `local-variable
is introduced, and then it identifies the textually most recent
introduction.
Otherwise, the `name is an `op-name or an `embedder; for the
disambiguation between the latter two, see <link linkend="Embedders"><emphasis>Embedders</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
A `local-variable used as an `expression has the sorted value
assigned to it in the environment.
</para>
<!-- ***************************************************************** -->
<section id="Lambda-forms"><title>Lambda-forms</title>
<para>
<<
||`lambda-form ::= fn `match
||
>>
Example `lambda-form:
[[
||    fn (s : String) -> s ^ "."
]]
The value of a `lambda-form is a partial or total function.
If the value determined for a `lambda-form as described
below is not a total function, the context must enforce
that the function can not be applied to values for which it
is undefined.
Otherwise, the `spec is incorrect.
The &Specware; system does not attempt to detect this condition.
</para>
<!-- ================================================================= -->
<para>
The sort of a `lambda-form is that of its `match.
The meaning of a given `lambda-form of sort
<replaceable>S</replaceable> [[->]]
<replaceable>T</replaceable> is
the function <replaceable>f</replaceable> mapping each
inhabitant <replaceable>x</replaceable> of
<replaceable>S</replaceable> to a value
<replaceable>y</replaceable> of sort
<replaceable>T</replaceable>, where
<replaceable>y</replaceable> is the return value
of <replaceable>x</replaceable> for the `match of the
`lambda-form.
If the `match accepts each <replaceable>x</replaceable> of
sort <replaceable>S</replaceable> (for acceptance and return
value, see the section on <link linkend="Matches"><emphasis>Matches</emphasis></link>) function
<replaceable>f</replaceable> is total; otherwise it is
partial, and undefined for those values
<replaceable>x</replaceable> rejected.
</para>
<!-- ================================================================= -->
<para>
In case of a recursive definition, the above procedure may
fail to determine a value for <replaceable>y</replaceable>,
in which case function <replaceable>f</replaceable> is not
total, but undefined for <replaceable>x</replaceable>.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Case-expressions"><title>Case-expressions</title>
<para>
<<
||`case-expression ::= case `expression of `match
>>
Example `case-expressions:
[[
||    case z of {re = x, im = y} -> {re = x, im = ~y}
||
||    case s of
||       | Empty -> true
||       | Push {top = _, pop = rest} -> hasBottom? rest
]]
The value of a `case-expression
[[case]] <replaceable>E</replaceable> [[of]]
<replaceable>M</replaceable> is the same as that of
the `application
[[(fn]] <replaceable>M</replaceable>[[)
(]]<replaceable>E</replaceable>[[)]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Let-expressions"><title>Let-expressions</title>
<para>
<<
||`let-expression ::= let `let-bindings in `expression
||
||`let-bindings ::= `recless-let-binding | `rec-let-binding-sequence
||
||`recless-let-binding ::= `pattern `equals `expression
||
||`rec-let-binding-sequence ::= `rec-let-binding { `rec-let-binding }*
||
||`rec-let-binding ::=
||    def `name `formal-parameter-sequence [ : `sort ] `equals `expression
||
||`formal-parameter-sequence ::= { `formal-parameter }* `formal-parameter
>>
Example `let-expressions:
[[
||    let x = x + e in f(x, x)
||    let def f x = x + e in f (f x)
]]
In the case of a `recless-let-binding (recless =
recursion-less), the value of the `let-expression
[[let]] <replaceable>P</replaceable> [[=]]
<replaceable>A</replaceable> [[in]]
<replaceable>E</replaceable> is the same as that of the
`application
[[(fn]] <replaceable>P</replaceable> [[->]]
<replaceable>E</replaceable>[[)]]
[[(]]<replaceable>A</replaceable>[[)]].
For the first example above, this amounts to [[f(x + e, x + e)]].
Note that [[x = x + e]] is not interpreted as a recursive
definition.
</para>
<!-- ================================================================= -->
<para>
In case of a `rec-let-binding-sequence (rec = recursive), the
`rec-let-bindings have the role of <quote>local</quote>
`op-definitions; that is, they are treated exactly like
`op-definitions except that they are interpreted in the
local environment instead of the global model.
For the second example above, this amounts to
[[(x + e) + e]].
(If [[e]] is a `local-variable in this scope, the definition
of [[f]] can not be <quote>promoted</quote> to an
`op-definition, which would be outside the scope binding
[[e]].)
A `spec with `rec-let-bindings can be transformed into one
without such by creating `op-definitions for each
`rec-let-binding that take additional arguments, one for each of
the `local-variables referenced.  For the example, in which
[[f]] references `local-variable [[e]], the
`op-definition for the <quote>extended</quote> `op [[f\<superscript>+\</superscript>]]
would be [[def f\<superscript>+\</superscript> e x = x + e]], and the
`let-expression would become [[f\<superscript>+\</superscript> e (f\<superscript>+\</superscript> e x)]].
The only difference in meaning is that the models of the
transformed `spec assign a value to the newly introduced
`op-name [[f\<superscript>+\</superscript>]].
</para>
<!-- ================================================================= -->
<para>
Note that the first occurrence of [[x]] in the above example
of a `rec-let-binding is a `variable-pattern and the
second-occurrence is in its scope; the third and last occurrence of
[[x]], however, is outside the scope of the first [[x]] and
identifies an `op or `local-variable [[x]] introduced
elsewhere.
So, without change in meaning, the `rec-let-binding can be
changed to:
[[
||    let def f xena = xena + e in f (f x)
]]
</para>
</section>
<!-- ***************************************************************** -->
<section id="If-expressions"><title>If-expressions</title>
<para>
<<
||`if-expression ::= if `expression then `expression else `expression
||
>>
Example `if-expression:
[[
||    if x <= y then x else y
]]
The value of an `if-expression
[[if]] <replaceable>B</replaceable> [[then]]
<replaceable>T</replaceable> [[else]]
<replaceable>F</replaceable> is the same as that of the
`case-expression
[[case]] <replaceable>B</replaceable> [[of true ->
(]]<replaceable>T</replaceable>[[) | false ->
(]]<replaceable>F</replaceable>[[)]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Quantifications"><title>Quantifications</title>
<para>
<<
||`quantification ::= `quantifier ( `local-variable-list ) `expression
||
||`quantifier ::= fa | ex
||
||`local-variable-list ::= `annotable-variable { , `annotable-variable }*
||
||`annotable-variable ::= `local-variable [ : `sort ]
||
||`local-variable ::= `name
||
>>
Example `quantifications:
[[
||    fa(x) norm (norm x) = norm x
||    ex(e : M) fa(x : M) x <*> e = x & e <*> x = x
]]
Restriction.
Each `local-variable of the `local-variable-list must
be a different `name.
</para>
<!-- ================================================================= -->
<para>
</para>
<!-- ================================================================= -->
<para>
`Quantifications are non-constructive, even when the domain
sort is finitely enumerable.
The main use is in `claims.
The sort of a `quantification is [[Boolean]].
There are two kinds of quantifications:
[[fa]]-`quantifications (or <quote>universal
quantifications</quote>; fa = for all), and
[[ex]]-`quantifications (or <quote>existential
quantifications</quote>; ex = there exists).
</para>
<!-- ================================================================= -->
<para>
The value of a [[fa]]-`quantification
[[fa]] <replaceable>V</replaceable>
<replaceable>E</replaceable>, in which
<replaceable>V</replaceable> is a `local-variable-list and
<replaceable>E</replaceable> is an `expression,
is determined as
follows.
Let <replaceable>M</replaceable> be the `match
<replaceable>V</replaceable> [[->]] <replaceable>E</replaceable>.
If <replaceable>M</replaceable> has return value [[true]] for each
value <replaceable>x</replaceable> in its domain (note that
rejection cannot happen here), the value of the
`quantification is [[true]]; otherwise it is [[false]].
</para>
<!-- ================================================================= -->
<para>
The value of an [[ex]]-`quantification
[[ex]] <replaceable>V</replaceable>
<replaceable>E</replaceable> is the same as that of the
[[fa]]-`quantification
[[~(fa]] <replaceable>V</replaceable>
[[~(]]<replaceable>E</replaceable>[[))]].
</para>
<!-- ================================================================= -->
<para>
Note that [[fa]] and [[ex]] must be followed by an
opening parenthesis[[ ( ]].
So [[fa x (x = x)]], for example, is ungrammatical.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Applications"><title>Applications</title>
<para>
<<
||`application ::= `prefix-application | `infix-application
||
||`prefix-application ::= `application-head `actual-parameter
||
||`application-head ::= `closed-expression | `prefix-application
||
||`actual-parameter ::= `closed-expression
||
||`infix-application ::= `actual-parameter `op-name `actual-parameter
>>
Example `applications:
[[
||    f (x, x)
||    f x (g y)
||    x + 1
]]
Disambiguation.
The grammar for `application is ambiguous for cases
like
<replaceable>P N Q</replaceable>, in which
<replaceable>P</replaceable> and
<replaceable>Q</replaceable> are `closed-expressions, and
<replaceable>N</replaceable> is the `name of an infix operator.
The ambiguity is resolved in favor of the reading
as an `infix-application, and then the
`infix-application <replaceable>P N Q</replaceable>
is equivalent to the `prefix-application
<replaceable>N</replaceable>
[[(]]<replaceable>P</replaceable>[[,]]
<replaceable>Q</replaceable>[[)]].
For example, in the second example `application
[[f x (g y)]] given above,
if [[x]] is an infix operator,
the `application is an `infix-application
equivalent to `prefix-application [[x (f, g y)]].
If [[x]] is not defined as an infix operator, or is a
`local-variable in scope, the `application is the same as
the unconditionally unambiguous version [[(f x) (g y)]].
Note that the resolution of the ambiguity does not rely on
information about the sorts.  Even if
[[(f x) (g y)]] is sort-correct and
[[x (f, g y)]] is not, the latter interpretation is chosen
for disambiguating [[f x (g y)]]
whenever [[x]] is an infix operator in the context, and
consequently [[f x (g y)]] is then also sort-incorrect.
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
An `infix-application
<replaceable>P M Q N R</replaceable>, in which
<replaceable>P</replaceable>,
<replaceable>Q</replaceable> and
<replaceable>R</replaceable> are `actual-parameters and
<replaceable>M</replaceable> and
<replaceable>N</replaceable> are infix operators,
is interpreted as either
[[(]]<replaceable>P M Q</replaceable>[[)]] <replaceable>N
R</replaceable> or
<replaceable>P M</replaceable> [[(]]<replaceable>Q N
R</replaceable>[[)]].
The choice is made as follows.
If <replaceable>M</replaceable> has higher priority than
<replaceable>N</replaceable>, or the priorities are the same
but <replaceable>M</replaceable> is left-associative,
the interpretation is
[[(]]<replaceable>P M Q</replaceable>[[)]] <replaceable>N
R</replaceable>.
In all other cases
the interpretation is
<replaceable>P M</replaceable> [[(]]<replaceable>Q N
R</replaceable>[[)]].
For example, given
[[
||    op @ infixl 10: Nat * Nat -> Nat
||    op $ infixr 20: Nat * Nat -> Nat
]]
the following interpretations hold:
[[
||    1 $ 2 @ 3  =  (1 $  2) @ 3
||    1 @ 2 @ 3  =  (1 @  2) @ 3
||    1 @ 2 $ 3  =   1 @ (2  $ 3)
||    1 $ 2 $ 3  =   1 $ (2  $ 3)
]]
Note that no sort information is used in the disambiguation.
If [[(1 @ 2) $ 3]] is sort-correct but [[1 @ (2 $ 3)]] is
not, the formula [[1 @ 2 $ 3]] is sort-incorrect, since its
interpretation is.
</para>
<!-- ================================================================= -->
<para>
Restriction.
In an `application <replaceable>H</replaceable>
<replaceable>P</replaceable>, in which
<replaceable>H</replaceable> is an `application-head
and <replaceable>P</replaceable> an `actual-parameter,
the sort of <replaceable>P</replaceable>
must be some function sort
<replaceable>S</replaceable> [[->]] <replaceable>T</replaceable>, and then
<replaceable>H</replaceable> must have the domain sort
<replaceable>S</replaceable>.
The sort of the whole `application is then
<replaceable>T</replaceable>.
</para>
<!-- ================================================================= -->
<para>
The value of 
`application <replaceable>H</replaceable>
<replaceable>P</replaceable> is the value returned by
function <replaceable>H</replaceable> for the argument
value <replaceable>P</replaceable>.
(Since `infix-applications may always be rewritten
equivalently as
`prefix-applications, only the semantics for
`prefix-applications is given explicitly.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Annotated-expressions"><title>Annotated-expressions</title>
<para>
<<
||`annotated-expression ::= `tight-expression : `sort
>>
Restriction.
In an `annotated-expression
<replaceable>E</replaceable> [[:]]
<replaceable>S</replaceable>, the `expression
<replaceable>E</replaceable> must have sort
<replaceable>S</replaceable>.
</para>
<!-- ================================================================= -->
<para>
Example `annotated-expression:
[[
||    [] : List Arg
||    Positive : Sign
]]
The value of an `annotated-expression
<replaceable>E</replaceable> [[:]]
<replaceable>S</replaceable> is the value of
<replaceable>E</replaceable>.
</para>
<!-- ================================================================= -->
<para>
The sort of some `expressions is polymorphic.  For example,
for any sort <replaceable>T</replaceable>,
[[[]]] denotes the empty list of sort [[List]]
<replaceable>T</replaceable>.
Likewise, `constructors of parameterized sum sorts can be
polymorphic, as the constructor [[None]] of
[[
||    sort Option a = | Some a | None
]]
Further, overloaded `constructors have an ambiguous sort.
By annotating such polymorphic or sort-ambiguous
`expressions with a `sort, their sort can
be disambiguated, which is required unless an
unambiguous sort can already be inferred from the context.
Annotation, even when redundant, can further help to
increase clarity.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Op-names"><title>Op-names</title>
<para>
<<
||`op-name ::= `qualifiable-name
>>
Example `op-names:
[[
||    length
||    >=
||    DB_LOOKUP.Lookup
]]
Restriction.
An `op-name may only be used if
there is an `op-declaration and/or
`op-definition for it in the current `spec or in some `spec
that is imported (directly or indirectly) in the current `spec.
If there is a unique `qualified-name for a given
`unqualified-ending that is sort-correct in the context,
the qualification may be omitted for an
`op-name used as an `expression.
So overloaded `ops
may only be used as such when their sort can be
disambiguated in the context.
</para>
<!-- ================================================================= -->
<!-- ====================== NOT YET ==================================
<para>
Restriction.
Overloaded `ops, when used as `expressions, have an ambiguous sort.
They may only be used as such when their sort can be
disambiguated in the context.
Unlike for `constructors, target-sort information is not used
for this disambiguation.
For example, consider
[[
||    op abs : Nat -> Nat
||    op abs : Char -> Nat
||
||    def ok (c : Char) = abs c
||    def ko x          = abs x
]]
In the application [[abs c]]
(the right-hand side of the `definition for [[ok]])
[[c]] is known to have sort [[Char]] in the context.
This is enough to determine [[abs]] as identifying here
[[op abs : Char -> Nat]].
In the application [[abs x]]
(the right-hand side of the `definition for [[ko]])
the context gives no constraint on the sort of [[x]],
and no sort-disambiguation for [[abs]] is possible, so its
use there is incorrect.
</para>
     ====================== TEY TON ================================== -->
<!-- ================================================================= -->
<para>
The value of an `op-name is the value assigned to
it in the model.
(In this case, the context can not have superseded the
original assignment.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Literals"><title>Literals</title>
<para>
<<
||`literal ::=
||      `boolean-literal
||    | `nat-literal
||    | `char-literal
||    | `string-literal
||
>>
Example `literals:
[[
||    true
||    3260
||    #z
||    "On/Off switch"
]]
Restriction:
No whitespace is allowed anywhere inside any kind of `literal,
except for <quote>significant</quote> whitespace in
`string-literals, as explained there.
</para>
<!--====================================================================-->
<para>
`Literals provide denotations for the inhabitants of the
<quote>built-in</quote> sorts [[Boolean]], [[Nat]], [[Char]]
and [[String]].
The value of a `literal is independent of the environment.
</para>
<!--====================================================================-->
<para>
(There are no `literals for the built-in sort [[Integer]].
For nonnegative integers, a `nat-literal can be used.
For negative integers, apply the built-in `op [[~]], which
negates an integer, or use the built-in infix operator
[[-]]: both [[~1]] and [[0 - 1]] denote the negative integer
[[-]]1.)
</para>
<!-- ***************************************************************** -->
<section id="Boolean-literals"><title>Boolean-literals</title>
<para>
<<
||`boolean-literal ::= true | false
||
>>
Example `boolean-literals:
[[
||    true
||    false
]]
The sort [[Boolean]] has precisely two inhabitants,
the values of [[true]] and [[false]].
</para>
<!--====================================================================-->
<para>
Note that [[true]] and [[false]] are not `constructors.
So [[embed true]] is ungrammatical.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Nat-literals"><title>Nat-literals</title>
<para>
<<
||`nat-literal ::= `decimal-digit { `decimal-digit }*
>>
Example `nat-literals:
[[
||    3260
||    007
]]
The `sort [[Nat]] is, by definition, the subsort of
[[Integer]] restricted to the nonnegative integers 0, 1, 2,
... , which we identify with the natural numbers.
The value of a `nat-literal is the natural number of which
it is a decimal representation; for example, the
`nat-literal [[3260]] denotes the natural number 3260.
Leading `decimal-digits [[0]] have no significance:
both [[007]] and [[7]] denote the number 7.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Char-literals"><title>Char-literals</title>
<para>
<<
||`char-literal ::= #`char-literal-glyph
||
||`char-literal-glyph ::= `char-glyph | "
||
||`char-glyph ::=
||      `letter
||    | `decimal-digit
||    | `other-char-glyph
||
||`other-char-glyph ::=
||      ! | : | @ | # | $ | % | ^ | & | * | ( | ) | _ | - | + | =
||    | '| | ~ | ` | . | , | < | > | ? | / | ; | '' | '[ | '] | '{ | '}
||    | \\ | \"
||    | \a | \b | \t | \n | \v | \f | \r | \s
||    | \x `hexadecimal-digit `hexadecimal-digit
||
||`hexadecimal-digit ::=
||      `decimal-digit
||    | a | b | c | d | e | f
||    | A | B | C | D | E | F
>>
</para>
<!--====================================================================-->
<para>
Example `char-literals:
[[
||   #z
||   #\x7a
]]
The sort [[Char]] is inhabited by the 256
8-bit <emphasis>characters</emphasis>
occupying decimal positions 0 through 255 (hexadecimal
positions 00 through FF) in the ISO 8859-1 code table.
The first 128 characters of that code table are the
traditional ASCII characters (ISO 646).
(Depending on the operating environment, in particular the
second set of 128 characters -- those with
<quote>the high bit set</quote> -- may print or otherwise
be visually presented differently than intended by the
ISO 8859-1 code.)
The value of a `char-literal is a character of sort
[[Char]].
</para>
<!--====================================================================-->
<para>
The value of a `char-literal [[#]]<replaceable>G</replaceable>, where
<replaceable>G</replaceable> is a `char-glyph, is the character denoted by
<replaceable>G</replaceable>.
For example, [[#z]] is the character that prints as
[[z]].
The  two-mark `char-literal [[#"]] provides a variant notation of the
three-mark `char-literal [[#\"]] and yields the
character[[ " ]](decimal position 34).
</para>
<!--====================================================================-->
<para>
Each one-mark `char-glyph
<replaceable>C</replaceable> denotes the character that
<quote>prints</quote> as <replaceable>C</replaceable>.
The two-mark `char-glyph [[\\]] denotes
the character[[ \ ]](decimal position 92),
and the two-mark `char-glyph [[\"]] denotes
the character [[ " ]](decimal position 34).
</para>
<!--====================================================================-->
<para>
Notations are provided for denoting eight
<quote>non-printing</quote> characters, which, with the
exception of the first, are meant to regulate lay-out in
printing;
the actual effect may depend on the operating environment:
<informaltable frame="none">
<tgroup cols="4">
<tbody>
<row><entry>[[    ]]</entry><entry>glyph</entry><entry>decimal</entry><entry>name</entry></row>
<row><entry>[[]]</entry><entry>[[]]</entry><entry>[[]]</entry><entry>[[]]</entry></row>
<row><entry>[[]]</entry><entry>[[ \a]]</entry><entry>&nbsp;&nbsp;&nbsp;7</entry><entry>bell</entry></row>
<row><entry>[[]]</entry><entry>[[ \b]]</entry><entry>&nbsp;&nbsp;&nbsp;8</entry><entry>backspace</entry></row>
<row><entry>[[]]</entry><entry>[[ \t]]</entry><entry>&nbsp;&nbsp;&nbsp;9</entry><entry>horizontal tab</entry></row>
<row><entry>[[]]</entry><entry>[[ \n]]</entry><entry>&nbsp;&nbsp;10</entry><entry>newline</entry></row>
<row><entry>[[]]</entry><entry>[[ \v]]</entry><entry>&nbsp;&nbsp;11</entry><entry>vertical tab</entry></row>
<row><entry>[[]]</entry><entry>[[ \f]]</entry><entry>&nbsp;&nbsp;12</entry><entry>form feed</entry></row>
<row><entry>[[]]</entry><entry>[[ \r]]</entry><entry>&nbsp;&nbsp;13</entry><entry>return</entry></row>
<row><entry>[[]]</entry><entry>[[ \s]]</entry><entry>&nbsp;&nbsp;32</entry><entry>space</entry></row>
</tbody>
</tgroup>
</informaltable>
Finally, every character can be obtained using the
hexadecimal representation of its position.
The four-mark `char-glyph
[[\x]]<replaceable>H</replaceable><subscript>1</subscript><replaceable>H</replaceable><subscript>0</subscript>
denotes the character with hexadecimal position
<replaceable>H</replaceable><subscript>1</subscript><replaceable>H</replaceable><subscript>0</subscript>,
which is decimal position
16 times the decimal value of `hexadecimal-digit
<replaceable>H</replaceable><subscript>1</subscript> plus
the decimal value of `hexadecimal-digit
<replaceable>H</replaceable><subscript>0</subscript>,
where the decimal value of the digits [[0]] through [[9]] is
conventional, while the six extra digits [[A]] through [[F]]
correspond to 10 through 15.
The case (lower or upper) of the six extra
digits is not significant.
For example, [[\x7A]] or equivalently [[\x7a]] has decimal
position 16 times 7 plus 10 = 122, and either version denotes
the character [[z]].
The <quote>null</quote> character can be obtained by using
[[\x00]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="String-literals"><title>String-literals</title>
<para>
<<
||`string-literal ::= " `string-body "
||
||`string-body ::= { `string-literal-glyph }*
||
||`string-literal-glyph ::= `char-glyph | `significant-whitespace
||
||`significant-whitespace ::= `space | `tab | `newline
>>
The presentation of a `significant-whitespace is the
whitespace suggested by the name (`space, `tab or `newline).
</para>
<!--====================================================================-->
<para>
Example `string-literals:
[[
||    ""
||    "see page"
||    "see\spage"
||    "the symbol ' is a single quote"
||    "the symbol \" is a double quote"
]]
The sort [[String]] is inhabited by the
<emphasis>strings</emphasis>, which are (possibly empty)
sequences of characters.
The sort [[String]] is primitive; it is a different sort
than the isomorphic sort [[List Char]], and the list operations 
can not be directly applied to strings.
</para>
<!--====================================================================-->
<para>
The value of a `string-literal is the sequence of characters
denoted by the `string-literal-glyphs comprising its
`string-body, where
the value of a `significant-whitespace is the
whitespace character suggested by the name (space,
horizontal tab or newline).
For example, the `string-literal [["seepage"]] is different
from [["see page"]]; the latter denotes an eight-character
string of which the fourth character is a space.
The space can be made explicit by using the `char-glyph
[[\s]].
</para>
<!--====================================================================-->
<para>
When a double-quote character[[ " ]]is needed in a string, it
must be escaped, as in [["[6'2\"]"]], which would print like
this: [[[6'2"]]].
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Field-selections"><title>Field-selections</title>
<para>
<<
||`field-selection ::= `closed-expression . `field-selector
||
||`field-selector ::= `nat-literal | `field-name
||
>>
<!-- No longer needed because of transformation to project F E ****
** Restriction.
** When the `field-selector is some `nat-literal with value
** <replaceable>i</replaceable>, the sort of the
** `closed-expression must be a product sort,
** and if the number of components of that product sort is
** <replaceable>n</replaceable>, it must hold that
** <replaceable>i</replaceable> is one of the values 1 through 
** <replaceable>n</replaceable>.
** When the `field-selector is some `field-name
** <replaceable>F</replaceable>, the sort of the
** `closed-expression must be a record sort, one of whose
** fields has that `field-name <replaceable>F</replaceable>.
** </para>
** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
** <para>
**** No longer needed because of transformation to project F E -->
Disambiguation.
A `closed-expression of the form
<replaceable>M</replaceable>[[.]]<replaceable>N</replaceable>,
in which <replaceable>M</replaceable> is a `word-symbol and
<replaceable>N</replaceable> is a `name, is interpreted as
an `op-name if
<replaceable>M</replaceable>[[.]]<replaceable>N</replaceable>
occurs as the `op-name of an `op-declaration or `op-definition
in the `spec in which it occurs or in the set of `names
imported from another `spec through an `import-declaration.
Otherwise,
<replaceable>M</replaceable>[[.]]<replaceable>N</replaceable>
is interpreted as a `field-selection.
(The effect of a `field-selection can always be obtained
with a `projector.)
</para>
<!--====================================================================-->
<para>
Example `field-selections:
[[
||    triple.2
||    z.re
]]
<!-- No longer needed because of transformation to project F E ****
** Let the tuple or record <replaceable>v</replaceable> be the value of the
** `closed-expression of the `field-selection, and let the natural
** number <replaceable>i</replaceable> be determined as follows.
** When the `field-selector is some `nat-literal
** <replaceable>N</replaceable>,
** <replaceable>i</replaceable> is the value of
** <replaceable>N</replaceable>.
** When the `field-selector is some `field-name
** <replaceable>F</replaceable>, <replaceable>i</replaceable>
** is the position selected by <replaceable>F</replaceable> in
** sort <replaceable>S</replaceable>, as discussed under
** `Sort-records.
** The value of the `field-selection is then the
** <replaceable>i</replaceable>th component of
** <replaceable>v</replaceable>.
**** No longer needed because of transformation to project F E -->
A `field-selection
<replaceable>E</replaceable>[[.]]<replaceable>F</replaceable>
is a convenient notation for the equivalent `expression
[[(project]] <replaceable>F</replaceable>
<replaceable>E</replaceable>[[)]].
(See under <link linkend="Projectors"><emphasis>Projectors</emphasis></link>.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Tuple-displays"><title>Tuple-displays</title>
<para>
<<
||`tuple-display ::= ( `tuple-display-body )
||
||`tuple-display-body ::= [ `expression , `expression { , `expression }* ]
||
>>
Example `tuple-display:
[[
||    ("George", Poodle : Dog, 10)
]]
Note that a `tuple-display-body contains either no
`expressions, or else at least two.
</para>
<!--====================================================================-->
<para>
The value of a `tuple-display whose `tuple-display-body is
not empty, is the tuple whose
components are the respective values of the `expressions of
the `tuple-display-body, taken in textual order.
The sort of that tuple is the <quote>product</quote> of the
corresponding sorts of the components.
The value of [[()]] is the empty tuple, which is the sole
inhabitant of the unit sort [[()]].
(The fact that the notation [[()]] does double duty, for
a `sort and as an `expression, creates no ambiguity.
Note also that -- unlike the empty `list-display [[[]]] --
the `expression [[()]] is monomorphic, so
there is no need to ever annotate it with a `sort.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Record-displays"><title>Record-displays</title>
<para>
<<
||`record-display ::= '{ `record-display-body '}
||
||`record-display-body ::= [ `field-filler { , `field-filler }* ]
||
||`field-filler ::= `field-name `equals `expression
||
>>
Example `record-display:
[[
||    {name = "George", kind = Poodle : Dog, age = 10}
]]
The value of a `record-display is the record whose
components are the respective values of the `expressions of
the `record-display-body, taken in the lexicographic order
of the `field-names, as discussed under <link
linkend="Sort-records"><emphasis>Sort-records</emphasis></link>.
The sort of that record is the record sort with the same set
of `field-names, where the sort for each `field-name
<replaceable>F</replaceable> is the sort of
the corresponding sort of the component selected by
<replaceable>F</replaceable> in the record.
The value of [[{}]] is the empty tuple, which is the sole
inhabitant of the unit sort [[()]].
(For `expressions as well as for `sorts, the notations
[[{}]] and [[()]] are fully interchangeable.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sequential-expressions"><title>Sequential-expressions</title>
<para>
<<
||`sequential-expression ::= ( `open-sequential-expression )
||
||`open-sequential-expression ::= `void-expression ; `sequential-tail
||
||`void-expression ::= `expression
||
||`sequential-tail ::= `expression | `open-sequential-expression
>>
Example `sequential-expression:
[[
||    (writeLine "key not found"; embed Missing)
]]
A `sequential-expression
[[(]]<replaceable>V</replaceable>[[;]]
<replaceable>T</replaceable>[[)]] is equivalent to the
`let-expression [[let _ =]] <replaceable>V</replaceable>
[[in]] [[(]]<replaceable>T</replaceable>[[)]].
So the value of a `sequential-expression
[[(]]<replaceable>V</replaceable><subscript>1</subscript>[[;]]
... [[;]]
<replaceable>V</replaceable><subscript>n</subscript>[[;]]
<replaceable>E</replaceable>[[)]]
is the value of its
last constituent `expression <replaceable>E</replaceable>.
</para>
<!--====================================================================-->
<para>
`Sequential-expressions can be used to achieve
non-functional <quote>side effects</quote>, effectuated by
the elaboration of the `void-expressions, in particular
the output of a message.
This is useful for tracing the execution of generated code.
The equivalent effect of the example above can be achieved
by a `let-binding:
[[
||    let _ = writeLine "key not found" in
||    embed Missing
]]
(If the intent is to temporarily add, and later remove or
disable the tracing output, this is probably a more convenient
style, as the modifications needed concern a single full text line.)
Any values resulting from elaborating the `void-expressions are
discarded.
</para>
</section>
<!-- ***************************************************************** -->
<section id="List-displays"><title>List-displays</title>
<para>
<<
||`list-display ::= '[ `list-display-body ']
||
||`list-display-body ::= [ `expression { , `expression }* ]
||
>>
Example `list-display:
[[
||    ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
]]
Restriction.
All `expressions of the `list-display-body must have the
same sort.
</para>
<!--====================================================================-->
<para>
Note that a `list-display [[[]]] with empty
`list-display-body is polymorphic, and may need to be
sort-disambiguated, for example with a sort annotation.
In a case like [[[[], [1]]]], there is no need to
disambiguate [[[]]], since the above restriction already
implies that [[[]]] here has the same sort as [[[1]]],
which has sort [[List Nat]].
</para>
<!--====================================================================-->
<para>
The parameterized sort [[List]], although built-in, is
actually not primitive, but defined by:
[[
||    sort List a =
||      | Nil
||      | Cons a * List a
]]
The empty `list-display [[[]]] denotes the same list as the
`expression [[Nil]], a singleton `list-display
[[[]]<replaceable>E</replaceable>[[]]] denotes the same
list as the `expression [[Cons
(\<replaceable>E\</replaceable>, Nil)]], and a
multi-element `list-display
[[[\<replaceable>E\</replaceable>\<subscript>1\</subscript>, \<replaceable>E\</replaceable>\<subscript>2\</subscript>,]]
... [[,]] [[\<replaceable>E\<subscript>n\</subscript>\</replaceable>]]]
denotes the same list as the `expression [[Cons
(\<replaceable>E\</replaceable>\<subscript>1\</subscript>,
[\<replaceable>E\</replaceable>\<subscript>2\</subscript>,]]
... [[,]] [[\<replaceable>E\<subscript>n\</subscript>\</replaceable>])]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Structors"><title>Structors</title>
<para>
<<
||`structor ::=
||      `projector
||    | `relaxator
||    | `restrictor
||    | `quotienter
||    | `chooser
||    | `embedder
||    | `embedding-test
>>
<!-- *****************************************************************
<<    | `selector
>>
********************************************************************** -->
The `structors are a medley of constructs, all having polymorphic
or sort-ambiguous function sorts and denoting special functions
that go between structurally related sorts, such as
the constructors of sum sorts and the destructors of product sorts.
</para>
<!--====================================================================-->
<para>
Restriction.
Like all polymorphic or sort-ambiguous constructs, a `structor
can only be used in a context where its sort can be inferred
uniquely.
This restriction will not be repeated for the various kinds
of `structors described in the following subsections.
</para>
<!--====================================================================-->
<para>
For example, the following correct `spec becomes incorrect when
any of the sort annotations is omitted:
[[
||    spec
||      def fa(a) p2 = project 2 : String *  a  ->  a
||      def       q2 = project 2 : String * Nat -> Nat
||    endspec
]]
</para>
<!-- ***************************************************************** -->
<section id="Projectors"><title>Projectors</title>
<para>
<<
||`projector ::= project `field-selector
>>
Example `projectors:
[[
||    project 2
||    project re
]]
When the `field-selector is some `nat-literal with value
<replaceable>i</replaceable>, it is required that
<replaceable>i</replaceable> be at least 1.
The sort of the
`projector is a function sort (whose domain sort is a product
sort) of the form
<replaceable>S</replaceable><subscript>1</subscript> [[*]]
<replaceable>S</replaceable><subscript>2</subscript> [[*]] ...
[[*]] <replaceable>S<subscript>n</subscript></replaceable>
[[->]]
<replaceable>S<subscript>i</subscript></replaceable>,
where <replaceable>n</replaceable> is at least
<replaceable>i</replaceable>,
and the value of the `projector is the function that maps
each
<replaceable>n</replaceable>-tuple
(<replaceable>v<subscript>1</subscript></replaceable>,
<replaceable>v<subscript>2</subscript></replaceable>, ... ,
<replaceable>v<subscript>n</subscript></replaceable>)
inhabiting the domain sort 
to its <replaceable>i</replaceable>th component
<replaceable>v<subscript>i</subscript></replaceable>.
</para>
<!--====================================================================-->
<para>
When the `field-selector is some `field-name
<replaceable>F</replaceable>,
the sort of the
`projector is a function sort (whose domain sort is a record
sort) of the form
[[{]]<replaceable>F</replaceable><subscript>1</subscript>
[[:]]
<replaceable>S</replaceable><subscript>1</subscript>[[,]]
<replaceable>F</replaceable><subscript>2</subscript>
[[:]]
<replaceable>S</replaceable><subscript>2</subscript>[[,]]
...
[[,]]
<replaceable>F<subscript>n</subscript></replaceable>
[[:]]
<replaceable>S<subscript>n</subscript></replaceable>[[}]]
[[->]]
<replaceable>S<subscript>i</subscript></replaceable>,
where <replaceable>F</replaceable> is the same `field-name
as
<replaceable>F<subscript>i</subscript></replaceable>
for some natural number <replaceable>i</replaceable> in the
range 1 through <replaceable>n</replaceable>.
Assuming that the fields are lexicographically ordered by
`field-name (see under <link
linkend="Sort-records"><emphasis>Sort-records</emphasis></link>),
the value of the `projector is the function that maps
each
<replaceable>n</replaceable>-tuple
(<replaceable>v<subscript>1</subscript></replaceable>,
<replaceable>v<subscript>2</subscript></replaceable>, ... ,
<replaceable>v<subscript>n</subscript></replaceable>)
inhabiting the domain sort 
to its <replaceable>i</replaceable>th component
<replaceable>v<subscript>i</subscript></replaceable>.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Relaxators"><title>Relaxators</title>
<para>
<<
||`relaxator ::= relax `closed-expression
>>
Example `relaxator:
[[
||    relax even
]]
Restriction.
The `closed-expression of a `relaxator must have some function
sort <replaceable>S</replaceable> [[-> Boolean]].
</para>
<!--====================================================================-->
<para>
The sort of `relaxator [[relax]] <replaceable>P</replaceable>,
where <replaceable>P</replaceable> has sort
<replaceable>S</replaceable> [[-> Boolean]], is the function
sort (whose domain is a subsort) [[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]] [[->]]
<replaceable>S</replaceable>.
The value of the `relaxator is the function that maps each
inhabitant of subsort
[[(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]] to the same value --
apart from the sort information -- inhabiting supersort
<replaceable>S</replaceable>.
</para>
<!--====================================================================-->
<para>
For example, given
[[
||    sort Even = (Nat | even)
]]
we have the sorting
[[
||    relax even : Even -> Nat
]]
for the function that injects the even natural numbers back
into the supersort of [[Even]].
</para>
<!--====================================================================-->
<para>
Note the remarks about equivalence of `sort-restrictions in
the corresponding section.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Restrictors"><title>Restrictors</title>
<para>
<<
||`restrictor ::= restrict `closed-expression
>>
Example `restrictor:
[[
||    restrict even
]]
Restriction.
The `closed-expression of a `restrictor must have some function
sort <replaceable>S</replaceable> [[-> Boolean]].
</para>
<!--====================================================================-->
<para>
A `restrictor
[[restrict]] <replaceable>P</replaceable> is a convenient
notation for the `lambda-form
[[fn]] <replaceable>X</replaceable> [[->
let relax]] <replaceable>P</replaceable> <replaceable>V</replaceable> [[=]]
<replaceable>X</replaceable> [[in]]
<replaceable>V</replaceable>, where
<replaceable>V</replaceable> is some unique fresh `name, that
is, it is any `name that does not already occur in the
`spec, directly or indirectly through an import.
</para>
<!--====================================================================-->
<para>
The sort of a `restrictor is of the form
<replaceable>S</replaceable> [[->
(]]<replaceable>S</replaceable> [[|]]
<replaceable>P</replaceable>[[)]], that is, it goes from a
supersort to a subsort.
In general its value is a partial function, defined only on
the range of the function [[relax]]
<replaceable>P</replaceable>.
The use of this partial function engenders a proof obligation
that the arguments to which it is applied satisfy predicate
<replaceable>P</replaceable>.
</para>
<!--====================================================================-->
<para>
For example, the `restrictor
[[restrict (fn (n : Integer) -> n >= 0)]] has sort
[[Integer -> Nat]]; its domain of definedness are the
nonnegative integers (of sort [[Integer]]).
Used in the following `expression, which has
sort [[Nat]] assuming that [[i]] has sort [[Integer]],
[[
||    if i < 0
||    then 0
||    else restrict (fn (n : Integer) -> n >= 0) i
]]
the context guarantees that integer [[i]], where it is subjected
to the `restrictor, satisfies the nonnegativity
restriction on natural numbers, and will be accepted and
achieve [[Nat]]-hood.
Formally, the proof obligation here is [[((i < 0) =
false) => ((i >= 0) = true)]].
This is a theorem from the Theory of Integers.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Quotienters"><title>Quotienters</title>
<para>
<<
||`quotienter ::= quotient `closed-expression
>>
Example `quotienter:
[[
||     quotient (fn (m, n) -> m rem 3 = n rem 3)
]]
Restriction.
The `closed-expression of a `quotienter must have some sort
<replaceable>S</replaceable> [[*]]
<replaceable>S</replaceable> [[-> Boolean]];
in addition, it must be an equivalence relation, as explained
under <link
linkend="Sort-quotients"><emphasis>Sort-quotients</emphasis></link>.
</para>
<!--====================================================================-->
<para>
The sort of `quotienter [[quotient]] <replaceable>Q</replaceable>,
where <replaceable>Q</replaceable> has sort
<replaceable>S</replaceable> [[*]] <replaceable>S</replaceable>
[[-> Boolean]], is the function sort
<replaceable>S</replaceable> [[->]]
<replaceable>S</replaceable> [[/]]
<replaceable>Q</replaceable>, that is, it goes from some
sort to one of its quotient sorts.
The value of the `quotienter is the function that maps each
inhabitant of sort <replaceable>S</replaceable> to the
<replaceable>Q</replaceable>-equivalence class inhabiting <replaceable>S</replaceable>
[[/]] 
<replaceable>Q</replaceable> of which it is a member.
</para>
<!--====================================================================-->
<para>
For example, given
[[
||    def congMod3 : Nat * Nat -> Boolean =
||      (fn (m, n) -> m rem 3 = n rem 3)
||
||    sort Z3 = Nat / congMod3
]]
we have the sorting
[[
||    quotient congMod3 : Nat -> Z3
]]
and the function maps, for example, the number 5 to the
equivalence class {2, 5, 8, ...}, which is one of the three
inhabitants of [[Z3]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Choosers"><title>Choosers</title>
<para>
<<
||`chooser ::= choose `closed-expression
>>
Example `chooser:
[[
||    choose congMod3
]]
Restriction.
The `closed-expression of a `chooser must have some sort
<replaceable>S</replaceable> [[*]]
<replaceable>S</replaceable> [[-> Boolean]], and
must be an equivalence relation (see under
<link linkend="Sort-quotients"><emphasis>Sort-quotients</emphasis></link>).
</para>
<!--====================================================================-->
<para>
The sort of a `chooser [[choose]] <replaceable>Q</replaceable>,
where <replaceable>Q</replaceable> has sort
<replaceable>S</replaceable> [[*]] <replaceable>S</replaceable>
[[-> Boolean]], is a function sort of the form
[[(]]<replaceable>S</replaceable> [[->]]
<replaceable>T</replaceable>[[)]] [[->]]
[[(]]<replaceable>S</replaceable> [[/]]
<replaceable>Q</replaceable> [[->]]
<replaceable>T</replaceable>[[)]].
The value of the `chooser is the (in general partial)
function mapping each <replaceable>Q</replaceable>-constant
(explained below) function <replaceable>f</replaceable> inhabiting sort
<replaceable>S</replaceable> [[->]]
<replaceable>T</replaceable> to the function that maps 
each inhabitant <replaceable>C</replaceable> of
<replaceable>S</replaceable> [[/]]
<replaceable>Q</replaceable> to <replaceable>f</replaceable>
<replaceable>x</replaceable>, where
<replaceable>x</replaceable> is any member of
<replaceable>C</replaceable>.
Expressed symbolically, using a pseudo-function [[any]] that
arbitrarily picks any member from a nonempty set, this is
the function
[[
||    fn f -> fn C -> f (any C)
]]
The requirement of <replaceable>Q</replaceable>-constancy
is precisely what is needed to make this function insensitive
to the choice made by [[any]].
</para>
<!--====================================================================-->
<para>
Function <replaceable>f</replaceable> is
<replaceable>Q</replaceable>-constant if,
for each <replaceable>Q</replaceable>-equivalence class
<replaceable>C</replaceable> inhabiting
<replaceable>S</replaceable> [[/]]
<replaceable>Q</replaceable>,
<replaceable>f</replaceable> <replaceable>x</replaceable>
equals <replaceable>f</replaceable>
<replaceable>y</replaceable> for any two values
<replaceable>x</replaceable> and
<replaceable>y</replaceable> that are members of
<replaceable>C</replaceable>,
or <replaceable>f</replaceable> is undefined on all members of
<replaceable>C</replaceable>.
(Since the result of <replaceable>f</replaceable> is
constant across each equivalence class, it does not matter
which of its elements is selected by [[any]].)
For example -- continuing the example of the previous section --
function [[fn n -> n*n rem 3]] is [[congMod3]]-constant;
for the equivalence class {2, 5, 8, ...}, for example, it
maps each member to the same value 1.
So [[choose congMod3 (fn n -> n*n rem 3)]] maps the inhabitant
{2, 5, 8, ...} of sort [[Z3]] to the natural number 1.
</para>
<!--====================================================================-->
<para>
The most discriminating
<replaceable>Q</replaceable>-constant function is
[[quotient]] <replaceable>Q</replaceable>, and
[[choose]] <replaceable>Q</replaceable> [[quotient]]
<replaceable>Q</replaceable> is the identity function on the
quotient sort for <replaceable>Q</replaceable>.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Embedders"><title>Embedders</title>
<para>
<<
||`embedder ::= [ embed ] `constructor
>>
Example `embedders:
[[
||    Nil
||    embed Nil
||    Cons
||    embed Cons
]]
Disambiguation.
If an `expression consists of a single `name, which, in the
context, is both the `name of a `constructor and the `name
of an `op or a `local-variable in scope, then it is
interpreted as the latter of the various possibilities.
For example, in the context of
[[
||    sort Answer = | yes | no
||
||    def yes = no : Answer
||
||    def which (a : Answer) = case a of
||      | yes -> "Yes!"
||      | no  -> "Oh, no!"
]]
the value of [[which yes]] is [["Oh, no!"]], since [[yes]]
here is disambiguated as identifying the `op [[yes]], which
has value [[no]].
The interpretation as `embedder is forced by using
the [[embed]] keyword:
the value of [[which embed yes]] is [["Yes!"]].
By using `names that begin with a capital `letter for
`constructors, and 
`names that do not begin with a capital `letter for
`ops and `local-variables, the risk of an accidental wrong
interpretation can be avoided.
</para>
<!-- ================================================================= -->
<para>
The semantics of `embedders is described in the section on
<link linkend="Sort-sums"><emphasis>Sort-sums</emphasis></link>.
The presence or absence of the keyword [[embed]] is not
significant for the meaning of the construct (although it
may be required for grammatical disambiguation, as described
above).
</para>
</section>
<!-- ***************************************************************** -->
<section id="Embedding-tests"><title>Embedding-tests</title>
<para>
<<
||`embedding-test ::= embed? `constructor
>>
Example `embedding-test:
[[
||    embed? Cons
]]
Restriction.
The sort of an `embedding-test [[embed?]]
<replaceable>C</replaceable> must be of the form
<replaceable>SS</replaceable> [[-> Boolean]], where
<replaceable>SS</replaceable> is a sum sort that has a
`constructor <replaceable>C</replaceable>.
</para>
<!-- ================================================================= -->
<para>
The value of `embedding-test [[embed?]]
<replaceable>C</replaceable> is the predicate that returns
[[true]] if the argument value -- which, as inhabitant of a
sum sort, is tagged -- has tag <replaceable>C</replaceable>,
and otherwise [[false]].
The `embedding-test can be equivalently rewritten as
[[
||    fn
||     | \<replaceable>C\</replaceable> _  ->  true
||     | _    ->  false
]]
where the wildcard [[_]] in the first `branch is omitted when
<replaceable>C</replaceable> is parameter-less.
</para>
<!-- ================================================================= -->
<para>
In plain words, [[embed?]] <replaceable>C</replaceable>
tests whether its sum-sorted argument has been constructed with the
`constructor <replaceable>C</replaceable>.
It is an error when <replaceable>C</replaceable> is not a
constructor of the sum sort.
</para>
</section>
<!-- ***************************************************************** -->
<!-- *****************************************************************
** <section id="Selectors"><title>Selectors</title>
** <para>
** <<
** ||`selector ::= select `constructor
** >>
** </para>
** </section>
********************************************************************** -->
</section>
</section>
<section id="MatchesAndPatterns"><title>Matches and Patterns</title>
<!--  ***************************************************************** -->
<section id="Matches"><title>Matches</title>
<para>
<<
||`match ::= [ '| ] `branch { '| `branch }*
||
||`branch ::= `pattern -> `expression
||
>>
Example `matches:
[[
||    {re = x, im = y} -> {re = x, im = ~y}
||
||      Empty -> true
||    | Push {top = _, pop = rest} -> hasBottom? rest
||
||    | Empty -> true
||    | Push {top = _, pop = rest} -> hasBottom? rest
]]
Restriction.
In a `match, given the environment, there must be a
unique sort <replaceable>S</replaceable> to which the `pattern
of each `branch conforms, and a unique sort
<replaceable>T</replaceable> to which the `expression of each
`branch conforms, and then the `match has sort
<replaceable>S</replaceable> [[->]]
<replaceable>T</replaceable>.
The `pattern of each `branch then has
sort <replaceable>S</replaceable>.
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
If a `branch could belong to several open `matches, it is
interpreted as being a `branch of the textually most recently
introduced `match.
For example,
[[
||   case x of
||     | A -> a
||     | B -> case y of
||              | C -> c
||     | D -> d
]]
is not interpreted as suggested by the indentation, but as
[[
||   case x of
||     | A -> a
||     | B -> (case y of
||               | C -> c
||               | D -> d)
]]
If the other interpretation is intended, the `expression
introducing the inner `match needs to be parenthesized:
[[
||   case x of
||     | A -> a
||     | B -> (case y of
||               | C -> c)
||     | D -> d
]]
</para>
<!-- ================================================================= -->
<para>
Acceptance and return value <replaceable>y</replaceable>, if
any, of a value <replaceable>x</replaceable> for a given `match
are determined as follows.
If each `branch of the `match rejects
<replaceable>x</replaceable> (see below), the whole `match
rejects <replaceable>x</replaceable>, and does not return
a value.
Otherwise, let <replaceable>B</replaceable> stand for the
textually first `branch accepting <replaceable>x</replaceable>.
Then <replaceable>y</replaceable> is the return value of
<replaceable>x</replaceable> for <replaceable>B</replaceable>.
</para>
<!-- ================================================================= -->
<para>
Acceptance and return value <replaceable>y</replaceable>, if
any, of a value <replaceable>x</replaceable> for a `branch
<replaceable>P</replaceable> [[->]]
<replaceable>E</replaceable> in an environment
<replaceable>C</replaceable> are determined as follows.
If `pattern <replaceable>P</replaceable> rejects
<replaceable>x</replaceable>, the `branch rejects
<replaceable>x</replaceable>, and does not return a value.
(For acceptance by a `pattern, see under <link linkend="Patterns"><emphasis>Patterns</emphasis></link>.)
Otherwise, <replaceable>y</replaceable> is the value of
`expression <replaceable>E</replaceable> in the environment
<replaceable>C</replaceable> extended with the acceptance
binding of `pattern <replaceable>P</replaceable> for
<replaceable>x</replaceable>.
</para>
<!-- ================================================================= -->
<para>
For example, in
[[
||   case z of
||     | (x, true)  -> Some x
||     | (_, false) -> None
]]
if [[z]] has value [[(3, true)]], the first branch accepts this
value with acceptance binding [[x = 3]].
The value of [[Some x]] in the extended environment
is then [[Some 3]].
If [[z]] has value [[(3, false)]], the second branch accepts this
value with empty acceptance binding (empty since there are no
<quote>accepting</quote> `local-variables in `pattern
[[(_, false)]]), and the return value is [[None]]
(interpreted in the original environment).
</para>
</section>
<!--  ***************************************************************** -->
<section id="Patterns"><title>Patterns</title>
<para>
<<
||`pattern ::=
||      `annotated-pattern
||    | `tight-pattern
||
||`tight-pattern ::=
||      `aliased-pattern
||    | `cons-pattern
||    | `embed-pattern
||    | `quotient-pattern
||    | `relax-pattern
||    | `closed-pattern
||
||`closed-pattern ::=
||      `variable-pattern
||    | `wildcard-pattern
||    | `literal-pattern
||    | `list-pattern
||    | `tuple-pattern
||    | `record-pattern
||    | ( `pattern )
>>
(As for `expressions, the distinctions `tight- and `closed- for
`patterns have no semantic significance, but merely serve to
avoid grammatical ambiguities.)
<<
||
||`annotated-pattern ::= `pattern : `sort
||
||`aliased-pattern ::= `variable-pattern as `tight-pattern
||
||`cons-pattern ::= `closed-pattern :: `tight-pattern
||
||`embed-pattern ::= `constructor `closed-pattern
||
||`quotient-pattern ::= quotient `closed-expression `tight-pattern
||
||`relax-pattern ::= relax `closed-expression `tight-pattern
||
||`variable-pattern ::= `local-variable
||
||`wildcard-pattern ::= _
||
||`literal-pattern ::= `literal
||
||`list-pattern ::= '[ `list-pattern-body ']
||
||`list-pattern-body ::= [ `pattern { , `pattern }* ]
||
||`tuple-pattern ::= ( `tuple-pattern-body )
||
||`tuple-pattern-body ::= [ `pattern , `pattern { , `pattern }* ]
||
||`record-pattern ::= '{ `record-pattern-body '}
||
||`record-pattern-body ::= [ `field-patterner { , `field-patterner }* ]
||
||`field-patterner ::= `field-name [ `equals `pattern ]
>>
Example `patterns:
[[
||    (i, p) : Integer * Boolean
||    z as {re = x, im = y}
||    hd :: tail
||    Push {top, pop = rest}
||    embed Empty
||    quotient congMod3 n
||    relax even e
||    x
||    _
||    #z
||    [0, x]
||    (c1 as (0, _), x)
||    {top, pop = rest}
]]
Restriction.
Like all polymorphic or sort-ambiguous constructs, a `pattern
may only be used in a context where its sort can be uniquely
inferred.
</para>
<!--====================================================================-->
<para>
Restriction.
Each `local-variable in a `pattern must be a different
`name, disregarding any `local-variables introduced in
`expressions or `sorts contained in the `pattern.
(For example, [[Line (z, z)]] is not a lawful `pattern,
since [[z]] is repeated; but [[n : {n : Nat | n < p}]]
is lawful: the second [[n]] is <quote>shielded</quote> by
the `sort-comprehension in which it occurs.)
</para>
<!--  ================================================================= -->
<para>
Restriction.
The `closed-expression of a `quotient-pattern must have some sort
<replaceable>S</replaceable> [[*]]
<replaceable>S</replaceable> [[-> Boolean]];
in addition, it must be an equivalence relation, as explained
under <link
linkend="Sort-quotients"><emphasis>Sort-quotients</emphasis></link>.
</para>
<!--  ================================================================= -->
<para>
Restriction.
The `closed-expression of a `relax-pattern must have some function
sort <replaceable>S</replaceable> [[-> Boolean]].
</para>
<!--  ================================================================= -->
<para>
To define acceptance and acceptance binding (if any)
for a value and a `pattern, we introduce a number of
auxiliary definitions.
</para>
<!--  ================================================================= -->
<para>
The <emphasis>accepting</emphasis> `local-variables of a `pattern
<replaceable>P</replaceable> are
the collection of `local-variables occurring in
<replaceable>P</replaceable>,
disregarding any `local-variables introduced in
`expressions or `sorts contained in the
<replaceable>P</replaceable>.
For example, in `pattern [[u : {v : S | p v}]], [[u]] is an
accepting `local-variable, but [[v]] is not.  (The latter is an
accepting `local-variable of `pattern [[v : S]], but not of the
larger `pattern.)
</para>
<!--  ================================================================= -->
<para>
The <emphasis>expressive descendants</emphasis> of a
`pattern are a finite set of `expressions having the
syntactic form of `patterns, as determined in the
following three steps (of which the order of steps 1 and 2
is actually immaterial).
</para>
<!--  ================================================================= -->
<para>
Step 1.  From `pattern <replaceable>P</replaceable>, form some
<emphasis>tame variant</emphasis>
<replaceable>P<subscript>t</subscript></replaceable> by
first replacing each `field-patterner consisting of a single
`field-name <replaceable>F</replaceable> by the
`field-patterner <replaceable>F</replaceable> [[=]] [[_]], and
next
replacing each `wildcard-pattern [[_]] in
<replaceable>P</replaceable>, thus modified, by a
unique fresh `name, that
is, any `name that does not already occur in the
`spec, directly or indirectly through an import.
For example, assuming that the `names [[v7944]] and [[v7945]]
are fresh, a tame variant of
[[
||    s0 as _ :: s1 as (Push {top, pop = rest}) :: ss
]]
is
[[
||    s0 as v7944 :: s1 as (Push {top = v7945, pop = rest}) :: ss
]]
</para>
<!--  ================================================================= -->
<para>
Step 2.  Next, from
<replaceable>P<subscript>t</subscript></replaceable>, form a
(tamed) <emphasis>construed version</emphasis>
<replaceable>P<subscript>tc</subscript></replaceable> by
replacing each constituent `cons-pattern
<replaceable>H</replaceable> [[::]] <replaceable>T</replaceable>
by the `embed-pattern [[Cons
(]]<replaceable>H</replaceable>[[,]]
<replaceable>T</replaceable>[[)]], where [[Cons]] denotes the
`constructor of the parameterized sort [[List]].
For the example, the construed version is:
[[
||    s0 as Cons (v7944,
||                s1 as Cons (Push {top = v7945, pop = rest}, ss))
]]
</para>
<!--  ================================================================= -->
<para>
Step 3.  Finally, from
<replaceable>P<subscript>tc</subscript></replaceable>, form
the set <replaceable>ED<subscript>P</subscript></replaceable> of
<emphasis>expressive descendants</emphasis> of
<replaceable>P</replaceable>, where
`expression <replaceable>E</replaceable> is an
expressive descendant
if <replaceable>E</replaceable>
can be obtained by repeatedly replacing some constituent
`aliased-pattern <replaceable>L</replaceable> [[as]]
<replaceable>R</replaceable>
of <replaceable>P<subscript>tc</subscript></replaceable>
by one of the two `patterns
<replaceable>L</replaceable> and
<replaceable>R</replaceable> until no `aliased-patterns
remain, and then interpreting the result as an `expression.
For the example, the expressive descendants
are the three `expressions:
[[
||    s0
||    Cons (v7944, s1)
||    Cons (v7944, Cons (Push {top = v7945, pop = rest}, ss))
]]
</para>
<!--  ================================================================= -->
<para>
An <emphasis>accepting binding</emphasis> of a `pattern
<replaceable>P</replaceable> for a value
<replaceable>x</replaceable> in an environment
<replaceable>C</replaceable> is some
binding <replaceable>B</replaceable> of sorted
values to the accepting `local-variables of the
<emphasis>tame</emphasis> variant
<replaceable>P<subscript>t</subscript></replaceable>,
such that the value of each expressive descendant
<replaceable>E</replaceable> in
<replaceable>ED<subscript>P</subscript></replaceable>
in the environment
<replaceable>C</replaceable> extended with binding
<replaceable>B</replaceable>, is the same sorted value as
<replaceable>x</replaceable>.
</para>
<!--  ================================================================= -->
<para>
Acceptance and acceptance binding, if any,
for a value <replaceable>x</replaceable> and a `pattern
<replaceable>P</replaceable>
are then determined as follows.
If there is no accepting binding of
<replaceable>P</replaceable> for
<replaceable>x</replaceable>,
<replaceable>x</replaceable> is rejected.
If an accepting binding exists, the value
<replaceable>x</replaceable> is accepted by `pattern
<replaceable>P</replaceable>.
There is a unique binding
<replaceable>B</replaceable> among the accepting bindings in
which the sort of each assigned value is as
<quote>restricted</quote> as possible in the subsort-supersort
hierarchy without violating well-sortedness constraints (in
other words, there are no avoidable implicit relaxations).
The acceptance binding is then the binding
<replaceable>B</replaceable> <emphasis>projected
on</emphasis> the accepting `local-variables of
<replaceable>P</replaceable>.
</para>
<!--  ================================================================= -->
<para>
For the example, the accepting `local-variables of
<replaceable>P<subscript>t</subscript></replaceable> are the
six `local-variables [[s0]], [[s1]], [[ss]], [[rest]], [[v7944]] and
[[v7945]].
In general, they are the accepting `local-variables of the
original `pattern together with any fresh `names used for
taming.
Let the value <replaceable>x</replaceable> being matched
against the pattern be
[[
||    Cons (Empty, Cons (Push {top = 200, pop = Empty}, Nil))
]]
Under the accepting binding
[[
||    s0 = Cons (Empty, Cons (Push {top = 200, pop = Empty}, Nil))
||    s1 = Cons (Push {top = 200, pop = Empty}, Nil)
||    ss = Nil
||    rest = Empty
||    v7944 = Empty
||    v7945 = 200
]]
the value of each <replaceable>E</replaceable> in
<replaceable>ED<subscript>P</subscript></replaceable>
amounts to the value <replaceable>x</replaceable>.
Therefore, <replaceable>x</replaceable> is accepted by the
original `pattern, with acceptance binding
[[
||    s0 = Cons (Empty, Cons (Push {top = 200, pop = Empty}, Nil))
||    s1 = Cons (Push {top = 200, pop = Empty}, Nil)
||    ss = Nil
||    rest = Empty
]]
obtained by <quote>forgetting</quote> the fresh `names
[[v7944]] and [[v7945]].
</para>
</section>
</section>
<!-- *****************************************************************

TODO:

More sort-correctness restrictions.
Unification, monomorphicity restriction.
Unspecified op sorts.

Constructive

Test constructs used

At Semantics: transformational semantics.

Relationship choose & quotient?

Relax not needed.

**********************************************************************

Wishes for further syntax changes:

<< `formal-application-head +::= ( `formal-application ) >>

Allow [[op]] for [[def]].

Allow [[def sort]] and [[def op]].

Allow [[sort fa]] for all `sort-variable-binders.

(Maybe) Allow [[sort op]] for infix parameterized sorts.

Allow
[[
||    def o : fa(a,b,c) (b -> c) * (a -> b) -> a -> c =
||      fn (f, g) -> fn (x) -> f(g x)
]]
or
[[
||    op fa(a,b,c) o : (b -> c) * (a -> b) -> a -> c
]]
or both

********************************************************************** -->
</chapter>
