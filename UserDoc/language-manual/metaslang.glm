<chapter id="metaslang"><title>&Metaslang;</title>
<!-- ***************************************************************** -->
<para>
This chapter introduces the &Metaslang; specification language.
</para>
<!-- ================================================================= -->
<para>
The following sections give the grammar rules and meaning
for each &Metaslang; language construct.
</para>
<!-- ================================================================= -->
<section id="Preliminaries"><title>Preliminaries</title>
<!-- ================================================================= -->
<section id="GrammarDescriptionFormalism"><title>The Grammar Description Formalism</title>
<para>
The grammar rules used to describe the &Metaslang; language
use the conventions of (extended) BNF.
For example, a grammar rule like:
<<
||    `wiffle ::= `waffle [ `waffle-tail ] | `piffle { + `piffle }*
>>
defines a `wiffle to be: either a `waffle optionally
followed by a `waffle-tail, or a sequence of one or more
`piffles separated by terminal symbols [[+]] .
(Further rules would be needed for `waffle, `waffle-tail and
`piffle.)
In a grammar rule the left-hand side of <<::=>> shows the kind
of construct being defined, and the right-hand side shows
how it is defined in terms of other constructs.
The sign <<|>> separates alternatives, the
square brackets <<[>> ... <<]>> enclose optional parts, and
the curly braces plus asterisk <<{>> ... <<}*>> enclose a part
that may be repeated any number of times, including zero
times.
All other signs stand for themselves, like the symbol [[+]]
in the example rule above.
</para>
<!-- ================================================================= -->
<para>
In the grammar rules terminal symbols appear in a bold font.
Some of the terminal symbols used, like [[|]] and [[{]], are
very similar to the grammar signs like <<|>> and <<{>> as
described above.
They can hopefully be distinguished by their bold appearance.
</para>
<!-- ================================================================= -->
<para>
Grammar rules may be <emphasis>recursive</emphasis>: a
construct may be defined in terms of itself, directly or
indirectly.
For example, given the rule:
<<
||    `piffle ::= 1 | M { `piffle }*
>>
here are some possible `piffles:
[[
||      1       M       M1      M111    MMMM    M1M1
]]
Note that the last two examples of `piffles are ambiguous.
For example, [[M1M1]] can be interpreted as:
[[M]] followed by the two `piffles [[1]] and [[M1]],
but also as:
[[M]] followed by the three `piffles [[1]], [[M]], and another
[[1]].
Some of the actual grammar rules allow ambiguities; the
accompanying text will indicate how they are to be resolved.
</para>
</section>
<!-- ================================================================= -->
<section id="Models"><title>Models</title>
<para>
<<
||`op ::= `op-name
>>
In &Metaslang;, <emphasis>`op</emphasis> is used
used as an abbreviation for
<quote>`op-name</quote>, where `op-names
are declared `names representing values.
(<emphasis>Op</emphasis> for <emphasis>operator</emphasis>, a
term used for historical reasons, although including
things normally not considered operators.)
</para>
<para>
<<
||`spec ::= `spec-form
>>
The term `spec is used as short for `spec-form.
The <emphasis>semantics</emphasis> of &Metaslang; `specs is given
in terms of classes of <emphasis>models</emphasis>.
A model is an assignment of sets of values (called
``types'') to all the
`type-names and of ``typed'' values to all the `ops
declared -- explicitly or implicitly -- in the `spec.
The notion of <emphasis>value</emphasis> includes
numbers, strings, arrays, functions, etcetera.
A typed value can be thought of as a pair ($T$, $V$),
in which $T$ is a type and $V$ is a value that is an
inhabitant of $T$.
For example, the `expressions [[0 : Nat]] and [[0 : Integer]]
correspond, semantically, to the typed values
($N$, 0) and
($Z$, 0), respectively,
in which
$N$ stands for the set of
natural numbers {0, 1, 2, ...}, and 
$Z$ for the set of
integers {..., -2, -1, 0, 1, 2, ...}.
For example, given this `spec:
[[
||    spec
||      type Even
||      op next : Even -> Even
||      axiom nextEffect is
||        fa(x : Even) ~(next x = x)
||    endspec
]]
one possible model (out of many!) is the assignment of
the even integers to [[Even]], and of the function that
increments an even number by 2 to [[next]].
</para>
<!-- ================================================================= -->
<para>
Each model has to <emphasis>respect typing</emphasis>; for
example, given the above assignment to [[Even]], the function
that increments a number by 1 does not map all even numbers
to even numbers, and therefore can not -- in the same model
-- be assigned to [[next]].
Additionally, the `claims (axioms, theorems and conjectures)
of the `spec have to be satisfied in the model.
The axiom labeled [[nextEffect]] above states that
the function assigned to `op [[next]]
maps any value of the type assigned to `type-name [[Even]]
to a different value.
So the squaring function, although type-respecting, could not
be assigned to [[next]] since it maps 0 to itself.
</para>
<!-- ================================================================= -->
<para>
If all type-respecting combinations of assignments of types to
`type-names and values to `ops fail the one or more `claims, the
`spec has no models and is called
<emphasis>inconsistent</emphasis>.
Although usually undesirable, an inconsistent `spec is not by
itself considered ill formed.
The &Specware; system does not attempt to detect
inconsistencies, but associated provers can sometimes be
used to find them.
Not always; in general it is undecidable whether a
`spec is consistent or not.
</para>
<!-- ================================================================= -->
<para>
In general, the meaning of a construct in a model depends on
the assignments of that model, and more generally on an
<emphasis>environment</emphasis>: a model possibly extended
with assignments to `local-variables.
For example, the meaning of the `claim
[[fa(x : Even) ~(next x = x)]] in axiom [[nextEffect]]
depends on the meanings of [[Even]] and [[next]],
while the sub-expression [[next x]], for example, also depends on
an assignment (of an <quote>even</quote> value) to [[x]].
To avoid laborious phrasings, the semantic descriptions use
language like <quote>the function [[next]] applied to
[[x]]</quote> as shorthand for this lengthy phrase:
<quote>the function assigned in the environment to [[next]] applied
to the value assigned in the environment to [[x]]</quote>.
</para>
<!-- ================================================================= -->
<para>
When an environment is extended with an assignment to a
`local-variable, any assignments to synonymous
`ops or other `local-variables are superseded by the
new assignment in the new environment.
In terms of &Metaslang; text, within the scope of the binding of
`local-variables, synonymous `ops and earlier introduced
`local-variables (that is, having the same `simple-name) are
<quote>hidden</quote>; any use of the `simple-name in that scope
refers to the textually most recently introduced
`local-variable.
For example, given:
[[
||    def x = "op-x"
||    def y = let v = "let-v" in x
||    def z = let x = "let-x" in x
]]
the value of [[y]] is [["op-x"]] (`op [[x]] is not hidden by the
`local-variable [[v]] of the `let-binding), whereas
the value of [[z]] is [["let-x"]] (`op [[x]]
<emphasis>is</emphasis> hidden by the
`local-variable [[x]] of the `let-binding).
</para>
</section>
<!-- ================================================================= -->
<section id="Type-correctness"><title>Type-correctness</title>
<para>
Next to the general requirement that each model respects
typing, there are specific restrictions for
various constructs that constrain the possible types for the
components. For example, in an `application [[f(x)]], the
type of the `actual-parameter [[x]] has to match the domain
type of function [[f]].
These requirements are stated in the relevant sections of
this language manual.
If no type-respecting combinations of assignments meeting all
these requirements exist for a given `spec, it is considered
<emphasis>type-incorrect</emphasis> and therefore
<emphasis>ill formed</emphasis>.
This is determined by &Specware; while elaborating the `spec,
and signaled as an error.
Type-incorrectness differs from inconsistency in that the
meaning of the `claims does not come into play, and the
question whether an ill-formed `spec is consistent is moot.
</para>
<!-- ================================================================= -->
<para>
To be precise, there are subtle and less subtle differences
between type-incorrectness of a `spec and its having no 
type-respecting combinations of assignments.
For example, the following `spec is type-correct but has no
models:
[[
||    spec
||      type Empty = | Just Empty
||      op IdoNotExist : Empty
||    endspec
]]
The explanation is that the `type-definition for [[Empty]]
generates an <emphasis>implicit</emphasis> axiom that all
inhabitants of the type [[Empty]] must satisfy, and for this
recursive definition the axiom effectively states that such
creatures can't exist: the type [[Empty]] is uninhabited.
That by itself is no problem, but precludes a type-respecting
assignment of an inhabitant of [[Empty]] to `op [[IdoNotExist]].
So the `spec, while type-correct, is actually inconsistent.
See further under <link linkend="Type-definitions"><emphasis>Type-definitions</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
Here is a type-incorrect `spec that has type-respecting
combinations of assignments:
[[
||    spec
||      type Outcome = | Positive | Negative
||      type Sign = | Positive | Zero | Negative
||      def whatAmI = Positive
||    endspec
]]
Here there are two constructors [[Positive]]
of different types, the type [[Outcome]] and the type
[[Sign]].
That by itself is fine, but when such
<quote>overloaded</quote> constructors are used,
the context must give sufficient information which is meant.
Here, the use of [[Positive]] in the `definition for `op
[[whatAmI]] leaves both possibilities open; as used it is
<emphasis>type-ambiguous</emphasis>.
&Metaslang; allows omitting type information provided that, given
a type assignment to all `local-type-variables in scope, unique
types for all typed constructs, such as `expressions and
`patterns, can be inferred from the context.
If no complete and unambiguous type-assignment can be made,
the `spec is not accepted by the &Specware; system.
Type-ambiguous `expressions can be disambiguated by using a
type annotation, as described under <link
linkend="Annotated-expressions"><emphasis>Annotated-expressions</emphasis></link>.
In the example, the `definition of [[whatAmI]] can be disambiguated in either
of the following ways:
[[
||      def whatAmI : Sign = Positive
||      def whatAmI = Positive : Sign
]]
Also, if the `spec elsewhere contains something along the lines of:
[[
||      op signToNat : Sign -> Nat
||      def sw = signToNat whatAmI
]]
that is sufficient to establish that [[whatAmI]] has type [[Sign]]
and thereby disambiguate the use of [[Positive]].
See further under
<link linkend="Op-definitions"><emphasis>Op-definitions</emphasis></link>
and <link linkend="Structors"><emphasis>Structors</emphasis></link>.
</para>
</section>
<!-- ================================================================= -->
<section id="Constructive"><title>Constructive</title>
<para>
When code is generated for a `spec, complete
<quote>self-contained</quote> code is only
generated for `type-definitions and `op-definitions that are
fully <emphasis>constructive</emphasis>.
Non-constructiveness is <quote>contagious</quote>:
a `definition is only constructive if all components of the
definition are.
The type of a `type-name without `definition is not
constructive.
A type is only constructive if all component types are.
An `op without `definition is non-constructive, and so
is an `op whose type is non-constructive.
A `quantification is non-constructive.
The polymorphic `inbuilt-op [[=]] for testing equality and its inequality
counterpart [[~=]] are only
constructive for <emphasis>discrete types</emphasis> (see
below).
</para>
<!-- ================================================================= -->
<para>
A type is called discrete if the equality predicate [[=]]
for that type is constructive.
The inbuilt and base-library types [[Boolean]], [[Integer]], [[NonZeroInteger]], [[Nat]], [[PosNat]],
[[Char]], [[String]] and [[Compare]] are all discrete.
Types [[List $T$]] and [[Option $T$]] are discrete when
$T$ is.
All function types are non-discrete (even when the domain
type is the unit type).
Sum types, product types and record types are discrete
whenever all component types are.
Subtype
[[($T$ | $P$)]] is discrete when
supertype $T$ is.
(Predicate $P$ need not be
constructive: the equality test is that of the supertype.)
Quotient type
[[$T$ / $Q$]] is discrete when
predicate $Q$ is
constructive.
(Type $T$ need not be discrete:
the equality test on the quotient type is just the predicate
$Q$ applied to pairs of members of the
$Q$-equivalence classes.)
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="LexicalConventions"><title>Lexical conventions</title>
<para>
A &Metaslang; text consists of a sequence of
`symbols, possibly interspersed with whitespace.
The term <emphasis>whitespace</emphasis> refers to any
non-empty sequence of spaces, tabs, newlines, and `comments
(described below).
A `symbol is presented in the text as a sequence of one or
more <quote>marks</quote> (ASCII characters).
Within a composite (multi-mark) `symbol, no whitespace is
allowed, but whitespace may be needed between two `symbols if
together they could be taken for one `symbol; in particular,
two `simple-names that follow each other should be separated by
whitespace.
<!-- OBSOLETE
More precisely, whitespace is required between two `symbols
unless at least one of the two is a `special-symbol (see
below for the various classes of `symbols).
Additionally, whitespace is required in two other
situations.
The first is after the
`special-symbol [[(]] when immediately followed by a
`non-word-symbol that starts with a `non-word-mark [[*]].
Without such whitespace, [[(*]] introduces a `block-comment.
The second is before or after the `special-symbol [[_]] (the
presentation of a `wildcard-pattern) when immediately followed
or preceded by a `simple-name or another [[_]].
ETELOSBO -->
More precisely, whitespace is required between two adjacent
`symbols for each of the following combinations, in which
<quote>[[abc]]</quote> stands for an arbitrary `word-symbol,
<quote>[[<*>]]</quote> stands for an arbitrary `non-word-symbol,
<quote>[[?:!]]</quote> stands for an arbitrary `non-word-symbol
starting with a [[?]]-mark, and
<quote>[[123]]</quote> stands for an arbitrary `literal
(see below for the definitions of the various classes of
`symbols):
[[
||    abc  abc
||    abc  ?:!
||    abc  123
||    <*>  <*>
||    123  abc
||    123  123
||    abc  _
||      (  *
]]
Apart from the last two cases, no whitespace is ever
needed adjacent to a `special-symbol.
</para>
<!-- ================================================================= -->
<para>
Inside `literals (constant-denotations) whitespace is also
disallowed, except for <quote>`significant-whitespace</quote>
as described under
<link linkend="String-literals"><emphasis>String-literals</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
Other than that, whitespace -- or the lack of it -- has no significance.
Whitespace can be used to lay-out the text for readability, but
as far as only the meaning is concerned, the following two
presentations of the same `spec are entirely equivalent:
[[
||    spec
||      type Even
||      op next : Even -> Even
||      axiom nextEffect is
||        fa(x : Even) ~(next x = x)
||    endspec
||
||    spec type   Even op   next : Even -> Even axiom nextEffect
||    is fa(x : Even)~(next     x            = x)endspec
]]
</para>
<!-- ***************************************************************** -->
<section id="Symbols"><title>Symbols and Names</title>
<para>
<<
||`symbol ::= `simple-name | `literal | `special-symbol
||
||`simple-name ::= `word-symbol | `non-word-symbol
||
||`word-symbol ::= `word-start-mark { `word-continue-mark }*
||
||`word-start-mark ::= `letter
||
||`word-continue-mark ::=
||    `letter | `decimal-digit | _ | ?
||
||`letter ::=
||      A | B | C | D | E | F | G | H | I | J | K | L | M
||    | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
||    | a | b | c | d | e | f | g | h | i | j | k | l | m
||    | n | o | p | q | r | s | t | u | v | w | x | y | z
||
||`decimal-digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
||
||`non-word-symbol ::= `non-word-mark { `non-word-mark }*
||
||`non-word-mark ::=
||      ` | ~ | ! | @ | $ | ^ | & | * | -
||    | = | + | \ | '| | : | < | > | / | ?
||
||`special-symbol ::= _ | ( | ) | '[ | '] | '{ | '} | ; | , | .
>>
Sample `simple-names:
[[
||    Date                    $$$$          ?!
||    yymmdd2date             <*>           :=:
||    well_ordered?           ~==           
]]
For convenience, here are the 14 printing ASCII marks that,
next to `letters and `decimal-digits,
can <emphasis>not</emphasis> occur in a `non-word-symbol:
[[
||      #    %    '    "    _    (    )
||      [    ]    {    }    ;    ,    .
]]
Restriction.
As mentioned before, no whitespace is allowed in `symbols:
while [[anode]] is a single `simple-name, both [[a node]] and
[[an ode]] consist of two `simple-names.
Further, the case (lower or upper) of `letters in `simple-names is
significant: [[grandparent]], [[grandParent]] and
[[grandpaRent]] are three different `simple-names.
</para>
<!-- ================================================================= -->
<para>
Restriction.
In general, `simple-names can be chosen freely.
However, the following <emphasis>reserved symbols</emphasis> have a
special meaning and must not be used for `simple-names:
<!-- !! echo RESWORDS | abc -w meta -->
[[
||    as              endspec       infixr           relax
||    axiom           ex            is               restrict
||    case            fa            let              spec
||    choose          false         morphism         then
||    colimit         fn            obligations      theorem
||    conjecture      from          of               translate
||    def             generate      op               true
||    diagram         if            project          type
||    else            import        prove            where
||    embed           in            qualifying
||    embed?          infixl        quotient
||
||    :         ::        |         =>        ||       &&
||    <-        ->        +->       =         ~=       <<
]]
They each count as a single `symbol, and no whitespace is
allowed inside any reserved symbol.
</para>
<!-- ================================================================= -->
<para>
`Non-word-symbols can be used to choose convenient `simple-names
for `operators that, conventionally, are written with
non-alphabetic marks.
</para>
<!-- ================================================================= -->
<para>
Some &Metaslang; users follow the convention of using
`simple-names that start with a capital letter for
`unit-identifiers and `type-names and for `constructors,
while `word-symbols chosen for `ops and `field-names start with a
lower-case `letter.
Both plain `local-variables and `local-type-variables are often chosen
to be single lower-case `letters: [[x]], [[y]], [[z]],
[[a]], [[b]], [[c]], with the start of the alphabet
preferred for `local-type-variables.
`Op-names of predicates (that is, having some type
[[$T$ -> Boolean]]) often end with
the mark [[?]].
These are just conventions that users are free to follow or
ignore, but in particular some convention distinguishing 
`constructors from `ops and `local-variables is
recommended.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Comments"><title>Comments</title>
<para>
<<
||`comment ::= `line-end-comment | `block-comment
||
||`line-end-comment ::= % `line-end-comment-body
||
||`line-end-comment-body ::=
||    `any-text-up-to-end-of-line
||
||`block-comment ::= (* `block-comment-body *)
||
||`block-comment-body ::=
||    `any-text-including-newlines-and-nested-block-comments
>>
Sample `comments:
[[
||    % keys must be unique
||    (* op yymmdd2Date : String -> Date *)
]]
&Metaslang; allows two styles of `comments.
The [[%]]-style is light-weight, for adding comment
on a line <emphasis>after</emphasis> the formal text (or
taking a line on its own, but always confined to
a single line).
The [[(*]]...[[*)]]-style can be used for blocks of text,
spanning several lines, or stay within a line.
Any text remaining on the line after the closing [[*)]] is
processed as formal text.
`Block-comments may be nested, so the pairs of brackets
[[(*]] and [[*)]] must be balanced.
</para>
<para>
A `block-comment can not contain a `line-end-comment and
vice versa: whichever starts first has <quote>the right of
way</quote>.
For example, [[(* 100 % or more! *)]] is a `block-comment
with `block-comment-body 
[[ 100 % or more! ]].
The [[%]] here is a mark like any
other; it does not introduce a `line-end-comment.
Conversely, in the `line-end-comment [[% op <*> stands for (*)]]
the [[(*]] is part of the `line-end-comment-body; it does
not introduce a `block-comment.
Note also that [[%]] and [[(*]] have no special significance
in `literals (which must not contain whitespace, including
`comments): [["100 % or more!"]] is a well-formed
`string-literal.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Units"><title>Units</title>
<para>
A ``unit'' is an identifiable `unit-term, where
``identifiable'' means that the `unit-term can be referred
to by a `unit-identifier.
`Unit-terms can be ``elaborated'', resulting in `specs,
morphisms, diagrams or other entities.
The effect of elaborating a `unit-definition is that its
`unit-term is elaborated and becomes associated with its
`unit-identifier.
</para>
<para>
For the elaboration of a `unit-term to be meaningful, it has to be well
formed and result in a well-formed -- and therefore type-correct -- entity.
Well-formedness is a stricter requirement than type-correctness.
If a `unit-term or one of its constituent parts does not meet any of the
restrictions stated in this language manual, it is ill formed.
This holds throughout, also if it is not mentioned explicitly for some
syntactic construct.
Well-formedness is more than a syntactic property; in general, to
establish well-formedness it may be necessary to ``discharge''
(prove) proof obligations engendered by the `unit-term.
</para>
<para>
A &Specware; project consists of a collection of
&Metaslang; `unit-definitions.
They can be recorded in one or more 
&Specware; files.
There are basically two styles for recording
`unit-definitions using &Specware; files.
In the single-unit style, the file, when processed by
&Specware;, contributes a single
`unit-definition to the project.
In the multiple-unit style, the file may contribute several
`unit-definitions.
The two styles may be freely mixed in a project (but not in
the same &Specware; file).
This is explained in more detail in what follows.
</para>
<para>
<<
||`unit-definition ::= `unit-identifier = `unit-term
||
||`unit-term ::=
||     `spec-term
||   | `morphism-term
||   | `diagram-term
||   | `target-code-term
||   | `proof-term
||
||`specware-file-contents ::=
||     `unit-term
||   | `infile-unit-definition { `infile-unit-definition }*
||
||`infile-unit-definition ::= `fragment-identifier = `unit-term
||
||`fragment-identifier ::= `word-symbol
>>
<!--
** ||     | `let-term
** ||     | `where-term
-->
</para>
<para>
`Unit-definitions may use other
`unit-definitions, including standard
libraries, which in &SpecwareV; are supposed to be part of
each project.
However, the dependencies between units must not form a
cycle; it must always be possible to arrange the
`unit-definitions in an order in which later
`unit-definitions only depend on earlier ones.
How `unit-definitions are processed by &Specware; is further
dealt with in the &Specware; User Manual.
</para>
<para>
As mentioned above,
`unit-definitions are collected in &Specware; files, which in
&SpecwareV; must have an [[.sw]] extension.
The &Specware; files do not directly contain the
`unit-definitions that form the project.
In fact, a user never writes `unit-definition explicitly.
These are instead determined from the contents of the
&Specware; files using the following rules.
There are two possibilities here.
The first is that the `specware-file-contents consists of a
single `unit-term.
If
<"$P$.sw"> is
the path for the &Specware; file, the unit
being defined has as its `unit-identifier
$P$.
For example, if file <"C:/units/Layout/Fixture.sw"> contains a
single `unit-term $U$, the `unit-identifier is
[[/units/Layout/Fixture]], and the `unit-definition it
contributes to the project is
[[
||  /units/Layout/Fixture = $U$
]]
(Note that this is not allowed as an `infile-unit-definition in a
`specware-file-contents, since the `unit-identifier is not a
`fragment-identifier.)
</para>
<para>
The second possibility is that the &Specware; file contains one or more
`infile-unit-definitions.
If $I$ is the `fragment-identifier
of such an `infile-unit-definition, and
<"$P$.sw"> is the path for the
&Specware; file, the unit
being defined has as its `unit-identifier
$P$#$I$.
For example, if file <"C:/units/Layout/Cart.sw"> contains an
`infile-unit-definition [[Pos = $U$]],
the `unit-identifier is [[/units/Layout/Cart#Pos]],
and the `unit-definition it contributes to the project is
[[
||  /units/Layout/Cart#Pos = $U$
]]
</para>
<!-- ***************************************************************** -->
<section><title>Unit Identifiers</title>
<para>
<<
||`unit-identifier ::= `swpath-based-path | `relative-path
||
||`swpath-based-path ::= / `relative-path
||
||`relative-path ::= { `path-element / }* `path-element [ # `fragment-identifier ]
||
||`path-element ::= `word-symbol
>>
</para>
<formalpara id="Warning0"><title>Warning</title> <para>
Note that `unit-identifiers are processed by the tokenizer like
everything else. This means that whitespace is removed and
marks not allowed in `word-symbols, even if otherwise permitted in
filenames (such as <".">), cannot appear in `unit-identifiers.
For this reason, some care must be taken when naming units.
</para> </formalpara>
<para>
`Unit-identifiers are used to identify `unit-terms.
Typically, only a final part of the full `unit-identifier is
used.  When &Specware is started with environment variable
<"SWPATH"> set to a semicolon-separated list of pathnames for
directories, the &Specware; files are searched for
relative to these pathnames; for example, if <"SWPATH"> is set
to <"C:/units/Layout;C:/units/Layout/Cart">, then
<"C:/units/Layout/Fixture.sw"> may be shortened to [[/Fixture]],
and <"C:/units/Layout/Cart.sw"> to [[/Cart]].
How `unit-definitions are processed by &Specware; is further
dealt with in the &Specware; User Manual.
</para>
<para>
Further, `unit-identifiers can be relative to the directory
containing the &Specware; file in which they occur.
So, for example, both in file <"C:/units/Layout/Fixture.sw">
and in file <"C:/units/Layout/Cart.sw">, `unit-identifier
[[Tools/Pivot]] refers to the `unit-term contained in
file <"C:/units/Layout/Tools/Pivot.sw">,
while [[Props#SDF]] refers to the `unit-term of
`infile-unit-definition [[SDF = ...]] contained
in file  <"C:/units/Layout/Props.sw">.
As a special case, a `unit-term with the same `name as the file may be
referenced without a `fragment-identifier. For example, in the current
case, if the file  <"C:/units/Layout/Props.sw"> contains the  `unit-term of
`infile-unit-definition [[Props = ...]], then this `unit-term can be referred to
either by [[Props#Props]] or [[Props]].
</para>
<para>
The `unit-identifier must identify a `unit-definition as
described above; the elaboration of the `unit-identifier is
then the result of elaborating the corresponding `unit-term,
yielding a `spec, morphism, diagram, or other entity.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Specs</title>
<para>
<<
||`spec-term ::=
||     `unit-identifier
||   | `spec-form
||   | `spec-qualification
||   | `spec-translation
||   | `spec-substitution
||   | `diagram-colimit
||   | `obligator
||
>>
<!--
||     | `spec-visibility
-->
Restriction.
When used as a `spec-term, the elaboration of a
`unit-identifier must yield a `spec.
</para>
<para>
The elaboration of a `spec-term, if defined, yields an
``expanded'' `spec-form as defined in the next subsection.
</para>
<!-- ***************************************************************** -->
<section><title>Spec Forms</title>
<para>
<<
||`spec-form ::= spec { `declaration }* endspec
>>
</para>
<para>
Sample `spec-forms:
[[
||    spec import Measures import Valuta endspec
]]
</para>
<!-- ================================================================= -->
<para>
An <emphasis>expanded</emphasis> `spec-form is a `spec-form
containing no `import-declarations.
</para>
<para>
The elaboration of a `spec-form yields the &Metaslang; text which is that
`spec itself, after expanding any `import-declarations.
The <emphasis>meaning</emphasis> of that text is the class
of models of the `spec, as described throughout this
Chapter.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Qualifications</title>
<!--====================================================================-->
<para>
`Names of types and `ops may be <emphasis>simple</emphasis>
or <emphasis>qualified</emphasis>.
The difference is that `simple-names are ``unqualified'': they
do not contain a
dot sign ``[[.]]'', while `qualified-names are prefixed with
a ```qualifier'' followed by a dot.  Examples of
`simple-names are [[Date]], [[today]] and [[<*>]].
Examples of `qualified-names are 
[[Calendar.Date]], [[Calendar.today]] and [[Monoid.<*>]].
</para>

<para>
`Qualifiers can be used to disambiguate.  For example, there
may be reason to use two different `ops called [[union]] in
the same context: one for set union, and one for bag
(multiset) union.  They could then more fully be
called [[Set.union]] and [[Bag.union]], respectively.
Unlike in earlier versions of Specware, there is no rigid
relationship between `qualifiers and the `unit-identifiers
identifying `specs.
The author of a collection of `specs may use the `qualifier
deemed most appropriate for any `type- or `op-name.
For example, there could be a single `spec dubbed
[[SetsAndBags]] that introduces two new `ops, one called
[[Set.union]] and one called [[Bag.union]].
Generally, types and `ops that ``belong together''
should receive the same `qualifier.
It is up to the author of the `specs to determine what
belongs together.
</para>

<para>
`Type-names and `ops are <emphasis>introduced</emphasis> in a
`declaration or `definition, and may then be
<emphasis>employed</emphasis> elsewhere in the same `spec.
Thus, all occurrences of a `type- or `op-name can be divided
into ``introductions'' and ``employs''.
The `name as introduced in an introduction is the 
<emphasis>full</emphasis> `name of the type or `op.
If that `name is a `simple-name, the full `name is a `simple-name.
If the `name as introduced is a `qualified-name, then so is the full
`name.
</para>

<para>
For employs the rules are slightly different.  First, if the
`name employed
occurs just like that in an introduction, then it is the
full `name.
Also, if the `name employed is qualified, it is the full `name.
Otherwise, the `name as employed may be unqualified
shorthand for a qualified full `name.
For example, given an employ of the unqualified `type-name
[[Date]], possible qualified full `names for it are
[[Calendar.Date]], [[DateAndTime.Date]],
[[Diary.Date]], and so on.  But, of course, the full `name
must be one that is introduced in the `spec.
If there is precisely one `qualified-name introduced whose last part is
the same as the `simple-name employed, then that `name is the full `name.
Otherwise, type information may be employed to disambiguate
(``resolve overloading'').
</para>

<para>
Here is an illustration of the various possibilities:

[[
||  spec
||    type Apple
||    type Fruit.Apple
||    type Fruit.Pear
||    type Fruit.Date
||    type Calendar.Date
||    type Fruit.Basket = Apple * Pear * Date
||  endspec
]]

In the definition of type [[Fruit.Basket]] we have three
unqualified employs of `type-names, viz. [[Apple]], [[Pear]] and
[[Date]].
The `name [[Apple]] is introduced like that, so the employ
[[Apple]] already uses the full `name; it does not refer to
[[Fruit.Apple]].
The `name [[Pear]] is nowhere introduced just like that, so the employ
must be shorthand for some qualified full `name.  There is
only one applicable introduction, namely [[Fruit.Pear]].
Finally, for [[Date]] there are two candidates:
[[Fruit.Date]] and [[Calendar.Date]].  This is ambiguous,
and in fact an error.
To correct the error, the employ of [[Date]] should be
changed into either [[Fruit.Date]] or [[Calendar.Date]],
depending on the intention.
</para>

<para>
It is possible to give a qualification in one go to all
`simple-names introduced in a `spec.
If $Q$ is a `qualifier, and
$S$ is a term denoting a `spec, then
the term [[$Q$ qualifying
$S$]] denotes the same `spec as
$S$, except that each introduction
of an `simple-name $N$ is
replaced by an introduction of the `qualified-name
[[$Q$.$N$]].
Employs that before referred to the unqualified introduction
are also accordingly qualified, so that they now refer to
the qualified introduction.

For example, the value of

[[
||  Company qualifying spec
||    type Apple
||    type Fruit.Apple
||    type Fruit.Pear
||    type Fruit.Basket = Apple * Pear
||  endspec
]]

is the same as that of

[[
||  spec
||    type Company.Apple
||    type Fruit.Apple
||    type Fruit.Pear
||    type Fruit.Basket = Company.Apple * Fruit.Pear
||  endspec
]]
</para>

<!--====================================================================-->
<para>
<<
||`spec-qualification ::=  `qualifier qualifying `spec-term
||
||`qualifier ::= `word-symbol
||
||`name ::= `simple-name | `qualified-name
||
||`qualified-name ::= `qualifier . `simple-name
>>
Restriction.
`Qualifiers cannot be reserved symbols, with the exception of
[[Boolean]], which is allowed as a `qualifier.
</para>
<para>
Sample `spec-qualification:
[[
||    Weight qualifying /Units#Weights
]]
Sample `names:
[[
||    Key
||    $$
||    Calendar.Date
||    Monoid.<*>
]]
Let $R$ be the result of
elaborating `spec-term $S$.
Then the elaboration of `qualification [[$Q$
qualifying $S$]], where
$Q$ is a `qualifier, is
$R$ with each unqualified
`type-name, `op-name or `claim-name $N$ introduced there 
replaced by the `qualified-name
[[$Q$.$N$]].
The same replacement applies to all employs of
$N$ identifying that introduced `simple-name.
As always, the result of the replacement is required to be a well-formed
`spec.
</para>
<para>
For example, the elaboration of
[[
||  Buffer qualifying spec
||    op size : Nat
||    axiom LargeSize is size >= 1024
||  endspec
]]
results in:
[[
||  spec
||    op Buffer.size : Nat
||    axiom Buffer.LargeSize is Buffer.size >= 1024
||  endspec
]]
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Translations</title>
<para>
<<
||`spec-translation ::= translate `spec-term by `name-map
||
||`name-map ::= '{ [ `name-map-item { , `name-map-item }* ] '}
||
||`name-map-item ::= `type-name-map-item | `op-name-map-item
||
||`type-name-map-item ::= [ type ] `name +-> `name
||
||`op-name-map-item ::= [ op ] `annotable-name +-> `annotable-name
||
||`annotable-name ::= `name [ : `type-descriptor ]
>>
Restriction.
A `spec-translation may not map two different `type-names or two different
`op-names to the same `simple-name.  Note that this implies that
`type- and `op-names cannot be translated to `simple-names defined in
the base libraries.
</para>
<para>
Sample `spec-translation:
[[
||    translate A by {Counter +-> Register, tally +-> incr}
]]
Let $R$ be the result of
elaborating `spec-term $S$.
Then the elaboration of [[translate
$S$ by {
$M$\<subscript>1\</subscript> +->
$N$\<subscript>1\</subscript>, ...
$M<subscript>n</subscript>$ +->
$N<subscript>n</subscript>$ }]]
is $R$ with each occurrence of a `name
$M<subscript>i</subscript>$
replaced by
$N<subscript>i</subscript>$.
All other `names are mapped to themselves, i.e., they are unchanged.
The presence of a type annotation in a `name-map-item, as in
[[X:E +-> cross]], indicates that the `name-map-item refers to an `op-name;
additionally, on the left-hand side such an annotation may serve to disambiguate
between several synonymous `ops, and then there must be an `op in $R$ of
the type given by the `type-descriptor.
If the right-hand side of a `name-map-item carries a type
annotation, its `type-descriptor must conform to the type of
the `op-name in the resulting `spec.
Without such annotation on either side, if a `name
to be translated is introduced both as a `type-name and as an
`op-name in $R$, it must be preceded by [[type]] or [[op]] to
indicate which of the two is meant.
Otherwise the indication [[type]] or [[op]] is not
required, but allowed; if present, it must correspond to the kind of
`simple-name (`type-name or `op-name) to be translated.
</para>
<para>
For example, the elaboration of
[[
||  translate spec
||    type E
||    op i : E
||  endspec by {
||    E +-> Counter,
||    i +-> reset
||  }
]]
results in:
[[
||  spec
||    type Counter
||    op reset : Counter
||  endspec
]]
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Substitutions</title>
<para>
<<
||`spec-substitution ::= `spec-term '[ `morphism-term ']
>>
Sample `spec-substitution:
[[
||    Routing#Basis[morphism /Coll/Lattice ->
||                           /Coll/LatticeWithTop {} ]
]]
</para>
<para>
The elaboration of `spec-substitution
[[$S$[$M$]]]
yields the `spec
$T$ obtained as follows.
Let `spec $R$ be the result of
elaborating $S$,
and morphism $N$ that of
$M$.
Let `specs $D$ and
$C$ be the domain and codomain of
$N$.
First, remove from $R$ all
`declarations of $D$, and subject
the result to the effect of $N$,
meaning that all `name translations of
$N$ and all extensions with
`declarations are performed.
Then add the `declarations of $C$,
but without duplications, i.e., as if
$C$ is imported.
The result obtained is $T$.
</para>
<para>
Restriction.
`Spec $D$ must be
a ``sub-spec'' of `spec $R$,
meaning that each `declaration of
$D$ is also a
`declaration of $R$.
</para>
<para>
Informally,
$T$
is to $R$ as
$C$ is to
$D$.
</para>
<para>
Except when $R$ introduces, next
to the `type- and `op-names it has in common with
$D$, new `type- or `op-names
that also occur in $C$,
the result `spec $T$
is a categorical colimit of this pushout diagram:
[[
||              $D$ ---------> $R$
||              |            |
||              |            |
||              |            |
||              v            v
||              $C$ ---------> $T$
]]
Although isomorphic to the result that would be obtained 
by using a `diagram-colimit, $T$
is more ``user-oriented'' in two ways:
the `names in $T$ are `names from
$C$, and `claims of $D$ not repeated in
$C$ are not repeated here either.
</para>
<para>
For example, assume we have:
[[
||  A = spec
||    type Counter
||    op reset: Counter
||    op tally : Counter -> Counter
||    axiom Effect is
||      fa (c : Counter) ~(tally c = c)
||  endspec
||  
||  B = spec
||    type Register = Nat
||    def reset = 0
||    def incr c = c+1
||  endspec
||
||  M = morphism A -> B {Counter +-> Register, tally +-> incr}
||  
||  AA = spec
||    import A
||    type Interval = {start: Counter, stop: Counter}
||    op isEmptyInterval? : Interval -> Boolean
||    def isEmptyInterval? {start = x, stop = y} = (x = y)
||  endspec
]]
Then the result of [[AA[M]]] is the same as that of this `spec:
[[
||  spec
||    import B
||    type Interval = {start: Register, stop: Register}
||    op isEmptyInterval? : Interval -> Boolean
||    def isEmptyInterval? {start = x, stop = y} = (x = y)
||  endspec
]]
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Diagram Colimits</title>
<para>
<<
||`diagram-colimit ::= colimit `diagram-term
>>
The result of elaborating a `diagram-colimit is the `spec
which is the apex of the cocone forming the
colimit in the category of `specs and `spec-morphisms.
As always, the result is required to be well formed.
See further the &Specware; Tutorial.
<!-- TODO: weird `names -->
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Obligators</title>
<para>
<<
||`obligator ::= obligations `unit-term
>>
Restriction.
The `unit-term of an `obligator must either be a `spec-term
or a `morphism-term.
</para>
<para>
The result of elaborating an `obligator is a `spec
containing the proof obligations engendered by the `spec or morphism
resulting from elaborating its `unit-term.
These proof obligations are expressed as `conjectures;
they can be discharged by proving them, using `proof-terms.
See further the &Specware; User Manual.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section><title>Morphisms</title>
<para>
<<
||`morphism-term ::=
||     `unit-identifier
||   | `spec-morphism
||
||`spec-morphism ::= morphism `spec-term -> `spec-term `name-map
>>
A morphism is a formal mapping between two expanded `spec-forms that
describes exactly how one is translated or extended into the other.
It consists of the two `specs, referred to as ``domain'' and
``codomain'', and a mapping of all `type- and `op-names introduced in
the domain `spec to `type- and `op-names of the codomain `spec.
To be well-formed, a morphism must obey conditions that express that it
is a proper refinement of the domain into the codomain ` spec.
</para>
<para>
Restriction.
When used as a `morphism-term, the elaboration of a
`unit-identifier must yield a morphism.
</para>
<para>
Restriction (``proof obligations'').
Given `spec-morphism [[morphism $S$ ->
$T$ {
$M$\<subscript>1\</subscript> +->
$N$\<subscript>1\</subscript>, ...
$M<subscript>n</subscript>$ +->
$N<subscript>n</subscript>$ }]]
let $R$ be the result of elaborating $S$, and let
$S'$ be $R$ with each occurrence of a
`name
$M<subscript>i</subscript>$
replaced by
$N<subscript>i</subscript>$.
The same rules apply as for `spec-translation [[translate $S$
by {]]...[[}]], and the result $S'$ must be well formed, with the
exception that the restriction on `spec-translations requiring
different `type- or `op-names to be mapped to different `simple-names
does not apply here.
Let $T'$ be the result of elaborating $T$.
Then, first, each `type-name or `op-name introduced in
$S'$ must also be introduced in $T'$.
Further, no `type-name or `op-name originating from a
library `spec may have been subject to translation.
Finally, each `claim in $S'$ must be a theorem that follows
from the `claims of $T'$.
Collectively, the `claims in $S'$
are known as the <emphasis>proof obligations</emphasis>
engendered by the morphism.
They are the formal expression of the requirement that the step from
$S'$ to $T'$ is a proper refinement.
</para>

<para>
For example, in
[[
||  S = spec endspec
||  T = spec type Bullion = (Char | isAlpha) endspec
||  M = morphism S -> T {Boolean -> Bullion}
]]
the type-name [[Boolean]], which originates from a library spec,
is subject to translation.  Therefore, [[M]] is not a proper morphism.
Further, in
[[
||  S = spec
||         op f : Nat -> Nat
||         axiom ff is fa(n:Nat) f(n) ~= f(n+1)
||      endspec
||
||  T = spec
||         def f(n:Nat) = n*n rem 5
||      endspec
||
||  M = morphism S -> T
]]
axiom [[ff]] does not follow from (the axiom implied by) the `op-definition
for [[f]] in `spec [[T]], since [[f(2)]] = [[f(3)]] = 4.
Therefore, [[M]] is not a proper morphism here either.
</para>

<para>
Sample `spec-morphism:
[[
||  morphism A -> B {Counter +-> Register, tally +-> incr}
]]
</para>

<para>
The elaboration of `spec-morphism [[morphism $S$ -> $T$ {$M$}]]
results in the morphism whose domain and codomain are the result of
elaborating $S$ and $T$, respectively, and whose mapping is given
by the list of `name-map-items in $M$, using type annotations and
indicators [[type]] and [[op]] as described for `spec-translations,
and extended to all domain `type- and `op-names not yet covered
by having these map to themselves.  (In particular, `simple-names from
the base-libraries always map to themselves.)
</para>
</section>
<!-- ***************************************************************** -->
<!--
** <section><title>Spec type and operator visibility</title>
** <para>
** <<
** ||`spec-visibility ::=
** ||     hide `name-list in `spec-term
** ||   | export `name-list from `spec-term
** ||
** ||`name-list ::= '{ `name { , `name }* '}
** >>
** </para>
** </section>
-->
<!-- ***************************************************************** -->
<section><title>Diagrams</title>
<para>
<<
||`diagram-term ::=
||     `unit-identifier
||   | `diagram-form
||
||`diagram-form ::= diagram '{ `diagram-element { , `diagram-element }* '}
||
||`diagram-element ::=
||     `diagram-node
||   | `diagram-edge
||
||`diagram-node ::= `simple-name +-> `spec-term
||
||`diagram-edge ::= `simple-name : `simple-name -> `simple-name +-> `morphism-term
||     
>>
Restriction.
When used as a `diagram-term, the elaboration of a
`unit-identifier must yield a diagram.
</para>
<para>
Restriction.
In a `diagram, the first `simple-name of each `diagram-node and
`diagram-edge must be unique (i.e., not be used more than
once in that `diagram).  Further, for each `diagram-edge
[[$E$ :
$ND$ ->
$NC$ +->
$M$]], there must be `diagram-nodes
[[$ND$ +->
$D$]] and
[[$NC$ +->
$C$]] of the `diagram such that,
after elaboration, [[$M$]] is a
morphism from [[$D$]] to
[[$C$]].
</para>
<para>
Sample `diagram:
[[
||    diagram {
||       A          +-> /Coll/Lattice,
||       B          +-> /Coll/LatticeWithTop,
||       m : A -> B +-> /Coll/AddTop,
||       C          +-> Routing#Basis,
||       i : A -> C +-> morphism /Coll/Lattice ->
||                                   Routing#Basis {}
||    }
]]
</para>
<para>
The result of elaborating a `diagram-form is the categorical
diagram whose nodes are labeled with the `specs and
whose edges are labeled with the morphisms that result
from elaborating the corresponding `spec-terms and
`morphism-terms.
</para>
</section>
<!-- ***************************************************************** -->
<!--
** <section><title>Let and Where Expressions</title>
** <para>
** <<
** ||`let-term ::= let `local-bindings in `unit-term
** ||
** ||`where-term ::= `unit-term where `local-bindings end
** ||
** ||`local-bindings ::= `simple-name = `unit-term { `simple-name = `unit-term }*
** >>
** </para>
** </section>
-->
<!-- ***************************************************************** -->
<section><title>Target Code Terms</title>
<para>
<<
||`target-code-term ::=
||      generate `target-language-name `spec-term [ in `string-literal ]
||
||`target-language-name ::= c | java | lisp
>>
Sample `target-code-term:
[[
||    generate lisp /Vessel#Contour
||                      in "C:/Projects/Vessel/Contour.lisp"
]]
The elaboration of a `target-code-term for a well-formed `spec-term
generates code in the language suggested by the
`target-language-name (currently only C, Java, and Common Lisp);
see further the
&Specware; User Manual.
</para>
</section>
<!-- ***************************************************************** -->
<section><title>Proof Terms</title>
<para>
<<
||`proof-term ::=
||      prove `claim-name in `spec-term
||                      [ with `prover-name ]
||                      [ using `claim-list ]
||                      [ options `prover-options ]
||
||`prover-name ::= snark
||
||`claim-list ::= `claim-name { , `claim-name }*
||
||`prover-options ::= `string-literal
>>
</para>
<para>
Restriction.
The `claim-names must occur as `claim-names in the `spec
that results from elaborating the `spec-term.
</para>
<para>
Sample `proof-term:
[[
||    prove Effect in obligations M
||                         options "(use-paramodulation t)"
]]
</para>
<para>
The elaboration of a `proof-term invokes the prover suggested
by the `prover-name (currently only SNARK).
The property to be proved is the `claim of the first
`claim-name; the `claim-list lists the hypotheses (assumptions)
that may be used in the proof.
The `prover-options are prover-specific and are not
further described here.
For details, see the &Specware; User Manual.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Declarations"><title>Declarations</title>
<para>
<<
||`declaration ::=
||      `import-declaration
||    | `type-declaration
||    | `op-declaration
||    | `definition
||
||`definition ::=
||      `type-definition
||    | `op-definition
||    | `claim-definition
||
||`equals ::= is | =
>>
Sample `declarations:
[[
||    import Lookup
||    type Key
||    op present : Database * Key -> Boolean
||    type Key = String
||    def present(db, k) = embed? Some (lookup (db, k))
||    axiom norm_idempotent is fa(x) norm (norm x) = norm x
]]
</para>
<!-- ***************************************************************** -->
<section id="Import-declarations"><title>Import-declarations</title>
<!--====================================================================-->
<para>
A `spec may contain one or more `import-declarations.
On elaboration, these are ``expanded''.
The effect is as if the bodies of these imported `specs (themselves
in elaborated form, which means that all `import-declarations
have been expanded, all translations performed and all
shorthand employs of `names have been resolved to full `names,
after which only declarations or definitions of types, `ops
and `claims are left)
is inserted in place in the receiving `spec.
</para>

<para>
For example, the result of

[[
||  spec
||    import spec
||             type A.Z
||             op b : Nat -> Z
||           end
||    type A.Z = String
||    def b = toString
||  endspec
]]

is this ``expanded'' `spec:

[[
||  spec
||    type A.Z
||    op b : Nat -> A.Z
||    type A.Z = String
||    def b = toString
||  endspec
]]
</para>

<para>
For this to be well formed, the imported `specs must be well formed
by themselves; in addition, the result of expanding them in
place must result in a well-formed `spec.
</para>

<para>
There are a few restrictions, which are meant to catch
unintentional naming mistakes.
First, if two different imported `specs each introduce a
type or `op
with the same (full) `name, the introductions must be
identical declarations or definitions, or one may be a
declaration and the other a ``compatible'' definition.
For example, given

[[
||  S1 = spec op e : Integer end
||  S2 = spec op e : Char end
||  S3 = spec def e = 0 end
]]

the `specs [[S1]] and [[S3]] can be imported together, but
all other combinations of two or more co-imported `specs
result in an ill-formed `spec.
This restriction is in fact a special case of the general
requirement that import expansion must result in a well-formed
`spec.

Secondly, a `type-name introduced in any of the imported
`specs cannot be re-introduced in the receiving `spec except
for the case of an ``imported'' declaration together with a
definition in the receiving `spec.
Similarly for `op-names, with the addition that an
`op-definition in the receiving `spec
must be compatible with an `op-declaration for the same `name
in an imported `spec.
The latter is again a special case of the general requirement that
import expansion must result in a well-formed `spec.
</para>

<para>
What is specifically excluded by the above, is giving a
definition of a type or `op in some `spec, import it, and then
redefining or declaring that type or `op with the same full
`name in the receiving `spec.
</para>

<!--====================================================================-->
<para>
<<
||`import-declaration ::= import `spec-term
>>
Sample `import-declarations
[[
||    import Lookup
]]
</para>
<!-- ================================================================= -->
<para>
An `import-declaration is contained in some `spec-form, and 
to elaborate that `spec-form the `spec-term of
the `import-declaration is elaborated first, giving some
`spec $S$.
The `import-declaration has then the effect as if the
`declarations of the imported `spec
$S$ are expanded in place.
This cascades: if `spec $A$ imports
$B$, and `spec
$B$ imports
$C$, then effectively `spec
$A$ also imports
$C$.
An important difference with earlier versions of &Specware;
than version 4
is that multiple imports of the same `spec have the same
effect as a single import.
</para>
<!-- ================================================================= -->
<para>
If `spec $A$ is imported by
$B$, each model of
$B$ is necessarily a model of
$A$ (after <quote>forgetting</quote>
any `simple-names newly introduced by $B$).
So $A$ is then refined by
$B$, and the morphism from
$A$ to $B$ is
known as the <quote>import morphism</quote>.
As it does not involve translation of `type- or `op-names,
it can be denoted by [[morphism $A$
-> $B$ {}]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-declarations"><title>Type-declarations</title>
<para>
<<
||`type-declaration ::= type `type-name [ `formal-type-parameters ]
||
||`formal-type-parameters ::= `local-type-variable | ( `local-type-variable-list )
||
||`local-type-variable ::= `simple-name
||
||`local-type-variable-list ::= `local-type-variable { , `local-type-variable }*
||
>>
Restriction.
Each `local-type-variable of the `formal-type-parameters must
be a different `simple-name.
</para>
<!-- ================================================================= -->
<para>
Sample `type-declarations:
[[
||    type Date
||    type Array a
||    type Map(a, b)
]]
</para>
<!-- ================================================================= -->
<para>
Every `type-name used in a `spec must be declared (in the
same `spec or in an imported `spec, included the
``base-library'' `specs that are always implicitly imported).
A `type-name may have <emphasis>type parameters</emphasis>.
Given the example `type-declarations above, some valid
`type-descriptors that can be used in this context are [[Array Date]],
[[Array (Array Date)]] and [[Map (Nat, Boolean)]].
</para>
<!-- ================================================================= -->
<para>
In a model of the `spec, a type is assigned to
each unparameterized `type-name, while an infinite
<emphasis>family</emphasis> of types is assigned to
parameterized `type-names <quote>indexed</quote> by tuples
of types, that is, there is one family member, a type,
for each possible assignment
of types to the `local-type-variables.
So for the above example `type-declaration of [[Array]]
one type must be assigned to [[Array Nat]], one to
[[Array Boolean]], one to [[Array (Array Date)]], and so on.
These assigned types could all be the same type, or perhaps all
different, as long as the model respects typing.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-definitions"><title>Type-definitions</title>
<para>
<<
||`type-definition ::= type `type-name [ `formal-type-parameters ] `equals `type-descriptor
>>
Sample `type-definitions:
[[
||    type Date = {year : Nat, month : Nat, day : Nat}
||    type Array a = List a
||    type Map(a, b) = (Array (a * b) | key_uniq?)
]]
In each model, the type assigned to the
`type-name must be the same as the right-hand-side `type-descriptor.
For parameterized types, this extends to all possible
assignments
of types to the `local-type-variables, taking the right-hand `type-descriptors
as interpreted under each of these assignments.
So, for the example, [[Map(Nat, Char)]] is the same type as
[[(Array (Nat * Char) | key_uniq?)]], and so on.
</para>
<!-- ================================================================= -->
<para>
With <emphasis>recursive</emphasis> `type-definitions, there
are additional requirements.
For example, consider
[[
||    type Stack a =
||      | Empty
||      | Push {top : a, pop : Stack a}
]]
This means that for each type [[a]] there is a value
[[Empty]] of type [[Stack a]], and further a function
[[Push]] that maps values of type [[{top : a, pop : Stack
a}]] to [[Stack a]].
Furthermore, the type assigned to [[Stack a]] must be such
that all its inhabitants can be constructed
<emphasis>exclusively</emphasis> and
<emphasis>uniquely</emphasis> in this way:
there is one inhabitant [[Empty]], and all others are the
result of a [[Push]].
Finally -- this is the point -- the type in the model must
be such that its inhabitants can be constructed this way in
<emphasis>a finite number of steps</emphasis>.
So there can be no <quote>bottom-less</quote> stacks:
deconstructing a stack using
[[
||    def [a] hasBottom? (s : Stack a) : Boolean =
||      case s of
||         | Empty -> true
||         | Push {top, pop = rest} -> hasBottom? rest
]]
is a procedure that is guaranteed to terminate, always
resulting in [[true]].
</para>
<!-- ================================================================= -->
<para>
In general, `type-definitions generate implicit axioms,
which for recursive definitions imply that the type is not
<quote>larger</quote> than necessary.
In technical terms, in each model the type is the least
fixpoint of a recursive domain equation.
</para>
<!-- ================================================================= -->
<!--
** <para>
** Note.  Not all recursive definitions have such least fixpoints,
** in which case the `spec is inconsistent.
** The corresponding axioms are higher-order of a nature that
** the provers that can currently be coupled to the &Specware;
** system can not handle, and are not actually generated.
** For normal cases of <quote>algebraic types</quote>
** like [[Stack a]] above, there is a first-order
** characterization, and the appropriate axioms are generated for
** use by provers.
** </para>
-->
</section>
<!-- ***************************************************************** -->
<section id="Op-declarations"><title>Op-declarations</title>
<para>
<<
||`op-declaration ::= op `op-name [ `fixity ] : `type-scheme
||
||`fixity ::= `associativity `priority
||
||`associativity ::= infixl | infixr
||
||`priority ::= `nat-literal
||
||`type-scheme ::= [ `type-variable-binder ] `type-descriptor
||
||`type-variable-binder ::= `[ `local-type-variable-list `]
||
>>
Sample `op-declarations:
[[
||    op usage : String
||
||    op o infixl 24 : [a,b,c] (b -> c) * (a -> b) -> a -> c
]]
</para>
<!-- ====================== NOT YET ==================================
<para>
Restriction.
Although `ops may be <quote>overloaded</quote>,
an `op can not be redeclared and/or redefined with overlapping
<emphasis>source types</emphasis> (see below), whether in the
same `spec or after having been defined in an imported `spec,
not even when the meaning of both `definitions is the same.
For example, [[op abs : Nat -> Nat]] cannot coexist with
[[op abs : Integer -> Integer]], but either can coexist
with [[op abs : Char -> Nat]].
There may be both an `op-declaration and an `op-definition
for the same `op, provided that the type information supplied
by the `op-declaration is compatible with the (explicit or
inferred) type of the `op-definition, and that the
`op-definition is not given in an imported `spec (but in the
current `spec, or in a later `spec importing the current
`spec).
</para>

<para>
Restriction.
When an `infix-operator (see below) is overloaded,
all `op-declarations for the `op must have the same
`fixity.
</para>
     ====================== TEY TON ================================== -->
<!--
<para>
** Restriction.
** User-defined `ops may not be <quote>overloaded</quote>,
** or otherwise be redeclared and/or redefined, whether in the
** same `spec or after having been defined in an imported `spec,
** not even when the meaning of both `definitions is the same.
** </para>
-->
<!-- ================================================================= -->
<para>
An `op-declaration introduces an `op with an associated type.
The type can be <quote>monomorphic</quote>, like [[String]], or
<quote>polymorphic</quote> (indicated by a `type-variable-binder).
In the latter case, an indexed family of values is assigned to
parameterized `type-names <quote>indexed</quote> by tuples of
types, that is, there is one family member, a typed value, for each
possible assignment of types to the `local-type-variables of
the `type-variable-binder, and the type of that value is the
result of the corresponding substitution of types for
`local-type-variables on the
polymorphic type of the `op.
In the example above, the declaration of polymorphic [[o]] can
be thought of as introducing a family of (fictitious) `ops,
one for each possible assignment to the
`local-type-variables [[a]], [[b]] and [[c]]:
[[
||o\<subscript>Nat,String,Char \</subscript> : (String -> Char) * (Nat -> String) -> Nat -> Char
||
||o\<subscript>Nat,Nat,Boolean \</subscript> : (Nat -> Boolean) * (Nat -> Nat) -> Nat -> Boolean
||
||o\<subscript>Char,Boolean,Nat\</subscript> : (Boolean -> Nat) * (Char -> Boolean) -> Char -> Nat
]]
and so on.
Any `op-definition for [[o]] must be likewise accommodating.
</para>
<!-- ================================================================= -->
<!-- ====================== NOT YET ==================================
<para>
Given a type $T$, the type
super($T$) is defined to be
$T$ if $T$
is not a subtype.
For a subtype [[($T$ | $P$)]],
super([[($T$ | $P$)]]) is the type
super($T$).
For example, super([[(Nat | even)]]) is [[Integer]].
</para>

<para>
The source types of an `op are the set of types determined
as follows.
If the type of the `op is some monomorphic function type
[[$S$ -> $T$]], the source types are the
singleton set {super($S$)}.
If the type of the `op is a polymorphic function type
corresponding to some `type-scheme
[[[$V$] $S$ -> $T$]], the source types are the
set of all types super($S'$)
for the types
[[$S'$ -> ]]$T'$ of the indexed family of
values,
obtainable by the substitution of types for
the `local-type-variables in
$V$.
For example, for
[[
||   op f : [a] a * a -> a
]]
the source types are the set
{[[Integer * Integer]], [[Boolean * Boolean]], [[Char *
Char]], ...}.
</para>

<para>
Finally, if the type of the `op is not a (monomorphic or
polymorphic) function type, the source types of the `op are
the singleton set {[[()]]}, containing just the unit type.
</para>
     ====================== TEY TON ================================== -->
<!-- ================================================================= -->
<para>
Only binary `ops (those having some type
[[$S$ * $T$ -> $U$]])
may be declared with a `fixity.
When declared with a `fixity, the `op may be used in infix
notation, and then it is called an `infix-operator.
For [[o]] above, this means that [[o(f, g)]] and [[f o g]]
may be used, interchangeably, with no difference in meaning.
If the `associativity is [[infixl]], the `infix-operator is
called <emphasis>left-associative</emphasis>; otherwise,
if the `associativity is [[infixr]], it is
called <emphasis>right-associative</emphasis>.
If the `priority is [[priority $N$]],
the operator is said to have
<emphasis>priority</emphasis> $N$.
The `nat-literal $N$ stands for a
natural number; if `infix-operator 
$O1$ has priority
$N1$,
and $O2$ has priority
$N2$, with
$N1$ &lt; $N2$,
we say that $O1$ has
<emphasis>lower priority</emphasis> than
$O2$,
and that $O2$ has
<emphasis>higher priority</emphasis> than
(or <emphasis>takes priority over</emphasis>)
$O1$.
For the role of the `associativity and `priority, see further at
<link linkend="metaslang-infix-application"><emphasis>Infix-applications</emphasis></link>.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Op-definitions"><title>Op-definitions</title>
<para>
<<
||`op-definition ::=
||    def [ `type-variable-binder ] `formal-expression [ : `type-descriptor ] `equals
||        `expression
||
||`formal-expression ::= `op-name | `formal-application
||
||`formal-application ::= `formal-application-head `formal-parameter
||
||`formal-application-head ::= `op-name | `formal-application
||
||`formal-parameter ::= `closed-pattern
||
>>
<!-- ====================== NOT YET ==================================
||`formal-application ::= `formal-prefix-application | `formal-infix-application
||
||`formal-prefix-application ::= `formal-application-head `formal-parameter
||
||`formal-application-head ::= `op-name | `formal-prefix-application
||
||`formal-parameter ::= `closed-pattern
||
||`formal-infix-application ::= `formal-parameter `op-name `formal-parameter
>>
</para>
<para>
Restriction.
The `op-name of a `formal-infix-application must be an infix
operator.
</para>
<para>
     ====================== TEY TON ================================== -->
Sample `op-definitions:
[[
||    def usage = "Usage: Lookup key [database]"
||
||    def [a,b,c] o(f : b -> c, g: a -> b) : a -> c =
||      fn (x : a) -> f(g x)
||
||    def o(f, g) x = f(g x)
]]
Restriction.
See the restriction under <link
linkend="Op-declarations"><emphasis>Op-declarations</emphasis></link>
on redeclaring/redefining
`ops.
</para>
<!-- ================================================================= -->
<!-- ====================== NOT YET ==================================
<para>
Disambiguation.
The grammar for `formal-application is ambiguous for cases
like
$M N P$, in which
$M$ is any `simple-name, and
$N$ is an `infix-operator.
The ambiguity is resolved in favor of the reading
as a `formal-infix-application, and then the
`formal-infix-application $M N P$
is equivalent to the `formal-prefix-application
[[$N$ ($M$, $P$)]].
For example, for `infix-operator [[o]],
[[
||    def f o g = fn x -> f(g x)
]]
is equivalent to
[[
||    def o (f, g) = fn x -> f(g x)
]]
</para>
     ====================== TEY TON ================================== -->
<para>
Note that a `formal-expression always contains precisely one
`op-name, which is the `op <emphasis>being defined</emphasis> by
the `op-definition.
Note further that the `formal-application of an `op-definition
always uses prefix notation, also for `infix-operators.
</para>
<!-- ================================================================= -->
<para>
An `op can be defined without having been declared.
In that case the `op-definition
generates an implicit `op-declaration for the `op, provided a
monomorphic type for the `op can be unambiguously determined
from the `op-definition together with the uses of the
`op in `applications and other contexts.
In general, typing information on `ops may be omitted, but sufficient
information must be supplied when used, so that all
`expressions can be assigned a type in the context in which
they occur while uniquely associating the `ops with
`op-declarations or `op-definitions.
If two different associations both give type-correct `specs,
the `spec is ambiguous and ill formed.
</para>
<!-- ================================================================= -->
<para>
As for `op-definitions, the presence of a `type-variable-binder
signals that the `op being defined is polymorphic.
Note that the optional type annotation in an `op-definition
can not be a polymorphic `type-scheme, unlike for
`op-declarations.  For example, the following is ungrammatical:
[[
||    def o : [a,b,c] (b -> c) * (a -> b) -> a -> c =
||      fn (f, g) -> fn (x) -> f(g x)
]]
The presumably intended effect is achieved by
[[
||    def [a,b,c] o : (b -> c) * (a -> b) -> a -> c =
||      fn (f, g) -> fn (x) -> f(g x)
]]
In a model of the `spec, an indexed family of typed values is
assigned to a polymorphic `op, with one family member for each
possible assignment of types to the `local-type-variables of
the `type-variable-binder, and the type of that value is the
result of the corresponding `type-instantiation for the
polymorphic type of the `op.
Thus, we can reduce the meaning of a polymorphic
`op-definition to a family of (fictitious) monomorphic
`op-definitions.
</para>
<!-- ================================================================= -->
<para>
An `op-definition with `formal-prefix-application
[[
||    def $H$ $P$ = $E$
]]
in which
$H$ is a `formal-application-head,
$P$ is a `formal-parameter and
$E$ an `expression,
is equivalent to the `op-definition
[[
||    def $H$ = fn $P$ -> $E$
]]
For example,
[[
||    def o (f, g) x = f(g x)
]]
is equivalent to
[[
||    def o (f, g) = fn x -> f(g x)
]]
which in turn is equivalent to
[[
||    def o = fn (f, g) -> fn x -> f(g x)
]]
By
<!-- ====================== NOT YET ==================================
using the transformation from infix to prefix if
applicable, and
repeating
     ====================== TEY TON ================================== -->
this deparameterizing transformation for each
`formal-parameter, an equivalent unparameterized `op-definition
is reached.
The semantics is described in terms of such `op-definitions.
</para>
<!-- ================================================================= -->
<para>
In each model, the typed value assigned to the
`op being defined must be the same as the value of the
right-hand-side `expression.
For polymorphic `op-definitions, this extends to all possible
assignments of types to the `local-type-variables.
</para>
<!-- ================================================================= -->
<para>
An `op-definition can be thought of as a special notation
for an axiom.
For example,
[[
||    def [a] double (x : a) = (x, x)
]]
can be thought of as standing for:
[[
||    op double : [a] a -> a * a
||
||    axiom double_def is
||      [a] fa(x : a) double x = (x, x)
]]
In fact, &Specware; generates such axioms for use by
provers.
But in the case of recursive definitions, this form of
axiomatization does not adequately capture the meaning.
For example,
[[
||    def f (n : Nat) : Nat = 0 * f n
]]
is an improper `definition, while
[[
||    axiom f_def is
||        fa(n : Nat) f n = 0 * f n
]]
characterizes the function that maps every natural number to
0.
The issue is the following.
Values in models can not be &undefined; and functions
assigned to `ops must
be <emphasis>total</emphasis>.
But in assigning a meaning to a recursive `op-definition, we
-- temporarily -- allow &undefined; and partial functions
(functions that are not everywhere defined on their domain
type) to be assigned to recursively defined `ops.
In the thus extended class of models, the recursive `ops must be
the least-defined solution to the <quote>axiomatic</quote>
equation (the least fixpoint as in domain theory), given the
assignment to the other `ops.
For the example of [[f]] above this results in the
everywhere undefined function, since
0 times &undefined; is &undefined;.
If the solution results in an undefined value or a function
that is not total (or for higher-order functions, functions
that may return non-total functions, and so on), the
`op-definition is improper.
Although &SpecwareV; does attempt to generate proof obligations
for this condition, it currently covers only ``simple''
recursion, and not mutual recursion or recursion introduced by
means of higher-order functions.
</para>
<!-- ================================================================= -->
<para>
Functions that are determined to be the value of an
`expression, but that are not assigned to `ops,
need not be total, but the context must enforce
that the function can not be applied to values for which it
is undefined.
Otherwise, the `spec is ill formed.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Claim-definitions"><title>Claim-definitions</title>
<para>
<<
||`claim-definition ::= `claim-kind `claim-name `equals `claim
||
||`claim-kind ::= axiom | theorem | conjecture
||
||`claim-name ::= `simple-name
||
||`claim ::= [ `type-variable-binder ] `expression
>>
Sample `claim-definitions:
[[
||    axiom norm_idempotent is
||      norm o norm = norm
||
||    theorem o_assoc is
||      [a,b,c,d] fa(f : c -> d, g : b -> c, h : a -> b)
||        f o (g o h) = (f o g) o h
||
||    conjecture pivot_hold is
||      let p = pivot hold in
||        fa (n : {n : Nat | n < p}) ~(hold n = hold p)
]]
</para>
<!-- ================================================================= -->
<para>
Restriction.
The type of the `claim must be [[Boolean]].
</para>
<!-- ================================================================= -->
<para>
When a `type-quantification is present, the `claim is polymorphic.
The `claim may be thought of as standing for an infinite family
of monomorphic `claims, one for each possible assignment of
types to the `local-type-variables.
</para>
<!-- ================================================================= -->
<para>
The `claim-kind [[theorem]] should only be used for `claims
that have actually been proved to follow from the (explicit or
implicit) axioms.
In other words, giving them axiom status should not change
the class of models.
Theorems can be used by provers.
</para>
<!-- ================================================================= -->
<para>
Conjectures are meant to represent proof obligations that should
eventually attain theoremhood.
Like theorems, they can be used by provers.
This is only sound if circularities (vicious circles) are avoided.
This kind of `claim is usually created automatically by the elaboration
of an `obligator, but can also be created manually.
</para>
<!-- ================================================================= -->
<para>
The &Specware; system passes on the `claim-name of the
`claim-definition with the `claim for purposes of
identification.
Both may be transformed to fit the requirements of the prover,
and appear differently there.
Not all `claims can be faithfully represented in all provers,
and even when they can, the logic of the prover may not be up
to dealing with them.
</para>
<!-- ================================================================= -->
<para>
Remark.
It is a common mistake to omit the part <quote>`claim-name
`equals</quote> from a `claim-definition.
A defensive style against this mistake is to have the `claim always
start on a new text line.
This is additionally recommended because it may become required in
future revisions of Metaslang.
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Type-descriptors"><title>Type-descriptors</title>
<para>
<<
||`type-descriptor ::=
||      `type-sum
||    | `type-arrow
||    | `slack-type-descriptor
||
||`slack-type-descriptor ::=
||      `type-product
||    | `tight-type-descriptor
||
||`tight-type-descriptor ::=
||      `type-instantiation
||    | `closed-type-descriptor
||
||`closed-type-descriptor ::=
||      `type-name
||    | Boolean
||    | `local-type-variable
||    | `type-record
||    | `type-restriction
||    | `type-comprehension
||    | `type-quotient
||    | ( `type-descriptor )
||
>>
(The distinctions <quote>`slack-</quote>,
<quote>`tight-</quote> and <quote>`closed-</quote> before
<quote>`type-descriptor</quote> have no semantic significance.
The distinction merely serves the purpose of diminishing the
need for parenthesizing in order to avoid grammatical ambiguities.)
</para>
<!-- ================================================================= -->
<para>
Sample `type-descriptors:
[[
||    | Point XYpos | Line XYpos * XYpos
||    List String * Nat -> Option String
||    a * Order a * a
||    PartialFunction (Key, Value)
||    Key
||    Boolean
||    a
||    {center : XYpos, radius : Length}
||    (Nat | even)
||    {k : Key | present (db, k)}
||    Nat / (fn (m, n) -> m rem 3 = n rem 3)
||    (Nat * Nat)
]]
The meaning of the `type-descriptor [[Boolean]] is the ``inbuilt'' type
inhabited by the two logical (truth) values [[true]] and [[false]].
The meaning of a parenthesized `type-descriptor
[[($T$)]] is the same
as that of the enclosed `type-descriptor
$T$.
</para>
<!-- ================================================================= -->
<para>
The various other kinds of `type-descriptors not defined here are described
each in their following respective sections, with the exception
of `local-type-variable, whose
(lack of) meaning as a `type-descriptor is described below.
</para>
<!-- ================================================================= -->
<para>
Restriction.
A `local-type-variable may only be used as a `type-descriptor if
it occurs in the scope of a `formal-type-parameters
or `type-variable-binder in which it is introduced.
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
A single `simple-name used as a `type-descriptor is a `local-type-variable
when it occurs in the scope of a `formal-type-parameters
or `type-variable-binder in which it is introduced, and
then it identifies the textually most recent introduction.
Otherwise, the `simple-name is a `type-name.
</para>
<!-- ================================================================= -->
<para>
A `local-type-variable used as a `type-descriptor has no meaning by
itself, and where relevant to the semantics is either
``indexed away'' (for parameterized types) or
``instantiated away'' (when introduced in a
`formal-type-parameters or `type-variable-binder) before a
meaning is ascribed to the construct in which it occurs.
Textually, it has a scope just like a plain `local-variable.
</para>
<!-- ***************************************************************** -->
<section id="Type-sums"><title>Type-sums</title>
<para>
<<
||`type-sum ::= `type-summand { `type-summand }*
||
||`type-summand ::= '| `constructor [ `slack-type-descriptor ]
||
||`constructor ::= `simple-name
||
>>
Sample `type-sum:
[[
||    | Point XYpos | Line XYpos * XYpos
]]
Restriction.
The `constructors of a `type-sum must all be different `simple-names.
</para>
<!-- ================================================================= -->
<para>
The ordering of the `type-summands has no significance:
[[| Zero | Succ Peano]] denotes the same <quote>sum type</quote> as
[[| Succ Peano | Zero]].
</para>
<!-- ================================================================= -->
<para>
A `type-sum denotes a <emphasis>sum type</emphasis>, which
is a type that is inhabited by <quote>tagged values</quote>.
A tagged value is a pair
($C$, $v$),
in which 
$C$ is a `constructor and
$v$ is a typed value.
</para>
<!-- ================================================================= -->
<para>
A `type-sum introduces a number of `embedders, one for each
`type-summand.
In the discussion, we omit the optional [[embed]] keyword of
the `embedders.
The `embedders are similar to `ops, and are explained as if
they were `ops, but note the Restriction specified under
<link linkend="Structors"><emphasis>Structors</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
For a `type-sum
$T$ with
`type-summand
$C$ $S$,
in which
$C$ is a `constructor and
$S$ a `type-descriptor,
the corresponding pseudo-`op introduced is typed as follows:
[[
||    op $C$ : $S$ -> $T$
]]
It maps a value $v$ of type
$S$ to the tagged value
($C$,
$v$).
If the `type-summand is a single
<emphasis>parameter-less</emphasis> `constructor (the
`slack-type-descriptor is missing),
the pseudo-`op introduced is typed as follows:
[[
||    op $C$ : $T$
]]
It denotes the tagged value
($C$, ()), in which () is the
inhabitant of the unit type (see under <link linkend="Type-records"><emphasis>Type-records</emphasis></link>).
</para>
<!-- ================================================================= -->
<para>
The sum type denoted by the `type-sum then consists of the
union of the ranges (for parameter-less constructors the
values) of the pseudo-`ops for all constructors.
</para>
<!-- ================================================================= -->
<para>
The `embedders are individually, jointly and severally
<emphasis>injective</emphasis>,
and jointly <emphasis>surjective</emphasis>.
</para>
<!-- ================================================================= -->
<para>
This means, first, that for any pair of `constructors
$C1$ and
$C2$ of
<emphasis>any</emphasis> `type-sum, and for any pair
of values
$v1$ and
$v2$
of the appropriate type
(to be omitted for parameter-less `constructors),
the value of
$C1$ $v1$
is only equal to
$C2$ $v2$
when
$C1$
and
$C2$
are the same `constructor of the <emphasis>same</emphasis>
sum type, and
$v1$ and
$v2$
(which then are either both absent, or else must have the
same type) are both absent or are the same value.
In other words, whenever the `constructors are different, or are from
different `type-sums, or the values are different, the
results are different.
(The fact that synonymous `constructors of different types
yield different values already follows from the fact that
values in the models are typed.)
</para>
<!-- ================================================================= -->
<para>
Secondly, for any value $u$ of any sum
type, there is a `constructor $C$ of
that sum type and a value
$v$ of the appropriate type
(to be omitted for parameter-less `constructors),
such that the value of
$C$ $v$
is
$u$.
In other words, all values of a sum type can be constructed
with an `embedder.
</para>
<!-- ================================================================= -->
<para>
For example, consider
[[
||     type Peano =
||       | Zero
||       | Succ Peano
||
||     type Unique =
||       | Zero
]]
This means that there is a value
[[Zero]] of type [[Peano]], and further a function
[[Succ]] that maps values of type [[Peano]]
to type [[Peano]].
Then [[Zero]] and [[Succ n]] are guaranteed to be
different, and each value of type [[Peano]] is either
[[Zero : Peano]], or expressible in the form
[[Succ (n : Peano)]] for a suitable expression [[n]].
The `expressions [[Zero : Peano]] and [[Zero : Unique]]
denote different, entirely unrelated, values.
(Note that [[Unique]] is <emphasis>not</emphasis> a subtype of
[[Peano]].  Subtypes of a type can only be made with a
`type-restriction, for instance as in
[[(Peano | embed? Zero)]].)
For recursively defined `type-sums, see also the discussion
under <link linkend="Type-definitions"><emphasis>Type-definitions</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
Note.
Although the sum types [[| Mono]] and [[| Mono ()]] have
exactly the same set of inhabitants when considered as
untyped values, these two types are different, and the
pseudo-`ops they introduce have different types, only the
second of which is a function type:
[[
||    Mono : | Mono
||
||    Mono : () -> | Mono ()
]]
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-arrows"><title>Type-arrows</title>
<para>
<<
||`type-arrow ::= `arrow-source -> `type-descriptor
||
||`arrow-source ::= `type-sum | `slack-type-descriptor
||
>>
Sample `type-arrow:
[[
||    (a -> b) * b -> List a -> List b
]]
In this example, the `arrow-source is [[(a -> b) * b]], and the (target)
`type-descriptor [[List a -> List b]].
</para>
<!-- ================================================================= -->
<para>
The <emphasis>function type</emphasis> [[$S$ -> $T$]] is inhabited by
precisely all <emphasis>partial or total</emphasis> functions from
$S$
to $T$.
That is, function $f$ has type
[[$S$ -> $T$]] if, and only if,
for each value $x$ of type
$S$ such that the value of
$f$ $x$ is
defined, that value has type $T$.
Functions can be constructed with `lambda-forms, and be used
in `applications.
</para>
<!-- ================================================================= -->
<para>
In considering whether two functions (of the same type) are
equal, only the meaning on the domain type is relevant.
Whether a function is undefined outside its domain type, or
might return some value of some type, is immaterial to the
semantics of &Metaslang;.
(For a type-correct `spec, the difference is unobservable.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-products"><title>Type-products</title>
<para>
<<
||`type-product ::= `tight-type-descriptor * `tight-type-descriptor { * `tight-type-descriptor }*
||
>>
Sample `type-product:
[[
||    (a -> b) * b * List a
]]
Note that a `type-product contains
at least two constituent `tight-type-descriptors.
</para>
<!--====================================================================-->
<para>
A `type-product denotes a <emphasis>product type</emphasis>
that has at least two <quote>component types</quote>,
represented by its `tight-type-descriptors.
The ordering of the component types is significant: unless
$S$
and $T$ are the same type,
the product type
[[$S$ * $T$]] is different from the type
[[$T$ * $S$]].
Further, the three types
[[($S$ * $T$)]] [[* $U$]],
[[$S$ *]] [[($T$ * $U$)]] and
[[$S$ * $T$ * $U$]] are all different; the first
two have two component types, while the last one has three.
The inhabitants of the product type
$T$<subscript>1</subscript> [[* $T$]]<subscript>2</subscript> [[*]] ...
[[* ]]$T<subscript>n</subscript>$
are precisely all $n$-tuples
($v<subscript>1</subscript>$,
$v<subscript>2</subscript>$, ... ,
$v<subscript>n</subscript>$), where each
$v<subscript>i</subscript>$ has type
[[$T<subscript>i</subscript>$]], for
$i$ = 1, 2, ... ,
$n$.
Values of a product type can be constructed with
`tuple-displays, and component values can be extracted with
`tuple-patterns as well as with `projectors.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-instantiations"><title>Type-instantiations</title>
<para>
<<
||`type-instantiation ::= `type-name `actual-type-parameters
||
||`actual-type-parameters ::= `closed-type-descriptor | ( `proper-type-list )
||
||`proper-type-list ::= `type-descriptor , `type-descriptor { , `type-descriptor }*
||
>>
Sample `type-instantiation:
[[
||    Map (Nat, Boolean)
]]
Restriction.
The `type-name must have been declared or
defined as a parameterized type (see <link linkend="Type-declarations"><emphasis>Type-declarations</emphasis></link>), and
the number of `type-descriptors in the `actual-type-parameters must match
the number of `local-type-variables in the
`formal-type-parameters of the `type-declaration and/or `type-definition.
</para>
<!-- ================================================================= -->
<para>
The `type-descriptor represented by a `type-instantiation is the type
assigned for the combination of types of the `actual-type-parameters
in the indexed family of types for the `type-name of the
`type-instantiation.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-names"><title>Type-names</title>
<para>
<<
||`type-name ::= `name
>>
Sample `type-names:
[[
||    Key
||    Calendar.Date
]]
Restriction.
At the spec level, a `type-name may only be used if
there is a `type-declaration and/or
`type-definition for it in the current `spec or in some `spec
that is imported (directly or indirectly) in the current `spec.
If there is a unique `qualified-name for a given
unqualified ending, the qualification may be omitted for a
`type-name used as a `type-descriptor.
</para>
<!-- ================================================================= -->
<para>
The type of a `type-name is the type assigned to
it in the model.
(In this case, the context can not have superseded the
original assignment.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-records"><title>Type-records</title>
<para>
<<
||`type-record ::= '{ [ `field-typer-list ] '} | ( )
||
||`field-typer-list ::= `field-typer { , `field-typer }*
||
||`field-typer ::= `field-name : `type-descriptor
||
||`field-name ::= `simple-name
||
>>
Sample `type-record:
[[
||    {center : XYpos, radius : Length}
]]
Restriction.
The `field-names of a `type-record must all be different.
</para>
<!-- ================================================================= -->
<para>
Note that a `type-record contains either no
constituent `field-typers, or else at least two.
</para>
<!--====================================================================-->
<para>
A `type-record is like a `type-product, except that the
components, called <quote>fields</quote>, are identified by
`name instead of by position.
The ordering of the `field-typers has no significance:
[[{center : XYpos, radius : Length}]]
denotes the same <emphasis>record type</emphasis> as
[[{radius : Length, center : XYpos}]].
Therefore we assume in the following, without loss of generality, that
the fields are ordered lexicographically according to their
`field-names (as in a dictionary: [[a]] comes
before [[ab]] comes before [[b]]) using some fixed collating
order for all marks that may comprise a `name.
Then each field of a record type with
$n$ fields has a
<emphasis>position</emphasis> in the range 1 to
$n$.
The inhabitants of the record type
[[{$F$]]<subscript>1</subscript>
[[: $T$]]<subscript>1</subscript>[[, $F$]]<subscript>2</subscript>
[[: $T$]]<subscript>2</subscript>[[,]]
...
[[, $F<subscript>n</subscript>$ : $T<subscript>n</subscript>$}]]
are precisely all $n$-tuples
($v<subscript>1</subscript>$,
$v<subscript>2</subscript>$, ... ,
$v<subscript>n</subscript>$), where each
$v<subscript>i</subscript>$ has type
$T<subscript>i</subscript>$, for
$i$ = 1, 2, ... ,
$n$.
The `field-names of that record type are the `field-names
$F$<subscript>1</subscript>,
... ,
$F<subscript>n</subscript>$,
and, given the lexicographic ordering,
`field-name 
$F<subscript>i</subscript>$
<emphasis>selects</emphasis>
position$i$, for
$i$ = 1, 2, ... ,
$n$.
Values of a record type can be constructed with
`record-displays, and field values can be extracted with
`record-patterns and (as for
product types) with `projectors.
</para>
<!--====================================================================-->
<para>
For the `type-record [[{}]], which may be equivalently
written as [[()]], the record type it denotes has zero components, and
therefore no `field-names.
This zero-component type has precisely one
inhabitant, and is called the <emphasis>unit
type</emphasis>.
The unit type may equally well be
considered a product type, and is the only type that is both
a product and a record type.
<!--====================================================================-->
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-restrictions"><title>Type-restrictions</title>
<para>
<<
||`type-restriction ::= ( `slack-type-descriptor '| `expression )
||
>>
Sample `type-restriction:
[[
||    (Nat | even)
]]
Restriction.
In a `type-restriction
[[($T$ | $P$)]], the `expression
$P$ must be a predicate on
the type
$T$, that is,
$P$ must be a function of type
[[$T$ -> Boolean]].
</para>
<!-- ================================================================= -->
<para>
Note that the parentheses in
[[($T$ | $P$)]] are mandatory.
</para>
<!-- ================================================================= -->
<para>
The inhabitants of type
[[($T$ | $P$)]] are precisely the
inhabitants of type $T$ that satisfy the
predicate $P$, that is, they are those values
$v$ for which the value of $P$ $v$ is [[true]].
</para>
<!-- ================================================================= -->
<para>
If $P1$ and $P2$ are the same function, then
[[($T$ | $P1$)]] and
[[($T$ | $P2$)]] are equivalent, that is,
they denote the same type.
Furthermore, [[($T$ | fn _ -> true)]] is equivalent to $T$.
</para>
<!-- ================================================================= -->
<para>
The type 
[[($T$ | $P$)]] is called a
<emphasis>subtype</emphasis> of
<emphasis>supertype</emphasis> $T$.
Values can be shuttled between a subtype and its supertype
and vice versa with
`relaxators and `restrict-expressions; see also
<link linkend="metaslang-relax-pattern"><emphasis>Relax-patterns</emphasis></link>.
</para>
<!--====================================================================-->
<para>
Metaslang does not require the explicit use of a `relaxator to relax
an `expression from a subtype to its supertype if the
context requires the latter.
Implicit relaxation will take place when needed.
For example, in the `expression [[-1]] the `nat-literal [[1]]
of type [[Nat]] is implicitly relaxed to type [[Integer]] to
accommodate the unary negation operator [[-]], which has type
[[Integer -> Integer]].
</para>
<!--====================================================================-->
<para>
Likewise, Metaslang does not require the explicit use of a
`restrict-expression
to restrict
an `expression from a type to a subtype if the
context requires the latter.
Implicit restriction will take place when needed.
For example, in the `expression [[7 div 2]] the `nat-literal [[2]]
of type [[Nat]] is implicitly restricted to type [[PosNat]],
a subtype of [[Nat]], to accommodate the division operator
[[div]], whose second argument has type [[PosNat]].
But note that implicit restriction engenders the same proof
obligation as results when using an explicit
`restrict-expression.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-comprehensions"><title>Type-comprehensions</title>
<para>
<<
||`type-comprehension ::= '{ `annotated-pattern '| `expression '}
||
>>
Sample `type-comprehension:
[[
||    {n : Nat | even n}
]]
Restriction.
In a `type-comprehension
[[{$P$ : $T$ | $E$}]],
the `expression
$E$ must
have type [[Boolean]].
</para>
<!-- ================================================================= -->
<para>
`Type-comprehensions provide an alternative notation for
`type-restrictions that is akin
to the common mathematical notation for set comprehensions.
The meaning of `type-comprehension
[[{$P$ : $T$ | $E$}]]
is the same as that of the `type-restriction
[[($T$ |
fn $P$ -> $E$)]].
So the meaning of the example `type-comprehension above is
[[(Nat | fn n -> even n)]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Type-quotients"><title>Type-quotients</title>
<para>
<<
||`type-quotient ::= `closed-type-descriptor / `closed-expression
>>
Sample `type-quotient:
[[
||     Nat / (fn (m, n) -> m rem 3 = n rem 3)
]]
Restriction.
In a `type-quotient
[[$T$ / $Q$]], the `expression
$Q$ must be a (binary) predicate on
the type [[$T$ * $T$]] that is an equivalence relation,
as explained below.
</para>
<!-- ================================================================= -->
<para>
Equivalence relation.
Call two values $x$ and
$y$ of type
$T$
<quote>$Q$-related</quote>
if
($x$, $y$)
satisfies $Q$.
Then $Q$ is an
<emphasis>equivalence relation</emphasis>
if, for all values $x$,
$y$ and
$z$ of type
$T$,
$x$ is
$Q$-related
to itself,
$y$ is
$Q$-related to
$x$ whenever
$x$ is
$Q$-related to
$y$, and
$x$ is
$Q$-related to
$z$ whenever
$x$ is
$Q$-related to
$y$ and
$y$ is
$Q$-related to
$z$.
The equivalence relation $Q$
then partitions the inhabitants of
$T$ into
<emphasis>equivalence classes</emphasis>, being the maximal
subsets of
$T$ containing
mutually $Q$-related members.
These equivalence classes will be called
<quote>$Q$-equivalence classes</quote>.
</para>
<!-- ================================================================= -->
<para>
The inhabitants of the <emphasis>quotient
type</emphasis>
[[$T$ / $Q$]]
are precisely the $Q$-equivalence classes
into which the inhabitants of
$T$ are partitioned by
$Q$.
For the example above, there are three equivalence
classes of natural numbers leaving the same remainder on
division by 3: the sets {0, 3, 6, ...},
{1, 4, 7, ...} and {2, 5, 8, ...}, and so the quotient type
has three inhabitants.
</para>
<!-- ================================================================= -->
<para>
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Expressions"><title>Expressions</title>
<para>
<<
||`expression ::=
||      `lambda-form
||    | `case-expression
||    | `let-expression
||    | `if-expression
||    | `quantification
||    | `annotated-expression
||    | `tight-expression
||
||`tight-expression ::=
||      `application
||    | `restrict-expression
||    | `closed-expression
||
||`closed-expression ::=
||      `op-name
||    | `local-variable
||    | `literal
||    | `field-selection
||    | `tuple-display
||    | `record-display
||    | `sequential-expression
||    | `list-display
||    | `structor
||    | ( `expression )
||    | ( `inbuilt-op )
||
||`inbuilt-op ::= `inbuilt-prefix-op | `inbuilt-infix-op
||
||`inbuilt-prefix-op ::=  ~
||
||`inbuilt-infix-op ::=  =>  |  <=>  |  '|'|  |  &&  |  =  |  ~=  |  <<
>>
(The distinctions `tight- and `closed- for `expressions lack
semantic significance, and merely serve the purpose of avoiding
grammatical ambiguities.)
</para>
<!--====================================================================-->
<para>
Sample `expressions:
[[
||    fn (s : String) -> s ^ "."
||    case z of {re = x, im = y} -> {re = x, im = -y}
||    let x = x + 1 in f(x, x)
||    if x <= y then x else y
||    fa(x,y) (x <= y)  <=>  ((x < y) or (x = y))
||    f(x, x)
||    [] : List Arg
||    abs(x-y)
||    restrict posNat? (n+1)
||    ++
||    x
||    3260
||    z.re
||    ("George", Poodle : Dog, 10)
||    {`name = "George", kind = Poodle : Dog, age = 10}
||    (writeLine "key not found"; embed Missing)
||    ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
||    project 2
||    (n + 1)
||    (||)
]]
Restriction.
Like all polymorphic or type-ambiguous constructs, an `expression
can only be used in a context if its type can be inferred
uniquely, given the `expression and the context.
This restriction will not be repeated for the various kinds of
`expressions defined in the following subsections.
</para>
<!-- ================================================================= -->
<para>
The meaning of a parenthesized `expression
[[($E$)]] is the same
as that of the enclosed `expression
$E$.
The meaning of a parenthesized `inbuilt-prefix-op [[($P$)]] is the same
as that of the `lambda-form [[fn x -> $P$ x]].
The meaning of a parenthesized `inbuilt-infix-op [[($I$)]] is the same
as that of the `lambda-form [[fn (x,y) -> x $I$ y]].
Note that this function is strict in both arguments, unlike $I$ itself.
</para>
<!-- ================================================================= -->
<para>
The various other kinds of `expressions not defined here are described
each in their following respective sections, with the exception
of `local-variable, whose
meaning as an `expression is described below.
</para>
<!-- ================================================================= -->
<para>
Restriction.
A `local-variable may only be used as an `expression if
it occurs in the scope of the `local-variable-list of a
`quantification or of a `variable-pattern in which it is
introduced.
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
A single `simple-name used as an `expression is a `local-variable
when it occurs in the scope of a `local-variable-list
or `variable-pattern in which a synonymous `local-variable
is introduced, and then it identifies the textually most recent
introduction.
Otherwise, the `simple-name is an `op-name or an `embedder; for the
disambiguation between the latter two, see <link linkend="Embedders"><emphasis>Embedders</emphasis></link>.
</para>
<!-- ================================================================= -->
<para>
A `local-variable used as an `expression has the typed value
assigned to it in the environment.
</para>
<!-- ***************************************************************** -->
<section id="Lambda-forms"><title>Lambda-forms</title>
<para>
<<
||`lambda-form ::= fn `match
||
>>
Sample `lambda-form:
[[
||    fn (s : String) -> s ^ "."
]]
The value of a `lambda-form is a partial or total function.
If the value determined for a `lambda-form as described
below is not a total function, the context must enforce
that the function can not be applied to values for which it
is undefined.
Otherwise, the `spec is ill formed.
&SpecwareV; does not attempt to generate proof obligations for
establishing this.
</para>
<!-- ================================================================= -->
<para>
The type of a `lambda-form is that of its `match.
The meaning of a given `lambda-form of type
[[$S$ -> $T$]] is
the function $f$ mapping each
inhabitant $x$ of
$S$ to a value
$y$ of type
$T$, where
$y$ is the return value
of $x$ for the `match of the
`lambda-form.
If the `match accepts each $x$ of
type $S$ (for acceptance and return
value, see the section on <link linkend="Matches"><emphasis>Matches</emphasis></link>) function
$f$ is total; otherwise it is
partial, and undefined for those values
$x$ rejected.
</para>
<!-- ================================================================= -->
<para>
In case of a recursive definition, the above procedure may
fail to determine a value for $y$,
in which case function $f$ is not
total, but undefined for $x$.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Case-expressions"><title>Case-expressions</title>
<para>
<<
||`case-expression ::= case `expression of `match
>>
Sample `case-expressions:
[[
||    case z of {re = x, im = y} -> {re = x, im = -y}
||
||    case s of
||       | Empty -> true
||       | Push {top = _, pop = rest} -> hasBottom? rest
]]
The value of a `case-expression
[[case $E$ of $M$]] is the same as that of
the `application
[[(fn $M$)
($E$)]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Let-expressions"><title>Let-expressions</title>
<para>
<<
||`let-expression ::= let `let-bindings in `expression
||
||`let-bindings ::= `recless-let-binding | `rec-let-binding-sequence
||
||`recless-let-binding ::= `pattern `equals `expression
||
||`rec-let-binding-sequence ::= `rec-let-binding { `rec-let-binding }*
||
||`rec-let-binding ::=
||    def `simple-name `formal-parameter-sequence [ : `type-descriptor ] `equals `expression
||
||`formal-parameter-sequence ::= `formal-parameter { `formal-parameter }*
>>
Sample `let-expressions:
[[
||    let x = x + e in f(x, x)
||    let def f x = x + e in f (f x)
]]
In the case of a `recless-let-binding (recless =
recursion-less), the value of the `let-expression
[[let $P$ = $A$ in $E$]] is the same as that of the
`application
[[(fn $P$ -> $E$)]]
[[($A$)]].
For the first example above, this amounts to [[f(x + e, x + e)]].
Note that [[x = x + e]] is not interpreted as a recursive
definition.
</para>
<!-- ================================================================= -->
<para>
In case of a `rec-let-binding-sequence (rec = recursive), the
`rec-let-bindings have the role of <quote>local</quote>
`op-definitions; that is, they are treated exactly like
`op-definitions except that they are interpreted in the
local environment instead of the global model.
For the second example above, this amounts to
[[(x + e) + e]].
(If [[e]] is a `local-variable in this scope, the definition
of [[f]] can not be <quote>promoted</quote> to an
`op-definition, which would be outside the scope binding
[[e]].)
A `spec with `rec-let-bindings can be transformed into one
without such by creating `op-definitions for each
`rec-let-binding that take additional arguments, one for each of
the `local-variables referenced.  For the example, in which
[[f]] references `local-variable [[e]], the
`op-definition for the <quote>extended</quote> `op [[f\<superscript>+\</superscript>]]
would be [[def f\<superscript>+\</superscript> e x = x + e]], and the
`let-expression would become [[f\<superscript>+\</superscript> e (f\<superscript>+\</superscript> e x)]].
The only difference in meaning is that the models of the
transformed `spec assign a value to the newly introduced
`op [[f\<superscript>+\</superscript>]].
</para>
<!-- ================================================================= -->
<para>
Note that the first occurrence of [[x]] in the above example
of a `rec-let-binding is a `variable-pattern and the
second-occurrence is in its scope; the third and last occurrence of
[[x]], however, is outside the scope of the first [[x]] and
identifies an `op or `local-variable [[x]] introduced
elsewhere.
So, without change in meaning, the `rec-let-binding can be
changed to:
[[
||    let def f xena = xena + e in f (f x)
]]
</para>
</section>
<!-- ***************************************************************** -->
<section id="If-expressions"><title>If-expressions</title>
<para>
<<
||`if-expression ::= if `expression then `expression else `expression
||
>>
Sample `if-expression:
[[
||    if x <= y then x else y
]]
The value of an `if-expression
[[if $B$ then $T$ else $F$]] is the same as that of the
`case-expression
[[case $B$ of true ->
($T$) | false ->
($F$)]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Quantifications"><title>Quantifications</title>
<para>
<<
||`quantification ::= `quantifier ( `local-variable-list ) `expression
||
||`quantifier ::= fa | ex
||
||`local-variable-list ::= `annotable-variable { , `annotable-variable }*
||
||`annotable-variable ::= `local-variable [ : `type-descriptor ]
||
||`local-variable ::= `simple-name
||
>>
Sample `quantifications:
[[
||    fa(x) norm (norm x) = norm x
||    ex(e : M) fa(x : M) x <*> e = x & e <*> x = x
]]
Restriction.
Each `local-variable of the `local-variable-list must
be a different `simple-name.
</para>
<!-- ================================================================= -->
<para>
</para>
<!-- ================================================================= -->
<para>
`Quantifications are non-constructive, even when the domain
type is finitely enumerable.
The main uses are in `type-restrictions and `type-comprehensions,
and `claims.
The type of a `quantification is [[Boolean]].
There are two kinds of quantifications:
[[fa]]-`quantifications (or <quote>universal
quantifications</quote>; fa = for all), and
[[ex]]-`quantifications (or <quote>existential
quantifications</quote>; ex = there exists).
</para>
<!-- ================================================================= -->
<para>
The value of a [[fa]]-`quantification
[[fa $V$]]
$E$, in which
$V$ is a `local-variable-list and
$E$ is an `expression,
is determined as
follows.
Let $M$ be the `match
[[$V$ -> $E$]].
If $M$ has return value [[true]] for each
value $x$ in its domain (note that
rejection cannot happen here), the value of the
`quantification is [[true]]; otherwise it is [[false]].
</para>
<!-- ================================================================= -->
<para>
The value of an [[ex]]-`quantification
[[ex $V$]]
$E$ is the same as that of the
[[fa]]-`quantification
[[~(fa $V$ ~($E$))]].
</para>
<!-- ================================================================= -->
<para>
Note that [[fa]] and [[ex]] must be followed by an
opening parenthesis[[ ( ]].
So [[fa x (x = x)]], for example, is ungrammatical.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Annotated-expressions"><title>Annotated-expressions</title>
<para>
<<
||`annotated-expression ::= `tight-expression : `type-descriptor
>>
Restriction.
In an `annotated-expression
[[$E$ : $T$]], the `expression
$E$ must have type
$T$.
</para>
<!-- ================================================================= -->
<para>
Sample `annotated-expression:
[[
||    [] : List Arg
||    Positive : Sign
]]
The value of an `annotated-expression
[[$E$ : $T$]] is the value of
$E$.
</para>
<!-- ================================================================= -->
<para>
The type of some `expressions is polymorphic.  For example,
for any type $T$,
[[[]]] denotes the empty list of type [[List $T$]].
Likewise, `constructors of parameterized sum types can be
polymorphic, as the constructor [[None]] of
[[
||    type Option a = | Some a | None
]]
Further, overloaded `constructors have an ambiguous type.
By annotating such polymorphic or type-ambiguous
`expressions with a `type-descriptor, their type can
be disambiguated, which is required unless an
unambiguous type can already be inferred from the context.
Annotation, even when redundant, can further help to
increase clarity.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Applications"><title>Applications</title>
<para>
<<
||`application ::= `prefix-application | `infix-application
||
||`prefix-application ::= `application-head `actual-parameter
||
||`application-head ::=
||      `closed-expression
||    | `inbuilt-prefix-op
||    | `prefix-application
||
||`actual-parameter ::= `closed-expression
||
||`infix-application ::= `operand `infix-operator `operand
||
||`operand ::= `tight-expression
||
||`infix-operator ::= `op-name | `inbuilt-infix-op
>>
Sample `applications:
[[
||    f (x, x)
||    f x (g y)
||    x + 1
]]
Restriction.
An `infix-operator, whether qualified or
unqualified, can not be used without more as an
`actual-parameter or `operand (and in the case of an `inbuilt-op,
it can not be used without more as any other kind of `expression either).
To use an `infix-operator in such cases, it
must be enclosed in parentheses, as for example in the
`prefix-applications [[foldl (+) 0]] and [[foldl ( *) 1]]
or the `infix-application [[(<) o ival]].
Note the space between ``[[(]]'' and ``[[*]]'', since without
space ``[[(*]]'' signals the start of a `comment.
</para>
<!--====================================================================-->
<para>
Restriction.
An `op-name can be used as an `infix-operator only if it has been
declared as such in an `op-declaration
(see under <link linkend="Op-declarations"><emphasis>Op-declarations</emphasis></link>).
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
An `infix-application
$P M Q N R$, in which
$P$,
$Q$ and
$R$ are `operands and
$M$ and
$N$ are `infix-operators,
is interpreted as either
[[($P M Q$) ]]$N R$ or
[[$P M$ ($Q N R$)]].
The choice is made as follows.
If $M$ has higher priority than
$N$, or the priorities are the same
but $M$ is left-associative,
the interpretation is
[[($P M Q$) ]]$N R$.
In all other cases
the interpretation is
[[$P M$ ($Q N R$)]].
For example, given
[[
||    op @ infixl 10: Nat * Nat -> Nat
||    op $$ infixr 20: Nat * Nat -> Nat
]]
the following interpretations hold:
[[
||    1 $$ 2 @ 3  =  (1 $$  2) @ 3
||    1 @ 2 @ 3  =  (1 @  2) @ 3
||    1 @ 2 $$ 3  =   1 @ (2  $$ 3)
||    1 $$ 2 $$ 3  =   1 $$ (2  $$ 3)
]]
Note that no type information is used in the disambiguation.
If [[(1 @ 2) $$ 3]] is type-correct but [[1 @ (2 $$ 3)]] is
not, the formula [[1 @ 2 $$ 3]] is type-incorrect, since its
interpretation is.
</para>
<para>
For the application of this disambiguation rule, the `inbuilt-ops
have `fixity as suggested by the following
pseudo-`op-declarations:
[[
||op =>  infixr 13 : Boolean * Boolean -> Boolean 
||op ||  infixr 14 : Boolean * Boolean -> Boolean 
||op &&  infixr 15 : Boolean * Boolean -> Boolean 
||op =   infixr 20 : [a]   a * a       -> Boolean 
||op ~=  infixr 20 : [a]   a * a       -> Boolean 
||op <<  infixl 25 : {$x$:$A$, ... , $y$:$B$, ...} * {$x$:$A$, ... , $z$:$C$, ...}
||                -> {$x$:$A$, ... , $y$:$B$, ... , $z$:$C$, ...}
]]
</para>
<!-- ================================================================= -->
<para>
Restriction.
In an `application $H$ $P$, in which
$H$ is an `application-head and $P$ an `actual-parameter,
the type of $P$ must be some function type
[[$S$ -> $T$]], and then
$H$ must have the domain type
$S$.
The type of the whole `application is then
$T$.
</para>
<!-- ================================================================= -->
<para>
The value of `prefix-application $H P$ is the value returned by
function $(H)$ for the argument value $P$.
</para>
<para>
The meaning of `infix-application $P N Q$, in which $P$ and $Q$ are
`operands and $N$ is an `op-name, is the same as that of the
`prefix-application [[$N(P, Q)$]].
</para>
<para>
The meaning of `infix-application [[$P$ => $Q$]], in which $P$ and $Q$ are
`operands, is the same as that of the
`if-expression [[if $P$ then $Q$ else true]].
</para>
<para>
The meaning of `infix-application [[$P$ || $Q$]], in which $P$ and $Q$ are
`operands, is the same as that of the
`if-expression [[if $P$ then true else $Q$]].
</para>
<para>
The meaning of `infix-application [[$P$ && $Q$]], in which $P$ and $Q$ are
`operands, is the same as that of the
`if-expression [[if $P$ then $Q$ else false]].
</para>
<para>
The value of `infix-application [[$P$ = $Q$]], in which $P$ and $Q$ are
`operands, is [[true]] if $P$ and $Q$ have the same value, and [[false]]
otherwise.
$P$ and $Q$ must have the same type, or else have
types that are subtypes of the same supertype.
In the latter case, the comparison is the same as for the values
of the `operands relaxed to the supertype,
so, for example, the value of [[(1:Nat)=(1:PosNat)]] is [[true]].
</para>
<para>
The meaning of `infix-application [[$P$ ~= $Q$]], in which $P$ and $Q$ are
`operands, is the same as that of the
`prefix-application [[~($P$ = $Q$)]].
</para>
<para>
An `infix-application [[$P$ << $Q$]] is also called a ``record update''.
In a record update [[$P$ << $Q$]], in which $P$ and $Q$ are
`operands, $P$ and $Q$ must have record types, referred to as $S$ and $T$,
respectively.
Moreover, for each `field-name $F$ these types $S$ and $T$ have in common,
the field types for $F$ in $S$ and $T$ must be the same, or be
subtypes of the same supertype.
The type of [[$P$ << $Q$]] is then the record type $R$ whose `field-names are formed
by the union of the `field-names of $S$ and $T$, where for each `field-name
$F$ in that union, the type of field $F$ in $R$ is that of field $F$ in
$T$ if $F$ is a field of $T$, and otherwise the type of field $F$ in
$S$.
Likewise,
the value of [[$P$ << $Q$]] is the record value of type $R$ whose field value
of each field $F$ is that of field $F$ in 
$Q$ if $F$ is a field of $T$, and otherwise the field value of field $F$ in 
$P$.
So, for example, the value of
[[{a=1, b=#z} << {a=2, c=true}]]
is
[[{a=2, b=#z, c=true}]]: fields of the right-hand side `operand
take precedence over the left-hand side when present in both.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Restrict-expressions"><title>Restrict-expressions</title>
<para>
<<
||`restrict-expression ::= restrict `closed-expression `closed-expression
>>
Sample `restrict-expression:
[[
||    restrict posNat? (n+1)
]]
Restriction.
In a `restrict-expression
[[restrict $P$]] $E$
the `expression $P$ must have function
type [[$T$ -> Boolean]] and the
`expression $E$ must have type
$T$ for some
$T$.
</para>
<!--====================================================================-->
<para>
The type of a `restrict-expression
[[restrict $P$]]
$E$,
where $P$ has
type [[$T$ -> Boolean]],
is the type
[[($T$]] [[|]] [[$P$)]].
</para>
<!--====================================================================-->
<para>
A `restrict-expression
[[restrict $P$]] $E$
is a convenient notation for the `let-expression
[[let relax $P$]] [[$V$ = $E$ in $V$]], where
$V$ is some unique fresh `simple-name, that
is, it is any `simple-name that does not already occur in the
`spec, directly or indirectly through an import.
</para>
<!--====================================================================-->
<para>
The use of this `restrict-expression engenders a proof obligation
that the value of $E$ satisfies predicate
$P$.
</para>
<!--====================================================================-->
<para>
For example, assuming the `definitions from the Base Library
for [[Nat]], the `restrict-expression
[[restrict posNat? (n+1)]] has type
[[PosNat]].
The proof obligation here is that, in the context,
[[(n+1) > 0]].
</para>
<!--====================================================================-->
<para>
The purpose of `restrict-expressions is to make it
explicit that an `expression whose a-priori type is some
supertype $T$ actually is guaranteed
(or required) to have subtype
[[($T$]] [[|]]
[[$P$)]].
Note, however, that Metaslang does not require the explicit use of a
`restrict-expression
to restrict
an `expression from a type to a subtype if the
context requires the latter.
Implicit restriction will take place when needed.
For example, in the `expression [[7 div 2]] the `nat-literal [[2]]
of type [[Nat]] is implicitly restricted to type [[PosNat]],
a subtype of [[Nat]], to accommodate the division operator
[[div]], whose second argument has type [[PosNat]].
But note that implicit restriction engenders the same proof
obligation as results when using an explicit
`restrict-expression.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Op-names"><title>Op-names</title>
<para>
<<
||`op-name ::= `name
>>
Sample `op-names:
[[
||    length
||    >=
||    DB_LOOKUP.Lookup
]]
Restriction.
An `op-name may only be used if there is an `op-declaration
and/or `op-definition for it in the current `spec or in some
`spec that is imported (directly or indirectly) in the current
`spec.
If there is a unique `qualified-name for a given unqualified
ending that is type-correct in the context, the qualification
may be omitted for an `op-name used as an `expression.
So overloaded `ops may only be used as such when their type can
be disambiguated in the context.
</para>
<!-- ================================================================= -->
<!-- ====================== NOT YET ==================================
<para>
Restriction.
Overloaded `ops, when used as `expressions, have an ambiguous type.
They may only be used as such when their type can be
disambiguated in the context.
Unlike for `constructors, target-type-descriptor information is not used
for this disambiguation.
For example, consider
[[
||    op abs : Nat -> Nat
||    op abs : Char -> Nat
||
||    def ok (c : Char) = abs c
||    def ko x          = abs x
]]
In the application [[abs c]]
(the right-hand side of the `definition for [[ok]])
[[c]] is known to have type [[Char]] in the context.
This is enough to determine [[abs]] as identifying here
[[op abs : Char -> Nat]].
In the application [[abs x]]
(the right-hand side of the `definition for [[ko]])
the context gives no constraint on the type of [[x]],
and no type-disambiguation for [[abs]] is possible, so its
use there is incorrect.
</para>
     ====================== TEY TON ================================== -->
<!-- ================================================================= -->
<para>
The value of an `op-name is the value assigned to
it in the model.
(In this case, the context can not have superseded the
original assignment.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Literals"><title>Literals</title>
<para>
<<
||`literal ::=
||      `boolean-literal
||    | `nat-literal
||    | `char-literal
||    | `string-literal
||
>>
Sample `literals:
[[
||    true
||    3260
||    #z
||    "On/Off switch"
]]
Restriction:
No whitespace is allowed anywhere inside any kind of `literal,
except for <quote>significant</quote> whitespace in
`string-literals, as explained there.
</para>
<!--====================================================================-->
<para>
`Literals provide denotations for the inhabitants of the
inbuilt and ``base-library'' types [[Boolean]], [[Nat]], [[Char]]
and [[String]].
The value of a `literal is independent of the environment.
</para>
<!--====================================================================-->
<para>
(There are no `literals for the base-library type [[Integer]].
For nonnegative integers, a `nat-literal can be used.
For negative integers, apply the unary base-library `op [[-]], which
negates an integer:
[[-1]] denote the negative integer [[-]]1.)
</para>
<!-- ***************************************************************** -->
<section id="Boolean-literals"><title>Boolean-literals</title>
<para>
<<
||`boolean-literal ::= true | false
||
>>
Sample `boolean-literals:
[[
||    true
||    false
]]
The type [[Boolean]] has precisely two inhabitants,
the values of [[true]] and [[false]].
</para>
<!--====================================================================-->
<para>
Note that [[true]] and [[false]] are not `constructors.
So [[embed true]] is ungrammatical.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Nat-literals"><title>Nat-literals</title>
<para>
<<
||`nat-literal ::= `decimal-digit { `decimal-digit }*
>>
Sample `nat-literals:
[[
||    3260
||    007
]]
The `type-descriptor [[Nat]] is, by definition, the subtype of
[[Integer]] restricted to the nonnegative integers 0, 1, 2,
... , which we identify with the natural numbers.
The value of a `nat-literal is the natural number of which
it is a decimal representation; for example, the
`nat-literal [[3260]] denotes the natural number 3260.
Leading `decimal-digits [[0]] have no significance:
both [[007]] and [[7]] denote the number 7.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Char-literals"><title>Char-literals</title>
<para>
<<
||`char-literal ::= #`char-literal-glyph
||
||`char-literal-glyph ::= `char-glyph | "
||
||`char-glyph ::=
||      `letter
||    | `decimal-digit
||    | `other-char-glyph
||
||`other-char-glyph ::=
||      ! | : | @ | # | $ | % | ^ | & | * | ( | ) | _ | - | + | =
||    | '| | ~ | ` | . | , | < | > | ? | / | ; | '' | '[ | '] | '{ | '}
||    | \\ | \"
||    | \a | \b | \t | \n | \v | \f | \r | \s
||    | \x `hexadecimal-digit `hexadecimal-digit
||
||`hexadecimal-digit ::=
||      `decimal-digit
||    | a | b | c | d | e | f
||    | A | B | C | D | E | F
>>
</para>
<!--====================================================================-->
<para>
Sample `char-literals:
[[
||   #z
||   #\x7a
]]
The type [[Char]] is inhabited by the 256
8-bit <emphasis>characters</emphasis>
occupying decimal positions 0 through 255 (hexadecimal
positions 00 through FF) in the ISO 8859-1 code table.
The first 128 characters of that code table are the
traditional ASCII characters (ISO 646).
(Depending on the operating environment, in particular the
second set of 128 characters -- those with
<quote>the high bit set</quote> -- may print or otherwise
be visually presented differently than intended by the
ISO 8859-1 code.)
The value of a `char-literal is a character of type
[[Char]].
</para>
<!--====================================================================-->
<para>
The value of a `char-literal [[#$G$]], where
$G$ is a `char-glyph, is the character denoted by
$G$.
For example, [[#z]] is the character that prints as
[[z]].
The  two-mark `char-literal [[#"]] provides a variant notation of the
three-mark `char-literal [[#\"]] and yields the
character[[ " ]](decimal position 34).
</para>
<!--====================================================================-->
<para>
Each one-mark `char-glyph
$C$ denotes the character that
<quote>prints</quote> as $C$.
The two-mark `char-glyph [[\\]] denotes
the character[[ \ ]](decimal position 92),
and the two-mark `char-glyph [[\"]] denotes
the character [[ " ]](decimal position 34).
</para>
<!--====================================================================-->
<para>
Notations are provided for denoting eight
<quote>non-printing</quote> characters, which, with the
exception of the first, are meant to regulate lay-out in
printing;
the actual effect may depend on the operating environment:
<informaltable frame="none">
<tgroup cols="4">
<tbody>
<row><entry>[[    ]]</entry><entry>glyph</entry><entry>decimal</entry><entry>`name</entry></row>
<row><entry>[[]]</entry><entry>[[]]</entry><entry>[[]]</entry><entry>[[]]</entry></row>
<row><entry>[[]]</entry><entry>[[ \a]]</entry><entry>&nbsp;&nbsp;&nbsp;7</entry><entry>bell</entry></row>
<row><entry>[[]]</entry><entry>[[ \b]]</entry><entry>&nbsp;&nbsp;&nbsp;8</entry><entry>backspace</entry></row>
<row><entry>[[]]</entry><entry>[[ \t]]</entry><entry>&nbsp;&nbsp;&nbsp;9</entry><entry>horizontal tab</entry></row>
<row><entry>[[]]</entry><entry>[[ \n]]</entry><entry>&nbsp;&nbsp;10</entry><entry>newline</entry></row>
<row><entry>[[]]</entry><entry>[[ \v]]</entry><entry>&nbsp;&nbsp;11</entry><entry>vertical tab</entry></row>
<row><entry>[[]]</entry><entry>[[ \f]]</entry><entry>&nbsp;&nbsp;12</entry><entry>form feed</entry></row>
<row><entry>[[]]</entry><entry>[[ \r]]</entry><entry>&nbsp;&nbsp;13</entry><entry>return</entry></row>
<row><entry>[[]]</entry><entry>[[ \s]]</entry><entry>&nbsp;&nbsp;32</entry><entry>space</entry></row>
</tbody>
</tgroup>
</informaltable>
Finally, every character can be obtained using the
hexadecimal representation of its position.
The four-mark `char-glyph
[[\x$H$]]<subscript>1</subscript>$H$<subscript>0</subscript>
denotes the character with hexadecimal position
$H$<subscript>1</subscript>$H$<subscript>0</subscript>,
which is decimal position
16 times the decimal value of `hexadecimal-digit
$H$<subscript>1</subscript> plus
the decimal value of `hexadecimal-digit
$H$<subscript>0</subscript>,
where the decimal value of the digits [[0]] through [[9]] is
conventional, while the six extra digits [[A]] through [[F]]
correspond to 10 through 15.
The case (lower or upper) of the six extra
digits is not significant.
For example, [[\x7A]] or equivalently [[\x7a]] has decimal
position 16 times 7 plus 10 = 122, and either version denotes
the character [[z]].
The <quote>null</quote> character can be obtained by using
[[\x00]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="String-literals"><title>String-literals</title>
<para>
<<
||`string-literal ::= " `string-body "
||
||`string-body ::= { `string-literal-glyph }*
||
||`string-literal-glyph ::= `char-glyph | `significant-whitespace
||
||`significant-whitespace ::= `space | `tab | `newline
>>
The presentation of a `significant-whitespace is the
whitespace suggested by the `name (`space, `tab or `newline).
</para>
<!--====================================================================-->
<para>
Sample `string-literals:
[[
||    ""
||    "see page"
||    "see\spage"
||    "the symbol ' is a single quote"
||    "the symbol \" is a double quote"
]]
The type [[String]] is inhabited by the
<emphasis>strings</emphasis>, which are (possibly empty)
sequences of characters.
The type [[String]] is primitive; it is a different type
than the isomorphic type [[List Char]], and the list operations 
can not be directly applied to strings.
</para>
<!--====================================================================-->
<para>
The value of a `string-literal is the sequence of characters
denoted by the `string-literal-glyphs comprising its
`string-body, where
the value of a `significant-whitespace is the
whitespace character suggested by the `name (space,
horizontal tab or newline).
For example, the `string-literal [["seepage"]] is different
from [["see page"]]; the latter denotes an eight-character
string of which the fourth character is a space.
The space can be made explicit by using the `char-glyph
[[\s]].
</para>
<!--====================================================================-->
<para>
When a double-quote character[[ " ]]is needed in a string, it
must be escaped, as in [["[6'2\"]"]], which would print like
this: [[[6'2"]]].
</para>
</section>
</section>
<!-- ***************************************************************** -->
<section id="Field-selections"><title>Field-selections</title>
<para>
<<
||`field-selection ::= `closed-expression . `field-selector
||
||`field-selector ::= `nat-literal | `field-name
||
>>
<!-- No longer needed because of transformation to project F E ****
** Restriction.
** When the `field-selector is some `nat-literal with value
** $i$, the type of the
** `closed-expression must be a product type,
** and if the number of components of that product type is
** $n$, it must hold that
** $i$ is one of the values 1 through 
** $n$.
** When the `field-selector is some `field-name
** $F$, the type of the
** `closed-expression must be a record type, one of whose
** fields has that `field-name $F$.
** </para>
** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
** <para>
**** No longer needed because of transformation to project F E -->
Disambiguation.
A `closed-expression of the form
[[$M$.$N$]],
in which $M$ is a `word-symbol and
$N$ is a `simple-name, is interpreted as
an `op if
[[$M$.$N$]]
occurs as the `op-name of an `op-declaration or `op-definition
in the `spec in which it occurs or in the set of `simple-names
imported from another `spec through an `import-declaration.
Otherwise,
[[$M$.$N$]]
is interpreted as a `field-selection.
(The effect of a `field-selection can always be obtained
with a `projector.)
</para>
<!--====================================================================-->
<para>
Sample `field-selections:
[[
||    triple.2
||    z.re
]]
<!-- No longer needed because of transformation to project F E ****
** Let the tuple or record $v$ be the value of the
** `closed-expression of the `field-selection, and let the natural
** number $i$ be determined as follows.
** When the `field-selector is some `nat-literal
** $N$,
** $i$ is the value of
** $N$.
** When the `field-selector is some `field-name
** $F$, $i$
** is the position selected by $F$ in
** type $T$, as discussed under
** `Type-records.
** The value of the `field-selection is then the
** $i$th component of
** $v$.
**** No longer needed because of transformation to project F E -->
A `field-selection
[[$E$.$F$]]
is a convenient notation for the equivalent `expression
[[(project $F$]]
[[$E$)]].
(See under <link linkend="Projectors"><emphasis>Projectors</emphasis></link>.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Tuple-displays"><title>Tuple-displays</title>
<para>
<<
||`tuple-display ::= ( `tuple-display-body )
||
||`tuple-display-body ::= [ `expression , `expression { , `expression }* ]
||
>>
Sample `tuple-display:
[[
||    ("George", Poodle : Dog, 10)
]]
Note that a `tuple-display-body contains either no
`expressions, or else at least two.
</para>
<!--====================================================================-->
<para>
The value of a `tuple-display whose `tuple-display-body is
not empty, is the tuple whose
components are the respective values of the `expressions of
the `tuple-display-body, taken in textual order.
The type of that tuple is the <quote>product</quote> of the
corresponding types of the components.
The value of [[()]] is the empty tuple, which is the sole
inhabitant of the unit type [[()]].
(The fact that the notation [[()]] does double duty, for
a `type-descriptor and as an `expression, creates no ambiguity.
Note also that -- unlike the empty `list-display [[[]]] --
the `expression [[()]] is monomorphic, so
there is no need to ever annotate it with a `type-descriptor.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Record-displays"><title>Record-displays</title>
<para>
<<
||`record-display ::= '{ `record-display-body '}
||
||`record-display-body ::= [ `field-filler { , `field-filler }* ]
||
||`field-filler ::= `field-name `equals `expression
||
>>
Sample `record-display:
[[
||    {`name = "George", kind = Poodle : Dog, age = 10}
]]
The value of a `record-display is the record whose
components are the respective values of the `expressions of
the `record-display-body, taken in the lexicographic order
of the `field-names, as discussed under <link
linkend="Type-records"><emphasis>Type-records</emphasis></link>.
The type of that record is the record type with the same set
of `field-names, where the type for each `field-name
$F$ is the type of
the corresponding type of the component selected by
$F$ in the record.
The value of [[{}]] is the empty tuple, which is the sole
inhabitant of the unit type [[()]].
(For `expressions as well as for `type-descriptors, the notations
[[{}]] and [[()]] are fully interchangeable.)
</para>
</section>
<!-- ***************************************************************** -->
<section id="Sequential-expressions"><title>Sequential-expressions</title>
<para>
<<
||`sequential-expression ::= ( `open-sequential-expression )
||
||`open-sequential-expression ::= `void-expression ; `sequential-tail
||
||`void-expression ::= `expression
||
||`sequential-tail ::= `expression | `open-sequential-expression
>>
Sample `sequential-expression:
[[
||    (writeLine "key not found"; embed Missing)
]]
A `sequential-expression
[[($V$; $T$)]] is equivalent to the
`let-expression [[let _ = $V$ in]] [[($T$)]].
So the value of a `sequential-expression
[[($V$]]<subscript>1</subscript>[[;]]
... [[; $V$]]<subscript>n</subscript>[[; $E$)]]
is the value of its
last constituent `expression $E$.
</para>
<!--====================================================================-->
<para>
`Sequential-expressions can be used to achieve
non-functional <quote>side effects</quote>, effectuated by
the elaboration of the `void-expressions, in particular
the output of a message.
This is useful for tracing the execution of generated code.
The equivalent effect of the example above can be achieved
by a `let-binding:
[[
||    let _ = writeLine "key not found" in
||    embed Missing
]]
(If the intent is to temporarily add, and later remove or
disable the tracing output, this is probably a more convenient
style, as the modifications needed concern a single full text line.)
Any values resulting from elaborating the `void-expressions are
discarded.
</para>
</section>
<!-- ***************************************************************** -->
<section id="List-displays"><title>List-displays</title>
<para>
<<
||`list-display ::= '[ `list-display-body ']
||
||`list-display-body ::= [ `expression { , `expression }* ]
||
>>
Sample `list-display:
[[
||    ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
]]
Restriction.
All `expressions of the `list-display-body must have the
same type.
</para>
<!--====================================================================-->
<para>
Note that a `list-display [[[]]] with empty
`list-display-body is polymorphic, and may need to be
type-disambiguated, for example with a type annotation.
In a case like [[[[], [1]]]], there is no need to
disambiguate [[[]]], since the above restriction already
implies that [[[]]] here has the same type as [[[1]]],
which has type [[List Nat]].
</para>
<!--====================================================================-->
<para>
The parameterized type [[List]], although a base-library type, is
actually not primitive, but defined by:
[[
||    type List a =
||      | Nil
||      | Cons a * List a
]]
The empty `list-display [[[]]] denotes the same list as the
`expression [[Nil]], a singleton `list-display
[[[$E$]]] denotes the same
list as the `expression [[Cons
($E$, Nil)]], and a
multi-element `list-display
[[[$E<subscript>1</subscript>$, $E<subscript>2</subscript>$,]]
... [[,]] [[$E\<subscript>n\</subscript>$]]]
denotes the same list as the `expression [[Cons
($E<subscript>1</subscript>$,
[$E<subscript>2</subscript>$,]]
... [[,]] [[$E<subscript>n</subscript>$])]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Structors"><title>Structors</title>
<para>
<<
||`structor ::=
||      `projector
||    | `relaxator
||    | `quotienter
||    | `chooser
||    | `embedder
||    | `embedding-test
>>
<!-- *****************************************************************
<<    | `selector
>>
********************************************************************** -->
The `structors are a medley of constructs, all having polymorphic
or type-ambiguous function types and denoting special functions
that go between structurally related types, such as
the constructors of sum types and the destructors of product types.
</para>
<!--====================================================================-->
<para>
Restriction.
Like all polymorphic or type-ambiguous constructs, a `structor
can only be used in a context where its type can be inferred
uniquely.
This restriction will not be repeated for the various kinds
of `structors described in the following subsections.
</para>
<!--====================================================================-->
<para>
For example, the following well-formed `spec becomes ill formed when
any of the type annotations is omitted:
[[
||    spec
||      def [a] p2 = project 2 : String *  a  ->  a
||      def     q2 = project 2 : String * Nat -> Nat
||    endspec
]]
</para>
<!-- ***************************************************************** -->
<section id="Projectors"><title>Projectors</title>
<para>
<<
||`projector ::= project `field-selector
>>
Sample `projectors:
[[
||    project 2
||    project re
]]
When the `field-selector is some `nat-literal with value
$i$, it is required that
$i$ be at least 1.
The type of the
`projector is a function type (whose domain type is a product
type) of the form
$T$<subscript>1</subscript> [[* $T$]]<subscript>2</subscript> [[*]] ...
[[* $T<subscript>n</subscript>$ -> ]]$T<subscript>i</subscript>$,
where $n$ is at least
$i$,
and the value of the `projector is the function that maps
each
$n$-tuple
($v<subscript>1</subscript>$,
$v<subscript>2</subscript>$, ... ,
$v<subscript>n</subscript>$)
inhabiting the domain type 
to its $i$th component
$v<subscript>i</subscript>$.
</para>
<!--====================================================================-->
<para>
When the `field-selector is some `field-name
$F$,
the type of the
`projector is a function type (whose domain type is a record
type) of the form
[[{$F$]]<subscript>1</subscript>
[[: $T$]]<subscript>1</subscript>[[, $F$]]<subscript>2</subscript>
[[: $T$]]<subscript>2</subscript>[[,]]
...
[[, $F<subscript>n</subscript>$ : $T<subscript>n</subscript>$}]]
[[-> ]]$T<subscript>i</subscript>$,
where $F$ is the same `field-name
as
$F<subscript>i</subscript>$
for some natural number $i$ in the
range 1 through $n$.
Assuming that the fields are lexicographically ordered by
`field-name (see under <link
linkend="Type-records"><emphasis>Type-records</emphasis></link>),
the value of the `projector is the function that maps
each
$n$-tuple
($v<subscript>1</subscript>$,
$v<subscript>2</subscript>$, ... ,
$v<subscript>n</subscript>$)
inhabiting the domain type 
to its $i$th component
$v<subscript>i</subscript>$.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Relaxators"><title>Relaxators</title>
<para>
<<
||`relaxator ::= relax `closed-expression
>>
Sample `relaxator:
[[
||    relax even
]]
Restriction.
The `closed-expression of a `relaxator must have some function
type [[$T$ -> Boolean]].
</para>
<!--====================================================================-->
<para>
The type of `relaxator [[relax $P$]],
where $P$ has type
[[$T$ -> Boolean]], is the function
type (whose domain is a subtype) [[($T$ | $P$)]] [[-> $T$]].
The value of the `relaxator is the function that maps each
inhabitant of subtype
[[($T$ | $P$)]] to the same value --
apart from the type information -- inhabiting supertype
$T$.
</para>
<!--====================================================================-->
<para>
For example, given
[[
||    type Even = (Nat | even)
]]
we have the typing
[[
||    relax even : Even -> Nat
]]
for the function that injects the even natural numbers back
into the supertype of [[Even]].
</para>
<!--====================================================================-->
<para>
Metaslang does not require the explicit use of a `relaxator to relax
an `expression from a subtype to its supertype if the
context requires the latter.
Implicit relaxation will take place when needed.
For example, in the `expression [[-1]] the `nat-literal [[1]]
of type [[Nat]] is implicitly relaxed to type [[Integer]] to
accommodate the unary negation operator [[-]], which has type
[[Integer -> Integer]].
</para>
<!--====================================================================-->
<para>
Note the remarks about equivalence of `type-restrictions in
the corresponding section.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Quotienters"><title>Quotienters</title>
<para>
<<
||`quotienter ::= quotient `closed-expression
>>
Sample `quotienter:
[[
||     quotient (fn (m, n) -> m rem 3 = n rem 3)
]]
Restriction.
The `closed-expression of a `quotienter must have some type
[[$T$ * $T$ -> Boolean]];
in addition, it must be an equivalence relation, as explained
under <link
linkend="Type-quotients"><emphasis>Type-quotients</emphasis></link>.
</para>
<!--====================================================================-->
<para>
The type of `quotienter [[quotient $Q$]],
where $Q$ has type
[[$T$ * $T$ -> Boolean]], is the function type
[[$T$ -> $T$ / $Q$]], that is, it goes from some
type to one of its quotient types.
The value of the `quotienter is the function that maps each
inhabitant of type $T$ to the
$Q$-equivalence class inhabiting [[$T$ /]] 
$Q$ of which it is a member.
</para>
<!--====================================================================-->
<para>
For example, given
[[
||    def congMod3 : Nat * Nat -> Boolean =
||      (fn (m, n) -> m rem 3 = n rem 3)
||
||    type Z3 = Nat / congMod3
]]
we have the typing
[[
||    quotient congMod3 : Nat -> Z3
]]
and the function maps, for example, the number 5 to the
equivalence class {2, 5, 8, ...}, which is one of the three
inhabitants of [[Z3]].
</para>
</section>
<!-- ***************************************************************** -->
<section id="Choosers"><title>Choosers</title>
<para>
<<
||`chooser ::= choose `closed-expression
>>
Sample `chooser:
[[
||    choose congMod3
]]
Restriction.
In a `chooser [[choose $Q$]],
`expression $Q$ must have some type
[[$T$ * $T$ -> Boolean]], and must be an equivalence relation (see under
<link linkend="Type-quotients"><emphasis>Type-quotients</emphasis></link>).
</para>
<!--====================================================================-->
<para>
The type of a `chooser [[choose $Q$]],
where $Q$ has type
[[$S$ * $S$ -> Boolean]], is a function type of the form
$R$ [[->]]
[[($S$ /
$Q$ ->
$T$)]], where
$R$ is the subtype of
[[$S$ -> $T$]]
consisting of the $Q$-constant
(explained below) functions.
Expressed more formally, $R$ is the type
[[{f :]] [[$S$ ->
$T$]] [[| fa((x,y) :]]
$S$ [[*]]
[[$S$)]]
[[$Q$(x,y) => f x = f y}]],
where the `simple-names [[f]], [[x]] and [[y]] must be replaced by
``fresh'' `simple-names not clashing with `simple-names already in use in
$S$,
$T$ or
$Q$.
</para>
<!--====================================================================-->
<para>
The value of the `chooser is the
function mapping each $Q$-constant
(explained below) function $f$ inhabiting type
[[$S$ -> $T$]] to the function that maps 
each inhabitant $C$ of
[[$S$ / $Q$]] to $f$
$x$, where
$x$ is any member of
$C$.
Expressed symbolically, using a pseudo-function [[any]] that
arbitrarily picks any member from a nonempty set, this is
the function
[[
||    fn f -> fn C -> f (any C)
]]
The requirement of $Q$-constancy
is precisely what is needed to make this function insensitive
to the choice made by [[any]].
</para>
<!--====================================================================-->
<para>
Function $f$ is
$Q$-constant if,
for each $Q$-equivalence class
$C$ inhabiting
[[$S$ / $Q$]],
$f$ $x$
equals $f$
$y$ for any two values
$x$ and
$y$ that are members of
$C$,
or $f$ is undefined on all members of
$C$.
(Since the result of $f$ is
constant across each equivalence class, it does not matter
which of its elements is selected by [[any]].)
For example -- continuing the example of the previous section --
function [[fn n -> n*n rem 3]] is [[congMod3]]-constant;
for the equivalence class {2, 5, 8, ...}, for example, it
maps each member to the same value 1.
So [[choose congMod3 (fn n -> n*n rem 3)]] maps the inhabitant
{2, 5, 8, ...} of type [[Z3]] to the natural number 1.
</para>
<!--====================================================================-->
<para>
The most discriminating
$Q$-constant function is
[[quotient $Q$]], and
[[choose $Q$ quotient $Q$]] is the identity function on the
quotient type for $Q$.
</para>
<!--====================================================================-->
<para>
The meaning of [[choose $Q$ (fn x -> $E$) $A$]]
is the same as that of the `let-expression
[[let quotient $Q$ x = $A$ in $E$]].
Indeed, often a `quotient-pattern offers a more convenient 
way of expressing the intention of a `chooser.
Note, however, the remarks on the proof obligations for
`quotient-patterns.
</para>
</section>
<!-- ***************************************************************** -->
<section id="Embedders"><title>Embedders</title>
<para>
<<
||`embedder ::= [ embed ] `constructor
>>
Sample `embedders:
[[
||    Nil
||    embed Nil
||    Cons
||    embed Cons
]]
Disambiguation.
If an `expression consists of a single `simple-name, which, in the
context, is both the `simple-name of a `constructor and the `simple-name
of an `op or a `local-variable in scope, then it is
interpreted as the latter of the various possibilities.
For example, in the context of
[[
||    type Answer = | yes | no
||
||    def yes = no : Answer
||
||    def which (a : Answer) = case a of
||      | yes -> "Yes!"
||      | no  -> "Oh, no!"
]]
the value of [[which yes]] is [["Oh, no!"]], since [[yes]]
here is disambiguated as identifying the `op [[yes]], which
has value [[no]].
The interpretation as `embedder is forced by using
the [[embed]] keyword:
the value of [[which embed yes]] is [["Yes!"]].
By using `simple-names that begin with a capital `letter for
`constructors, and 
`simple-names that do not begin with a capital `letter for
`ops and `local-variables, the risk of an accidental wrong
interpretation can be avoided.
</para>
<!-- ================================================================= -->
<para>
The semantics of `embedders is described in the section on
<link linkend="Type-sums"><emphasis>Type-sums</emphasis></link>.
The presence or absence of the keyword [[embed]] is not
significant for the meaning of the construct (although it
may be required for grammatical disambiguation, as described
above).
</para>
</section>
<!-- ***************************************************************** -->
<section id="Embedding-tests"><title>Embedding-tests</title>
<para>
<<
||`embedding-test ::= embed? `constructor
>>
Sample `embedding-test:
[[
||    embed? Cons
]]
Restriction.
The type of an `embedding-test [[embed? $C$]] must be of the form
[[$T$ -> Boolean]], where
$T$ is a sum type that has a
`constructor $C$.
</para>
<!-- ================================================================= -->
<para>
The value of `embedding-test [[embed? $C$]] is the predicate that returns
[[true]] if the argument value -- which, as inhabitant of a
sum type, is tagged -- has tag $C$,
and otherwise [[false]].
The `embedding-test can be equivalently rewritten as
[[
||    fn
||     | $C$ _  ->  true
||     | _    ->  false
]]
where the wildcard [[_]] in the first `branch is omitted when
$C$ is parameter-less.
</para>
<!-- ================================================================= -->
<para>
In plain words, [[embed? $C$]]
tests whether its sum-typed argument has been constructed with the
`constructor $C$.
It is an error when $C$ is not a
constructor of the sum type.
</para>
</section>
<!-- ***************************************************************** -->
<!-- *****************************************************************
** <section id="Selectors"><title>Selectors</title>
** <para>
** <<
** ||`selector ::= select `constructor
** >>
** </para>
** </section>
********************************************************************** -->
</section>
</section>
<section id="MatchesAndPatterns"><title>Matches and Patterns</title>
<!--  ***************************************************************** -->
<section id="Matches"><title>Matches</title>
<para>
<<
||`match ::= [ '| ] `branch { '| `branch }*
||
||`branch ::= `pattern -> `expression
||
>>
Sample `matches:
[[
||    {re = x, im = y} -> {re = x, im = -y}
||
||      Empty -> true
||    | Push {top = _, pop = rest} -> hasBottom? rest
||
||    | Empty -> true
||    | Push {top = _, pop = rest} -> hasBottom? rest
]]
Restriction.
In a `match, given the environment, there must be a
unique type $T$ to which the `pattern
of each `branch conforms, and a unique type
$T$ to which the `expression of each
`branch conforms, and then the `match has type
[[$S$ -> $T$]].
The `pattern of each `branch then has
type $S$.
</para>
<!-- ================================================================= -->
<para>
Disambiguation.
If a `branch could belong to several open `matches, it is
interpreted as being a `branch of the textually most recently
introduced `match.
For example,
[[
||   case x of
||     | A -> a
||     | B -> case y of
||              | C -> c
||     | D -> d
]]
is not interpreted as suggested by the indentation, but as
[[
||   case x of
||     | A -> a
||     | B -> (case y of
||               | C -> c
||               | D -> d)
]]
If the other interpretation is intended, the `expression
introducing the inner `match needs to be parenthesized:
[[
||   case x of
||     | A -> a
||     | B -> (case y of
||               | C -> c)
||     | D -> d
]]
</para>
<!-- ================================================================= -->
<para>
Acceptance and return value $y$, if
any, of a value $x$ for a given `match
are determined as follows.
If each `branch of the `match rejects
$x$ (see below), the whole `match
rejects $x$, and does not return
a value.
Otherwise, let $B$ stand for the
textually first `branch accepting $x$.
Then $y$ is the return value of
$x$ for $B$.
</para>
<!-- ================================================================= -->
<para>
Acceptance and return value $y$, if
any, of a value $x$ for a `branch
[[$P$ -> $E$]] in an environment
$C$ are determined as follows.
If `pattern $P$ rejects
$x$, the `branch rejects
$x$, and does not return a value.
(For acceptance by a `pattern, see under <link linkend="Patterns"><emphasis>Patterns</emphasis></link>.)
Otherwise, $y$ is the value of
`expression $E$ in the environment
$C$ extended with the acceptance
binding of `pattern $P$ for
$x$.
</para>
<!-- ================================================================= -->
<para>
For example, in
[[
||   case z of
||     | (x, true)  -> Some x
||     | (_, false) -> None
]]
if [[z]] has value [[(3, true)]], the first branch accepts this
value with acceptance binding [[x = 3]].
The value of [[Some x]] in the extended environment
is then [[Some 3]].
If [[z]] has value [[(3, false)]], the second branch accepts this
value with empty acceptance binding (empty since there are no
<quote>accepting</quote> `local-variables in `pattern
[[(_, false)]]), and the return value is [[None]]
(interpreted in the original environment).
</para>
</section>
<!--  ***************************************************************** -->
<section id="Patterns"><title>Patterns</title>
<para>
<<
||`pattern ::=
||      `annotated-pattern
||    | `tight-pattern
||
||`tight-pattern ::=
||      `aliased-pattern
||    | `cons-pattern
||    | `embed-pattern
||    | `quotient-pattern
||    | `relax-pattern
||    | `closed-pattern
||
||`closed-pattern ::=
||      `variable-pattern
||    | `wildcard-pattern
||    | `literal-pattern
||    | `list-pattern
||    | `tuple-pattern
||    | `record-pattern
||    | ( `pattern )
>>
(As for `expressions, the distinctions `tight- and `closed- for
`patterns have no semantic significance, but merely serve to
avoid grammatical ambiguities.)
<<
||
||`annotated-pattern ::= `pattern : `type-descriptor
||
||`aliased-pattern ::= `variable-pattern as `tight-pattern
||
||`cons-pattern ::= `closed-pattern :: `tight-pattern
||
||`embed-pattern ::= `constructor [ `closed-pattern ]
||
||`quotient-pattern ::= quotient `closed-expression `tight-pattern
||
||`relax-pattern ::= relax `closed-expression `tight-pattern
||
||`variable-pattern ::= `local-variable
||
||`wildcard-pattern ::= _
||
||`literal-pattern ::= `literal
||
||`list-pattern ::= '[ `list-pattern-body ']
||
||`list-pattern-body ::= [ `pattern { , `pattern }* ]
||
||`tuple-pattern ::= ( `tuple-pattern-body )
||
||`tuple-pattern-body ::= [ `pattern , `pattern { , `pattern }* ]
||
||`record-pattern ::= '{ `record-pattern-body '}
||
||`record-pattern-body ::= [ `field-patterner { , `field-patterner }* ]
||
||`field-patterner ::= `field-name [ `equals `pattern ]
>>
Sample `patterns:
[[
||    (i, p) : Integer * Boolean
||    z as {re = x, im = y}
||    hd :: tail
||    Push {top, pop = rest}
||    embed Empty
||    quotient congMod3 n
||    relax even e
||    x
||    _
||    #z
||    [0, x]
||    (c1 as (0, _), x)
||    {top, pop = rest}
]]
Restriction.
Like all polymorphic or type-ambiguous constructs, a `pattern
may only be used in a context where its type can be uniquely
inferred.
</para>
<!--====================================================================-->
<para>
Disambiguation.
A single `simple-name used as a `pattern is an `embed-pattern
if it is a `constructor of the type of the `pattern.
Otherwise, the `simple-name is a `variable-pattern.
</para>
<!--====================================================================-->
<para>
Restriction.
Each `local-variable in a `pattern must be a different
`simple-name, disregarding any `local-variables introduced in
`expressions or `type-descriptors contained in the `pattern.
(For example, [[Line (z, z)]] is not a lawful `pattern,
since [[z]] is repeated; but [[n : {n : Nat | n < p}]]
is lawful: the second [[n]] is <quote>shielded</quote> by
the `type-comprehension in which it occurs.)
</para>
<!--  ================================================================= -->
<para>
Restriction.
The `closed-expression of a `quotient-pattern must have some type
[[$T$ * $T$ -> Boolean]];
in addition, it must be an equivalence relation, as explained
under <link
linkend="Type-quotients"><emphasis>Type-quotients</emphasis></link>.
</para>
<!--  ================================================================= -->
<para>
Restriction.
`Quotient-patterns may only be used in a `definition or
`claim if the result is insensitive to the choice of representative
from the equivalence class.
&SpecwareV; does not attempt to generate proof obligations for
establishing this.
</para>
<!--  ================================================================= -->
<para>
Restriction.
The `closed-expression of a `relax-pattern must have some function
type [[$T$ -> Boolean]].
</para>
<!--  ================================================================= -->
<para>
To define acceptance and acceptance binding (if any)
for a value and a `pattern, we introduce a number of
auxiliary definitions.
</para>
<!--  ================================================================= -->
<para>
The <emphasis>accepting</emphasis> `local-variables of a `pattern
$P$ are
the collection of `local-variables occurring in
$P$,
disregarding any `local-variables introduced in
`expressions or `type-descriptors contained in the
$P$.
For example, in `pattern [[u : {v : S | p v}]], [[u]] is an
accepting `local-variable, but [[v]] is not.  (The latter is an
accepting `local-variable of `pattern [[v : S]], but not of the
larger `pattern.)
</para>
<!--  ================================================================= -->
<para>
The <emphasis>expressive descendants</emphasis> of a
`pattern are a finite set of `expressions having the
syntactic form of `patterns, as determined in the
following three steps (of which the order of steps 1 and 2
is actually immaterial).
</para>
<!--  ================================================================= -->
<para>
Step 1.  From `pattern $P$, form some
<emphasis>tame variant</emphasis>
$P<subscript>t</subscript>$ by
replacing each `field-patterner consisting of a single
`field-name $F$ by the
`field-patterner [[$F$ = $F$]]
and replacing each `wildcard-pattern [[_]] in
$P$ by a unique fresh `simple-name, that is,
any `simple-name that does not already occur in the `spec, directly or
indirectly through an import.
For example, assuming that the `simple-name [[v7944]]
is fresh, a tame variant of
[[
||    s0 as _ :: s1 as (Push {top, pop = rest}) :: ss
]]
is
[[
||    s0 as v7944 :: s1 as (Push {top = top, pop = rest}) :: ss
]]
</para>
<!--  ================================================================= -->
<para>
Step 2.  Next, from
$P<subscript>t</subscript>$, form a
(tamed) <emphasis>construed version</emphasis>
$P<subscript>tc</subscript>$ by
replacing each constituent `cons-pattern
[[$H$ :: $T$]]
by the `embed-pattern [[Cons
($H$, $T$)]], where [[Cons]] denotes the
`constructor of the parameterized type [[List]].
For the example, the construed version is:
[[
||    s0 as Cons (v7944,
||                s1 as Cons (Push {top = top, pop = rest}, ss))
]]
</para>
<!--  ================================================================= -->
<para>
Step 3.  Finally, from
$P<subscript>tc</subscript>$, form
the set $ED<subscript>P</subscript>$ of
<emphasis>expressive descendants</emphasis> of
$P$, where
`expression $E$ is an
expressive descendant
if $E$
can be obtained by repeatedly replacing some constituent
`aliased-pattern [[$L$ as $R$]]
of $P<subscript>tc</subscript>$
by one of the two `patterns
$L$ and
$R$ until no `aliased-patterns
remain, and then interpreting the result as an `expression.
For the example, the expressive descendants
are the three `expressions:
[[
||    s0
||    Cons (v7944, s1)
||    Cons (v7944, Cons (Push {top = top, pop = rest}, ss))
]]
</para>
<!--  ================================================================= -->
<para>
An <emphasis>accepting binding</emphasis> of a `pattern
$P$ for a value
$x$ in an environment
$C$ is some
binding $B$ of typed
values to the accepting `local-variables of the
<emphasis>tame</emphasis> variant
$P<subscript>t</subscript>$,
such that the value of each expressive descendant
$E$ in
$ED<subscript>P</subscript>$
in the environment
$C$ extended with binding
$B$, is the same typed value as
$x$.
</para>
<!--  ================================================================= -->
<para>
Acceptance and acceptance binding, if any,
for a value $x$ and a `pattern
$P$
are then determined as follows.
If there is no accepting binding of
$P$ for
$x$,
$x$ is rejected.
If an accepting binding exists, the value
$x$ is accepted by `pattern
$P$.
There is a unique binding
$B$ among the accepting bindings in
which the type of each assigned value is as
<quote>restricted</quote> as possible in the subtype-supertype
hierarchy without violating well-typedness constraints (in
other words, there are no avoidable implicit relaxations).
The acceptance binding is then the binding
$B$ <emphasis>projected
on</emphasis> the accepting `local-variables of
$P$.
</para>
<!--  ================================================================= -->
<para>
For the example, the accepting `local-variables of
$P<subscript>t</subscript>$ are the
six `local-variables [[s0]], [[s1]], [[ss]], [[rest]] and
[[v7944]].
In general, they are the accepting `local-variables of the
original `pattern together with any fresh `simple-names used for
taming.
Let the value $x$ being matched
against the pattern be
[[
||    Cons (Empty, Cons (Push {top = 200, pop = Empty}, Nil))
]]
Under the accepting binding
[[
||    s0 = Cons (Empty, Cons (Push {top = 200, pop = Empty}, Nil))
||    s1 = Cons (Push {top = 200, pop = Empty}, Nil)
||    ss = Nil
||    top = 200
||    rest = Empty
||    v7944 = Empty
]]
the value of each $E$ in
$ED<subscript>P</subscript>$
amounts to the value $x$.
Therefore, $x$ is accepted by the
original `pattern, with acceptance binding
[[
||    s0 = Cons (Empty, Cons (Push {top = 200, pop = Empty}, Nil))
||    s1 = Cons (Push {top = 200, pop = Empty}, Nil)
||    ss = Nil
||    top = 200
||    rest = Empty
]]
obtained by <quote>forgetting</quote> the fresh `simple-name
[[v7944]].
</para>
</section>
</section>
<!-- *****************************************************************

TODO:

More type-correctness restrictions.
Unification, monomorphicity restriction.
Unspecified op types.

Constructive

Test constructs used

At Semantics: transformational semantics.

Relationship choose & quotient?

Relax not needed.

**********************************************************************

Wishes for further syntax changes:

<< `formal-application-head +::= ( `formal-application ) >>

Allow [[op]] for [[def]].

Allow [[def type]] and [[def op]].

(Maybe) Allow [[type op]] for infix parameterized types.

Allow
[[
||    def o : [a,b,c] (b -> c) * (a -> b) -> a -> c =
||      fn (f, g) -> fn (x) -> f(g x)
]]
or
[[
||    op [a,b,c] o : (b -> c) * (a -> b) -> a -> c
]]
or both

********************************************************************** -->
</chapter>
