<appendix id="grammar"><title>&Metaslang; Grammar</title>
<!-- ***************************************************************** -->
<para>
This appendix lists the grammar rules of the &Metaslang; specification language.
These rules are identical to those of the <link linkend="metaslang">Chapter
on <emphasis>&Metaslang;</emphasis></link>.
They are brought together here, without additional text, for
easy reference.
</para>
<!-- ***************************************************************** -->
<formalpara><title>Models</title>
<para>
<<
||  `spec ::= `spec-form
||  
||  `op ::= `op-name
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Symbols and Names</title>
<para>
<<
||  `symbol ::= `name | `literal | `special-symbol
||  
||  `name ::= `word-symbol | `non-word-symbol
||  
||  `word-symbol ::= `word-start-mark { `word-continue-mark }*
||  
||  `word-start-mark ::= `letter
||  
||  `word-continue-mark ::=
||    `letter | `decimal-digit | _ | ?
||  
||  `letter ::=
||      A | B | C | D | E | F | G | H | I | J | K | L | M
||    | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
||    | a | b | c | d | e | f | g | h | i | j | k | l | m
||    | n | o | p | q | r | s | t | u | v | w | x | y | z
||  
||  `decimal-digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
||  
||  `non-word-symbol ::= `non-word-mark { `non-word-mark }*
||  
||  `non-word-mark ::=
||      ` | ~ | ! | @ | $ | ^ | & | * | -
||    | = | + | \ | '| | : | < | > | / | ?
||  
||  `special-symbol ::= _ | ( | ) | '[ | '] | '{ | '} | ; | , | .
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Comments</title>
<para>
<<
||  `comment ::= `line-end-comment | `block-comment
||  
||  `line-end-comment ::= % `line-end-comment-body
||  
||  `line-end-comment-body ::=
||    `any-text-up-to-end-of-line
||  
||  `block-comment ::= (* `block-comment-body *)
||  
||  `block-comment-body ::=
||    `any-text-including-newlines-and-nested-block-comments
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Units</title>
<para>
<<
||  `unit-definition ::= `unit-identifier = `unit-term
||  
||  `unit-term ::=
||     `spec-term
||   | `morphism-term
||   | `diagram-term
||   | `target-code-term
||   | `proof-term
||  
||  `specware-file-contents ::=
||     `unit-term
||   | `infile-unit-definition { `infile-unit-definition }*
||  
||  `infile-unit-definition ::= `fragment-identifier = `unit-term
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Unit Identifiers</title>
<para>
<<
||  `unit-identifier ::= `swpath-based-path | `relative-path
||  
||  `swpath-based-path ::= / `relative-path
||  
||  `relative-path ::= { `path-element / }* `path-element [ # `path-element ]
||  
||  `path-element ::= `word-symbol
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Specs</title>
<para>
<<
||  `spec-term ::=
||     `unit-identifier
||   | `spec-form
||   | `spec-qualification
||   | `spec-translation
||   | `spec-substitution
||   | `diagram-colimit
||   | `obligator
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Spec Forms</title>
<para>
<<
||  `spec-form ::= spec { `declaration }* endspec
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Qualifications</title>
<para>
<<
||  `spec-qualification ::=  `qualifier qualifying `spec-term
||  
||  `qualifier ::= `word-symbol
||  
||  `qualifiable-name ::= `unqualified-name | `qualified-name
||  
||  `unqualified-name ::= `name
||  
||  `qualified-name ::= `qualifier . `name
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Translations</title>
<para>
<<
||  `spec-translation ::= translate `spec-term by `name-map
||  
||  `name-map ::= '{ [ `name-map-item { , `name-map-item }* ] '}
||  
||  `name-map-item ::= `sort-name-map-item | `op-name-map-item
||  
||  `sort-name-map-item ::= [ sort ] `qualifiable-name +-> `qualifiable-name
||  
||  `op-name-map-item ::=
||      [ op ] `annotable-qualifiable-name +-> `annotable-qualifiable-name
||  
||  `annotable-qualifiable-name ::= `qualifiable-name [ : `sort ]
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Substitutions</title>
<para>
<<
||  `spec-substitution ::= `spec-term '[ `morphism-term ']
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Diagram Colimits</title>
<para>
<<
||  `diagram-colimit ::= colimit `diagram-term
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Obligators</title>
<para>
<<
||  `obligator ::= obligations `unit-term
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Morphisms</title>
<para>
<<
||  `morphism-term ::=
||     `unit-identifier
||   | `spec-morphism
||  
||  `spec-morphism ::= morphism `spec-term -> `spec-term `name-map
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Diagrams</title>
<para>
<<
||  `diagram-term ::=
||     `unit-identifier
||   | `diagram-form
||  
||  `diagram-form ::= diagram '{ `diagram-element { , `diagram-element }* '}
||  
||  `diagram-element ::=
||     `diagram-node
||   | `diagram-edge
||  
||  `diagram-node ::= `name +-> `spec-term
||  
||  `diagram-edge ::= `name : `name -> `name +-> `morphism-term
||     
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Generate Terms</title>
<para>
<<
||  `target-code-term ::=
||      generate `target-language-name `spec-term [ in `string-literal ]
||  
||  `target-language-name ::= lisp
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Proof Terms</title>
<para>
<<
||  `proof-term ::=
||      prove `claim-name in `spec-term
||                      [ with `prover-name ]
||                      [ using '{ `claim-list '} ]
||                      [ options `prover-options ]
||  
||  `prover-name ::= snark
||  
||  `claim-list ::= `claim-name { , `claim-name }*
||  
||  `prover-options ::= `string-literal
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Declarations</title>
<para>
<<
||  `declaration ::=
||      `import-declaration
||    | `sort-declaration
||    | `op-declaration
||    | `definition
||  
||  `definition ::=
||      `sort-definition
||    | `op-definition
||    | `claim-definition
||  
||  `equals ::= is | =
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Import-declarations</title>
<para>
<<
||  `import-declaration ::= import `spec-term
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-declarations</title>
<para>
<<
||  `sort-declaration ::= sort `sort-name [ `formal-sort-parameters ]
||  
||  `formal-sort-parameters ::= `local-sort-variable | ( `local-sort-variable-list )
||  
||  `local-sort-variable ::= `name
||  
||  `local-sort-variable-list ::= `local-sort-variable { , `local-sort-variable }*
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-definitions</title>
<para>
<<
||  `sort-definition ::= sort `sort-name [ `formal-sort-parameters ] `equals `sort
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Op-declarations</title>
<para>
<<
||  `op-declaration ::= op `op-name [ `fixity ] : `sort-scheme
||  
||  `fixity ::= `associativity `priority
||  
||  `associativity ::= infixl | infixr
||  
||  `priority ::= `nat-literal
||  
||  `sort-scheme ::= [ `sort-variable-binder ] `sort
||  
||  `sort-variable-binder ::= fa ( `local-sort-variable-list )
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Op-definitions</title>
<para>
<<
||  `op-definition ::=
||    def [ `sort-variable-binder ] `formal-expression [ : `sort ] `equals
||        `expression
||  
||  `formal-expression ::= `op-name | `formal-application
||  
||  `formal-application ::= `formal-application-head `formal-parameter
||  
||  `formal-application-head ::= `op-name | `formal-application
||  
||  `formal-parameter ::= `closed-pattern
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Claim-definitions</title>
<para>
<<
||  `claim-definition ::= `claim-kind `claim-name `equals `claim
||  
||  `claim-kind ::= axiom | theorem | conjecture
||  
||  `claim-name ::= `name
||  
||  `claim ::= [ `sort-quantification ] `expression
||  
||  `sort-quantification ::= sort `sort-variable-binder
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sorts</title>
<para>
<<
||  `sort ::=
||      `sort-sum
||    | `sort-arrow
||    | `slack-sort
||  
||  `slack-sort ::=
||      `sort-product
||    | `tight-sort
||  
||  `tight-sort ::=
||      `sort-instantiation
||    | `closed-sort
||  
||  `closed-sort ::=
||      `sort-name
||    | `local-sort-variable
||    | `sort-record
||    | `sort-restriction
||    | `sort-comprehension
||    | `sort-quotient
||    | ( `sort )
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-sums</title>
<para>
<<
||  `sort-sum ::= `sort-summand { `sort-summand }*
||  
||  `sort-summand ::= '| `constructor [ `slack-sort ]
||  
||  `constructor ::= `name
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-arrows</title>
<para>
<<
||  `sort-arrow ::= `arrow-source -> `sort
||  
||  `arrow-source ::= `sort-sum | `slack-sort
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-products</title>
<para>
<<
||  `sort-product ::= `tight-sort * `tight-sort { * `tight-sort }*
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-instantiations</title>
<para>
<<
||  `sort-instantiation ::= `sort-name `actual-sort-parameters
||  
||  `actual-sort-parameters ::= `closed-sort | ( `proper-sort-list )
||  
||  `proper-sort-list ::= `sort , `sort { , `sort }*
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-names</title>
<para>
<<
||  `sort-name ::= `qualifiable-name
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-records</title>
<para>
<<
||  `sort-record ::= '{ [ `field-sorter-list ] '} | ( )
||  
||  `field-sorter-list ::= `field-sorter { , `field-sorter }*
||  
||  `field-sorter ::= `field-name : `sort
||  
||  `field-name ::= `name
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-restrictions</title>
<para>
<<
||  `sort-restriction ::= ( `slack-sort '| `expression )
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-comprehensions</title>
<para>
<<
||  `sort-comprehension ::= '{ `annotated-pattern '| `expression '}
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sort-quotients</title>
<para>
<<
||  `sort-quotient ::= `closed-sort / `closed-expression
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Expressions</title>
<para>
<<
||  `expression ::=
||      `lambda-form
||    | `case-expression
||    | `let-expression
||    | `if-expression
||    | `quantification
||    | `tight-expression
||  
||  `tight-expression ::=
||      `application
||    | `annotated-expression
||    | `restricted-expression
||    | `closed-expression
||  
||  `closed-expression ::=
||      `op-name
||    | `local-variable
||    | `literal
||    | `field-selection
||    | `tuple-display
||    | `record-display
||    | `sequential-expression
||    | `list-display
||    | `structor
||    | ( `expression )
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Lambda-forms</title>
<para>
<<
||  `lambda-form ::= fn `match
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Case-expressions</title>
<para>
<<
||  `case-expression ::= case `expression of `match
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Let-expressions</title>
<para>
<<
||  `let-expression ::= let `let-bindings in `expression
||  
||  `let-bindings ::= `recless-let-binding | `rec-let-binding-sequence
||  
||  `recless-let-binding ::= `pattern `equals `expression
||  
||  `rec-let-binding-sequence ::= `rec-let-binding { `rec-let-binding }*
||  
||  `rec-let-binding ::=
||    def `name `formal-parameter-sequence [ : `sort ] `equals `expression
||  
||  `formal-parameter-sequence ::= `formal-parameter { `formal-parameter }*
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>If-expressions</title>
<para>
<<
||  `if-expression ::= if `expression then `expression else `expression
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Quantifications</title>
<para>
<<
||  `quantification ::= `quantifier ( `local-variable-list ) `expression
||  
||  `quantifier ::= fa | ex
||  
||  `local-variable-list ::= `annotable-variable { , `annotable-variable }*
||  
||  `annotable-variable ::= `local-variable [ : `sort ]
||  
||  `local-variable ::= `name
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Applications</title>
<para>
<<
||  `application ::= `prefix-application | `infix-application
||  
||  `prefix-application ::= `application-head `actual-parameter
||  
||  `application-head ::= `closed-expression | `prefix-application
||  
||  `actual-parameter ::= `closed-expression
||  
||  `infix-application ::= `actual-parameter `op-name `actual-parameter
>>
</appendix>
