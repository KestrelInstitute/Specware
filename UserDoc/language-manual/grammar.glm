<appendix id="grammar"><title>&Metaslang; Grammar</title>
<!-- ***************************************************************** -->
<para>
This appendix lists the grammar rules of the &Metaslang; specification language.
These rules are identical to those of the <link linkend="metaslang">Chapter
on <emphasis>&Metaslang;</emphasis></link>.
They are brought together here, without additional text, for
easy reference.
</para>
<!-- ***************************************************************** -->
<formalpara><title>Models</title>
<para>
<<
||  `op ::= `op-name
>>
<<
||  `spec ::= `spec-form
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Symbols and Names</title>
<para>
<<
||  `symbol ::= `name | `literal | `special-symbol
||  
||  `name ::= `word-symbol | `non-word-symbol
||  
||  `word-symbol ::= `word-start-mark { `word-continue-mark }*
||  
||  `word-start-mark ::= `letter
||  
||  `word-continue-mark ::=
||    `letter | `decimal-digit | _ | ?
||  
||  `letter ::=
||      A | B | C | D | E | F | G | H | I | J | K | L | M
||    | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
||    | a | b | c | d | e | f | g | h | i | j | k | l | m
||    | n | o | p | q | r | s | t | u | v | w | x | y | z
||  
||  `decimal-digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
||  
||  `non-word-symbol ::= `non-word-mark { `non-word-mark }*
||  
||  `non-word-mark ::=
||      ` | ~ | ! | @ | $ | ^ | & | * | -
||    | = | + | \ | '| | : | < | > | / | ?
||  
||  `special-symbol ::= _ | ( | ) | '[ | '] | '{ | '} | ; | , | .
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Comments</title>
<para>
<<
||  `comment ::= `line-end-comment | `block-comment
||  
||  `line-end-comment ::= % `line-end-comment-body
||  
||  `line-end-comment-body ::=
||    `any-text-up-to-end-of-line
||  
||  `block-comment ::= (* `block-comment-body *)
||  
||  `block-comment-body ::=
||    `any-text-including-newlines-and-nested-block-comments
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Units</title>
<para>
<<
||  `unit-definition ::= `unit-identifier = `unit-term
||  
||  `unit-term ::=
||     `spec-term
||   | `morphism-term
||   | `diagram-term
||   | `target-code-term
||   | `proof-term
||  
||  `specware-file-contents ::=
||     `unit-term
||   | `infile-unit-definition { `infile-unit-definition }*
||  
||  `infile-unit-definition ::= `fragment-identifier = `unit-term
||  
||  `fragment-identifier ::= `word-symbol
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Unit Identifiers</title>
<para>
<<
||  `unit-identifier ::= `swpath-based-path | `relative-path
||  
||  `swpath-based-path ::= / `relative-path
||  
||  `relative-path ::= { `path-element / }* `path-element [ # `fragment-identifier ]
||  
||  `path-element ::= `word-symbol
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Specs</title>
<para>
<<
||  `spec-term ::=
||     `unit-identifier
||   | `spec-form
||   | `spec-qualification
||   | `spec-translation
||   | `spec-substitution
||   | `diagram-colimit
||   | `obligator
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Spec Forms</title>
<para>
<<
||  `spec-form ::= spec { `declaration }* endspec
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Qualifications</title>
<para>
<<
||  `spec-qualification ::=  `qualifier qualifying `spec-term
||  
||  `qualifier ::= `word-symbol
||  
||  `qualifiable-name ::= `unqualified-name | `qualified-name
||  
||  `unqualified-name ::= `name
||  
||  `qualified-name ::= `qualifier . `name
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Translations</title>
<para>
<<
||  `spec-translation ::= translate `spec-term by `name-map
||  
||  `name-map ::= '{ [ `name-map-item { , `name-map-item }* ] '}
||  
||  `name-map-item ::= `type-name-map-item | `op-name-map-item
||  
||  `type-name-map-item ::= [ type ] `qualifiable-name +-> `qualifiable-name
||  
||  `op-name-map-item ::=
||      [ op ] `annotable-qualifiable-name +-> `annotable-qualifiable-name
||  
||  `annotable-qualifiable-name ::= `qualifiable-name [ : `type-descriptor ]
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Substitutions</title>
<para>
<<
||  `spec-substitution ::= `spec-term '[ `morphism-term ']
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Diagram Colimits</title>
<para>
<<
||  `diagram-colimit ::= colimit `diagram-term
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Obligators</title>
<para>
<<
||  `obligator ::= obligations `unit-term
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Morphisms</title>
<para>
<<
||  `morphism-term ::=
||     `unit-identifier
||   | `spec-morphism
||  
||  `spec-morphism ::= morphism `spec-term -> `spec-term `name-map
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Diagrams</title>
<para>
<<
||  `diagram-term ::=
||     `unit-identifier
||   | `diagram-form
||  
||  `diagram-form ::= diagram '{ `diagram-element { , `diagram-element }* '}
||  
||  `diagram-element ::=
||     `diagram-node
||   | `diagram-edge
||  
||  `diagram-node ::= `name +-> `spec-term
||  
||  `diagram-edge ::= `name : `name -> `name +-> `morphism-term
||     
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Target Code Terms</title>
<para>
<<
||  `target-code-term ::=
||      generate `target-language-name `spec-term [ in `string-literal ]
||  
||  `target-language-name ::= c | java | lisp
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Proof Terms</title>
<para>
<<
||  `proof-term ::=
||      prove `claim-name in `spec-term
||                      [ with `prover-name ]
||                      [ using '{ `claim-list '} ]
||                      [ options `prover-options ]
||  
||  `prover-name ::= snark
||  
||  `claim-list ::= `claim-name { , `claim-name }*
||  
||  `prover-options ::= `string-literal
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Declarations</title>
<para>
<<
||  `declaration ::=
||      `import-declaration
||    | `type-declaration
||    | `op-declaration
||    | `definition
||  
||  `definition ::=
||      `type-definition
||    | `op-definition
||    | `claim-definition
||  
||  `equals ::= is | =
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Import-declarations</title>
<para>
<<
||  `import-declaration ::= import `spec-term
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-declarations</title>
<para>
<<
||  `type-declaration ::= type `type-name [ `formal-type-parameters ]
||  
||  `formal-type-parameters ::= `local-type-variable | ( `local-type-variable-list )
||  
||  `local-type-variable ::= `name
||  
||  `local-type-variable-list ::= `local-type-variable { , `local-type-variable }*
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-definitions</title>
<para>
<<
||  `type-definition ::= type `type-name [ `formal-type-parameters ] `equals `type-descriptor
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Op-declarations</title>
<para>
<<
||  `op-declaration ::= op `op-name [ `fixity ] : `type-scheme
||  
||  `fixity ::= `associativity `priority
||  
||  `associativity ::= infixl | infixr
||  
||  `priority ::= `nat-literal
||  
||  `type-scheme ::= [ `type-variable-binder ] `type-descriptor
||  
||  `type-variable-binder ::= fa ( `local-type-variable-list )
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Op-definitions</title>
<para>
<<
||  `op-definition ::=
||    def [ `type-variable-binder ] `formal-expression [ : `type-descriptor ] `equals
||        `expression
||  
||  `formal-expression ::= `op-name | `formal-application
||  
||  `formal-application ::= `formal-application-head `formal-parameter
||  
||  `formal-application-head ::= `op-name | `formal-application
||  
||  `formal-parameter ::= `closed-pattern
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Claim-definitions</title>
<para>
<<
||  `claim-definition ::= `claim-kind `claim-name `equals `claim
||  
||  `claim-kind ::= axiom | theorem | conjecture
||  
||  `claim-name ::= `name
||  
||  `claim ::= [ `type-quantification ] `expression
||  
||  `type-quantification ::= type `type-variable-binder
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-descriptors</title>
<para>
<<
||  `type-descriptor ::=
||      `type-sum
||    | `type-arrow
||    | `slack-type-descriptor
||  
||  `slack-type-descriptor ::=
||      `type-product
||    | `tight-type-descriptor
||  
||  `tight-type-descriptor ::=
||      `type-instantiation
||    | `closed-type-descriptor
||  
||  `closed-type-descriptor ::=
||      `type-name
||    | `local-type-variable
||    | `type-record
||    | `type-restriction
||    | `type-comprehension
||    | `type-quotient
||    | ( `type-descriptor )
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-sums</title>
<para>
<<
||  `type-sum ::= `type-summand { `type-summand }*
||  
||  `type-summand ::= '| `constructor [ `slack-type-descriptor ]
||  
||  `constructor ::= `name
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-arrows</title>
<para>
<<
||  `type-arrow ::= `arrow-source -> `type-descriptor
||  
||  `arrow-source ::= `type-sum | `slack-type-descriptor
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-products</title>
<para>
<<
||  `type-product ::= `tight-type-descriptor * `tight-type-descriptor { * `tight-type-descriptor }*
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-instantiations</title>
<para>
<<
||  `type-instantiation ::= `type-name `actual-type-parameters
||  
||  `actual-type-parameters ::= `closed-type-descriptor | ( `proper-type-list )
||  
||  `proper-type-list ::= `type-descriptor , `type-descriptor { , `type-descriptor }*
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-names</title>
<para>
<<
||  `type-name ::= `qualifiable-name
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-records</title>
<para>
<<
||  `type-record ::= '{ [ `field-typer-list ] '} | ( )
||  
||  `field-typer-list ::= `field-typer { , `field-typer }*
||  
||  `field-typer ::= `field-name : `type-descriptor
||  
||  `field-name ::= `name
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-restrictions</title>
<para>
<<
||  `type-restriction ::= ( `slack-type-descriptor '| `expression )
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-comprehensions</title>
<para>
<<
||  `type-comprehension ::= '{ `annotated-pattern '| `expression '}
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Type-quotients</title>
<para>
<<
||  `type-quotient ::= `closed-type-descriptor / `closed-expression
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Expressions</title>
<para>
<<
||  `expression ::=
||      `lambda-form
||    | `case-expression
||    | `let-expression
||    | `if-expression
||    | `quantification
||    | `annotated-expression
||    | `tight-expression
||  
||  `tight-expression ::=
||      `application
||    | `restrict-expression
||    | `closed-expression
||  
||  `closed-expression ::=
||      `op-name
||    | `local-variable
||    | `literal
||    | `field-selection
||    | `tuple-display
||    | `record-display
||    | `sequential-expression
||    | `list-display
||    | `structor
||    | ( `expression )
||    | ( `inbuilt-infix )
||  
||  `inbuilt-infix ::= => | '|'| | && | = | ~= | <<
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Lambda-forms</title>
<para>
<<
||  `lambda-form ::= fn `match
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Case-expressions</title>
<para>
<<
||  `case-expression ::= case `expression of `match
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Let-expressions</title>
<para>
<<
||  `let-expression ::= let `let-bindings in `expression
||  
||  `let-bindings ::= `recless-let-binding | `rec-let-binding-sequence
||  
||  `recless-let-binding ::= `pattern `equals `expression
||  
||  `rec-let-binding-sequence ::= `rec-let-binding { `rec-let-binding }*
||  
||  `rec-let-binding ::=
||    def `name `formal-parameter-sequence [ : `type-descriptor ] `equals `expression
||  
||  `formal-parameter-sequence ::= `formal-parameter { `formal-parameter }*
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>If-expressions</title>
<para>
<<
||  `if-expression ::= if `expression then `expression else `expression
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Quantifications</title>
<para>
<<
||  `quantification ::= `quantifier ( `local-variable-list ) `expression
||  
||  `quantifier ::= fa | ex
||  
||  `local-variable-list ::= `annotable-variable { , `annotable-variable }*
||  
||  `annotable-variable ::= `local-variable [ : `type-descriptor ]
||  
||  `local-variable ::= `name
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Annotated-expressions</title>
<para>
<<
||  `annotated-expression ::= `tight-expression : `type-descriptor
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Applications</title>
<para>
<<
||  `application ::= `prefix-application | `infix-application
||  
||  `prefix-application ::= `application-head `actual-parameter
||  
||  `application-head ::= `closed-expression | `prefix-application
||  
||  `actual-parameter ::= `closed-expression
||  
||  `infix-application ::= `operand `infix-operator `operand
||  
||  `operand ::= `tight-expression
||  
||  `infix-operator ::= `op-name | `inbuilt-infix
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Restrict-expressions</title>
<para>
<<
||  `restrict-expression ::= restrict `closed-expression `closed-expression
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Op-names</title>
<para>
<<
||  `op-name ::= `qualifiable-name
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Literals</title>
<para>
<<
||  `literal ::=
||      `boolean-literal
||    | `nat-literal
||    | `char-literal
||    | `string-literal
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Boolean-literals</title>
<para>
<<
||  `boolean-literal ::= true | false
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Nat-literals</title>
<para>
<<
||  `nat-literal ::= `decimal-digit { `decimal-digit }*
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Char-literals</title>
<para>
<<
||  `char-literal ::= #`char-literal-glyph
||  
||  `char-literal-glyph ::= `char-glyph | "
||  
||  `char-glyph ::=
||      `letter
||    | `decimal-digit
||    | `other-char-glyph
||  
||  `other-char-glyph ::=
||      ! | : | @ | # | $ | % | ^ | & | * | ( | ) | _ | - | + | =
||    | '| | ~ | ` | . | , | < | > | ? | / | ; | '' | '[ | '] | '{ | '}
||    | \\ | \"
||    | \a | \b | \t | \n | \v | \f | \r | \s
||    | \x `hexadecimal-digit `hexadecimal-digit
||  
||  `hexadecimal-digit ::=
||      `decimal-digit
||    | a | b | c | d | e | f
||    | A | B | C | D | E | F
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>String-literals</title>
<para>
<<
||  `string-literal ::= " `string-body "
||  
||  `string-body ::= { `string-literal-glyph }*
||  
||  `string-literal-glyph ::= `char-glyph | `significant-whitespace
||  
||  `significant-whitespace ::= `space | `tab | `newline
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Field-selections</title>
<para>
<<
||  `field-selection ::= `closed-expression . `field-selector
||  
||  `field-selector ::= `nat-literal | `field-name
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Tuple-displays</title>
<para>
<<
||  `tuple-display ::= ( `tuple-display-body )
||  
||  `tuple-display-body ::= [ `expression , `expression { , `expression }* ]
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Record-displays</title>
<para>
<<
||  `record-display ::= '{ `record-display-body '}
||  
||  `record-display-body ::= [ `field-filler { , `field-filler }* ]
||  
||  `field-filler ::= `field-name `equals `expression
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Sequential-expressions</title>
<para>
<<
||  `sequential-expression ::= ( `open-sequential-expression )
||  
||  `open-sequential-expression ::= `void-expression ; `sequential-tail
||  
||  `void-expression ::= `expression
||  
||  `sequential-tail ::= `expression | `open-sequential-expression
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>List-displays</title>
<para>
<<
||  `list-display ::= '[ `list-display-body ']
||  
||  `list-display-body ::= [ `expression { , `expression }* ]
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Structors</title>
<para>
<<
||  `structor ::=
||      `projector
||    | `relaxator
||    | `quotienter
||    | `chooser
||    | `embedder
||    | `embedding-test
>>
<<
||  `projector ::= project `field-selector
>>
<<
||  `relaxator ::= relax `closed-expression
>>
<<
||  `quotienter ::= quotient `closed-expression
>>
<<
||  `chooser ::= choose `closed-expression
>>
<<
||  `embedder ::= [ embed ] `constructor
>>
<<
||  `embedding-test ::= embed? `constructor
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Matches</title>
<para>
<<
||  `match ::= [ '| ] `branch { '| `branch }*
||  
||  `branch ::= `pattern -> `expression
||  
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
<formalpara><title>Patterns</title>
<para>
<<
||  `pattern ::=
||      `annotated-pattern
||    | `tight-pattern
||  
||  `tight-pattern ::=
||      `aliased-pattern
||    | `cons-pattern
||    | `embed-pattern
||    | `quotient-pattern
||    | `relax-pattern
||    | `closed-pattern
||  
||  `closed-pattern ::=
||      `variable-pattern
||    | `wildcard-pattern
||    | `literal-pattern
||    | `list-pattern
||    | `tuple-pattern
||    | `record-pattern
||    | ( `pattern )
>>
<<
||  
||  `annotated-pattern ::= `pattern : `type-descriptor
||  
||  `aliased-pattern ::= `variable-pattern as `tight-pattern
||  
||  `cons-pattern ::= `closed-pattern :: `tight-pattern
||  
||  `embed-pattern ::= `constructor [ `closed-pattern ]
||  
||  `quotient-pattern ::= quotient `closed-expression `tight-pattern
||  
||  `relax-pattern ::= relax `closed-expression `tight-pattern
||  
||  `variable-pattern ::= `local-variable
||  
||  `wildcard-pattern ::= _
||  
||  `literal-pattern ::= `literal
||  
||  `list-pattern ::= '[ `list-pattern-body ']
||  
||  `list-pattern-body ::= [ `pattern { , `pattern }* ]
||  
||  `tuple-pattern ::= ( `tuple-pattern-body )
||  
||  `tuple-pattern-body ::= [ `pattern , `pattern { , `pattern }* ]
||  
||  `record-pattern ::= '{ `record-pattern-body '}
||  
||  `record-pattern-body ::= [ `field-patterner { , `field-patterner }* ]
||  
||  `field-patterner ::= `field-name [ `equals `pattern ]
>>
</para>
</formalpara>
<!-- ***************************************************************** -->
</appendix>
