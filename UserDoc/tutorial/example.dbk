<chapter>
<title>Example</title>

<para>This chapter presents a step-by-step example of a small
application developed with Specware. Despite its small size, the
example illustrates the general methodology to develop software with
Specware. Furthermore, the description of the example includes
concrete explanations to run the example through Specware, thus
serving as a usage tutorial.</para>

<section>
<title>The Problem</title>

<para>The problem solved by this simple application is the
following. A message is given, consisting of a sequence of characters,
some of which are ``obscured'', i.e., it may look something
like:</para>

<programlisting>
**V*ALN**EC*E*S
</programlisting>

<para>Then, a list of words is given, where a word is a sequence of
characters, e.g.:</para>

<programlisting>
CERAMIC
CHESS
DECREE
FOOTMAN
INLET
MOLOCH
OCELOT
PROFUSE
RESIDE
REVEAL
SECRET
SODIUM
SPECIES
VESTIGE
WALNUT
YOGURT
</programlisting>

<para>Even though the above list is alphabetically sorted, the list of
words can be given in any order.</para>

<para>The application must find which words of the list may occur
somewhere in the message, where an obscured character in the message
may match any character in a word, while a non-obscured character must
be matched exactly.  The application must also show the offset in the
message at which the possible occurrence is found; if there is more
than one offset, the smallest one should be returned. So, the output
for the example message and word list above is the following:</para>

<programlisting>
10 CHESS
 8 DECREE
 0 REVEAL
 8 SECRET
 7 SPECIES
 3 WALNUT
</programlisting>

<para>Again, even though the list of words and numbers is
alphabetically ordered, the application can produce it in any
order.</para>

</section>

<section>
<title>Specification</title>

<section>
<title>Construction</title>

<para>We specify the application in a bottom-up fashion. We build
specs for the concepts involved in the application, starting with the
simplest ones up to the spec for the application.</para>

<para>MetaSlang provides strings of characters among the built-in
sorts, ops, and axioms. We could define messages and words as strings
satisfying certain properties, e.g., that the character
<literal>*</literal> can appear in messages but not in words,
etc.</para>

<para>However, it is generally better to specify things as abstractly
as possible. It is clear that the problem as stated above does not
depend on obscured characters being represented as
<literal>*</literal> and on non-obscured characters being uppercase
letters only, or letters and numbers, or other. The abstract notion is
that there are characters that form words, and messages are made of
those characters but some characters may be obscured.</para>

<para>So, we start with a spec for symbols (i.e., characters):</para>

<programlisting>
Symbols = spec
  sort Symbol
end-spec
</programlisting>

<para>This is a very simple spec: it just consists of one sort. This
is perfectly adequate because the application treats symbols
atomically: it only compares them for equality (which is built-in in
MetaSlang for every sort). Any further constraint on symbols would
just make the spec unnecessarily less general.</para>

<para>The text above is MetaSlang syntax: it not only introduces a
spec consisting of the sort <literal>Symbol</literal>, but also
assigns a name to it, <literal>Symbols</literal>. This spec can thus
be referred to by its name, as shown shortly. The exact way in which
the text above is supplied to Specware is explained later.</para>

<para>Now that we have the concept of symbols, we can introduce the
concept of word as a sequence of characters. MetaSlang provides lists,
built-in.  The polymorphic sort <literal>List a</literal> is used to
define words:</para>

<programlisting>
Words = spec
  import Symbols
  sort Word = List Symbol
end-spec
</programlisting>

<para>The name of the spec is <literal>Words</literal>. The spec
imports <literal>Symbols</literal> defined above, and extends it with
a new sort <literal>Word</literal>, defined to be <literal>List
Symbol</literal>. This sort is obtained as an instantiation of
<literal>List a</literal> by replacing the sort parameter
<literal>a</literal> with <literal>Symbol</literal>.</para>

<para>A message is a sequence of symbols some of which may be
obscured. This can be specified by lists whose elements are either
symbols or a special extra value that stands for an ``obscured
symbol'' (the ``<literal>*</literal>'' in the problem description
given earlier).</para>

<para>MetaSlang provides, built-in, a polymorphic sort <literal>Option
a</literal> that adds an extra element to a sort.  More precisely, it
is defined as <literal>sort Option a = | Some a | None</literal>. The
sort <literal>Option a</literal> is defined as a coproduct of sort
<literal>a</literal> tagged by <literal>Some</literal> and the
singleton sort consisting of the constant
<literal>None</literal>.</para>

<para>So, we can define messages as follows:</para>

<programlisting>
Messages = spec
  import Symbols
  sort Message = List (Option Symbol)
end-spec
</programlisting>

<para>At this point, we can define the notion of symbol matching: a
symbol must be matched by the exact same symbol, while an obscured
symbol may be matched by any symbol. This is captured by the following
spec:</para>

<programlisting>
SymbolMatching = spec
  import Symbols

  op symb_matches? : Symbol * Option Symbol -&gt; Boolean
  def symb_matches?(s,os) = case os of Some s1 -&gt; s = s1
                                     | None    -&gt; true
end-spec
</programlisting>

<para>The spec imports <literal>Symbols</literal> and extends it with
an op <literal>symb_matches?</literal> that returns a boolean from a
pair whose first component is a symbol and the second component is a
possibly obscured symbol. This op can be viewed as a binary
predicate. The op is defined by pattern matching on the second
argument, in a straightforward way. Note that <literal>s =
s1</literal> is a term of type <literal>Boolean</literal>.</para>

<para>The definition is given as a <literal>def</literal>, which means
that code can be eventually generated directly, without any need to
refine it. This is one of those cases where the simplest and most
abstract definition of an op happens to be directly executable.</para>

<para>Having the notion of symbol matching, now we define the notion
of word matching, i.e., when a word matches a message. We could define
an op (predicate) of type <literal>Word * Message -&gt;
Boolean</literal>. However, since the application involves offsets for
matching words, it is better to declare the op to have type
<literal>Word * Message * Nat -&gt; Boolean</literal>: the predicate
is true if the given word matches the given message at the given
position.  Here is the spec:</para>

<programlisting>
WordMatching = spec

  import Words
  import Messages
  import SymbolMatching

  op word_matches_at? : Word * Message * Nat -&gt; Boolean
  axiom word_matching is
        fa(wrd,msg,pos)
          word_matches_at?(wrd,msg,pos) &lt;=&gt;
          pos + length wrd &lt;= length msg &amp;
          (fa(i) i &lt; length wrd =&gt;
                 symb_matches?(nth(wrd, i), nth(msg, pos + i)))

end-spec
</programlisting>

<para>First, the spec imports the specs for words, messages, and
symbol matching.  Then it introduces the op
<literal>word_matches_at?</literal>, with the type explained
above. The axiom (whose name is <literal>word_matching</literal>)
defines the predicate. It says that the predicate holds on a triple
<literal>(wrd,msg,pos)</literal> if and only if two conditions are
satisfied:</para>

<orderedlist>

<listitem>
<para><literal>msg</literal> is long enough to possibly contain the
whole <literal>wrd</literal> at position <literal>pos</literal>;</para>
</listitem>

<listitem>
<para>every symbol of <literal>wrd</literal> at position
<literal>i</literal> matches the corresponding, possibly obscured
symbol in <literal>msg</literal> at position <literal>pos +
i</literal>.</para>
</listitem>

</orderedlist>

<para>Note the use of <literal>symb_matches?</literal> previously
defined.  The ops <literal>length</literal> and <literal>nth</literal>
are built-in, polymorphic ops over lists: the former returns the
length of a list, while the latter returns the n-th element of a list
(n is numbered starting from 0).</para>

<para>Unlike <literal>symb_matches?</literal> above, the definition of
<literal>word_matches_at?</literal> is not executable. This means that
it must be eventually refined. An executable definition of this op
involves some kind of loop through the message: so, it would not be as
simple and abstract as it is now. The general rule is that, at the
specification level, things should be expressed as simply, clearly,
and declaratively as possible.</para>

<para>Having all the above concepts in hand, we are ready to define
how a message and a list of words are processed by the application to
produce a list of matches. As explained in the problem description
above, a match is not only a word, but also the (least) position in
the message at which the match occurs. So, it is appropriate to define
the concept of a match, as a pair consisting of a word and a position
(i.e., a natural number):</para>

<programlisting>
spec Matches is
  import Words
  sort Match = {word : Word, position : Nat}
end-spec
</programlisting>

<para>The sort <literal>Match</literal> is defined to be a record with
two components, named <literal>word</literal> and
<literal>position</literal>. A record is like a cartesian product, but
the components have user-chosen names.</para>

<para>Finally, the spec for the whole application is the
following:</para>

<programlisting>
spec FindMatches is

  import WordMatching
  import Matches

  op find_matches : Message * List Word -&gt; List Match
  axiom match_finding is
        fa(msg,wrds,mtch)
          member(mtch,find_matches(msg,wrds)) &lt;=&gt;
          member(mtch.word,wrds) &amp;
          word_matches_at?(mtch.word,msg,mtch.position) &amp;
          (fa(pos) word_matches_at?(mtch.word,msg,pos) =&gt;
                   pos &gt;= mtch.position)

end-spec
</programlisting>

<para>The spec imports <literal>WordMatching</literal> and
<literal>Matches</literal>, and declares an op
<literal>find_matches</literal> that, given a message and a list of
words, returns a list of matches. This op captures the processing
performed by the application. The axiom states the required
properties.  The built-in polymorphic op <literal>member</literal> is
a predicate that says whether an element belongs to a list or not. So,
the required property for <literal>find_matches</literal> is the
following: given a message <literal>msg</literal> and a list of words
<literal>wrds</literal>, a match <literal>mtch</literal> belongs to
the result of <literal>find_words</literal> if and only if:</para>

<orderedlist>

<listitem>
<para>the word of the match is in <literal>wrds</literal>, i.e., the
word must have been given as input;</para>
</listitem>

<listitem>
<para>the word can be matched with <literal>msg</literal> at the
position indicated by the match;</para>
</listitem>

<listitem>
<para>the position of the match is the least position where the word
matches.</para>
</listitem>

</orderedlist>

<para>Note how the specification of this word matching application is
simple and abstract. No commitments have been made to particular data
structures or algorithms. These commitments are made during the
refinement process. Note also that the op
<literal>find_matches</literal> is not completely defined by the
axiom: the order of the resulting matches is not specified (the axiom
only says what the members of the resulting list are, but not their
order).  This under-specification is consistent with the informal
problem description given above. Of course, it is possible to change
the axiom to require a particular order (e.g., the same as in the
input list), if desired.</para>

</section>  <!-- construction -->

<section>
<title>Processing by Specware</title>

<para>How do we actually enter the above text into Specware and how do
we have Specware process it?</para>

<para>The current version of Specware works more or less like a
compiler: it processes one or more files producing results. The files
define specs, morphisms, etc. The results include error messages if
something is wrong (e.g., type errors in specs), and possibly the
generation of other files (e.g., containing code generated by
Specware).</para>

<para>The files processed by Specware are text files with extension
<filename>.sw</filename> (the ``s'' and ``w'' come from the first and
fifth letter of ``Specware''). A <filename>.sw</filename> file
contains a sequence of definitions of specs, morphisms, etc.</para>

<para>For the word matching application constructed above, it is
sensible to put all the specs above inside a file
<literal>MatchingSpecs.sw</literal>:</para>

<programlisting>
Symbols = spec
  sort Symbols
end-spec

...

FindMatches = spec
 ...
end-spec
</programlisting>

<para>Unlike a traditional compiler, the interaction with Specware is
within a Lisp shell.  When Specware is started, a Lisp shell is
available for interaction with Specware (Specware is part of the Lisp
image). In the Lisp shell, the user can move to any desired directory
of the file system by means of the <literal>:cd</literal> command,
followed by the name of the directory, e.g., <literal>:cd
~/mydir</literal>.  Usually, the <filename>.sw</filename> files that
form an application are put inside a directory, and from the Lisp
shell the user moves to that directory.</para>

<para>In order to have Specware process a spec (or morpshim, etc.)
contained in a <filename>.sw</filename> file in the current directory,
the user provides the following command in the Lisp shell:</para>

<programlisting>
(sw "&lt;filename&gt;/&lt;specname&gt;")
</programlisting>

<para>The ``top-level'' Lisp function of Specware is
<literal>sw</literal>, which is called by the above command (starting
Specware sets the current Lisp package to the Specware package, where
<literal>sw</literal> is defined). The
<literal>&lt;filename&gt;</literal> portion of the argument string is
a place holder for the file name (without the <literal>.sw</literal>
extension); the <literal>&lt;specname&gt;</literal> portion is a place
holder for the spec (or morphism, etc.) name.</para>

<para>The effect of the above command is that Specware processes the
indicated spec (or morphism, etc.) in the indicated file, recursively
processing other specs, morphisms, etc. that are referenced by the
indicated spec.</para>

<para>To have Specware process the spec of the word matching
application, the command is:</para>

<programlisting>
(sw "MatchingSpecs/FindMatches")
</programlisting>

<para>This has the effect of processing the spec named
<literal>FindMatches</literal> in file
<literal>MatchingSpecs.sw</literal>. Since this spec imports specs
<literal>WordMatching</literal> and <literal>Matches</literal>, these
are processed first, and so are the specs imported by them,
recursively. Thus, all the specs in
<literal>MatchingSpecs.sw</literal> are processed.
<literal>FindMatches</literal> is the top-level spec in the
file.</para>

<para>Specware finds the specs <literal>WordMatching</literal> and
<literal>Matches</literal>, imported by
<literal>FindMatches</literal>, because they are contained in the same
file. As it will be explained shortly, it is possible to refer from
one file to specs defined in different files.</para>

<para> There is a slightly more concise syntax for having Specware
process a spec (or morphism etc.):</para>

<programlisting>
:sw &lt;filename&gt;/&lt;specname&gt;
</programlisting>

<para>For the word matching spec, the command is:</para>

<programlisting>
:sw MatchingSpecs/FindMatches
</programlisting>

<para>The differences with the slightly more verbose syntax are that
there are no parentheses and no double quotes, but there is a colon
at the beginning.</para>

</section>  <!-- specware processing -->

</section>  <!-- specification -->

<section>
<title>Refinement</title>

<section>
<title>Construction</title>

<para>We now refine the application specified above in order to obtain
a running program that implements the specified functionality.  We do
that by defining the specs below inside a file
<literal>MatchingRefinements.sw</literal>, in the same directory as
<literal>MatchingSpecs.sw</literal>.

<para>In order to obtain an executable program, we need to choose a
concrete representation for the symbols composing words and
messages. For example, we can choose uppercase characters:</para>

<programlisting>
Symbols = spec
  sort Symbol = (Char | isUpperCase)
end-spec
</programlisting>

<para>The built-in sort <literal>Char</literal> is the sort for
characters. The built-in op <literal>isUpperCase</literal> is a
predicate on characters that says whether a character is an uppercase
letter or not. The subsort construct ``<literal>|</literal>'' is used
to define the sort <literal>Symbol</literal> as a subsort of
<literal>Char</literal>.</para>

<para>Note that the above spec has the same name
(<literal>Symbols</literal>) as its corresponding abstract spec. This
is allowed and it is a feature of Specware: <literal>.sw</literal>
files define separate name spaces. The file
<literal>MatchingSpecs.sw</literal> creates a name space, and the file
<literal>MatchingRefinements.sw</literal> creates a separate name
space. The full name of the spec <literal>Symbols</literal> in
<literal>MatchingSpecs.sw</literal> is
<literal>MatchingSpecs/Symbols</literal>, while the full name of the
spec <literal>Symbols</literal> in
<literal>MatchingRefinements.sw</literal> is
<literal>MatchingRefinements/Symbols</literal>. Indeed, when Specware
is invoked to process a spec (or morphism, etc.), the full name is
supplied, as in <literal>:sw MatchingSpecs/FindMatches</literal>.
</para>

<!--
%<para>
%The fact that spec <literal>Symbols_Refined</literal> is a refinement
%of <literal>Symbols</literal> is expressed by the following
%morphism:</para>
%
%<programlisting>
%def Symbols_Refinement = Symbols !-&gt; Symbols_Refined
%</programlisting>
%
%<para>This text defines a morphism called
%<literal>Symbols_Refinement</literal>.  The construct
%``<literal>!-&gt;</literal>'' is an infix operator that builds the
%inclusion morphism from the leftmost spec to the rightmost spec, if
%any (if there is no inclusion morphism, Specware produces an error
%message).  Since <literal>Symbols</literal> consists of just one sort
%{Symbol}, it is immediate that <literal>Symbols_Refinement</literal>
%is a legal morphism.</para>
-->

<para>The specs <literal>Words</literal>, <literal>Messages</literal>,
and <literal>SymbolMatching</literal> (in
<literal>MatchingSpecs.sw</literal>) need not be refined, because they
constructively define their sorts and ops. But the op
<literal>word_matches_at?</literal> in <literal>WordMatching</literal>
needs to be refined. We do that by constructing a spec that imports
the same specs imported by <literal>WordMatching</literal> and that
defines op <literal>word_matches_at?</literal> in an executable
way:</para>

<programlisting>
WordMatching0 = spec

  import MatchingSpecs/Words
  import MatchingSpecs/Messages
  import MatchingSpecs/SymbolMatching

  op word_matches_at? : Word * Message * Nat -&gt; Boolean
  def word_matches_at?(wrd,msg,pos) =
      if pos + length wrd > length msg
      then false
      else word_matches_aux?
            (wrd, if pos = 0 then msg else nthTail(msg, pos - 1))

  op word_matches_aux? : {(wrd,msg) : Word * Message |
                          length wrd &lt;= length msg} -&gt; Boolean
  def word_matches_aux?(wrd,msg) =
      case wrd of Nil -&gt; true
                | Cons(wsym,wrd1) -&gt;
                  let Cons(msym,msg1) = msg in
                  if symb_matches?(wsym,msym)
                  then word_matches_aux?(wrd1,msg1)
                  else false

end-spec
</programlisting>

<para>Since the imported specs are not in the file
<literal>MatchingRefinements.sw</literal>, their full names are used
after <literal>import</literal>.</para>

<para>The definition of <literal>word_matches_at?</literal> makes use
of an auxiliary op <literal>word_matches_aux?</literal>, which takes
as input a word and a message such that the length of the word is not
greater than that of the message. This constraint is expressed as a
subsort of the cartesian product <literal>Word * Message</literal>. Op
<literal>word_matches_aux?</literal> returns a boolean if the word
matches the message, at the start of the message. It is defined
recursively, by pattern matching on the word.  Note the use of
<literal>let</literal> to decompose the msg into the initial symbol
and the rest. This is always possible because of the subsort
constraint on the word and the message. So,
<literal>word_matches_at?</literal> simply calls
<literal>word_matches_aux?</literal> with the word and the tail of the
message obtained by eliminating the first <literal>pos</literal>
symbols, by means of the built-in op <literal>nthTail</literal> over
lists.</para>

<!--
%<para>The fact that {WordMatching_Refined0} is a refinement of
%<literal>WordMatching</literal> is expressed by the following
%morphism:</para>
%
%<programlisting>
%def WordMatching_Refinement0 =
%    WordMatching !-&gt; WordMatching_Refined0
%</programlisting>
%
%<para>The fact that it is a legal morphism follows from the fact that
%the axiom about <literal>word_matches_at?</literal> in
%<literal>WordMatching</literal> is a theorem in
%<literal>WordMatching_Refined0</literal>, i.e., it follows from the
%executable definition of <literal>word_matches_at?</literal>.</para>

%<para>Currently, Specware does not provide commands to call external
%theorem provers to discharge the proof obligations attached to
%morphisms. This functionality will be provided in future versions of
%the system.</para>
-->

<para>The refinement for word matching can be composed with the
refinement for symbols constructed earlier. This is achieved by
putting together (via <literal>import</literal>) the spec just defined
with the spec <literal>Symbols</literal> defined earlier.</para>

<programlisting>
WordMatching_Refined = spec
  import WordMatching0
  import Symbols
end-spec
</programlisting>

<para>The resulting spec is like <literal>WordMatching0</literal>, but
in addition the sort <literal>Symbol</literal> is defined to consist
of uppercase characters. Since the second imported spec is referred to
by its short name, it is
<literal>MatchingRefinements/Symbols</literal>, and not
<literal>MatchingSpecs/Symbols</literal>.</para>

<para>Now we proceed to refine op <literal>find_matches</literal>. We
do that in two steps, analogously to word matching above. First, we
build a spec <literal>FindMatches0</literal> that imports the same
specs imported by <literal>MatchingSpecs/FindMatches</literal> and
that defines op <literal>find_matches</literal> in an executable
way:</para>

<programlisting>
FindMatches0 = spec

  import MatchingSpecs/WordMatching
  import MatchingSpecs/Matches

  op find_matches : Message * List Word -&gt; List Match
  def find_matches(msg,wrds) =
      foldl (fn(wrd,mtchs) -&gt;
               case find_matches_aux(msg,wrd,0)
                 of Some pos -&gt;
                    Cons({word = wrd, position = pos}, mtchs)
                  | None -&gt; mtchs)
            Nil
            wrds

  op find_matches_aux : Message * Word * Nat -&gt; Option Nat
  def find_matches_aux(msg,wrd,pos) =
      if pos + length wrd > length msg
      then None
      else if word_matches_at?(wrd,msg,pos)
           then Some pos
           else find_matches_aux(msg, wrd, pos + 1)

end-spec
</programlisting>

<para>Op <literal>find_matches</literal> makes use of the auxiliary op
<literal>find_matches_aux</literal>, which takes as input a message
<literal>msg</literal>, a word <literal>wrd</literal>, and a position
<literal>pos</literal>. It returns either a natural number (a position
where the match starts) or <literal>None</literal> if there is no
match. Op <literal>find_matches_aux</literal> first checks if
<literal>msg</literal> is long enough to possibly contain a match for
<literal>wrd</literal> starting at <literal>pos</literal>. If that is
not the case, <literal>None</literal> is returned. Otherwise,
<literal>word_matches_at?</literal> is called: if it returns
<literal>true</literal>, then the position <literal>pos</literal> is
returned (wrapped by <literal>Some</literal>). Otherwise,
<literal>find_matches_aux</literal> is recursively called,
incrementing the position by 1. So, when
<literal>find_matches_aux</literal> is called with 0 as its third
argument, it iterates through the message to find the first match, if
any.  The position of the first match is returned, otherwise
<literal>None</literal>.</para>

<para>The op <literal>find_matches</literal> iterates through the
words of the list constructing a list of matches. The iteration is
performed by means of the built-in op <literal>foldl</literal> for
lists. For each word, <literal>find_matches_aux</literal> is called,
with 0 as its third argument.  Then, a pattern matching on the result
is done: if the result is a position, a match is added to the output
list; otherwise, the list is left unmodified.</para>

<!--
%<para>The following morphism expresses that
%<literal>FindMatches_Refined0</literal> is a refinement of
%<literal>FindMatches</literal>:</para>
%
%<programlisting>
%def FindMatches_Refinement0 =
%    FindMatches !-&gt; FindMatches_Refined0
%</programlisting>
%
%<para>The axiom about <literal>find_matches</literal> in spec
%<literal>FindMatches</literal> is a theorem in spec
%<literal>FindMatches_Refined0</literal>, i.e., it follows from the
%executable definition of <literal>find_matches</literal>.</para>
-->

<para>This refinement for <literal>FindMatches</literal> can be
composed with the one for <literal>WordMatching</literal> built
earlier. The composition is analogous to the one for
<literal>WordMatching</literal>:</para>

<programlisting>
FindMatches = spec
  import FindMatches0
  import WordMatching
end-spec
</programlisting>

<para>The resulting spec includes the refinement for op
<literal>find_matches</literal> as well as the refinement for op
<literal>word_matches_at?</literal> and for symbols.</para>

<para>This concludes the refinement of the application.</para>

</section>  <!-- construction -->

</section>  <!-- refinement -->

<section>
<title>Alternatives</title>

<para>The refinement for the word matching application developed above
is certainly not the only one possible.</para>

<para>For example, we could have refined symbols differently. We could
have refined them to be all letters (uppercase or lowercase) and
numbers, or to be natural numbers. It is worth noting that the
refinement for symbols is encapsulated in spec
<literal>MatchingRefinements/Symbols</literal>. If we want to change
the refinement for symbols, we just need to change that spec, while
the other specs remain unaltered.</para>

<para>As another example, we could have chosen a more efficient
refinement for op <literal>find_matches</literal>, using some fast
substring search algorithm.  In particular, while we have refined op
<literal>word_matches_at?</literal> first, and then composed its
refinement with one for <literal>find_matches</literal>, we could have
refined <literal>find_matches</literal> ``directly'', without using
<literal>word_matches_at?</literal>, so that it would have been
unnecessary to refine <literal>word_matches_at?</literal>.</para>

<para>The latter example illustrates an important principle concerning
refinement. In general, it is not necessary to refine all ops present
in a spec. Only the ops that are meant to be used by an external
program need to be refined to be executable, and in turn the ops that
are used inside their executable definitions. Other ops serve only an
auxiliary role in specifying abstractly the ops that are meant to be
eventually refined.</para>

<para>Currently, Specware provides no support to indicate explicitly
which ops are meant to be ``exported'' by a spec. In future versions
of the system, some functionality like this may be included.</para>

</section>  <!-- alternatives -->

<section>
<title>Code Generation and Testing</title>

<section>
<title>Code Generation</title>

<para>Now that our simple word matching application has been refined
to be executable, we can generate code from it. In order to have
Specware generate (Lisp) code from a spec, the following command is
given in the Lisp shell:</para>

<programlisting>
(swl "&lt;fullspecname&gt;" "&lt;targetfilename&gt;")
</programlisting>

<para>The Lisp function <literal>swl</literal> (where the ``l'' comes
from ``Lisp'') first processes the spec given as first argument (as
explained earlier) and then generates Lisp code from it, writing the
code in the file whose name is given as second argument (the file is
created if it does not exist; if it exists, it is overwritten).</para>

<para>For instance, we can generate Lisp code for the word matching
application by means of the following command:</para>

<programlisting>
(swl "MatchingRefinements/FindMatches" "find-matches.lisp")
</programlisting>

<para>Similarly to the <literal>sw</literal> function, a slightly
shorter syntax for the above command is:</para>

<programlisting>
:swl MatchingRefinements/FindMatches find-matches.lisp
</programlisting>

<para>After we generate the code, we can then try to run it by calling
the Lisp function produced from op
<literal>find_matches</literal>. Since messages and words are
represented as lists of characters (plus <literal>None</literal> for
messages), it would be slightly inconvenient to enter and read lists
of characters. It would be better to enter strings with letters and
<literal>*</literal>'s, as shown in the informal problem description
at the beginning of this chapter.</para>

<para>In order to do that, we define translations between strings and
messages and words, and we wrap <literal>find_matches</literal> in
order to translate from and to strings. We do that inside a spec
called <literal>Test</literal> in a file
<literal>MatchingTest.sw</literal> in the same directory as the other
two <literal>.sw</literal> files:</para>

<programlisting>
spec Test is

  import MatchingRefinements/FindMatches

  op word_char? : Char -&gt; Boolean
  def word_char? ch = isUpperCase ch

  op msg_char? : Char -&gt; Boolean
  def msg_char? ch = isUpperCase ch or ch = #*

  sort WordString = (String | all word_char?)

  sort MessageString = (String | all msg_char?)

  op word2string : Word -&gt; WordString
  def word2string wrd = implode wrd

  op string2word : WordString -&gt; Word
  def string2word wstr = explode wstr

  op message2string : Message -&gt; MessageString
  def message2string msg =
      implode(map (fn msym -&gt; case msym of Some ch -&gt; ch
                                            | None -&gt; #*)
                  msg)

  op string2message : MessageString -&gt; Message
  def string2message mstr =
      map (fn ch -&gt; if ch = #* then None else Some ch)
          (explode mstr)

  sort MatchString = {word : WordString, position : Nat}

  op match2string : Match -&gt; MatchString
  def match2string mtch =
      {word = word2string mtch.word, position = mtch.position}

  op test_find_matches :
     MessageString * List WordString -&gt; List MatchString
  def test_find_matches(mstr,wstrs) =
      map match2string
          (find_matches(string2message mstr,
                        map string2word wstrs))

end-spec
</programlisting>

<para>Since the translation is not defined on all strings, we
introduce two subsorts of the built-in sort <literal>String</literal>:
the sort <literal>WordString</literal> consists of all strings whose
characters are uppercase letters; the sort
<literal>MessageString</literal> consists of all strings whose
characters are uppercase letters or <literal>*</literal>. The built-in
op <literal>all</literal> over strings is used to define the subsorts,
using the ops (predicates) <literal>word_char?</literal> and
<literal>msg_char?</literal>.</para>

<para>The op <literal>word2string</literal> translates a word to a
word string, by means of the built-in op
<literal>implode</literal>. The op <literal>string2word</literal>
performs the opposite translation, using the built-in op
<literal>explode</literal>. The ops <literal>message2string</literal>
and <literal>string2message</literal> translate between messages and
string messages. Besides the use of <literal>implode</literal> and
<literal>explode</literal>, they need to map <literal>Some
ch</literal> from/to <literal>ch</literal> (where
<literal>ch</literal> is an uppercase letter) and
<literal>None</literal> from/to <literal>*</literal>.</para>

<para>Since <literal>find_matches</literal> returns a match, i.e., a
pair consisting of a word and a position, we define a sort
<literal>MatchString</literal> consisting of a word string and a
position, together with an op <literal>match2string</literal> that
translates from a match to a string match.</para>

<para>Finally, we define an op <literal>test_find_matches</literal> to
take a message string and a list of word strings as input, and to
return a list of string matches as output. The message string and word
strings are first translated to a message and list of words, then
<literal>find_matches</literal> is called, and then the resulting
matches are translated to string matches.  Note that the op
<literal>message2string</literal> is never used. In fact, it could
have been omitted.</para>

<para>Now, instead of generating code from
<literal>MatchingRefinements/FindMatches</literal>, we generate code
from <literal>MatchingTest/Test</literal>:</para>

<programlisting>
(swl "MatchingTest/Test" "find-matches-test.lisp")
</programlisting>

<section>
<title>Testing</title>

<para>In order to test the generated code, we need to load the
generated Lisp file into the Lisp environment. We do that from the
Lisp shell, by means of the following command:</para>

<programlisting>
(load "find-matches-test")
</programlisting>

<para>In Lisp, entities like functions, constants, etc. are defined
inside packages. When Specware generates code, it puts it inside a
package whose name is the name of the spec from which code has been
generated (in this case, <literal>Test</literal>. This can
be seen from the package declaration at the beginning of file
<filename>find-matches-test.lisp</filename> (note that Lisp is
case-insensitive).</para>

<para>So, in order to call the functions defined in that file (after
it has been loaded), it is necessary either to prepend the package
name to them, or to move to that package and then call them without
package qualification.  To follow the first approach, we write
<literal>test::test_find_matches</literal> to call the function. To
follow the second approach, we change package by means of the Lisp
command <literal>:pa test</literal> and then we just write
<literal>test_find_matches</literal> to call the function.</para>

<para>In order to test the program on the example input and output
given at the beginning of the chapter, we proceed as follows. First,
we define a variable containing the message:</para>

<programlisting>
(setq msg "**V*ALN**EC*E*S")
</programlisting>

<para>Then we define a variable containing the list of words:</para>

<programlisting>
(setq words '("CERAMIC" "CHESS" "DECREE" "FOOTMAN"
              "INLET" "MOLOCH" "OCELOT" "PROFUSE"
              "RESIDE" "REVEAL" "SECRET" "SODIUM"
              "SPECIES" "VESTIGE" "WALNUT" "YOGURT"))
</programlisting>

<para>Finally, we call (assuming to be in package
<literal>test</literal>):</para>

<programlisting>
(test_find_matches msg words)
</programlisting>

<para>The following result is then displayed:</para>

<programlisting>
((3 . "WALNUT") (7 . "SPECIES") (8 . "SECRET")
 (0 . "REVEAL") (8 . "DECREE") (10 . "CHESS"))
</programlisting>

<para>The result is a list of pairs, each of which represents a match.</para>

</section>  <!-- testing -->

</section>  <!-- code gen and testing -->

</section>

</chapter>
