<chapter id="example">
<title>Example</title>

<para>This chapter presents a step-by-step example of a small
application developed with &Specware;. Despite its small size, the
example illustrates the general methodology to develop software with
&Specware;. Furthermore, the description of the example includes
concrete explanations to run the example through &Specware;, thus
serving as a usage tutorial. The code for this example may be found
in the <filename>Examples\Matching\</filename> folder in your installation directory
(e.g. <filename>C:\Program Files\Specware\</filename>).</para>

<section>
<title>The Problem</title>

<para>The problem solved by this simple application is the
following. A message is given, consisting of a sequence of characters,
some of which are <quote>obscured</quote>, i.e., it may look something
like:</para>

<programlisting lang="metaslang">
    **V*ALN**EC*E*S
</programlisting>

<para>Then, a list of words is given, where a word is a sequence of
characters, e.g.:</para>

<programlisting lang="metaslang">
    CERAMIC
    CHESS
    DECREE
    FOOTMAN
    INLET
    MOLOCH
    OCELOT
    PROFUSE
    RESIDE
    REVEAL
    SECRET
    SODIUM
    SPECIES
    VESTIGE
    WALNUT
    YOGURT
</programlisting>

<para>Even though the above list is alphabetically sorted, the list of
words can be given in any order.</para>

<para>The application must find which words of the list may occur
somewhere in the message, where an obscured character in the message
may match any character in a word, while a non-obscured character must
be matched exactly.  The application must also show the offset in the
message at which the possible occurrence is found; if there is more
than one offset, the smallest one should be returned. So, the output
for the example message and word list above is the following:</para>

<programlisting lang="metaslang">
    10 CHESS
     8 DECREE
     0 REVEAL
     8 SECRET
     7 SPECIES
     3 WALNUT
</programlisting>

<para>Again, even though the list of words and numbers is
alphabetically ordered, the application can produce it in any
order.</para>

</section>

<section>
<title>Specification</title>

<section>
<title>Construction</title>

<para>We specify the application in a bottom-up fashion. We build
specs for the concepts involved in the application, starting with the
simplest ones up to the spec for the application.</para>

<para>MetaSlang provides strings of characters among the built-in
sorts, ops, and axioms. We could define messages and words as strings
satisfying certain properties, e.g., that the character <computeroutput lang="metaslang">*</computeroutput> can
appear in messages but not in words, etc.</para>

<para>However, it is generally better to specify things as abstractly
as possible. It is clear that the problem as stated above does not
depend on obscured characters being represented as <computeroutput lang="metaslang">*</computeroutput> and on
non-obscured characters being uppercase letters only, or letters and
numbers, or other. The abstract notion is that there are characters
that form words, and messages are made of those characters but some
characters may be obscured.</para>

<para>So, we start with a spec for symbols (i.e., characters):</para>

<programlisting lang="metaslang">
    Symbols = spec
      sort Symbol
    endspec
</programlisting>

<para>This is a very simple spec: it just consists of one sort. This
is perfectly adequate because the application treats symbols
atomically: it only compares them for equality (which is built-in in
MetaSlang for every sort). Any further constraint on symbols would
just make the spec unnecessarily less general.</para>

<para>The text above is MetaSlang syntax: it not only introduces a
spec consisting of the sort <computeroutput lang="metaslang">Symbol</computeroutput>, but also assigns a name to it,
<computeroutput lang="metaslang">Symbols</computeroutput>. This spec can thus be referred to by its name, as shown
shortly. The exact way in which the text above is supplied to
&Specware; is explained later.</para>

<para>Now that we have the concept of symbols, we can introduce the
concept of word as a sequence of characters. MetaSlang provides lists,
built-in.  The polymorphic sort <computeroutput lang="metaslang">List a</computeroutput> is used to define
words:</para>

<programlisting lang="metaslang">
    Words = spec
      import Symbols
      sort Word = List Symbol
    endspec
</programlisting>

<para>The name of the spec is <computeroutput lang="metaslang">Words</computeroutput>. The spec imports <computeroutput lang="metaslang">Symbols</computeroutput>
defined above, and extends it with a new sort <computeroutput lang="metaslang">Word</computeroutput>, defined to be
<computeroutput lang="metaslang">List Symbol</computeroutput>. This sort is obtained as an instantiation of <computeroutput lang="metaslang">List
a</computeroutput> by replacing the sort parameter <computeroutput lang="metaslang">a</computeroutput> with <computeroutput lang="metaslang">Symbol</computeroutput>.</para>

<para>A message is a sequence of symbols some of which may be
obscured. This can be specified by lists whose elements are either
symbols or a special extra value that stands for an <quote>obscured
symbol</quote> (the <quote><computeroutput lang="metaslang">*</computeroutput></quote> in the problem description given
earlier).</para>

<para>MetaSlang provides, built-in, a polymorphic sort <computeroutput lang="metaslang">Option a</computeroutput>
that adds an extra element to a sort.  More precisely, it is defined
as <computeroutput lang="metaslang">sort Option a = | Some a | None</computeroutput>. The sort <computeroutput lang="metaslang">Option a</computeroutput> is
defined as a coproduct of sort <computeroutput lang="metaslang">a</computeroutput> tagged by <computeroutput lang="metaslang">Some</computeroutput> and the
singleton sort consisting of the constant <computeroutput lang="metaslang">None</computeroutput>.</para>

<para>So, we can define messages as follows:</para>

<programlisting lang="metaslang">
    Messages = spec
      import Symbols
      sort Message = List (Option Symbol)
    endspec
</programlisting>

<para>At this point, we can define the notion of symbol matching: a
symbol must be matched by the exact same symbol, while an obscured
symbol may be matched by any symbol. This is captured by the following
spec:</para>

<programlisting lang="metaslang">
    SymbolMatching = spec
      import Symbols
    
      op symb_matches? : Symbol * Option Symbol -&gt; Boolean
      def symb_matches?(s,os) = case os of Some s1 -&gt; s = s1
                                         | None    -&gt; true
    endspec
</programlisting>

<para>The spec imports <computeroutput lang="metaslang">Symbols</computeroutput> and extends it with an op
<computeroutput lang="metaslang">symb_matches?</computeroutput> that returns a boolean from a pair whose first
component is a symbol and the second component is a possibly obscured
symbol. This op can be viewed as a binary predicate. The op is defined
by pattern matching on the second argument, in a straightforward
way. Note that <computeroutput lang="metaslang">s = s1</computeroutput> is a term of type <computeroutput lang="metaslang">Boolean</computeroutput>.</para>

<para>The definition is given as a <computeroutput lang="metaslang">def</computeroutput>, which means that code can
be eventually generated directly, without any need to refine it. This
is one of those cases where the simplest and most abstract definition
of an op happens to be directly executable.</para>

<para>Having the notion of symbol matching, now we define the notion
of word matching, i.e., when a word matches a message. We could define
an op (predicate) of type <computeroutput lang="metaslang">Word * Message -&gt; Boolean</computeroutput>. However,
since the application involves offsets for matching words, it is
better to declare the op to have type <computeroutput lang="metaslang">Word * Message * Nat -&gt;
Boolean</computeroutput>: the predicate is true if the given word matches the given
message at the given position.  Here is the spec:</para>

<programlisting lang="metaslang">
    WordMatching = spec
    
      import Words
      import Messages
      import SymbolMatching
    
      op word_matches_at? : Word * Message * Nat -&gt; Boolean
      axiom word_matching is
            fa(wrd,msg,pos)
              word_matches_at?(wrd,msg,pos) &lt;=&gt;
              pos + length wrd &lt;= length msg &amp;
              (fa(i) i &lt; length wrd =&gt;
                     symb_matches?(nth(wrd, i),
                                   nth(msg, pos + i)))
    
    endspec
</programlisting>

<para>First, the spec imports the specs for words, messages, and
symbol matching.  Then it introduces the op <computeroutput lang="metaslang">word_matches_at?</computeroutput>, with
the type explained above. The axiom (whose name is <computeroutput lang="metaslang">word_matching</computeroutput>)
defines the predicate. It says that the predicate holds on a triple
<computeroutput lang="metaslang">(wrd,msg,pos)</computeroutput> if and only if two conditions are satisfied:</para>

<orderedlist>

<listitem>
<para><computeroutput lang="metaslang">msg</computeroutput> is long enough to possibly contain the
whole <computeroutput lang="metaslang">wrd</computeroutput> at position <computeroutput lang="metaslang">pos</computeroutput>;</para>
</listitem>

<listitem>
<para>every symbol of <computeroutput lang="metaslang">wrd</computeroutput> at position
<computeroutput lang="metaslang">i</computeroutput> matches the corresponding, possibly obscured
symbol in <computeroutput lang="metaslang">msg</computeroutput> at position <computeroutput lang="metaslang">pos +
i</computeroutput>.</para>
</listitem>

</orderedlist>

<para>Note the use of <computeroutput lang="metaslang">symb_matches?</computeroutput> previously defined.  The ops
<computeroutput lang="metaslang">length</computeroutput> and <computeroutput lang="metaslang">nth</computeroutput> are built-in, polymorphic ops over lists: the
former returns the length of a list, while the latter returns the n-th
element of a list (n is numbered starting from 0).</para>

<para>Unlike <computeroutput lang="metaslang">symb_matches?</computeroutput> above, the definition of
<computeroutput lang="metaslang">word_matches_at?</computeroutput> is not executable. This means that it must be
eventually refined. An executable definition of this op involves some
kind of loop through the message: so, it would not be as simple and
abstract as it is now. The general rule is that, at the specification
level, things should be expressed as simply, clearly, and
declaratively as possible.</para>

<para>Having all the above concepts in hand, we are ready to define
how a message and a list of words are processed by the application to
produce a list of matches. As explained in the problem description
above, a match is not only a word, but also the (least) position in
the message at which the match occurs. So, it is appropriate to define
the concept of a match, as a pair consisting of a word and a position
(i.e., a natural number):</para>

<programlisting lang="metaslang">
    Matches = spec
      import Words
      sort Match = {word : Word, position : Nat}
    endspec
</programlisting>

<para>The sort <computeroutput lang="metaslang">Match</computeroutput> is defined to be a record with two
components, named <computeroutput lang="metaslang">word</computeroutput> and <computeroutput lang="metaslang">position</computeroutput>. A record is like a
cartesian product, but the components have user-chosen names.</para>

<para>Finally, the spec for the whole application is the
following:</para>

<programlisting lang="metaslang">
    FindMatches = spec
    
      import WordMatching
      import Matches
    
      op find_matches : Message * List Word -&gt; List Match
      axiom match_finding is
            fa(msg,wrds,mtch)
              member(mtch,find_matches(msg,wrds)) &lt;=&gt;
              member(mtch.word,wrds) &amp;
              word_matches_at?(mtch.word,msg,mtch.position) &amp;
              (fa(pos) word_matches_at?(mtch.word,msg,pos) =&gt;
                       pos &gt;= mtch.position)
    
    endspec
</programlisting>

<para>The spec imports <computeroutput lang="metaslang">WordMatching</computeroutput> and <computeroutput lang="metaslang">Matches</computeroutput>, and declares
an op <computeroutput lang="metaslang">find_matches</computeroutput> that, given a message and a list of words,
returns a list of matches. This op captures the processing performed
by the application. The axiom states the required properties.  The
built-in polymorphic op <computeroutput lang="metaslang">member</computeroutput> is a predicate that says whether an
element belongs to a list or not. So, the required property for
<computeroutput lang="metaslang">find_matches</computeroutput> is the following: given a message <computeroutput lang="metaslang">msg</computeroutput> and a list
of words <computeroutput lang="metaslang">wrds</computeroutput>, a match <computeroutput lang="metaslang">mtch</computeroutput> belongs to the result of
<computeroutput lang="metaslang">find_words</computeroutput> if and only if:</para>

<orderedlist>

<listitem>
<para>the word of the match is in <computeroutput lang="metaslang">wrds</computeroutput>, i.e., the
word must have been given as input;</para>
</listitem>

<listitem>
<para>the word can be matched with <computeroutput lang="metaslang">msg</computeroutput> at the
position indicated by the match;</para>
</listitem>

<listitem>
<para>the position of the match is the least position where the word
matches.</para>
</listitem>

</orderedlist>

<para>Note how the specification of this word matching application is
simple and abstract. No commitments have been made to particular data
structures or algorithms. These commitments are made during the
refinement process. Note also that the op <computeroutput lang="metaslang">find_matches</computeroutput> is not
completely defined by the axiom: the order of the resulting matches is
not specified (the axiom only says what the members of the resulting
list are, but not their order). The axiom does not prohibit duplicate
elements in the output list; a suitable conjunct could be added to
enforce uniqueness, if desired.  This under-specification is
consistent with the informal problem description given above. Of
course, it is possible to change the axiom to require a particular
order (e.g., the same as in the input list), if desired.</para>

</section>  <!-- construction -->

<section>
<title>Processing by &Specware;</title>

<para>How do we actually enter the above text into &Specware; and how
do we have &Specware; process it?</para>

<para>The current version of &Specware; works more or less like a
compiler: it processes one or more files producing results. The files
define specs, morphisms, etc. The results include error messages if
something is wrong (e.g., type errors in specs), and possibly the
generation of other files (e.g., containing code generated by
&Specware;).</para>

<para>The files processed by &Specware; are text files with extension
<filename>.sw</filename> (the <quote>s</quote> and <quote>w</quote> come from the first and fifth letter of
<quote>&Specware;</quote>). A <filename>.sw</filename> file contains a sequence of definitions of
specs, morphisms, etc.</para>

<para>For the word matching application constructed above, it is
sensible to put all the specs above inside a file
<filename>MatchingSpecs.sw</filename>:</para>

<programlisting lang="metaslang">
    Symbols = spec
      sort Symbols
    endspec
    
    ...
    
    FindMatches = spec
     ...
    endspec
</programlisting>

<para>Unlike a traditional compiler, the interaction with &Specware;
is within a Lisp shell.  When &Specware; is started, a Lisp shell is
available for interaction with &Specware; (&Specware; is part of the
Lisp image). In the Lisp shell, the user can move to any desired
directory of the file system by means of the <computeroutput lang="metaslang">:cd</computeroutput> command, followed
by the name of the directory, e.g., <computeroutput lang="metaslang">:cd ~/mydir</computeroutput>.  Usually, the
<filename>.sw</filename> files that form an application are put inside a directory, and
from the Lisp shell the user moves to that directory.</para>

<para>In order to have &Specware; process a spec (or morphism, etc.)
contained in a <filename>.sw</filename> file in the current directory, the user
provides the following command in the Lisp shell:</para>

<programlisting lang="lisp">
    :sw &lt;filename&gt;#&lt;specname&gt;
</programlisting>

<para>The <computeroutput lang="metaslang">&lt;filename&gt;</computeroutput> portion of the argument string is a place
holder for the file name (without the <filename>.sw</filename> extension); the
<computeroutput lang="metaslang">&lt;specname&gt;</computeroutput> portion is a place holder for the spec (or morphism,
etc.) name as it appears inside the file.</para>

<para>The effect of the above command is to have &Specware; process
the indicated spec (or morphism, etc.) in the indicated file,
recursively processing other specs, morphisms, etc. that are
referenced by the indicated spec.</para>

<para>To have &Specware; process the spec of the word matching
application, the command is:</para>

<programlisting lang="lisp">
    :sw MatchingSpecs#FindMatches
</programlisting>

<para>This has the effect of processing the spec named <computeroutput lang="metaslang">FindMatches</computeroutput>
in file <filename>MatchingSpecs.sw</filename>. Since this spec imports specs
<computeroutput lang="metaslang">WordMatching</computeroutput> and <computeroutput lang="metaslang">Matches</computeroutput>, these are processed first, and so
are the specs imported by them, recursively. Thus, all the specs in
<filename>MatchingSpecs.sw</filename> are processed.  <computeroutput lang="metaslang">FindMatches</computeroutput> is the top-level
spec in the file.</para>

<para>&Specware; finds the specs <computeroutput lang="metaslang">WordMatching</computeroutput> and <computeroutput lang="metaslang">Matches</computeroutput>,
imported by <computeroutput lang="metaslang">FindMatches</computeroutput>, because they are contained in the same
file. As it will be explained shortly, it is possible to refer from
one file to specs defined in different files.</para>

</section>  <!-- specware processing -->

</section>  <!-- specification -->

<section>
<title>Refinement</title>

<section>
<title>Construction</title>

<para>We now refine the application specified above in order to obtain
a running program that implements the specified functionality.  We do
that by defining the specs and morphisms below inside a file
<filename>MatchingRefinements.sw</filename>, in the same directory as
<filename>MatchingSpecs.sw</filename>.</para>

<para>In order to obtain an executable program, we need to choose a
concrete representation for the symbols composing words and
messages. For example, we can choose uppercase characters:</para>

<programlisting lang="metaslang">
    Symbols = spec
      sort Symbol = (Char | isUpperCase)
    endspec
</programlisting>

<para>The built-in sort <computeroutput lang="metaslang">Char</computeroutput> is the sort for characters. The
built-in op <computeroutput lang="metaslang">isUpperCase</computeroutput> is a predicate on characters that says
whether a character is an uppercase letter or not. The subsort
construct <quote><computeroutput lang="metaslang">|</computeroutput></quote> is used to define the sort <computeroutput lang="metaslang">Symbol</computeroutput> as a subsort
of <computeroutput lang="metaslang">Char</computeroutput>.</para>

<para>Note that the above spec has the same name (<computeroutput lang="metaslang">Symbols</computeroutput>) as its
corresponding abstract spec. This is allowed and it is a feature of
&Specware;: <filename>.sw</filename> files define separate name spaces. The file
<filename>MatchingSpecs.sw</filename> creates a name space, and the file
<filename>MatchingRefinements.sw</filename> creates a separate name space. The full
name of the spec <computeroutput lang="metaslang">Symbols</computeroutput> in <filename>MatchingSpecs.sw</filename> is
<computeroutput lang="metaslang">MatchingSpecs#Symbols</computeroutput>, while the full name of the spec <computeroutput lang="metaslang">Symbols</computeroutput>
in <filename>MatchingRefinements.sw</filename> is
<computeroutput lang="metaslang">MatchingRefinements#Symbols</computeroutput>. Indeed, when &Specware; is invoked to
process a spec (or morphism, etc.), the full name is supplied, as in
<computeroutput lang="lisp">:sw MatchingSpecs#FindMatches</computeroutput>.  </para>

<para> The fact that spec <computeroutput lang="metaslang">MatchingRefinements#Symbols</computeroutput> is a
refinement of <computeroutput lang="metaslang">MatchingSpecs#Symbols</computeroutput> is expressed by the following
morphism:</para>

<programlisting lang="metaslang">
    Symbols_Ref = morphism MatchingSpecs#Symbols -&gt;
                           MatchingRefinements#Symbols {}
</programlisting>

<para>This text defines a morphism called <computeroutput lang="metaslang">Symbols_Ref</computeroutput>, with domain
<computeroutput lang="metaslang">MatchingSpecs#Symbols</computeroutput> and codomain <computeroutput lang="metaslang">MatchingRefinements#Symbols</computeroutput>
and where the sort <computeroutput lang="metaslang">Symbol</computeroutput> in <computeroutput lang="metaslang">MatchingSpecs#Symbols</computeroutput> is mapped
to the sort <computeroutput lang="metaslang">Symbol</computeroutput> in <computeroutput lang="metaslang">MatchingRefinements#Symbols</computeroutput>.</para>

<para>The specs <computeroutput lang="metaslang">Words</computeroutput>, <computeroutput lang="metaslang">Messages</computeroutput>, and <computeroutput lang="metaslang">SymbolMatching</computeroutput> (in
<filename>MatchingSpecs.sw</filename>) need not be refined, because they constructively
define their sorts and ops. But the op <computeroutput lang="metaslang">word_matches_at?</computeroutput> in
<computeroutput lang="metaslang">WordMatching</computeroutput> needs to be refined. We do that by constructing a
spec that imports the same specs imported by <computeroutput lang="metaslang">WordMatching</computeroutput> and that
defines op <computeroutput lang="metaslang">word_matches_at?</computeroutput> in an executable way:</para>

<programlisting lang="metaslang">
    WordMatching0 = spec
    
      import MatchingSpecs#Words
      import MatchingSpecs#Messages
      import MatchingSpecs#SymbolMatching
    
      op word_matches_at? : Word * Message * Nat -&gt; Boolean
      def word_matches_at?(wrd,msg,pos) =
          if pos + length wrd &gt; length msg
          then false
          else word_matches_aux?
                (wrd, if pos = 0 then msg
                                 else nthTail(msg, pos - 1))
    
      op word_matches_aux? :
         {(wrd,msg) : Word * Message | length wrd &lt;= length msg}
         -&gt; Boolean
      def word_matches_aux?(wrd,msg) =
          case wrd of Nil -&gt; true
                    | Cons(wsym,wrd1) -&gt;
                      let Cons(msym,msg1) = msg in
                      if symb_matches?(wsym,msym)
                      then word_matches_aux?(wrd1,msg1)
                      else false
    
    endspec
</programlisting>

<para>Since the imported specs are not in the file
<filename>MatchingRefinements.sw</filename>, their full names are used after
<computeroutput lang="metaslang">import</computeroutput>.</para>

<para>The definition of <computeroutput lang="metaslang">word_matches_at?</computeroutput> makes use of an auxiliary
op <computeroutput lang="metaslang">word_matches_aux?</computeroutput>, which takes as input a word and a message
such that the length of the word is not greater than that of the
message. This constraint is expressed as a subsort of the cartesian
product <computeroutput lang="metaslang">Word * Message</computeroutput>. Op <computeroutput lang="metaslang">word_matches_aux?</computeroutput> returns a boolean
if the word matches the message, at the start of the message. It is
defined recursively, by pattern matching on the word.  Note the use of
<computeroutput lang="metaslang">let</computeroutput> to decompose the msg into the initial symbol and the
rest. This is always possible because of the subsort constraint on the
word and the message. So, <computeroutput lang="metaslang">word_matches_at?</computeroutput> simply calls
<computeroutput lang="metaslang">word_matches_aux?</computeroutput> with the word and the tail of the message
obtained by eliminating the first <computeroutput lang="metaslang">pos</computeroutput> symbols, by means of the
built-in op <computeroutput lang="metaslang">nthTail</computeroutput> over lists.</para>

<para>The fact that <computeroutput lang="metaslang">WordMatching0</computeroutput> is a refinement of
<computeroutput lang="metaslang">MatchingSpecs#WordMatching</computeroutput> is expressed by the following
morphism:</para>

<programlisting lang="metaslang">
    WordMatching_Ref0 = morphism MatchingSpecs#WordMatching -&gt;
                                 WordMatching0 {}
</programlisting>

<para>The refinement for word matching can be composed with the
refinement for symbols constructed earlier. This is achieved by means
of &Specware;'s substitution operator:</para>

<programlisting lang="metaslang">
    WordMatching = WordMatching0[Symbols_Ref]
</programlisting>

<para>The resulting spec is like <computeroutput lang="metaslang">WordMatching0</computeroutput>, but in addition
the sort <computeroutput lang="metaslang">Symbol</computeroutput> is defined to consist of uppercase
characters.</para>

<para>The fact that <computeroutput lang="metaslang">MatchingRefinements#WordMatching</computeroutput> is a
refinement of <computeroutput lang="metaslang">MatchingSpecs#WordMatching</computeroutput> is expressed by
the following morphism:</para>

<programlisting lang="metaslang">
    WordMatching_Ref =
       morphism MatchingSpecs#WordMatching -&gt;
                MatchingRefinements#WordMatching {}
</programlisting>

<para>Now we proceed to refine op <computeroutput lang="metaslang">find_matches</computeroutput>. We do that in two
steps, analogously to word matching above. First, we build a spec
<computeroutput lang="metaslang">FindMatches0</computeroutput> that imports the same specs imported by
<computeroutput lang="metaslang">MatchingSpecs#FindMatches</computeroutput> and that defines op <computeroutput lang="metaslang">find_matches</computeroutput> in
an executable way:</para>

<programlisting lang="metaslang">
    FindMatches0 = spec
    
      import MatchingSpecs#WordMatching
      import MatchingSpecs#Matches
    
      op find_matches : Message * List Word -&gt; List Match
      def find_matches(msg,wrds) =
          foldl (fn(wrd,mtchs) -&gt;
                   case find_matches_aux(msg,wrd,0)
                     of Some pos -&gt;
                        Cons({word = wrd, position = pos},
                             mtchs)
                      | None -&gt; mtchs)
                Nil
                wrds
    
      op find_matches_aux : Message * Word * Nat -&gt; Option Nat
      def find_matches_aux(msg,wrd,pos) =
          if pos + length wrd &gt; length msg
          then None
          else if word_matches_at?(wrd,msg,pos)
               then Some pos
               else find_matches_aux(msg, wrd, pos + 1)
    
    endspec
</programlisting>

<para>Op <computeroutput lang="metaslang">find_matches</computeroutput> makes use of the auxiliary op
<computeroutput lang="metaslang">find_matches_aux</computeroutput>, which takes as input a message <computeroutput lang="metaslang">msg</computeroutput>, a word
<computeroutput lang="metaslang">wrd</computeroutput>, and a position <computeroutput lang="metaslang">pos</computeroutput>. It returns either a natural number (a
position where the match starts) or <computeroutput lang="metaslang">None</computeroutput> if there is no match. Op
<computeroutput lang="metaslang">find_matches_aux</computeroutput> first checks if <computeroutput lang="metaslang">msg</computeroutput> is long enough to
possibly contain a match for <computeroutput lang="metaslang">wrd</computeroutput> starting at <computeroutput lang="metaslang">pos</computeroutput>. If that is
not the case, <computeroutput lang="metaslang">None</computeroutput> is returned. Otherwise, <computeroutput lang="metaslang">word_matches_at?</computeroutput> is
called: if it returns <computeroutput lang="metaslang">true</computeroutput>, then the position <computeroutput lang="metaslang">pos</computeroutput> is returned
(wrapped by <computeroutput lang="metaslang">Some</computeroutput>). Otherwise, <computeroutput lang="metaslang">find_matches_aux</computeroutput> is recursively
called, incrementing the position by 1. So, when <computeroutput lang="metaslang">find_matches_aux</computeroutput>
is called with 0 as its third argument, it iterates through the
message to find the first match, if any.  The position of the first
match is returned, otherwise <computeroutput lang="metaslang">None</computeroutput>.</para>

<para>The op <computeroutput lang="metaslang">find_matches</computeroutput> iterates through the words of the list
constructing a list of matches. The iteration is performed by means of
the built-in op <computeroutput lang="metaslang">foldl</computeroutput> for lists. For each word,
<computeroutput lang="metaslang">find_matches_aux</computeroutput> is called, with 0 as its third argument.  Then, a
pattern matching on the result is done: if the result is a position, a
match is added to the output list; otherwise, the list is left
unmodified.</para>

<para>The following morphism expresses that <computeroutput lang="metaslang">FindMatches0</computeroutput> is a
refinement of <computeroutput lang="metaslang">MatchingSpecs#FindMatches</computeroutput>:</para>

<programlisting lang="metaslang">
    FindMatches_Ref0 = morphism MatchingSpecs#FindMatches -&gt;
                                FindMatches0 {}
</programlisting>

<para>This refinement for <computeroutput lang="metaslang">MatchingSpecs#FindMatches</computeroutput> can be
composed with the one for <computeroutput lang="metaslang">MatchingSpecs#WordMatching</computeroutput> built
earlier. The composition is analogous to the one for
<computeroutput lang="metaslang">MatchingSpecs#WordMatching</computeroutput>:</para>

<programlisting lang="metaslang">
    FindMatches = FindMatches0[WordMatching_Ref]
</programlisting>

<para>The resulting spec includes the refinement for op
<computeroutput lang="metaslang">find_matches</computeroutput> as well as the refinement for op <computeroutput lang="metaslang">word_matches_at?</computeroutput>
and for symbols.</para>

<para>The fact that <computeroutput lang="metaslang">MatchingRefinements#FindMatches</computeroutput> is a
refinement of <computeroutput lang="metaslang">MatchingSpecs#FindMatches</computeroutput> is expressed by the
following morphism:</para>

<programlisting lang="metaslang">
    FindMatches_Ref =
      morphism MatchingSpecs#FindMatches -&gt;
               MatchingRefinements#FindMatches {}
</programlisting>

<para>All the specs and morphisms of the file
<filename>MatchingRefinements.sw</filename> can be processed by means of the
following command:</para>

<programlisting lang="lisp">
    :sw MatchingRefinements#FindMatches_Ref
</programlisting>

</section>  <!-- construction -->

<section>
<title>Proof Obligations</title>

<para>In general, a morphism has proof obligations associated to it:
all the axioms in the source spec must be mapped to theorems in the
target spec. These proof obligations are expressed in the form of a
spec obtained by extending the target spec of the morphism with the
axioms of the source spec (translated along the morphism) as
conjectures. The user can then attempt to prove these conjectures
using theorem provers linked to &Specware;.</para>

<para>We collect the proof obligations of the morphisms defined above
in a file <filename>MatchingObligations.sw</filename>, in the same directory as
<filename>MatchingSpecs.sw</filename> and <filename>MatchingRefinements.sw</filename>. The file contains
the following definitions:</para>

<programlisting lang="metaslang">
    SymbolMatching_Oblig = 
      obligations MatchingSpecs#SymbolMatching

    Symbols_Ref_Oblig =
      obligations MatchingRefinements#Symbols_Ref

    WordMatching_Ref0_Oblig =
      obligations MatchingRefinements#WordMatching_Ref0

    FindMatches_Ref0_Oblig =
      obligations MatchingRefinements#FindMatches_Ref0
</programlisting>

<para><computeroutput lang="metaslang">SymbolMatching_Oblig</computeroutput> is a spec that expresses the proof
obligations that arise as a result of typechecking the spec
<computeroutput lang="metaslang">SymbolMatching</computeroutput>. <computeroutput lang="metaslang">Symbols_Ref_Oblig</computeroutput>, <computeroutput lang="metaslang">WordMatching_Ref0_Oblig</computeroutput>,
and <computeroutput lang="metaslang">FindMatches_Ref0_Oblig</computeroutput> are specs that express the proof
obligations of the associated morphisms as conjectures. &Specware;
provides the capability to display (i.e., print) any spec, morphism,
etc., via the <computeroutput lang="metaslang">:show</computeroutput> command. This command can be used to see the
proof obligations associated to the morphisms, by displaying the specs
expressing such obligations.</para>

<para>For instance, the proof obligations associated to the morphism
<computeroutput lang="metaslang">Symbols_Ref</computeroutput> can be displayed by using the following
command:</para>

<programlisting lang="metaslang">
    :show MatchingObligations#Symbols_Ref_Oblig
</programlisting>

<para>The absence of conjectures indicates that no proof obligations
need to be discharged in order to establish the validity of the
morphism <computeroutput lang="metaslang">Symbols_Ref</computeroutput>. In fact, this morphism is very simple: its
source <computeroutput lang="metaslang">MatchingSpecs#Symbols</computeroutput> has no axioms, just an abstract sort
<computeroutput lang="metaslang">Symbol</computeroutput> that the morphism maps to the concretely defined sort
<computeroutput lang="metaslang">Symbol</computeroutput> in <computeroutput lang="metaslang">MatchingRefinements#Symbols</computeroutput>.</para>

<para>Unlike <computeroutput lang="metaslang">Symbols_Ref</computeroutput>, <computeroutput lang="metaslang">WordMatching_Ref0</computeroutput> has a non-trivial
proof obligation that needs to be discharged in order to establish the
validity of the morphism. Inspection (via <computeroutput lang="metaslang">:show</computeroutput>) of the spec
<computeroutput lang="metaslang">WordMatching_Ref0_Oblig</computeroutput> reveals a conjecture. The conjecture is
the axiom about <computeroutput lang="metaslang">word_matches_at?</computeroutput> in
<computeroutput lang="metaslang">MatchingSpecs#WordMatching</computeroutput>, which is indeed provable from the
executable definition of <computeroutput lang="metaslang">word_matches_at?</computeroutput>.</para>

<para>Also <computeroutput lang="metaslang">FindMatches_Ref0</computeroutput> has a non-trivial proof obligation,
consisting of the axiom about <computeroutput lang="metaslang">find_matches</computeroutput> in
<computeroutput lang="metaslang">MatchingSpecs#FindMatches</computeroutput>. This obligation is indeed provable from
the executable definition of <computeroutput lang="metaslang">find_matches</computeroutput>.</para>

<para>The validity of the morphisms <computeroutput lang="metaslang">WordMatching_Ref</computeroutput> and
<computeroutput lang="metaslang">FindMatches_Ref</computeroutput> follows from the validity of the morphisms
<computeroutput lang="metaslang">Symbols_Ref</computeroutput>, <computeroutput lang="metaslang">WordMatching_Ref0</computeroutput>, and <computeroutput lang="metaslang">FindMatches_Ref0</computeroutput>. The
reason is that sequential composition of morphisms always yields a
morphism and that substitution always produces a spec and (implicitly)
two morphisms.</para>

<para><computeroutput lang="metaslang">WordMatching_Ref</computeroutput> is the sequential composition of
<computeroutput lang="metaslang">WordMatching_Ref0</computeroutput> with the morphism from <computeroutput lang="metaslang">WordMatching0</computeroutput> to
<computeroutput lang="metaslang">MatchingRefinements#WordMatching</computeroutput> that is implicitly computed by
the substitution operator used to define
<computeroutput lang="metaslang">MatchingRefinements#WordMatching</computeroutput>. Similarly, <computeroutput lang="metaslang">FindMatches_Ref</computeroutput>
is the sequential composition of <computeroutput lang="metaslang">FindMatches_Ref0</computeroutput> with the
morphism from <computeroutput lang="metaslang">FindMatches0</computeroutput> to <computeroutput lang="metaslang">MatchingRefinements#FindMatches</computeroutput>
that is implicitly computed by the substitution operator used to
define <computeroutput lang="metaslang">MatchingRefinements#FindMatches</computeroutput>.</para>

<para>&Specware; provides the capability to invoke external theorem
provers in order to attempt proofs of conjectures. Concretely, this is
carried out by creating proof objects. Each proof object is associated
with a certain conjecture in a certain spec; it also indicates the
prover to use and some directives on how to perform the proof.
Processing of the proof object invokes the indicated prover with the
given directives. Currently, the only available prover is Snark; more
provers will be added in the future.</para>

<para>For example, the user can attempt to discharge the proof
obligation for <computeroutput lang="metaslang">MatchingSpecs#SymbolMatching</computeroutput> by writing the
following command in a file named <filename>MatchingProof.sw</filename>, located in the
same directory as <filename>MatchingObligations.sw</filename>:

<programlisting lang="metaslang">
    prove symb_matches? in
      MatchingObligations#SymbolMatching_Oblig
</programlisting>

Then at the Lisp prompt, issue this command to discharge the proof:

<programlisting lang="lisp">
    :sw MatchingProof
</programlisting>

The obligation is translated to the Snark theorem prover and
automatically proven based primarily on the knowledge of &Specware;'s
<computeroutput lang="metaslang">Option</computeroutput> sort that we automatically send to Snark.</para>

</section> <!-- proof obligations -->

</section>  <!-- refinement -->

<section>
<title>Alternatives</title>

<para>The refinement for the word matching application developed above
is certainly not the only one possible.</para>

<para>For example, we could have refined symbols differently. We could
have refined them to be all letters (uppercase or lowercase) and
numbers, or to be natural numbers. It is worth noting that the
refinement for symbols is encapsulated in spec
<computeroutput lang="metaslang">MatchingRefinements#Symbols</computeroutput>. If we want to change the refinement
for symbols, we just need to change that spec, while the other specs
remain unaltered.</para>

<para>As another example, we could have chosen a more efficient
refinement for op <computeroutput lang="metaslang">find_matches</computeroutput>, using some fast substring search
algorithm.  In particular, while we have refined op
<computeroutput lang="metaslang">word_matches_at?</computeroutput> first, and then composed its refinement with one
for <computeroutput lang="metaslang">find_matches</computeroutput>, we could have refined <computeroutput lang="metaslang">find_matches</computeroutput>
<quote>directly</quote>, without using <computeroutput lang="metaslang">word_matches_at?</computeroutput>, so that it would
have been unnecessary to refine <computeroutput lang="metaslang">word_matches_at?</computeroutput>.</para>

<para>The latter example illustrates an important principle concerning
refinement. In general, it is not necessary to refine all ops present
in a spec. Only the ops that are meant to be used by an external
program need to be refined to be executable, and in turn the ops that
are used inside their executable definitions. Other ops serve only an
auxiliary role in specifying abstractly the ops that are meant to be
eventually refined.</para>

<para>Currently, &Specware; provides no support to indicate explicitly
which ops are meant to be <quote>exported</quote> by a spec. In future versions
of the system, some functionality like this may be included.</para>

</section>  <!-- alternatives -->

<section>
<title>Code Generation and Testing</title>

<section>
<title>Code Generation</title>

<para>Now that our simple word matching application has been refined
to be executable, we can generate code from it. This is concretely
achieved by creating a (Lisp) program from a spec, indicating a file
name where the code is deposited as a side effect. The following
command is given in the Lisp shell:</para>

<programlisting lang="lisp">
    :swl &lt;specname&gt; &lt;targetfilename&gt;
</programlisting>

<para>The above command first processes the named spec and then
generates Lisp code from it, writing the code into the indicated file.
The file is created if it does not exist; if it exists, it is
overwritten.</para>

<para>For instance, we can generate Lisp code for the word matching
application by means of the following command:</para>

<programlisting lang="lisp">
    :swl MatchingRefinements#FindMatches find-matches
</programlisting>

<para>Note that if the <filename>.lisp</filename> suffix is omitted, &Specware; adds it
to the file name.</para>

<para>After we generate the code, we can then try to run it by calling
the Lisp function produced from op <computeroutput lang="metaslang">find_matches</computeroutput>. Since messages
and words are represented as lists of characters (plus <computeroutput lang="metaslang">None</computeroutput> for
messages), it would be slightly inconvenient to enter and read lists
of characters. It would be better to enter strings with letters and
<computeroutput lang="metaslang">*</computeroutput>'s, as shown in the informal problem description at the beginning
of this chapter.</para>

<para>In order to do that, we define translations between strings and
messages and words, and we wrap <computeroutput lang="metaslang">find_matches</computeroutput> in order to translate
from and to strings. We do that inside a spec called <computeroutput lang="metaslang">Test</computeroutput> in a
file <filename>MatchingTest.sw</filename> in the same directory as the other two
<filename>.sw</filename> files:</para>

<programlisting lang="metaslang">
    Test = spec
    
      import MatchingRefinements#FindMatches
    
      op word_char? : Char -&gt; Boolean
      def word_char? ch = isUpperCase ch
    
      op msg_char? : Char -&gt; Boolean
      def msg_char? ch = isUpperCase ch or ch = #*
    
      sort WordString = (String | all word_char?)
    
      sort MessageString = (String | all msg_char?)
    
      op word2string : Word -&gt; WordString
      def word2string wrd = implode wrd
    
      op string2word : WordString -&gt; Word
      def string2word wstr = explode wstr
    
      op message2string : Message -&gt; MessageString
      def message2string msg =
          implode(map (fn msym -&gt; case msym
                                    of Some ch -&gt; ch
                                     | None -&gt; #*)
                      msg)
    
      op string2message : MessageString -&gt; Message
      def string2message mstr =
          map (fn ch -&gt; if ch = #* then None else Some ch)
              (explode mstr)
    
      sort MatchString = {word : WordString, position : Nat}
    
      op match2string : Match -&gt; MatchString
      def match2string mtch =
          {word     = word2string mtch.word,
           position = mtch.position}
    
      op test_find_matches :
         MessageString * List WordString -&gt; List MatchString
      def test_find_matches(mstr,wstrs) =
          map match2string
              (find_matches(string2message mstr,
                            map string2word wstrs))
    
    endspec
</programlisting>

<para>Since the translation is not defined on all strings, we
introduce two subsorts of the built-in sort <computeroutput lang="metaslang">String</computeroutput>: the sort
<computeroutput lang="metaslang">WordString</computeroutput> consists of all strings whose characters are uppercase
letters; the sort <computeroutput lang="metaslang">MessageString</computeroutput> consists of all strings whose
characters are uppercase letters or <computeroutput lang="metaslang">*</computeroutput>. The built-in op <computeroutput lang="metaslang">all</computeroutput>
over strings is used to define the subsorts, using the ops
(predicates) <computeroutput lang="metaslang">word_char?</computeroutput> and <computeroutput lang="metaslang">msg_char?</computeroutput>.</para>

<para>The op <computeroutput lang="metaslang">word2string</computeroutput> translates a word to a word string, by
means of the built-in op <computeroutput lang="metaslang">implode</computeroutput>. The op <computeroutput lang="metaslang">string2word</computeroutput> performs
the opposite translation, using the built-in op <computeroutput lang="metaslang">explode</computeroutput>. The ops
<computeroutput lang="metaslang">message2string</computeroutput> and <computeroutput lang="metaslang">string2message</computeroutput> translate between messages
and string messages. Besides the use of <computeroutput lang="metaslang">implode</computeroutput> and <computeroutput lang="metaslang">explode</computeroutput>,
they need to map <computeroutput lang="metaslang">Some ch</computeroutput> from/to <computeroutput lang="metaslang">ch</computeroutput> (where <computeroutput lang="metaslang">ch</computeroutput> is an
uppercase letter) and <computeroutput lang="metaslang">None</computeroutput> from/to <computeroutput lang="metaslang">*</computeroutput>.</para>

<para>Since <computeroutput lang="metaslang">find_matches</computeroutput> returns a match, i.e., a pair consisting
of a word and a position, we define a sort <computeroutput lang="metaslang">MatchString</computeroutput> consisting
of a word string and a position, together with an op <computeroutput lang="metaslang">match2string</computeroutput>
that translates from a match to a string match.</para>

<para>Finally, we define an op <computeroutput lang="metaslang">test_find_matches</computeroutput> to take a message
string and a list of word strings as input, and to return a list of
string matches as output. The message string and word strings are
first translated to a message and list of words, then <computeroutput lang="metaslang">find_matches</computeroutput>
is called, and then the resulting matches are translated to string
matches.  Note that the op <computeroutput lang="metaslang">message2string</computeroutput> is never used. In fact,
it could have been omitted.</para>

<para>Now, instead of generating code from
<computeroutput lang="metaslang">MatchingRefinements#FindMatches</computeroutput>, we generate code from
<computeroutput lang="metaslang">MatchingTest#Test</computeroutput>:</para>

<programlisting lang="lisp">
    :swl MatchingTest#Test find-matches-test.lisp
</programlisting>

<section>
<title>Testing</title>

<para>In order to test the generated code, we need to load the
generated Lisp file into the Lisp environment. We do that from the
Lisp shell, by means of the following command:</para>

<programlisting lang="lisp">
    :ld find-matches-test
</programlisting>

<para>In Lisp, entities like functions, constants, etc. are defined
inside packages. When &Specware; generates code, it puts it inside a
package named <computeroutput lang="metaslang">SW-USER</computeroutput>. This can be seen from the package
declaration at the beginning of file <filename>find-matches-test.lisp</filename> (note
that Lisp is case-insensitive).</para>

<para>So, in order to call the functions defined in that file (after
it has been loaded), it is necessary either to prepend the package
name to them, or to move to that package and then call them without
package qualification.  To follow the first approach, we would write
<computeroutput lang="metaslang">(sw-user::test_find_matches &lt;arg1&gt; &lt;arg2&gt;)</computeroutput> to call the function.
To follow the second approach, we would first change package by means
of the Lisp command <computeroutput lang="metaslang">:pa sw-user</computeroutput>, and then we can just write 
<computeroutput lang="metaslang">(test_find_matches &lt;arg1&gt; &lt;arg2&gt;)</computeroutput> to call the function.</para>

<para>In order to test the program on the example input and output
given at the beginning of the chapter, we proceed as follows. First,
we define a variable containing the message:</para>

<programlisting lang="lisp">
    (setq msg "**V*ALN**EC*E*S")
</programlisting>

<para>Then we define a variable containing the list of words:</para>

<programlisting lang="lisp">
    (setq words '("CERAMIC" "CHESS" "DECREE" "FOOTMAN"
                  "INLET" "MOLOCH" "OCELOT" "PROFUSE"
                  "RESIDE" "REVEAL" "SECRET" "SODIUM"
                  "SPECIES" "VESTIGE" "WALNUT" "YOGURT"))
</programlisting>

<para>Finally, we call (assuming to be in package <computeroutput lang="metaslang">sw-user</computeroutput>):</para>

<programlisting lang="lisp">
    (test_find_matches msg words)
</programlisting>

<para>The following result is then displayed:</para>

<programlisting lang="lisp">
    ((3 . "WALNUT") (7 . "SPECIES") (8 . "SECRET")
     (0 . "REVEAL") (8 . "DECREE") (10 . "CHESS"))
</programlisting>

<para>The result is a list of pairs, each of which represents a
match.</para>

</section>  <!-- testing -->

</section>  <!-- code gen and testing -->

</section>

</chapter>
