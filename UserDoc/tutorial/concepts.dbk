<chapter id="concepts">
<title>&Specware; Concepts</title>

<section>
<title>Overview</title>

<para>&Specware; is designed with the idea that large and complex
problems can be specified by combining small and simple
specifications, and that problem specifications can be refined into a
working system by the controlled stepwise introduction of
implementation design decisions, in such a way that the refined
specifications and ultimately the working code is a provably correct
refinement of the original problem specification.</para>

<para>&Specware; allows you to express requirements as formal
specifications without regard to the ultimate implementation or target
language.  Specifications can describe the desired functionality of a
program independently of such implementation concerns as architecture,
algorithms, data structures, and efficiency.  This makes it possible
to focus on the correctness, which is crucial to the reliability of
large software systems.</para>

<para>Often, there are many possible solutions to a single problem,
all valid, with different advantages and drawbacks.  It is sometimes
very difficult to make a decision given all the different trade-offs.
Using &Specware;, the analysis of the problem can be kept separate from
the implementation process, and implementation choices can be
introduced piecemeal, making it easier to backtrack or explore
alternatives.</para>

<para>&Specware; allows you to articulate software requirements, make
implementation choices, and generate provably correct code in a
formally verifiable manner.  The progression of specifications forms a
record of the system design and development that is invaluable for
system maintenance.  You can later adapt the specifications to new or
changed requirements or make different implementation decisions at any
level of the development while reusing what has not changed, and
generate provably correct new code by the same process.</para>

</section>  <!-- overview -->

<section>
<title>&Specware; Development Process</title>

<section>
<title>Building Specifications</title>

<para>The first step in building an application in &Specware; is to
describe the problem domain in abstract form.  You use the &Metaslang;
language to build specifications (specs) that describe the abstract
concepts of the problem domain.  Specs contain sorts, which are like
data types, operations, which are functions defined on sorts, and
axioms, which describe the required properties of the operations in
logical formulas.</para>

<para>To design specifications, you may combine top-down and bottom-up
approaches.  To begin, you break down the problem domain into small,
manageable parts that you can understand more easily in complete
detail.  You create specifications for each part.  This conceptual
decomposition process allows you to isolate and describe each detail
of functionality.</para>

<para>You then extend and compose the smaller specifications to form
a larger, more complex specification.</para>

<para>You create morphisms to describe how specifications are related.
A morphism is a formal mapping between two specifications that
describes exactly how one is translated or extended into the other.
Morphisms can describe <quote>part-of</quote> as well as <quote>is-a</quote>
relationships.</para>

<para>You can extend a specification by importing it and adding new
concepts.  When you extend a specification, you can also translate the
names of the concepts to a different terminology.</para>

<para>As you extend the specification, you provide more and more
information about the structure and details of the sorts and
operations, by including axioms and theorems to describe them.</para>

<para>You compose simple specifications to form more complex
specifications using the colimit operation.  Colimit
<quote>glues</quote> specs together along shared concepts.  Morphisms
describe exactly how concepts are shared.</para>

</section> <!-- building -->

<section>
<title>Refining Specifications</title>

<para>When you have described the abstract concepts in your problem
domain, you begin the refinement process.  Refinement maps a problem
specification set into a solution specification set.  Refinements
replace functionality constraints with algorithms and abstract sorts
with implementation data structures.  You refine a specification by
mapping it into the implementation domain.  You describe how the
concepts of the problem domain are implemented in terms of
computational concepts.  Computational concepts, such as numbers
(e.g., integers) and collections (e.g., lists) are already specified
in the &Specware; library.  In the process of refinement, you build a
bridge from your abstract specifications to these concrete,
implementation-specific specifications.</para>

<para>Morphisms are also used to describe how each specification is to
be mapped into a desired target specification.  The source spec is a
more abstract description of concepts, while the target spec describes
those concepts more concretely. Often, the target spec is obtained by
extending some other spec that contains concepts in term of which the
concepts of the source spec are expressed.  For example, if you have
an abstract spec for a house, you can refine it by importing a spec
for materials (wood, etc.) and expressing how the house is built in
terms of those materials.</para>

<para>A morphism maps each sort or operation of the source spec to a
sort or operation of the target spec. In certain cases, it may be
useful to map a sort or operation to a new sort or operation that is
not present in the target spec but that is defined in terms of those
in the target spec. Interpretations are used for this purpose.</para>

<para>An interpretation contains three specs: a source spec (the
domain), a target spec (the codomain), and a mediator.  The mediator
spec extends the target, so there is an inclusion morphism from the
target to the mediator.  A morphism from the source spec to the
mediator expresses how the source spec maps to the extension of the
target spec.</para>

<para>A morphisms can be viewed as a particular kind of interpretation
where the mediator coincides with the target. Indeed, the refinement
relation between a more abstract spec and a more concrete one can be
expressed by a morphism but also by an interpretation.</para>

</section>  <!-- refining -->

<section>
<title>Extending Refinements</title>

<para>You build up a refinement in the same way you build up a
specification, in an iterative, stepwise progression.  You build basic
morphisms (or interpretations) from more abstract specs to more
concrete specs, then compose the morphisms to extend the refinement.
There are two ways to compose morphisms.</para>

<para>Sequential composition 
(<computeroutput lang="metaslang">A=&gt;B + B=&gt;C = A=&gt;C</computeroutput>) 
deepens a refinement.  For example, if you are specifying a house, you
might use sequential composition of morphisms to create an
increasingly detailed description of a single room.</para>

<para>Parallel composition 
(<computeroutput lang="metaslang">A=&gt;A' + B=&gt;B' = (A,B) =&gt; (A',B')</computeroutput>)
widens, or increases the complexity of a refinement.  For example, in
the specification of a house, when you have several morphisms that
refine different rooms, you could combine them in parallel to create a
description of a multi-room house.  You could do this before or after
providing the additional detail for each one.  You use the colimit
method for this kind of composition, as you do to compose
specifications.</para>

<para>&Specware; contains a library of specs that fully describe various
mathematical and computational concepts that you need to produce an
implementation of an abstract specification.  The goal of refinement
is to refine your abstract specs in terms of these library specs.
This process guarantees that &Specware; can generate code to implement
your specifications in its target language, Lisp.</para>

</section>  <!-- extending -->

<section>
<title>Generating Code</title>

<para>Once the abstract spec is refined to a <quote>constructive</quote> spec,
&Specware; can generate code in the target language.  The generated code
contains a function for each of the operations you have described in
the abstract specification.  After you examine and test it, you can
embed it in an application that uses the functions.</para>

</section>  <!-- generating -->

</section>  <!-- process -->

<section>
<title>Specification Components</title>

<para>A specification (spec) consists of some sorts, some operations
(ops), and some axioms about the sorts and ops.</para>

<section>
<title>Sorts, Operations, Axioms</title>

<para>A sort is a syntactic entity that denotes a set of values. In
its simplest form, a sort is a symbol. For example, a spec can contain
a sort <computeroutput lang="metaslang">Nat</computeroutput> that denotes the set of natural numbers,
i.e., 0, 1, 2, ...</para>

<para>Sort symbols can be combined by means of some pre-defined
constructs to build more complex sorts. One such construct is
<quote><computeroutput lang="metaslang">-&gt;</computeroutput></quote>: if <computeroutput lang="metaslang">A</computeroutput> and
<computeroutput lang="metaslang">B</computeroutput> are sorts, <computeroutput lang="metaslang">A -&gt; B</computeroutput> is also a
sort.  The set denoted by <computeroutput lang="metaslang">A -&gt; B</computeroutput> is the set of
all total functions from the set denoted by <computeroutput lang="metaslang">A</computeroutput> to
the set denoted by <computeroutput lang="metaslang">B</computeroutput>.</para>

<para>An op is a syntactic symbol accompanied by a sort: the sort is
the <quote>type</quote> of the op. An op denotes an element of the set
denoted by its sort.  For example, a spec can contain an op <computeroutput lang="metaslang">zero</computeroutput>
of type <computeroutput lang="metaslang">Nat</computeroutput>, which denotes the natural number 0. It can also
contain an op <computeroutput lang="metaslang">succ</computeroutput> of type <computeroutput lang="metaslang">Nat -&gt; Nat</computeroutput>, which denotes the
function that returns the successor of any given natural
number.</para>

<para>From the sort <computeroutput lang="metaslang">Nat</computeroutput> and the ops
<computeroutput lang="metaslang">zero</computeroutput> and <computeroutput lang="metaslang">succ</computeroutput> alone, it does not
follow that they denote the natural numbers, 0, and successor
function. They could denote the set of the days of the week,
Wednesday, and the identity function, respectively. The intended
meaning can be enforced by means of axioms.</para>

<para>An axiom is a term of type <computeroutput lang="metaslang">Boolean</computeroutput>. <computeroutput lang="metaslang">Boolean</computeroutput> is a sort
automatically present (built-in) in every spec, which denotes the set
of boolean truth values (<quote>true</quote> and
<quote>false</quote>). Terms are built from typed variables (a
variable is a symbol accompanied by a sort), ops, and some pre-defined
constructs. These include universal and existential quantifiers
(<quote>for all</quote> and <quote>exists</quote>), logical
connectives (<quote>and</quote>, <quote>or</quote>,
<quote>implies</quote>, <quote>iff</quote>, <quote>not</quote>), and
equality.</para>

<para>Here is an example of an axiom to constrain successor never to
return 0:</para>
<programlisting lang="metaslang">
    fa(x) ~(succ x = zero)
</programlisting>

<para>In the axiom, <quote><computeroutput lang="metaslang">=</computeroutput></quote> denotes equality,
<quote><computeroutput lang="metaslang">~</computeroutput></quote> boolean negation, and
<quote><computeroutput lang="metaslang">fa</computeroutput></quote> universal quantification. Note that this
axiom rules out the possibility that <computeroutput lang="metaslang">succ</computeroutput> is the
identity function.  Additional axioms can be added to constrain the
spec to capture exactly the natural numbers (essentially, the rest of
Peano's axioms).</para>

</section>

<section>
<title>Models</title>

<para>In the above description, the notion of a sort or op
<quote>denoting</quote> a set or a function corresponds to the notion
of model of a spec. A model of a spec is an assignment of a set to
each sort and of an element to each op from the set assigned to the
type of the op, such that all the axioms of the spec are
satisfied.</para>

<para>In the example spec sketched above, a model consists of a set
<replaceable>N</replaceable> assigned to <computeroutput lang="metaslang">Nat</computeroutput>, an element
<replaceable>z</replaceable> in <replaceable>N</replaceable> assigned
to <computeroutput lang="metaslang">zero</computeroutput>, and a function <replaceable>s</replaceable> from
<replaceable>N</replaceable> to <replaceable>N</replaceable> (i.e., an
element <replaceable>s</replaceable> of the set denoted by <computeroutput lang="metaslang">Nat -&gt; Nat</computeroutput>)
assigned to <computeroutput lang="metaslang">succ</computeroutput>.  In the absence of axioms, the model where
<replaceable>N</replaceable> consists of the days of the week,
<replaceable>z</replaceable> Wednesday, and
<replaceable>s</replaceable> identity, is a valid model. But with the
axiom shown above, since <replaceable>s(z) = z</replaceable>, this
cannot be a model. With the rest of Peano's axioms,
<replaceable>N</replaceable>, <replaceable>z</replaceable>, and
<replaceable>s</replaceable> are constrained to be isomorphic to
natural numbers, 0, and successor.  (No matter how many axioms are
added to the spec, it is not possible to pin down
<replaceable>N</replaceable> to be exactly the set of natural
numbers. Things can be pinned down only up to isomorphism. But this is
fine because isomorphic sets are totally equivalent.)</para>

<para>A spec may have no models. This happens when the spec contains
incompatible axioms. This situation is often subtle and difficult to
detect, and it is always a symptom of human errors in the
specification process. Whether a spec has models or not is an
undecidable problem. However, by following certain practices and
disciplines in the development of specs, this situation can be
avoided.</para>

</section>

<section>
<title>Polymorphism</title>

<para>Sorts can be polymorphic. In its simplest form, a polymorphic
sort is a symbol plus one or more <quote>parameter
sorts</quote>. While a monomorphic (i.e., non-polymorphic) sort
denotes a set, a polymorphic sort denotes a function that returns a
set given sets for all its parameters. For example, a spec can contain
a sort <computeroutput lang="metaslang">List a</computeroutput>, where <computeroutput lang="metaslang">a</computeroutput> is the sort parameter, which denotes
the set of (finite) lists over <computeroutput lang="metaslang">a</computeroutput>: more precisely, it denotes a
function that, given a set <replaceable>S</replaceable> for <computeroutput lang="metaslang">a</computeroutput>,
returns the set of all lists of elements of
<replaceable>S</replaceable>. If <replaceable>S</replaceable> is the
set of natural numbers, it returns the set of all lists of natural
numbers; if <replaceable>S</replaceable> is the set of the days of the
week, it returns the set of all lists of days of the week.</para>

<para>A polymorphic sort can be instantiated by replacing its
parameters with other sorts. The latter can be polymorphic or
monomorphic: if at least one is polymorphic, the instantiated sort is
polymorphic; otherwise, it is monomorphic. For example, <computeroutput lang="metaslang">List a</computeroutput> can
be instantiated to the monomorphic <computeroutput lang="metaslang">List Nat</computeroutput> or to the polymorphic
<computeroutput lang="metaslang">List(List a)</computeroutput>.</para>

<para>Correspondingly, ops can be polymorphic. An op is polymorphic
when its type is a polymorphic sort. While a monomorphic op denotes an
element of the set denoted by the type of the op, a polymorphic op
denotes a function that, given a set for each parameter sort of the
polymorphic type of the op, returns an element of the set obtained by
applying to such parameter sets the function denoted by the type of
the op. For example, a spec can contain an op <computeroutput lang="metaslang">nil</computeroutput>
of type <computeroutput lang="metaslang">List a</computeroutput>, that denotes the empty list, for
each set assigned to parameter <computeroutput lang="metaslang">a</computeroutput>.</para>

</section>

<section>
<title>Morphisms</title>

<para>A morphism is a mapping from a source spec to a target
spec. More precisely, it consists of two functions: one maps each sort
symbol of the source to a sort symbol of the target, and the other
maps each op symbol of the source to an op symbol of the target. The
mapping must be type-consistent: if <computeroutput lang="metaslang">f</computeroutput> of type <computeroutput lang="metaslang">T</computeroutput> in the source
spec is mapped to <computeroutput lang="metaslang">g</computeroutput> of type <computeroutput lang="metaslang">U</computeroutput> in the target spec, then <computeroutput lang="metaslang">T</computeroutput>
must be mapped to <computeroutput lang="metaslang">U</computeroutput>. This mapping of sorts and ops can be lifted
to terms, and thus to the axioms of the source spec. A morphism must
be such that each axiom of the source spec maps to a theorem in the
target spec: in other words, the translation of the axiom (according
to the mapping expressed by the morphism) must be provable from the
axioms in the target spec.</para>

<para>So, a morphism expresses that all the properties (i.e., the
axioms) of the source spec are satisfied by the target spec. This is
why refinement is expressed by means of morphisms: the source spec
contains more abstract concepts; the target spec contains more
concrete concepts, but all the properties of the abstract concepts
must be satisfied by the concrete ones.</para>

<para>At the level of models, a morphism <computeroutput lang="metaslang">m</computeroutput> induces a function that
maps models of the target spec to models of the source spec (the
function goes in the opposite direction of the morphism). The function
operates as follows: given a model of the target spec, the
corresponding model of the source spec is constructed as follows. The
set assigned to a sort <computeroutput lang="metaslang">S</computeroutput> of the source spec is the set assigned to
<computeroutput lang="metaslang">m(S)</computeroutput> by the model of the target spec (or, if <computeroutput lang="metaslang">S</computeroutput> is polymorphic,
replace <quote>set</quote> with <quote>set-valued function over
sets</quote>); the element assigned to an op <computeroutput lang="metaslang">f</computeroutput> of type <computeroutput lang="metaslang">S</computeroutput> of
the source spec is the element (of the set assigned to <computeroutput lang="metaslang">S</computeroutput>) assigned
to <computeroutput lang="metaslang">m(f)</computeroutput> by the model of the target spec (or, if <computeroutput lang="metaslang">f</computeroutput> has a
polymorphic type, replace <quote>element</quote> with
<quote>element-valued function over sets</quote>).</para>

<para>In other words, the morphism induces a reduction of the models
of the target spec to models of the source spec. A model of the target
spec can be reduced to a model of the source spec. This shows how a
morphism can express an <quote>is-a</quote> relationship.</para>

<para>For example, if a spec imports another spec, possibly adding
sorts, ops, and axioms, there is an inclusion morphism from the
imported spec to the importing spec. Since all the sorts, ops, and
axioms are mapped to themselves, the fact that axioms are mapped to
theorems is immediate.</para>

<para>As another, less trivial example, consider a spec for natural
numbers that also includes an op <computeroutput lang="metaslang">plus</computeroutput> and an op <computeroutput lang="metaslang">times</computeroutput>, both
of type <computeroutput lang="metaslang">Nat * Nat -&gt; Nat</computeroutput>. (The construct <quote><computeroutput lang="metaslang">*</computeroutput></quote>
builds the cartesian product of two sorts: in a model, <computeroutput lang="metaslang">A * B</computeroutput>
denotes the cartesian product of the set denoted by <computeroutput lang="metaslang">A</computeroutput> and the set
denoted by <computeroutput lang="metaslang">B</computeroutput>.) The spec also contains axioms that define <computeroutput lang="metaslang">plus</computeroutput>
and <computeroutput lang="metaslang">times</computeroutput> to be addition and multiplication. Now, consider another
spec consisting of a sort <computeroutput lang="metaslang">X</computeroutput>, an op <computeroutput lang="metaslang">f</computeroutput> of type <computeroutput lang="metaslang">X * X -&gt; X</computeroutput>,
and an axiom stating that <computeroutput lang="metaslang">f</computeroutput> is commutative:</para>

<programlisting lang="metaslang">
    fa(x,y) f(x,y) = f(y,x)
</programlisting>

<para>There is a morphism from the latter spec to the former that maps
<computeroutput lang="metaslang">X</computeroutput> to <computeroutput lang="metaslang">Nat</computeroutput> and
<computeroutput lang="metaslang">f</computeroutput> to <computeroutput lang="metaslang">plus</computeroutput>: since addition is
commutative, the commutativity axiom can be proved as a theorem in the
spec for natural numbers. Note that there is also another morphism
that maps <computeroutput lang="metaslang">X</computeroutput> to <computeroutput lang="metaslang">Nat</computeroutput> and
<computeroutput lang="metaslang">f</computeroutput> to <computeroutput lang="metaslang">times</computeroutput>.</para>

</section>

<section>
<title>Diagrams and Colimits</title>

<para> A diagram is a graph whose nodes are labeled by specs and whose
edges are labeled by morphisms. The morphism labeling an edge must be
such that its source is the spec labeling the source node of the edge,
and its target is the spec labeling the target node of the edge.
</para>

<para> The colimit operation produces a spec from a diagram. The
resulting spec is the gluing of the specs of the diagram, with the
sharing expressed by the morphisms of the diagram.  </para>

<para> In order to understand how the colimit operation works,
consider first the simple case of a diagram without edges (and
morphisms). This is called a discrete diagram. The colimit operation
produces a spec whose sorts, ops, and axioms are the disjoint union of
the sorts, ops, and axioms of the specs in the diagram. In other
words, the specs are all glued together without any sharing.  </para>

<para> Now, consider a diagram with some edges, labeled by
morphisms. The colimit operation produces a spec containing all the
sorts, ops, and axioms of the specs in the diagram, but all the sorts
or ops that are linked, directly or indirectly, through the morphisms,
are identified (i.e., they are the same sort or op).  </para>

<para>Consider, for example, a diagram with three nodes,
<computeroutput lang="metaslang">a</computeroutput>, <computeroutput lang="metaslang">b</computeroutput>, and <computeroutput lang="metaslang">c</computeroutput>,
and two edges, one from <computeroutput lang="metaslang">a</computeroutput> to <computeroutput lang="metaslang">b</computeroutput>
and the other from <computeroutput lang="metaslang">a</computeroutput> to <computeroutput lang="metaslang">c</computeroutput>. Node
<computeroutput lang="metaslang">a</computeroutput> is labeled by a spec consisting of a sort
<computeroutput lang="metaslang">X</computeroutput>, node <computeroutput lang="metaslang">b</computeroutput> by a spec consisting
of two sorts <computeroutput lang="metaslang">Y</computeroutput> and <computeroutput lang="metaslang">Z</computeroutput>, and node
<computeroutput lang="metaslang">c</computeroutput> by a spec consisting of a sort
<computeroutput lang="metaslang">W</computeroutput>. The morphism labeling the edge from
<computeroutput lang="metaslang">a</computeroutput> to <computeroutput lang="metaslang">b</computeroutput> maps <computeroutput lang="metaslang">X</computeroutput>
to <computeroutput lang="metaslang">Y</computeroutput>, and the one labeling the edge from
<computeroutput lang="metaslang">a</computeroutput> to <computeroutput lang="metaslang">c</computeroutput> maps <computeroutput lang="metaslang">X</computeroutput>
to <computeroutput lang="metaslang">W</computeroutput>.  The colimit contains all sorts
<computeroutput lang="metaslang">X</computeroutput>, <computeroutput lang="metaslang">Y</computeroutput>, <computeroutput lang="metaslang">Z</computeroutput>, and
<computeroutput lang="metaslang">W</computeroutput>, but <computeroutput lang="metaslang">X</computeroutput>, <computeroutput lang="metaslang">Y</computeroutput>,
and <computeroutput lang="metaslang">W</computeroutput> are identified.  So, the colimit effectively
contains two sorts, one that can be referred to as
<computeroutput lang="metaslang">X</computeroutput>, <computeroutput lang="metaslang">Y</computeroutput>, or <computeroutput lang="metaslang">W</computeroutput>,
and the other that can be only referred to as
<computeroutput lang="metaslang">Z</computeroutput>. For diagrams of this shape, with three nodes and
two edges forming a wedge, the colimit operation is also called a
pushout.</para>

</section>

<section>
<title>Substitutions</title>

<para>Given a spec <computeroutput lang="metaslang">S</computeroutput> and a morphism <computeroutput lang="metaslang">M</computeroutput>, it is possible (under
certain conditions) to substitute the domain of <computeroutput lang="metaslang">M</computeroutput> with its
codomain inside <computeroutput lang="metaslang">S</computeroutput>. Another way to say the same thing is that it is
possible to <quote>apply</quote> the morphism <computeroutput lang="metaslang">M</computeroutput> to the spec
<computeroutput lang="metaslang">S</computeroutput>.</para>

<para>Let <computeroutput lang="metaslang">A</computeroutput> and <computeroutput lang="metaslang">B</computeroutput> be the domain and codomain specs of <computeroutput lang="metaslang">M</computeroutput>.
The substitution operation is possible if and only if <computeroutput lang="metaslang">A</computeroutput> is a
sub-spec of <computeroutput lang="metaslang">S</computeroutput>, in the sense that all the sorts, ops, and axioms of
<computeroutput lang="metaslang">A</computeroutput> are also in <computeroutput lang="metaslang">S</computeroutput>. This is the case when <computeroutput lang="metaslang">S</computeroutput> is constructed by
importing and extending, directly or indirectly, <computeroutput lang="metaslang">A</computeroutput>.</para>

<para>If that condition is satisfied, the result of the substitution
is the spec <computeroutput lang="metaslang">S'</computeroutput> that consists of all the sorts, ops, and axioms of
<computeroutput lang="metaslang">B</computeroutput> plus all the sorts, ops, and axioms of <computeroutput lang="metaslang">S</computeroutput> that are not in
<computeroutput lang="metaslang">A</computeroutput>; the latter must all be translated according to the name mapping
of <computeroutput lang="metaslang">M</computeroutput>.</para>

<para>For example, suppose that:</para>

<orderedlist>

<listitem>
<para><computeroutput lang="metaslang">A</computeroutput> consists of a sort <computeroutput lang="metaslang">X</computeroutput>;</para>
</listitem>

<listitem>
<para><computeroutput lang="metaslang">S</computeroutput> consists of two sorts <computeroutput lang="metaslang">X</computeroutput> and <computeroutput lang="metaslang">Y</computeroutput> and an op <computeroutput lang="metaslang">f</computeroutput>
of type <computeroutput lang="metaslang">X -&gt; Y</computeroutput>;</para>
</listitem>

<listitem>
<para><computeroutput lang="metaslang">B</computeroutput> consists of a sort <computeroutput lang="metaslang">X'</computeroutput> and an op <computeroutput lang="metaslang">c</computeroutput> of type
<computeroutput lang="metaslang">X'</computeroutput>;</para>
</listitem>

<listitem>
<para><computeroutput lang="metaslang">M</computeroutput> maps sort <computeroutput lang="metaslang">X</computeroutput> in <computeroutput lang="metaslang">A</computeroutput> to sort <computeroutput lang="metaslang">X'</computeroutput> in <computeroutput lang="metaslang">B</computeroutput>.</para>
</listitem>

</orderedlist>

<para>The result <computeroutput lang="metaslang">S'</computeroutput> of the substitution consists of sorts <computeroutput lang="metaslang">X'</computeroutput>
and <computeroutput lang="metaslang">Y</computeroutput>, an op <computeroutput lang="metaslang">f</computeroutput> of type <computeroutput lang="metaslang">X' -&gt; Y</computeroutput>, and an op <computeroutput lang="metaslang">c</computeroutput> of type
<computeroutput lang="metaslang">X'</computeroutput>. In other words, <computeroutput lang="metaslang">A</computeroutput> is replaced with <computeroutput lang="metaslang">B</computeroutput> inside <computeroutput lang="metaslang">S</computeroutput> and
the remaining portion of <computeroutput lang="metaslang">S</computeroutput> is renamed accordingly.</para>

<!-- REMOVED BECAUSE SUBSTITUTION IS NOT ALWAYS A PUSHOUT:

<para>In category theory, colimits are defined up to isomorphism in
the sense that, given a diagram of specs and morphisms, there is an
infinite class of specs (all isomorphic to each other) that are all
colimits of the diagram. From a practical point of view, it is
important which spec of the isomorphic class is actually returned.
Substitution yields a pushout which is what users want most of the
time.</para>

-->

</section>  <!-- substitution -->

<section>
<title>Interpretations</title>

<para>A morphism maps a sort or op of the source spec to a sort or op
of the target spec. In certain cases, it may be useful to map the sort
or op to a new sort or op that is not present in the target spec but
that can be defined in terms of those present in the target spec. This
is captured by the concept of interpretation.</para>

<para>An interpretation is a morphism from a spec to a definitional
extension of another spec. A definitional extension is an extension of
a spec that only introduces new sorts and ops with axioms that define
them in terms of those present in the spec that is being
extended.</para>

<para>More precisely, an interpretation contains three specs: a source
spec (the domain), a target spec (the codomain), and a mediator
spec. The mediator is a definitional extension of the target spec, and
there is an inclusion morphism from the target spec to the
mediator. There is a morphism from the source spec to the
mediator.</para>

<para>Consider, as an example, a spec for natural numbers without any
<computeroutput lang="metaslang">plus</computeroutput> op, but just with <computeroutput lang="metaslang">zero</computeroutput> and
<computeroutput lang="metaslang">succ</computeroutput>, and with Peano's axioms. Consider the spec
(also used as an example above) consisting of a sort
<computeroutput lang="metaslang">X</computeroutput>, and op <computeroutput lang="metaslang">f</computeroutput>, and a commutativity
axiom about <computeroutput lang="metaslang">f</computeroutput>. There is no morphism from the latter
spec to the one for natural numbers. But there is an interpretation,
where the mediator extends the spec for natural numbers with an op
<computeroutput lang="metaslang">plus</computeroutput> for addition, which can be inductively defined
by the following two axioms:</para>
<programlisting lang="metaslang">
    fa(x) plus(x,zero) = x
    fa(x,y) plus(x,succ y) = succ(plus(x,y))
</programlisting>

<para>A morphism can be viewed as a particular case of an
interpretation, where the mediator is the same spec as the target, and
the inclusion morphism from the target to the mediator is the identity
morphism.</para>

<para>Diagrams of specs and morphisms can be generalized to diagrams
of specs and interpretations: nodes are labeled by specs and edges by
interpretations.  The colimit operation works on these diagrams as
well. The sorts and ops in the resulting spec include not only those
from the specs labeling the nodes, but also those from the mediators
of the interpretations.</para>

</section>

</section>  <!-- components -->

</chapter>
